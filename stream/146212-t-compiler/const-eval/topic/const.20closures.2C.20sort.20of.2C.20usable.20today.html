<html>
<head><meta charset="utf-8"><title>const closures, sort of, usable today · t-compiler/const-eval · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/index.html">t-compiler/const-eval</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/const.20closures.2C.20sort.20of.2C.20usable.20today.html">const closures, sort of, usable today</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="251032372"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/const%20closures%2C%20sort%20of%2C%20usable%20today/near/251032372" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> fee1-dead <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/const.20closures.2C.20sort.20of.2C.20usable.20today.html#251032372">(Aug 28 2021 at 06:06)</a>:</h4>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="cp">#![feature(fn_traits)]</span><span class="w"></span>
<span class="cp">#![feature(unboxed_closures)]</span><span class="w"></span>
<span class="cp">#![feature(const_fn_trait_bound)]</span><span class="w"></span>
<span class="cp">#![feature(const_trait_impl)]</span><span class="w"></span>

<span class="k">const</span><span class="w"> </span><span class="k">fn</span> <span class="nf">have_fn</span><span class="o">&lt;</span><span class="n">F</span>: <span class="o">~</span><span class="k">const</span><span class="w"> </span><span class="nb">FnOnce</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="kt">u8</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u8</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">f</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">MyTy</span><span class="p">;</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="nb">FnOnce</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">MyTy</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u8</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">extern</span><span class="w"> </span><span class="s">"rust-call"</span><span class="w"> </span><span class="k">fn</span> <span class="nf">call_once</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">_</span>: <span class="p">())</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Output</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">42</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">const</span><span class="w"> </span><span class="n">ANS</span>: <span class="kt">u8</span> <span class="o">=</span><span class="w"> </span><span class="n">have_fn</span><span class="p">(</span><span class="n">MyTy</span><span class="p">);</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">ANS</span><span class="p">,</span><span class="w"> </span><span class="mi">42</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>This might be surprising, but it is already possible to accept closures in const fns and create closures with a simply const <code>impl</code> of <code>Fn</code> family traits.</p>
<p>This would allow a macro like this to define a const closure:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="fm">macro_rules!</span><span class="w"> </span><span class="n">const_closure</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="n">check_fn_type</span><span class="w"> </span><span class="nb">FnOnce</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="n">check_fn_type</span><span class="w"> </span><span class="nb">Fn</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="n">check_fn_type</span><span class="w"> </span><span class="nb">FnMut</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="n">check_fn_type</span><span class="cp">$($tt</span>:<span class="nc">tt</span><span class="p">)</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="fm">compile_error!</span><span class="p">(</span><span class="s">"Invalid Fn type"</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="cp">$FnType</span>:<span class="nc">ident</span><span class="p">(</span><span class="cp">$($ArgTypes</span>:<span class="nc">ty</span><span class="p">),</span><span class="o">*</span><span class="cp">$(,</span><span class="p">)</span><span class="o">?</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="cp">$($id</span>:<span class="nc">ident</span><span class="w"> </span>: <span class="cp">$ty</span>:<span class="nc">ty</span><span class="p">),</span><span class="o">*</span><span class="cp">$(,</span><span class="p">)</span><span class="o">?|</span><span class="w"> </span><span class="cp">$exp</span>:<span class="nc">expr</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">const_closure</span><span class="o">!</span><span class="p">(</span><span class="cp">$FnType</span><span class="p">(</span><span class="cp">$($ArgTypes</span><span class="p">),</span><span class="o">*</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="p">()</span><span class="w"> </span><span class="o">|</span><span class="cp">$($id</span>: <span class="cp">$ty</span><span class="p">),</span><span class="o">*|</span><span class="w"> </span><span class="cp">$exp</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="cp">$FnType</span>:<span class="nc">ident</span><span class="p">(</span><span class="cp">$($ArgTypes</span>:<span class="nc">ty</span><span class="p">),</span><span class="o">*</span><span class="cp">$(,</span><span class="p">)</span><span class="o">?</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="cp">$RetTy</span>:<span class="nc">ty</span><span class="w"> </span><span class="o">|</span><span class="cp">$($id</span>:<span class="nc">ident</span><span class="p">),</span><span class="o">*</span><span class="cp">$(,</span><span class="p">)</span><span class="o">?|</span><span class="w"> </span><span class="cp">$exp</span>:<span class="nc">expr</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{{</span><span class="w"></span>
<span class="w">        </span><span class="n">const_closure</span><span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">check_fn_type</span><span class="w"> </span><span class="cp">$FnType</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="k">fn</span> <span class="nf">generated_closure_fn</span><span class="p">(</span><span class="cp">$($id</span>: <span class="cp">$ArgTypes</span><span class="p">),</span><span class="o">*</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="cp">$RetTy</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="cp">$exp</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="cp">#[derive(Copy, Clone)]</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span> <span class="nc">__GeneratedClosureType</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="k">impl</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="cp">$FnType</span><span class="o">&lt;</span><span class="p">(</span><span class="cp">$($ArgTypes</span><span class="p">),</span><span class="o">*</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">__GeneratedClosureType</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="cp">$RetTy</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">extern</span><span class="w"> </span><span class="s">"rust-call"</span><span class="w"> </span><span class="k">fn</span> <span class="nf">call_once</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="cp">$($id</span><span class="p">),</span><span class="o">*</span><span class="p">)</span>: <span class="p">(</span><span class="cp">$($ArgTypes</span><span class="p">),</span><span class="o">*</span><span class="p">))</span><span class="w"> </span>-&gt; <span class="cp">$RetTy</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">generated_closure_fn</span><span class="p">(</span><span class="cp">$($id</span><span class="p">),</span><span class="o">*</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="n">__GeneratedClosureType</span><span class="w"></span>
<span class="w">    </span><span class="p">}}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Example use case</span>
<span class="k">const</span><span class="w"> </span><span class="k">fn</span> <span class="nf">pass_two_constants</span><span class="o">&lt;</span><span class="n">F</span>: <span class="o">~</span><span class="k">const</span><span class="w"> </span><span class="nb">FnOnce</span><span class="p">(</span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u8</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u8</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">f</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">const</span><span class="w"> </span><span class="n">ANS2</span>: <span class="kt">u8</span> <span class="o">=</span><span class="w"> </span><span class="n">pass_two_constants</span><span class="p">(</span><span class="n">const_closure</span><span class="o">!</span><span class="p">(</span><span class="nb">FnOnce</span><span class="p">(</span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u8</span> <span class="o">|</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">y</span><span class="p">));</span><span class="w"></span>
</code></pre></div>
<p><a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=e75a4c029eb1b5be93e730504c22a453">try it on playground!</a></p>
<p>What's next? This would allow us to mark some of the functions on the <code>Iterator</code> trait as <code>default_method_body_is_const</code>, such as <code>Iterator::count</code>, which is currently implemented like this:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span>
    <span class="nc">where</span><span class="w"></span>
<span class="w">        </span><span class="bp">Self</span>: <span class="nb">Sized</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">fold</span><span class="p">(</span><span class="w"></span>
<span class="w">            </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="cp">#[rustc_inherit_overflow_checks]</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="o">|</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>Or we can start expanding its usability and allow a <code>const fn</code> pointer to coerce into const <code>Fn</code> impls. (Note that we don't introduce any new syntax here like <code>const fn()</code>)</p>



<a name="251061363"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/const%20closures%2C%20sort%20of%2C%20usable%20today/near/251061363" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/const.20closures.2C.20sort.20of.2C.20usable.20today.html#251061363">(Aug 28 2021 at 14:57)</a>:</h4>
<blockquote>
<p>Or we can start expanding its usability and allow a const fn pointer to coerce into const Fn impls. </p>
</blockquote>
<p>I don't think fn pointers are involved when using a function zst in a generic context.</p>
<p>but it seems reasonable to let const fn items have const Fn impls</p>



<a name="251061599"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/const%20closures%2C%20sort%20of%2C%20usable%20today/near/251061599" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/const.20closures.2C.20sort.20of.2C.20usable.20today.html#251061599">(Aug 28 2021 at 15:01)</a>:</h4>
<p>actual closures can probably make their constness get inferred from the body without any semver hazard. unsure how to implement that tho</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>