<html>
<head><meta charset="utf-8"><title>Why slice::from_raw_parts is not const? · t-compiler/const-eval · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/index.html">t-compiler/const-eval</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/Why.20slice.3A.3Afrom_raw_parts.20is.20not.20const.3F.html">Why slice::from_raw_parts is not const?</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="257928720"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/Why%20slice%3A%3Afrom_raw_parts%20is%20not%20const%3F/near/257928720" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Waffle Lapkin <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/Why.20slice.3A.3Afrom_raw_parts.20is.20not.20const.3F.html#257928720">(Oct 17 2021 at 15:56)</a>:</h4>
<p>It's surprising that <code>slice::from_raw_parts</code> is not <code>const</code> while <code>ptr::from_raw_parts</code> (the more general version) and <code>ptr::slice_from_raw_parts</code> (pointer version) <strong>are</strong> <code>const</code>.</p>
<p>Are there any reasons for that? The tracking issue (<a href="https://github.com/rust-lang/rust/issues/67456">#67456</a>) talks about <code>is_aligned_and_not_null</code> check, but it's debug-only, not used in <code>ptr::from_raw_parts</code> and a similar check was disabled for <code>copy[_nonoverlapping]</code>.</p>



<a name="257930531"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/Why%20slice%3A%3Afrom_raw_parts%20is%20not%20const%3F/near/257930531" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/Why.20slice.3A.3Afrom_raw_parts.20is.20not.20const.3F.html#257930531">(Oct 17 2021 at 16:25)</a>:</h4>
<p>well... now that we have const_eval_select, we can essentially just ask T-lang and T-libs if they are alright with using that to create alignment/null checks only in runtime mode, and skip them in const eval.</p>



<a name="257930539"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/Why%20slice%3A%3Afrom_raw_parts%20is%20not%20const%3F/near/257930539" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/Why.20slice.3A.3Afrom_raw_parts.20is.20not.20const.3F.html#257930539">(Oct 17 2021 at 16:25)</a>:</h4>
<p>then we can re-enable them in copy_nonoverlapping, too</p>



<a name="257930606"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/Why%20slice%3A%3Afrom_raw_parts%20is%20not%20const%3F/near/257930606" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/Why.20slice.3A.3Afrom_raw_parts.20is.20not.20const.3F.html#257930606">(Oct 17 2021 at 16:26)</a>:</h4>
<p>probably worth a separate issue that is labeled for both teams</p>



<a name="257934091"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/Why%20slice%3A%3Afrom_raw_parts%20is%20not%20const%3F/near/257934091" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Waffle Lapkin <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/Why.20slice.3A.3Afrom_raw_parts.20is.20not.20const.3F.html#257934091">(Oct 17 2021 at 17:19)</a>:</h4>
<p>So I can open issues for checks in copy and from raw parts and tag T-lang and T-libs?</p>



<a name="257940180"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/Why%20slice%3A%3Afrom_raw_parts%20is%20not%20const%3F/near/257940180" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/Why.20slice.3A.3Afrom_raw_parts.20is.20not.20const.3F.html#257940180">(Oct 17 2021 at 18:56)</a>:</h4>
<p>yea</p>



<a name="257940802"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/Why%20slice%3A%3Afrom_raw_parts%20is%20not%20const%3F/near/257940802" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Gary Guo <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/Why.20slice.3A.3Afrom_raw_parts.20is.20not.20const.3F.html#257940802">(Oct 17 2021 at 19:06)</a>:</h4>
<p>Couldn't we just make is_aligned_and_not_null const?</p>



<a name="257941570"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/Why%20slice%3A%3Afrom_raw_parts%20is%20not%20const%3F/near/257941570" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Waffle Lapkin <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/Why.20slice.3A.3Afrom_raw_parts.20is.20not.20const.3F.html#257941570">(Oct 17 2021 at 19:18)</a>:</h4>
<p>I think the problem with <code>is_aligned_and_not_null</code> is the ptr-&gt;int cast in it? (that allows checking for the alignment)</p>



<a name="257947246"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/Why%20slice%3A%3Afrom_raw_parts%20is%20not%20const%3F/near/257947246" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/Why.20slice.3A.3Afrom_raw_parts.20is.20not.20const.3F.html#257947246">(Oct 17 2021 at 20:44)</a>:</h4>
<p>Yea, we can't really make that const other than adding more intrinsics or magic that are only somewhat correct. You can never tell if something is aligned to a higher alignment than the one used to allocate it if you are in const eval. Like if you allocate a [42; u8], the address you get is symbolic, and all you know is that it has 1 byte alignment. No matter which element of the array you check, the alignment is never known to be more than 1, as we don't know the "true" base address of the entire array</p>



<a name="257947264"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/Why%20slice%3A%3Afrom_raw_parts%20is%20not%20const%3F/near/257947264" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/Why.20slice.3A.3Afrom_raw_parts.20is.20not.20const.3F.html#257947264">(Oct 17 2021 at 20:44)</a>:</h4>
<p>This is a fundamental limit of const eval.</p>



<a name="257957685"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/Why%20slice%3A%3Afrom_raw_parts%20is%20not%20const%3F/near/257957685" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Gary Guo <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/Why.20slice.3A.3Afrom_raw_parts.20is.20not.20const.3F.html#257957685">(Oct 17 2021 at 23:32)</a>:</h4>
<p>I thought the <code>align</code> field of <code>Allocation</code> is used for misalignment detection</p>



<a name="257957739"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/Why%20slice%3A%3Afrom_raw_parts%20is%20not%20const%3F/near/257957739" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Gary Guo <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/Why.20slice.3A.3Afrom_raw_parts.20is.20not.20const.3F.html#257957739">(Oct 17 2021 at 23:33)</a>:</h4>
<p>(I tried to create an unaligned read and it's not detected though)</p>



<a name="257994183"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/Why%20slice%3A%3Afrom_raw_parts%20is%20not%20const%3F/near/257994183" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/Why.20slice.3A.3Afrom_raw_parts.20is.20not.20const.3F.html#257994183">(Oct 18 2021 at 08:33)</a>:</h4>
<p>In miri, yea, but const eval doesn't care mostly. The thing is, that alignment is the alignment of the first byte of the alloc. So if that alignment is 1 that does not mean if you take the second byte's address you get an alignment of 2, unlike at runtime</p>



<a name="258019330"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/Why%20slice%3A%3Afrom_raw_parts%20is%20not%20const%3F/near/258019330" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Waffle Lapkin <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/Why.20slice.3A.3Afrom_raw_parts.20is.20not.20const.3F.html#258019330">(Oct 18 2021 at 12:20)</a>:</h4>
<p>I've opened <a href="https://github.com/rust-lang/rust/issues/90011">#90011</a> (<code>slice::from_raw_parts[_mut]</code>) and <a href="https://github.com/rust-lang/rust/issues/90012">#90012</a> (<code>copy[_nonoverlapping]</code>). Hopefully I didn't mess anything up <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span></p>



<a name="258096271"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/Why%20slice%3A%3Afrom_raw_parts%20is%20not%20const%3F/near/258096271" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Gary Guo <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/Why.20slice.3A.3Afrom_raw_parts.20is.20not.20const.3F.html#258096271">(Oct 18 2021 at 20:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="124288">oli</span> <a href="#narrow/stream/146212-t-compiler.2Fconst-eval/topic/Why.20slice.3A.3Afrom_raw_parts.20is.20not.20const.3F/near/257994183">said</a>:</p>
<blockquote>
<p>In miri, yea, but const eval doesn't care mostly. The thing is, that alignment is the alignment of the first byte of the alloc. So if that alignment is 1 that does not mean if you take the second byte's address you get an alignment of 2, unlike at runtime</p>
</blockquote>
<p>I think we can just record the known alignment and reject anything that is not sufficiently aligned. I don't think we need to know the actual alignment.</p>



<a name="258096507"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/Why%20slice%3A%3Afrom_raw_parts%20is%20not%20const%3F/near/258096507" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Gary Guo <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/Why.20slice.3A.3Afrom_raw_parts.20is.20not.20const.3F.html#258096507">(Oct 18 2021 at 20:41)</a>:</h4>
<p>E.g. given an allocation <code>alloc1</code> with alignment 1, fail the alignment check for all of <code>alloc1 + N</code> with any N if a slice of alignment &gt; 1 is created.</p>



<a name="258096578"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/Why%20slice%3A%3Afrom_raw_parts%20is%20not%20const%3F/near/258096578" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Gary Guo <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/Why.20slice.3A.3Afrom_raw_parts.20is.20not.20const.3F.html#258096578">(Oct 18 2021 at 20:41)</a>:</h4>
<p>This should be fine since const eval code cannot convert ptr to int so it has no way to know the actual alignment.</p>



<a name="258102032"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/Why%20slice%3A%3Afrom_raw_parts%20is%20not%20const%3F/near/258102032" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/Why.20slice.3A.3Afrom_raw_parts.20is.20not.20const.3F.html#258102032">(Oct 18 2021 at 21:18)</a>:</h4>
<p>Sure we can do that, but that requires a new intrinsic or lang item for a debug assertion that is never executed outside a custom built libstd. I don't think it's worth the effort, especially as we rarely check alignment in CTFE, so why go the extra mile here ?</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>