<html>
<head><meta charset="utf-8"><title>equation solving in const generics (say no to SFINAE try 2) · t-compiler/const-eval · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/index.html">t-compiler/const-eval</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/equation.20solving.20in.20const.20generics.20(say.20no.20to.20SFINAE.20try.202).html">equation solving in const generics (say no to SFINAE try 2)</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="276320077"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/equation%20solving%20in%20const%20generics%20%28say%20no%20to%20SFINAE%20try%202%29/near/276320077" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/equation.20solving.20in.20const.20generics.20(say.20no.20to.20SFINAE.20try.202).html#276320077">(Mar 23 2022 at 11:34)</a>:</h4>
<p>If we have two impls that we want to check for overlap, like <code>impl&lt;const N: usize&gt; Default for [T; N + 1]</code> and one for <code>impl Default for [T; 0]</code>, what we actually want to prove is <code>0 != N + 1</code></p>
<p>Similarly if we have <code>impl&lt;const N: u32&gt; Trait&lt;Some(N)&gt; for Struct</code> and <code>impl Trait&lt;None&gt; for Struct</code>, we want to prove <code>None != Some(N)</code></p>
<p>Can we explore the space of designs that don't evaluate but equate expressions? Or are there obvious examples that make this unfeasible? I mean, the moment you stop having expressions and go into statements it's game over of course, but are these cases interesting?</p>



<a name="276320281"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/equation%20solving%20in%20const%20generics%20%28say%20no%20to%20SFINAE%20try%202%29/near/276320281" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> lcnr <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/equation.20solving.20in.20const.20generics.20(say.20no.20to.20SFINAE.20try.202).html#276320281">(Mar 23 2022 at 11:36)</a>:</h4>
<p>so for unification, even with concrete values, we start by staying fully syntactic?</p>



<a name="276320376"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/equation%20solving%20in%20const%20generics%20%28say%20no%20to%20SFINAE%20try%202%29/near/276320376" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> lcnr <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/equation.20solving.20in.20const.20generics.20(say.20no.20to.20SFINAE.20try.202).html#276320376">(Mar 23 2022 at 11:37)</a>:</h4>
<p>and a bunch of rules for both "does unify" + "does not unify"</p>



<a name="276320389"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/equation%20solving%20in%20const%20generics%20%28say%20no%20to%20SFINAE%20try%202%29/near/276320389" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/equation.20solving.20in.20const.20generics.20(say.20no.20to.20SFINAE.20try.202).html#276320389">(Mar 23 2022 at 11:37)</a>:</h4>
<p>Well, proving <code>5 != 4</code> is trivial, but yea, not sure what to do about <code>5 != 3 + 1</code></p>



<a name="276320452"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/equation%20solving%20in%20const%20generics%20%28say%20no%20to%20SFINAE%20try%202%29/near/276320452" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> lcnr <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/equation.20solving.20in.20const.20generics.20(say.20no.20to.20SFINAE.20try.202).html#276320452">(Mar 23 2022 at 11:38)</a>:</h4>
<blockquote>
<p>Can we explore the space of designs that don't evaluate but equate expressions?</p>
</blockquote>
<p>we can</p>



<a name="276320472"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/equation%20solving%20in%20const%20generics%20%28say%20no%20to%20SFINAE%20try%202%29/near/276320472" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> lcnr <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/equation.20solving.20in.20const.20generics.20(say.20no.20to.20SFINAE.20try.202).html#276320472">(Mar 23 2022 at 11:38)</a>:</h4>
<p>I am getting closer and closer to make my own a-mir-formality</p>



<a name="276320522"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/equation%20solving%20in%20const%20generics%20%28say%20no%20to%20SFINAE%20try%202%29/near/276320522" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> lcnr <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/equation.20solving.20in.20const.20generics.20(say.20no.20to.20SFINAE.20try.202).html#276320522">(Mar 23 2022 at 11:38)</a>:</h4>
<p>but actually as a separate prog lang so i can also experiment with polymorphization</p>



<a name="276320529"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/equation%20solving%20in%20const%20generics%20%28say%20no%20to%20SFINAE%20try%202%29/near/276320529" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> lcnr <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/equation.20solving.20in.20const.20generics.20(say.20no.20to.20SFINAE.20try.202).html#276320529">(Mar 23 2022 at 11:38)</a>:</h4>
<p>without having to deal with rustc being horrible</p>



<a name="276320576"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/equation%20solving%20in%20const%20generics%20%28say%20no%20to%20SFINAE%20try%202%29/near/276320576" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> lcnr <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/equation.20solving.20in.20const.20generics.20(say.20no.20to.20SFINAE.20try.202).html#276320576">(Mar 23 2022 at 11:39)</a>:</h4>
<p>or well, I can probably just go ahead and do that as part of a-mir-formality</p>



<a name="276320608"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/equation%20solving%20in%20const%20generics%20%28say%20no%20to%20SFINAE%20try%202%29/near/276320608" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> lcnr <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/equation.20solving.20in.20const.20generics.20(say.20no.20to.20SFINAE.20try.202).html#276320608">(Mar 23 2022 at 11:39)</a>:</h4>
<p>which would be a good introduction to it for me</p>



<a name="276320652"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/equation%20solving%20in%20const%20generics%20%28say%20no%20to%20SFINAE%20try%202%29/near/276320652" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> lcnr <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/equation.20solving.20in.20const.20generics.20(say.20no.20to.20SFINAE.20try.202).html#276320652">(Mar 23 2022 at 11:40)</a>:</h4>
<p>but idk if that's something we should add already, as it will be pretty damn experimental</p>



<a name="276320879"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/equation%20solving%20in%20const%20generics%20%28say%20no%20to%20SFINAE%20try%202%29/near/276320879" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/equation.20solving.20in.20const.20generics.20(say.20no.20to.20SFINAE.20try.202).html#276320879">(Mar 23 2022 at 11:41)</a>:</h4>
<blockquote>
<p>and a bunch of rules for both "does unify" + "does not unify"</p>
</blockquote>
<p>Yea, I was considering just implementing a bunch of rules first and only allowing them. Staying forward compatible with more powerful designs</p>



<a name="276321007"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/equation%20solving%20in%20const%20generics%20%28say%20no%20to%20SFINAE%20try%202%29/near/276321007" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/equation.20solving.20in.20const.20generics.20(say.20no.20to.20SFINAE.20try.202).html#276321007">(Mar 23 2022 at 11:42)</a>:</h4>
<blockquote>
<p>I am getting closer and closer to make my own a-mir-formality</p>
</blockquote>
<p>I was considering a librarification of AbstractConst and adding the equating algorithms there</p>



<a name="276321061"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/equation%20solving%20in%20const%20generics%20%28say%20no%20to%20SFINAE%20try%202%29/near/276321061" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> lcnr <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/equation.20solving.20in.20const.20generics.20(say.20no.20to.20SFINAE.20try.202).html#276321061">(Mar 23 2022 at 11:43)</a>:</h4>
<p><span class="user-mention silent" data-user-id="216206">lcnr</span> <a href="#narrow/stream/146212-t-compiler.2Fconst-eval/topic/equation.20solving.20in.20const.20generics.20.28say.20no.20to.20SFINAE.20try.202.29/near/276320576">said</a>:</p>
<blockquote>
<p>or well, I can probably just go ahead and do that as part of a-mir-formality</p>
</blockquote>
<p>cc <span class="user-mention" data-user-id="116009">@nikomatsakis</span> your take on adding cg support to a-mir-formality this early</p>



<a name="276321077"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/equation%20solving%20in%20const%20generics%20%28say%20no%20to%20SFINAE%20try%202%29/near/276321077" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> lcnr <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/equation.20solving.20in.20const.20generics.20(say.20no.20to.20SFINAE.20try.202).html#276321077">(Mar 23 2022 at 11:43)</a>:</h4>
<p>or well, an idealized cg version</p>



<a name="276321485"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/equation%20solving%20in%20const%20generics%20%28say%20no%20to%20SFINAE%20try%202%29/near/276321485" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> lcnr <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/equation.20solving.20in.20const.20generics.20(say.20no.20to.20SFINAE.20try.202).html#276321485">(Mar 23 2022 at 11:47)</a>:</h4>
<blockquote>
<p>librarification of AbstractConst</p>
</blockquote>
<p>that's actually fairly straightforward I think?</p>



<a name="276321496"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/equation%20solving%20in%20const%20generics%20%28say%20no%20to%20SFINAE%20try%202%29/near/276321496" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> lcnr <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/equation.20solving.20in.20const.20generics.20(say.20no.20to.20SFINAE.20try.202).html#276321496">(Mar 23 2022 at 11:47)</a>:</h4>
<p>like, doable in a few hours</p>



<a name="276328963"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/equation%20solving%20in%20const%20generics%20%28say%20no%20to%20SFINAE%20try%202%29/near/276328963" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/equation.20solving.20in.20const.20generics.20(say.20no.20to.20SFINAE.20try.202).html#276328963">(Mar 23 2022 at 13:00)</a>:</h4>
<p>Yes</p>



<a name="276329125"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/equation%20solving%20in%20const%20generics%20%28say%20no%20to%20SFINAE%20try%202%29/near/276329125" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/equation.20solving.20in.20const.20generics.20(say.20no.20to.20SFINAE.20try.202).html#276329125">(Mar 23 2022 at 13:01)</a>:</h4>
<p>Likely a few days total work time but the initial PR should be simple enough</p>



<a name="276330164"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/equation%20solving%20in%20const%20generics%20%28say%20no%20to%20SFINAE%20try%202%29/near/276330164" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> lcnr <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/equation.20solving.20in.20const.20generics.20(say.20no.20to.20SFINAE.20try.202).html#276330164">(Mar 23 2022 at 13:10)</a>:</h4>
<blockquote>
<p>Can we explore the space of designs that don't evaluate but equate expressions?</p>
</blockquote>
<p>how does that work when unifying <code>generic_fn::&lt;N&gt;() + 3</code> with let's say <code>7</code></p>



<a name="276330176"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/equation%20solving%20in%20const%20generics%20%28say%20no%20to%20SFINAE%20try%202%29/near/276330176" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> lcnr <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/equation.20solving.20in.20const.20generics.20(say.20no.20to.20SFINAE.20try.202).html#276330176">(Mar 23 2022 at 13:10)</a>:</h4>
<p>once <code>N</code> is concrete?</p>



<a name="276364138"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/equation%20solving%20in%20const%20generics%20%28say%20no%20to%20SFINAE%20try%202%29/near/276364138" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nikomatsakis <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/equation.20solving.20in.20const.20generics.20(say.20no.20to.20SFINAE.20try.202).html#276364138">(Mar 23 2022 at 16:45)</a>:</h4>
<p><span class="user-mention" data-user-id="216206">@lcnr</span> my take is that I would love to do that</p>



<a name="276364146"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/equation%20solving%20in%20const%20generics%20%28say%20no%20to%20SFINAE%20try%202%29/near/276364146" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nikomatsakis <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/equation.20solving.20in.20const.20generics.20(say.20no.20to.20SFINAE.20try.202).html#276364146">(Mar 23 2022 at 16:45)</a>:</h4>
<p>(adding CG)</p>



<a name="276364179"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/equation%20solving%20in%20const%20generics%20%28say%20no%20to%20SFINAE%20try%202%29/near/276364179" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nikomatsakis <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/equation.20solving.20in.20const.20generics.20(say.20no.20to.20SFINAE.20try.202).html#276364179">(Mar 23 2022 at 16:46)</a>:</h4>
<p>it's kind of exactly what I feel I need to be able to explain how it fits into things in the "big picture"</p>



<a name="276449253"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/equation%20solving%20in%20const%20generics%20%28say%20no%20to%20SFINAE%20try%202%29/near/276449253" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/equation.20solving.20in.20const.20generics.20(say.20no.20to.20SFINAE.20try.202).html#276449253">(Mar 24 2022 at 09:24)</a>:</h4>
<p><span class="user-mention silent" data-user-id="124288">oli</span> <a href="#narrow/stream/146212-t-compiler.2Fconst-eval/topic/equation.20solving.20in.20const.20generics.20.28say.20no.20to.20SFINAE.20try.202.29/near/276320077">said</a>:</p>
<blockquote>
<p>If we have two impls that we want to check for overlap, like <code>impl&lt;const N: usize&gt; Default for [T; N + 1]</code> and one for <code>impl Default for [T; 0]</code>, what we actually want to prove is <code>0 != N + 1</code></p>
</blockquote>
<p>I've been wondering about this for a while. I think this is definitely intuitively the right way to write such patterns, but it hits a semantic issue in that <code>usize</code> is not "peano natural numbers", <code>0 != N + 1</code> does not (necessarily) hold since <code>usize::MAX + 1 = 0</code> on release</p>



<a name="276449610"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/equation%20solving%20in%20const%20generics%20%28say%20no%20to%20SFINAE%20try%202%29/near/276449610" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/equation.20solving.20in.20const.20generics.20(say.20no.20to.20SFINAE.20try.202).html#276449610">(Mar 24 2022 at 09:28)</a>:</h4>
<p>perhaps a more sensible model is something like a const <code>match</code> expression, although this gets syntactically weird. Something like:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">impl</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">N</span>: <span class="kt">usize</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Default</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">[</span><span class="n">T</span><span class="p">;</span><span class="w"> </span><span class="n">N</span><span class="p">]</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">N</span><span class="p">.</span><span class="n">checked_sub</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">fn</span> <span class="nf">default</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">..</span><span class="p">.</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="n">M</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">fn</span> <span class="nf">default</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">..</span><span class="p">.</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>



<a name="276451753"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/equation%20solving%20in%20const%20generics%20%28say%20no%20to%20SFINAE%20try%202%29/near/276451753" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/equation.20solving.20in.20const.20generics.20(say.20no.20to.20SFINAE.20try.202).html#276451753">(Mar 24 2022 at 09:50)</a>:</h4>
<blockquote>
<p>I've been wondering about this for a while. I think this is definitely intuitively the right way to write such patterns, but it hits a semantic issue in that <code>usize</code> is not "peano natural numbers", <code>0 != N + 1</code> does not (necessarily) hold since <code>usize::MAX + 1 = 0</code> on release</p>
</blockquote>
<p>const items always have overflow checks on, sadly const fn do not. I wonder if we could fix that</p>



<a name="276456277"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/equation%20solving%20in%20const%20generics%20%28say%20no%20to%20SFINAE%20try%202%29/near/276456277" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> lcnr <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/equation.20solving.20in.20const.20generics.20(say.20no.20to.20SFINAE.20try.202).html#276456277">(Mar 24 2022 at 10:32)</a>:</h4>
<blockquote>
<p>sadly const fn do not.</p>
</blockquote>
<p>not even during ctfe? don't we have different mir for ctfe</p>



<a name="276456302"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/equation%20solving%20in%20const%20generics%20%28say%20no%20to%20SFINAE%20try%202%29/near/276456302" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> lcnr <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/equation.20solving.20in.20const.20generics.20(say.20no.20to.20SFINAE.20try.202).html#276456302">(Mar 24 2022 at 10:32)</a>:</h4>
<p>we could at least reasonable keep the overflow checks until the <code>mir_for_ctfe</code></p>



<a name="276456308"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/equation%20solving%20in%20const%20generics%20%28say%20no%20to%20SFINAE%20try%202%29/near/276456308" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> lcnr <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/equation.20solving.20in.20const.20generics.20(say.20no.20to.20SFINAE.20try.202).html#276456308">(Mar 24 2022 at 10:32)</a>:</h4>
<p>and only remove them later during optimizations</p>



<a name="276456457"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/equation%20solving%20in%20const%20generics%20%28say%20no%20to%20SFINAE%20try%202%29/near/276456457" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Olivier FAURE <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/equation.20solving.20in.20const.20generics.20(say.20no.20to.20SFINAE.20try.202).html#276456457">(Mar 24 2022 at 10:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="271719">Mario Carneiro</span> <a href="#narrow/stream/146212-t-compiler.2Fconst-eval/topic/equation.20solving.20in.20const.20generics.20.28say.20no.20to.20SFINAE.20try.202.29/near/276449610">said</a>:</p>
<blockquote>
<p>perhaps a more sensible model is something like a const <code>match</code> expression, although this gets syntactically weird.</p>
</blockquote>
<p>Maybe this:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">impl</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">N</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Default</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">[</span><span class="n">T</span><span class="p">;</span><span class="w"> </span><span class="n">N</span><span class="p">]</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">N</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Default</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">[</span><span class="n">T</span><span class="p">;</span><span class="w"> </span><span class="n">N</span><span class="p">]</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">T</span>: <span class="nb">Default</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>



<a name="276465223"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/equation%20solving%20in%20const%20generics%20%28say%20no%20to%20SFINAE%20try%202%29/near/276465223" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/equation.20solving.20in.20const.20generics.20(say.20no.20to.20SFINAE.20try.202).html#276465223">(Mar 24 2022 at 12:04)</a>:</h4>
<p>Carving out the subset of interest is only half of the problem though. You can make subsets using where clauses, but then you want to know that in that subset certain operations are valid and live in other subsets. (This is getting <em>really</em> close to dependent types.) If you have <code>N in 1..</code> then this should imply that <code>N - 1</code> is a valid expression without having to bubble up some constraint to the caller. This is problematic in general for the same reason that it is hard to statically check that <code>if foo.is_some() { foo.unwrap() } else { 0 }</code> doesn't panic. Using <code>checked_sub(1)</code> and a match ties the two aspects together so that the compiler doesn't need to do linear algebra to compile the code</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>