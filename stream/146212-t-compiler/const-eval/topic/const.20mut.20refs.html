<html>
<head><meta charset="utf-8"><title>const mut refs · t-compiler/const-eval · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/index.html">t-compiler/const-eval</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/const.20mut.20refs.html">const mut refs</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="261603271"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/const%20mut%20refs/near/261603271" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jacob Pratt <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/const.20mut.20refs.html#261603271">(Nov 16 2021 at 06:42)</a>:</h4>
<p>Is there any technical reason we should not go ahead with stabilizing const mut refs (<a href="https://github.com/rust-lang/rust/issues/57349">#57349</a>)? The most recent status update is <a href="https://github.com/rust-lang/rust/issues/57349#issuecomment-881432337">here</a>. It seems like we should have no issue stabilizing it in <code>const fn</code> (but not <code>static</code>/<code>const</code> for reasons stated). This is exactly what was proposed <a href="https://github.com/rust-lang/rust/issues/57349#issuecomment-666348647">last July</a>, with the requested checks apparently being implemented in the meantime.</p>



<a name="261636640"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/const%20mut%20refs/near/261636640" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/const.20mut.20refs.html#261636640">(Nov 16 2021 at 13:01)</a>:</h4>
<p>well... we are very hesitant to add more const/constfn differences, so preferrably we'd fix the static/const situation and then just stabilize it everywhere</p>



<a name="261667865"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/const%20mut%20refs/near/261667865" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jacob Pratt <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/const.20mut.20refs.html#261667865">(Nov 16 2021 at 16:30)</a>:</h4>
<p>Any idea how difficult that might be?</p>



<a name="261668468"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/const%20mut%20refs/near/261668468" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Gary Guo <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/const.20mut.20refs.html#261668468">(Nov 16 2021 at 16:35)</a>:</h4>
<p>What's the issue of having it in <code>static/const</code>? The example given in the comments</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">FOO</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="nb">static</span> <span class="nc">mut</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span><span class="w"></span>
</code></pre></div>
<p>doesn't compile today (gives E0764, mutable references are not allowed in the final value of statics)</p>



<a name="261731890"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/const%20mut%20refs/near/261731890" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jacob Pratt <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/const.20mut.20refs.html#261731890">(Nov 17 2021 at 01:09)</a>:</h4>
<p>From the <a href="https://doc.rust-lang.org/error-index.html#E0764">error index</a>:</p>
<blockquote>
<p>While there could be a more fine-grained scheme in the future that allows mutable references if they are not “leaked” to the final value, a more conservative approach was chosen for now. <code>const fn</code> do not have this problem, as the borrow checker will prevent the <code>const fn</code> from returning new mutable references.</p>
</blockquote>
<p>It's more that we <em>could</em> permit more in the future. Personally I don't think it should be a blocker due to the amount this would permit, but that's up for debate.</p>



<a name="261805862"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/const%20mut%20refs/near/261805862" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/const.20mut.20refs.html#261805862">(Nov 17 2021 at 16:06)</a>:</h4>
<p>Yeah, as a user I don't mind const/const_fn differences if it means that my const fn can do <em>more</em> than a basic const block.</p>
<p>If it's expected to take more than another release or two for the non-fn situation to be fixed, and the fn situation is ready now, please just stabilize for const fn only.</p>



<a name="261831298"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/const%20mut%20refs/near/261831298" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dylan MacKenzie (ecstatic-morse) <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/const.20mut.20refs.html#261831298">(Nov 17 2021 at 18:56)</a>:</h4>
<p>What would allowing mutable references in <code>const fn</code> mean for heap-allocation? With heap-allocation, you would be able to return a legal reference from a <code>const fn</code> that allows mutation, which breaks the assumption I used to justify its legality.</p>
<p>I'm also a little worried about the correctness of existing code when mutable references are allowed. <span class="user-mention silent" data-user-id="352985">tm</span> just found a silly bug in const qualification with <code>&amp;mut</code> (my fault). We've also allowed more raw pointer stuff since I went dormant. Are the existing justifications still valid once we have to consider raw pointers?</p>



<a name="261836001"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/const%20mut%20refs/near/261836001" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/const.20mut.20refs.html#261836001">(Nov 17 2021 at 19:34)</a>:</h4>
<p>Is your concern that you'd allocate on the const heap and then leak that into a static mutable reference which returns out of the function?</p>



<a name="261837083"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/const%20mut%20refs/near/261837083" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dylan MacKenzie (ecstatic-morse) <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/const.20mut.20refs.html#261837083">(Nov 17 2021 at 19:42)</a>:</h4>
<p>That's the first-order problem, yes. What if you cast that mutable reference to a <code>usize</code> or a raw pointer, then cast it back in a const initializer or another <code>const fn</code> or during runtime after accessing the final value of the <code>const</code>?</p>



<a name="261838701"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/const%20mut%20refs/near/261838701" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/const.20mut.20refs.html#261838701">(Nov 17 2021 at 19:52)</a>:</h4>
<p>well ptr to usize is currently disallowed, and unlikely to ever be allowed</p>



<a name="261838967"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/const%20mut%20refs/near/261838967" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/const.20mut.20refs.html#261838967">(Nov 17 2021 at 19:54)</a>:</h4>
<p>However, to side step too many more specific cases, I think that what people want to be able to do is just have functions that take mutable references (particularly &amp;mut self) and use them, possibly returning a mutable reference based on an input (eg: subslice).</p>



<a name="261839113"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/const%20mut%20refs/near/261839113" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/const.20mut.20refs.html#261839113">(Nov 17 2021 at 19:55)</a>:</h4>
<p>so even if the limit was that you can't fabricate a lifetime for a mutable reference return value, people would be quite happy to have &amp;mut self support in const fn for example.</p>



<a name="261842024"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/const%20mut%20refs/near/261842024" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dylan MacKenzie (ecstatic-morse) <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/const.20mut.20refs.html#261842024">(Nov 17 2021 at 20:14)</a>:</h4>
<p>Yes, I agree that the status quo sucks. That was what motivated the initial suggestion to allow them in <code>const fn</code> and rely on the borrow checker to prevent them from escaping into the final value of a <code>const</code>. I just don't want us to commit to a relaxed system without considering how it might constrain heap allocations in constants down the line.</p>



<a name="262627578"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/const%20mut%20refs/near/262627578" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dylan MacKenzie (ecstatic-morse) <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/const.20mut.20refs.html#262627578">(Nov 24 2021 at 18:52)</a>:</h4>
<p>Hey <span class="user-group-mention" data-user-group-id="1916">@WG-const-eval</span>, this came up in the Rust-for-Linux CTCFT again, so I think I owe it to the community to actually try to resolve my concerns instead of just spreading FUD.</p>
<p>The reason that this is a problem in<code>const</code>s is that  the final value of a <code>const</code> is bitwise copied whenever it is accessed, <em>even when its type is not <code>Copy</code></em>. This is what allows <code>Vec::new()</code> to be stored to a  <code>const</code>. This is sound for now because we forbid any operations that would actually cause a problem if their result is copied. However, <code>&amp;mut</code> and owned pointers (e.g. <code>Box</code>) break that assumption. Luckily, we will always have Miri as a backstop, which can detect problematic <code>const</code>s but I think we should fix the underlying issue, or at least try to.</p>
<p>You could add a type-based check that rejects constants whose type contains <code>&amp;mut</code>, but I don't think that it would be sufficient. If we have a type like <code>UniquePtr</code>, we cannot give it a <code>const fn</code> constructor and still assume that it is unique.</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">struct</span> <span class="nc">UniquePtr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Doesn't impl `Copy` or `Clone`.</span>
<span class="w">    </span><span class="n">ptr</span>: <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Needs `PhantomData` for variance too</span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">UniquePtr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">ptr</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="fm">todo!</span><span class="p">()</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="c1">// Any `UniquePtr` in the final value of a const can be copied anyways!</span>
<span class="o">|</span><span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>You can argue that, with only <code>const_mut_refs</code>, it's difficult (maybe impossible) to get a mutable reference to something that lives until the end of a <code>const</code> initializer. However, that will cease to be true once heap allocation is allowed (consider <code>Box::leak</code> for example).</p>



<a name="262630193"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/const%20mut%20refs/near/262630193" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dylan MacKenzie (ecstatic-morse) <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/const.20mut.20refs.html#262630193">(Nov 24 2021 at 19:16)</a>:</h4>
<p>I think I've brought all this up in 2020, and we didn't reach any conclusions. Perhaps the thinking has changed in the meantime? My first thought was to apply the Qualif system (value-based reasoning with a type-based fallback) to things that can be copied (<code>MayCopy</code>?), and to forbid non-Copy values from the final value of constants. I don't particularly like that system, but at least there's a precedent.</p>
<p>This would also be backwards incompatible, though I have some thoughts on what a migration system might look like. You would need to allow annotating some const fn (e.g., <code>Vec::new</code>) with a guarantee that their return value is safe to copy. This is similar to the <code>const(heap)</code> proposals. Unfortunately, extending this to trait methods would require yet another ad-hoc effect-system (on top of <code>const</code> and <code>unsafe</code>). I doubt there's any appetite for this, but maybe the simple system would be enough?</p>



<a name="262637188"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/const%20mut%20refs/near/262637188" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/const.20mut.20refs.html#262637188">(Nov 24 2021 at 20:30)</a>:</h4>
<p>oh no XD I've been avoiding thinking about this. I am not yet done with my type alias impl trait refactor, so this is still low priority rn.</p>



<a name="262637351"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/const%20mut%20refs/near/262637351" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/const.20mut.20refs.html#262637351">(Nov 24 2021 at 20:32)</a>:</h4>
<p>imo we can just ignore heap in any design decisions, as users can always create a struct MutRef(*mut i32) with their own API that behaves like &amp;mut i32 and we won't ever be able to do anything about that beyond detecting it during interning. This is like post monomorphization errors. Let's keep avoiding most, but not go overboard and restrict users to an unusable subset of code</p>



<a name="262638094"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/const%20mut%20refs/near/262638094" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dylan MacKenzie (ecstatic-morse) <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/const.20mut.20refs.html#262638094">(Nov 24 2021 at 20:41)</a>:</h4>
<blockquote>
<p>users can always create a struct MutRef(*mut i32) with their own API that behaves like &amp;mut i32 and we won't ever be able to do anything about that</p>
</blockquote>
<p>My point was that users might reasonably assume that they could wrap a pointer with both a <code>DerefMut</code> impl and a const fn constructor, so long as the wrapper type didn't implement <code>Clone</code> or <code>Copy</code> and its fields were private. However, that's not sound today because we always bitwise copy consts.</p>
<p>I'd like to experiment with value-based reasoning for <code>Copy</code> like I mentioned above. It's possible that the fallout will be too big, in which case I don't know what else to do besides rely on Miri (post-monomorphization) and the lack of heap allocation (since the targets of any mutable references can't outlive the initializer AFAIK)</p>



<a name="262642535"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/const%20mut%20refs/near/262642535" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/const.20mut.20refs.html#262642535">(Nov 24 2021 at 21:31)</a>:</h4>
<p>the issue of a &amp;mut in a const seems separate from &amp;mut in a const fn. If the final value of a const expression comes out to be i32 or whatever, but uses &amp;mut internally, there's no problems there?</p>



<a name="262646964"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/146212-t-compiler/const-eval/topic/const%20mut%20refs/near/262646964" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/146212-t-compiler/const-eval/topic/const.20mut.20refs.html#262646964">(Nov 24 2021 at 22:24)</a>:</h4>
<p>The same is true for const items. If we consider heap things, then const fn have no avantage over const items anymore in terms of borrowck helping us out</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>