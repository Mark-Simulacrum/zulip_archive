<html>
<head><meta charset="utf-8"><title>Rust instrumentation data · t-compiler/performance · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/247081-t-compiler/performance/index.html">t-compiler/performance</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/247081-t-compiler/performance/topic/Rust.20instrumentation.20data.html">Rust instrumentation data</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="278571548"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/247081-t-compiler/performance/topic/Rust%20instrumentation%20data/near/278571548" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jakub Beránek <a href="https://zulip-archive.rust-lang.org/stream/247081-t-compiler/performance/topic/Rust.20instrumentation.20data.html#278571548">(Apr 11 2022 at 15:30)</a>:</h4>
<p>Based on <span class="user-mention" data-user-id="120989">@nnethercote</span> 's suggestions, I have implemented a hacky way of instrumenting <code>stdlib</code> so that we can gather information about various events that might be interesting for optimizing <code>rustc</code> performance.</p>
<p>As a first experiment, I have tried to count cases where a <code>Vec</code> is deallocated when empty (A) and when it is deallocated when empty and also with capacity zero (B). In theory, if we could find a place where many such <code>Vec</code>s are created, and these vecs would be embedded within size-critical structures, we could optimize them with e.g. <code>ThinVec</code>.</p>
<p>It's a bit difficult to make sense of the data though, so I thought that I would also share it if anyone was intereseted in it. The data is <a href="https://github.com/Kobzol/rustc-instrumentation-data">here</a>. Here's how to interpret the data:<br>
1) I sample 1/1000 of all <code>Vec</code> <code>drop</code> calls where the vec was empty (sampling is done otherwise it would be too slow).<br>
2) I get a backtrace, and store the filename, line and symbol name from the backtrace. I only store the first 5 entries in the backtrace (ignoring the first one, since that is the instrumentation function itself). For each such backtrace entry, I accumulate it in a hashmap.<br>
3) At the end of the compilation session, I write the entries and their counts into a file and then merge all files together.<br>
4) The output file then contains the backtrace entries (when did the Vec drop happen), along with a count how often it happened.</p>
<p>This concrete data was gathered by compiling the (final) <code>cargo</code> crate.</p>
<p>If you are interested in other similar "queries" that could be performed, let me know. I can also share my branch. <span class="user-mention" data-user-id="120989">@nnethercote</span> also has a <a href="#narrow/stream/131828-t-compiler/topic/.60Rc.60.20without.20the.20weak.20count.3F/near/278240450">guide</a> for doing this with <code>dhat-rs</code> (it works fine, it just wasn't usable in <code>alloc</code>, so I had to hack something new).</p>



<a name="278573063"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/247081-t-compiler/performance/topic/Rust%20instrumentation%20data/near/278573063" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> rylev <a href="https://zulip-archive.rust-lang.org/stream/247081-t-compiler/performance/topic/Rust.20instrumentation.20data.html#278573063">(Apr 11 2022 at 15:40)</a>:</h4>
<p>Cools stuff! Am I correct in assuming that the second entry can also be discarded since presumably that will be the drop function for Vec?</p>



<a name="278573296"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/247081-t-compiler/performance/topic/Rust%20instrumentation%20data/near/278573296" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> rylev <a href="https://zulip-archive.rust-lang.org/stream/247081-t-compiler/performance/topic/Rust.20instrumentation.20data.html#278573296">(Apr 11 2022 at 15:42)</a>:</h4>
<p>I guess it would be interesting to tell what the top level symbol in a backtrace that's in libcore or libstd. That should give a decent understanding of what the vec is being used for (i.e., is it being used directly or as a part of some higher-level functionality inside of lib{std,core})</p>



<a name="278596122"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/247081-t-compiler/performance/topic/Rust%20instrumentation%20data/near/278596122" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jakub Beránek <a href="https://zulip-archive.rust-lang.org/stream/247081-t-compiler/performance/topic/Rust.20instrumentation.20data.html#278596122">(Apr 11 2022 at 18:22)</a>:</h4>
<p>Yeah the backtrace filtering needs to get better. It's not so simple though, the output from the backtrace crate returns several sub-frames for each frame, since stuff gets inlined a lot, so it's not straightforward to look for the "right place", especially on such scale. I'll try to improve it.</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>