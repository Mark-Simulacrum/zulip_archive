<html>
<head><meta charset="utf-8"><title>Infallible encoding · t-compiler/performance · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/247081-t-compiler/performance/index.html">t-compiler/performance</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/247081-t-compiler/performance/topic/Infallible.20encoding.html">Infallible encoding</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="274612837"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/247081-t-compiler/performance/topic/Infallible%20encoding/near/274612837" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/247081-t-compiler/performance/topic/Infallible.20encoding.html#274612837">(Mar 08 2022 at 21:53)</a>:</h4>
<p><a href="https://github.com/rust-lang/rust/issues/94732">#94732</a> is a draft PR to make "opaque" encoding infallible. This was inspired by <a href="https://github.com/rust-lang/rust/issues/93066">#93066</a>, which did the same for decoding and was a nice performance win. But the perf effect of infallible encoding was underwhelming, some sub-1% instruction count improvements on a range of incremental scenarios. I guess we just do a lot more decoding (for <code>std</code> metatada, mostly) than encoding.</p>



<a name="274613078"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/247081-t-compiler/performance/topic/Infallible%20encoding/near/274613078" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/247081-t-compiler/performance/topic/Infallible.20encoding.html#274613078">(Mar 08 2022 at 21:55)</a>:</h4>
<p>This comment describes how I did the error handling, because I didn't actually make encoding infallible:</p>
<div class="codehilite"><pre><span></span><code>+/// Encoders are often fallible, but in practice failure is rare and there are
+/// so many nested calls that typical Rust error handling (via `Result`) is
+/// annoyingly expensive. Instead, impls of this trait must implement a delayed
+/// error handling strategy. If a failure occurs, they should record this
+/// internally, and all subsequent encoding operations can be processed or
+/// ignored, whichever is appropriate. Then when `finish()` is called, an error
+/// result should be returned to indicate the failure. If no failures occurred,
+/// then `finish()` should return a success result.
</code></pre></div>



<a name="274613199"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/247081-t-compiler/performance/topic/Infallible%20encoding/near/274613199" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/247081-t-compiler/performance/topic/Infallible.20encoding.html#274613199">(Mar 08 2022 at 21:56)</a>:</h4>
<p>The existing encoding code mostly used standard error handling, with <code>Result</code> and <code>?</code>. But a few places just used <code>unwrap</code>. And then one or two other places did some local delayed error handling like I did in the PR. So overall, the PR makes the encoding error handling more uniform, even though it is non-standard.</p>



<a name="274613248"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/247081-t-compiler/performance/topic/Infallible%20encoding/near/274613248" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/247081-t-compiler/performance/topic/Infallible.20encoding.html#274613248">(Mar 08 2022 at 21:56)</a>:</h4>
<p>Now I'm wondering if I should just abandon this, given that the perf effects are so mild.</p>



<a name="274613949"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/247081-t-compiler/performance/topic/Infallible%20encoding/near/274613949" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/247081-t-compiler/performance/topic/Infallible.20encoding.html#274613949">(Mar 08 2022 at 22:01)</a>:</h4>
<p><span class="user-mention" data-user-id="116122">@simulacrum</span> you might have thoughts</p>



<a name="274614258"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/247081-t-compiler/performance/topic/Infallible%20encoding/near/274614258" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> simulacrum <a href="https://zulip-archive.rust-lang.org/stream/247081-t-compiler/performance/topic/Infallible.20encoding.html#274614258">(Mar 08 2022 at 22:04)</a>:</h4>
<p>I agree this doesn't look worthwhile by default, though I wonder if it would have further impact if &amp; when we drop the JSON logic -- I could imagine that LLVM is less able to optimize with it still all interleaved in</p>



<a name="274623592"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/247081-t-compiler/performance/topic/Infallible%20encoding/near/274623592" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/247081-t-compiler/performance/topic/Infallible.20encoding.html#274623592">(Mar 08 2022 at 23:36)</a>:</h4>
<p>@lqd: On a related note, I was reading <a href="https://arxiv.org/abs/1709.08990">this paper</a> and wondering about alternatives to LEB128 encoding. The separation of control bytes and data bytes is cool, but it's very much oriented towards the case where you are encoding a long <code>Vec&lt;u32&gt;</code>. In contrast, we are encoding a heterogenous sequence containing <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>, <code>usize</code>, with <code>u8</code> being easily the most common (for which we don't need to LEB128 encode).</p>



<a name="274623611"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/247081-t-compiler/performance/topic/Infallible%20encoding/near/274623611" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/247081-t-compiler/performance/topic/Infallible.20encoding.html#274623611">(Mar 08 2022 at 23:37)</a>:</h4>
<p>So I am struggling to apply any of the ideas from the paper to our situation.</p>



<a name="274624616"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/247081-t-compiler/performance/topic/Infallible%20encoding/near/274624616" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> simulacrum <a href="https://zulip-archive.rust-lang.org/stream/247081-t-compiler/performance/topic/Infallible.20encoding.html#274624616">(Mar 08 2022 at 23:48)</a>:</h4>
<p>There's a few cases of <code>Vec&lt;u32&gt;</code> in e.g. incremental state encoding/decoding, at least, I think</p>



<a name="274624638"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/247081-t-compiler/performance/topic/Infallible%20encoding/near/274624638" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> simulacrum <a href="https://zulip-archive.rust-lang.org/stream/247081-t-compiler/performance/topic/Infallible.20encoding.html#274624638">(Mar 08 2022 at 23:48)</a>:</h4>
<p>But they're quite hard to pull through our current traits</p>



<a name="274624822"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/247081-t-compiler/performance/topic/Infallible%20encoding/near/274624822" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/247081-t-compiler/performance/topic/Infallible.20encoding.html#274624822">(Mar 08 2022 at 23:51)</a>:</h4>
<p><span class="user-mention" data-user-id="120989">@nnethercote</span> In theory you could have the control stream be bounded-powers-of-two expressed as an exponent: <code>2**0</code> (<code>u8</code>), <code>2**1</code> (<code>u16</code>), <code>2**2</code> (<code>u32</code>), <code>2**3</code> (<code>u64</code>), <code>2**4</code> (<code>u128</code>). You'd need 3 bits per value, and that gives you a couple of spare values for things like <code>usize</code> if you want to distinguish it from the sized type of the same size.</p>



<a name="274624844"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/247081-t-compiler/performance/topic/Infallible%20encoding/near/274624844" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/247081-t-compiler/performance/topic/Infallible.20encoding.html#274624844">(Mar 08 2022 at 23:51)</a>:</h4>
<p>That doesn't scale to bigger values, but if you don't <em>need</em> to scale to bigger values (or you can break format compatibility when you do) then it'd work.</p>



<a name="274625966"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/247081-t-compiler/performance/topic/Infallible%20encoding/near/274625966" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> simulacrum <a href="https://zulip-archive.rust-lang.org/stream/247081-t-compiler/performance/topic/Infallible.20encoding.html#274625966">(Mar 09 2022 at 00:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="116122">simulacrum</span> <a href="#narrow/stream/247081-t-compiler.2Fperformance/topic/Infallible.20encoding/near/274624638">said</a>:</p>
<blockquote>
<p>But they're quite hard to pull through our current traits</p>
</blockquote>
<p>One of the 'easy' problems we run into is that <code>Vec&lt;u32&gt;</code> is pretty typically <code>Vec&lt;SomeNewType&gt;</code> where the new type has some bits carved out at the top, but since there's lots of those new types we would need some, uh, more interesting specialization work to make this feasible. I'm not sure it's possible with min_specialization.</p>



<a name="274626662"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/247081-t-compiler/performance/topic/Infallible%20encoding/near/274626662" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> lqd <a href="https://zulip-archive.rust-lang.org/stream/247081-t-compiler/performance/topic/Infallible.20encoding.html#274626662">(Mar 09 2022 at 00:10)</a>:</h4>
<p>do we btw have have an idea of the tradeoffs in our use of LEB128 encoding/decoding itself ? The gains in size and reduction in IO costs, compared to the encoding and decoding costs ? (It’s known to be quite fast but maybe alternatives with slightly higher cpu costs could be recouped in IO savings, if the compression is worth it)</p>



<a name="274632712"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/247081-t-compiler/performance/topic/Infallible%20encoding/near/274632712" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> simulacrum <a href="https://zulip-archive.rust-lang.org/stream/247081-t-compiler/performance/topic/Infallible.20encoding.html#274632712">(Mar 09 2022 at 01:28)</a>:</h4>
<p>Not to my knowledge, at least not recently.</p>



<a name="274633818"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/247081-t-compiler/performance/topic/Infallible%20encoding/near/274633818" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/247081-t-compiler/performance/topic/Infallible.20encoding.html#274633818">(Mar 09 2022 at 01:48)</a>:</h4>
<p>I can tell from looking at some data today that LEB128 is very effective, compression-wise -- <em>many</em> of the u32/u64/usize values we encode/decode are &lt; 128</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>