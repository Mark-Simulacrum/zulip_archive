<html>
<head><meta charset="utf-8"><title>Instrumenting MIR to trace program execution · t-compiler/wg-mir-opt · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/189540-t-compiler/wg-mir-opt/index.html">t-compiler/wg-mir-opt</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/189540-t-compiler/wg-mir-opt/topic/Instrumenting.20MIR.20to.20trace.20program.20execution.html">Instrumenting MIR to trace program execution</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="259434717"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/189540-t-compiler/wg-mir-opt/topic/Instrumenting%20MIR%20to%20trace%20program%20execution/near/259434717" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Vsevolod Tymofyeyev <a href="https://zulip-archive.rust-lang.org/stream/189540-t-compiler/wg-mir-opt/topic/Instrumenting.20MIR.20to.20trace.20program.20execution.html#259434717">(Oct 28 2021 at 18:48)</a>:</h4>
<p>Hello everyone,</p>
<p>I hope somebody can help me with this :) I'm a master's student and I'm quite new to Rust, especially as far as the compiler itself is concerned. Currently, I'm writing my thesis on testing with Rust and I'd like to instrument Rust programs and insert additional function calls in certain branches (e.g., after if's) that trace the execution of a branch along with additional information. For this, I need the condition expressions to be atomic, which is why MIR seems to me to be most suitable.</p>
<p>From this <a href="https://zulip-archive.rust-lang.org/stream/182449-t-compiler/help/topic/Modifying.20the.20MIR.20of.20a.20function.20from.20rustc_driver.html">archive post</a>, I learned that I can modify  MIR and pass the modified version back to the compiler. So what I do is run the compiler and register my own function where I modify the MIR of a function body:</p>
<div class="codehilite"><pre><span></span><code>const CUSTOM_OPT_MIR: for&lt;&#39;tcx&gt; fn(_: TyCtxt&lt;&#39;tcx&gt;, _: DefId) -&gt; &amp;&#39;tcx Body&lt;&#39;tcx&gt; = |tcx, def| {
    let opt_mir = rustc_interface::DEFAULT_QUERY_PROVIDERS
        .borrow()
        .optimized_mir;
    let mut body = opt_mir(tcx, def).clone();

    let mut mir_visitor = MirVisitor { tcx };

    mir_visitor.visit_body(&amp;mut body);
    tcx.arena.alloc(body)
};

struct CompilerCallbacks;

impl rustc_driver::Callbacks for CompilerCallbacks {
    fn config(&amp;mut self, _config: &amp;mut Config) {
        _config.override_queries = Some(|session, local, external| {
            local.optimized_mir = CUSTOM_OPT_MIR;
        });
    }
}

fn main() {
    // define args and stuff

    let mut callbacks = CompilerCallbacks {};
    rustc_driver::RunCompiler::new(&amp;args, &amp;mut callbacks)
        .run()
        .unwrap();
}
</code></pre></div>
<p>Now, this seems to work. In my MirVisitor, I want to insert a function call at some point. Let's assume I have the following program I try to instrument and a dummy tracing function:</p>
<div class="codehilite"><pre><span></span><code>use
mod monitor {
    pub fn trace() {
        // do something
    }
}

fn main() {
    let inputs: Vec&lt;u64&gt; = std::env::args()
        .map(|a| a.parse::&lt;u64&gt;().unwrap())
        .take(2)
        .collect();
    let x = *inputs.get(0).unwrap();
    let y = *inputs.get(1).unwrap();

    if x &lt; y {
        println!(&quot;x &lt; y&quot;);
    } else {
        println!(&quot;x &gt;= y&quot;);
    }
}
</code></pre></div>
<p>The relevant basic block in the MIR of the main function looks like this: </p>
<div class="codehilite" data-code-language="Text only"><pre><span></span><code>bb10: {
        _12 = (*_13);
        _19 = _6;
        _20 = _12;
        _18 = Lt(move _19, move _20);
        switchInt(move _18) -&gt; [false: bb13, otherwise: bb11];
    }
</code></pre></div>
<p>Now I want to call the monitor::trace function directly after that, on both control paths. A function call is a terminator, so I could insert a whole new basic block for each branch and let it point to the original descendent blocks, i.e.,</p>
<div class="codehilite" data-code-language="Text only"><pre><span></span><code>bb10: {
        _12 = (*_13);
        _19 = _6;
        _20 = _12;
        _18 = Lt(move _19, move _20);
        switchInt(move _18) -&gt; [false: bb14, otherwise: bb15];
    }


bb14: {
        _22 = monitor::trace() -&gt; [return: bb13, unwind: ...];
    }


bb15: {
        _23 = monitor::trace() -&gt; [return: bb11, unwind: ...];
    }
</code></pre></div>
<p>I understand that I will also need to add the locals, however, I don't even know how to create such an artificial function call programmatically in the first place. A part of the <a href="https://doc.rust-lang.org/stable/nightly-rustc/rustc_middle/mir/terminator/struct.Terminator.html">Terminator</a> struct is a reference (ConstantKind::Ty). Hence, the basic block I initialize does not live long enough to be passed back to the compiler :( </p>
<p>Is there a way to implement this idea anyway? Maybe in a different way? Note that I don't just want to trace coverage, but also make computations based on the runtime values used in condition expressions and so on. It seems like a MirPass could achieve something like this. However, as far as I understand, to apply my own MirPass logic, I'd have to build a custom version of the compiler, which I'd like to avoid.</p>



<a name="259444810"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/189540-t-compiler/wg-mir-opt/topic/Instrumenting%20MIR%20to%20trace%20program%20execution/near/259444810" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/189540-t-compiler/wg-mir-opt/topic/Instrumenting.20MIR.20to.20trace.20program.20execution.html#259444810">(Oct 28 2021 at 20:06)</a>:</h4>
<blockquote>
<p>However, as far as I understand, to apply my own MirPass logic, I'd have to build a custom version of the compiler, which I'd like to avoid.</p>
</blockquote>
<p>there is no difference between a MirPass and "modify MIR and pass the modified version back to the compiler.", so you don't gain anything by using a MirPass.</p>



<a name="259444895"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/189540-t-compiler/wg-mir-opt/topic/Instrumenting%20MIR%20to%20trace%20program%20execution/near/259444895" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/189540-t-compiler/wg-mir-opt/topic/Instrumenting.20MIR.20to.20trace.20program.20execution.html#259444895">(Oct 28 2021 at 20:07)</a>:</h4>
<blockquote>
<p>Is there a way to implement this idea anyway? Maybe in a different way?</p>
</blockquote>
<p>you got the right idea. just some details missing <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span></p>



<a name="259445022"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/189540-t-compiler/wg-mir-opt/topic/Instrumenting%20MIR%20to%20trace%20program%20execution/near/259445022" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/189540-t-compiler/wg-mir-opt/topic/Instrumenting.20MIR.20to.20trace.20program.20execution.html#259445022">(Oct 28 2021 at 20:08)</a>:</h4>
<blockquote>
<p>Hence, the basic block I initialize does not live long enough to be passed back to the compiler <span aria-label="frown" class="emoji emoji-1f641" role="img" title="frown">:frown:</span> </p>
</blockquote>
<p>that is because you need 'tcx lifetimes, and you get those by using methods like <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/context/struct.TyCtxt.html#method.mk_unit">https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/context/struct.TyCtxt.html#method.mk_unit</a> for the () type (and other mk_* functions for other types)</p>



<a name="259445144"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/189540-t-compiler/wg-mir-opt/topic/Instrumenting%20MIR%20to%20trace%20program%20execution/near/259445144" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/189540-t-compiler/wg-mir-opt/topic/Instrumenting.20MIR.20to.20trace.20program.20execution.html#259445144">(Oct 28 2021 at 20:09)</a>:</h4>
<blockquote>
<p>Note that I don't just want to trace coverage, but also make computations based on the runtime values used in condition expressions and so on</p>
</blockquote>
<p>you can pass arguments to your trace functions, which I guess would be the main way to get that information. Injecting more MIR to do computations is going to be rather annoying I would guess. Instead you can write the logic in Rust and call those functions</p>



<a name="259457333"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/189540-t-compiler/wg-mir-opt/topic/Instrumenting%20MIR%20to%20trace%20program%20execution/near/259457333" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Vsevolod Tymofyeyev <a href="https://zulip-archive.rust-lang.org/stream/189540-t-compiler/wg-mir-opt/topic/Instrumenting.20MIR.20to.20trace.20program.20execution.html#259457333">(Oct 28 2021 at 21:55)</a>:</h4>
<p><span class="user-mention" data-user-id="124288">@oli</span> that's amazing! Indeed, I just had to use <code>mk_const</code>. Now it works seamlessly <span aria-label="grinning" class="emoji emoji-1f600" role="img" title="grinning">:grinning:</span> Thanks a lot!</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>