<html>
<head><meta charset="utf-8"><title>Other undecided upon limits? · t-lang/doc · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/237824-t-lang/doc/index.html">t-lang/doc</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/237824-t-lang/doc/topic/Other.20undecided.20upon.20limits.3F.html">Other undecided upon limits?</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="276292107"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/237824-t-lang/doc/topic/Other%20undecided%20upon%20limits%3F/near/276292107" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> isHavvy <a href="https://zulip-archive.rust-lang.org/stream/237824-t-lang/doc/topic/Other.20undecided.20upon.20limits.3F.html#276292107">(Mar 23 2022 at 06:05)</a>:</h4>
<p>Other than the maximum number of raw string delimiters, are there other limits that should be defined at some point?</p>



<a name="276345070"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/237824-t-lang/doc/topic/Other%20undecided%20upon%20limits%3F/near/276345070" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Eric Huss <a href="https://zulip-archive.rust-lang.org/stream/237824-t-lang/doc/topic/Other.20undecided.20upon.20limits.3F.html#276345070">(Mar 23 2022 at 14:54)</a>:</h4>
<p>I think it would be nice to have some kind of high-level guiding principles on that.  There are many places where the reference currently defines unbounded limits.  Just in the lexer, any production that has <code>*</code> or <code>+</code> repetition (identifier lengths, literals, etc.).  </p>
<p>However, I feel like every instance will be a difficult process to make a final decision.  There will be reasons for and against a limit, or what specific limits there should be, or if they should be minimum or maximums, or should it be implementation-defined. I'm honestly not sure if it is worth the effort right now. There are lots of other things to consider and spend energy on.</p>



<a name="276345109"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/237824-t-lang/doc/topic/Other%20undecided%20upon%20limits%3F/near/276345109" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Eric Huss <a href="https://zulip-archive.rust-lang.org/stream/237824-t-lang/doc/topic/Other.20undecided.20upon.20limits.3F.html#276345109">(Mar 23 2022 at 14:54)</a>:</h4>
<p>As an example, here are some limits defined in C11:</p>
<p>5.2.4.1 Translation limits<br>
1 The implementation shall be able to translate and execute at least one program that<br>
contains at least one instance of every one of the following limits:18)<br>
— 127 nesting levels of blocks<br>
— 63 nesting levels of conditional inclusion<br>
— 12 pointer, array, and function declarators (in any combinations) modifying an<br>
arithmetic, structure, union, or void type in a declaration<br>
— 63 nesting levels of parenthesized declarators within a full declarator<br>
— 63 nesting levels of parenthesized expressions within a full expression<br>
— 63 significant initial characters in an internal identifier or a macro name (each<br>
universal character name or extended source character is considered a single<br>
character)<br>
— 31 significant initial characters in an external identifier (each universal character name<br>
specifying a short identifier of 0000FFFF or less is considered 6 characters, each<br>
18) Implementations should avoid imposing fixed translation limits whenever possible.<br>
§5.2.4.1 Environment 25<br>
ISO/IEC 9899:201x Committee Draft — December 2, 2010 N1548<br>
universal character name specifying a short identifier of 00010000 or more is<br>
considered 10 characters, and each extended source character is considered the same<br>
number of characters as the corresponding universal character name, if any) 19)<br>
— 4095 external identifiers in one translation unit<br>
— 511 identifiers with block scope declared in one block<br>
— 4095 macro identifiers simultaneously defined in one preprocessing translation unit<br>
— 127 parameters in one function definition<br>
— 127 arguments in one function call<br>
— 127 parameters in one macro definition<br>
— 127 arguments in one macro invocation<br>
— 4095 characters in a logical source line<br>
— 4095 characters in a string literal (after concatenation)<br>
— 65535 bytes in an object (in a hosted environment only)<br>
— 15 nesting levels for #included files<br>
— 1023 case labels for a switch statement (excluding those for any nested switch<br>
statements)<br>
— 1023 members in a single structure or union<br>
— 1023 enumeration constants in a single enumeration<br>
— 63 levels of nested structure or union definitions in a single struct-declaration-lis</p>



<a name="276345638"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/237824-t-lang/doc/topic/Other%20undecided%20upon%20limits%3F/near/276345638" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Eric Huss <a href="https://zulip-archive.rust-lang.org/stream/237824-t-lang/doc/topic/Other.20undecided.20upon.20limits.3F.html#276345638">(Mar 23 2022 at 14:57)</a>:</h4>
<p>But other languages like Java are sometimes a little looser. For example, it says identifiers are "unlimited-length".  And IIRC, Java has many emergent limits due to the JVM.</p>



<a name="276358571"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/237824-t-lang/doc/topic/Other%20undecided%20upon%20limits%3F/near/276358571" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Eric Huss <a href="https://zulip-archive.rust-lang.org/stream/237824-t-lang/doc/topic/Other.20undecided.20upon.20limits.3F.html#276358571">(Mar 23 2022 at 16:14)</a>:</h4>
<p>Oh, I realize maybe you were asking if there are other pre-existing rustc-imposed limits.  None come to mind.</p>



<a name="276358897"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/237824-t-lang/doc/topic/Other%20undecided%20upon%20limits%3F/near/276358897" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/237824-t-lang/doc/topic/Other.20undecided.20upon.20limits.3F.html#276358897">(Mar 23 2022 at 16:16)</a>:</h4>
<p>I suspect if we went down that list from C11, we'd find a few other cases in the compiler that have limits. I know there are various things with u32 indices (which is a limit, even if it's a massive one that will never arise in practice).</p>



<a name="276358949"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/237824-t-lang/doc/topic/Other%20undecided%20upon%20limits%3F/near/276358949" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/237824-t-lang/doc/topic/Other.20undecided.20upon.20limits.3F.html#276358949">(Mar 23 2022 at 16:16)</a>:</h4>
<p>And I wouldn't be surprised if there are <em>some</em> things with u16 indices.</p>



<a name="276362564"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/237824-t-lang/doc/topic/Other%20undecided%20upon%20limits%3F/near/276362564" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/237824-t-lang/doc/topic/Other.20undecided.20upon.20limits.3F.html#276362564">(Mar 23 2022 at 16:36)</a>:</h4>
<p>xlang in lccc uses a u16 for "indexing" the operand stack (indexing in quotes because you can't do random access, but 3 instructions, pop, dup, and pivot, take a u16 number of values), and prescribes a minimum limit of 2^16-1 values on the stack (which translates, at least as it applies to rust, to 2^16-2 maximum function parameters, since parameters are removed from the operand stack by the <code>call</code> xir instruction).</p>



<a name="276362645"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/237824-t-lang/doc/topic/Other%20undecided%20upon%20limits%3F/near/276362645" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/237824-t-lang/doc/topic/Other.20undecided.20upon.20limits.3F.html#276362645">(Mar 23 2022 at 16:37)</a>:</h4>
<p>Of course, if you have 65536 parameters... idk what to tell you, because you're probably not calling that function on any practical system anyways, not unless 90% of those parameters are ZSTs.</p>



<a name="276386651"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/237824-t-lang/doc/topic/Other%20undecided%20upon%20limits%3F/near/276386651" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/237824-t-lang/doc/topic/Other.20undecided.20upon.20limits.3F.html#276386651">(Mar 23 2022 at 19:19)</a>:</h4>
<p>Yeah, even having more than 256 parameters seems like macro-generated-code territory.</p>



<a name="276563878"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/237824-t-lang/doc/topic/Other%20undecided%20upon%20limits%3F/near/276563878" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/237824-t-lang/doc/topic/Other.20undecided.20upon.20limits.3F.html#276563878">(Mar 25 2022 at 02:11)</a>:</h4>
<p>While I think it's not going to be possible to spell out every case an implementation may be limited in some capacity, I think some that may be worth explicitly mentioning are:</p>
<ul>
<li>Number of bytes (UTF-8 encoded) in a single token</li>
<li>Number of tokens in a source file</li>
<li>Number of tokens produced by a single macro expansion</li>
<li>Number of total characters in a source file</li>
<li>Number of parameters in a function declaration/function type</li>
<li>Number of arguments in a function call expression, including reciever.</li>
<li>Size of an allocation with a given type (static, stack, thread local, dynamic)</li>
<li>Size of an allocation produced during constant evaluation.</li>
</ul>



<a name="276563969"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/237824-t-lang/doc/topic/Other%20undecided%20upon%20limits%3F/near/276563969" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/237824-t-lang/doc/topic/Other.20undecided.20upon.20limits.3F.html#276563969">(Mar 25 2022 at 02:12)</a>:</h4>
<p>It may be a good idea to go the C++ route of "Here are the suggested minimums" and it could be expected that users code against the suggested minimums, so those could be placed suitably, but it would allow for limited capability implementations that have to go lower (thus we could set them higher than would be supportable on, say, a 16-bit host cpu).</p>



<a name="276564883"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/237824-t-lang/doc/topic/Other%20undecided%20upon%20limits%3F/near/276564883" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/237824-t-lang/doc/topic/Other.20undecided.20upon.20limits.3F.html#276564883">(Mar 25 2022 at 02:30)</a>:</h4>
<p>All of those would be worth explicitly mentioning, but I continue to believe we should <em>not</em> allow variation on the level of support required for any of those.</p>



<a name="276564924"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/237824-t-lang/doc/topic/Other%20undecided%20upon%20limits%3F/near/276564924" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/237824-t-lang/doc/topic/Other.20undecided.20upon.20limits.3F.html#276564924">(Mar 25 2022 at 02:31)</a>:</h4>
<p>If someone is building a stunt implementation for a 16-bit system, nobody's going to consider the accomplishment less impressive just because it says "not a compliant implementation of Rust, due to insufficient memory". Either way, it's an impressive stunt.</p>



<a name="276603284"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/237824-t-lang/doc/topic/Other%20undecided%20upon%20limits%3F/near/276603284" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/237824-t-lang/doc/topic/Other.20undecided.20upon.20limits.3F.html#276603284">(Mar 25 2022 at 11:06)</a>:</h4>
<p><span class="user-mention silent" data-user-id="239881">Josh Triplett</span> <a href="#narrow/stream/237824-t-lang.2Fdoc/topic/Other.20undecided.20upon.20limits.3F/near/276564883">said</a>:</p>
<blockquote>
<p>All of those would be worth explicitly mentioning, but I continue to believe we should <em>not</em> allow variation on the level of support required for any of those.</p>
</blockquote>
<p>Well, it might be hard to enforce in some cases. And a variation in these limits is going to be natural by different designs of implementation.</p>
<p>For "Size of an allocation produced during constant evaluation", consider the value <code>[0u8;1&lt;&lt;48]</code>. IIRC, a MIRI CTFE byte is 24 host bytes, so this is a massive (1&lt;&lt;56)+(1&lt;&lt;64) bytes. clearly outside the range of any practical implementation. In constrast, xlang's constant evaluator would likely use 256 bytes for the entire value, since it would just be stored as something like <code>CXValue::Array([Piece::Repeat(Value::Integer{ty: uint(8), val:0},Value::Integer{ty: uint(64), val: 0x100000000000})])</code>. </p>
<p>Thus, one couldn't expect such a limit to be enforced naturally (by it simply causing an oom condition), but instead requires calculating the actual runtime size of the allocation, which is, heh, fun (and likely would be a fair bit of the time cost of an evaluation step).</p>



<a name="276622791"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/237824-t-lang/doc/topic/Other%20undecided%20upon%20limits%3F/near/276622791" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/237824-t-lang/doc/topic/Other.20undecided.20upon.20limits.3F.html#276622791">(Mar 25 2022 at 14:01)</a>:</h4>
<p>we also have a limit for how many steps compile-time evaluation will take before it stops and errors</p>



<a name="276622868"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/237824-t-lang/doc/topic/Other%20undecided%20upon%20limits%3F/near/276622868" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/237824-t-lang/doc/topic/Other.20undecided.20upon.20limits.3F.html#276622868">(Mar 25 2022 at 14:02)</a>:</h4>
<p>and the number of steps a constant needs is dependent on MIR generation, so this is not really comparable across implementations</p>



<a name="276625291"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/237824-t-lang/doc/topic/Other%20undecided%20upon%20limits%3F/near/276625291" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/237824-t-lang/doc/topic/Other.20undecided.20upon.20limits.3F.html#276625291">(Mar 25 2022 at 14:19)</a>:</h4>
<p>Yeah.</p>



<a name="276625399"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/237824-t-lang/doc/topic/Other%20undecided%20upon%20limits%3F/near/276625399" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/237824-t-lang/doc/topic/Other.20undecided.20upon.20limits.3F.html#276625399">(Mar 25 2022 at 14:20)</a>:</h4>
<p>That would definately be a limit that would be impossible to put an absolute limit on in terms of rust syntax.</p>



<a name="276630675"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/237824-t-lang/doc/topic/Other%20undecided%20upon%20limits%3F/near/276630675" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/237824-t-lang/doc/topic/Other.20undecided.20upon.20limits.3F.html#276630675">(Mar 25 2022 at 14:57)</a>:</h4>
<p>well, not <em>impossible</em>. we could define it in terms of loop iterations and function calls as seen from the source.</p>



<a name="276630863"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/237824-t-lang/doc/topic/Other%20undecided%20upon%20limits%3F/near/276630863" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/237824-t-lang/doc/topic/Other.20undecided.20upon.20limits.3F.html#276630863">(Mar 25 2022 at 14:58)</a>:</h4>
<p>that would preclude doing heavy transformations on the IR before executing it (unless those transformations can preserve the information of how many calls and loops there were), but for anything 'sufficiently close to the source code' in structure -- including MIR -- that would work</p>



<a name="276633483"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/237824-t-lang/doc/topic/Other%20undecided%20upon%20limits%3F/near/276633483" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/237824-t-lang/doc/topic/Other.20undecided.20upon.20limits.3F.html#276633483">(Mar 25 2022 at 15:14)</a>:</h4>
<p>I doubt it would work with xir, though, which, while still fairly high level, will contain rust constructs desugared in some interesting ways. </p>
<p>xir doesn't have a concept of a loop, only branches, so it wouldn't be able to track the number of "loops" specifically, not without some magic.</p>



<a name="276633751"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/237824-t-lang/doc/topic/Other%20undecided%20upon%20limits%3F/near/276633751" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/237824-t-lang/doc/topic/Other.20undecided.20upon.20limits.3F.html#276633751">(Mar 25 2022 at 15:15)</a>:</h4>
<p>It can track calls, but only assuming any inlining hasn't already happened, which would be a very annoying thing to be enjoined from.</p>



<a name="276654961"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/237824-t-lang/doc/topic/Other%20undecided%20upon%20limits%3F/near/276654961" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/237824-t-lang/doc/topic/Other.20undecided.20upon.20limits.3F.html#276654961">(Mar 25 2022 at 17:42)</a>:</h4>
<p>I agree that limits on CTFE would be harder to standardize.</p>



<a name="276655097"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/237824-t-lang/doc/topic/Other%20undecided%20upon%20limits%3F/near/276655097" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/237824-t-lang/doc/topic/Other.20undecided.20upon.20limits.3F.html#276655097">(Mar 25 2022 at 17:43)</a>:</h4>
<p>Insofar as in the limit that would be equivalent to putting limits on the runtime of compiled code.</p>



<a name="276657833"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/237824-t-lang/doc/topic/Other%20undecided%20upon%20limits%3F/near/276657833" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/237824-t-lang/doc/topic/Other.20undecided.20upon.20limits.3F.html#276657833">(Mar 25 2022 at 18:05)</a>:</h4>
<p>Lower bounds could probably be easily standardized, but yeah, absolute limits would be impossible to enforce w/o a significant amount of additional state.</p>



<a name="276661265"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/237824-t-lang/doc/topic/Other%20undecided%20upon%20limits%3F/near/276661265" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/237824-t-lang/doc/topic/Other.20undecided.20upon.20limits.3F.html#276661265">(Mar 25 2022 at 18:34)</a>:</h4>
<p>Even lower bounds would be difficult to establish without standardizing the execution mechanism for CTFE.</p>



<a name="276661346"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/237824-t-lang/doc/topic/Other%20undecided%20upon%20limits%3F/near/276661346" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/237824-t-lang/doc/topic/Other.20undecided.20upon.20limits.3F.html#276661346">(Mar 25 2022 at 18:35)</a>:</h4>
<p>It may make sense to instead require that execution time of CTFE maps onto some scalar value, and provide a means of turning that scalar value up, so that the user can push it to the limits of available resources.</p>



<a name="276661388"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/237824-t-lang/doc/topic/Other%20undecided%20upon%20limits%3F/near/276661388" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/237824-t-lang/doc/topic/Other.20undecided.20upon.20limits.3F.html#276661388">(Mar 25 2022 at 18:35)</a>:</h4>
<p>But that would still lead to having to tune that value differently for different implementations. Definitely problematic.</p>



<a name="276676823"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/237824-t-lang/doc/topic/Other%20undecided%20upon%20limits%3F/near/276676823" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/237824-t-lang/doc/topic/Other.20undecided.20upon.20limits.3F.html#276676823">(Mar 25 2022 at 20:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/237824-t-lang.2Fdoc/topic/Other.20undecided.20upon.20limits.3F/near/276633483">said</a>:</p>
<blockquote>
<p>I doubt it would work with xir, though, which, while still fairly high level, will contain rust constructs desugared in some interesting ways. </p>
<p>xir doesn't have a concept of a loop, only branches, so it wouldn't be able to track the number of "loops" specifically, not without some magic.</p>
</blockquote>
<p>MIR doesnt have loops either. they are just cycles in the CFG. but it's not that hard to ensure that on each cycle in the CG, one BB is marked as 'entry' or so and entering that one counts as a 'step'.</p>



<a name="276676894"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/237824-t-lang/doc/topic/Other%20undecided%20upon%20limits%3F/near/276676894" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/237824-t-lang/doc/topic/Other.20undecided.20upon.20limits.3F.html#276676894">(Mar 25 2022 at 20:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/237824-t-lang.2Fdoc/topic/Other.20undecided.20upon.20limits.3F/near/276633751">said</a>:</p>
<blockquote>
<p>It can track calls, but only assuming any inlining hasn't already happened, which would be a very annoying thing to be enjoined from.</p>
</blockquote>
<p>or inlining has to preserve markers, yeah. I dont necessarily think inlining should happen on the IR used for CTFE but <span aria-label="shrug" class="emoji emoji-1f937" role="img" title="shrug">:shrug:</span></p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>