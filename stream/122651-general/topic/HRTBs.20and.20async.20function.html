<html>
<head><meta charset="utf-8"><title>HRTBs and async function · general · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/122651-general/index.html">general</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/HRTBs.20and.20async.20function.html">HRTBs and async function</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="276172707"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/HRTBs%20and%20async%20function/near/276172707" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> BN <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/HRTBs.20and.20async.20function.html#276172707">(Mar 22 2022 at 11:16)</a>:</h4>
<p>I want to write a version of the following that takes an async function instead:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Semaphore</span><span class="p">;</span><span class="w"></span>

<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">RwLockReadGuard</span><span class="o">&lt;'</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">s</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">a</span> <span class="nc">Semaphore</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">data</span>: <span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">marker</span>: <span class="nc">marker</span>::<span class="n">PhantomData</span><span class="o">&lt;&amp;'</span><span class="na">a</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;'</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="n">RwLockReadGuard</span><span class="o">&lt;'</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">map</span><span class="o">&lt;</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">U</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="p">(</span><span class="n">this</span>: <span class="nc">Self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">RwLockReadGuard</span><span class="o">&lt;'</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">U</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">    </span><span class="k">where</span><span class="w"></span>
<span class="w">        </span><span class="n">F</span>: <span class="nb">FnOnce</span><span class="p">(</span><span class="o">&amp;</span><span class="n">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">U</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="o">&amp;*</span><span class="n">this</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">U</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">this</span><span class="p">.</span><span class="n">s</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="c1">// NB: Forget to avoid drop impl from being called.</span>
<span class="w">        </span><span class="n">mem</span>::<span class="n">forget</span><span class="p">(</span><span class="n">this</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="n">RwLockReadGuard</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">s</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">data</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">marker</span>: <span class="nc">marker</span>::<span class="n">PhantomData</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>Unfortunately I have problems with providing a lifetime to the Future trait. I want something like this:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="k">fn</span> <span class="nf">map_async</span><span class="o">&lt;</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">U</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="p">(</span><span class="n">this</span>: <span class="nc">Self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">RwLockReadGuard</span><span class="o">&lt;'</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">U</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">    </span><span class="k">where</span><span class="w"></span>
<span class="w">        </span><span class="n">F</span>: <span class="nc">for</span><span class="o">&lt;'</span><span class="na">b</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">FnOnce</span><span class="p">(</span><span class="o">&amp;'</span><span class="na">b</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">impl</span><span class="w"> </span><span class="n">Future</span><span class="o">&lt;</span><span class="n">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;'</span><span class="na">b</span><span class="w"> </span><span class="n">U</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="o">&amp;*</span><span class="n">this</span><span class="p">).</span><span class="k">await</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">U</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">this</span><span class="p">.</span><span class="n">s</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="c1">// NB: Forget to avoid drop impl from being called.</span>
<span class="w">        </span><span class="n">mem</span>::<span class="n">forget</span><span class="p">(</span><span class="n">this</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="n">RwLockReadGuard</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">s</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">data</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">marker</span>: <span class="nc">marker</span>::<span class="n">PhantomData</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>but impl Trait isn't yet allowed in Fn return types.</p>
<p>It might be possible to wrap the Future in another type that takes a lifetime parameter and then delegates to the wrapped type in its Future impl, but that isn't a really a feasible API probably.</p>
<p>Alternatively I think I could use the following:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="k">fn</span> <span class="nf">map_async</span><span class="o">&lt;'</span><span class="na">b</span>: <span class="o">'</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">Fut</span><span class="p">,</span><span class="w"> </span><span class="n">U</span>: <span class="o">'</span><span class="na">b</span> <span class="o">+</span><span class="w"> </span><span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">this</span>: <span class="nc">Self</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">f</span>: <span class="nc">F</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">RwLockReadGuard</span><span class="o">&lt;'</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">U</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">    </span><span class="k">where</span><span class="w"></span>
<span class="w">        </span><span class="n">F</span>: <span class="nb">FnOnce</span><span class="p">(</span><span class="o">&amp;</span><span class="n">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Fut</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">Fut</span>: <span class="nc">Future</span><span class="o">&lt;</span><span class="n">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;'</span><span class="na">b</span><span class="w"> </span><span class="n">U</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="o">..</span><span class="p">.</span><span class="w"></span>
</code></pre></div>
<p>but given that <code>RwLockReadGuard</code> uses a raw pointer the <code>b: 'a</code> bound isn't actually necessary afaict.</p>
<p>Also when I try to run this version with the lifetime bound I hit, what I think is a GAT bug:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">async</span><span class="w"> </span><span class="k">fn</span> <span class="nf">foo_fn</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">foo</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">a</span> <span class="nc">Foo</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="o">'</span><span class="na">a</span> <span class="kt">u32</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="o">&amp;</span><span class="n">foo</span><span class="p">.</span><span class="mi">0</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cp">#[tokio::main]</span><span class="w"></span>
<span class="k">async</span><span class="w"> </span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Foo</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">guard</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RwLockReadGuard</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">s</span>: <span class="kp">&amp;</span><span class="nc">Semaphore</span><span class="w"> </span><span class="p">{},</span><span class="w"></span>
<span class="w">        </span><span class="n">data</span>: <span class="kp">&amp;</span><span class="nc">foo</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">marker</span>: <span class="nc">PhantomData</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">guard</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RwLockReadGuard</span>::<span class="n">map_async</span><span class="p">(</span><span class="n">guard</span><span class="p">,</span><span class="w"> </span><span class="n">foo_fn</span><span class="p">).</span><span class="k">await</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">guard</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>which fails with:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">error</span><span class="p">[</span><span class="n">E0308</span><span class="p">]</span>: <span class="nc">mismatched</span><span class="w"> </span><span class="n">types</span><span class="w"></span>
<span class="w">   </span><span class="o">-</span>-&gt; <span class="nc">src</span><span class="o">/</span><span class="n">main</span><span class="p">.</span><span class="n">rs</span>:<span class="mi">101</span>:<span class="mi">17</span><span class="w"></span>
<span class="w">    </span><span class="o">|</span><span class="w"></span>
<span class="mi">101</span><span class="w"> </span><span class="o">|</span><span class="w">     </span><span class="kd">let</span><span class="w"> </span><span class="n">guard</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RwLockReadGuard</span>::<span class="n">map_async</span><span class="p">(</span><span class="n">guard</span><span class="p">,</span><span class="w"> </span><span class="n">foo_fn</span><span class="p">).</span><span class="k">await</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="o">|</span><span class="w">                 </span><span class="o">^^^^^^^^^^^^^^^^^^^^^^^^^^</span><span class="w"> </span><span class="n">lifetime</span><span class="w"> </span><span class="n">mismatch</span><span class="w"></span>
<span class="w">    </span><span class="o">|</span><span class="w"></span>
<span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">note</span>: <span class="nc">expected</span><span class="w"> </span><span class="n">associated</span><span class="w"> </span><span class="k">type</span> <span class="err">`</span><span class="o">&lt;</span><span class="k">for</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;'</span><span class="na">a</span><span class="w"> </span><span class="n">Foo</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">impl</span><span class="w"> </span><span class="n">Future</span><span class="o">&lt;</span><span class="n">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;'</span><span class="na">a</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="n">foo_fn</span><span class="p">}</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">FnOnce</span><span class="o">&lt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Foo</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">,)</span><span class="o">&gt;&gt;</span>::<span class="n">Output</span><span class="err">`</span><span class="w"></span>
<span class="w">               </span><span class="n">found</span><span class="w"> </span><span class="n">associated</span><span class="w"> </span><span class="k">type</span> <span class="err">`</span><span class="o">&lt;</span><span class="k">for</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;'</span><span class="na">a</span><span class="w"> </span><span class="n">Foo</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">impl</span><span class="w"> </span><span class="n">Future</span><span class="o">&lt;</span><span class="n">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;'</span><span class="na">a</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="n">foo_fn</span><span class="p">}</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">FnOnce</span><span class="o">&lt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Foo</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">,)</span><span class="o">&gt;&gt;</span>::<span class="n">Output</span><span class="err">`</span><span class="w"></span>
<span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">note</span>: <span class="nc">the</span><span class="w"> </span><span class="n">required</span><span class="w"> </span><span class="n">lifetime</span><span class="w"> </span><span class="n">does</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">necessarily</span><span class="w"> </span><span class="n">outlive</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">empty</span><span class="w"> </span><span class="n">lifetime</span><span class="w"></span>
<span class="n">note</span>: <span class="nc">the</span><span class="w"> </span><span class="n">lifetime</span><span class="w"> </span><span class="n">requirement</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">introduced</span><span class="w"> </span><span class="n">here</span><span class="w"></span>
<span class="w">   </span><span class="o">-</span>-&gt; <span class="nc">src</span><span class="o">/</span><span class="n">main</span><span class="p">.</span><span class="n">rs</span>:<span class="mi">49</span>:<span class="mi">26</span><span class="w"></span>
<span class="w">    </span><span class="o">|</span><span class="w"></span>
<span class="mi">49</span><span class="w">  </span><span class="o">|</span><span class="w">         </span><span class="n">F</span>: <span class="nb">FnOnce</span><span class="p">(</span><span class="o">&amp;</span><span class="n">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Fut</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="o">|</span><span class="w">                          </span><span class="o">^^^</span><span class="w"></span>

<span class="n">For</span><span class="w"> </span><span class="n">more</span><span class="w"> </span><span class="n">information</span><span class="w"> </span><span class="n">about</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">error</span><span class="p">,</span><span class="w"> </span><span class="kr">try</span><span class="w"> </span><span class="err">`</span><span class="n">rustc</span><span class="w"> </span><span class="o">--</span><span class="n">explain</span><span class="w"> </span><span class="n">E0308</span><span class="err">`</span><span class="p">.</span><span class="w"></span>
</code></pre></div>
<p>Though I might also hit that bug with the HRTB version.</p>
<p>Can anybody help here? Is there any way to get this to work?</p>



<a name="276178671"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/HRTBs%20and%20async%20function/near/276178671" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/HRTBs.20and.20async.20function.html#276178671">(Mar 22 2022 at 12:09)</a>:</h4>
<p>Start off using <a href="https://docs.rs/async_fn_traits/latest/async_fn_traits/">https://docs.rs/async_fn_traits/latest/async_fn_traits/</a>, rather than the <code>-&gt; Fut</code> dance. With it, <code>async fn</code>s can be provided to your API, but not <code>|| async move {</code> closures.<br>
So, in the end, you'll end up having to use something like:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">F</span><span class="w"> </span>: <span class="nb">FnOnce</span><span class="p">(</span><span class="o">&amp;</span><span class="n">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">BoxFuture</span><span class="o">&lt;'</span><span class="nb">_</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;'</span><span class="nb">_</span><span class="w"> </span><span class="n">U</span><span class="o">&gt;</span><span class="w"></span>
</code></pre></div>
<p>and even then you may run into implicit <code>: 'static</code> assertions about the future, which will disallow you from capturing other locals; you may thus need to add a dummy parameter:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">F</span><span class="w"> </span>: <span class="nc">for</span><span class="o">&lt;'</span><span class="na">b</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">FnOnce</span><span class="p">(</span><span class="o">&amp;'</span><span class="na">b</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">PhantomBound</span><span class="o">&lt;'</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="o">'</span><span class="na">b</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">BoxFuture</span><span class="o">&lt;'</span><span class="na">b</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;'</span><span class="na">b</span><span class="w"> </span><span class="p">()</span><span class="o">&gt;</span><span class="w"></span>
</code></pre></div>
<p>where</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="sd">/// where `'a : 'b`</span>
<span class="k">type</span> <span class="nc">PhantomBound</span><span class="o">&lt;'</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="o">'</span><span class="na">b</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;'</span><span class="na">b</span><span class="w"> </span><span class="o">&amp;'</span><span class="na">a</span><span class="w"> </span><span class="p">();</span><span class="w"> </span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
</code></pre></div>



<a name="276179746"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/HRTBs%20and%20async%20function/near/276179746" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Giacomo Stevanato <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/HRTBs.20and.20async.20function.html#276179746">(Mar 22 2022 at 12:21)</a>:</h4>
<p><span class="user-mention silent" data-user-id="328097">BN</span> <a href="#narrow/stream/122651-general/topic/HRTBs.20and.20async.20function/near/276172707">said</a>:</p>
<blockquote>
<p>Alternatively I think I could use the following:</p>
<p><div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="k">fn</span> <span class="nf">map_async</span><span class="o">&lt;'</span><span class="na">b</span>: <span class="o">'</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">Fut</span><span class="p">,</span><span class="w"> </span><span class="n">U</span>: <span class="o">'</span><span class="na">b</span> <span class="o">+</span><span class="w"> </span><span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">this</span>: <span class="nc">Self</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">f</span>: <span class="nc">F</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">RwLockReadGuard</span><span class="o">&lt;'</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">U</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">    </span><span class="k">where</span><span class="w"></span>
<span class="w">        </span><span class="n">F</span>: <span class="nb">FnOnce</span><span class="p">(</span><span class="o">&amp;</span><span class="n">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Fut</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">Fut</span>: <span class="nc">Future</span><span class="o">&lt;</span><span class="n">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;'</span><span class="na">b</span><span class="w"> </span><span class="n">U</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="o">..</span><span class="p">.</span><span class="w"></span>
</code></pre></div><br>
</p>
</blockquote>
<p>I don't think that function signature is reasonable: the closure takes a reference that could have any lifetime, but is forced to return one with the <code>'b</code> lifetime, which isn't necessarily outlived by the one passed to the closure.</p>
<p>More in general, <code>Fut</code> is defined outside the HRTB scope, so it can't reference the generic lifetime, neither in its type (because it will capture that reference) nor in its return type.</p>
<p>You could write a trait with a blanket implementation for the right closure types <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=4efc4028031a68327d98027c6b2b3baa">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=4efc4028031a68327d98027c6b2b3baa</a> but you'll notice that you'll quickly run into <a href="https://github.com/rust-lang/rust/issues/70263">https://github.com/rust-lang/rust/issues/70263</a></p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>