<html>
<head><meta charset="utf-8"><title>&quot;ref impls&quot; · general · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/122651-general/index.html">general</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/.22ref.20impls.22.html">&quot;ref impls&quot;</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="272460353"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/%22ref%20impls%22/near/272460353" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Gus Wynn <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/.22ref.20impls.22.html#272460353">(Feb 18 2022 at 21:33)</a>:</h4>
<p>trait impls like this: <a href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#3461-3476">https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#3461-3476</a> (i call them <code>ref</code> impls, are extremely dank; they allow at least 2 different cool patterns:</p>
<ul>
<li>the use of <code>self</code> receiver methods like <code>Iterator::map</code> on trait objects which is normally impossible (!!!) (we take this for granted with <code>Iterator</code> combinators!!)</li>
<li>patterns like:</li>
</ul>
<div class="codehilite"><pre><span></span><code>let i = &amp;mut thing.iter();
i.take(n);
i.take(2);
</code></pre></div>
<p>(calling <code>self</code> methods more than once!!)</p>
<p>however, they are weird in that if the underlying <code>I</code> impl overrides a provided method, it is it not used: <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=c3be48f4cbc778fb5676e699812d460f">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=c3be48f4cbc778fb5676e699812d460f</a> (the recursive function warning is broken here too lol)</p>
<p>My understanding is that its impossible to fix this without some change in the compiler, as the provided method is not always callable in the ref impl block (because the referent is not <code>: Sized</code>. Is this something people feel is fixable, and worth fixing? I find it very confusing</p>



<a name="272461526"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/%22ref%20impls%22/near/272461526" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/.22ref.20impls.22.html#272461526">(Feb 18 2022 at 21:44)</a>:</h4>
<p>Even if it were sized, you're not allowed to move out of <code>&amp;mut I</code> to use the underlying <code>I</code> as <code>self</code>.</p>



<a name="272461644"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/%22ref%20impls%22/near/272461644" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Gus Wynn <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/.22ref.20impls.22.html#272461644">(Feb 18 2022 at 21:45)</a>:</h4>
<p>yeah...maybe the iterator combinators should have taken <code>&amp;mut self</code> instead</p>



<a name="272461701"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/%22ref%20impls%22/near/272461701" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/.22ref.20impls.22.html#272461701">(Feb 18 2022 at 21:45)</a>:</h4>
<p>The reason we can do this sort of ref impl for <code>Iterator</code> is because the only <em>required</em> methods take <code>&amp;mut self</code>, so we can forward those.</p>



<a name="272461789"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/%22ref%20impls%22/near/272461789" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/.22ref.20impls.22.html#272461789">(Feb 18 2022 at 21:46)</a>:</h4>
<p>If we took references in all the combinators, it would be a mess of borrowed lifetimes.</p>



<a name="272461819"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/%22ref%20impls%22/near/272461819" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Gus Wynn <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/.22ref.20impls.22.html#272461819">(Feb 18 2022 at 21:46)</a>:</h4>
<p>yeah thats the tradeoff it seems</p>



<a name="272462040"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/%22ref%20impls%22/near/272462040" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake Goulding <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/.22ref.20impls.22.html#272462040">(Feb 18 2022 at 21:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257428">Gus Wynn</span> <a href="#narrow/stream/122651-general/topic/.22ref.20impls.22/near/272461644">said</a>:</p>
<blockquote>
<p>yeah...maybe the iterator combinators should have taken <code>&amp;mut self</code> instead</p>
</blockquote>
<p>Then you wouldn't be able to do</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span> <span class="nf">x</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">impl</span><span class="w"> </span><span class="nb">Iterator</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="mi">1</span><span class="p">).</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</code></pre></div>



<a name="272462276"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/%22ref%20impls%22/near/272462276" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake Goulding <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/.22ref.20impls.22.html#272462276">(Feb 18 2022 at 21:51)</a>:</h4>
<p>But maybe that would have forced a language-supported way of self-referential types sooner rather than later... <span aria-label="shrug" class="emoji emoji-1f937" role="img" title="shrug">:shrug:</span></p>



<a name="272462474"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/%22ref%20impls%22/near/272462474" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Gus Wynn <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/.22ref.20impls.22.html#272462474">(Feb 18 2022 at 21:52)</a>:</h4>
<p>omg</p>



<a name="272465685"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/%22ref%20impls%22/near/272465685" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/.22ref.20impls.22.html#272465685">(Feb 18 2022 at 22:17)</a>:</h4>
<p>Btw, you can call them <code>by_ref</code> iterators, since that's the trait method to get one.<br>
<a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.by_ref">https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.by_ref</a></p>



<a name="272466531"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/%22ref%20impls%22/near/272466531" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/.22ref.20impls.22.html#272466531">(Feb 18 2022 at 22:25)</a>:</h4>
<blockquote>
<p>however, they are weird in that if the underlying I impl overrides a provided method, it is it not used</p>
</blockquote>
<p>It shouldn't be a problem outside performance though. All the methods have default impls in terms of <code>next()</code> after all. One could always wrap an iterator into an adapter struct that uses the default impls.<br>
For the performance aspect <a href="https://github.com/rust-lang/rust/issues/82185">#82185</a> might help one day.</p>



<a name="272473776"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/%22ref%20impls%22/near/272473776" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Gus Wynn <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/.22ref.20impls.22.html#272473776">(Feb 18 2022 at 23:37)</a>:</h4>
<p>yeah its only a perf problem i suppose</p>



<a name="272478812"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/%22ref%20impls%22/near/272478812" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Gary Guo <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/.22ref.20impls.22.html#272478812">(Feb 19 2022 at 00:43)</a>:</h4>
<p>It doesn't really make sense to override these methods. For example the return type of <code>map</code> is fixed to be <code>Map</code>, and only the provided implementation can construct that.</p>



<a name="272520270"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/%22ref%20impls%22/near/272520270" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/.22ref.20impls.22.html#272520270">(Feb 19 2022 at 14:01)</a>:</h4>
<p>Regarding the "specialized <code>.map()</code> is lost", that makes sense, with or without by-ref transitivity: such specialized impls are generic and thus wouldn't be usable by a trait object.</p>
<p>If you really needed that extra bit of performance, then the trick is to provide your own trait, taking a <code>dyn</code> closure (rather than an <code>impl</code> one):</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">trait</span><span class="w"> </span><span class="n">TryForEach</span><span class="w"> </span>: <span class="nb">Iterator</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">dyn_try_for_each</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">f</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="k">dyn</span><span class="w"> </span><span class="nb">FnMut</span><span class="p">(</span><span class="bp">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">ControlFlow</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">ControlFlow</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span><span class="w"> </span>: <span class="nb">Iterator</span><span class="o">&gt;</span><span class="w"> </span><span class="n">TryForEach</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">I</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">try_for_each</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">any</span><span class="w"> </span><span class="p">(</span><span class="n">iterator</span>: <span class="kp">&amp;</span><span class="nc">own</span><span class="w"> </span><span class="k">dyn</span><span class="w"> </span><span class="n">TryForEach</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span>-&gt; <span class="kt">bool</span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">iterator</span><span class="p">.</span><span class="n">dyn_try_for_each</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="o">|</span><span class="n">b</span><span class="o">|</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">ControlFlow</span>::<span class="n">BREAK</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">ControlFlow</span>::<span class="n">CONTINUE</span><span class="w"></span>
<span class="w">    </span><span class="p">}).</span><span class="n">break_value</span><span class="p">().</span><span class="n">is_some</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">any</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">iter</span>::<span class="n">once</span><span class="p">(</span><span class="mi">42</span><span class="p">).</span><span class="n">chain</span><span class="p">([</span><span class="mi">27</span><span class="p">]).</span><span class="n">chain</span><span class="p">([</span><span class="mi">0</span><span class="p">]).</span><span class="n">chain</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">]));</span><span class="w"> </span><span class="c1">// internal iteration</span>
</code></pre></div>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>