<html>
<head><meta charset="utf-8"><title>Syntactic sugar for Typestate pattern · general · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/122651-general/index.html">general</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Syntactic.20sugar.20for.20Typestate.20pattern.html">Syntactic sugar for Typestate pattern</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="260321090"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Syntactic%20sugar%20for%20Typestate%20pattern/near/260321090" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Alex Keizer <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Syntactic.20sugar.20for.20Typestate.20pattern.html#260321090">(Nov 04 2021 at 19:21)</a>:</h4>
<p>Hey, I'm someone who is very interested in behavioral types / the typestate pattern. Rust is very cool, because you can make quite elegant typestate-based functions<br>
<code>
impl Foo&lt;StateA&gt; {
  a_to_b(self) -&gt; Foo&lt;StateB&gt; {
    //...
  }
}
impl Foo&lt;StateB&gt; {
  b_to_c(self) -&gt; Foo&lt;StateC&gt; {
    //...
  }
}
</code><br>
The call-site is a bit less elegant, but at least we can chain the calls<br>
<code>
let foo = 
  foo.a_to_b()
      .b_to_c();
</code></p>
<p>Sometimes we want a function that not only changes the state of foo, but also returns some other value. Defining that is still quite easy.<br>
<code>
impl Foo&lt;StateA&gt; {
  a_to_b_with_val(self) -&gt; (Foo&lt;StateB&gt;, Bar) {
    //...
  }
}
</code><br>
However, calling such a function becomes quite a pain.<br>
<code>
let (foo, bar) = foo.a_to_b_with_val();
let foo = foo.b_to_c();
</code></p>
<p>In my opinion this is quite a shame; all the hard stuff for typestates is already solved in Rust, it is just the syntax that is clunky.</p>
<p>Thus, I was thinking it would be nice to have a "self-return" type (better name pending) for methods that consume <code>self</code>, with the intent that this value is not returned in the traditional sense, but instead <code>foo.a_to_b();</code> is desugared to <code>let foo = foo.a_to_b();</code>. Crucially, such functions can still have a regular return type. E.g., <code>let bar = foo.a_to_b_with_val();</code> would desugar to <code>let (foo, bar) = foo.a_to_b_with_val();</code>.</p>
<p>Obviously, this idea still needs a lot of working out (most importantly, how would chained calls desugar?).<br>
I wondered if the folks here think this is interesting and might merit more polish, or if it seems like too much magic for an obscure problem?<br>
Whichever direction, I'd be glad to hear what you think of it.</p>



<a name="260328022"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Syntactic%20sugar%20for%20Typestate%20pattern/near/260328022" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Noah Lev <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Syntactic.20sugar.20for.20Typestate.20pattern.html#260328022">(Nov 04 2021 at 20:14)</a>:</h4>
<p>The idea of being able to have <code>(Self) -&gt; (Self, ReturnType)</code> functions with better ergonomics at the call site sounds interesting to me. The particular example of having <code>let bar = foo.a_to_b_with_val();</code> desugar to <code>let (foo, bar) = ...</code> seems too magical to me though.</p>



<a name="260328153"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Syntactic%20sugar%20for%20Typestate%20pattern/near/260328153" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Noah Lev <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Syntactic.20sugar.20for.20Typestate.20pattern.html#260328153">(Nov 04 2021 at 20:15)</a>:</h4>
<p>Note that you can approximate the syntactic sugar you're describing using a macro. In fact, the Rust compiler already uses such a macro internally: <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_build/build/macro.unpack.html"><code>unpack!</code></a>.</p>



<a name="260328327"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Syntactic%20sugar%20for%20Typestate%20pattern/near/260328327" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Noah Lev <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Syntactic.20sugar.20for.20Typestate.20pattern.html#260328327">(Nov 04 2021 at 20:17)</a>:</h4>
<p>With a version of that macro generalized to tuples (should be pretty easy; just remove the <code>BlockAnd</code>), your example call would look like this:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">bar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">unpack</span><span class="o">!</span><span class="p">(</span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo</span><span class="p">.</span><span class="n">a_to_b_with_val</span><span class="p">());</span><span class="w"></span>
</code></pre></div>
<p>(<code>foo</code> would have to be mutable because this uses assignment.)</p>



<a name="260339234"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Syntactic%20sugar%20for%20Typestate%20pattern/near/260339234" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Alex Keizer <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Syntactic.20sugar.20for.20Typestate.20pattern.html#260339234">(Nov 04 2021 at 21:46)</a>:</h4>
<p>Thanks for mentioning <code>unpack!</code>, it seems like I could use that to work out my ideas.</p>
<p>The motivation behind desugaring to <code>let (foo, bar) = ...</code> is that seems redundant to mention <code>foo</code> twice.<br>
The original value is consumed, so I couldn't think of a scenario where you'd want to bind the returned Foo&lt;...&gt; to another name. <br>
Particularly in contexts with a lot of <code>Self -&gt; (Self, ReturnType)</code> functions, it creates a lot of noise. </p>
<p>I do agree that it could be confusing if there is no indication at the call-site that this desugaring is happening, I guess that's something for me to work out more.</p>



<a name="260395815"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Syntactic%20sugar%20for%20Typestate%20pattern/near/260395815" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Marcin Mielniczuk <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Syntactic.20sugar.20for.20Typestate.20pattern.html#260395815">(Nov 05 2021 at 11:59)</a>:</h4>
<p>Hi,</p>
<p>In our code we have a <code>struct State</code>. Since the library we're using requires a cheap <code>Clone</code> implementation (so that the state can be given to multiple workers), we're using <code>Arc&lt;RwLock&lt;...&gt;&gt;</code> for the interior fields, like </p>
<div class="codehilite"><pre><span></span><code>struct State {
    user_data: Arc&lt;RwLock&lt;HashMap&lt;String, u64&gt;&gt;&gt;,
}
</code></pre></div>
<p>We also have convenience method for modifying the state, something like </p>
<div class="codehilite"><pre><span></span><code>impl State {
    pub async fn update_data(&amp;self, user: &amp;str) {
        let entry = self.user_data.write().await.entry();
        /* modify the entry */
    }
}
</code></pre></div>
<p>We currently disagree whether the methods should rather be </p>
<div class="codehilite"><pre><span></span><code>pub async fn update_data(&amp;mut self, user: &amp;str)
</code></pre></div>
<p>since the method clearly changes the interior state. On the other hand, many rust projects only require an immutable borrow of self whenever <code>RwLock</code>, for instance <a href="https://github.com/smallnest/rpcx-rs/blob/master/rpcx_client/src/discovery.rs">this one</a>. This probably stems from the fact that, once <code>RwLock</code> is employed, there are no memory safety issues coming from the use of <code>&amp;self</code>.</p>
<p>Which way is more preferable in Rust?</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>