<html>
<head><meta charset="utf-8"><title>Why is a state machine not optimized like other iterators? · general · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/122651-general/index.html">general</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Why.20is.20a.20state.20machine.20not.20optimized.20like.20other.20iterators.3F.html">Why is a state machine not optimized like other iterators?</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="265603380"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Why%20is%20a%20state%20machine%20not%20optimized%20like%20other%20iterators%3F/near/265603380" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake Goulding <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Why.20is.20a.20state.20machine.20not.20optimized.20like.20other.20iterators.3F.html#265603380">(Dec 20 2021 at 18:59)</a>:</h4>
<p>What prevents <code>usage1</code> from being as optimized as <code>usage2</code> and <code>usage3</code>? That implementation is closer to what I'd expect from async code / a generator, so I would have assumed it had more optimization attention paid to it than the other two.</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span> <span class="nf">it1</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">impl</span><span class="w"> </span><span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">usize</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span>::<span class="n">iter</span>::<span class="n">from_fn</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">state</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">match</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="mi">1</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">(),</span><span class="w">             </span><span class="c1">// Code A, does not emit item</span>
<span class="w">                </span><span class="mi">2</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">break</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="w">  </span><span class="c1">// Code B, emits item</span>
<span class="w">                </span><span class="mi">3</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">break</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="mi">45</span><span class="p">),</span><span class="w"> </span><span class="c1">// Code C, emits item</span>
<span class="w">                </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">break</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">})</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">it2</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">impl</span><span class="w"> </span><span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">usize</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">[</span><span class="w"></span>
<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="nb">None</span><span class="w"> </span><span class="c1">// Code A runs, does not emit item</span>
<span class="w">        </span><span class="p">},</span><span class="w"></span>
<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="nb">Some</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="c1">// Code B runs, emits item</span>
<span class="w">        </span><span class="p">},</span><span class="w"></span>
<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="nb">Some</span><span class="p">(</span><span class="mi">45</span><span class="p">)</span><span class="w"> </span><span class="c1">// Code C runs, emits item</span>
<span class="w">        </span><span class="p">},</span><span class="w"></span>
<span class="w">    </span><span class="p">]</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">into_iter</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">filter_map</span><span class="p">(</span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">it3</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">impl</span><span class="w"> </span><span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">usize</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span>::<span class="n">iter</span>::<span class="n">empty</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">chain</span><span class="p">(</span><span class="n">std</span>::<span class="n">iter</span>::<span class="n">once_with</span><span class="p">(</span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="c1">// Code A runs, does not emit item</span>
<span class="w">            </span><span class="nb">None</span><span class="w"></span>
<span class="w">        </span><span class="p">}))</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">chain</span><span class="p">(</span><span class="n">std</span>::<span class="n">iter</span>::<span class="n">once_with</span><span class="p">(</span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="c1">// Code B runs, emits item</span>
<span class="w">            </span><span class="nb">Some</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">}))</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">chain</span><span class="p">(</span><span class="n">std</span>::<span class="n">iter</span>::<span class="n">once_with</span><span class="p">(</span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="c1">// Code C runs, emits item</span>
<span class="w">            </span><span class="nb">Some</span><span class="p">(</span><span class="mi">45</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">}))</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">filter_map</span><span class="p">(</span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">usage1</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="kt">usize</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">it1</span><span class="p">().</span><span class="n">sum</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">usage2</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="kt">usize</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">it2</span><span class="p">().</span><span class="n">sum</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">usage3</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="kt">usize</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">it3</span><span class="p">().</span><span class="n">sum</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p><code>usage2</code> and <code>usage3</code> are optimized all the way:</p>
<div class="codehilite" data-code-language="GAS"><pre><span></span><code><span class="nl">playground:</span><span class="err">:</span><span class="nl">usage2:</span>
    <span class="nf">movl</span>    <span class="no">$48</span><span class="p">,</span> <span class="nv">%eax</span>
    <span class="nf">retq</span>
</code></pre></div>
<p>From <a href="https://stackoverflow.com/q/70426439/155423">Are there established patterns to build iterators that return items from different code blocks?</a></p>



<a name="265605759"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Why%20is%20a%20state%20machine%20not%20optimized%20like%20other%20iterators%3F/near/265605759" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake Goulding <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Why.20is.20a.20state.20machine.20not.20optimized.20like.20other.20iterators.3F.html#265605759">(Dec 20 2021 at 19:22)</a>:</h4>
<p>May be irrelevant, but <code>it2</code> and <code>it3</code> implement <code>FusedIterator</code>.</p>



<a name="265606508"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Why%20is%20a%20state%20machine%20not%20optimized%20like%20other%20iterators%3F/near/265606508" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Why.20is.20a.20state.20machine.20not.20optimized.20like.20other.20iterators.3F.html#265606508">(Dec 20 2021 at 19:30)</a>:</h4>
<p>My guess is that it can turn the other variants into counted loops</p>



<a name="265612266"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Why%20is%20a%20state%20machine%20not%20optimized%20like%20other%20iterators%3F/near/265612266" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Why.20is.20a.20state.20machine.20not.20optimized.20like.20other.20iterators.3F.html#265612266">(Dec 20 2021 at 20:30)</a>:</h4>
<p><span class="user-mention silent" data-user-id="116155">Jake Goulding</span> <a href="#narrow/stream/122651-general/topic/Why.20is.20a.20state.20machine.20not.20optimized.20like.20other.20iterators.3F/near/265603380">said</a>:</p>
<blockquote>
<p>What prevents <code>usage1</code> from being as optimized as <code>usage2</code> and <code>usage3</code>? </p>
</blockquote>
<p>Looks to me like the classic internal-vs-external iteration problem.  <code>sum</code> uses <code>fold</code>, which is overridden for 2 &amp; 3, but <code>from_fn</code> produces a pretty poor iterator in lots of ways.</p>
<p>Also, you're <em>always</em> incrementing <code>state</code> in <code>it1</code>, which means it's non-fused, which could also confuse it.  (The loop canonicalizer might not obviously recognize it, for example, when compiling the closure, which happens before everything else.)</p>



<a name="265612380"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Why%20is%20a%20state%20machine%20not%20optimized%20like%20other%20iterators%3F/near/265612380" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake Goulding <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Why.20is.20a.20state.20machine.20not.20optimized.20like.20other.20iterators.3F.html#265612380">(Dec 20 2021 at 20:31)</a>:</h4>
<p>scott "internal vs external iteration" mcm</p>



<a name="265612637"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Why%20is%20a%20state%20machine%20not%20optimized%20like%20other%20iterators%3F/near/265612637" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake Goulding <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Why.20is.20a.20state.20machine.20not.20optimized.20like.20other.20iterators.3F.html#265612637">(Dec 20 2021 at 20:34)</a>:</h4>
<p>My own intuition (not necessarily based on any optimizer knowledge) was that the <code>from_fn</code> version allows for a lot more flexibility even if that wasn't used (e.g. <code>state</code> _could_ go backwards).</p>



<a name="265612972"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Why%20is%20a%20state%20machine%20not%20optimized%20like%20other%20iterators%3F/near/265612972" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Why.20is.20a.20state.20machine.20not.20optimized.20like.20other.20iterators.3F.html#265612972">(Dec 20 2021 at 20:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="116155">Jake Goulding</span> <a href="#narrow/stream/122651-general/topic/Why.20is.20a.20state.20machine.20not.20optimized.20like.20other.20iterators.3F/near/265612637">said</a>:</p>
<blockquote>
<p>e.g. <code>state</code> _could_ go backwards</p>
</blockquote>
<p>Looks like that's not it, because use no-wrap add doesn't do better: <a href="https://rust.godbolt.org/z/5KW6xTGMq">https://rust.godbolt.org/z/5KW6xTGMq</a></p>



<a name="265613160"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Why%20is%20a%20state%20machine%20not%20optimized%20like%20other%20iterators%3F/near/265613160" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Why.20is.20a.20state.20machine.20not.20optimized.20like.20other.20iterators.3F.html#265613160">(Dec 20 2021 at 20:39)</a>:</h4>
<p>Moving the state initialization into the closure helps</p>



<a name="265613169"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Why%20is%20a%20state%20machine%20not%20optimized%20like%20other%20iterators%3F/near/265613169" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake Goulding <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Why.20is.20a.20state.20machine.20not.20optimized.20like.20other.20iterators.3F.html#265613169">(Dec 20 2021 at 20:39)</a>:</h4>
<p>semi-related: I love showing off iterator optimizations during training <em>so much</em>. Please keep making them more and more awesome :-)</p>



<a name="265613428"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Why%20is%20a%20state%20machine%20not%20optimized%20like%20other%20iterators%3F/near/265613428" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Why.20is.20a.20state.20machine.20not.20optimized.20like.20other.20iterators.3F.html#265613428">(Dec 20 2021 at 20:42)</a>:</h4>
<p>They don't come for free.</p>



<a name="265613441"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Why%20is%20a%20state%20machine%20not%20optimized%20like%20other%20iterators%3F/near/265613441" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Why.20is.20a.20state.20machine.20not.20optimized.20like.20other.20iterators.3F.html#265613441">(Dec 20 2021 at 20:42)</a>:</h4>
<p>/me has caused at least one CVE</p>



<a name="265613501"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Why%20is%20a%20state%20machine%20not%20optimized%20like%20other%20iterators%3F/near/265613501" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake Goulding <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Why.20is.20a.20state.20machine.20not.20optimized.20like.20other.20iterators.3F.html#265613501">(Dec 20 2021 at 20:43)</a>:</h4>
<p>Are you a "real programmer" if you haven't caused memory unsafety in a million-dollar business? <span aria-label="thinking" class="emoji emoji-1f914" role="img" title="thinking">:thinking:</span></p>



<a name="265613573"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Why%20is%20a%20state%20machine%20not%20optimized%20like%20other%20iterators%3F/near/265613573" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Why.20is.20a.20state.20machine.20not.20optimized.20like.20other.20iterators.3F.html#265613573">(Dec 20 2021 at 20:43)</a>:</h4>
<p>🦹</p>



<a name="265613866"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Why%20is%20a%20state%20machine%20not%20optimized%20like%20other%20iterators%3F/near/265613866" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Why.20is.20a.20state.20machine.20not.20optimized.20like.20other.20iterators.3F.html#265613866">(Dec 20 2021 at 20:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="116155">Jake Goulding</span> <a href="#narrow/stream/122651-general/topic/Why.20is.20a.20state.20machine.20not.20optimized.20like.20other.20iterators.3F/near/265612637">said</a>:</p>
<blockquote>
<p>My own intuition (not necessarily based on any optimizer knowledge) </p>
</blockquote>
<p>My understanding -- though I'm by no means an expert -- is that LLVM is <em>highly</em> dependant on getting a loop canonicalized.  It needs <em>exactly one</em> iteration variable, and <em>exactly one</em> loop exit condition.</p>
<p>That's why the classic min-max binary search doesn't unroll, for example, which is why it's written to have a descending width instead -- just one variable, which stops at zero.  (Well, that was true before they made <code>binary_search</code> perf much worse for cheap predicates.  Hopefully <code>partition_point</code> still works like that.)</p>



<a name="265613935"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Why%20is%20a%20state%20machine%20not%20optimized%20like%20other%20iterators%3F/near/265613935" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake Goulding <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Why.20is.20a.20state.20machine.20not.20optimized.20like.20other.20iterators.3F.html#265613935">(Dec 20 2021 at 20:47)</a>:</h4>
<p>(thank you for implicitly describing what loop canonicalization is, I was dreading trying to search for those terms)</p>



<a name="265614066"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Why%20is%20a%20state%20machine%20not%20optimized%20like%20other%20iterators%3F/near/265614066" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Why.20is.20a.20state.20machine.20not.20optimized.20like.20other.20iterators.3F.html#265614066">(Dec 20 2021 at 20:48)</a>:</h4>
<p>Example of an unrollable binary search: <a href="https://github.com/scottmcm/uax/blob/7a82b89312c0f3bfa5cde1a59b761a40ac0dfa5a/src/lookup_table.rs#L39-L48">https://github.com/scottmcm/uax/blob/7a82b89312c0f3bfa5cde1a59b761a40ac0dfa5a/src/lookup_table.rs#L39-L48</a></p>



<a name="265614532"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Why%20is%20a%20state%20machine%20not%20optimized%20like%20other%20iterators%3F/near/265614532" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Why.20is.20a.20state.20machine.20not.20optimized.20like.20other.20iterators.3F.html#265614532">(Dec 20 2021 at 20:53)</a>:</h4>
<p>This might be interesting: <a href="https://www.cs.cornell.edu/courses/cs6120/2019fa/blog/strength-reduction-pass-in-llvm/#loop-strength-reduction">https://www.cs.cornell.edu/courses/cs6120/2019fa/blog/strength-reduction-pass-in-llvm/#loop-strength-reduction</a></p>
<hr>
<p>Some extra info for loops: the classic <code>while C { B }</code> loop is a bad structure for optimizers.  It'll basically always turn that into <code>if C { do { B } while C; }</code> because that way the body of the loop always runs at least once.  That makes it much easier, for example, to move loop-invariant code out of the body because it'll still be inside the <code>if C</code> so if the condition was important for soundness it's still met.</p>



<a name="265615086"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Why%20is%20a%20state%20machine%20not%20optimized%20like%20other%20iterators%3F/near/265615086" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake Goulding <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Why.20is.20a.20state.20machine.20not.20optimized.20like.20other.20iterators.3F.html#265615086">(Dec 20 2021 at 20:58)</a>:</h4>
<blockquote>
<p>Unfortunately, our pass does not optimize all programs correctly [...] We have not figured out the reason of these errors yet.</p>
</blockquote>
<p>Heh</p>



<a name="265616322"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Why%20is%20a%20state%20machine%20not%20optimized%20like%20other%20iterators%3F/near/265616322" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Why.20is.20a.20state.20machine.20not.20optimized.20like.20other.20iterators.3F.html#265616322">(Dec 20 2021 at 21:10)</a>:</h4>
<p>Another thing you might explore: try writing it as a <code>try_fold</code>, then just using <code>self.try_for_each(ControlFlow::Break).break_value()</code> as the <code>next()</code> method.</p>
<p>I don't know if it'll be possible to do that in general, but since you needed a <code>loop</code> in the <code>next</code> anyway, it might translate really nicely to a <code>try_fold</code> so the summing loop is internal, not around the closure.</p>



<a name="265617803"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Why%20is%20a%20state%20machine%20not%20optimized%20like%20other%20iterators%3F/near/265617803" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jacob Lifshay <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Why.20is.20a.20state.20machine.20not.20optimized.20like.20other.20iterators.3F.html#265617803">(Dec 20 2021 at 21:27)</a>:</h4>
<p>relevant, llvm getting better loop optimizations: <a href="https://reviews.llvm.org/rG1d0244aed781">https://reviews.llvm.org/rG1d0244aed781</a></p>



<a name="265623895"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Why%20is%20a%20state%20machine%20not%20optimized%20like%20other%20iterators%3F/near/265623895" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Why.20is.20a.20state.20machine.20not.20optimized.20like.20other.20iterators.3F.html#265623895">(Dec 20 2021 at 22:34)</a>:</h4>
<p><span class="user-mention" data-user-id="116155">@Jake Goulding</span> Do you get better optimization if you change the loop/match/break to just a match, or an if/else-if? (I realize that doesn't "naturally" handle case 1, but that's what I'm trying to find out: is it the loop that's throwing off the optimization?</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>