<html>
<head><meta charset="utf-8"><title>When do GATs implementations need `Self: &#x27;a`? · general · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/122651-general/index.html">general</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/When.20do.20GATs.20implementations.20need.20.60Self.3A.20&#x27;a.60.3F.html">When do GATs implementations need `Self: &#x27;a`?</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="273416470"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/When%20do%20GATs%20implementations%20need%20%60Self%3A%20%27a%60%3F/near/273416470" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake Goulding <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/When.20do.20GATs.20implementations.20need.20.60Self.3A.20&#x27;a.60.3F.html#273416470">(Feb 27 2022 at 17:56)</a>:</h4>
<p>It's especially annoying when the concrete associated type doesn't have lifetimes.</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span><span class="w"> </span><span class="n">token</span>::<span class="n">Exchange</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Validator</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">    </span><span class="k">where</span><span class="w"></span>
<span class="w">        </span><span class="n">R</span>: <span class="o">'</span><span class="na">a</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="kt">char</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">exchange</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">idx</span>: <span class="kt">char</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Output</span><span class="o">&lt;'</span><span class="nb">_</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">idx</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>



<a name="273418006"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/When%20do%20GATs%20implementations%20need%20%60Self%3A%20%27a%60%3F/near/273418006" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> LegionMammal978 <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/When.20do.20GATs.20implementations.20need.20.60Self.3A.20&#x27;a.60.3F.html#273418006">(Feb 27 2022 at 18:29)</a>:</h4>
<p>What is the rationale in general for requiring the full list of <code>where</code> bounds in a GAT impl, instead of implicitly copying them from the trait definition?</p>



<a name="273420846"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/When%20do%20GATs%20implementations%20need%20%60Self%3A%20%27a%60%3F/near/273420846" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake Goulding <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/When.20do.20GATs.20implementations.20need.20.60Self.3A.20&#x27;a.60.3F.html#273420846">(Feb 27 2022 at 19:30)</a>:</h4>
<p>Some background in <a href="https://github.com/rust-lang/rust/issues/87479">https://github.com/rust-lang/rust/issues/87479</a></p>



<a name="273420970"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/When%20do%20GATs%20implementations%20need%20%60Self%3A%20%27a%60%3F/near/273420970" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake Goulding <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/When.20do.20GATs.20implementations.20need.20.60Self.3A.20&#x27;a.60.3F.html#273420970">(Feb 27 2022 at 19:31)</a>:</h4>
<p>Also in general... "that's how Rust does it"</p>



<a name="273421042"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/When%20do%20GATs%20implementations%20need%20%60Self%3A%20%27a%60%3F/near/273421042" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake Goulding <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/When.20do.20GATs.20implementations.20need.20.60Self.3A.20&#x27;a.60.3F.html#273421042">(Feb 27 2022 at 19:32)</a>:</h4>
<p>But I think <a href="https://rust-lang.github.io/rfcs/2089-implied-bounds.html">implied_bounds</a> is relevant to your point.</p>



<a name="273423422"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/When%20do%20GATs%20implementations%20need%20%60Self%3A%20%27a%60%3F/near/273423422" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> LegionMammal978 <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/When.20do.20GATs.20implementations.20need.20.60Self.3A.20&#x27;a.60.3F.html#273423422">(Feb 27 2022 at 20:30)</a>:</h4>
<p>Yeah, I think implied_bounds is closer to what I was talking about. To me, there would appear to be no issue if <code>where Self: 'a</code> was always required in the trait definition but was optional in the impl block.</p>



<a name="273480813"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/When%20do%20GATs%20implementations%20need%20%60Self%3A%20%27a%60%3F/near/273480813" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/When.20do.20GATs.20implementations.20need.20.60Self.3A.20&#x27;a.60.3F.html#273480813">(Feb 28 2022 at 12:20)</a>:</h4>
<p>So, I think what you are hinting at, <span class="user-mention" data-user-id="116155">@Jake Goulding</span>, is that being able to name an assoc type with no clause is actually a <em>more general</em> definition than what the trait requires, and thus, it should be compatible with that narrower version.</p>
<p>Similarly to</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span><span class="o">&lt;'</span><span class="na">r</span><span class="o">&gt;</span><span class="w"> </span>: <span class="o">'</span><span class="na">r</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="o">&amp;'</span><span class="na">r</span><span class="w"> </span><span class="bp">self</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;'</span><span class="na">r</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Trait</span><span class="o">&lt;'</span><span class="na">r</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">foo</span><span class="o">&lt;'</span><span class="na">any</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;'</span><span class="na">any</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>compiling.</p>
<p>The trait:</p>
<blockquote>
<p>You must give me an impl able to handle <code>'r</code>.</p>
</blockquote>
<p>The implementor:</p>
<blockquote>
<p>I won't bother with that fine-grained level of detail. Would handling <em>any</em> lifetime suit you?</p>
</blockquote>
<p>The trait:</p>
<blockquote>
<p>Even better!</p>
</blockquote>
<hr>
<p>Back to GATs, the idea of that <code>where Self : 'r</code> bound stems from the trait definition trying to play nice with implementors. Indeed, given</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span> <span class="nf">next</span><span class="o">&lt;'</span><span class="na">r</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="bp">self</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">r</span> <span class="nc">mut</span><span class="w"> </span><span class="bp">Self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">Item</span><span class="o">&lt;'</span><span class="na">r</span><span class="o">&gt;&gt;</span><span class="w"></span>
</code></pre></div>
<p>by virtue of having that <code>&amp;'r … Self</code>, we know that the <code>Self : 'r</code> range will be the only acceptable range / set of applicable lifetimes. So let's at least use that when defining <code>Self::Item&lt;'r&gt;</code>. Indeed, imagine an "identity lending iterator":</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">struct</span> <span class="nc">IdentityLendingIterator</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">IdentityLendingIterator</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">It</span><span class="p">;</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">LendingIterator</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">It</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">next</span><span class="o">&lt;'</span><span class="na">r</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="bp">self</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">r</span> <span class="nc">mut</span><span class="w"> </span><span class="n">It</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span>-&gt; <span class="nb">Option</span><span class="o">&lt;&amp;'</span><span class="na">r</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">It</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="c1">// where</span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Item</span><span class="o">&lt;'</span><span class="na">r</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;'</span><span class="na">r</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">It</span><span class="p">;</span><span class="w"> </span><span class="c1">// Error, can't name `&amp;'r mut It` if you can't guarantee that `It : 'r` holds.</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>But, obviously, given the <code>fn next</code> usage, <em>we could guarantee it</em>! Hence why the trait definition is able to <em>provide</em> <code>where Self : 'r</code> as a bonus / gift.</p>
<p>The issue then stems from the fact that this <em>gift</em> suddenly becomes a mandatory one for downstream implementors to mention, even for those who don't need that extra property.</p>
<p><strong>Given the <code>Trait&lt;'r&gt;</code> example above, it would make sense for the <code>where Self : 'r</code> kind of clauses not to be <em>necessary</em> either, by providing a <em>more general</em> (generic) associated type definition</strong>; (make it be needed only when the associated type itself makes use of it for WF-ness).</p>



<a name="273487685"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/When%20do%20GATs%20implementations%20need%20%60Self%3A%20%27a%60%3F/near/273487685" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake Goulding <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/When.20do.20GATs.20implementations.20need.20.60Self.3A.20&#x27;a.60.3F.html#273487685">(Feb 28 2022 at 13:25)</a>:</h4>
<p>Ah, nothing that intelligent from me. I mean it on a more basic level:</p>
<ul>
<li>my trait’s associated type has <code>Self: 'a</code></li>
<li>not all implementations need to restate that bound</li>
</ul>
<p>I understand that we are being conservative in requiring the bounds when we don’t strictly need it. </p>
<p>What I’m missing: what are the conditions where I <strong>don’t</strong> need to restate the bound?</p>



<a name="273489542"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/When%20do%20GATs%20implementations%20need%20%60Self%3A%20%27a%60%3F/near/273489542" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> LegionMammal978 <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/When.20do.20GATs.20implementations.20need.20.60Self.3A.20&#x27;a.60.3F.html#273489542">(Feb 28 2022 at 13:40)</a>:</h4>
<p>So you're saying that repeating an explicit <code>where</code> bound could be unnecessary when it is covered by a bound implied by the <code>impl</code> or <code>type</code> declaration?</p>



<a name="273489894"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/When%20do%20GATs%20implementations%20need%20%60Self%3A%20%27a%60%3F/near/273489894" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> LegionMammal978 <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/When.20do.20GATs.20implementations.20need.20.60Self.3A.20&#x27;a.60.3F.html#273489894">(Feb 28 2022 at 13:43)</a>:</h4>
<p>I'd be somewhat wary of that, since implied bounds seem somewhat fragile currently (e.g., with <a href="https://github.com/rust-lang/rust/issues/25860">rust-lang/rust#25860</a>)</p>



<a name="273490691"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/When%20do%20GATs%20implementations%20need%20%60Self%3A%20%27a%60%3F/near/273490691" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake Goulding <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/When.20do.20GATs.20implementations.20need.20.60Self.3A.20&#x27;a.60.3F.html#273490691">(Feb 28 2022 at 13:49)</a>:</h4>
<p>My current mental model is: we don’t need to restate <code>Self: 'a</code> when the implementing type doesn’t have generics.</p>



<a name="273520525"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/When%20do%20GATs%20implementations%20need%20%60Self%3A%20%27a%60%3F/near/273520525" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/When.20do.20GATs.20implementations.20need.20.60Self.3A.20&#x27;a.60.3F.html#273520525">(Feb 28 2022 at 17:00)</a>:</h4>
<p>I think there are two similar but different questions here: When/why do we need <code>Self: 'a</code> bounds in the <em>trait</em> and when/why do we need <code>Self: 'a</code> bounds in the <em>impl</em></p>



<a name="273520791"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/When%20do%20GATs%20implementations%20need%20%60Self%3A%20%27a%60%3F/near/273520791" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/When.20do.20GATs.20implementations.20need.20.60Self.3A.20&#x27;a.60.3F.html#273520791">(Feb 28 2022 at 17:01)</a>:</h4>
<p>For the first question, the answer is: We require bounds that are provable when constructing the GAT in the methods of the trait. (So, if you have <code>fn foo(&amp;'a self) -&gt; Self::Gat&lt;'a&gt;</code> then we require <code>Self: 'a</code>)</p>



<a name="273520997"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/When%20do%20GATs%20implementations%20need%20%60Self%3A%20%27a%60%3F/near/273520997" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/When.20do.20GATs.20implementations.20need.20.60Self.3A.20&#x27;a.60.3F.html#273520997">(Feb 28 2022 at 17:02)</a>:</h4>
<p>This is done to give "maximum" flexibility to impls in decided what types can be chosen</p>



<a name="273521106"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/When%20do%20GATs%20implementations%20need%20%60Self%3A%20%27a%60%3F/near/273521106" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/When.20do.20GATs.20implementations.20need.20.60Self.3A.20&#x27;a.60.3F.html#273521106">(Feb 28 2022 at 17:03)</a>:</h4>
<p>Any bounds on the trait must be repeated on the impl when without them you cannot prove the bounds on trait.</p>



<a name="273521245"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/When%20do%20GATs%20implementations%20need%20%60Self%3A%20%27a%60%3F/near/273521245" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/When.20do.20GATs.20implementations.20need.20.60Self.3A.20&#x27;a.60.3F.html#273521245">(Feb 28 2022 at 17:04)</a>:</h4>
<p>In theory, we could "imply" these - but like with <code>unsafe</code> in impls, we might want to one day allow omitting these requirements in impls</p>



<a name="273523646"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/When%20do%20GATs%20implementations%20need%20%60Self%3A%20%27a%60%3F/near/273523646" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/When.20do.20GATs.20implementations.20need.20.60Self.3A.20&#x27;a.60.3F.html#273523646">(Feb 28 2022 at 17:22)</a>:</h4>
<p><span class="user-mention" data-user-id="116155">@Jake Goulding</span> you <em>currently</em> don't need to repeat the <code>where Self : 'a</code> bounds when, for a given concrete impl, <code>Self</code> is some type that is known to be <code>'static</code>. Indeed, in that case <code>Self : 'a</code> holds for literally any lifetime, and thus becomes a trivial(ly true) bound.</p>
<p>In my previous comment, I advocated for the bound technically not being necessary when the actually provided GAT does not make use of the bound, <em>e.g.</em>, when the stuff behind <code>'a</code> (if any) is already known to be usable-within-<code>'a</code> (<em>e.g.</em>, <code>u32</code>, or <code>&amp;'a str</code>).</p>
<p>Finally, for when the bound is both non-trivial, and used (<em>e.g.</em>, <code>&amp;'a Self</code> assoc type, for a not-ncessarily-<code>'static</code> <code>Self</code>), there is the case of "if the trait provides the bound, why is it necessary for the downstream impl to repeat it". I know that Rust, in general, often requires that kind of repetitions, even outside of GATs, so I don't see them being elidable in this situation.</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>