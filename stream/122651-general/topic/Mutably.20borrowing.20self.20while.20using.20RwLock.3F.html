<html>
<head><meta charset="utf-8"><title>Mutably borrowing self while using RwLock? · general · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/122651-general/index.html">general</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Mutably.20borrowing.20self.20while.20using.20RwLock.3F.html">Mutably borrowing self while using RwLock?</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="260402144"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Mutably%20borrowing%20self%20while%20using%20RwLock%3F/near/260402144" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Leany <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Mutably.20borrowing.20self.20while.20using.20RwLock.3F.html#260402144">(Nov 05 2021 at 13:05)</a>:</h4>
<p>I think <code>&amp;mut</code> should only be used if it's needed. It doesn't look like it's needed here. The effect of using <code>&amp;mut</code> would be to force the caller to have exclusive access to the <code>State</code>, which doesn't seem necessary since the locked data is the only field. However, if you plan to add more fields outside the lock then you might want to consider if this function will need exclusive access to the new fields.</p>



<a name="260404746"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Mutably%20borrowing%20self%20while%20using%20RwLock%3F/near/260404746" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Marcin Mielniczuk <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Mutably.20borrowing.20self.20while.20using.20RwLock.3F.html#260404746">(Nov 05 2021 at 13:27)</a>:</h4>
<p>We don't need exclusive access at all. What we thought about was to use <code>&amp;mut</code> to ensure const-correctness.</p>



<a name="260405659"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Mutably%20borrowing%20self%20while%20using%20RwLock%3F/near/260405659" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joshua Nelson <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Mutably.20borrowing.20self.20while.20using.20RwLock.3F.html#260405659">(Nov 05 2021 at 13:36)</a>:</h4>
<p>I'm not sure what "const-correctness" means in this case. The compiler already enforces that you can't modify an immutable reference.</p>



<a name="260410548"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Mutably%20borrowing%20self%20while%20using%20RwLock%3F/near/260410548" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Leany <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Mutably.20borrowing.20self.20while.20using.20RwLock.3F.html#260410548">(Nov 05 2021 at 14:15)</a>:</h4>
<p>Generally, the correct thing is to not give mutable access when shared (non-<code>mut</code>) access will suffice. The point of interior mutability is to allow shared access to the container, meaning that <code>mut</code> isn't required. In summary, I think you should probably stick with the shared reference since you don't need exclusive access.</p>



<a name="260412520"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Mutably%20borrowing%20self%20while%20using%20RwLock%3F/near/260412520" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Marcin Mielniczuk <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Mutably.20borrowing.20self.20while.20using.20RwLock.3F.html#260412520">(Nov 05 2021 at 14:30)</a>:</h4>
<p><span class="user-mention" data-user-id="232545">@Joshua Nelson</span> the point here is that if I initialize the state as <code>let state = State::default()</code>, then the compiler should reject the call <code>state.update_data(...)</code> since <code>state</code> is an immutable variable and <code>update_data</code> mutates the state.</p>



<a name="260413033"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Mutably%20borrowing%20self%20while%20using%20RwLock%3F/near/260413033" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joshua Nelson <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Mutably.20borrowing.20self.20while.20using.20RwLock.3F.html#260413033">(Nov 05 2021 at 14:35)</a>:</h4>
<p><span class="user-mention" data-user-id="455523">@Marcin Mielniczuk</span> <a href="https://docs.rs/dtolnay/0.0.9/dtolnay/macro._02__reference_types.html">https://docs.rs/dtolnay/0.0.9/dtolnay/macro._02__reference_types.html</a></p>



<a name="260416823"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Mutably%20borrowing%20self%20while%20using%20RwLock%3F/near/260416823" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Marcin Mielniczuk <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Mutably.20borrowing.20self.20while.20using.20RwLock.3F.html#260416823">(Nov 05 2021 at 15:01)</a>:</h4>
<p><span class="user-mention" data-user-id="232545">@Joshua Nelson</span> Thanks. With this understanding, using <code>&amp;self</code> seems a perfect fit; however, if we understand <code>&amp;</code>/<code>&amp;mut</code> as shared/exclusive references, then it means that Rust doesn't really have a way to ensure const-correctness of methods.</p>



<a name="260417451"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Mutably%20borrowing%20self%20while%20using%20RwLock%3F/near/260417451" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joshua Nelson <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Mutably.20borrowing.20self.20while.20using.20RwLock.3F.html#260417451">(Nov 05 2021 at 15:06)</a>:</h4>
<p>That is true, there is no way to enforce that a type doesn't have interior mutability.</p>



<a name="260422099"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Mutably%20borrowing%20self%20while%20using%20RwLock%3F/near/260422099" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Mutably.20borrowing.20self.20while.20using.20RwLock.3F.html#260422099">(Nov 05 2021 at 15:41)</a>:</h4>
<p>Hrm, with auto traits that should be possible, no?</p>



<a name="260422170"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Mutably%20borrowing%20self%20while%20using%20RwLock%3F/near/260422170" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joshua Nelson <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Mutably.20borrowing.20self.20while.20using.20RwLock.3F.html#260422170">(Nov 05 2021 at 15:41)</a>:</h4>
<p><span class="user-mention" data-user-id="330154">@The 8472</span> I'm not sure that actually meets their goal though - they have a function that takes <code>&amp;self</code> and they want to prevent calling it only in certain contexts</p>



<a name="260663276"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Mutably%20borrowing%20self%20while%20using%20RwLock%3F/near/260663276" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Mutably.20borrowing.20self.20while.20using.20RwLock.3F.html#260663276">(Nov 08 2021 at 14:26)</a>:</h4>
<p>"<code>const</code>-correctness", here, would have to be encoded/expressed by having descriptive names and/or descriptive docs, since, indeed, contrary to popular's belief / what the Rust book says, <code>&amp;</code> and <code>&amp;mut</code> do not have the semantics of  immutable and mutable references, respectively, but the semantics of shared and exclusive references. The latter is a stronger property than that of mutability, so it entails it, but the former has to interact with the question of shared mutability to know if it is an immutable reference or not.</p>
<p>In this instance, given that you have <em>shared ownership</em> over the data, and that the <code>State</code> is thus just a "handle", unique access to a shared ownership is an oxymoron, and you should thus just be featuring <code>&amp;</code>-based APIs.</p>
<p>If you really wanted <code>const</code>-correctness, you could express in the docs that your type has no shared mutability over the meaningful data it contains, and make the <code>Arc&lt;RwLock&lt;&gt;&gt;</code> layer be added by users of your type. That way, on top of <code>&amp;mut</code> = unique/exclusive =&gt; mutable ref, you'd have "back" the idea that <code>&amp;</code> =&gt; immutable thanks to the lack of shared ownership.</p>
<p>Generally, the latter pattern is common for (some) public types, whereas the former (<code>Arc&lt;RwLock&lt;&gt;&gt;</code> inside) is very common for private types, as a way to reduce boilerplate when that private type is shared all around <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>