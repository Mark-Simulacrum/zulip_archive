<html>
<head><meta charset="utf-8"><title>Writing an instance for a `Fn` trait · general · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/122651-general/index.html">general</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Writing.20an.20instance.20for.20a.20.60Fn.60.20trait.html">Writing an instance for a `Fn` trait</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="273980238"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Writing%20an%20instance%20for%20a%20%60Fn%60%20trait/near/273980238" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Writing.20an.20instance.20for.20a.20.60Fn.60.20trait.html#273980238">(Mar 03 2022 at 14:28)</a>:</h4>
<p>Hi! I'm hitting an issue when trying to write a trait impl for a type which implements <code>FnOnce</code> because the arguments are unconstrained.</p>
<p>Specifically, I have a trait:</p>
<div class="codehilite"><pre><span></span><code>trait Resolve {
  fn resolve(self) -&gt; bool;
}
</code></pre></div>
<p>I would like to write the following impl:</p>
<div class="codehilite"><pre><span></span><code>impl &lt;A, F : FnOnce&lt;A&gt;&gt; Resolve for F {
...
}
</code></pre></div>
<p>But I get :</p>
<div class="codehilite"><pre><span></span><code>error[E0207]: the type parameter `Args` is not constrained by the impl trait, self type, or predicates
  --&gt; creusot-contracts/src/std/fun.rs:75:6
   |
75 | impl&lt;Args, F : FnOnce&lt;Args&gt;&gt; crate::Resolve for F {
   |      ^^^^ unconstrained type parameter
</code></pre></div>
<p>Which makes <em>sense</em>, in that I understand I'm what rule I'm breaking and how but I can't think of a way to work around it</p>



<a name="273980460"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Writing%20an%20instance%20for%20a%20%60Fn%60%20trait/near/273980460" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Writing.20an.20instance.20for.20a.20.60Fn.60.20trait.html#273980460">(Mar 03 2022 at 14:30)</a>:</h4>
<p>This is rather frustrating as, in general it also seems to mean writing instances for <code>Fn</code> types is impossible?</p>



<a name="273980761"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Writing%20an%20instance%20for%20a%20%60Fn%60%20trait/near/273980761" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Writing.20an.20instance.20for.20a.20.60Fn.60.20trait.html#273980761">(Mar 03 2022 at 14:32)</a>:</h4>
<p>i really wish i could just write instances for closure types directly....</p>



<a name="273983982"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Writing%20an%20instance%20for%20a%20%60Fn%60%20trait/near/273983982" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> detrumi <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Writing.20an.20instance.20for.20a.20.60Fn.60.20trait.html#273983982">(Mar 03 2022 at 14:55)</a>:</h4>
<p>This might work?</p>
<div class="codehilite"><pre><span></span><code>trait Resolve&lt;A = Self&gt; {
  fn resolve(self) -&gt; bool;
}
impl &lt;A, F : FnOnce(A) -&gt; ()&gt; Resolve&lt;A&gt; for F {
    fn resolve(self) -&gt; bool { true }
}
</code></pre></div>



<a name="273984510"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Writing%20an%20instance%20for%20a%20%60Fn%60%20trait/near/273984510" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> detrumi <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Writing.20an.20instance.20for.20a.20.60Fn.60.20trait.html#273984510">(Mar 03 2022 at 14:58)</a>:</h4>
<p>(maybe with <code>resolve(a: A)</code> instead so it makes more sense)</p>



<a name="273987438"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Writing%20an%20instance%20for%20a%20%60Fn%60%20trait/near/273987438" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Writing.20an.20instance.20for.20a.20.60Fn.60.20trait.html#273987438">(Mar 03 2022 at 15:19)</a>:</h4>
<p>i'd rather not change the trait artificially, especially since its defined for many other types than functions</p>



<a name="273987471"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Writing%20an%20instance%20for%20a%20%60Fn%60%20trait/near/273987471" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Writing.20an.20instance.20for.20a.20.60Fn.60.20trait.html#273987471">(Mar 03 2022 at 15:19)</a>:</h4>
<p>(in fact it should be defined for every rust type)</p>



<a name="273987517"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Writing%20an%20instance%20for%20a%20%60Fn%60%20trait/near/273987517" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Writing.20an.20instance.20for.20a.20.60Fn.60.20trait.html#273987517">(Mar 03 2022 at 15:20)</a>:</h4>
<p>but I suppose if its unavoidable...</p>



<a name="274005571"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Writing%20an%20instance%20for%20a%20%60Fn%60%20trait/near/274005571" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Writing.20an.20instance.20for.20a.20.60Fn.60.20trait.html#274005571">(Mar 03 2022 at 17:15)</a>:</h4>
<p>So, the issue is that closures can technically be overloaded: you could have <code>F : FnOnce() + FnOnce(i32)</code>, for instance.</p>
<p>While that example is contrived and can currently only be featured on nightly, using manual impls, on stable Rust we have overloaded <code>FnOnce</code> impls the moment we have a higher-order signature:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">F</span><span class="w"> </span>: <span class="nb">FnOnce</span><span class="p">(</span><span class="o">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"></span>
<span class="c1">// i.e.</span>
<span class="k">for</span><span class="o">&lt;'</span><span class="na">any</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">    </span><span class="n">F</span><span class="w"> </span>: <span class="nb">FnOnce</span><span class="p">(</span><span class="o">&amp;'</span><span class="na">any</span><span class="w"> </span><span class="kt">str</span><span class="p">)</span><span class="w"></span>
<span class="p">,</span><span class="w"></span>
</code></pre></div>
<p>is actually an infinite range of concrete <code>FnOnce(&amp;'any str)</code> impls that <code>F</code> meets.</p>
<hr>
<p>If what you need is for the trait to be implemented at least once, I think you'd need to use a <code>#[marker]</code> trait, using the unstable <code>market_trait_attr</code> feature:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="cp">#[marker]</span><span class="w"></span>
<span class="k">trait</span><span class="w"> </span><span class="n">IsSomeFnOnce</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">Args</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="w"> </span>: <span class="o">?</span><span class="nb">Sized</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">FnOnce</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">IsSomeFnOnce</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">F</span><span class="w"> </span>: <span class="nc">IsSomeFnOnce</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Resolve</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
</code></pre></div>
<p>But:</p>
<ul>
<li><code>#[marker]</code> traits, for some reason, can't handle unconstrained params yet (<em>that is silly</em>);</li>
<li>you'd, in practice, encounter a lot of blanket impl issues with that <code>F : IsSomeFnOnce</code>, since you can't tell the coherence checker the "reverse" condition for <code>IsSomeFnOnce</code>.</li>
</ul>



<a name="274011863"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Writing%20an%20instance%20for%20a%20%60Fn%60%20trait/near/274011863" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> LegionMammal978 <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Writing.20an.20instance.20for.20a.20.60Fn.60.20trait.html#274011863">(Mar 03 2022 at 17:55)</a>:</h4>
<p>If <code>Resolve</code> is defined for many non-function types, then how would it even be possible to add such a blanket impl? After all, other impls can't use negative reasoning to assert the type is not <code>FnOnce</code></p>



<a name="274020545"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Writing%20an%20instance%20for%20a%20%60Fn%60%20trait/near/274020545" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Writing.20an.20instance.20for.20a.20.60Fn.60.20trait.html#274020545">(Mar 03 2022 at 18:55)</a>:</h4>
<p>It can since the <code>Fn</code> traits are <code>#[fundamental]</code>.</p>



<a name="274024932"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Writing%20an%20instance%20for%20a%20%60Fn%60%20trait/near/274024932" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Writing.20an.20instance.20for.20a.20.60Fn.60.20trait.html#274024932">(Mar 03 2022 at 19:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="232018">Daniel Henry-Mantilla</span> <a href="#narrow/stream/122651-general/topic/Writing.20an.20instance.20for.20a.20.60Fn.60.20trait/near/274005571">said</a>:</p>
<blockquote>
<p>So, the issue is that closures can technically be overloaded: you could have <code>F : FnOnce() + FnOnce(i32)</code>, for instance.</p>
<p>While that example is contrived and can currently only be featured on nightly, using manual impls, on stable Rust we have overloaded <code>FnOnce</code> impls the moment we have a higher-order signature:</p>
</blockquote>
<p>Yea, I get that, its the downside of universally quantifying the input parameters. It just particularily sucks because there's no other way to even <em>approximately</em> name a closure type.</p>
<blockquote>
<p>If what you need is for the trait to be implemented at least once, I think you'd need to use a <code>#[marker]</code> trait, using the unstable <code>market_trait_attr</code> feature:<br>
</p>
</blockquote>
<p>Yea, that would be good enough, I just need to be able to give an instance which covers each closure. The 'correct' solution would be one instance per closure type, but that's impossible even with the rustc apis... If i could at least give a blanket impl, then my backend is capable of recognizing it and emitting the correct code secretly..</p>



<a name="274025596"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Writing%20an%20instance%20for%20a%20%60Fn%60%20trait/near/274025596" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Writing.20an.20instance.20for.20a.20.60Fn.60.20trait.html#274025596">(Mar 03 2022 at 19:27)</a>:</h4>
<p>oh my god, I hate zulip's chat window...</p>



<a name="274146697"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Writing%20an%20instance%20for%20a%20%60Fn%60%20trait/near/274146697" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Writing.20an.20instance.20for.20a.20.60Fn.60.20trait.html#274146697">(Mar 04 2022 at 15:40)</a>:</h4>
<p>I found a way to get the result I need using <code>min_specialization</code>, all I have to do is define a default instance for <code>T</code>, and then I can override it for types other than closures</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>