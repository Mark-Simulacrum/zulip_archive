<html>
<head><meta charset="utf-8"><title>Best Practices for porting legacy C · general · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/122651-general/index.html">general</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Best.20Practices.20for.20porting.20legacy.20C.html">Best Practices for porting legacy C</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="250386690"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Best%20Practices%20for%20porting%20legacy%20C/near/250386690" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Larry Dewey <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Best.20Practices.20for.20porting.20legacy.20C.html#250386690">(Aug 23 2021 at 17:49)</a>:</h4>
<p>As Rust does not provide support for bitfield structs, what is the best practice for porting over a C bitfield struct to Rust code? I have been looking at a number of crates (<code>bitfield</code>, <code>modular-bitfield</code>, etc.), but the approaches all seem quite bloated or heavy (maybe I am too much of a minimalist). Are these crates what is currently recommended, or is there another approach which is better?</p>



<a name="250386862"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Best%20Practices%20for%20porting%20legacy%20C/near/250386862" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Laurențiu <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Best.20Practices.20for.20porting.20legacy.20C.html#250386862">(Aug 23 2021 at 17:50)</a>:</h4>
<p><span class="user-mention" data-user-id="232545">@Joshua Nelson</span> bitfields aren't flags</p>



<a name="250386925"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Best%20Practices%20for%20porting%20legacy%20C/near/250386925" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joshua Nelson <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Best.20Practices.20for.20porting.20legacy.20C.html#250386925">(Aug 23 2021 at 17:51)</a>:</h4>
<p>Oh oh I was confused</p>



<a name="250387164"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Best%20Practices%20for%20porting%20legacy%20C/near/250387164" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Larry Dewey <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Best.20Practices.20for.20porting.20legacy.20C.html#250387164">(Aug 23 2021 at 17:53)</a>:</h4>
<p><span class="user-mention" data-user-id="232545">@Joshua Nelson</span> I did look at those for another solution, but as <span class="user-mention" data-user-id="203546">@Laurențiu</span> mentioned, bitfields aren't quite the same thing.</p>



<a name="250387362"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Best%20Practices%20for%20porting%20legacy%20C/near/250387362" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Laurențiu <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Best.20Practices.20for.20porting.20legacy.20C.html#250387362">(Aug 23 2021 at 17:55)</a>:</h4>
<p>What do you mean by bloated and heavy?</p>



<a name="250388129"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Best%20Practices%20for%20porting%20legacy%20C/near/250388129" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Larry Dewey <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Best.20Practices.20for.20porting.20legacy.20C.html#250388129">(Aug 23 2021 at 18:01)</a>:</h4>
<p><span class="user-mention" data-user-id="203546">@Laurențiu</span> lots of boilerplate implementations which look to mimic the behavior, many of them dramatically changing the behavior you would find in C. I understand that Rust makes things much safer, but it seems like a pretty important feature which is currently missing from the core language. After reading a number of threads, I recognize the teams desire to make all code portable between different architectures in Rust, but blacklisting a feature due to portability seems a bit extreme. It also is inconsistent with previously implemented features in the standard library which are unique implementations for individual operating systems, etc.</p>



<a name="250388335"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Best%20Practices%20for%20porting%20legacy%20C/near/250388335" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Larry Dewey <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Best.20Practices.20for.20porting.20legacy.20C.html#250388335">(Aug 23 2021 at 18:02)</a>:</h4>
<p>That being said, I am probably missing something, and recognize there might be a much better way to approach manipulating registers. Thus my question <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="250388613"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Best%20Practices%20for%20porting%20legacy%20C/near/250388613" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Laurențiu <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Best.20Practices.20for.20porting.20legacy.20C.html#250388613">(Aug 23 2021 at 18:05)</a>:</h4>
<p><code>modular-bitfield</code> looks reasonable unless you want to avoid proc macros.</p>



<a name="250388835"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Best%20Practices%20for%20porting%20legacy%20C/near/250388835" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Laurențiu <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Best.20Practices.20for.20porting.20legacy.20C.html#250388835">(Aug 23 2021 at 18:07)</a>:</h4>
<p>I wouldn't call this "blacklisting a feature". It's not available yet. It can still be proposed (like in <a href="https://github.com/rust-lang/rfcs/pull/3113">https://github.com/rust-lang/rfcs/pull/3113</a>), and there is a chance that the proposal will be accepted, but there's probably a high bar of entry.</p>



<a name="250389080"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Best%20Practices%20for%20porting%20legacy%20C/near/250389080" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Best.20Practices.20for.20porting.20legacy.20C.html#250389080">(Aug 23 2021 at 18:09)</a>:</h4>
<p>If you have C headers afaik bindgen can generate wrapper structs that provide equivalent APIs. But that's not exactly minimal either.</p>



<a name="250389207"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Best%20Practices%20for%20porting%20legacy%20C/near/250389207" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Laurențiu <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Best.20Practices.20for.20porting.20legacy.20C.html#250389207">(Aug 23 2021 at 18:10)</a>:</h4>
<p>Specifically for registers, I'd look at the <code>cortex-m</code> ecosystem. It uses the <code>volatile-register</code> crate, which has some wrappers over registers to provide a <code>modify</code> operation.</p>



<a name="250400563"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Best%20Practices%20for%20porting%20legacy%20C/near/250400563" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Larry Dewey <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Best.20Practices.20for.20porting.20legacy.20C.html#250400563">(Aug 23 2021 at 19:34)</a>:</h4>
<p><span class="user-mention" data-user-id="203546">@Laurențiu</span> I appreciate the approach <code>modular-bitfield</code> took, but it doesn't provide an easy way to mix with primitive data types outside of the pre-defined bit types (B1-B64). An example of what I mean:</p>
<div class="codehilite"><pre><span></span><code>typedef struct some_example_t
{
    uint64_t a;
    uint8_t b[8];    &lt;--- porting over this in Rust while also using bit types.
    uint64_t c; // reserved
    uint64_t d; // reserved
    uint32_t e : 1;
    uint32_t f : 2;
    uint32_t g : 29;
} some_example;
</code></pre></div>



<a name="250401003"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Best%20Practices%20for%20porting%20legacy%20C/near/250401003" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joshua Nelson <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Best.20Practices.20for.20porting.20legacy.20C.html#250401003">(Aug 23 2021 at 19:38)</a>:</h4>
<p>would <code>#[bitfield] struct B8Array([u8; 8]);</code> work?</p>



<a name="250401228"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Best%20Practices%20for%20porting%20legacy%20C/near/250401228" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Best.20Practices.20for.20porting.20legacy.20C.html#250401228">(Aug 23 2021 at 19:40)</a>:</h4>
<p>I think that example would have a rust type of</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">struct</span> <span class="nc">SomeExample</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">a</span>: <span class="kt">u64</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">b</span>: <span class="p">[</span><span class="kt">u8</span><span class="p">;</span><span class="w"> </span><span class="mi">8</span><span class="p">],</span><span class="w"></span>
<span class="w">    </span><span class="n">c</span>: <span class="kt">u64</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">d</span>: <span class="kt">u64</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">efg</span>: <span class="kt">u32</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>and the rest is made up with macro magic from a library like <code>#[bitfield]</code></p>



<a name="250401338"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Best%20Practices%20for%20porting%20legacy%20C/near/250401338" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Larry Dewey <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Best.20Practices.20for.20porting.20legacy.20C.html#250401338">(Aug 23 2021 at 19:41)</a>:</h4>
<p><span class="user-mention" data-user-id="271719">@Mario Carneiro</span>  I tried that, but received:</p>
<p>Error: the trait bound <code>[u8; 8]: Specifier</code> is not satisfied.</p>



<a name="250401376"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Best%20Practices%20for%20porting%20legacy%20C/near/250401376" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Stephen Crane <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Best.20Practices.20for.20porting.20legacy.20C.html#250401376">(Aug 23 2021 at 19:41)</a>:</h4>
<p>we ran into similar issues with bitfield crates a couple years ago, so maybe this would be a useful resource for you? <a href="https://immunant.com/blog/2020/01/bitfields/">https://immunant.com/blog/2020/01/bitfields/</a> Not sure if the c2rust crate does exactly what you need, but I think it might.</p>



<a name="250401437"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Best%20Practices%20for%20porting%20legacy%20C/near/250401437" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Best.20Practices.20for.20porting.20legacy.20C.html#250401437">(Aug 23 2021 at 19:42)</a>:</h4>
<p>The type being magicked here is <code>efg: u32</code></p>



<a name="250401507"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Best%20Practices%20for%20porting%20legacy%20C/near/250401507" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Best.20Practices.20for.20porting.20legacy.20C.html#250401507">(Aug 23 2021 at 19:42)</a>:</h4>
<p>so you would have <code>efg: MyU32Bitfield</code> where some macro defines <code>MyU32Bitfield</code></p>



<a name="250401585"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Best%20Practices%20for%20porting%20legacy%20C/near/250401585" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Best.20Practices.20for.20porting.20legacy.20C.html#250401585">(Aug 23 2021 at 19:43)</a>:</h4>
<p>and since the repr of this type is just a plain <code>u32</code> you shouldn't have issues with <code>Specifier</code> (I don't know much about the <code>modular-bitfield</code> crate though so I might be off base for the intended usage)</p>



<a name="250401816"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Best%20Practices%20for%20porting%20legacy%20C/near/250401816" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Stephen Crane <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Best.20Practices.20for.20porting.20legacy.20C.html#250401816">(Aug 23 2021 at 19:45)</a>:</h4>
<p>Nesting the bitfield field as a struct itself? I think that would work, although it's a bit cumbersome</p>



<a name="250401972"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Best%20Practices%20for%20porting%20legacy%20C/near/250401972" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Best.20Practices.20for.20porting.20legacy.20C.html#250401972">(Aug 23 2021 at 19:46)</a>:</h4>
<p>It sounds reasonable for a bitfield crate to support structs containing "foreign" fields with no constraints, but that might be technically difficult for the macro implementation</p>



<a name="250402189"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Best%20Practices%20for%20porting%20legacy%20C/near/250402189" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Best.20Practices.20for.20porting.20legacy.20C.html#250402189">(Aug 23 2021 at 19:48)</a>:</h4>
<p>But I think that it would be a bad idea for this to be integrated into the language the way it is in C/C++. It adds <em>way</em> too much complication to the spec, since the concept of what a field is gets very muddy</p>



<a name="250402259"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Best%20Practices%20for%20porting%20legacy%20C/near/250402259" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Best.20Practices.20for.20porting.20legacy.20C.html#250402259">(Aug 23 2021 at 19:48)</a>:</h4>
<p>Even if it gets some sugar, it should never be more than that</p>



<a name="250404569"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Best%20Practices%20for%20porting%20legacy%20C/near/250404569" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Thom Chiovoloni <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Best.20Practices.20for.20porting.20legacy.20C.html#250404569">(Aug 23 2021 at 20:07)</a>:</h4>
<p>yeah the number of places bitfields need special casing in the c++ standard is... a bit much lol</p>



<a name="250429487"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Best%20Practices%20for%20porting%20legacy%20C/near/250429487" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Best.20Practices.20for.20porting.20legacy.20C.html#250429487">(Aug 24 2021 at 00:27)</a>:</h4>
<p>for this, i just newtype and in and use getter/setter stuff. I don't even use proc-macros, this sort of code is usually made once and then doesn't change because it's baked into hardware, so proc-macros aren't useful.</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>