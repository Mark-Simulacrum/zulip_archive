<html>
<head><meta charset="utf-8"><title>Counting enum variants · general · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/122651-general/index.html">general</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Counting.20enum.20variants.html">Counting enum variants</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="269223892"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Counting%20enum%20variants/near/269223892" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Counting.20enum.20variants.html#269223892">(Jan 25 2022 at 08:37)</a>:</h4>
<p>I have an enum with 10 variants, and I want to count how many occurrences of each variant are passed to a function. I can create a <code>Vec&lt;usize&gt;</code> with 10 elements using <code>std::mem::variant_count</code>. If the enum variants don't have any arguments then I can coerce each one to an integer using <code>as</code>. But if one or more of the enum variants have arguments I don't think there's an automatic way to convert the discriminant to the appropriate integer, right? <code>std::mem::Discriminant</code> doesn't have any kind of to-integer conversion.</p>
<p>I guess I can just write my own function for it...</p>



<a name="269227774"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Counting%20enum%20variants/near/269227774" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> lqd <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Counting.20enum.20variants.html#269227774">(Jan 25 2022 at 09:12)</a>:</h4>
<p><span class="user-mention" data-user-id="120989">@nnethercote</span> <code>std::intrinsics::discriminant_value</code> should help</p>



<a name="269229711"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Counting%20enum%20variants/near/269229711" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Counting.20enum.20variants.html#269229711">(Jan 25 2022 at 09:29)</a>:</h4>
<p>How do you convert that to an integer?</p>



<a name="269230526"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Counting%20enum%20variants/near/269230526" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Counting.20enum.20variants.html#269230526">(Jan 25 2022 at 09:36)</a>:</h4>
<p>Oh, I see. It's not clear from the docs, but <code>&lt;T as DiscriminantKind&gt;::Discriminant</code> appears in practice to be... an <code>isize</code> O_o</p>



<a name="269230535"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Counting%20enum%20variants/near/269230535" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Counting.20enum.20variants.html#269230535">(Jan 25 2022 at 09:36)</a>:</h4>
<p>I wouldn't have predicted that, I would have guessed <code>usize</code></p>



<a name="269233005"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Counting%20enum%20variants/near/269233005" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Counting.20enum.20variants.html#269233005">(Jan 25 2022 at 09:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120989">nnethercote</span> <a href="#narrow/stream/122651-general/topic/Counting.20enum.20variants/near/269230526">said</a>:</p>
<blockquote>
<p>Oh, I see. It's not clear from the docs, but <code>&lt;T as DiscriminantKind&gt;::Discriminant</code> appears in practice to be... an <code>isize</code> O_o</p>
</blockquote>
<p>I've gotten ICEs making by making this assumption, I don't think it's always true. I think maybe its <code>#[repr(DifferentType)]</code> that is the cause of issues? Not sure though</p>



<a name="269237133"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Counting%20enum%20variants/near/269237133" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Counting.20enum.20variants.html#269237133">(Jan 25 2022 at 10:31)</a>:</h4>
<p>The type exists to hide the actual type, this is very intentional.</p>



<a name="269251929"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Counting%20enum%20variants/near/269251929" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Counting.20enum.20variants.html#269251929">(Jan 25 2022 at 12:53)</a>:</h4>
<p><span class="user-mention" data-user-id="120989">@nnethercote</span> doesn't a <code>Vec&lt;Discriminant&lt;YourEnum&gt;&gt;</code> work for you? If you <em>really</em> need an integer, you could use its <code>Hash</code> impl</p>



<a name="269254850"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Counting%20enum%20variants/near/269254850" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Counting.20enum.20variants.html#269254850">(Jan 25 2022 at 13:17)</a>:</h4>
<p>I want a <code>Vec&lt;usize&gt;</code> with a length that matches the variant count, and index into it based on the integer value of the discriminant</p>



<a name="269254977"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Counting%20enum%20variants/near/269254977" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Counting.20enum.20variants.html#269254977">(Jan 25 2022 at 13:18)</a>:</h4>
<p>And I could use <code>Hash</code> and a hash table, that's just suboptimal when there is an obvious mapping for each variant to 0..n</p>



<a name="269257745"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Counting%20enum%20variants/near/269257745" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Counting.20enum.20variants.html#269257745">(Jan 25 2022 at 13:42)</a>:</h4>
<p>You could use <code>#[repr(u8)]</code> and then <code>unsafe { *(self as *const Self as *const u8) }</code> as suggested by <a href="https://rust-lang.github.io/rfcs/2363-arbitrary-enum-discriminant.html">rfc 2363</a>.</p>



<a name="269296569"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Counting%20enum%20variants/near/269296569" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Counting.20enum.20variants.html#269296569">(Jan 25 2022 at 17:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120989">nnethercote</span> <a href="#narrow/stream/122651-general/topic/Counting.20enum.20variants/near/269254977">said</a>:</p>
<blockquote>
<p>And I could use <code>Hash</code> and a hash table, that's just suboptimal when there is an obvious mapping for each variant to 0..n</p>
</blockquote>
<p>Well, the point seems to be that that mapping is currently unstable, hence the opaque layer. If you feel confident about extracting a <code>u64</code>, potentially lossily, I'd suggest still taking advantage of <code>Hash</code>:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="cp">#[inline]</span><span class="w"></span>
<span class="k">fn</span> <span class="nf">to_u64</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">d</span>: ::<span class="n">core</span>::<span class="n">mem</span>::<span class="n">Discriminant</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span>-&gt; <span class="kt">u64</span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">Hasher</span><span class="p">(</span><span class="kt">u64</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">impl</span><span class="w"> </span>::<span class="n">core</span>::<span class="n">hash</span>::<span class="n">Hasher</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Hasher</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">write_u64</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">n</span>: <span class="kt">u64</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">write</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">d</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"></span>
<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">write_u64</span><span class="p">(</span><span class="kt">u64</span>::<span class="n">from_ne_bytes</span><span class="p">(</span><span class="w"></span>
<span class="w">                </span><span class="n">d</span><span class="p">.</span><span class="n">try_into</span><span class="p">().</span><span class="n">unwrap</span><span class="p">()</span><span class="w"></span>
<span class="w">            </span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="k">fn</span> <span class="nf">finish</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span>-&gt; <span class="kt">u64</span>
        <span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="fm">unimplemented!</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Hasher</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span>::<span class="n">core</span>::<span class="n">hash</span>::<span class="n">Hash</span>::<span class="n">hash</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">h</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">h</span><span class="p">.</span><span class="mi">0</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>It's a way less "stable" approach than, for instance, using a well-defined repr to read the discriminant (since the point of a well-defined repr is to opt-out of future improvements to discriminants), but if you can't use the <code>repr()</code> approach, then this is the only way to extract the integer that I know of.</p>
<p>FWIW, </p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">enum</span> <span class="nc">E</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">s</span>: <span class="kt">u16</span> <span class="p">}}</span><span class="w"></span>

<span class="cp">#[no_mangle]</span><span class="w"></span>
<span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">aaa</span><span class="w"> </span><span class="p">(</span><span class="n">e</span>: <span class="nc">E</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span>-&gt; <span class="kt">u64</span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">to_u64</span><span class="p">(</span>::<span class="n">core</span>::<span class="n">mem</span>::<span class="n">discriminant</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="p">))</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>currently compiles down to:</p>
<div class="codehilite" data-code-language="ActionScript"><pre><span></span><code><span class="nx">aaa</span><span class="o">:</span><span class="w"></span>
<span class="w">        </span><span class="nx">movzx</span><span class="w">   </span><span class="nx">eax</span><span class="o">,</span><span class="w"> </span><span class="nx">di</span><span class="w"></span>
<span class="w">        </span><span class="nx">ret</span><span class="w"></span>
</code></pre></div>
<p>on release.</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>