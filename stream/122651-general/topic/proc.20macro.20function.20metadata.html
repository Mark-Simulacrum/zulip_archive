<html>
<head><meta charset="utf-8"><title>proc macro function metadata · general · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/122651-general/index.html">general</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/proc.20macro.20function.20metadata.html">proc macro function metadata</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="249068988"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/proc%20macro%20function%20metadata/near/249068988" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> devsnek <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/proc.20macro.20function.20metadata.html#249068988">(Aug 11 2021 at 05:03)</a>:</h4>
<p>to work around the lack of variadic generics i was thinking of doing a proc macro that parses the function parameters and stores that info somewhere. i'm just not sure where "somewhere" is. typically i'd use a trait but there's no way to impl a trait for a function item. anyone have any ideas?</p>



<a name="249634013"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/proc%20macro%20function%20metadata/near/249634013" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Kestrer <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/proc.20macro.20function.20metadata.html#249634013">(Aug 16 2021 at 19:15)</a>:</h4>
<p>Is this function only invoked by your macro? If so, you could make it a constant that implements a trait or something.</p>



<a name="249971702"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/proc%20macro%20function%20metadata/near/249971702" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/proc.20macro.20function.20metadata.html#249971702">(Aug 19 2021 at 11:25)</a>:</h4>
<blockquote>
<p>there's no way to impl a trait for a function item</p>
</blockquote>
<p>If the proc macro is the one emitting the function, you can create your own ZST which fakes being a function item; I guess I should probably publish that knowledge / technique as a lib:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="sd">//! Classic well-known case</span>

<span class="sd">/// Instead of:</span>
<span class="k">fn</span> <span class="nf">foo</span><span class="w"> </span><span class="p">(</span><span class="n">arg</span>: <span class="nc">Arg</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span>-&gt; <span class="nc">Ret</span><span class="w"></span>
<span class="p">{</span><span class="w"> </span><span class="err">…</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="c1">// Emit:</span>
<span class="cp">#[derive(Clone, Copy)]</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">foo</span><span class="p">;</span><span class="w"></span>
<span class="k">impl</span><span class="w"> </span>::<span class="n">core</span>::<span class="n">ops</span>::<span class="n">Deref</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">fn</span><span class="p">(</span><span class="n">Arg</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Ret</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">deref</span><span class="w"> </span><span class="p">(</span><span class="bp">self</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="nb">_</span> <span class="nc">foo</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span>-&gt; <span class="nc">Ret</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">FUN</span>: <span class="nc">fn</span><span class="p">(</span><span class="n">Arg</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="n">arg</span>: <span class="nc">Arg</span><span class="o">|</span><span class="w"> </span>-&gt; <span class="nc">Ret</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="err">…</span><span class="w"></span>
<span class="w">        </span><span class="p">};</span><span class="w"></span>
<span class="w">        </span><span class="o">&amp;</span><span class="n">FUN</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cm">/* Now you can do `foo(arg)` without problems, `foo` is a ZST,</span>
<span class="cm">   and can also `impl Stuff for foo */</span><span class="w"></span>
</code></pre></div>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="sd">//! More advanced case: GENERICS.</span>
<span class="sd">/// Instead of:</span>
<span class="k">fn</span> <span class="nf">bar</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">arg</span>: <span class="nc">Arg</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span>-&gt; <span class="nc">Ret</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="err">…</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Emit:</span>
<span class="cp">#[::ghost::phantom]</span><span class="w"> </span><span class="c1">// or inline its implementation</span>
<span class="k">struct</span> <span class="nc">bar</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Clone</span><span class="p">,</span><span class="nb">Copy</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">bar</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="err">…</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span>::<span class="n">core</span>::<span class="n">ops</span>::<span class="n">Deref</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">bar</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="err">…</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="err">…</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span> <span class="nc">GenericConst</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">T</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">GenericConst</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="n">FUN</span>: <span class="nc">fn</span><span class="p">(</span><span class="n">Arg</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Ret</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="n">arg</span>: <span class="nc">Arg</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;|</span><span class="w"> </span>-&gt; <span class="nc">Ret</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="err">…</span><span class="w"></span>
<span class="w">            </span><span class="p">};</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="o">&amp;</span><span class="n">GenericConst</span>::<span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>::<span class="n">FUN</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<ul>
<li>There is one subtlety, though: while the <em>type</em> and <em>constant</em> generic parameters must go on the ZST, I highly recommend that the <em>lifetime</em> generic parameters go on the <code>FUN</code> assoc constant and <code>Deref::Target</code> (by using <code>for&lt;'lifetimes…&gt; fn…</code> syntax). This will ensure the function remains higher order which may be needed to reduce friction / disparity-wrt-a-real-fun to a minimum.</li>
</ul>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>