<html>
<head><meta charset="utf-8"><title>Borrow checking magic · general · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/122651-general/index.html">general</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Borrow.20checking.20magic.html">Borrow checking magic</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="253036539"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Borrow%20checking%20magic/near/253036539" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Borrow.20checking.20magic.html#253036539">(Sep 13 2021 at 04:33)</a>:</h4>
<p>This code breaks my mental model of the borrow checker:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">struct</span> <span class="nc">Foo</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;'</span><span class="na">a</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">]);</span><span class="w"></span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Foo</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[]);</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="n">foo</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vec</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>What is <code>'a</code> set to here? I would have expected this code to be rejected because <code>foo: Foo&lt;'a&gt;</code> outlives <code>vec</code>, and <code>'a</code> is at most the lifetime of <code>vec</code>. I know that polonius (specifically, flow-sensitive lifetimes) can validate this, but how does NLL do it?</p>



<a name="253036847"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Borrow%20checking%20magic/near/253036847" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Gary Guo <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Borrow.20checking.20magic.html#253036847">(Sep 13 2021 at 04:38)</a>:</h4>
<p>It's same as if Foo is just a reference.</p>



<a name="253036859"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Borrow%20checking%20magic/near/253036859" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Gary Guo <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Borrow.20checking.20magic.html#253036859">(Sep 13 2021 at 04:38)</a>:</h4>
<p>If you add <code>Drop</code> to Foo then it'll fail.</p>



<a name="253037217"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Borrow%20checking%20magic/near/253037217" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Gary Guo <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Borrow.20checking.20magic.html#253037217">(Sep 13 2021 at 04:45)</a>:</h4>
<p>And I suppose this example may break your mental model further :D</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">foo</span>: <span class="nb">Vec</span><span class="o">&lt;&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="n">foo</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vec</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>



<a name="253037971"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Borrow%20checking%20magic/near/253037971" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Borrow.20checking.20magic.html#253037971">(Sep 13 2021 at 04:58)</a>:</h4>
<p>oh dear...</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">struct</span> <span class="nc">Foo</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;'</span><span class="na">a</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">]);</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">bla</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">foo</span>: <span class="nc">Foo</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="n">foo</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vec</span><span class="p">;</span><span class="w"> </span><span class="c1">// vec does not live long enough</span>
<span class="p">}</span><span class="w"></span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Foo</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[]);</span><span class="w"></span>
<span class="w">    </span><span class="n">bla</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>



<a name="253041576"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Borrow%20checking%20magic/near/253041576" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Borrow.20checking.20magic.html#253041576">(Sep 13 2021 at 05:59)</a>:</h4>
<p>In that example, the caller can pick any lifetime, so the borrow checker must assume the worst</p>



<a name="253041648"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Borrow%20checking%20magic/near/253041648" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Borrow.20checking.20magic.html#253041648">(Sep 13 2021 at 06:00)</a>:</h4>
<p>When all of the code is in the same function, the borrow checker 'knows' the actual inferred lifetime for <code>'a</code></p>



<a name="253041707"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Borrow%20checking%20magic/near/253041707" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Borrow.20checking.20magic.html#253041707">(Sep 13 2021 at 06:00)</a>:</h4>
<p>As far as I know there is no way to make <code>bla</code> typecheck, no matter what constraints you put on <code>'a</code></p>



<a name="253041745"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Borrow%20checking%20magic/near/253041745" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Borrow.20checking.20magic.html#253041745">(Sep 13 2021 at 06:01)</a>:</h4>
<p>so whatever lifetime <code>foo</code> has, it is not directly expressible in the language</p>



<a name="253041818"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Borrow%20checking%20magic/near/253041818" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Borrow.20checking.20magic.html#253041818">(Sep 13 2021 at 06:02)</a>:</h4>
<p>The caller could pick <code>'static</code>, in which case the reference to the local variable would have too short of a lifetime</p>



<a name="253041850"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Borrow%20checking%20magic/near/253041850" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Borrow.20checking.20magic.html#253041850">(Sep 13 2021 at 06:03)</a>:</h4>
<p>But yeah, you can't express 'the lifetime of this local variable' in the function signature</p>



<a name="253113617"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Borrow%20checking%20magic/near/253113617" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Borrow.20checking.20magic.html#253113617">(Sep 13 2021 at 15:54)</a>:</h4>
<p><span class="user-mention" data-user-id="271719">@Mario Carneiro</span> this is one of things <code>dropck</code> is about: since <code>Foo</code> does not implement drop glue that would dereference the <code>'a</code> reference, you are allowed to have a "dangling <code>foo</code>" by the time it goes out of scope. If you had drop glue, you can, <code>unsafe</code>ly, opt back into this behavior by having a <code>&lt;#[may_dangle] 'a&gt;</code> genericity in the <code>Drop</code> impl.</p>



<a name="253129017"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Borrow%20checking%20magic/near/253129017" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Borrow.20checking.20magic.html#253129017">(Sep 13 2021 at 17:32)</a>:</h4>
<p>While I kind of get the argument for what's going on at drop time with <code>may_dangle</code> and all that, the part that I'm puzzled about is what the lifetime means <em>before</em> the lifetime of <code>vec</code> has started. I can pass <code>foo</code> to other functions just fine before <code>vec</code> is created:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">struct</span> <span class="nc">Foo</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;'</span><span class="na">a</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">]);</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">bar</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span>: <span class="kp">&amp;</span><span class="nc">Foo</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Foo</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[]);</span><span class="w"></span>
<span class="w">    </span><span class="n">bar</span><span class="p">(</span><span class="o">&amp;</span><span class="n">foo</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="n">foo</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vec</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>This isn't just a matter of <code>foo</code> having type <code>Foo&lt;'static&gt;</code> and changing to <code>Foo&lt;'vec&gt;</code> later, because if you change the signature of bar to <code>fn(&amp;Foo&lt;'static&gt;)</code> then it fails. So <code>'a</code> seems to be a valid lifetime, which is both limited to <code>vec</code> but also works before <code>vec</code> is constructed...</p>



<a name="253131254"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Borrow%20checking%20magic/near/253131254" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Borrow.20checking.20magic.html#253131254">(Sep 13 2021 at 17:48)</a>:</h4>
<p>That is, I'm not sure what kind of model of what a lifetime "is" would validate a pattern like this. It makes sense that a borrow checker written with constraints at each program point might allow this kind of "time dependent timeline", but how are we arguing that these lifetimes are sound? Do RustBelt lifetimes handle this?</p>



<a name="253131408"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Borrow%20checking%20magic/near/253131408" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Frank Steffahn <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Borrow.20checking.20magic.html#253131408">(Sep 13 2021 at 17:49)</a>:</h4>
<p>I feel like there’s two separate questions about this code</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">struct</span> <span class="nc">Foo</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;'</span><span class="na">a</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">]);</span><span class="w"></span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Foo</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[]);</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="n">foo</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vec</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<ul>
<li>How can I assign the <code>&amp;vec</code> reference to foo even though <code>foo</code> exists <em>before</em> <code>vec</code> is created? One might think that this is problematic because the reference <code>&amp;vec</code> would need to have type <code>&amp;'a [u8]</code> with the lifetime <code>'a</code> appearing inside of the type of <code>Foo&lt;'a&gt;</code>, too, but the variable <code>foo</code> of type <code>Foor&lt;'a&gt;</code> us already <em>used</em> in the first line of code of <code>main</code>, hence the lifetime contains an area of code where the reference <code>&amp;vec</code> doesn't exist yet, so shouldn't be valid?</li>
<li>How can the reference <code>&amp;vec</code> be assigned to <code>foo</code> even though <code>vec</code> gets dropped <em>before</em> <code>foo</code> does? At the point of time <code>foo</code> is dropped, it's type <code>Foo&lt;'a&gt;</code> has the lifetime of a reference, <code>&amp;vec</code>, that obviously is not valid anymore.</li>
</ul>
<p>The answer to the second question is how dropck works; it doesn't care about an invalidated reference in a struct field when that struct doesn't itself implement <code>Drop</code>.</p>
<p>I <em>think</em> the answer to the first question is (and this is only my intuition, I'm not really knowing any details of the actual implementation): It's not a problem to extend the lifetime of a reference back into time. You can retroactively claim, the reference you've produced has been a valid reference for the last few centuries or before the beginning of the universe, and while that’s weird, I think there's nothing unsound in such a claim. So in my above analysis/explanation of the issue</p>
<blockquote>
<p>the lifetime contains an area of code where the reference <code>&amp;vec</code> doesn't exist yet, so shouldn't be valid</p>
</blockquote>
<p>this conclusion is simply wrong: it <em>is valid</em>; the lifetime of a reference <em>can</em> include lines of code from before the reference was first created.</p>
<p>Ultimately lifetime analysis is for avoiding use of references <em>after</em> they become invalid. Using references <em>before</em> they're first created is impossible for the same reason you can't print a number before you calculate it, the borrow checker doesn't need to do any additional enforcing in that direction.</p>



<a name="253131866"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Borrow%20checking%20magic/near/253131866" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Frank Steffahn <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Borrow.20checking.20magic.html#253131866">(Sep 13 2021 at 17:52)</a>:</h4>
<p>Ah, now you've made the distinction yourself while I was writing this post, <span class="user-mention" data-user-id="271719">@Mario Carneiro</span> </p>
<p>One potentially interesting version of the code that I’ve just written while playing around with the example is the following</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">marker</span>::<span class="n">PhantomData</span><span class="p">;</span><span class="w"></span>

<span class="c1">//      Let's make sure, this isn’t variance-related either.</span>
<span class="c1">//                       vvvvvvvvvvvvvvvvvvvvvvv</span>
<span class="k">struct</span> <span class="nc">Foo</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;'</span><span class="na">a</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">],</span><span class="w"> </span><span class="n">PhantomData</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;'</span><span class="na">a</span><span class="w"> </span><span class="p">())</span><span class="o">&gt;</span><span class="p">);</span><span class="w"></span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Foo</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[],</span><span class="w"> </span><span class="n">PhantomData</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="n">bar</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vec</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">vec2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="n">bar</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vec2</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">bar</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">foo</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Foo</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">vec_ref</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">a</span> <span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">foo</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec_ref</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>



<a name="253133107"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Borrow%20checking%20magic/near/253133107" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Borrow.20checking.20magic.html#253133107">(Sep 13 2021 at 18:00)</a>:</h4>
<p>I think I agree with your analysis <span class="user-mention" data-user-id="280891">@Frank Steffahn</span> . Maybe one way to put it is that, rather than a bounded interval like C++ lifetimes, a lifetime represents a half-infinite interval of time extending from the beginning of time, and references are valid in that interval; the upper bound is there in the type system to ensure a reference is not used after the data it points to is destroyed but the lower bound is ensured by the act of using the reference - every reference points to something created before the reference was because this is ensured in the constructor <code>&amp;x</code>, so this fact does not need to be tracked in the type.</p>



<a name="253133124"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Borrow%20checking%20magic/near/253133124" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Frank Steffahn <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Borrow.20checking.20magic.html#253133124">(Sep 13 2021 at 18:01)</a>:</h4>
<p>Thinking about this some more</p>
<blockquote>
<p>You can retroactively claim, the reference you've produced has been a valid reference for the last few centuries or before the beginning of the universe, and while that’s weird, I think there's nothing unsound in such a claim. </p>
</blockquote>
<p>That’s essentially what <code>Box::leak</code> does, right? The lifetime <code>'static</code> could be interpreted as “from the beginning of the program until the end of the program”. But <code>Box::leak</code> can create a <code>&amp;'static mut T</code> to a value that <em>definitely</em> wasn't created anytime close to the beginning of the program, but much later.</p>
<p>Another approach/interpretation: A lifetime doesn't speak about the past at all, only about the future. Then <code>'static</code> means “until the end of the program”, nothing more.</p>



<a name="253133594"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Borrow%20checking%20magic/near/253133594" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Borrow.20checking.20magic.html#253133594">(Sep 13 2021 at 18:04)</a>:</h4>
<p>And thus the almighty loader created the current program state in six cycles.</p>



<a name="253134185"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Borrow%20checking%20magic/near/253134185" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Frank Steffahn <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Borrow.20checking.20magic.html#253134185">(Sep 13 2021 at 18:08)</a>:</h4>
<p>Simple methods like <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.insert"><code>Option::insert</code></a> wouldn’t work either, if lifetimes talked about the past. The type signature is</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span> <span class="nf">insert</span><span class="o">&lt;'</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">this</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">a</span> <span class="nc">mut</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">value</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="o">'</span><span class="na">a</span> <span class="nc">mut</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">this</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>but obviously, the returned mutable reference is created much later than <code>this</code> is created (after all, <code>this</code> was used to insert the new value before creating the returned reference).</p>



<a name="253135202"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Borrow%20checking%20magic/near/253135202" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Borrow.20checking.20magic.html#253135202">(Sep 13 2021 at 18:16)</a>:</h4>
<p>For <a href="#narrow/stream/122651-general/topic/Borrow.20checking.20magic/near/253037971">this example</a>, what we're saying is that when <code>bla</code> receives <code>foo: Foo&lt;'a&gt;</code>, it asserts that <code>'a</code> dies after the call frame of <code>bla</code> does, which is why we can't make it compile. I like that RustBelt makes this explicit, by adding a <code>'fn</code> lifetime that represents the lifetime of the call, and any lifetime parameters automatically get a <code>'a: 'fn</code> constraint. It makes me wonder whether this is a hole in the syntax, and it could be possible in principle to have a lifetime parameter that doesn't have such a constraint; that would be a lifetime that dies somewhere in the callee, which wouldn't make sense for all parameter types (i.e. a reference to a stack local in the caller couldn't have such a lifetime) but would work for parameters like <code>foo</code> here.</p>



<a name="253886370"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Borrow%20checking%20magic/near/253886370" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Borrow.20checking.20magic.html#253886370">(Sep 18 2021 at 18:46)</a>:</h4>
<p>Ah yes, "of course", from <code>'static</code> (and leaking) I've always deemed quite "obvious" that, intuitively, lifetimes had to be some kind of "end of the line" / half-infinite intervals. So I wasn't seeing the "lifetime spans before the creation of a borrowee" as the problematic/surprising aspect, but rather the dropck stuff <span aria-label="big smile" class="emoji emoji-1f604" role="img" title="big smile">:big_smile:</span> </p>
<hr>
<p><span class="user-mention silent" data-user-id="280891">Frank Steffahn</span> <a href="#narrow/stream/122651-general/topic/Borrow.20checking.20magic/near/253131866">said</a>:</p>
<blockquote>
<p>One potentially interesting version</p>
</blockquote>
<p>Yep, that's one typical case where this aspect of lifetimes can be useful (imagine if <code>foo</code> were an actual container). But all is good since that snippet would fail if <code>vec</code> were to be dropped before the <code>&amp;vec2</code> borrow.</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>