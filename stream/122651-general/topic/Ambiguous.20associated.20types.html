<html>
<head><meta charset="utf-8"><title>Ambiguous associated types · general · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/122651-general/index.html">general</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Ambiguous.20associated.20types.html">Ambiguous associated types</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="250958178"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Ambiguous%20associated%20types/near/250958178" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Philip Herron <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Ambiguous.20associated.20types.html#250958178">(Aug 27 2021 at 16:35)</a>:</h4>
<p>Hi everyone I have been investigating some test cases around qualified paths and this one has me a little confused: <a href="https://github.com/rust-lang/rust/blob/master/src/test/ui/qualified/qualified-path-params-2.rs">https://github.com/rust-lang/rust/blob/master/src/test/ui/qualified/qualified-path-params-2.rs</a></p>
<p>The associated path &lt;S as Tr&gt;::A on its own will resolve to unit-struct S so when the final segment of ::f&lt;u8&gt; i would have assumed this would have resolved to the type of the impl function f substituted with u8. I don't see why this ambiguous.</p>



<a name="251210283"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Ambiguous%20associated%20types/near/251210283" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Ambiguous.20associated.20types.html#251210283">(Aug 30 2021 at 10:34)</a>:</h4>
<p>First of all, given <code>impl S { fn f&lt;T&gt;… }</code>, <code>S::f::&lt;u8&gt;</code> does not refer to a type, but to a value, that of the function <code>f</code> instantiated with <code>u8</code>. While it could also be used to refer to the (singleton) type of that value, it hasn't done that to begin with, and it would thus be a breaking change if it did (maybe through an edition boundary?).</p>
<p>Then, we can't write <code>impl S { type Assoc; }</code> in stable Rust, we currently need the unstable <code>inherent_associated_types</code> feature. But when we do use that, even something as simple as <code>S::Assoc</code> does not work. Mainly, <strong>to even <em>mention</em> an associated type in Rust, a <code>as Trait</code> disambiguator is needed</strong> (which thus makes <code>inherent_associated_types</code> quite useless, I'd say).</p>
<p>And so that is mainly the error you see: a path such as <code>S::…</code> is not <em>semantically</em> allowed to refer to a type. The reason for this appears to be technical, see <a href="https://github.com/rust-lang/rust/issues/38078#issuecomment-268284794">this comment</a> and the surrounding discussion for more context <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="251210602"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Ambiguous%20associated%20types/near/251210602" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Philip Herron <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Ambiguous.20associated.20types.html#251210602">(Aug 30 2021 at 10:38)</a>:</h4>
<p>So overall the QualifiedPathInType should only ever be able to refer to associated types?</p>



<a name="251211754"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Ambiguous%20associated%20types/near/251211754" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Ambiguous.20associated.20types.html#251211754">(Aug 30 2021 at 10:51)</a>:</h4>
<p>Regarding the:</p>
<div class="codehilite" data-code-language="Text only"><pre><span></span><code>QualifiedPathInType :
   QualifiedPathType (:: TypePathSegment)+
</code></pre></div>
<p>I'd say that the <code>::TypePathSegment</code> part cannot, in practice, occur more than once, yes. Maybe once <code>inherent_associated_types</code> is fully implemented it will be able to work?</p>



<a name="251212077"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Ambiguous%20associated%20types/near/251212077" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Philip Herron <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Ambiguous.20associated.20types.html#251212077">(Aug 30 2021 at 10:55)</a>:</h4>
<p>ah ok thats what i was looking for, I have been trying to find examples with more than 1 segment for testing. another thing i just wrote a test like:</p>
<div class="codehilite"><pre><span></span><code>fn foo() {}

type a = foo;
</code></pre></div>
<p>which fails because foo is not a type but a function. I was assuming type declarations like this take the type of the function. So overall maybe multiple segments will rely on inherent_associated_types like you mention. I think from the grammar allowing multiple segments makes this confusing for me but this helps. thanks.</p>



<a name="251412381"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Ambiguous%20associated%20types/near/251412381" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Olivier FAURE <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Ambiguous.20associated.20types.html#251412381">(Aug 31 2021 at 16:14)</a>:</h4>
<blockquote>
<p>which thus makes inherent_associated_types quite useless, I'd say</p>
</blockquote>
<p>Oh hey, someone's talking about my feature!</p>
<p>Yup, when I worked on the feature I wanted to go the entire way and be able to get an associated type without the <code>as Trait</code> syntax, but I got stalled, and I haven't gotten back to it since.</p>



<a name="251413104"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Ambiguous%20associated%20types/near/251413104" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Olivier FAURE <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Ambiguous.20associated.20types.html#251413104">(Aug 31 2021 at 16:18)</a>:</h4>
<p>From what I remember, the main problem (aside from my lack of familiarity with the compiler) was that the machinery for processing qualified paths is split in two (one for getting associated functions / constants and one for getting associated type), and the one that handles associated type is built in a way that fundamentally assumes that the left side of a qualified path is either a generic parameter or a disambiguated path. (Again, saying this from memory, I don't remember the code that well)</p>



<a name="251413223"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Ambiguous%20associated%20types/near/251413223" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Olivier FAURE <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Ambiguous.20associated.20types.html#251413223">(Aug 31 2021 at 16:19)</a>:</h4>
<p>I remember thinking that the code needed a full refactor to handle associated type resolution in a recursive way, and I kinda gave up at that point.</p>



<a name="251551840"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Ambiguous%20associated%20types/near/251551840" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Philip Herron <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Ambiguous.20associated.20types.html#251551840">(Sep 01 2021 at 12:51)</a>:</h4>
<p>Thanks for your reply, I've been a bit stumped with this in regards to my work on gccrs. But this helps a lot.</p>



<a name="252762158"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Ambiguous%20associated%20types/near/252762158" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Charles Lew <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Ambiguous.20associated.20types.html#252762158">(Sep 10 2021 at 10:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="232018">Daniel Henry-Mantilla</span> <a href="#narrow/stream/122651-general/topic/Ambiguous.20associated.20types/near/251210283">said</a>:</p>
<blockquote>
<p>And so that is mainly the error you see: a path such as <code>S::…</code> is not <em>semantically</em> allowed to refer to a type. The reason for this appears to be technical, see <a href="https://github.com/rust-lang/rust/issues/38078#issuecomment-268284794">this comment</a> and the surrounding discussion for more context <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>
</blockquote>
<p>I'm not super convinced by this. I think it's reasonable to ask <code>resolve</code> to give a first "associated item or variant" lookup or something. <br>
If it's resolved without ambiguity, an error should not be emitted to the user.</p>
<p>This kind of resolution is easy victim to upstream associated item changes. However for ergonomics it might be worth it?</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>