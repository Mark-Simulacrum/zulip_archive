<html>
<head><meta charset="utf-8"><title>Assembly generated for thread-local access (on Linux amd64) · general · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/122651-general/index.html">general</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Assembly.20generated.20for.20thread-local.20access.20(on.20Linux.20amd64).html">Assembly generated for thread-local access (on Linux amd64)</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="276140077"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Assembly%20generated%20for%20thread-local%20access%20%28on%20Linux%20amd64%29/near/276140077" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Raekye <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Assembly.20generated.20for.20thread-local.20access.20(on.20Linux.20amd64).html#276140077">(Mar 22 2022 at 03:32)</a>:</h4>
<p>I was looking at the assembly generated for accessing <code>thread_local!</code> variables (on Linux amd64), and noticed that the assembly was ever so slightly different depending on whether the thread-local variable was defined inside the executable directly (e.g. inside <code>src/bin/my_executable.rs</code>), or inside the library (e.g. inside <code>src/lib.rs</code>), even if the library is statically linked to the executable (as far as I understand).</p>
<p>In short, accessing the executable's thread local generates:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">mov</span><span class="w"> </span><span class="o">%</span><span class="n">fs</span>:<span class="o">-</span><span class="mh">0x48</span><span class="p">,</span><span class="o">%</span><span class="n">rax</span><span class="w"></span>
</code></pre></div>
<p>Whereas accessing the library's thread local generates:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">mov</span><span class="w"> </span><span class="o">%</span><span class="n">fs</span>:<span class="mi">0</span><span class="p">,</span><span class="o">%</span><span class="n">rax</span><span class="w"></span>
<span class="n">mov</span><span class="w"> </span><span class="o">-</span><span class="mh">0x40</span><span class="p">(</span><span class="o">%</span><span class="n">rax</span><span class="p">),</span><span class="o">%</span><span class="n">rax</span><span class="w"></span>
</code></pre></div>
<p>The thing is, as far as I am aware, the value at <code>%fs:0</code> is just the value in <code>%fs</code> itself, under <a href="https://www.akkadia.org/drepper/tls.pdf">TLS models for ELF</a>. If that is true, then accessing the library's thread local should similarly be a single <code>mov %fs:-0x40,%rax</code>.</p>
<p>Unfortunately, I cannot replicate the behaviour on Godbolt, as it invokes <code>rustc</code> on a single file (as far as I can tell), or the Rust playground, which either compiles a shared library or an executable (depending on whether a <code>main</code> function is defined). But I have created a self-contained Cargo project that anyone can clone and look at: <a href="https://github.com/Raekye/rust-tlstest">https://github.com/Raekye/rust-tlstest</a> . The README also contains the <code>objdump</code> commands to look at the generated assembly on your local artifacts yourself</p>



<a name="276140198"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Assembly%20generated%20for%20thread-local%20access%20%28on%20Linux%20amd64%29/near/276140198" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Assembly.20generated.20for.20thread-local.20access.20(on.20Linux.20amd64).html#276140198">(Mar 22 2022 at 03:35)</a>:</h4>
<p>that doesn't sound unusual. they're statically linked but are two crates in one case, so the codegen is done separately, and LTO must have whiffed on this one.</p>



<a name="276140485"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Assembly%20generated%20for%20thread-local%20access%20%28on%20Linux%20amd64%29/near/276140485" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Raekye <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Assembly.20generated.20for.20thread-local.20access.20(on.20Linux.20amd64).html#276140485">(Mar 22 2022 at 03:40)</a>:</h4>
<p>The thing is it <em>knows</em> that it can access the thread local by a fixed offset from the TLS/TCB structure at <code>%fs:0</code>, but it hasn't realized that the word at <code>%fs:0</code> is always just <code>%fs</code>. If you look at the TLS models in <a href="https://www.akkadia.org/drepper/tls.pdf">TLS models for ELF</a>, you can see that both the code snippets (for the library thread local access and executable thread local access) are for the "local exec" model; it first shows the longer version (the 2 instructions generated for the library), then says "or shorter" followed by the 1-instruction sequence (section 4.4.6)</p>



<a name="276145582"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Assembly%20generated%20for%20thread-local%20access%20%28on%20Linux%20amd64%29/near/276145582" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Assembly.20generated.20for.20thread-local.20access.20(on.20Linux.20amd64).html#276145582">(Mar 22 2022 at 05:36)</a>:</h4>
<p>In the library case rustc should use the global dynamic TLS model. The linker can optimize it to local exec I think.</p>



<a name="276183442"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Assembly%20generated%20for%20thread-local%20access%20%28on%20Linux%20amd64%29/near/276183442" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Raekye <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Assembly.20generated.20for.20thread-local.20access.20(on.20Linux.20amd64).html#276183442">(Mar 22 2022 at 12:53)</a>:</h4>
<p>The more I look into it, the more I am convinced - <strong>both</strong> the library and binary <strong>are</strong> using local exec, but the code generated for the library just is the longer (but computationally identical) version in <a href="https://www.akkadia.org/drepper/tls.pdf">ELF Handling for TLS</a> (section 4.4.6)</p>
<p>One can easily see all 4 models being used in C: <a href="https://godbolt.org/z/a19zoqc3E">https://godbolt.org/z/a19zoqc3E</a> . Note that there is nothing that looks like the assembly for the library function:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">mov</span><span class="w"> </span><span class="o">%</span><span class="n">fs</span>:<span class="mi">0</span><span class="p">,</span><span class="o">%</span><span class="n">rax</span><span class="w"></span>
<span class="n">mov</span><span class="w"> </span><span class="o">-</span><span class="mh">0x40</span><span class="p">(</span><span class="o">%</span><span class="n">rax</span><span class="p">),</span><span class="o">%</span><span class="n">rax</span><span class="w"></span>
</code></pre></div>
<p>because it can be simply <code>mov %fs:-0x40,%rax</code>, since <code>%fs:0</code> is <code>%fs</code> [*].</p>
<p>Basically, regardless of there being a library crate + binary crate, rustc/llvm has figured out to use the local exec (most optimal) model, but it just... doesn't use the optimal instruction sequence (unless someone can correct me about <code>%fs:0</code> being <code>%fs</code> [*]).</p>
<p>Here are a couple other sources about TLS: <a href="https://maskray.me/blog/2021-02-14-all-about-thread-local-storage">blog</a> and <a href="https://lists.llvm.org/pipermail/llvm-dev/2017-November/118887.html">llvm mailing list</a></p>
<p>[*] To be clear, <code>mov %fs:0,%rax</code>is (AFAIK) "load the word at offset 0 from <code>%fs</code>", which is not obviously the same as <code>%fs</code>. But in ELF the word at <code>%fs:0</code> is always set to the value of <code>%fs</code>; it's basically a pointer to itself. And I'm trying to say that if you know the constant offset you want to access, which at some point/by the end rustc/llvm does (presumably link time), there's no reason to use the two instructions instead of one</p>



<a name="276183984"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Assembly%20generated%20for%20thread-local%20access%20%28on%20Linux%20amd64%29/near/276183984" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amanieu <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Assembly.20generated.20for.20thread-local.20access.20(on.20Linux.20amd64).html#276183984">(Mar 22 2022 at 12:57)</a>:</h4>
<p>You can try playing around with the <code>-Z tls-model</code> option to see how it affects codegen.</p>



<a name="276185287"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Assembly%20generated%20for%20thread-local%20access%20%28on%20Linux%20amd64%29/near/276185287" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Assembly.20generated.20for.20thread-local.20access.20(on.20Linux.20amd64).html#276185287">(Mar 22 2022 at 13:07)</a>:</h4>
<p>Rustc uses global dynamic, not local exec for libraries. If you look at the unlinked object files you will see <code>__tls_get_addr</code> together with a whole lot of unnecessary prefixes to pad the whole sequence. This allows the linker to relax it to local exec when linking.</p>



<a name="276185317"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Assembly%20generated%20for%20thread-local%20access%20%28on%20Linux%20amd64%29/near/276185317" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Raekye <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Assembly.20generated.20for.20thread-local.20access.20(on.20Linux.20amd64).html#276185317">(Mar 22 2022 at 13:07)</a>:</h4>
<p>I have; here is a Godbolt showing local-exec and initial-exec (local and global dynamic are not relevant here/I didn't want to crowd the panes): <a href="https://rust.godbolt.org/z/xov6P75oY">https://rust.godbolt.org/z/xov6P75oY</a> (note that I'm calling <code>Cell::replace</code> so that it doesn't get optimized to a constant, so there is a <code>mov</code> to load and a <code>mov</code> to store). The codegen for the initial-exec model looks nothing like what's generated above, and the codegen for local-exec is the 1-instruction sequence. It's only when the TLS is defined (privately) in a library statically linked to a binary that it uses the 2-instruction sequence</p>
<p>(I don't mean to be a freak over literally just 1 extra instruction; I was initially looking at the assembly to see/understand if another TLS model was being used for my code, but at my current understanding of what's going on, the codegen seems unsatisfying)</p>



<a name="276185952"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Assembly%20generated%20for%20thread-local%20access%20%28on%20Linux%20amd64%29/near/276185952" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Assembly.20generated.20for.20thread-local.20access.20(on.20Linux.20amd64).html#276185952">(Mar 22 2022 at 13:12)</a>:</h4>
<p>TLS inside a binary makes rustc use local-exec so when writing the object file you already have the shorter sequence. When in a library global-dynamic is used, causing the linker to rewrite the sequence when linking into a binary. This rewriting in the linker probably doesn't know about the shorter sequence.</p>



<a name="276186220"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Assembly%20generated%20for%20thread-local%20access%20%28on%20Linux%20amd64%29/near/276186220" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Raekye <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Assembly.20generated.20for.20thread-local.20access.20(on.20Linux.20amd64).html#276186220">(Mar 22 2022 at 13:14)</a>:</h4>
<p>(To be clear, in my test project <a href="https://github.com/Raekye/rust-tlstest">https://github.com/Raekye/rust-tlstest</a> I am looking at the final binary object file (with the library code statically linked). I did look at the library .rlib archive before. Specifically, <code>objdump --disassemble=get_lib_tl target/release/libtlstest.rlib</code> shows the following, which isn't quite what bjorn3 said (maybe because it's just the .rlib and I didn't tell it to created a shared object?), though it certainly looks like a placeholder)</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="mi">0000000000000000</span><span class="w"> </span><span class="o">&lt;</span><span class="n">get_lib_tl</span><span class="o">&gt;</span>:
   <span class="mi">1</span>:   <span class="mi">48</span><span class="w"> </span><span class="mi">8</span><span class="n">d</span><span class="w"> </span><span class="mi">3</span><span class="n">d</span><span class="w"> </span><span class="mi">00</span><span class="w"> </span><span class="mi">00</span><span class="w"> </span><span class="mi">00</span><span class="w"> </span><span class="mi">00</span><span class="w">    </span><span class="n">lea</span><span class="w">    </span><span class="mh">0x0</span><span class="p">(</span><span class="o">%</span><span class="n">rip</span><span class="p">),</span><span class="o">%</span><span class="n">rdi</span><span class="w">        </span>#<span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="o">&lt;</span><span class="n">get_lib_tl</span><span class="o">+</span><span class="mh">0x8</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">   </span><span class="mi">8</span>:   <span class="nc">e8</span><span class="w"> </span><span class="mi">00</span><span class="w"> </span><span class="mi">00</span><span class="w"> </span><span class="mi">00</span><span class="w"> </span><span class="mi">00</span><span class="w">          </span><span class="n">call</span><span class="w">   </span><span class="n">d</span><span class="w"> </span><span class="o">&lt;</span><span class="n">get_lib_tl</span><span class="o">+</span><span class="mh">0xd</span><span class="o">&gt;</span><span class="w"></span>
</code></pre></div>



<a name="276186384"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Assembly%20generated%20for%20thread-local%20access%20%28on%20Linux%20amd64%29/near/276186384" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Assembly.20generated.20for.20thread-local.20access.20(on.20Linux.20amd64).html#276186384">(Mar 22 2022 at 13:16)</a>:</h4>
<p>get_lib_tl calls some other function it seems. This function does the actual TLS access.</p>



<a name="276186659"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Assembly%20generated%20for%20thread-local%20access%20%28on%20Linux%20amd64%29/near/276186659" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Raekye <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Assembly.20generated.20for.20thread-local.20access.20(on.20Linux.20amd64).html#276186659">(Mar 22 2022 at 13:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="133247">bjorn3</span> <a href="#narrow/stream/122651-general/topic/Assembly.20generated.20for.20thread-local.20access.20.28on.20Linux.20amd64.29/near/276185952">said</a>:</p>
<blockquote>
<p>TLS inside a binary makes rustc use local-exec so when writing the object file you already have the shorter sequence. When in a library global-dynamic is used, causing the linker to rewrite the sequence when linking into a binary. This rewriting in the linker probably doesn't know about the shorter sequence.</p>
</blockquote>
<p>This makes sense. Now is this even related to rustc, or is it entirely the llvm linker (I'm guessing?)?</p>



<a name="276186905"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Assembly%20generated%20for%20thread-local%20access%20%28on%20Linux%20amd64%29/near/276186905" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Assembly.20generated.20for.20thread-local.20access.20(on.20Linux.20amd64).html#276186905">(Mar 22 2022 at 13:20)</a>:</h4>
<p>It is whatever linker you use. Binutils ld, gold, lld, mold or any other elf linker.</p>



<a name="276187034"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Assembly%20generated%20for%20thread-local%20access%20%28on%20Linux%20amd64%29/near/276187034" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Raekye <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Assembly.20generated.20for.20thread-local.20access.20(on.20Linux.20amd64).html#276187034">(Mar 22 2022 at 13:21)</a>:</h4>
<p>I didn't configure anything linker related; would the default be llvm's lld (I'm guessing since rustc uses llvm)?</p>



<a name="276187256"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Assembly%20generated%20for%20thread-local%20access%20%28on%20Linux%20amd64%29/near/276187256" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Assembly.20generated.20for.20thread-local.20access.20(on.20Linux.20amd64).html#276187256">(Mar 22 2022 at 13:22)</a>:</h4>
<p>Not yet. You are probably using ld from binutils as this is what gcc uses by default.</p>



<a name="276187451"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Assembly%20generated%20for%20thread-local%20access%20%28on%20Linux%20amd64%29/near/276187451" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Raekye <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Assembly.20generated.20for.20thread-local.20access.20(on.20Linux.20amd64).html#276187451">(Mar 22 2022 at 13:24)</a>:</h4>
<p>I realized my code paste for <code>get_lib_tl</code> in <code>libtlstest.rlib</code> was cut off, here is the full code (not that it makes much sense to me):</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="mi">0000000000000000</span><span class="w"> </span><span class="o">&lt;</span><span class="n">get_lib_tl</span><span class="o">&gt;</span>:
   <span class="mi">0</span>:   <span class="mi">50</span><span class="w">                      </span><span class="n">push</span><span class="w">   </span><span class="o">%</span><span class="n">rax</span><span class="w"></span>
<span class="w">   </span><span class="mi">1</span>:   <span class="mi">48</span><span class="w"> </span><span class="mi">8</span><span class="n">d</span><span class="w"> </span><span class="mi">3</span><span class="n">d</span><span class="w"> </span><span class="mi">00</span><span class="w"> </span><span class="mi">00</span><span class="w"> </span><span class="mi">00</span><span class="w"> </span><span class="mi">00</span><span class="w">    </span><span class="n">lea</span><span class="w">    </span><span class="mh">0x0</span><span class="p">(</span><span class="o">%</span><span class="n">rip</span><span class="p">),</span><span class="o">%</span><span class="n">rdi</span><span class="w">        </span>#<span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="o">&lt;</span><span class="n">get_lib_tl</span><span class="o">+</span><span class="mh">0x8</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">   </span><span class="mi">8</span>:   <span class="nc">e8</span><span class="w"> </span><span class="mi">00</span><span class="w"> </span><span class="mi">00</span><span class="w"> </span><span class="mi">00</span><span class="w"> </span><span class="mi">00</span><span class="w">          </span><span class="n">call</span><span class="w">   </span><span class="n">d</span><span class="w"> </span><span class="o">&lt;</span><span class="n">get_lib_tl</span><span class="o">+</span><span class="mh">0xd</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">   </span><span class="n">d</span>:   <span class="mi">48</span><span class="w"> </span><span class="mi">8</span><span class="n">b</span><span class="w"> </span><span class="mi">80</span><span class="w"> </span><span class="mi">00</span><span class="w"> </span><span class="mi">00</span><span class="w"> </span><span class="mi">00</span><span class="w"> </span><span class="mi">00</span><span class="w">    </span><span class="n">mov</span><span class="w">    </span><span class="mh">0x0</span><span class="p">(</span><span class="o">%</span><span class="n">rax</span><span class="p">),</span><span class="o">%</span><span class="n">rax</span><span class="w"></span>
<span class="w">  </span><span class="mi">14</span>:   <span class="mi">59</span><span class="w">                      </span><span class="n">pop</span><span class="w">    </span><span class="o">%</span><span class="n">rcx</span><span class="w"></span>
<span class="w">  </span><span class="mi">15</span>:   <span class="nc">c3</span><span class="w">                      </span><span class="n">ret</span><span class="w"></span>
</code></pre></div>
<p>(The call, as far as I can tell, is just the address of the next instruction in <code>get_lib_tl</code>. But as mentioned, it's presumably just placeholder (meta)data)</p>



<a name="276187681"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Assembly%20generated%20for%20thread-local%20access%20%28on%20Linux%20amd64%29/near/276187681" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Assembly.20generated.20for.20thread-local.20access.20(on.20Linux.20amd64).html#276187681">(Mar 22 2022 at 13:26)</a>:</h4>
<p>You can pass -r to see relocations.</p>



<a name="276188294"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Assembly%20generated%20for%20thread-local%20access%20%28on%20Linux%20amd64%29/near/276188294" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Raekye <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Assembly.20generated.20for.20thread-local.20access.20(on.20Linux.20amd64).html#276188294">(Mar 22 2022 at 13:30)</a>:</h4>
<p>I see, thanks! I can see the <code>__tls_get_addr</code> now (pasted for completeness)</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="mi">0000000000000000</span><span class="w"> </span><span class="o">&lt;</span><span class="n">get_lib_tl</span><span class="o">&gt;</span>:
   <span class="mi">0</span>:   <span class="mi">50</span><span class="w">                      </span><span class="n">push</span><span class="w">   </span><span class="o">%</span><span class="n">rax</span><span class="w"></span>
<span class="w">   </span><span class="mi">1</span>:   <span class="mi">48</span><span class="w"> </span><span class="mi">8</span><span class="n">d</span><span class="w"> </span><span class="mi">3</span><span class="n">d</span><span class="w"> </span><span class="mi">00</span><span class="w"> </span><span class="mi">00</span><span class="w"> </span><span class="mi">00</span><span class="w"> </span><span class="mi">00</span><span class="w">    </span><span class="n">lea</span><span class="w">    </span><span class="mh">0x0</span><span class="p">(</span><span class="o">%</span><span class="n">rip</span><span class="p">),</span><span class="o">%</span><span class="n">rdi</span><span class="w">        </span>#<span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="o">&lt;</span><span class="n">get_lib_tl</span><span class="o">+</span><span class="mh">0x8</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">                        </span><span class="mi">4</span>: <span class="nc">R_X86_64_TLSLD</span><span class="w">       </span><span class="n">_ZN7tlstest6LIB_TL7__getit3VAL17he76855629effc2fcE</span><span class="p">.</span><span class="mi">0</span><span class="o">-</span><span class="mh">0x4</span><span class="w"></span>
<span class="w">   </span><span class="mi">8</span>:   <span class="nc">e8</span><span class="w"> </span><span class="mi">00</span><span class="w"> </span><span class="mi">00</span><span class="w"> </span><span class="mi">00</span><span class="w"> </span><span class="mi">00</span><span class="w">          </span><span class="n">call</span><span class="w">   </span><span class="n">d</span><span class="w"> </span><span class="o">&lt;</span><span class="n">get_lib_tl</span><span class="o">+</span><span class="mh">0xd</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">                        </span><span class="mi">9</span>: <span class="nc">R_X86_64_PLT32</span><span class="w">       </span><span class="n">__tls_get_addr</span><span class="o">-</span><span class="mh">0x4</span><span class="w"></span>
<span class="w">   </span><span class="n">d</span>:   <span class="mi">48</span><span class="w"> </span><span class="mi">8</span><span class="n">b</span><span class="w"> </span><span class="mi">80</span><span class="w"> </span><span class="mi">00</span><span class="w"> </span><span class="mi">00</span><span class="w"> </span><span class="mi">00</span><span class="w"> </span><span class="mi">00</span><span class="w">    </span><span class="n">mov</span><span class="w">    </span><span class="mh">0x0</span><span class="p">(</span><span class="o">%</span><span class="n">rax</span><span class="p">),</span><span class="o">%</span><span class="n">rax</span><span class="w"></span>
<span class="w">                        </span><span class="mi">10</span>: <span class="nc">R_X86_64_DTPOFF32</span><span class="w">   </span><span class="n">_ZN7tlstest6LIB_TL7__getit3VAL17he76855629effc2fcE</span><span class="p">.</span><span class="mi">0</span><span class="w"></span>
<span class="w">  </span><span class="mi">14</span>:   <span class="mi">59</span><span class="w">                      </span><span class="n">pop</span><span class="w">    </span><span class="o">%</span><span class="n">rcx</span><span class="w"></span>
<span class="w">  </span><span class="mi">15</span>:   <span class="nc">c3</span><span class="w">                      </span><span class="n">ret</span><span class="w"></span>
</code></pre></div>



<a name="276193095"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Assembly%20generated%20for%20thread-local%20access%20%28on%20Linux%20amd64%29/near/276193095" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Raekye <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Assembly.20generated.20for.20thread-local.20access.20(on.20Linux.20amd64).html#276193095">(Mar 22 2022 at 14:04)</a>:</h4>
<p>Just wanted to share my findings... To start here is the full code for <code>get_lib_tl</code> in the binary:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="mi">0000000000007710</span><span class="w"> </span><span class="o">&lt;</span><span class="n">get_lib_tl</span><span class="o">&gt;</span>:
    <span class="mi">7710</span>:       <span class="mi">50</span><span class="w">                      </span><span class="n">push</span><span class="w">   </span><span class="o">%</span><span class="n">rax</span><span class="w"></span>
<span class="w">    </span><span class="mi">7711</span>:       <span class="mi">66</span><span class="w"> </span><span class="mi">66</span><span class="w"> </span><span class="mi">66</span><span class="w"> </span><span class="mi">64</span><span class="w"> </span><span class="mi">48</span><span class="w"> </span><span class="mi">8</span><span class="n">b</span><span class="w"> </span><span class="mi">04</span><span class="w">    </span><span class="n">data16</span><span class="w"> </span><span class="n">data16</span><span class="w"> </span><span class="n">data16</span><span class="w"> </span><span class="n">mov</span><span class="w"> </span><span class="o">%</span><span class="n">fs</span>:<span class="mh">0x0</span><span class="p">,</span><span class="o">%</span><span class="n">rax</span><span class="w"></span>
<span class="w">    </span><span class="mi">7718</span>:       <span class="mi">25</span><span class="w"> </span><span class="mi">00</span><span class="w"> </span><span class="mi">00</span><span class="w"> </span><span class="mi">00</span><span class="w"> </span><span class="mi">00</span><span class="w"></span>
<span class="w">    </span><span class="mi">771</span><span class="n">d</span>:       <span class="mi">48</span><span class="w"> </span><span class="mi">8</span><span class="n">b</span><span class="w"> </span><span class="mi">80</span><span class="w"> </span><span class="n">c0</span><span class="w"> </span><span class="n">ff</span><span class="w"> </span><span class="n">ff</span><span class="w"> </span><span class="n">ff</span><span class="w">    </span><span class="n">mov</span><span class="w">    </span><span class="o">-</span><span class="mh">0x40</span><span class="p">(</span><span class="o">%</span><span class="n">rax</span><span class="p">),</span><span class="o">%</span><span class="n">rax</span><span class="w"></span>
<span class="w">    </span><span class="mi">7724</span>:       <span class="mi">59</span><span class="w">                      </span><span class="n">pop</span><span class="w">    </span><span class="o">%</span><span class="n">rcx</span><span class="w"></span>
<span class="w">    </span><span class="mi">7725</span>:       <span class="nc">c3</span><span class="w">                      </span><span class="n">ret</span><span class="w"></span>
</code></pre></div>
<p><a href="https://github.com/llvm/llvm-project/blob/main/lld/ELF/Arch/X86_64.cpp#L430">Here</a> is the <code>lld</code> code for "relax tls gd (global dynamic) to le (local exec)". It doesn't look quite like our end code. I notice that the relocation in the latest dump for <code>get_lib_tl</code> in <code>libtlstest.rlib</code> is <code>R_X86_64_TLSLD</code> (notice the "LD" presumably for "local dynamic" instead of "GD"). <a href="https://github.com/llvm/llvm-project/blob/main/lld/ELF/Arch/X86_64.cpp#L555-L584">Here</a> is the code for "relax tls ld to le". Indeed, we see it start with three <code>0x66</code>/<code>data16</code> nops (and the rest of the hardcoded bytes).</p>
<p>(As mentioned in the comment in <code>relaxTlsLdToLe</code>) table 11.9 (under "Alternate Code Sequences for Security") in <a href="https://raw.githubusercontent.com/wiki/hjl-tools/x86-psABI/x86-64-psABI-1.0.pdf">this document</a> shows the general transformation from GD/LD to LE, which has <code>mov %fs:0,%rax</code>and requires 1 more <code>mov</code> with the static offset not shown. I'm still not sure why it cannot be transformed to a single <code>mov</code>, but in any case this seems like it's outside of the scope of the rust compiler. I'll ask the llvm/linker guys if I'm feeling adventurous later</p>



<a name="276244780"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Assembly%20generated%20for%20thread-local%20access%20%28on%20Linux%20amd64%29/near/276244780" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Assembly.20generated.20for.20thread-local.20access.20(on.20Linux.20amd64).html#276244780">(Mar 22 2022 at 19:47)</a>:</h4>
<p>Could linker-plugin LTO make a difference here?</p>



<a name="276244862"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Assembly%20generated%20for%20thread-local%20access%20%28on%20Linux%20amd64%29/near/276244862" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Assembly.20generated.20for.20thread-local.20access.20(on.20Linux.20amd64).html#276244862">(Mar 22 2022 at 19:48)</a>:</h4>
<p>Any kind of LTO can as it forces codegen to happen in the context of the main crate.</p>



<a name="276249372"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Assembly%20generated%20for%20thread-local%20access%20%28on%20Linux%20amd64%29/near/276249372" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Raekye <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Assembly.20generated.20for.20thread-local.20access.20(on.20Linux.20amd64).html#276249372">(Mar 22 2022 at 20:24)</a>:</h4>
<p>I tried building with different values for <code>lto</code> (<a href="https://doc.rust-lang.org/cargo/reference/profiles.html">these cargo profile settings</a>). <code>false</code> ("thin local lto") and <code>"thin"</code> produce the 2 instruction sequence (<code>mov %fs:0,%rax</code>, <code>mov -0x40(%rax),%rax</code>). I  thought I tested <code>"fat"</code> before, but I must have forgot the results because it actually produces a single <code>mov %fs:&lt;OFFSET&gt;,%rax</code> "as desired". For completeness, <code>"off"</code> produces a call into <code>std</code> (makes sense since it's a separate crate). If you follow the code through <code>std::thread::LocalKey</code>, you eventually get to the same 2 instruction sequence (<code>mov %fs:0,%rax</code>, <code>mov -0x40(%rax),%rax</code>), which I guess makes sense</p>
<p>So my current understanding is in general rustc uses global dynamic or local dynamic (not sure which one; bjorn3 says global dynamic, but the code I looked at seemed more like local dynamic. Does it have to do with the visibility?) for thread locals inside any library crate. But the <a href="https://github.com/llvm/llvm-project/blob/main/lld/ELF/Arch/X86_64.cpp#L48-L55">linker can optimize it</a> if the library crates are statically linked to an executable. But for reasons I don't understand the linker relaxation always uses the longer (2 instruction) sequence for local exec (<a href="https://raw.githubusercontent.com/wiki/hjl-tools/x86-psABI/x86-64-psABI-1.0.pdf">section 11.1.2</a>, <a href="https://www.akkadia.org/drepper/tls.pdf">section 4.4.6</a>). But you can make it produce a single instruction with "fat" lto</p>
<p>Idk if others are interested in continuing this (largely pedantic) discussion, but I don't really understand how fat lto changes it, in the sense that:</p>
<ol>
<li>linker relaxation <em>always</em> transforms GD/LD to the 2 instruction sequence, as far as I can tell</li>
<li>Unless fat lto actually changes compilation of the library to produce non GD/LD thread local access, the linker relaxation will produce 2 instructions as per previous point. But fat lto is... link time right? Shouldn't affect compilation? [*]</li>
<li>You can observe that even completely disabling lto (<code>"off"</code>) still lets the linker relax the thread local access to local exec (it just won't inline functions from std into your crate). So it "knows" it can do local exec regardless of lto</li>
<li>I'm not aware of any reason to use the 2 instruction sequence over the single instruction for local exec</li>
</ol>
<p>[*] I tried to <code>objdump</code> the library rlib compiled with fat lto, but it says</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">objdump</span>: <span class="nc">tlstest</span><span class="o">-</span><span class="mi">1</span><span class="n">a856feac2c81915</span><span class="p">.</span><span class="n">tlstest</span><span class="p">.</span><span class="mi">6</span><span class="n">eb0fa7f</span><span class="o">-</span><span class="n">cgu</span><span class="p">.</span><span class="mf">0.</span><span class="n">rcgu</span><span class="p">.</span><span class="n">o</span>: <span class="nc">file</span><span class="w"> </span><span class="n">format</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">recognized</span><span class="w"></span>
</code></pre></div>



<a name="276251360"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Assembly%20generated%20for%20thread-local%20access%20%28on%20Linux%20amd64%29/near/276251360" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Assembly.20generated.20for.20thread-local.20access.20(on.20Linux.20amd64).html#276251360">(Mar 22 2022 at 20:43)</a>:</h4>
<p>This is the default tls model: <a href="https://github.com/rust-lang/rust/blob/bce19cf7f19ee5729defaccc86b068cc3c206c9c/compiler/rustc_target/src/spec/mod.rs#L1463">https://github.com/rust-lang/rust/blob/bce19cf7f19ee5729defaccc86b068cc3c206c9c/compiler/rustc_target/src/spec/mod.rs#L1463</a></p>



<a name="276251511"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Assembly%20generated%20for%20thread-local%20access%20%28on%20Linux%20amd64%29/near/276251511" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Assembly.20generated.20for.20thread-local.20access.20(on.20Linux.20amd64).html#276251511">(Mar 22 2022 at 20:44)</a>:</h4>
<p>All LTO kinds except linker plugin LTO happen as part of rustc.</p>



<a name="276316201"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Assembly%20generated%20for%20thread-local%20access%20%28on%20Linux%20amd64%29/near/276316201" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joshua Nelson <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Assembly.20generated.20for.20thread-local.20access.20(on.20Linux.20amd64).html#276316201">(Mar 23 2022 at 11:00)</a>:</h4>
<blockquote>
<p>I'm not aware of any reason to use the 2 instruction sequence</p>
</blockquote>
<p>If my understanding is correct, this is something you should bring up to the linker maintainers, not to rustc. LTO actually happens before the linker itself runs I'm pretty sure - it works by storing llvm bitcode in object files instead of ELF, so I think what's happening is fat LTO makes llvm do the optimization before the linker sees it.</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>