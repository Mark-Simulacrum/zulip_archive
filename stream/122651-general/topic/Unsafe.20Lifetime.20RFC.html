<html>
<head><meta charset="utf-8"><title>Unsafe Lifetime RFC · general · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/122651-general/index.html">general</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html">Unsafe Lifetime RFC</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="263386688"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263386688" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mason Boeman <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263386688">(Dec 02 2021 at 02:38)</a>:</h4>
<p>Hello! I’m curious if anyone has feedback for either the content or form of the rfc I opened a few days ago: <a href="https://github.com/rust-lang/rfcs/pull/3199">https://github.com/rust-lang/rfcs/pull/3199</a></p>



<a name="263388545"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263388545" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jacob Lifshay <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263388545">(Dec 02 2021 at 03:17)</a>:</h4>
<p>Well, I, at least, quite like the idea! ...I don't have any specific feedback right now though.</p>



<a name="263389353"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263389353" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mason Boeman <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263389353">(Dec 02 2021 at 03:35)</a>:</h4>
<p>I still appreciate the read through!</p>



<a name="263389707"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263389707" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joshua Nelson <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263389707">(Dec 02 2021 at 03:43)</a>:</h4>
<p>Using reference syntax for unsafe ops seems ... not great. Someone suggested <code>*aligned const</code>, that seems more clear to me</p>



<a name="263389801"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263389801" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joshua Nelson <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263389801">(Dec 02 2021 at 03:44)</a>:</h4>
<p>Also I only skimmed the RFC, but I don't understand how it could be safe to write to the address but not safe to read from it</p>



<a name="263389828"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263389828" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joshua Nelson <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263389828">(Dec 02 2021 at 03:45)</a>:</h4>
<p>Since if it's been deallocated it's UB to write to it</p>



<a name="263392228"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263392228" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mason Boeman <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263392228">(Dec 02 2021 at 04:39)</a>:</h4>
<p>It’s not safe to write to, because assigning to a variable through a 'unsafe reference, and assigning to a value whose type is instantiated with the 'unsafe lifetime is unsafe is unsafe</p>



<a name="263399468"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263399468" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Kestrer <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263399468">(Dec 02 2021 at 06:54)</a>:</h4>
<p>I would imagine it to have slightly different SB behaviour than <code>*aligned const T</code> - it would enforce that no <code>&amp;mut T</code>s also exist to the same location.</p>



<a name="263404188"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263404188" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263404188">(Dec 02 2021 at 08:14)</a>:</h4>
<p>I don't understand why <code>'unsafe</code> is supposed to be shorter than all lifetimes. Doesn't that mean it's already invalid? How does that work? Also, does "all lifetimes" include <code>'unsafe</code>? Is <code>'unsafe</code> shorter than itself? That also seems bad. It is also not clear whether or not it is valid to substitute <code>'unsafe</code> for a generic lifetime. The rationale seems to suggest that it should be possible, since we want to use it for data structures and functions out of our control declared with lifetime arguments, but the rule for unsafe blocks doesn't work in that case:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="c1">// simplified example from the RFC</span>
<span class="k">fn</span> <span class="nf">store</span><span class="p">(</span><span class="n">val</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="o">&amp;'</span><span class="na">unsafe</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">some_ref</span>: <span class="kp">&amp;</span><span class="kt">usize</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// assigning to val, not through val.</span>
<span class="w">    </span><span class="c1">// unsafe due to rule 4. If we were assigning through it would be rule 3.</span>
<span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">*</span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">some_ref</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">store_generic</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">val</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="o">&amp;'</span><span class="na">a</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">some_ref</span>: <span class="kp">&amp;</span><span class="kt">usize</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="o">*</span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">some_ref</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="k">fn</span> <span class="nf">evil</span><span class="p">(</span><span class="n">val</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="o">&amp;'</span><span class="na">unsafe</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">some_ref</span>: <span class="kp">&amp;</span><span class="kt">usize</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">store_generic</span>::<span class="o">&lt;'</span><span class="na">unsafe</span><span class="o">&gt;</span><span class="p">(</span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="n">some_ref</span><span class="p">);</span><span class="w"> </span><span class="c1">// look ma, no unsafe</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>Rule 1.5 also seems to contradict the rationale, since it suggests that calls like <code>store_generic::&lt;'unsafe&gt;</code> are not legal (with or without an unsafe block), but in that case there is no point in constructing a <code>std::slice::Iter&lt;'unsafe, T&gt;</code> since you can't call any functions on it.</p>



<a name="263417521"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263417521" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263417521">(Dec 02 2021 at 10:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="232545">Joshua Nelson</span> <a href="#narrow/stream/122651-general/topic/Unsafe.20Lifetime.20RFC/near/263389707">said</a>:</p>
<blockquote>
<p>Using reference syntax for unsafe ops seems ... not great. Someone suggested <code>*aligned const</code>, that seems more clear to me</p>
</blockquote>
<p>It would have the advantage of "compositionality" (if that isn't a word you get what I meant); it incidentally reminds me a bit of the super subtle <code>#[may_dangle]</code> attribute. So, when thinking about it, being compositional is not necessarily always a good thing, at least for a fully opaque API: chances are that by promoting an <code>'unsafe</code> version of it to become "alive". Maybe the RFC should thus mention that it <em>should</em> (as in recommended, not mandatory) only be used with types defined in the same crates, or types of dependencies <em>provided</em> they properly document their lifetime-related properties.</p>
<p>For instance, one should be very aware of the <em>variance</em> of a type before using <code>'unsafe</code> in it, so the defined type better guarantee it. This is different from the current <em>status quo</em>, whereby if somebody incorrectly relies on the variance of an external type, or if the variance of that type changes, the borrow checker will be there to catch the error.</p>



<a name="263420921"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263420921" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263420921">(Dec 02 2021 at 11:02)</a>:</h4>
<p>Regarding the explanation, and this may be related to <span class="user-mention" data-user-id="271719">@Mario Carneiro</span>'s example, I think the whole model could be simplified, by a lot. The key idea is to think of that lifetime as <code>'empty</code> / <code>'void</code> / <code>'bottom</code>:</p>
<h4>an <code>'unsafe</code> lifetime acts as an expired lifetime <em>anywhere</em> it appears (but for the type itself being well-formed enough to be nameable)</h4>
<ul>
<li>The type itself can be named / passed around</li>
<li>Generic lifetime parameters in <em>functions</em> (and any other operation, <em>e.g.</em>, a dereference) cannot be instanced with the <code>'unsafe</code> lifetime without <code>unsafe</code>.</li>
</ul>
<p>And that's it. Anything else follows from variance or lack thereof:</p>
<p>Take <code>store_generic</code>, above:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span> <span class="nf">store_generic</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">val</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="o">&amp;'</span><span class="na">a</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">some_ref</span>: <span class="kp">&amp;</span><span class="kt">usize</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="o">*</span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">some_ref</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>that one already doesn't compile, <strong>thanks to invariance of <code>type T&lt;'a&gt; = &amp;'whatever &amp;'a usize;</code></strong>, unless the same lifetime appears on the right:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="c1">//                                      Bound added to make it compile</span>
<span class="c1">//                                      vvvvvvv</span>
<span class="k">fn</span> <span class="nf">store_generic</span><span class="o">&lt;'</span><span class="na">val</span>: <span class="o">'</span><span class="na">val</span><span class="p">,</span><span class="w"> </span><span class="o">'</span><span class="na">a</span><span class="w"> </span>: <span class="o">'</span><span class="na">val</span><span class="p">,</span><span class="w"> </span><span class="o">'</span><span class="na">r</span><span class="w"> </span>: <span class="o">'</span><span class="na">a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">val</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">val</span> <span class="nc">mut</span><span class="w"> </span><span class="o">&amp;'</span><span class="na">a</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">some_ref</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">r</span> <span class="kt">usize</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="o">*</span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">some_ref</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<ul>
<li>(The <code>'val : 'val</code> is just to make it an early-bound / non-higher-order lifetime parameter which can thus be turbofished)</li>
</ul>
<p>Then, <em>even assuming a non-<code>unsafe</code> usage of the <code>'unsafe</code> lifetime in a function's generic parameter</em>:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span> <span class="nf">evil</span><span class="o">&lt;'</span><span class="na">val</span><span class="p">,</span><span class="w"> </span><span class="o">'</span><span class="na">r</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">val</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">val</span> <span class="nc">mut</span><span class="w"> </span><span class="o">&amp;'</span><span class="na">unsafe</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">some_ref</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">r</span> <span class="kt">usize</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">store_generic</span>::<span class="o">&lt;'</span><span class="nb">_</span><span class="p">,</span><span class="w"> </span><span class="o">'</span><span class="na">unsafe</span><span class="p">,</span><span class="w"> </span><span class="o">'</span><span class="na">r</span><span class="o">&gt;</span><span class="p">(</span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="n">some_ref</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>does indeed compile, but that shouldn't be a surprise:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span> <span class="nf">evil</span><span class="p">(</span><span class="n">val</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">some_ref</span>: <span class="kp">&amp;</span><span class="kt">usize</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="o">*</span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">some_ref</span><span class="p">;</span><span class="w"> </span><span class="c1">// look motherboard, no unsafe!</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>Indeed, <code>&amp;mut &amp;'unsafe usize</code> can only be constructed off a <code>&amp;'unsafe usize</code> to begin with, it can't be obtained by subtyping / variance. And if somebody has a <code>&amp;'unsafe usize</code> they indeed to dereference later on, then they better dont feed a <code>&amp;mut</code> reference to it to an unknown API, much like you wouldn't do that with a <code>*const usize</code>.</p>
<p>But now imagine that <code>store_generic</code> were to double-dereference-read its first argument. Then calling it with an <code>'unsafe</code> lifetime would be unsound. Hence why that call, independently of the function's implementation, would have to be <code>unsafe</code>.</p>
<p>Construction of a self-referential struct using <code>'unsafe</code> would thus be easy: by covariance any short-lived instance of a self-reference can be coerced to <code>'unsafe</code>, and then stored within the type. It is the usage / dereference of such potentially-dangling "references" which would need <code>unsafe</code>, as it should.</p>



<a name="263422392"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263422392" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263422392">(Dec 02 2021 at 11:17)</a>:</h4>
<p>I think I agree with your model <span class="user-mention" data-user-id="232018">@Daniel Henry-Mantilla</span> , but the source of "unsafety" is still unclear to me. Here's a simpler example:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span> <span class="nf">read_generic</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">val</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">a</span> <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span> <span class="p">{</span><span class="w"> </span><span class="o">*</span><span class="n">val</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="k">fn</span> <span class="nf">evil2</span><span class="p">(</span><span class="n">val</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">unsafe</span> <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span> <span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">read_generic</span>::<span class="o">&lt;'</span><span class="na">unsafe</span><span class="o">&gt;</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>Clearly we want the call to <code>read_generic</code> to be unsafe, but is it the construction of <code>read_generic::&lt;'unsafe&gt;</code> that is unsafe, or the call operator? I recall having an aha moment when reading the rustbelt paper, when they observed that all lifetime parameters in a function call implicitly have outlives bounds over a lifetime you could call <code>'fn</code> which is the lifetime of the call itself (or the lifetime of the call stack allocation, if you will). In this case, <code>'unsafe</code> clearly does not outlive <code>'fn</code>, but depending on whether you consider this where bound to be early or late bound you could either have the function construction or the call to be unsafe. (Actually, with rust as it exists today, this isn't just unsafe, it's an error. You can't circumvent borrow check errors with an unsafe block, so there needs to be some other mechanism here.)</p>



<a name="263422592"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263422592" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263422592">(Dec 02 2021 at 11:19)</a>:</h4>
<p>Now, there is one thing that irks me with this design (or in other words, <span class="user-mention" data-user-id="271719">@Mario Carneiro</span>, I'm starting to disagree with my own model <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span>) now:</p>
<p>Given <code>&amp;'val mut &amp;'unsafe usize</code>: should <code>'val</code> be (constrained to be) <code>'unsafe</code>?</p>
<p>Well technically yes:</p>
<ul>
<li><code>'inner : 'outer</code> =&gt; <code>'unsafe : 'val</code> (<strong>unless we made an exception for the <code>'inner = 'unsafe</code> case? ughhh</strong>)</li>
<li>But <code>for &lt;'any&gt; 'any : 'unsafe</code> =&gt; <code>'val : 'unsafe</code>.<br>
Hence <code>'val = 'unsafe</code>.</li>
</ul>
<p>And that's a big bummer: <code>fn get (it: &amp;'_ (i32, &amp;'unsafe ())) -&gt; &amp;'_ i32</code> now would become <code>fn get (it: &amp;'unsafe (i32, &amp;'unsafe ())) -&gt; &amp;'unsafe i32</code> just because of that inner <code>'unsafe</code> appearing in an obviously unrelated field! This would totally defeat the point of self-referential structs.</p>
<p>So my previous suggestion doesn't work, or not directly: <code>'unsafe</code> does not represent a stale lifetime, or not exactly, it just represents a hack for the "compositionality" I was talking about:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">type</span> <span class="nc">Ref</span><span class="o">&lt;'</span><span class="na">lt</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;'</span><span class="na">lt</span><span class="w"> </span><span class="n">T</span><span class="p">;</span><span class="w"></span>
<span class="cp">#[magic]</span><span class="w"></span>
<span class="k">type</span> <span class="nc">Ref</span><span class="o">&lt;'</span><span class="na">unsafe</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptr</span>::<span class="n">NonNullAndWellAligned</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
</code></pre></div>
<p>where the RHS would be the genuine "current" Rust types, and the lhs would be sugared to <code>&amp;T</code>. So variance no longer plays that much of a role: any time we'd see <code>&amp;'unsafe …</code> it would just be an alias for a raw pointer, just so that <code>Iter&lt;'lt, T&gt;</code> can become <code>Iter&lt;'unsafe, T&gt;</code> automagically (with all of its API made <code>unsafe</code>).</p>
<ul>
<li>To be more rigorous, imagine, in an HKT world: <code>Iter_&lt;MaybeLifetimedRef&lt;_&gt;, T&gt; { slice: MaybeLifetimedRef&lt;T&gt;, … }</code> then <code>Iter&lt;'lt, T&gt;</code> would be <code>Iter_&lt;&amp;'lt, T&gt;</code>, and and <code>Iter&lt;'unsafe, T&gt;</code> would be <code>Iter_&lt;ptr::NonNullAndAligned, T&gt;</code>.</li>
</ul>
<hr>
<p>All in all, I think there is potential with some idea along these lines, but I have to admit that I find it oh so subtle: using <code>Pin</code> in comparison would be a children's game!</p>



<a name="263422891"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263422891" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263422891">(Dec 02 2021 at 11:22)</a>:</h4>
<p>One way around that is to allow types like <code>&amp;'a &amp;'unsafe T</code> or even <code>&amp;'a &amp;'b T</code> where <code>'b</code> does not outlive <code>'a</code>; it is just unsafe to access in the same way as <code>&amp;'unsafe T</code> (whatever that is; I'm still trying to grok that part). Unfortunately this doesn't play well with implied bounds though</p>



<a name="263423838"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263423838" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263423838">(Dec 02 2021 at 11:32)</a>:</h4>
<p>Maybe the "exception to the implicit outlives rule", despite how ugly, is the only way forward. Back to the <code>read_generic</code> example, what if the author, who knows they aren't <code>'a</code>-dereferencing stuff, wanted to opt into making their function safe to call even with <code>'unsafe</code>, by having to write <code>'unsafe</code>-aware code?</p>
<p>Then that's where we connect with <code>#[may_dangle]</code>:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span> <span class="nf">read_generic</span><span class="o">&lt;</span><span class="cp">#[may_dangle]</span><span class="w"> </span><span class="o">'</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="o">'</span><span class="na">r</span><span class="w"> </span>: <span class="o">'</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">val</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="nb">_</span> <span class="nc">mut</span><span class="w"> </span><span class="o">&amp;'</span><span class="na">a</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">some_ref</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">r</span> <span class="kt">usize</span><span class="p">,</span><span class="w"></span>
<span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="o">*</span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">some_ref</span><span class="p">;</span><span class="w"> </span><span class="c1">// OK (but any `**val` dereference would be forbidden in safe code).</span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">some_caller</span><span class="w"> </span><span class="p">(</span><span class="n">val</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="nb">_</span> <span class="nc">mut</span><span class="w"> </span><span class="o">&amp;'</span><span class="na">unsafe</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">some_ref</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="nb">_</span> <span class="kt">usize</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">read_generic</span><span class="p">(</span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="n">some_ref</span><span class="p">);</span><span class="w"> </span><span class="c1">// OK, no `unsafe`</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>That's all I wanted to mention on the topic, although the implied bounds question is annoying.</p>



<a name="263423864"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263423864" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263423864">(Dec 02 2021 at 11:33)</a>:</h4>
<p>FWIW, another interesting mention <em>w.r.t.</em> RFC would be the instance of atomic decrements being refactored into its own API making stuff technically UB <em>w.r.t.</em> <code>dereferenceable</code> <span class="user-mention" data-user-id="116083">@pnkfelix</span> <span class="user-mention" data-user-id="120791">@RalfJ</span></p>



<a name="263439511"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263439511" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mason Boeman <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263439511">(Dec 02 2021 at 13:52)</a>:</h4>
<p>On the topic of &amp;'val mut &amp;'unsafe, this is legal due to point 2 in the reference level explanation. “The check that a reference does not outlive borrowed content is skipped when the borrowed content has 'unsafe lifetime.”</p>



<a name="263439986"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263439986" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mason Boeman <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263439986">(Dec 02 2021 at 13:56)</a>:</h4>
<p>The *aligned const approach doesn’t solve the core problem which is that there is no way to store a type which is generic over a lifetime the borrow checker doesn’t understand (most often self reference lifetime)</p>



<a name="263442181"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263442181" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mason Boeman <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263442181">(Dec 02 2021 at 14:11)</a>:</h4>
<p>The place where the unsafety of this lifetime primarily comes from is the relaxation of the “reference must outlive borrowed content” check when the borrowed content uses 'unsafe”. We need to have some unavoidable part of the usage process be an unsafe operation, so we make it the variable assignment.<br>
If you don’t assign a variable to it you don’t need to worry about the lifetime being valid when the value is dropped. Coercion of values into unsafe lifetimes is safe, as you know the lifetime is valid at the time of coercion (for example calling a function with an unsafe lifetime in the function definition) but storing that value is not safe because that’s when you are ascribing a scope to it, and therefore a lifetime it is expected to be alive for. You can only assign if you know the variable into which you are assigning will be dropped while the &amp;'unsafe references within are valid.</p>



<a name="263469289"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263469289" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Khionu Sybiern <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263469289">(Dec 02 2021 at 17:07)</a>:</h4>
<p>Just want to chime in and say that this feature would have been pretty useful when I was implementing my actor model, as I was having to force moving by value because of that <code>T: `static</code> catch.</p>



<a name="263506423"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263506423" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263506423">(Dec 02 2021 at 22:04)</a>:</h4>
<p><span class="user-mention" data-user-id="232018">@Daniel Henry-Mantilla</span> I don't think this is actually <em>that</em> complicated. If I understand correctly, what you're suggesting is this:</p>
<ol>
<li><code>'a: 'unsafe</code> for all <code>'a</code>.</li>
<li><code>T&lt;'unsafe&gt;: 'static</code></li>
<li>
<p>Dereferencing a <code>&amp;'unsafe T</code> is instant UB, which implies:<br>
       3.1.  Instantiating any lifetime parameters in scope for a function with <code>'unsafe</code> is instant UB. This resolves the <code>dereferencable</code> issue, I think.</p>
</li>
<li>
<p>Besides that, it works like all other lifetimes</p>
</li>
</ol>
<p>Then, annotating the example:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">slice</span><span class="p">;</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">ArrayIter</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">buffer</span>: <span class="p">[</span><span class="n">T</span><span class="p">;</span><span class="w"> </span><span class="mi">32</span><span class="p">]</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Requires `T: 'unsafe` which is trivially met</span>
<span class="w">    </span><span class="c1">// But is `'static`, so if `T: 'a` then `ArrayIter&lt;T&gt;: 'a`</span>
<span class="w">    </span><span class="n">iter</span>: <span class="nc">slice</span>::<span class="n">Iter</span><span class="o">&lt;'</span><span class="na">unsafe</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ArrayIter</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// this function needs no `unsafe`</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">buffer</span>: <span class="p">[</span><span class="n">T</span><span class="p">;</span><span class="w"> </span><span class="mi">32</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Fake syntax to allow giving this lifetime a name.</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">r</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">a</span> <span class="p">[</span><span class="n">T</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">iter</span>: <span class="nc">slice</span>::<span class="n">Iter</span><span class="o">&lt;'</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span>::<span class="n">primitive</span>::<span class="n">slice</span>::<span class="n">iter</span><span class="p">(</span><span class="n">r</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="c1">// This compiles because of subtyping</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">unsafe_iter</span>: <span class="nc">slice</span>::<span class="n">Iter</span><span class="o">&lt;'</span><span class="na">unsafe</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iter</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="c1">// `'a` may now expire here</span>
<span class="w">        </span><span class="n">ArrayIter</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="c1">// No longer borrowed</span>
<span class="w">            </span><span class="n">iter</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="sd">/// SAFETY: `self` has not been moved since being constructed</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="k">fn</span> <span class="nf">next</span><span class="o">&lt;'</span><span class="na">outer</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;'</span><span class="na">outer</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;&amp;'</span><span class="na">outer</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Fake syntax again. Implies `'outer: 'a`</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">unsafe_ref</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">a</span> <span class="nc">mut</span><span class="w"> </span><span class="n">slice</span>::<span class="n">Iter</span><span class="o">&lt;'</span><span class="na">unsafe</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">iter</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="c1">// This would be UB and is rejected by the compiler</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slice</span>::<span class="n">Iter</span><span class="o">&lt;'</span><span class="na">unsafe</span><span class="o">&gt;</span>::<span class="n">next</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="p">;</span><span class="w"> </span><span class="c1">// ERROR</span>
<span class="w">        </span><span class="c1">// Instead, we transmute the lifetime out first</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">safe_ref</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">a</span> <span class="nc">mut</span><span class="w"> </span><span class="n">slice</span>::<span class="n">Iter</span><span class="o">&lt;'</span><span class="na">outer</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="c1">// SAFETY: The iterator is valid until at least the end of the</span>
<span class="w">            </span><span class="c1">// function because `self` has not been moved</span>
<span class="w">            </span><span class="n">std</span>::<span class="n">mem</span>::<span class="n">transmute</span><span class="p">(</span><span class="n">unsafe_ref</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">};</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Now this is ok</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slice</span>::<span class="n">Iter</span><span class="o">&lt;'</span><span class="na">outer</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span>::<span class="n">next</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">f</span><span class="p">(</span><span class="n">safe_ref</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>Of course, its possible to add in syntax sugar to do the equivalent of the transmute, but the rules at least seem reasonably simple like this.</p>



<a name="263512515"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263512515" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263512515">(Dec 02 2021 at 23:06)</a>:</h4>
<p>On the drop thing: could it be simplified to have the same kind of requirements as unions?  So unless the thing is <code>Copy</code>, you can only have the thing with <code>'unsafe</code> in a <code>ManuallyDrop</code>.</p>



<a name="263512852"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263512852" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263512852">(Dec 02 2021 at 23:09)</a>:</h4>
<p>If this is encouraging transmuting lifetimes, I would encourage it to include a specific function that can <em>only</em> do that.  <code>transmute</code> is a big hammer; a special <code>lifetime_transmute</code> could check that the two types are the same except for the lifetimes to make that less scary.</p>



<a name="263513204"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263513204" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263513204">(Dec 02 2021 at 23:13)</a>:</h4>
<p>One thing that scares me -- though I don't have a concrete example -- is that lifetimes are designed to be erased, so it feels really odd to have one that changes the available operations so thoroughly that it can't be treated like just another lifetime that happens to be shorter.  Our one other specially-namable lifetime what a primary source for specialization unsoundness, for example.</p>



<a name="263518231"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263518231" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263518231">(Dec 03 2021 at 00:07)</a>:</h4>
<p><span class="user-mention" data-user-id="310518">@Jake</span> yes, that's how I was viewing it initially (minimum lifetime; needs <code>unsafe</code> to be used to be dereferenced or fed to a lifetime-generic API (unless it has, itself, <code>#[may_dangle]</code>on that lifetime parameter).<br>
But the part about skipping the "inner lifetime does not need to outlive (live at least as long as) the outer one", as mentioned by <span class="user-mention" data-user-id="461427">@Mason Boeman</span>, would not only be an exception to the lifetime rule; which can be bearable (for the sake of the feature, say), but then the whole "call a generic-over-a-lifetime API with <code>unsafe</code>" would have to go. As <span class="user-mention" data-user-id="125270">@scottmcm</span>, we can't have Rust deal with <code>'a : 'b unless 'a is 'unsafe</code> bounds. So, yes, a <code>.transmute_lifetime_unbounded</code> and <code>.transmute_lifetime(&amp;thing)</code> would be the ways to remove the <code>'unsafe</code>, which would have to be done in order to be able to call a lifetime-generic API.</p>
<p>I guess I tunnel-visioned too much <em>w.r.t</em> calling lifetime-generic APIs, when that is so incompatible with the special "no outlives rule" that <code>'unsafe</code> needs. Incidentally, or actually relatedly, <span class="user-mention" data-user-id="125270">@scottmcm</span>, that would solve the "lifetime erasure" issue, since <code>T&lt;'unsafe&gt;</code> would be a genuinely distinct type from <code>T&lt;'lt&gt;</code>.</p>
<p>In that regard, a nit would be that, there wouldn't be a question of covariance or of <code>'a : 'unsafe</code> : <code>'unsafe</code> would just be a special state / value for a lifetime parameter. With this vision the proposal is consistent, and the no-outlives "special" rule is no longer a weird exception, since it's just a matter of sugar. Heck, when I think about it, maybe we should remove the <code>'</code> in it to remove all confusion: the "<code>unsafe</code> lifetime override": <code>&amp;unsafe T</code>, <code>Iter&lt;unsafe, T&gt;</code>, _etc._</p>



<a name="263519235"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263519235" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263519235">(Dec 03 2021 at 00:19)</a>:</h4>
<p>In that sense <code>'unsafe</code> should basically be read as <code>erased</code> and (if we had that keyword reserved) that would maybe even be a good name for it. This also makes many of the features around this very intuitive; obviously you can't dereference something with an erased lifetime, and lifetime-generic APIs need real, not erased, lifetimes to be called with. <code>transmute_lifetime</code> then becomes <code>unerase_lifetime</code> which is obviously unsafe.</p>



<a name="263519802"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263519802" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mason Boeman <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263519802">(Dec 03 2021 at 00:26)</a>:</h4>
<p>I do really like the “erased” name. Possibly it could go with another suggestion of removing the tick, so just &amp;erased.</p>
<p>One delicate thing is that erasing something’s lifetime is dangerous with types that impl Drop as you need to construct a lifetime at drop time.</p>
<p>Maybe what it should be is </p>
<p>Unsafe fn erase_lifetime(…)<br>
Unsafe fn unerase_lifetime(…).</p>
<p>The reason the first one needs to be unsafe is that you could erase a lifetime and call a drop function which relies on the erased lifetime after it expires, entirely in safe code otherwise.</p>



<a name="263519960"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263519960" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263519960">(Dec 03 2021 at 00:28)</a>:</h4>
<p><span class="user-mention" data-user-id="461427">@Mason Boeman</span> yeah, unfortunately <code>erased</code> on its own won't work, since in <code>T&lt;erased, U&gt;</code> its not clear whether <code>erased</code> is the special lifetime or the unfortunately not uppercase name of some type, and figuring this out would require knowing what the kinds of the generics on <code>T</code> are, which I assume is too context sensitive for Rust.</p>



<a name="263520163"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263520163" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263520163">(Dec 03 2021 at 00:31)</a>:</h4>
<p>I think leaving the <code>'</code> might still be best.  If you have <code>struct Foo&lt;'a, T, A = GlobalAlloc&gt;(...);</code> then <code>Foo&lt;'A, B&gt;</code> and <code>Foo&lt;A, B&gt;</code> are both legal.</p>
<p>(Now, as you said, <code>unsafe</code> is a keyword so it's not actually ambiguous there, but...)</p>



<a name="263520233"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263520233" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263520233">(Dec 03 2021 at 00:32)</a>:</h4>
<p>With regards to the drop issue, I think that Scott's suggestion basically works here. In particular, we can require that you're never allowed to drop a <code>T&lt;'erased&gt;</code>. So either <code>T</code> is <code>Copy</code>, or the <code>T&lt;'erased&gt;</code> gets moved into a <code>ManuallyDrop</code> at some point</p>



<a name="263520485"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263520485" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mason Boeman <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263520485">(Dec 03 2021 at 00:35)</a>:</h4>
<p>I don’t fully understand this. Is there precedent for saying “If your struct contains a 'unsafe lifetime, you must impl drop” and “if your struct is instantiated with the unsafe lifetime it must be copy or moved into a ManuallyDrop”</p>



<a name="263520488"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263520488" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mason Boeman <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263520488">(Dec 03 2021 at 00:35)</a>:</h4>
<p>You would need both</p>



<a name="263520749"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263520749" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mason Boeman <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263520749">(Dec 03 2021 at 00:39)</a>:</h4>
<p>Although you actually have a third out, if you impl drop for T&lt;'unsafe&gt; instead of T&lt;'a&gt; then you can drop it as normal, but that might just make it more confusing and the other two options are more simple</p>



<a name="263520894"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263520894" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263520894">(Dec 03 2021 at 00:41)</a>:</h4>
<p>You would not be required to <code>impl Drop</code> for your struct if it contains a <code>T&lt;'erased&gt;</code> for <code>T: !Copy</code>; the requirement would just be that your struct may not contain <code>T&lt;'erased&gt;</code>, and must instead contain <code>ManuallyDrop&lt;T&lt;'erased&gt;&gt;</code>.</p>



<a name="263520928"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263520928" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mason Boeman <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263520928">(Dec 03 2021 at 00:41)</a>:</h4>
<p>Ooooooooooohhhhh that’s actually much nicer</p>



<a name="263521023"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263521023" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263521023">(Dec 03 2021 at 00:43)</a>:</h4>
<p>So if you want to drop the <code>T</code>, then you need to <code>impl Drop</code> yourself and run the drop there using the appropriate <code>unsafe</code></p>



<a name="263521335"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263521335" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263521335">(Dec 03 2021 at 00:47)</a>:</h4>
<p>This is modulo interaction with <code>#[may_dangle]</code> which actually sounds like it'll make this situation lots easier, since you actually can drop <code>T&lt;'erased&gt;</code> for <code>T&lt;#[may_dangle] 'a&gt;</code> if I'm not mistaken</p>



<a name="263521433"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263521433" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mason Boeman <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263521433">(Dec 03 2021 at 00:48)</a>:</h4>
<p>I’m unclear on the function/purpose of <code>#[may_dangle]</code></p>



<a name="263521532"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263521532" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263521532">(Dec 03 2021 at 00:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="461427">Mason Boeman</span> <a href="#narrow/stream/122651-general/topic/Unsafe.20Lifetime.20RFC/near/263520928">said</a>:</p>
<blockquote>
<p>Ooooooooooohhhhh that’s actually much nicer</p>
</blockquote>
<p>Yeah, I was very happy when that was proposed for <code>union</code>s.  It makes it so much simpler than what the rules otherwise would have had to be, so hopefully the same trick can help here <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="263522177"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263522177" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263522177">(Dec 03 2021 at 00:58)</a>:</h4>
<p><span class="user-mention" data-user-id="461427">@Mason Boeman</span> It's no longer relevant now that we are no longer talking of generics</p>



<a name="263522279"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263522279" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263522279">(Dec 03 2021 at 01:00)</a>:</h4>
<p>I think it still is actually. If <code>T&lt;'a&gt;</code> has <code>#[may_dangle]</code> in its drop impl, it should be sound to drop <code>T&lt;'erased&gt;</code>, therefore not requiring the <code>ManuallyDrop</code></p>



<a name="263522364"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263522364" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263522364">(Dec 03 2021 at 01:00)</a>:</h4>
<p>But I also only 75% understand <code>#[may_dangle]</code>, so am very open to being wrong</p>



<a name="263522735"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263522735" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263522735">(Dec 03 2021 at 01:04)</a>:</h4>
<p>This possibly even opens the door for adding <code>#[may_dangle]</code> on things that aren't <code>impl Drop</code>, although maybe that's a door better left shut</p>



<a name="263522781"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263522781" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263522781">(Dec 03 2021 at 01:05)</a>:</h4>
<p>(where <code>#[may_dangle]</code> is read <code>#[may_be_erased]</code>)</p>



<a name="263523118"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263523118" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mason Boeman <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263523118">(Dec 03 2021 at 01:09)</a>:</h4>
<p>So with this it’s actually totally safe to assign a value T&lt;'a&gt; to a variable T&lt;'unsafe&gt;, because the variable is not allowed to be dropped unless it’s put in a manuallydrop</p>



<a name="263523415"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263523415" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263523415">(Dec 03 2021 at 01:13)</a>:</h4>
<p>Yeah, and I feel like that simplifies a lot of the proposal, since creating, moving, referencing, etc. stuff with erased lifetimes is now entirely safe and all works as expected. Its just that using stuff with erased lifetimes is a compiler error unless you <code>unsafe</code>ly un-erase the lifetime</p>



<a name="263523583"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263523583" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mason Boeman <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263523583">(Dec 03 2021 at 01:14)</a>:</h4>
<p>I will update the RFC to reflect this tonight.</p>



<a name="263525553"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263525553" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263525553">(Dec 03 2021 at 01:40)</a>:</h4>
<p>Hmm, doesn't this actually clean some things in the other direction? If I'm not misunderstanding,</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">unsafe</span><span class="w"> </span><span class="k">impl</span><span class="w"> </span><span class="nb">Drop</span><span class="o">&lt;</span><span class="cp">#[may_dangle]</span><span class="w"> </span><span class="o">'</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">..</span><span class="p">.</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>could now actually be spelled</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">impl</span><span class="w"> </span><span class="nb">Drop</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="o">&lt;'</span><span class="na">erased</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">..</span><span class="p">.</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>which feels <em>much</em> better and seems to make very clear what the semantics of drop checking and that are. In particular, that impl does not need <code>unsafe</code> anymore. Its completely ok to write as long as the check for "don't drop/call methods for things that are <code>U&lt;'erased&gt;</code>" continues to pass; in other words, if <code>T</code> contains a <code>&amp;'a U</code>, then the <code>drop</code> impl will not be allowed to dereference that on the basis of it now being a <code>&amp;'erased U</code></p>



<a name="263525797"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263525797" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mason Boeman <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263525797">(Dec 03 2021 at 01:43)</a>:</h4>
<p>Yeah that is much better. I think I need to read more on may dangle before I can form a solid opinion on that</p>



<a name="263525895"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263525895" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263525895">(Dec 03 2021 at 01:44)</a>:</h4>
<p>Yeah, this is definitely a bit of a side-issue, and I don't understand dropck well enough to actually be sure about this. I would be very interested in seeing what someone who does understand it thinks about this though</p>



<a name="263530009"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263530009" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263530009">(Dec 03 2021 at 02:52)</a>:</h4>
<p>(I'll add some comments about this on the RFC once you've updated it as well, so that even if this isn't part of the proposal its at least documented somewhere more permanent than a zulip stream)</p>



<a name="263531075"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263531075" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263531075">(Dec 03 2021 at 03:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="232018">Daniel Henry-Mantilla</span> <a href="#narrow/stream/122651-general/topic/Unsafe.20Lifetime.20RFC/near/263518231">said</a>:</p>
<blockquote>
<p>there wouldn't be a question of covariance or of <code>'a : 'unsafe</code> : <code>'unsafe</code> would just be a special state / value for a lifetime parameter</p>
</blockquote>
<p>This hadn't really clicked at first, but this is actually a good point and pretty critical to the proposal; <code>T&lt;'a&gt;</code> can always turn into <code>T&lt;'erased&gt;</code> regardless of variance, and when the conversion back from <code>T&lt;'erased&gt;</code> to <code>T&lt;'b&gt;</code> happens, its on that conversion to check that the requirements for the variance are being obeyed.</p>



<a name="263532730"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263532730" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mason Boeman <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263532730">(Dec 03 2021 at 03:48)</a>:</h4>
<p>I think the ability to use a 'a in place of a 'unsafe is critical because it’s the simplest way to construct one of these things. Especially if you have multiple lifetime parameters, only some of which have been erased</p>



<a name="263533059"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263533059" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263533059">(Dec 03 2021 at 03:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="461427">Mason Boeman</span> <a href="#narrow/stream/122651-general/topic/Unsafe.20Lifetime.20RFC/near/263532730">said</a>:</p>
<blockquote>
<p>I think the ability to use a 'a in place of a 'unsafe is critical because it’s the simplest way to construct one of these things. Especially if you have multiple lifetime parameters, only some of which have been erased</p>
</blockquote>
<p>What do you mean?</p>



<a name="263533203"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263533203" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mason Boeman <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263533203">(Dec 03 2021 at 03:58)</a>:</h4>
<p>If I have a T&lt;'a, 'b&gt; and I want to store a T&lt;'unsafe, 'b&gt; I just store it. The fact that 'a: 'unsafe for all 'a makes it trivial to acquire them.</p>



<a name="263534224"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263534224" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263534224">(Dec 03 2021 at 04:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="461427">Mason Boeman</span> <a href="#narrow/stream/122651-general/topic/Unsafe.20Lifetime.20RFC/near/263533203">said</a>:</p>
<blockquote>
<p>If I have a T&lt;'a, 'b&gt; and I want to store a T&lt;'unsafe, 'b&gt; I just store it. The fact that 'a: 'unsafe for all 'a makes it trivial to acquire them.</p>
</blockquote>
<p>Ah, yes. That being said, I actually sort of agree with <span class="user-mention" data-user-id="232018">@Daniel Henry-Mantilla</span> 's explanation that <code>'erased</code> isn't so much a lifetime as it is a special state to assign to a lifetime parameter. <code>'erased</code> doesn't represent a lifetime; instead it represents a "missing" lifetime, and you're free to "remove" the lifetime anytime you want</p>



<a name="263535216"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263535216" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mason Boeman <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263535216">(Dec 03 2021 at 04:36)</a>:</h4>
<p>I think that probably comes down to a borrow checker implementation detail and we’re mostly on the same page. The main reason I think unsafe is a better lifetime choice is because it’s reserved</p>



<a name="263537811"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263537811" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263537811">(Dec 03 2021 at 05:32)</a>:</h4>
<p>The complexity of adding this to the language seems extremely high. It's mentioned in the RFC that one could do all this by just using raw pointers, but that plan is rejected because "that would be hard". Except that the standard library is gaining more and more raw pointer support all the time, and just the other day a PR for a raw pointer iteration type was opened: <a href="https://github.com/rust-lang/rust/pull/91390">https://github.com/rust-lang/rust/pull/91390</a></p>
<p>So, I think that not using raw pointers should be much more strongly justified in the RFC text.</p>



<a name="263538009"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263538009" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263538009">(Dec 03 2021 at 05:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="224471">Lokathor</span> <a href="#narrow/stream/122651-general/topic/Unsafe.20Lifetime.20RFC/near/263537811">said</a>:</p>
<blockquote>
<p>The complexity of adding this to the language seems extremely high. It's mentioned in the RFC that one could do all this by just using raw pointers, but that plan is rejected because "that would be hard". Except that the standard library is gaining more and more raw pointer support all the time, and just the other day a PR for a raw pointer iteration type was opened: <a href="https://github.com/rust-lang/rust/pull/91390">https://github.com/rust-lang/rust/pull/91390</a></p>
<p>So, I think that not using raw pointers should be much more strongly justified in the RFC text.</p>
</blockquote>
<p>The issue here isn't that raw pointers are annoying to deal with, but rather that if I'm using foreign types, I can't convert them to raw pointers without re-implementing all the associated functionality. Being able to iterate over raw pointers doesn't get me anything if the actual type I'm storing demands to have a reference. The <code>slice::Iter</code> example here is a bit of a bad one in that sense, since that is one we could actually replace easily with raw pointers, especially after that RFC. But for general foreign types, this is not possible</p>



<a name="263538060"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263538060" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263538060">(Dec 03 2021 at 05:37)</a>:</h4>
<p>But swapping out <code>&amp;'a T</code> for <code>&amp;'unsafe T</code> is a lie in most cases, so you can't really use the code anyway</p>



<a name="263538234"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263538234" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263538234">(Dec 03 2021 at 05:40)</a>:</h4>
<p>this operation of taking some code that was written for references and hoping that it works for pointers is abstraction-breaking, because the original code assumes some lifetime constraints that were upheld by the borrow checker when it was compiled, and you are passing in something that potentially violates those constraints, resulting in who-knows-what proof obligations that the upstream author has not approved</p>



<a name="263538259"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263538259" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263538259">(Dec 03 2021 at 05:41)</a>:</h4>
<p>That means that internal non-breaking changes could cause UB in downstream code, which is bad for maintainers</p>



<a name="263538322"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263538322" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263538322">(Dec 03 2021 at 05:42)</a>:</h4>
<p>So on the whole I think that having to have a separate raw-pointer API is actually the right answer here</p>



<a name="263538348"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263538348" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263538348">(Dec 03 2021 at 05:43)</a>:</h4>
<p><span class="user-mention silent" data-user-id="271719">Mario Carneiro</span> <a href="#narrow/stream/122651-general/topic/Unsafe.20Lifetime.20RFC/near/263538234">said</a>:</p>
<blockquote>
<p>this operation of taking some code that was written for references and hoping that it works for pointers is abstraction-breaking, because the original code assumes some lifetime constraints that were upheld by the borrow checker when it was compiled, and you are passing in something that potentially violates those constraints, resulting in who-knows-what proof obligations that the upstream author has not approved</p>
</blockquote>
<p>With the version of the suggestion above, this would not be possible. You can't call any lifetime-generic code with an <code>'unsafe</code> lifetime; it's statically prevented and is a compiler error. However, you can <em>store</em> things with a <code>'unsafe</code> lifetime, and then later <code>unsafe</code>ly convert that lifetime to an actual <code>'a</code>, at which point you may once more use the value</p>



<a name="263538419"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263538419" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263538419">(Dec 03 2021 at 05:44)</a>:</h4>
<p>so the issue is layout compatibility between the reference and pointer versions of the data structure?</p>



<a name="263538533"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263538533" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263538533">(Dec 03 2021 at 05:47)</a>:</h4>
<p><span class="user-mention silent" data-user-id="271719">Mario Carneiro</span> <a href="#narrow/stream/122651-general/topic/Unsafe.20Lifetime.20RFC/near/263538419">said</a>:</p>
<blockquote>
<p>so the issue is layout compatibility between the reference and pointer versions of the data structure?</p>
</blockquote>
<p>No, the issue is the non-existence of a pointer version. There's no way to name "<code>T&lt;'a&gt;</code> but store a pointer where the reference goes." That's, under some interpretation, the point of this proposal as I see it</p>



<a name="263538548"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263538548" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263538548">(Dec 03 2021 at 05:48)</a>:</h4>
<p>the solution to that problem is "simple" (requires no language changes): make a pointer version. I think that is <span class="user-mention" data-user-id="224471">@Lokathor</span> 's proposed alternative</p>



<a name="263538624"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263538624" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263538624">(Dec 03 2021 at 05:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="271719">Mario Carneiro</span> <a href="#narrow/stream/122651-general/topic/Unsafe.20Lifetime.20RFC/near/263538548">said</a>:</p>
<blockquote>
<p>the solution to that problem is "simple" (requires no language changes): make a pointer version. I think that is <span class="user-mention silent" data-user-id="224471">Lokathor</span> 's proposed alternative</p>
</blockquote>
<p>This is not at all "simple"; you're proposing that <em>every</em> type in the Rust ecosystem that internally stores a reference provide a pointer alternative instead</p>



<a name="263538643"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263538643" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263538643">(Dec 03 2021 at 05:49)</a>:</h4>
<p>It has to be opt-in, yes. I don't think that doing it for every type makes sense</p>



<a name="263538714"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263538714" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263538714">(Dec 03 2021 at 05:51)</a>:</h4>
<p>maybe I'm just not clear on the killer use cases here; <code>std::slice::Iter</code> isn't that complicated of an example</p>



<a name="263538903"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263538903" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263538903">(Dec 03 2021 at 05:55)</a>:</h4>
<p>Yeah the fact that the intent for this change is specifically so that users can fudge lifetime stuff in types <em>from other crates</em> makes me all kinds of nervous.</p>



<a name="263539284"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263539284" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263539284">(Dec 03 2021 at 06:01)</a>:</h4>
<p><span class="user-mention silent" data-user-id="271719">Mario Carneiro</span> <a href="#narrow/stream/122651-general/topic/Unsafe.20Lifetime.20RFC/near/263538714">said</a>:</p>
<blockquote>
<p>maybe I'm just not clear on the killer use cases here; <code>std::slice::Iter</code> isn't that complicated of an example</p>
</blockquote>
<p>Yeah, the RFC should pick a better one. Let me try and give here a more "abstract" example, maybe that will be helpful: Consider any type, in any crate you don't own (call it <code>T&lt;'a&gt;</code>) that stores internally a <code>&amp;'a mut U</code>. Now imagine that you want to use this to create a self-referencing data structure:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">struct</span> <span class="nc">MyType</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">owned</span>: <span class="nc">U</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">t</span>: <span class="nc">T</span><span class="o">&lt;?</span><span class="p">,</span><span class="w"> </span><span class="o">'</span><span class="na">b</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>You wish to initialize it so that the <code>&amp;'a mut U</code> reference in <code>T</code> refers to <code>owned</code>; of course, this means that you can't move <code>MyType</code>, but let that be your problem (many people have had uses for self-referencing data). The problem that we are looking to solve is what do you make the lifetime parameter on <code>T</code>. You have no named lifetime parameter in scope to put there, and adding it to <code>MyType</code> will make the whole thing positively useless, since one of its fields will <em>always</em> be borrowed for the entire duration of its existence. But if you make it <code>'static</code>, then you also require that <code>U: 'static</code>, and you may not want that either. There's no good way out.</p>
<p>The important thing here is that there is no requirement on what <code>T</code> might reasonably be. Data structures would be a common, but by far not the only, possibility.</p>



<a name="263539362"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263539362" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263539362">(Dec 03 2021 at 06:03)</a>:</h4>
<p>And switching to a pointer version is not possible without the crate defining <code>T</code> duplicating it to a new <code>TWithPointer</code> that has no lifetime parameter and has all its methods marked <code>unsafe</code></p>



<a name="263539462"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263539462" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263539462">(Dec 03 2021 at 06:05)</a>:</h4>
<p><code>MyType</code> in your example has no lifetime arguments, so surely <code>U: 'static</code> anyway</p>



<a name="263539585"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263539585" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263539585">(Dec 03 2021 at 06:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="271719">Mario Carneiro</span> <a href="#narrow/stream/122651-general/topic/Unsafe.20Lifetime.20RFC/near/263539462">said</a>:</p>
<blockquote>
<p><code>MyType</code> in your example has no lifetime arguments, so surely <code>U: 'static</code> anyway</p>
</blockquote>
<p>Yeah, I've adjusted the example</p>



<a name="263539714"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263539714" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263539714">(Dec 03 2021 at 06:10)</a>:</h4>
<p>if we're fudging lifetimes anyway, one way to do that is to have <code>MyType</code> take a <code>'a</code> parameter which satisfies <code>U: 'a</code>. This isn't the actual lifetime of the reference, so it can be instantiated to some top level thing, or <code>'static</code> if <code>U</code> turns out to be static</p>



<a name="263540114"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263540114" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263540114">(Dec 03 2021 at 06:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="271719">Mario Carneiro</span> <a href="#narrow/stream/122651-general/topic/Unsafe.20Lifetime.20RFC/near/263539714">said</a>:</p>
<blockquote>
<p>if we're fudging lifetimes anyway, one way to do that is to have <code>MyType</code> take a <code>'a</code> parameter which satisfies <code>U: 'a</code>. This isn't the actual lifetime of the reference, so it can be instantiated to some top level thing, or <code>'static</code> if <code>U</code> turns out to be static</p>
</blockquote>
<p>How do I actually instantiate this struct then? eg in</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">my_api</span><span class="p">(</span><span class="n">u</span>: <span class="nc">U</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// here</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>In order to create such an <code>'a</code> (that gives that bound), I'd need to actually borrow <code>U</code> for <code>'a</code>, but thats not an option. Maybe there's a trick I'm missing here</p>



<a name="263540267"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263540267" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263540267">(Dec 03 2021 at 06:22)</a>:</h4>
<p>Assuming that <code>U</code> is a concrete type there, you take <code>'a</code> to be <code>'static</code>, and to satisfy the requirements you construct a <code>T&lt;'a, U&gt;</code> (where <code>'a</code> is a function-local lifetime) and transmute it to a <code>T&lt;'static, U&gt;</code></p>



<a name="263540277"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263540277" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263540277">(Dec 03 2021 at 06:22)</a>:</h4>
<p>that's what I meant by fudging lifetimes</p>



<a name="263540286"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263540286" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mason Boeman <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263540286">(Dec 03 2021 at 06:23)</a>:</h4>
<p>This requires that U is 'static</p>



<a name="263540306"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263540306" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263540306">(Dec 03 2021 at 06:24)</a>:</h4>
<p>Yes, I'm assuming that at the point of <code>my_api</code> you know what type <code>U</code> is and that it is <code>'static</code>. If not, you keep bubbling the constraint up</p>



<a name="263540355"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263540355" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263540355">(Dec 03 2021 at 06:24)</a>:</h4>
<p>Agh, I left out the generic param again. Sorry, let me fix</p>



<a name="263540357"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263540357" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263540357">(Dec 03 2021 at 06:24)</a>:</h4>
<p>so it would be <code>pub fn my_api&lt;'a, U&gt;(u: U) where U: 'a {}</code></p>



<a name="263540370"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263540370" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mason Boeman <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263540370">(Dec 03 2021 at 06:24)</a>:</h4>
<p>I just updated the rfc btw to reflect our conversations here</p>



<a name="263540395"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263540395" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263540395">(Dec 03 2021 at 06:25)</a>:</h4>
<p>I'm not saying this is a great solution, but I'm pretty sure it works, and I have used things like it with self referential structs before</p>



<a name="263540414"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263540414" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mason Boeman <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263540414">(Dec 03 2021 at 06:25)</a>:</h4>
<p>I have a use case in a self referential struct which is not possible in current rust</p>



<a name="263540417"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263540417" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mason Boeman <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263540417">(Dec 03 2021 at 06:26)</a>:</h4>
<p>Give me a minute</p>



<a name="263540457"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263540457" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263540457">(Dec 03 2021 at 06:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="271719">Mario Carneiro</span> <a href="#narrow/stream/122651-general/topic/Unsafe.20Lifetime.20RFC/near/263540357">said</a>:</p>
<blockquote>
<p>so it would be <code>pub fn my_api&lt;'a, U&gt;(u: U) where U: 'a {}</code></p>
</blockquote>
<p>That would be an exceptionally weird constraint to have in a public API.</p>



<a name="263540472"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263540472" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263540472">(Dec 03 2021 at 06:26)</a>:</h4>
<p>well, it would be great if <code>'lifetime_of(U)</code> was a thing, but we have to make do</p>



<a name="263540595"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263540595" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263540595">(Dec 03 2021 at 06:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="224471">Lokathor</span> <a href="#narrow/stream/122651-general/topic/Unsafe.20Lifetime.20RFC/near/263538903">said</a>:</p>
<blockquote>
<p>Yeah the fact that the intent for this change is specifically so that users can fudge lifetime stuff in types <em>from other crates</em> makes me all kinds of nervous.</p>
</blockquote>
<p>Yeah, this was actually my initial reaction too. The thing that comforts me with the most recent version of this is that there is a hard rule of "no lifetime-generic code may ever be instantiated with an <code>'unsafe</code> lifetime". That should very categorically prevent any issues with this; I'm more worried about being able to detect local issues caused by the new lifetime</p>



<a name="263540598"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263540598" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mason Boeman <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263540598">(Dec 03 2021 at 06:29)</a>:</h4>
<p>Actually my example is essentially what Jake just commented on. You can’t be generic over non 'static types and also not require a meaningless lifetime specifier at the same time</p>



<a name="263540654"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263540654" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mason Boeman <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263540654">(Dec 03 2021 at 06:30)</a>:</h4>
<p>And be self referential</p>



<a name="263540842"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263540842" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263540842">(Dec 03 2021 at 06:34)</a>:</h4>
<p>Actually that constraint is unnecessary, since rust can discharge it fine:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span> <span class="nf">foo</span><span class="o">&lt;'</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="n">u</span>: <span class="nc">U</span><span class="p">)</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">U</span>: <span class="o">'</span><span class="na">a</span> <span class="p">{}</span><span class="w"></span>
<span class="k">fn</span> <span class="nf">bar</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="n">u</span>: <span class="nc">U</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</code></pre></div>



<a name="263541169"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263541169" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mason Boeman <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263541169">(Dec 03 2021 at 06:40)</a>:</h4>
<p>In functions it can be dropped but The problem is storing it.</p>



<a name="263541218"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263541218" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mason Boeman <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263541218">(Dec 03 2021 at 06:40)</a>:</h4>
<p>You can’t drop the lifetime param by wrapping the struct or some other technique</p>



<a name="263541629"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263541629" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263541629">(Dec 03 2021 at 06:48)</a>:</h4>
<p>right, the idea here is to keep the lifetime parameter in the struct and only eliminate it from functions that don't use the struct</p>



<a name="263541655"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263541655" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263541655">(Dec 03 2021 at 06:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="461427">Mason Boeman</span> <a href="#narrow/stream/122651-general/topic/Unsafe.20Lifetime.20RFC/near/263535216">said</a>:</p>
<blockquote>
<p>I think that probably comes down to a borrow checker implementation detail and we’re mostly on the same page. The main reason I think unsafe is a better lifetime choice is because it’s reserved</p>
</blockquote>
<p>I'm not arguing so much about the name, I think there is a difference of interpretation. What I will try and do later tonight is do a full-writeup of the interpretation of this that I am thinking about, just to document it (and two explanations is always better than one)</p>



<a name="263541939"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263541939" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263541939">(Dec 03 2021 at 06:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="461427">Mason Boeman</span> <a href="#narrow/stream/122651-general/topic/Unsafe.20Lifetime.20RFC/near/263541218">said</a>:</p>
<blockquote>
<p>You can’t drop the lifetime param by wrapping the struct or some other technique</p>
</blockquote>
<p>Hmm, what if you indirect via GATs?</p>
<p>Sketch of the idea:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">trait</span><span class="w"> </span><span class="n">TypeGen</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Type</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">IterGen</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">!</span><span class="p">,</span><span class="w"> </span><span class="n">PhantomData</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">);</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">TypeGen</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">IterGen</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Type</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span>::<span class="n">slice</span>::<span class="n">Iter</span><span class="o">&lt;'</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">FunkyHolder</span><span class="o">&lt;</span><span class="n">G</span>: <span class="nc">TypeGen</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">unsafe_val</span>: <span class="nc">ManuallyDrop</span><span class="o">&lt;&lt;</span><span class="n">G</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">TypeGen</span><span class="o">&gt;</span>::<span class="n">Type</span><span class="o">&lt;'</span><span class="nb">static</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">G</span>: <span class="nc">TypeGen</span><span class="o">&gt;</span><span class="w"> </span><span class="n">FunkyHolder</span><span class="o">&lt;</span><span class="n">G</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">real</span>: <span class="o">&lt;</span><span class="n">G</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">TypeGen</span><span class="o">&gt;</span>::<span class="n">Type</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 'static is a lie, but we only let unsafe callers look at it.</span>
<span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">unsafe_val</span>: <span class="nc">ManuallyDrop</span>::<span class="n">new</span><span class="p">(</span><span class="n">transmute</span><span class="p">(</span><span class="n">real</span><span class="p">))</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="k">fn</span> <span class="nf">get_with_unchecked_lifetime</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="o">&lt;</span><span class="n">G</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">TypeGen</span><span class="o">&gt;</span>::<span class="n">Type</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">transmute</span><span class="p">(</span><span class="n">ManuallyDrop</span>::<span class="n">into_inner</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">unsafe_val</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<div class="codehilite"><pre><span></span><code>
</code></pre></div>



<a name="263542383"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263542383" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263542383">(Dec 03 2021 at 07:02)</a>:</h4>
<p><span class="user-mention" data-user-id="125270">@scottmcm</span> that does not compile  with an error that suggests adding "consider adding a where clause: <code>where T: 'a</code>" to the <code>impl TypeGen for IterGen</code></p>



<a name="263557634"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263557634" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263557634">(Dec 03 2021 at 10:07)</a>:</h4>
<p>That would be solved by making <code>TypeGen</code> generic over <code>T</code>. All this is getting pretty close to:</p>
<p><span class="user-mention silent" data-user-id="232018">Daniel Henry-Mantilla</span> <a href="#narrow/stream/122651-general/topic/Unsafe.20Lifetime.20RFC/near/263422592">said</a>:</p>
<blockquote>
<ul>
<li>To be more rigorous, imagine, in an HKT world: <code>Iter_&lt;MaybeLifetimedRef&lt;_&gt;, T&gt; { slice: MaybeLifetimedRef&lt;T&gt;, … }</code> then <code>Iter&lt;'lt, T&gt;</code> would be <code>Iter_&lt;&amp;'lt, T&gt;</code>, and and <code>Iter&lt;'unsafe, T&gt;</code> would be <code>Iter_&lt;ptr::NonNullAndAligned, T&gt;</code>.</li>
</ul>
</blockquote>
<p>but for GAT being the implementation of the HKT semantics.</p>
<hr>
<p>Back to the original issue, if we were to be "fudging lifetimes", then what we'd be missing here would be a "<code>'lifetime_of!</code>" kind of operator. For the sake of the explanation, I'll imagine it written as <code>'T</code> for some type parameter <code>T</code> (although it could be shadowed by an explicit <code>bad_style</code> parameter <code>&lt;'T&gt;</code>, for the sake of retro-compat). The semantics would be those of the "existential" pattern <span class="user-mention" data-user-id="271719">@Mario Carneiro</span> was talking about: <code>&lt;T&gt;</code> (and use <code>'T</code>) would be equivalent to <code>&lt;'T, T : 'T&gt;</code>, except for that <code>'T</code> swept under the rug, so that <code>&amp;'T T</code> always works. That way we could "hide the existential genericity" of the struct, which is the main ergonomics of self-referential stuff:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">struct</span> <span class="nc">Foo</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="n">U</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;'</span><span class="na">U</span><span class="w"> </span><span class="n">U</span><span class="p">);</span><span class="w"></span>
<span class="c1">// vs.</span>
<span class="k">struct</span> <span class="nc">Foo</span><span class="o">&lt;'</span><span class="na">U</span><span class="p">,</span><span class="w"> </span><span class="n">U</span><span class="w"> </span>: <span class="o">'</span><span class="na">U</span><span class="o">&gt;</span><span class="p">(</span><span class="n">U</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;'</span><span class="na">U</span><span class="p">,</span><span class="w"> </span><span class="n">U</span><span class="p">);</span><span class="w"></span>
</code></pre></div>
<p>That being said, this whole thing would be lying about lifetimes since the beginning, which is unsound as per Stacked Borrows model:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">thing</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span>::<span class="n">new_uninit</span>::<span class="o">&lt;</span><span class="n">Foo</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;&gt;</span><span class="p">();</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">at_u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">thing</span><span class="p">.</span><span class="n">as_mut_ptr</span><span class="p">().</span><span class="n">cast</span>::<span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">().</span><span class="n">add</span><span class="p">(</span><span class="n">offset_of</span><span class="o">!</span><span class="p">(</span><span class="n">Foo</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">.</span><span class="mi">0</span><span class="p">)).</span><span class="n">cast</span>::<span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>
<span class="n">at_u</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">value</span><span class="p">);</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">at_u</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">U</span> <span class="nc">U</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;*</span><span class="n">at_ut</span><span class="p">;</span><span class="w"> </span><span class="c1">// Fudging lifetimes</span>
<span class="n">thing</span><span class="p">.</span><span class="n">as_mut_ptr</span><span class="p">().</span><span class="n">cast</span>::<span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">().</span><span class="n">add</span><span class="p">(</span><span class="n">offset_of</span><span class="o">!</span><span class="p">(</span><span class="n">Foo</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">.</span><span class="mi">1</span><span class="p">)).</span><span class="n">cast</span>::<span class="o">&lt;&amp;'</span><span class="na">U</span><span class="w"> </span><span class="n">U</span><span class="o">&gt;</span><span class="p">().</span><span class="n">write</span><span class="p">(</span><span class="n">at_u</span><span class="p">);</span><span class="w"></span>
<span class="o">&lt;</span><span class="n">Pin</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;&gt;</span>::<span class="n">from</span><span class="p">(</span><span class="nb">Box</span>::<span class="n">assume_init</span><span class="p">(</span><span class="n">thing</span><span class="p">))</span><span class="w"></span>
</code></pre></div>
<p>The issue is that the moment a <code>Box&lt;Foo&lt;U&gt;&gt;</code> is constructed, it asserts lack of aliasing of the pointee <code>Foo&lt;U&gt;</code>, and of all of its constituents, thus invalidating the generated <code>at_u</code>, which is rendered unusable (lest we trigger UB —under the SB model—).</p>
<p>Now, making <code>at_u</code> a raw pointer, either in an <em>ad-hoc</em>  fashion (using <code>ptr::NonNull&lt;U&gt;</code>),  or in the suggested more general approach here (using <code>&amp;unsafe U</code> (I'm sticking to no tick to avoid confusion)), would not solve the problem alone, but it would already help with the symmetrical situation (existence of a <code>at_u: &amp;[mut] U</code> asserting stuff about <code>U</code> which forbids us from ever touching <code>U</code>). Indeed, if you combine that with replacing the outer <code>Box</code> with an <a href="https://docs.rs/aliasable"><code>::aliasable</code></a> one, you'd now finally achieve a sound self-referential type.</p>



<a name="263558271"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263558271" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263558271">(Dec 03 2021 at 10:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="224471">Lokathor</span> <a href="#narrow/stream/122651-general/topic/Unsafe.20Lifetime.20RFC/near/263538903">said</a>:</p>
<blockquote>
<p>Yeah the fact that the intent for this change is specifically so that users can fudge lifetime stuff in types <em>from other crates</em> makes me all kinds of nervous.</p>
</blockquote>
<p>Yes, this ought to be the main concern: fudging lifetimes in other types should not de done unless the type itself properly documented its safety invariants (or rather, lack thereof):</p>
<p><span class="user-mention silent" data-user-id="232018">Daniel Henry-Mantilla</span> <a href="#narrow/stream/122651-general/topic/Unsafe.20Lifetime.20RFC/near/263417521">said</a>:</p>
<blockquote>
<p>Maybe the RFC should thus mention that it <em>should</em> (as in recommended, not mandatory) only be used with types defined in the same crates, or types of dependencies <em>provided</em> they properly document their lifetime-related properties.</p>
</blockquote>



<a name="263722025"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263722025" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mason Boeman <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263722025">(Dec 04 2021 at 17:53)</a>:</h4>
<p>another approach, which would enable this with extreme unsafety in exchange for very minimal changes to the language is a const function like <code>core::mem::size_of</code> which is allowed to ignore generic parameters.</p>
<p>here's a playground exploring the idea:<br>
<a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=430355b2705e7d84e5ba23e16cf5aba8">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=430355b2705e7d84e5ba23e16cf5aba8</a></p>



<a name="263723196"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263723196" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263723196">(Dec 04 2021 at 18:13)</a>:</h4>
<p>Iirc specialization allows types to have extra fields depending on parameters. So <code>Iter&lt;'static&gt;</code> could have a different size than <code>Iter&lt;'some_concrete_lifetime_that_is_not_static&gt;</code> and that approach falls apart.</p>



<a name="263724104"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263724104" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mason Boeman <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263724104">(Dec 04 2021 at 18:28)</a>:</h4>
<p><a href="https://github.com/rust-lang/rfcs/blob/master/text/1210-impl-specialization.md#interaction-with-lifetimes">https://github.com/rust-lang/rfcs/blob/master/text/1210-impl-specialization.md#interaction-with-lifetimes</a></p>
<p>according to the rfc this is explicitly not possible</p>



<a name="263724688"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263724688" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263724688">(Dec 04 2021 at 18:42)</a>:</h4>
<p>Well, that might be a fault in the current implementation then. The layout can depend on a trait and the trait in turn can be selectively implemented for 'static. The rules say you must not do that, but you can. I thought the plan was to fix the unsafety that arises from that. But maybe it'll be fixed by detecting and forbidding it reliably.</p>



<a name="263724815"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263724815" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mason Boeman <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263724815">(Dec 04 2021 at 18:44)</a>:</h4>
<p>How do you add fields to something by specializing trait impls</p>



<a name="263724828"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263724828" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mason Boeman <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263724828">(Dec 04 2021 at 18:44)</a>:</h4>
<p>I don’t understand how the memory layout can be effected by it at all</p>



<a name="263724871"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263724871" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263724871">(Dec 04 2021 at 18:45)</a>:</h4>
<p>iter::Zip used to do that, let me find the PR that changed that</p>



<a name="263725082"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263725082" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263725082">(Dec 04 2021 at 18:49)</a>:</h4>
<p>here's the PR that introduced it. It's using an associated type as a struct member and the type varies based on specialization.</p>



<a name="263725084"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263725084" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263725084">(Dec 04 2021 at 18:49)</a>:</h4>
<p><a href="https://github.com/rust-lang/rust/pull/33090/files">https://github.com/rust-lang/rust/pull/33090/files</a></p>



<a name="263725164"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263725164" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mason Boeman <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263725164">(Dec 04 2021 at 18:50)</a>:</h4>
<p>It still doesn’t really make sense to me how something can specialize over 'static since those can be coerced into non 'static</p>



<a name="263725397"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263725397" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263725397">(Dec 04 2021 at 18:55)</a>:</h4>
<p>Unless the type is invariant</p>



<a name="263725499"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263725499" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263725499">(Dec 04 2021 at 18:56)</a>:</h4>
<p>but yeah, that's basically the problem why specialization is an incomplete feature</p>



<a name="263725553"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263725553" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mason Boeman <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263725553">(Dec 04 2021 at 18:57)</a>:</h4>
<p>it seems like their stated intention is for that to be illegal, so shouldn’t that mean the transmute-into-bytes approach should be fine?</p>



<a name="263725625"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263725625" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263725625">(Dec 04 2021 at 18:59)</a>:</h4>
<p>hrm, probably</p>



<a name="263726197"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263726197" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263726197">(Dec 04 2021 at 19:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="461427">Mason Boeman</span> <a href="#narrow/stream/122651-general/topic/Unsafe.20Lifetime.20RFC/near/263725553">said</a>:</p>
<blockquote>
<p>it seems like their stated intention is for that to be illegal, so shouldn’t that mean the transmute-into-bytes approach should be fine?</p>
</blockquote>
<p>This approach is only ok if a <code>&amp;mut T</code> to <code>usize</code> transmute is not UB, and I believe the most recent state of things was that this probably <em>is</em> UB (cc <span class="user-mention" data-user-id="120791">@RalfJ</span> )</p>



<a name="263726298"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263726298" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mason Boeman <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263726298">(Dec 04 2021 at 19:10)</a>:</h4>
<p>If you transmute back before doing anything with it where is it possible for UB to come in</p>



<a name="263726358"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263726358" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263726358">(Dec 04 2021 at 19:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="461427">Mason Boeman</span> <a href="#narrow/stream/122651-general/topic/Unsafe.20Lifetime.20RFC/near/263726298">said</a>:</p>
<blockquote>
<p>If you transmute back before doing anything with it where is it possible for UB to come in</p>
</blockquote>
<p>I believe the issue was that the original transmute is instantly UB, no matter what you end up doing after, for provenance reasons (in particular turning a pointer into an integer is not a no-op on the abstract machine)</p>



<a name="263732570"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263732570" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263732570">(Dec 04 2021 at 21:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="461427">Mason Boeman</span> <a href="#narrow/stream/122651-general/topic/Unsafe.20Lifetime.20RFC/near/263725164">said</a>:</p>
<blockquote>
<p>It still doesn’t really make sense to me how something can specialize over 'static since those can be coerced into non 'static</p>
</blockquote>
<p>That example is exactly why <code>feature(specialization)</code> is unsound, yes <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p>



<a name="263751403"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263751403" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263751403">(Dec 05 2021 at 05:46)</a>:</h4>
<p><span class="user-mention" data-user-id="461427">@Mason Boeman</span> I've thought about this quite a bit today and yesterday. In my opinion, there's an aspect of this that is way under-specified and probably a massive issue, and that is the implications of this for type checking. Thinking in terms of the type system for a second, its clear that <code>'unsafe</code> can't actually mean "the shortest lifetime" because that would be incredibly unsound for contra-variant lifetimes. Instead, it has to be some kind of non-lifetime that can be used in place of a lifetime, but isn't a lifetime at all. What does this mean for type checking though? Consider, for example</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">trait</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Assoc</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">get</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Assoc</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;'</span><span class="na">a</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Assoc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">i32</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">get</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="o">**</span><span class="bp">self</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">S</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">v</span>: <span class="o">&lt;&amp;'</span><span class="na">a</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">A</span><span class="o">&gt;</span>::<span class="n">Assoc</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">f</span><span class="p">(</span><span class="n">s</span>: <span class="nc">S</span><span class="o">&lt;'</span><span class="na">unsafe</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">     </span><span class="c1">// what happens here?</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>How is the behavior of the type checker meant to change in the body of <code>f</code>? In the past, it would have been allowed to use <code>S&lt;'unsafe&gt;</code> being well-formed to conclude that <code>&lt;&amp;'unsafe i32 as A&gt;::Assoc</code> is well-formed, and hence <code>&amp;'unsafe i32: A</code>. But that's not the case! In other words, getting this kind of change through requires fundamentally changing the rules for type checking, at least around this <code>'unsafe</code> lifetime, and exactly how that is to work needs to be 1) a part of the RFC, and 2) designed with <em>extreme</em> care to ensure safety guarantees are upheld</p>



<a name="263762109"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263762109" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263762109">(Dec 05 2021 at 10:48)</a>:</h4>
<p><span class="user-mention" data-user-id="310518">@Jake</span> I'd say that it should compile fail with <code>A is not implemented for &amp;unsafe i32</code></p>



<a name="263764041"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263764041" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263764041">(Dec 05 2021 at 11:36)</a>:</h4>
<p><span class="user-mention" data-user-id="232018">@Daniel Henry-Mantilla</span> but when do you want that error? When naming <code>S&lt;'unsafe&gt;</code> as a type? That isn't really an option, since <code>S</code> can be a foreign type with private fields so now you can never use any <code>T&lt;'unsafe&gt;</code>. What's the alternative?</p>



<a name="263764514"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263764514" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263764514">(Dec 05 2021 at 11:49)</a>:</h4>
<p>Indeed, there should be an opt-in way to allow for <code>'unsafe</code> substitution.<br>
And even then, we have a problem: if <code>&amp;unsafe T</code> is a distinct type from <code>&amp;'a T</code> (which it should), then through type-assoc indirection <code>Foo&lt;unsafe&gt;</code> and <code>Foo&lt;'a&gt;</code> may not have the same layout, breaking the back-and-forth</p>



<a name="263764788"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263764788" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263764788">(Dec 05 2021 at 11:57)</a>:</h4>
<p>Making unsafe opt-in on types is probably a non-starter for this idea, since the background is that we want to be able to erase the lifetime on arbitrary foreign types that don't necessarily care about <code>'unsafe</code></p>



<a name="263764862"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263764862" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263764862">(Dec 05 2021 at 11:59)</a>:</h4>
<p>Also I don't think the layout thing is an actual problem. <code>&amp;'a T</code> and <code>&amp;'b T</code> are already different types, and <code>Foo&lt;'a&gt;</code> and <code>Foo&lt;'b&gt;</code> cannot have different layouts</p>



<a name="263765074"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263765074" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263765074">(Dec 05 2021 at 12:02)</a>:</h4>
<p>To be clear, as far as I can tell, I don't think you can actually achieve any unsoundness with the example I posted above. Even if you manage to trick the compiler into believing what is not true, at the latest when you do impl matching when monomorphizing, you'll find no matching impl for <code>&amp;'unsafe i32: A</code> and ICE. The problem is just that I don't see how to write a correct type checker in the face of this</p>



<a name="263766335"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263766335" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263766335">(Dec 05 2021 at 12:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310518">Jake</span> <a href="#narrow/stream/122651-general/topic/Unsafe.20Lifetime.20RFC/near/263764862">said</a>:</p>
<blockquote>
<p>Also I don't think the layout thing is an actual problem. <code>&amp;'a T</code> and <code>&amp;'b T</code> are already different types, and <code>Foo&lt;'a&gt;</code> and <code>Foo&lt;'b&gt;</code> cannot have different layouts</p>
</blockquote>
<p>Because until now you couldn't talk of a non-<code>'static</code> lifetime without talking of all the lifetimes together, hence having coherence prevent the different layouts for <code>Foo&lt;'a&gt;</code> and <code>Foo&lt;'b&gt;</code>. But now <code>'unsafe</code> represents another distinct and nameable lifetime, and one which is not covered by <code>&lt;'a&gt;</code> genericity (we went over this the first time I mentioned dropping the tick; for this very reason btw):</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">impl</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;'</span><span class="na">a</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">type</span> <span class="nc">Assoc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="k">impl</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="k">unsafe</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">type</span> <span class="nc">Assoc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">();</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">Foo</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="p">(</span><span class="w"> </span><span class="o">&lt;&amp;'</span><span class="na">a</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">A</span><span class="o">&gt;</span>::<span class="n">Assoc</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="c1">// what is `Foo&lt;unsafe&gt;`?</span>
</code></pre></div>
<p>Either those two first impls don't overlap, and thus we can't guarantee same layout, or they do, but then <code>for&lt;'a&gt; fn(&amp;'a i32) -&gt; i32</code> ought to be callable with a <code>&amp;unsafe i32</code> parameter, which then leads to its own can of worms (outlives rule, <em>etc.</em>)</p>



<a name="263766582"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/263766582" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#263766582">(Dec 05 2021 at 12:41)</a>:</h4>
<p>So two thoughts. It's 1) not absolutely necessary to allow <code>impl A for &amp;unsafe i32</code>, and 2) <code>impl A for &amp;unsafe i32</code> can mean <code>impl&lt;'a&gt; A for &amp;unsafe i32 + &amp;'a i32</code>. This is actually why I think the <code>'erased</code> name is more clear, because it makes this second thing more obvious</p>



<a name="264169959"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/264169959" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#264169959">(Dec 08 2021 at 15:21)</a>:</h4>
<p><span class="user-mention silent" data-user-id="461427">Mason Boeman</span> <a href="#narrow/stream/122651-general/topic/Unsafe.20Lifetime.20RFC/near/263726298">said</a>:</p>
<blockquote>
<p>If you transmute back before doing anything with it where is it possible for UB to come in</p>
</blockquote>
<p>transmuting <code>0x03u8</code> to <code>bool</code> and back is UB (and <a href="https://www.ralfj.de/blog/2020/07/15/unused-data.html">this is why</a>).<br>
transmuting a reference to a <code>usize</code> and back might be UB in a similar way, though the reasons are complicated...<br>
<code>MaybeUninit&lt;u8/usize&gt;</code> would be more suited as a "general type holding arbitrary data".</p>



<a name="264201132"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/264201132" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jacob Lifshay <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#264201132">(Dec 08 2021 at 18:44)</a>:</h4>
<p><code>MaybeUninit&lt;usize&gt;</code> isn't any more suitable than <code>usize</code> as a thing to transmute pointers to...it generates the exact same llvm ir:<br>
<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=907d437c45653ba2afb31a8e5cd698d5">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=907d437c45653ba2afb31a8e5cd698d5</a></p>



<a name="264205416"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/264205416" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Eh2406 <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#264205416">(Dec 08 2021 at 19:14)</a>:</h4>
<p>Correction, it generates the exact same LLVM IR on this particular compiler today. UB is allowed to generate anything, including the code you intended. So generating the code you intended is not proof of defined behavior.</p>



<a name="264206116"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/264206116" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jacob Lifshay <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#264206116">(Dec 08 2021 at 19:19)</a>:</h4>
<p>I was attempting to prove that it has undefined behavior...assuming that transmuting pointers to integers is undefined behavior.</p>



<a name="264393926"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Unsafe%20Lifetime%20RFC/near/264393926" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Unsafe.20Lifetime.20RFC.html#264393926">(Dec 10 2021 at 01:51)</a>:</h4>
<p>well that just means we have to change the LLVM IR generation if we chose this way to clarify our semantics.<br>
LLVM is currently internally inconsistent, so until they resolved that problem there is not really a way to do correct translation.<br>
(and they are still in the 'denial' stage as far as I can see from the discussions around the byte type, so first they need to be convinced that there is a problem before there is any hope of fixing it)</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>