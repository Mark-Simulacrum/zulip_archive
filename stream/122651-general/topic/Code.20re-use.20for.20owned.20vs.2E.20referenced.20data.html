<html>
<head><meta charset="utf-8"><title>Code re-use for owned vs. referenced data · general · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/122651-general/index.html">general</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Code.20re-use.20for.20owned.20vs.2E.20referenced.20data.html">Code re-use for owned vs. referenced data</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="250419757"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Code%20re-use%20for%20owned%20vs.%20referenced%20data/near/250419757" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Will Crichton <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Code.20re-use.20for.20owned.20vs.2E.20referenced.20data.html#250419757">(Aug 23 2021 at 22:21)</a>:</h4>
<h1>The problem</h1>
<p>I'm implementing a data structure that wraps a <code>Set</code> data type. Imagine:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">struct</span> <span class="nc">MySet</span><span class="p">(</span><span class="n">Set</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">);</span><span class="w"></span>
</code></pre></div>
<p>I would like to have two versions of this struct: one that owns the interior, and one that doesn't. (Same issue as <code>String</code> vs <code>&amp;str</code>, <code>PathBuf</code> vs. <code>Path</code>, etc.). The most common approach I've seen for this is having multiple distinct types:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">struct</span> <span class="nc">MySet</span><span class="p">(</span><span class="n">Set</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">);</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">MySetRef</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;'</span><span class="na">a</span><span class="w"> </span><span class="n">Set</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">);</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">MySetMutRef</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;'</span><span class="na">a</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">Set</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">);</span><span class="w"></span>
</code></pre></div>
<p>I have two goals. First, I want to reuse methods that apply across each type. For example:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">impl</span><span class="w"> </span><span class="n">MySet</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="bp">self</span><span class="p">.</span><span class="mf">0.</span><span class="n">len</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>Ideally, I could write the body of this method once and re-use it for all three data types. </p>
<p>Second, I want to write functions that are generic in choice of data structure. For example:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span> <span class="nf">print_len</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="nc">MySet</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="fm">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">len</span><span class="p">());</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<h1>My solution</h1>
<p>I came up with something like this.</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="c1">// 1. define three variants of the inner type</span>
<span class="k">struct</span> <span class="nc">OwnedSet</span><span class="p">(</span><span class="n">Set</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">);</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">RefSet</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;'</span><span class="na">a</span><span class="w"> </span><span class="n">Set</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">);</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">MutSet</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;'</span><span class="na">a</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">Set</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">);</span><span class="w"></span>

<span class="c1">// 2. impl Deref and DerefMut for each type as applicable</span>
<span class="k">impl</span><span class="w"> </span><span class="n">Deref</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">OwnedSet</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">type</span> <span class="nc">Target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Set</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">fn</span> <span class="nf">deref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Self</span>::<span class="n">Target</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="c1">// ... more impls ...</span>

<span class="c1">// 3. Make the container generic in the inner type</span>
<span class="k">struct</span> <span class="nc">MySet</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span><span class="p">(</span><span class="n">S</span><span class="p">);</span><span class="w"></span>

<span class="c1">// 4. Implement methods depending on whether the inner type implements Deref or DerefMut</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">S</span>: <span class="nc">Deref</span><span class="o">&lt;</span><span class="n">Target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Set</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">MySet</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="bp">self</span><span class="p">.</span><span class="mf">0.</span><span class="n">len</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">S</span>: <span class="nc">DerefMut</span><span class="o">&lt;</span><span class="n">Target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Set</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">MySet</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 5. if a method would take another set as input, use a generic S2 instead of Self to allow mixed mut/immut sets</span>
<span class="w">  </span><span class="k">fn</span> <span class="nf">intersect</span><span class="o">&lt;</span><span class="n">S2</span>: <span class="nc">Deref</span><span class="o">&lt;</span><span class="n">Target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Set</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">MySet</span><span class="o">&lt;</span><span class="n">S2</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="bp">self</span><span class="p">.</span><span class="mf">0.</span><span class="n">intersect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">other</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>Does anyone know of other code that implements a similar strategy? Or of a cleaner version of this strategy? Pitfalls that I haven't though of yet?</p>



<a name="250422655"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Code%20re-use%20for%20owned%20vs.%20referenced%20data/near/250422655" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Thom Chiovoloni <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Code.20re-use.20for.20owned.20vs.2E.20referenced.20data.html#250422655">(Aug 23 2021 at 22:56)</a>:</h4>
<p>yeah, i did something similar with 2d grids as part of some contract work a while ago (i don't have/can't share the code in question). works relatively well.</p>
<p>in my case iterators ended up being a bit of a problem, but its possible that could have been part of the problem domain (and also it was long enough ago that I don't <em>quite</em> remember what the issue was, unfortunately)</p>



<a name="250424951"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Code%20re-use%20for%20owned%20vs.%20referenced%20data/near/250424951" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Will Crichton <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Code.20re-use.20for.20owned.20vs.2E.20referenced.20data.html#250424951">(Aug 23 2021 at 23:23)</a>:</h4>
<p>I'll report back if I have any trouble with iterators. One issue I've already run in to is implementing external traits that require relations on <code>(Self, Self)</code>. For example, <code>Eq</code> is annoying because you can't do <code>MySet&lt;OwnedSet&gt; == MySet&lt;RefSet&gt;</code>, you have to manually add <code>.as_ref()</code> to the <code>OwnedSet</code>.</p>



<a name="250455000"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Code%20re-use%20for%20owned%20vs.%20referenced%20data/near/250455000" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Giacomo Stevanato <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Code.20re-use.20for.20owned.20vs.2E.20referenced.20data.html#250455000">(Aug 24 2021 at 08:18)</a>:</h4>
<p>How is this actually the same issue as with <code>String</code> vs <code>str</code> and <code>PathBuf</code> vs <code>Path</code>? <code>str</code> and <code>Path</code> are necessary only because of slicing and str literals. You don't seem to have any of those. The only relation with them is how they don't actually wrap references, instead they wrap the referenced value, and just transmute between references when needed. If you wanted to copy this approach you would have something like:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="cp">#[repr(transparent)]</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">MySet</span><span class="p">(</span><span class="n">Set</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">);</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">MySet</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">from_set_ref</span><span class="p">(</span><span class="n">set</span>: <span class="kp">&amp;</span><span class="nc">Set</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">core</span>::<span class="n">mem</span>::<span class="n">transmute</span><span class="p">(</span><span class="n">set</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">from_set_mut</span><span class="p">(</span><span class="n">set</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Set</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">core</span>::<span class="n">mem</span>::<span class="n">transmute</span><span class="p">(</span><span class="n">set</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>



<a name="250480882"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Code%20re-use%20for%20owned%20vs.%20referenced%20data/near/250480882" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Code.20re-use.20for.20owned.20vs.2E.20referenced.20data.html#250480882">(Aug 24 2021 at 13:01)</a>:</h4>
<p>To avoid using <code>unsafe</code> yourself, note that there is the <a href="https://docs.rs/ref-cast"><code>::ref_cast</code> crate</a>.</p>
<p>Otherwise, if you want to keep the distinct types, you could do:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">use</span><span class="w"> </span>::<span class="n">core</span>::<span class="n">borrow</span>::<span class="n">Borrow</span><span class="p">;</span><span class="w"></span>

<span class="k">pub</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">MySet</span><span class="o">&lt;</span><span class="n">S</span><span class="w"> </span>: <span class="nc">Borrow</span><span class="o">&lt;</span><span class="n">Set</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Set</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="cm">/* = */</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">S</span><span class="p">,</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>

<span class="k">pub</span><span class="w"></span>
<span class="k">type</span> <span class="nc">MySetRef</span><span class="o">&lt;'</span><span class="na">lt</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MySet</span><span class="o">&lt;&amp;'</span><span class="na">lt</span><span class="w"> </span><span class="n">Set</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;&gt;</span><span class="p">;</span><span class="w"></span>

<span class="k">pub</span><span class="w"></span>
<span class="k">type</span> <span class="nc">MySetMut</span><span class="o">&lt;'</span><span class="na">lt</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MySet</span><span class="o">&lt;&amp;'</span><span class="na">lt</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">Set</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;&gt;</span><span class="p">;</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">S</span><span class="w"> </span>: <span class="nc">Borrow</span><span class="o">&lt;</span><span class="n">Set</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">MySet</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">_example</span><span class="w"> </span><span class="p">(</span><span class="bp">self</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="nb">_</span> <span class="nc">MySet</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">_set</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="mf">0.</span><span class="n">borrow</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">S0</span><span class="p">,</span><span class="w"> </span><span class="n">S1</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">MySet</span><span class="o">&lt;</span><span class="n">S1</span><span class="o">&gt;&gt;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">MySet</span><span class="o">&lt;</span><span class="n">S0</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">where</span><span class="w"></span>
<span class="w">    </span><span class="n">S0</span><span class="w"> </span>: <span class="nc">Borrow</span><span class="o">&lt;</span><span class="n">Set</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">S1</span><span class="w"> </span>: <span class="nc">Borrow</span><span class="o">&lt;</span><span class="n">Set</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">eq</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="bp">self</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="nb">_</span> <span class="nc">MySet</span><span class="o">&lt;</span><span class="n">S0</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="nb">_</span> <span class="nc">MySet</span><span class="o">&lt;</span><span class="n">S1</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span>
    <span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="o">*</span><span class="bp">self</span><span class="p">.</span><span class="mf">0.</span><span class="n">borrow</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">*</span><span class="n">other</span><span class="p">.</span><span class="mf">0.</span><span class="n">borrow</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">pub</span><span class="w"></span>
<span class="k">fn</span> <span class="nf">check</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">s0</span>: <span class="nc">MySet</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">s1</span>: <span class="nc">MySetRef</span><span class="o">&lt;'</span><span class="nb">_</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert!</span><span class="p">(</span><span class="n">s0</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">s1</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<ul>
<li><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=34ceaa435713eae28ea39f4c39a4d9a7">Playground</a></li>
</ul>
<p>but this remains very similar to what you did already (the difference being that it doesn't force you to <code>impl Deref</code> if you didn't want to); if you really want <code>Eq</code> on "by ref" and "owned", then I do recommend you use ref_cast when needed; everything else will then Just Work™</p>



<a name="250543535"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/Code%20re-use%20for%20owned%20vs.%20referenced%20data/near/250543535" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Will Crichton <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/Code.20re-use.20for.20owned.20vs.2E.20referenced.20data.html#250543535">(Aug 24 2021 at 20:26)</a>:</h4>
<p><span class="user-mention" data-user-id="338379">@Giacomo Stevanato</span> I mean generally "two distinct types representing owned and referenced versions of the same underlying datatype." I don't fully understand the design of these types, so you're right in that the analogy doesn't fully extend to my situation.</p>
<p>I hadn't thought of the transmute solution (or known about the ref_cast crate), so thanks I will consider that. <span class="user-mention" data-user-id="232018">@Daniel Henry-Mantilla</span> I would rather just have a single type, so the ref_cast seems like the best solution. Thanks to you both!</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>