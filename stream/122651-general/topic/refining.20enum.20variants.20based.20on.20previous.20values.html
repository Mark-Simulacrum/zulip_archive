<html>
<head><meta charset="utf-8"><title>refining enum variants based on previous values · general · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/122651-general/index.html">general</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values.html">refining enum variants based on previous values</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="272170048"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/refining%20enum%20variants%20based%20on%20previous%20values/near/272170048" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake Goulding <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values.html#272170048">(Feb 16 2022 at 19:57)</a>:</h4>
<p>I have an enum and a sequence of enum values:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">enum</span> <span class="nc">Color</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Red</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">Yellow</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">Green</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">color_stream</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">impl</span><span class="w"> </span><span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Color</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* ... */</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>I'm going to iterate over the sequence and match on the color. However, I know that the same color will never happen twice and I'd like to inform the compiler of this in some fashion.</p>
<p>I'm pretty sure that Rust doesn't have the capabilities to do this now (would love to be proven wrong!). My current designs end up with a large match on a tuple of <code>previous_color</code> and <code>current_color</code> and a bunch of <code>unreachable!()</code>.</p>
<p>I'm mostly curious if there are languages with this capability or something similar for me to read about.</p>



<a name="272188536"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/refining%20enum%20variants%20based%20on%20previous%20values/near/272188536" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nagisa <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values.html#272188536">(Feb 16 2022 at 22:30)</a>:</h4>
<p>if the enum is as is (i.e. small enough), you could write out all possible combinations in a single match statement</p>
<div class="codehilite"><pre><span></span><code>match (i.next(), i.next(), i.next()) {
    (Some(Red), Some(Yellow), Some(Green))  =&gt; ...,
    (Some(Yellow), Some(Green), None)) =&gt; ...,
    ...
    _ =&gt; std::hint::unreachable_unchecked()
}
</code></pre></div>



<a name="272188694"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/refining%20enum%20variants%20based%20on%20previous%20values/near/272188694" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nagisa <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values.html#272188694">(Feb 16 2022 at 22:31)</a>:</h4>
<p>that way the compiler will have a pretty easy time telling that e.g. green yellow green is not a possible combination. Whether there's any value in it being able to determine that is debatable though.</p>



<a name="272195608"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/refining%20enum%20variants%20based%20on%20previous%20values/near/272195608" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values.html#272195608">(Feb 16 2022 at 23:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="116155">Jake Goulding</span> <a href="#narrow/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values/near/272170048">said</a>:</p>
<blockquote>
<p>I'm pretty sure that Rust doesn't have the capabilities to do this now (would love to be proven wrong!).</p>
</blockquote>
<p>I think <code>Iterator</code> fundamentally can't, because there's nowhere for the type system to accumulate the necessary information when the iterator and its items are not allowed to change their static types.</p>
<p>But there's probably some dependent types language that can do it.</p>



<a name="272202488"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/refining%20enum%20variants%20based%20on%20previous%20values/near/272202488" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake Goulding <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values.html#272202488">(Feb 17 2022 at 01:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="123586">nagisa</span> <a href="#narrow/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values/near/272188536">said</a>:</p>
<blockquote>
<p>if the enum is as is (i.e. small enough), you could write out all possible combinations in a single match statement</p>
</blockquote>
<p>Are you saying that I'd put that... somewhere... nearby, but not actually as part of my "iterate over the sequence" business logic? If not, I'm unclear on how that differs from my "My current designs end up with [...]  a bunch of <code>unreachable!()</code>." (Other than the <code>unsafe</code> hint function)</p>



<a name="272202602"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/refining%20enum%20variants%20based%20on%20previous%20values/near/272202602" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake Goulding <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values.html#272202602">(Feb 17 2022 at 01:17)</a>:</h4>
<p>It does lead my brain to some sort of "inform the compiler by example" possibility, where the programmer could say that a function body is additional information about the type, which is in the same vein as a dependently typed language.</p>



<a name="272202780"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/refining%20enum%20variants%20based%20on%20previous%20values/near/272202780" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake Goulding <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values.html#272202780">(Feb 17 2022 at 01:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="125270">scottmcm</span> <a href="#narrow/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values/near/272195608">said</a>:</p>
<blockquote>
<p>I think <code>Iterator</code> fundamentally can't, because there's nowhere for the type system to accumulate the necessary information when the iterator and its items are not allowed to change their static types.</p>
</blockquote>
<p>Hmm, that makes me think of typestate (and the various issues therein). If the signature was some made-up syntax</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">impl</span><span class="w"> </span><span class="nb">Iterator</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Thing</span><span class="o">&lt;</span><span class="n">Red</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Yellow</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Green</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">    </span><span class="k">where</span><span class="w"></span>
<span class="w">        </span><span class="bp">Self</span><span class="w"> </span>-&gt; <span class="nc">Thing</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">Output</span>::<span class="n">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>



<a name="272205408"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/refining%20enum%20variants%20based%20on%20previous%20values/near/272205408" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values.html#272205408">(Feb 17 2022 at 02:02)</a>:</h4>
<p>Yeah, the simpler version of your problem is that there's no "fixed-length iterator" marker trait, because you can't do that -- the iterator shrinks without changing type.  A hypothetical solution could also solve the need for fuse, since the type would just change to make <code>next</code> impossible to call after you find out it's empty.</p>



<a name="272231580"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/refining%20enum%20variants%20based%20on%20previous%20values/near/272231580" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values.html#272231580">(Feb 17 2022 at 09:09)</a>:</h4>
<p>The general idea is called refinement types, I think liquid Haskell has them, though not for enum variants. They have been discussed for Rust (though there hasn't been an RFC or other serious proposal) as a generalisation of the idea of enum variant types</p>



<a name="272251822"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/refining%20enum%20variants%20based%20on%20previous%20values/near/272251822" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake Goulding <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values.html#272251822">(Feb 17 2022 at 12:29)</a>:</h4>
<p>Nice to see that the “refinement” in this thread title wasn’t completely made up.</p>



<a name="272252175"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/refining%20enum%20variants%20based%20on%20previous%20values/near/272252175" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> rylev <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values.html#272252175">(Feb 17 2022 at 12:33)</a>:</h4>
<p>TypeScript has this which I believe is likely the most "popular" example of this feature in the wild.</p>



<a name="272252250"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/refining%20enum%20variants%20based%20on%20previous%20values/near/272252250" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> rylev <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values.html#272252250">(Feb 17 2022 at 12:34)</a>:</h4>
<p>(FYI: <span class="user-mention" data-user-id="211722">@Yoshua Wuyts [he/they]</span> recently wrote about "anonymous enums" - among other things - which are a related concept in this post: <a href="https://blog.yoshuawuyts.com/more-enum-types/">https://blog.yoshuawuyts.com/more-enum-types/</a>)</p>



<a name="272258825"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/refining%20enum%20variants%20based%20on%20previous%20values/near/272258825" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values.html#272258825">(Feb 17 2022 at 13:32)</a>:</h4>
<p><span class="user-mention" data-user-id="116155">@Jake Goulding</span> , not <em>exactly</em> what you’re asking for since you want it in the type system, but this is also what formal verification is for</p>



<a name="272258897"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/refining%20enum%20variants%20based%20on%20previous%20values/near/272258897" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values.html#272258897">(Feb 17 2022 at 13:33)</a>:</h4>
<p>A verification tool could verify that your iterator returns a unique result each time</p>



<a name="272264492"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/refining%20enum%20variants%20based%20on%20previous%20values/near/272264492" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake Goulding <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values.html#272264492">(Feb 17 2022 at 14:13)</a>:</h4>
<p><span class="user-mention" data-user-id="224872">@rylev</span> does TypeScript call it refinement types as well? I didn’t see anything beyond proposals to add them.</p>



<a name="272265064"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/refining%20enum%20variants%20based%20on%20previous%20values/near/272265064" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> rylev <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values.html#272265064">(Feb 17 2022 at 14:17)</a>:</h4>
<p>I don't believe they advertise it as such. It's just the way that TypeScript works</p>



<a name="272265260"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/refining%20enum%20variants%20based%20on%20previous%20values/near/272265260" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> rylev <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values.html#272265260">(Feb 17 2022 at 14:18)</a>:</h4>
<p>Looks like they call it "narrowing": <a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html">https://www.typescriptlang.org/docs/handbook/2/narrowing.html</a></p>



<a name="272265379"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/refining%20enum%20variants%20based%20on%20previous%20values/near/272265379" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake Goulding <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values.html#272265379">(Feb 17 2022 at 14:19)</a>:</h4>
<p><span class="user-mention" data-user-id="312719">@Xavier Denis</span> this makes me think I almost want <code>unsafe</code> at the type level. Then I’d use the verification tool like I use valgrind or Miri.</p>



<a name="272267755"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/refining%20enum%20variants%20based%20on%20previous%20values/near/272267755" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values.html#272267755">(Feb 17 2022 at 14:36)</a>:</h4>
<p>Refinement types are a slightly different concept, another way of phrasing them is 'subset types' where you have a type <code>{ x : T | P x }</code> aka: values <code>x</code> of type <code>T</code> which satisfy <code>P</code></p>



<a name="272267909"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/refining%20enum%20variants%20based%20on%20previous%20values/near/272267909" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values.html#272267909">(Feb 17 2022 at 14:37)</a>:</h4>
<p>using this you can encode the condition you wanted, but the TypeScript case is different and emerges from its support for open union types (aka the type <code>A + B</code> or <code>{A | B}</code>)</p>



<a name="272268027"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/refining%20enum%20variants%20based%20on%20previous%20values/near/272268027" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values.html#272268027">(Feb 17 2022 at 14:38)</a>:</h4>
<p><span class="user-mention silent" data-user-id="116155">Jake Goulding</span> <a href="#narrow/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values/near/272265379">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="312719">Xavier Denis</span> this makes me think I almost want <code>unsafe</code> at the type level. Then I’d use the verification tool like I use valgrind or Miri.</p>
</blockquote>
<p>that would be one option but my personal opinion has been evolving to saying that trying to fit everything into the type system can be counterproductive in practice</p>



<a name="272268076"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/refining%20enum%20variants%20based%20on%20previous%20values/near/272268076" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values.html#272268076">(Feb 17 2022 at 14:38)</a>:</h4>
<p>it can be simpler to have certain obligations which are not in types and just have a seperate aspect to verificaiton</p>



<a name="272268135"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/refining%20enum%20variants%20based%20on%20previous%20values/near/272268135" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values.html#272268135">(Feb 17 2022 at 14:39)</a>:</h4>
<p>this is similar to the Coq advice to not use dependent types in your functions, but instead use simple types and <em>seperately</em> prove it to be correct</p>



<a name="272276294"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/refining%20enum%20variants%20based%20on%20previous%20values/near/272276294" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake Goulding <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values.html#272276294">(Feb 17 2022 at 15:32)</a>:</h4>
<p><span class="user-mention" data-user-id="312719">@Xavier Denis</span> from a current/practical perspective absolutely, but that does lead to a lot of cases where <code>unimplemented!</code> needs to be used. Without using the unsafe version, that also means that there’s junk code in the compiled binary.</p>



<a name="272276632"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/refining%20enum%20variants%20based%20on%20previous%20values/near/272276632" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake Goulding <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values.html#272276632">(Feb 17 2022 at 15:35)</a>:</h4>
<p>I’ve written some TypeScript before, but I don’t immediately see how to model this example in its type system</p>



<a name="272277102"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/refining%20enum%20variants%20based%20on%20previous%20values/near/272277102" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values.html#272277102">(Feb 17 2022 at 15:37)</a>:</h4>
<p>Not <code>unimplemented!</code> but <code>unreachable</code> which can be optimized out afaik</p>



<a name="272277334"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/refining%20enum%20variants%20based%20on%20previous%20values/near/272277334" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values.html#272277334">(Feb 17 2022 at 15:39)</a>:</h4>
<p>(deleted)</p>



<a name="272277591"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/refining%20enum%20variants%20based%20on%20previous%20values/near/272277591" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values.html#272277591">(Feb 17 2022 at 15:40)</a>:</h4>
<p>You could do it by implementing 3 functions with progressively narrower types</p>



<a name="272277766"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/refining%20enum%20variants%20based%20on%20previous%20values/near/272277766" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values.html#272277766">(Feb 17 2022 at 15:41)</a>:</h4>
<p>But since afaik typescript must be erasable you can’t do any sort of “type based dispatch/overloading”</p>



<a name="272277836"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/refining%20enum%20variants%20based%20on%20previous%20values/near/272277836" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values.html#272277836">(Feb 17 2022 at 15:42)</a>:</h4>
<p>I don’t know typescript well… merely enough to dable</p>



<a name="272278077"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/refining%20enum%20variants%20based%20on%20previous%20values/near/272278077" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake Goulding <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values.html#272278077">(Feb 17 2022 at 15:43)</a>:</h4>
<p><code>unimplemented!</code> and <code>unreachable!</code> are both runtime panics. The unsafe version in <code>hint</code> is different.</p>



<a name="272284519"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/refining%20enum%20variants%20based%20on%20previous%20values/near/272284519" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values.html#272284519">(Feb 17 2022 at 16:27)</a>:</h4>
<p>Ah yea ok</p>



<a name="272284567"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/refining%20enum%20variants%20based%20on%20previous%20values/near/272284567" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values.html#272284567">(Feb 17 2022 at 16:27)</a>:</h4>
<p>Then I guess the “solution” would be the unsafe + external Verif</p>



<a name="272321517"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/refining%20enum%20variants%20based%20on%20previous%20values/near/272321517" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nagisa <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values.html#272321517">(Feb 17 2022 at 20:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="116155">Jake Goulding</span> <a href="#narrow/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values/near/272202488">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="123586">nagisa</span> <a href="#narrow/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values/near/272188536">said</a>:</p>
<blockquote>
<p>if the enum is as is (i.e. small enough), you could write out all possible combinations in a single match statement</p>
</blockquote>
<p>Are you saying that I'd put that... somewhere... nearby, but not actually as part of my "iterate over the sequence" business logic? If not, I'm unclear on how that differs from my "My current designs end up with [...]  a bunch of <code>unreachable!()</code>." (Other than the <code>unsafe</code> hint function)</p>
</blockquote>
<p>I think making this match a part of iterate over sequence business logic is not that inconceivable if its wrapped into a macro or something. But yeah. And one big match statement is there to basically demonstrate to LLVM that it only needs to consider 3 iterations ever, and not an unknown number of them that a <code>for</code> loop and similar signals.</p>



<a name="272321639"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/refining%20enum%20variants%20based%20on%20previous%20values/near/272321639" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nagisa <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values.html#272321639">(Feb 17 2022 at 20:59)</a>:</h4>
<p>I was pretty much reacting to “inform compiler of this” portion of your question which to me kind of became “inform optimizer of this…” ^^</p>



<a name="272452134"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/refining%20enum%20variants%20based%20on%20previous%20values/near/272452134" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake Goulding <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values.html#272452134">(Feb 18 2022 at 20:18)</a>:</h4>
<p><span class="user-mention" data-user-id="312719">@Xavier Denis</span> do you have any resources that are useful for a Rust expert (with a large ego) but a formal verification newbie? Something specifically addressing a concern of mine of "I proved system A to be correct, too bad my code implements system B"?</p>



<a name="272458871"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/refining%20enum%20variants%20based%20on%20previous%20values/near/272458871" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values.html#272458871">(Feb 18 2022 at 21:19)</a>:</h4>
<p>Ha going straight for the hard problems</p>



<a name="272458994"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/refining%20enum%20variants%20based%20on%20previous%20values/near/272458994" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values.html#272458994">(Feb 18 2022 at 21:20)</a>:</h4>
<p>There’s few ways to interpret and answer that question let me see if I have some good papers</p>



<a name="272459276"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/refining%20enum%20variants%20based%20on%20previous%20values/near/272459276" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake Goulding <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values.html#272459276">(Feb 18 2022 at 21:23)</a>:</h4>
<p>That's how I know I'm in for a bad time: when papers are the solution. Usually ends up with me having to learn at least one whole new domain of math / computer science.</p>



<a name="272461606"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/refining%20enum%20variants%20based%20on%20previous%20values/near/272461606" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values.html#272461606">(Feb 18 2022 at 21:45)</a>:</h4>
<p>heh it won't be just papers (unless that's what you want)</p>



<a name="272462200"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/refining%20enum%20variants%20based%20on%20previous%20values/near/272462200" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake Goulding <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values.html#272462200">(Feb 18 2022 at 21:50)</a>:</h4>
<p>nah, a mix of sources is fine. And please don't rush to gather things up for me; this is mostly a background thing for me to learn more about (but I might as well ask someone who knows while they are around!)</p>



<a name="272468998"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/refining%20enum%20variants%20based%20on%20previous%20values/near/272468998" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values.html#272468998">(Feb 18 2022 at 22:49)</a>:</h4>
<p>So I'm far from an expert, I'm only starting out in my career here but let me share what I've learned.</p>
<p>For the french speakers in the audience: Xavier Leroy's lecture series at the college de france are <em>very</em> good and give a rather complete, and tight overview of verification and formal language design / modeling: <a href="https://www.college-de-france.fr/site/xavier-leroy/course-2021-03-04-09h30.htm">https://www.college-de-france.fr/site/xavier-leroy/course-2021-03-04-09h30.htm</a></p>
<p>A broad overview by Hillel: <a href="https://www.hillelwayne.com/post/why-dont-people-use-formal-methods/">https://www.hillelwayne.com/post/why-dont-people-use-formal-methods/</a> I think this post gives a good amount of context on the challenges in FV/FM. However, obviously his opinions are shaped by his domain of expertise (TLA+) so I don't necessarily agree with all his posts. </p>
<p>"seL4: Formal verification of an OS kernel": I think this work touches <em>exactly</em> on the heart of your question. They proved a high-performance microkernel in a long duration collaboration between fm and os researchers. They also specifically explored the question of proving they proved the right things as well as proving that the final binary actually did what their proofs said. I think all the papers on sel4 are good reads for this topic.</p>
<p>Verification of the Ligne 14 metro in Paris: <a href="https://link.springer.com/content/pdf/10.1007%252F3-540-48119-2_22.pdf">https://link.springer.com/content/pdf/10.1007%252F3-540-48119-2_22.pdf</a></p>
<p>More generally your question is verify similar to the so called 'specification problem': how do we know that the specification we've given is the correct one? Depending on your intellectual/academic heritage you'll typically have a different answer to the question. </p>
<p>On the one hand you will have 'modellers' who argue we should focus on building and reasoning about <em>models</em> of our systems rather than their implementations. This allows us to focus on the specification itself. However, since the models are written by hand, there's always a gap between it and the actual implementation. The typical tool here is TLA+ and related languages. If you're interested in this there's a <em>huge</em> literature on model checking. </p>
<p>In the other camp you have what could be called 'verifiers' who focus on the actual implementation, and specifying its behavior. This tradeoff isn't free, specifications usually have to care about details that wouldn't appear in a TLA model, potentially obscuring comprehension. <br>
People here would argue that its easier to verify by hand a terse and compact specification than a large complex codebase. <br>
I have some thoughts on that...</p>
<p>What follows is mostly context about various verification tools, terminology and approaches.</p>
<p>There's a wide-range of different tools here but many revolve in some way or another around the concept of 'weakest-preconditions' and 'hoare logic'. If you are not familiar with these terms I would highly recommend reading about them, here are some different resources:</p>
<ul>
<li><a href="https://softwarefoundations.cis.upenn.edu/plf-current/Hoare.html">Software Foundations</a> a great series of 'textbooks' on formal verification, written as exercises in Coq. The newest tome even covers 'seperation logic'. </li>
<li><a href="https://www.cl.cam.ac.uk/archive/mjcg/HL/Notes/Notes.pdf">https://www.cl.cam.ac.uk/archive/mjcg/HL/Notes/Notes.pdf</a> lecture notes that seem to form a quite good introduction to the topic of Hoare logic. </li>
</ul>
<p>The notion of 'weakest preconditions' was introduced by Dijkstra to explore the eponymous question: What is the <em>bare minimum</em> required for a program <code>P</code> to satisfy property <code>Q</code>. <br>
It turns out we can give a very efficient algorithmic answer to this.</p>
<ul>
<li>Old lecture notes from my supervisor: <a href="https://www.lri.fr/~marche/MPRI-2-36-1/2013/poly1.pdf">https://www.lri.fr/~marche/MPRI-2-36-1/2013/poly1.pdf</a> . They may be a bit terse, let me know. </li>
<li>A paper on the foundations of 'Why3' my lab's tool which is based on Hoare logic and weakest preconditions: <a href="https://hal.inria.fr/hal-01256434v3/document">https://hal.inria.fr/hal-01256434v3/document</a></li>
</ul>
<p>It turns out though that pointers throw a wrench in this whole weakest precondition and hoare logic business. All of a sudden we can effect changes 'at a distance'. This challenge stumped researchers for a very long time until in the early 2000s "seperation logic" was invented (an intellectual ancestor of Rust). It bore <a href="https://ilyasergey.net/assets/other/CSL-Family-Tree.pdf">many fruit</a> and has come to be accepted as the 'correct' answer to imperative program verification. Today, many seperation logics exist, like the one in <a href="https://www.pm.inf.ethz.ch/research/viper.html">Viper</a> the tool underlying Prusti, or Iris, the logic developed in part by our very own Ralf.<br>
In way too short, the key idea of seperation logic was to introduce a way to explicitly 'cut up' memory (ie: <em>seperate</em> it). Making memory first-class in our logic gives a lot of power to describe imperative pointer programs, and naturally generalizes to other kinds of 'resources' (see Iris). </p>
<ul>
<li>Software Foundations volume 5: <a href="https://softwarefoundations.cis.upenn.edu/slf-current/index.html">https://softwarefoundations.cis.upenn.edu/slf-current/index.html</a></li>
<li>RustBelt, a proof of Rust type safety using seperation logic: <a href="https://plv.mpi-sws.org/rustbelt/">https://plv.mpi-sws.org/rustbelt/</a></li>
<li><a href="https://www.cambridge.org/core/services/aop-cambridge-core/content/view/26301B518CE2C52796BFA12B8BAB5B5F/S0956796818000151a.pdf/iris_from_the_ground_up_a_modular_foundation_for_higherorder_concurrent_separation_logic.pdf">Iris 3.0</a>. This is a <em>hard</em> paper, I do not expect it to make sense.</li>
</ul>
<p>I hope this is useful for you, if you have any questions don't hesitate, but I should say I'm only a journeyman I have a long way to go still.</p>



<a name="272469039"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/refining%20enum%20variants%20based%20on%20previous%20values/near/272469039" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values.html#272469039">(Feb 18 2022 at 22:49)</a>:</h4>
<p>I hope you find this useful :)</p>



<a name="272485772"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/refining%20enum%20variants%20based%20on%20previous%20values/near/272485772" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake Goulding <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values.html#272485772">(Feb 19 2022 at 02:30)</a>:</h4>
<p>Thank you; there's a lot to chew on there!</p>
<p>Let's pretend that I'm a code monkey interested in making my normal run-of-the-mill Rust software "better" (for a handwavy definition of better) using formal verification. Is there a specific/primary tool that you'd point me towards using?</p>
<p>For example, I've read some papers about the usage of quickcheck in the small (reversing a list) and in the large (verifying C programs via their APIs) and I've since grown to be a fan of property-based testing as well as fuzzing.</p>



<a name="272510811"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/refining%20enum%20variants%20based%20on%20previous%20values/near/272510811" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values.html#272510811">(Feb 19 2022 at 10:56)</a>:</h4>
<p>Thanks Xavier for this comprehensive list of links. One of the transitive links seems like a pretty good fit for <span class="user-mention" data-user-id="116155">@Jake Goulding</span> 's question: the <a href="https://web.archive.org/web/20190228165642/infohost.nmt.edu/~al/cseet-paper.html">Cleanroom</a> method, which I had not heard of before. I would summarize it as: pretend you are using a formal specification language around your code like cruesot, but replace the actual checker by a human code review process. This has the advantage that you don't have to learn a formal language, only formal thinking, and it adapts much better to semi-formal methods that are important to making it useful in the "real world".</p>
<p>In a way, <code>// Safety</code> comments are a basic form of this, but you can extend the method to include all sorts of invariants, pushing beyond mere memory safety and into functional correctness. It's certainly not required to use a tool to do this; mathematicians write proofs without computer assistance so it stands to reason that similar methods can be applied to code as well. The most important part (IMO) is to actually <em>write the invariants down</em> so that people can see what you think should be true. Once you have the invariants at each program point, verification becomes a local problem, and long-distance bugs suddenly become obvious. Using a tool to derive that each line correctly preserves the invariants is just icing on the cake.</p>



<a name="272511173"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/refining%20enum%20variants%20based%20on%20previous%20values/near/272511173" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values.html#272511173">(Feb 19 2022 at 11:02)</a>:</h4>
<p>You can push this further, into an actual formal language that can be checked by tools, but if your goal is just to eliminate bugs then I would guess that the majority of bugs are squeezed out by the time you get to this semi-formal stage. The main thing that continuing to a formal language will help with is errors in reasoning or flaws in the proof, which in my experience is relatively rare compared to miscommunicated preconditions in real code.</p>



<a name="272513173"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/refining%20enum%20variants%20based%20on%20previous%20values/near/272513173" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values.html#272513173">(Feb 19 2022 at 11:43)</a>:</h4>
<p>^^^^^^^</p>



<a name="272513259"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/refining%20enum%20variants%20based%20on%20previous%20values/near/272513259" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values.html#272513259">(Feb 19 2022 at 11:45)</a>:</h4>
<p>1000% what mario said. A <em>lot</em> of the benefit in FV is being forced to <em>actually</em> write your invariants and specifications and not 'handwave' them. Then behind that you often have hours that are 'wasted' to convince the formal tools of those invariants.</p>
<p>Beyond writing invariants or contracts, if you're looking for an actual tool to help you, <code>quickcheck</code> is a <em>very</em> good cost benefit ratio tool</p>



<a name="272513271"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/refining%20enum%20variants%20based%20on%20previous%20values/near/272513271" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values.html#272513271">(Feb 19 2022 at 11:46)</a>:</h4>
<p>it plays into this 'writing your specification down' as you can only quickcheck things that have <em>properties</em> to check.</p>



<a name="272513635"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122651-general/topic/refining%20enum%20variants%20based%20on%20previous%20values/near/272513635" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values.html#272513635">(Feb 19 2022 at 11:53)</a>:</h4>
<p>If you want to move beyond fuzzing/checking properties, things quickly get more difficult as you ask to verify more. (My PhD thesis is about how we can bend that curve for rust).</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>