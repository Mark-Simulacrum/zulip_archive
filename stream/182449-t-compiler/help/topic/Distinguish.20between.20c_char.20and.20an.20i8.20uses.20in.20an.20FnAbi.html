<html>
<head><meta charset="utf-8"><title>Distinguish between c_char and an i8 uses in an FnAbi · t-compiler/help · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/182449-t-compiler/help/index.html">t-compiler/help</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/182449-t-compiler/help/topic/Distinguish.20between.20c_char.20and.20an.20i8.20uses.20in.20an.20FnAbi.html">Distinguish between c_char and an i8 uses in an FnAbi</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="276745385"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/182449-t-compiler/help/topic/Distinguish%20between%20c_char%20and%20an%20i8%20uses%20in%20an%20FnAbi/near/276745385" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/182449-t-compiler/help/topic/Distinguish.20between.20c_char.20and.20an.20i8.20uses.20in.20an.20FnAbi.html#276745385">(Mar 26 2022 at 20:57)</a>:</h4>
<p>We could add horrible hacks that allow implicit conversion from and to a special <code>struct c_char(i8);</code> and warn the user whenever they aren't using the newtype.</p>



<a name="276745607"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/182449-t-compiler/help/topic/Distinguish%20between%20c_char%20and%20an%20i8%20uses%20in%20an%20FnAbi/near/276745607" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/182449-t-compiler/help/topic/Distinguish.20between.20c_char.20and.20an.20i8.20uses.20in.20an.20FnAbi.html#276745607">(Mar 26 2022 at 21:01)</a>:</h4>
<p><span class="user-mention silent" data-user-id="295814">Ramon de C Valle</span> <a href="#narrow/stream/182449-t-compiler.2Fhelp/topic/Distinguish.20between.20c_char.20and.20an.20i8.20uses.20in.20an.20FnAbi/near/276743574">said</a>:</p>
<blockquote>
<p>The reason I'm exploring this encoding is because it'll provide a much more comprehensive protection than the alternative encoding.</p>
</blockquote>
<p>Could you elaborate on why CFI cares about the difference?  I skimmed a couple links in that tracking issue, but I didn't see anything that made it obvious.</p>
<p>Similarly, do you need to distinguish between <code>c_long</code> and <code>c_long_long</code> when those both happen to be <code>i64</code>?</p>



<a name="276745963"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/182449-t-compiler/help/topic/Distinguish%20between%20c_char%20and%20an%20i8%20uses%20in%20an%20FnAbi/near/276745963" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ramon de C Valle <a href="https://zulip-archive.rust-lang.org/stream/182449-t-compiler/help/topic/Distinguish.20between.20c_char.20and.20an.20i8.20uses.20in.20an.20FnAbi.html#276745963">(Mar 26 2022 at 21:10)</a>:</h4>
<p>It's related to the unresolved question at <a href="https://github.com/rust-lang/rust/issues/89653">https://github.com/rust-lang/rust/issues/89653</a>. I'll try to summarize it here, but I'll have it described in detail in the design doc:</p>
<p>I'm exploring two options, option (A) and (C). For option (A),  I'm using the Itanium C++ ABI with vendor extended type qualifiers and types for Rust types that are not used at the FFI boundary. For option (B), I'm working with clang/CFI team on a new encoding for cross-language CFI, but because of the requirements of this new encoding (i.e., be language agnostic and ideally compatible with any other language), it provides a less comprehensive protection than option (A) [e.g., neither distinguishes between certain types (e.g., c_char/char, bool, enum, and integers) nor discriminates between pointed element types (the latter mainly because of C’s void * abuse)].</p>
<p>Ideally, I want option (A) to be the main encoding both for Rust-compiled only code and when interoperating with foreign code written in C, and option (C) to be an alternative for interoperating with foreign code written in languages other than C (in the future).</p>



<a name="276747133"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/182449-t-compiler/help/topic/Distinguish%20between%20c_char%20and%20an%20i8%20uses%20in%20an%20FnAbi/near/276747133" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/182449-t-compiler/help/topic/Distinguish.20between.20c_char.20and.20an.20i8.20uses.20in.20an.20FnAbi.html#276747133">(Mar 26 2022 at 21:36)</a>:</h4>
<p>I believe it is not uncommon to use u8/i8 directly on the rust side when the C side uses char. For example when using <code>#[start]</code> to directly define the <code>main</code> function called by libc rustc mandates <code>*const *const i8</code> as argv type and not <code>*const *const c_char</code>.</p>



<a name="276747140"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/182449-t-compiler/help/topic/Distinguish%20between%20c_char%20and%20an%20i8%20uses%20in%20an%20FnAbi/near/276747140" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ramon de C Valle <a href="https://zulip-archive.rust-lang.org/stream/182449-t-compiler/help/topic/Distinguish.20between.20c_char.20and.20an.20i8.20uses.20in.20an.20FnAbi.html#276747140">(Mar 26 2022 at 21:36)</a>:</h4>
<p>For c_long and c_long_long, they’re aliased to their respective ty::Ty and encoded correctly to their respective type encoding in the Itanium C++ ABI. For c_char/char it has its own type encoding in the Itanium C++ ABI other than signed and unsigned char that needs to be discriminated (i.e., ‘c’ vs ‘a’ and ‘h’).</p>



<a name="276747509"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/182449-t-compiler/help/topic/Distinguish%20between%20c_char%20and%20an%20i8%20uses%20in%20an%20FnAbi/near/276747509" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ramon de C Valle <a href="https://zulip-archive.rust-lang.org/stream/182449-t-compiler/help/topic/Distinguish.20between.20c_char.20and.20an.20i8.20uses.20in.20an.20FnAbi.html#276747509">(Mar 26 2022 at 21:46)</a>:</h4>
<p>So for CFI purposes, when using option (A), char, signed char, and unsigned char, discriminates between valid destinations/functions on clang side, and the same would need to be done on Rust side.</p>



<a name="276747803"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/182449-t-compiler/help/topic/Distinguish%20between%20c_char%20and%20an%20i8%20uses%20in%20an%20FnAbi/near/276747803" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/182449-t-compiler/help/topic/Distinguish.20between.20c_char.20and.20an.20i8.20uses.20in.20an.20FnAbi.html#276747803">(Mar 26 2022 at 21:53)</a>:</h4>
<p>Hmm, actually, if all you have is an <code>Abi</code> you might not be able to tell even with a newtype -- I think it'd have to be <code>#[repr(transparent)] struct c_short(i16);</code> to be ABI-compatible in <code>extern "C"</code>, and thus down at the ABI level the difference might also not exist, even though it does in the function's type.</p>



<a name="276747985"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/182449-t-compiler/help/topic/Distinguish%20between%20c_char%20and%20an%20i8%20uses%20in%20an%20FnAbi/near/276747985" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ramon de C Valle <a href="https://zulip-archive.rust-lang.org/stream/182449-t-compiler/help/topic/Distinguish.20between.20c_char.20and.20an.20i8.20uses.20in.20an.20FnAbi.html#276747985">(Mar 26 2022 at 21:56)</a>:</h4>
<p>I was able to identify c_void by its name and crate name. Since struct c_char(i8) would be an ty::Adt, couldn’t I do the same?</p>



<a name="276754075"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/182449-t-compiler/help/topic/Distinguish%20between%20c_char%20and%20an%20i8%20uses%20in%20an%20FnAbi/near/276754075" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ramon de C Valle <a href="https://zulip-archive.rust-lang.org/stream/182449-t-compiler/help/topic/Distinguish.20between.20c_char.20and.20an.20i8.20uses.20in.20an.20FnAbi.html#276754075">(Mar 27 2022 at 00:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="124288">oli</span> <a href="#narrow/stream/182449-t-compiler.2Fhelp/topic/Distinguish.20between.20c_char.20and.20an.20i8.20uses.20in.20an.20FnAbi/near/276745385">said</a>:</p>
<blockquote>
<p>We could add horrible hacks that allow implicit conversion from and to a special <code>struct c_char(i8);</code> and warn the user whenever they aren't using the newtype.</p>
</blockquote>
<p>How would it work? Do you have an example? I'm trying to be as unobtrusive as possible, but if this can be done only for when CFI is enabled, I think it's a good cost vs benefit.</p>



<a name="276778284"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/182449-t-compiler/help/topic/Distinguish%20between%20c_char%20and%20an%20i8%20uses%20in%20an%20FnAbi/near/276778284" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/182449-t-compiler/help/topic/Distinguish.20between.20c_char.20and.20an.20i8.20uses.20in.20an.20FnAbi.html#276778284">(Mar 27 2022 at 09:26)</a>:</h4>
<p>Is CFI just a backend thing or more like a target/platform? If it's a target or platform, in theory we could cfg the type alias into a newtype. Adding the inference infrastructure is a bit of weirdness in the compiler, but with the libs team on board I think it would be a reasonable amount of work and very well contained</p>



<a name="276915113"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/182449-t-compiler/help/topic/Distinguish%20between%20c_char%20and%20an%20i8%20uses%20in%20an%20FnAbi/near/276915113" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ramon de C Valle <a href="https://zulip-archive.rust-lang.org/stream/182449-t-compiler/help/topic/Distinguish.20between.20c_char.20and.20an.20i8.20uses.20in.20an.20FnAbi.html#276915113">(Mar 28 2022 at 18:42)</a>:</h4>
<p>It's a combination of codegen, metadata, and a LLVM pass: <a href="https://github.com/rust-lang/rust/pull/89652">https://github.com/rust-lang/rust/pull/89652</a>. I'll msg you to get more details about it and see if it's something I can do.</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>