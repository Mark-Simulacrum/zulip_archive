<html>
<head><meta charset="utf-8"><title>Adding autodiff support to rustc · t-compiler/help · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/182449-t-compiler/help/index.html">t-compiler/help</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/182449-t-compiler/help/topic/Adding.20autodiff.20support.20to.20rustc.html">Adding autodiff support to rustc</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="278723718"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/182449-t-compiler/help/topic/Adding%20autodiff%20support%20to%20rustc/near/278723718" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Manuel Drehwald <a href="https://zulip-archive.rust-lang.org/stream/182449-t-compiler/help/topic/Adding.20autodiff.20support.20to.20rustc.html#278723718">(Apr 12 2022 at 17:17)</a>:</h4>
<p>Hello everyone. @bytesnake and I are currently working on integrating an llvm incubator project into rustc, which differentiates code in the calculus sense. We have used it successfully as a wrapper around rustc, but that comes with various limitations which we want to solve this way. </p>
<h3>Requirements</h3>
<p>We require the complete LLVM-IR, at least the one being used (possibly indirectly) by a function being differentiated. In general, that means that we have to merge all the compilation units and also rely on <code>build-std</code>, which worked pretty fine for us until now. Currently we also require debug-symbols, although we will change that later to rely on compiler internal layout details. For the best results we also require special / repeated optimizations, although these are optional to get started.</p>
<h3>Implementation</h3>
<p>We would like to make as little modifications as possible. In the rustc backend we therefore intent to:</p>
<p>1) Add enzyme as a submodule to the llvm project. <br>
2) Add enzyme as an llvm subproject to x.py to allow building it, together with rust bindings<br>
3) Add a trait file to <code>rustc_codegen_ssa/src/traits/autodiff.rs</code><br>
4) Update ModuleConfig (and equivalents earlier in the build chain) to include a boolean <code>autodiff</code> flag. If set to true we also check for build-std and embed-bitcode usage and panic if it isn't used.<br>
5) Update <code>rustc_codegen_llvm/src/lib.rs</code> and <code>rustc_codegen_ssa/src/back/write.rs</code> by using <code>cfg!()</code> in order to:</p>
<div class="codehilite"><pre><span></span><code>  - During normal compilation process:
       - concatenate all modules (including std ones) using run-link
       - end with single module, run: optimizations, enzyme, optimizations2. 
       - Continue normal compilation. (Same case as if we compile a trivial crate without dependencies, so the rest of the compilation should work?)
  - During thin-lto:
       - complicated, skip for now (multiple modules)
  - During fat-lto:
       - We have one compilation artifact anyway, so that should be comparably easy?
</code></pre></div>

<p>All of the steps above do not affect users, so would probably only require a MCP. However, we do intend to expose this behaviour similar to the inline-asm group, by having a special macro adding a magic node. This way we can assure that autodiff will only be invoked using the specific macro, allowing us to catch invalid input as early as possible. This macro will also generate an <code>unimplemented!()</code> function which will later be filled when running Enzyme. You can see an example of such a macro here: <a href="https://github.com/ZuseZ4/autodiff/blob/main/tests/rosenbrock.rs">https://github.com/ZuseZ4/autodiff/blob/main/tests/rosenbrock.rs</a>. It demonstrates Reverse, Forward, and Forward-Vectorized (8-width) autodiff. We don't see the specific macro design as too relevant for now but would rather ask for some general feedback on our Implementation thoughts. Is there any fundamental flaw or can we just go ahead and come back for an RFC once we have finished moving our logic into rustc?</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>