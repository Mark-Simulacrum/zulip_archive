<html>
<head><meta charset="utf-8"><title>perf of matching on `&amp;str` vs matching on `&amp;[u8]` · t-compiler/help · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/182449-t-compiler/help/index.html">t-compiler/help</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/182449-t-compiler/help/topic/perf.20of.20matching.20on.20.60.26str.60.20vs.20matching.20on.20.60.26.5Bu8.5D.60.html">perf of matching on `&amp;str` vs matching on `&amp;[u8]`</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="269088854"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/182449-t-compiler/help/topic/perf%20of%20matching%20on%20%60%26str%60%20vs%20matching%20on%20%60%26%5Bu8%5D%60/near/269088854" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Karl Meakin <a href="https://zulip-archive.rust-lang.org/stream/182449-t-compiler/help/topic/perf.20of.20matching.20on.20.60.26str.60.20vs.20matching.20on.20.60.26.5Bu8.5D.60.html#269088854">(Jan 24 2022 at 11:02)</a>:</h4>
<p>I've noticed that when matching over slices, rustc generates a decision tree. But when matching over <code>&amp;str</code> patterns, rustc generates a call to <code>PartialEq::eq</code> for each string pattern. This means that an expression like:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">match</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="s">"abc"</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">..</span><span class="p">.,</span><span class="w"></span>
<span class="w">    </span><span class="s">"abd"</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">..</span><span class="p">.,</span><span class="w"></span>
<span class="w">    </span><span class="s">"def"</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">..</span><span class="p">.,</span><span class="w"></span>
<span class="w">    </span><span class="s">"deg"</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">..</span><span class="p">.,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>generates LLVM IR equivalent to</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">if</span><span class="w">      </span><span class="n">s</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">"abc"</span><span class="w"> </span><span class="p">{</span><span class="o">..</span><span class="p">.}</span><span class="w"></span>
<span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">"abd"</span><span class="w"> </span><span class="p">{</span><span class="o">..</span><span class="p">.}</span><span class="w"></span>
<span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">"def"</span><span class="w"> </span><span class="p">{</span><span class="o">..</span><span class="p">.}</span><span class="w"></span>
<span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">"deg"</span><span class="w"> </span><span class="p">{</span><span class="o">..</span><span class="p">.}</span><span class="w"></span>
</code></pre></div>
<p>but if you append 'b' to the start of each pattern:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">match</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">as_bytes</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="s">b"abc"</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">..</span><span class="p">.,</span><span class="w"></span>
<span class="w">   </span><span class="s">b"abd"</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">..</span><span class="p">.,</span><span class="w"></span>
<span class="w">   </span><span class="s">b"def"</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">..</span><span class="p">.,</span><span class="w"></span>
<span class="w">   </span><span class="s">b"deg"</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">..</span><span class="p">.,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>rustc generates LLVM IR equivalent to:</p>
<div class="codehilite"><pre><span></span><code>let bytes = s.as_bytes();
match bytes.get(0) {
    Some(b&#39;a&#39;) =&gt; match bytes.get(1) {
        Some(b&#39;b&#39;) =&gt; match bytes.get(2) {
            Some(b&#39;c&#39;) if bytes.get(3) == None =&gt; ...,
            Some(b&#39;d&#39;) if bytes.get(3) == None =&gt; ...,
            _ =&gt; None,
        }
        _ =&gt; None,
    }
    Some(b&#39;d)&#39; =&gt; match bytes.get(1) {
        Some(b&#39;e&#39;) =&gt; match bytes.get(2) {
             Some(b&#39;f&#39;) if bytes.get(3) == None =&gt; ...,
             Some(b&#39;g&#39;) if bytes.get(3) == None =&gt; ...,
             _ =&gt; None,
        }
        _ =&gt; None,
    }
    _ =&gt; None,
}
</code></pre></div>
<p>The second style is much faster, since it is constant in the number of patterns, whilst the first is linear in the number of patterns.</p>
<p>Is there a good reason rustc doesn't compile <code>&amp;str</code> patterns like this, or is it an oversight?</p>



<a name="269091865"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/182449-t-compiler/help/topic/perf%20of%20matching%20on%20%60%26str%60%20vs%20matching%20on%20%60%26%5Bu8%5D%60/near/269091865" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/182449-t-compiler/help/topic/perf.20of.20matching.20on.20.60.26str.60.20vs.20matching.20on.20.60.26.5Bu8.5D.60.html#269091865">(Jan 24 2022 at 11:29)</a>:</h4>
<p>I think the only reason is that the <code>b"foo"</code> is an array, and thus it hits the array pattern code, which works very differently from strings.</p>
<p>I don't know that there's a great reason, though ideally I'd expect that LLVM would just do the tree form for the sequence-of-<code>memcmp</code>s if it's helpful.  (Though I guess it doesn't today?)</p>



<a name="269092521"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/182449-t-compiler/help/topic/perf%20of%20matching%20on%20%60%26str%60%20vs%20matching%20on%20%60%26%5Bu8%5D%60/near/269092521" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Karl Meakin <a href="https://zulip-archive.rust-lang.org/stream/182449-t-compiler/help/topic/perf.20of.20matching.20on.20.60.26str.60.20vs.20matching.20on.20.60.26.5Bu8.5D.60.html#269092521">(Jan 24 2022 at 11:35)</a>:</h4>
<p>nope, llvm doesn't transform chains of <code>memcp</code> into decision-trees. I imagine someone must have investigated that previously to bother generating decision trees from rustc</p>



<a name="269092814"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/182449-t-compiler/help/topic/perf%20of%20matching%20on%20%60%26str%60%20vs%20matching%20on%20%60%26%5Bu8%5D%60/near/269092814" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/182449-t-compiler/help/topic/perf.20of.20matching.20on.20.60.26str.60.20vs.20matching.20on.20.60.26.5Bu8.5D.60.html#269092814">(Jan 24 2022 at 11:38)</a>:</h4>
<p>I think it's less "bother generating" and more "well that was the right way to handle slice patterns".  When you have to support arms like <code>[0, 1, x, y, 10] =&gt; ...</code> you can't do it with just <code>PartialEq::eq</code>.</p>



<a name="269092901"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/182449-t-compiler/help/topic/perf%20of%20matching%20on%20%60%26str%60%20vs%20matching%20on%20%60%26%5Bu8%5D%60/near/269092901" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/182449-t-compiler/help/topic/perf.20of.20matching.20on.20.60.26str.60.20vs.20matching.20on.20.60.26.5Bu8.5D.60.html#269092901">(Jan 24 2022 at 11:39)</a>:</h4>
<p>(And then the constant version just falls out from it)</p>



<a name="269093368"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/182449-t-compiler/help/topic/perf%20of%20matching%20on%20%60%26str%60%20vs%20matching%20on%20%60%26%5Bu8%5D%60/near/269093368" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Karl Meakin <a href="https://zulip-archive.rust-lang.org/stream/182449-t-compiler/help/topic/perf.20of.20matching.20on.20.60.26str.60.20vs.20matching.20on.20.60.26.5Bu8.5D.60.html#269093368">(Jan 24 2022 at 11:44)</a>:</h4>
<p>good point</p>



<a name="269093993"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/182449-t-compiler/help/topic/perf%20of%20matching%20on%20%60%26str%60%20vs%20matching%20on%20%60%26%5Bu8%5D%60/near/269093993" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Karl Meakin <a href="https://zulip-archive.rust-lang.org/stream/182449-t-compiler/help/topic/perf.20of.20matching.20on.20.60.26str.60.20vs.20matching.20on.20.60.26.5Bu8.5D.60.html#269093993">(Jan 24 2022 at 11:50)</a>:</h4>
<p><a href="https://zulip-archive.rust-lang.org/stream/189540-t-compiler/wg-mir-opt/topic/better.20string.20pattern.20matching.html">https://zulip-archive.rust-lang.org/stream/189540-t-compiler/wg-mir-opt/topic/better.20string.20pattern.20matching.html</a></p>
<p>Someone posted about exactly the same thing last year, but it doesn't seem to have gone anywhere</p>



<a name="269096567"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/182449-t-compiler/help/topic/perf%20of%20matching%20on%20%60%26str%60%20vs%20matching%20on%20%60%26%5Bu8%5D%60/near/269096567" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Gary Guo <a href="https://zulip-archive.rust-lang.org/stream/182449-t-compiler/help/topic/perf.20of.20matching.20on.20.60.26str.60.20vs.20matching.20on.20.60.26.5Bu8.5D.60.html#269096567">(Jan 24 2022 at 12:15)</a>:</h4>
<p>It shouldn't be difficult to switch string to use  slice logic IMO</p>



<a name="269096664"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/182449-t-compiler/help/topic/perf%20of%20matching%20on%20%60%26str%60%20vs%20matching%20on%20%60%26%5Bu8%5D%60/near/269096664" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Gary Guo <a href="https://zulip-archive.rust-lang.org/stream/182449-t-compiler/help/topic/perf.20of.20matching.20on.20.60.26str.60.20vs.20matching.20on.20.60.26.5Bu8.5D.60.html#269096664">(Jan 24 2022 at 12:16)</a>:</h4>
<p>But I wonder if the performance will be worse for small number of match arms.</p>



<a name="269096935"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/182449-t-compiler/help/topic/perf%20of%20matching%20on%20%60%26str%60%20vs%20matching%20on%20%60%26%5Bu8%5D%60/near/269096935" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Karl Meakin <a href="https://zulip-archive.rust-lang.org/stream/182449-t-compiler/help/topic/perf.20of.20matching.20on.20.60.26str.60.20vs.20matching.20on.20.60.26.5Bu8.5D.60.html#269096935">(Jan 24 2022 at 12:19)</a>:</h4>
<p>i'll try to make rustc use slice matching logic first. if benchmarks show the perf is worse for small number of patterns, then we can have a heuristic to use <code>memcp</code> instead</p>



<a name="269098963"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/182449-t-compiler/help/topic/perf%20of%20matching%20on%20%60%26str%60%20vs%20matching%20on%20%60%26%5Bu8%5D%60/near/269098963" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/182449-t-compiler/help/topic/perf.20of.20matching.20on.20.60.26str.60.20vs.20matching.20on.20.60.26.5Bu8.5D.60.html#269098963">(Jan 24 2022 at 12:40)</a>:</h4>
<p>The thing that would scare me is really long literals, actually.  Because the tree is a good way to do distinct prefixes, but the <code>memcmp</code> is probably better for the "and does the rest match" part, so <em>just</em> going to the array logic might not be optimal.</p>
<p>IIRC the <code>==</code> is also pretty good for strings of different lengths, because it ends up matching on the lengths first, then just doing the <code>memcmp</code> for the one possibility of that length.</p>
<p>I do wonder if it might be better to make this an LLVM optimization -- it could easily notice a chain of <code>memcmp</code>s against constants -- rather than trying to pick the best approach in <code>match</code> desugaring.</p>



<a name="269100735"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/182449-t-compiler/help/topic/perf%20of%20matching%20on%20%60%26str%60%20vs%20matching%20on%20%60%26%5Bu8%5D%60/near/269100735" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Karl Meakin <a href="https://zulip-archive.rust-lang.org/stream/182449-t-compiler/help/topic/perf.20of.20matching.20on.20.60.26str.60.20vs.20matching.20on.20.60.26.5Bu8.5D.60.html#269100735">(Jan 24 2022 at 12:56)</a>:</h4>
<p>ok, so i can convert the <code>&amp;str</code> patterns to <code>&amp;[u8]</code> patterns, but the MIR optimiser/verifier complains that the scrutinee cannot be indexed into because it is still a <code>&amp;str</code>. Can I replace the scrutinee with <code>s.as_bytes()</code> ?</p>



<a name="269102566"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/182449-t-compiler/help/topic/perf%20of%20matching%20on%20%60%26str%60%20vs%20matching%20on%20%60%26%5Bu8%5D%60/near/269102566" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Karl Meakin <a href="https://zulip-archive.rust-lang.org/stream/182449-t-compiler/help/topic/perf.20of.20matching.20on.20.60.26str.60.20vs.20matching.20on.20.60.26.5Bu8.5D.60.html#269102566">(Jan 24 2022 at 13:10)</a>:</h4>
<p><span class="user-mention silent" data-user-id="125270">scottmcm</span> <a href="#narrow/stream/182449-t-compiler.2Fhelp/topic/perf.20of.20matching.20on.20.60.26str.60.20vs.20matching.20on.20.60.26.5Bu8.5D.60/near/269098963">said</a>:</p>
<blockquote>
<p>The thing that would scare me is really long literals, actually.  Because the tree is a good way to do distinct prefixes, but the <code>memcmp</code> is probably better for the "and does the rest match" part, so <em>just</em> going to the array logic might not be optimal.</p>
<p>IIRC the <code>==</code> is also pretty good for strings of different lengths, because it ends up matching on the lengths first, then just doing the <code>memcmp</code> for the one possibility of that length.</p>
<p>I do wonder if it might be better to make this an LLVM optimization -- it could easily notice a chain of <code>memcmp</code>s against constants -- rather than trying to pick the best approach in <code>match</code> desugaring.</p>
</blockquote>
<p>I'm not sure how easy it would be to detect this kind of thing from LLVM. My instinct is that it would be easier to implement this in rustc, since rustc has access to the structure of the match block, while all LLVM sees is an unstructured sea of <code>memcmp</code>s and <code>phi</code>s.</p>
<p>Matching prefixes/suffixes with <code>memcmp</code> is an orthogonal issue, because it would benefit matching over any slice that can be compared with <code>memcmp</code>, not just <code>&amp;str</code>. At the moment, decision trees are always generated for slice patterns, even if only one pattern is being matched against</p>



<a name="269103150"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/182449-t-compiler/help/topic/perf%20of%20matching%20on%20%60%26str%60%20vs%20matching%20on%20%60%26%5Bu8%5D%60/near/269103150" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Karl Meakin <a href="https://zulip-archive.rust-lang.org/stream/182449-t-compiler/help/topic/perf.20of.20matching.20on.20.60.26str.60.20vs.20matching.20on.20.60.26.5Bu8.5D.60.html#269103150">(Jan 24 2022 at 13:15)</a>:</h4>
<p>another discussion of the same subject: <a href="https://github.com/rust-lang/rust/issues/39525">https://github.com/rust-lang/rust/issues/39525</a></p>



<a name="269256856"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/182449-t-compiler/help/topic/perf%20of%20matching%20on%20%60%26str%60%20vs%20matching%20on%20%60%26%5Bu8%5D%60/near/269256856" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Giacomo Stevanato <a href="https://zulip-archive.rust-lang.org/stream/182449-t-compiler/help/topic/perf.20of.20matching.20on.20.60.26str.60.20vs.20matching.20on.20.60.26.5Bu8.5D.60.html#269256856">(Jan 25 2022 at 13:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="125270">scottmcm</span> <a href="#narrow/stream/182449-t-compiler.2Fhelp/topic/perf.20of.20matching.20on.20.60.26str.60.20vs.20matching.20on.20.60.26.5Bu8.5D.60/near/269098963">said</a>:</p>
<blockquote>
<p>IIRC the <code>==</code> is also pretty good for strings of different lengths, because it ends up matching on the lengths first, then just doing the <code>memcmp</code> for the one possibility of that length.</p>
</blockquote>
<p>Can't this also be applied to slice matching?</p>



<a name="269308150"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/182449-t-compiler/help/topic/perf%20of%20matching%20on%20%60%26str%60%20vs%20matching%20on%20%60%26%5Bu8%5D%60/near/269308150" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Noah Lev <a href="https://zulip-archive.rust-lang.org/stream/182449-t-compiler/help/topic/perf.20of.20matching.20on.20.60.26str.60.20vs.20matching.20on.20.60.26.5Bu8.5D.60.html#269308150">(Jan 25 2022 at 19:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="454562">Karl Meakin</span> <a href="#narrow/stream/182449-t-compiler.2Fhelp/topic/perf.20of.20matching.20on.20.60.26str.60.20vs.20matching.20on.20.60.26.5Bu8.5D.60/near/269093993">said</a>:</p>
<blockquote>
<p><a href="https://zulip-archive.rust-lang.org/stream/189540-t-compiler/wg-mir-opt/topic/better.20string.20pattern.20matching.html">https://zulip-archive.rust-lang.org/stream/189540-t-compiler/wg-mir-opt/topic/better.20string.20pattern.20matching.html</a></p>
<p>Someone posted about exactly the same thing last year, but it doesn't seem to have gone anywhere</p>
</blockquote>
<p>FWIW, I tried switching string matching to use slice lowering, but it ended up being difficult just because of the way the code was written</p>



<a name="269403559"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/182449-t-compiler/help/topic/perf%20of%20matching%20on%20%60%26str%60%20vs%20matching%20on%20%60%26%5Bu8%5D%60/near/269403559" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Karl Meakin <a href="https://zulip-archive.rust-lang.org/stream/182449-t-compiler/help/topic/perf.20of.20matching.20on.20.60.26str.60.20vs.20matching.20on.20.60.26.5Bu8.5D.60.html#269403559">(Jan 26 2022 at 12:38)</a>:</h4>
<blockquote>
<p>but it ended up being difficult just because of the way the code was written</p>
</blockquote>
<p>yep, im discovering that myself :/</p>



<a name="269403672"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/182449-t-compiler/help/topic/perf%20of%20matching%20on%20%60%26str%60%20vs%20matching%20on%20%60%26%5Bu8%5D%60/near/269403672" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Karl Meakin <a href="https://zulip-archive.rust-lang.org/stream/182449-t-compiler/help/topic/perf.20of.20matching.20on.20.60.26str.60.20vs.20matching.20on.20.60.26.5Bu8.5D.60.html#269403672">(Jan 26 2022 at 12:39)</a>:</h4>
<p>are there any experts on the rustc pattern matching logic i could ping for some help?</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>