<html>
<head><meta charset="utf-8"><title>`Muckable` semver hazard · project-safe-transmute · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/216762-project-safe-transmute/index.html">project-safe-transmute</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard.html">`Muckable` semver hazard</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="216002318"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/216762-project-safe-transmute/topic/%60Muckable%60%20semver%20hazard/near/216002318" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard.html#216002318">(Nov 08 2020 at 11:18)</a>:</h4>
<p>Another aspect maybe worth bikeshedding is if it should be <code>Muckable</code> or <code>MuckableFrom&lt;T&gt;</code>... the former opts-in to all transmutes with compatible layout going forward into the future, i.e., when new layout guarantees are established, suddenly more transmutes are possible. That seems like a potential semver hazard. We'll want to design things in a way that declaring more things <code>TransmuteFrom</code> (i.e., layouts are compatible, whatever that trait ends up being called) will not break anything.</p>



<a name="216112104"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/216762-project-safe-transmute/topic/%60Muckable%60%20semver%20hazard/near/216112104" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Wrenn <a href="https://zulip-archive.rust-lang.org/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard.html#216112104">(Nov 09 2020 at 16:54)</a>:</h4>
<p>I can think of an example of this, but it's rather contrived: If someone defined a trait with a <code>transmute_from</code> method that was implemented for two types that core's <code>TransmuteFrom</code> <em>wasn't</em> implemented for, and <em>then</em> core's <code>TransmuteFrom</code> became implemented for those types, a compile error (ambiguous method) would result.</p>
<p>Is that what you have in mind? If not, could you give an example?</p>



<a name="216371571"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/216762-project-safe-transmute/topic/%60Muckable%60%20semver%20hazard/near/216371571" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard.html#216371571">(Nov 11 2020 at 17:00)</a>:</h4>
<p>This might be more about the problems we regularly have with <code>.as_ref()</code> -- if there's only one of them, then that works unannotated, but when the second impl is added than it's suddenly ambiguous causing inference breakage in existing code.</p>



<a name="216373291"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/216762-project-safe-transmute/topic/%60Muckable%60%20semver%20hazard/near/216373291" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard.html#216373291">(Nov 11 2020 at 17:14)</a>:</h4>
<p>Can't that be solved with one or two hidden impls? That way the types <em>have</em> to be annotated</p>



<a name="216374221"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/216762-project-safe-transmute/topic/%60Muckable%60%20semver%20hazard/near/216374221" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Wrenn <a href="https://zulip-archive.rust-lang.org/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard.html#216374221">(Nov 11 2020 at 17:22)</a>:</h4>
<p><span class="user-mention" data-user-id="125270">@scottmcm</span>, I'm not familiar with the issues with <code>AsRef</code>, but I'm picturing something like:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">TransmuteFrom</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">transmute_from</span><span class="p">(</span><span class="n">src</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">Foo</span><span class="p">;</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">Bar</span><span class="p">;</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">TransmuteFrom</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Bar</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">transmute_from</span><span class="p">(</span><span class="n">_</span>: <span class="nc">Foo</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">Bar</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// error[E0282]: type annotations needed</span>
<span class="w">    </span><span class="c1">// Even though there is only one impl of `From`,</span>
<span class="w">    </span><span class="c1">// the destination type is not inferred.</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">dst</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TransmuteFrom</span>::<span class="n">transmute_from</span><span class="p">(</span><span class="n">Foo</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>...but that <em>does</em> result in a compile error.</p>



<a name="216374285"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/216762-project-safe-transmute/topic/%60Muckable%60%20semver%20hazard/near/216374285" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Wrenn <a href="https://zulip-archive.rust-lang.org/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard.html#216374285">(Nov 11 2020 at 17:23)</a>:</h4>
<p>Oh, I see. Does this issue only occur when it's a method call? This does <em>not</em> produce a compile error:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">TransmuteInto</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">transmute_into</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">T</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">Foo</span><span class="p">;</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">Bar</span><span class="p">;</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">TransmuteInto</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Bar</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">transmute_into</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">Foo</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">dst</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Bar</span><span class="p">.</span><span class="n">transmute_into</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>...but if I add:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">impl</span><span class="w"> </span><span class="n">TransmuteInto</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Bar</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">transmute_into</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u8</span> <span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="mi">0</span><span class="k">u8</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>...then it does!</p>



<a name="216374544"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/216762-project-safe-transmute/topic/%60Muckable%60%20semver%20hazard/near/216374544" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Wrenn <a href="https://zulip-archive.rust-lang.org/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard.html#216374544">(Nov 11 2020 at 17:25)</a>:</h4>
<p>So, it seems like this stability error might be neatly solved by providing <code>TransmuteFrom</code>, rather than <code>TransmuteInto</code>.</p>



<a name="216389007"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/216762-project-safe-transmute/topic/%60Muckable%60%20semver%20hazard/near/216389007" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard.html#216389007">(Nov 11 2020 at 19:35)</a>:</h4>
<p>(or a free function, or not taking <code>self</code>)</p>



<a name="216389142"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/216762-project-safe-transmute/topic/%60Muckable%60%20semver%20hazard/near/216389142" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard.html#216389142">(Nov 11 2020 at 19:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="219211">Jack Wrenn</span> <a href="#narrow/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard/near/216374285">said</a>:</p>
<blockquote>
<p>Oh, I see. Does this issue only occur when it's a method call?</p>
</blockquote>
<p>I actually have no idea.  I'm not enough of a trait resolution wizard to understand what happens...</p>



<a name="216725762"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/216762-project-safe-transmute/topic/%60Muckable%60%20semver%20hazard/near/216725762" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard.html#216725762">(Nov 14 2020 at 12:13)</a>:</h4>
<p>I was actually not thinking of resolution failures but semantic issues</p>



<a name="216725815"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/216762-project-safe-transmute/topic/%60Muckable%60%20semver%20hazard/near/216725815" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard.html#216725815">(Nov 14 2020 at 12:14)</a>:</h4>
<p>e.g., given a <code>#[repr(Rust)] struct Foo(i32, i32)</code>, doing <code>impl Muckable for Foo</code> would currently be a NOP -- there are no layout guarantees for <code>Foo</code>. But maybe one day we'll guarantee that homogeneous structs are compatible with arrays, so suddenly this <code>impl Muckable</code> will allow safe transmutes from <code>[i32; 2]</code>.</p>



<a name="216746906"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/216762-project-safe-transmute/topic/%60Muckable%60%20semver%20hazard/near/216746906" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard.html#216746906">(Nov 14 2020 at 19:54)</a>:</h4>
<p>I don't see a problem though, isn't that the whole point of Muckable? The only way it wouldn't work would be if stuff got removed.</p>



<a name="216747469"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/216762-project-safe-transmute/topic/%60Muckable%60%20semver%20hazard/near/216747469" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Wrenn <a href="https://zulip-archive.rust-lang.org/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard.html#216747469">(Nov 14 2020 at 20:06)</a>:</h4>
<p>Oh, hm. I spy a potential <em>language-level</em> stability hazard.</p>
<p>Imagine you've written:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="cp">#[repr(Rust)]</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Foo</span><span class="p">{</span><span class="n">a</span>: <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">b</span>: <span class="kt">f32</span><span class="p">})</span><span class="w"></span>
<span class="k">impl</span><span class="w"> </span><span class="n">Muckable</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
</code></pre></div>
<p>This is <em>currently</em> a no-op, since Rust doesn't provide any layout guarantees for <code>Foo</code>. </p>
<p>But let's say that Rust <em>does</em> guarantee that <code>Foo</code> is transmutable into <code>[i32; 2]</code>, but still doesn't specify field order. You could not implement <code>Muckable</code> for such a type because <em>you</em> don't need to change the definition for the fields to be re-ordered in memory!</p>
<p><code>Muckable</code>'s promise is unenforcable. The type author doesn't need to reorder the field themselves for the fields to get re-ordered in memory.</p>



<a name="216747556"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/216762-project-safe-transmute/topic/%60Muckable%60%20semver%20hazard/near/216747556" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Wrenn <a href="https://zulip-archive.rust-lang.org/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard.html#216747556">(Nov 14 2020 at 20:09)</a>:</h4>
<p><code>Muckable</code> is really only fit for <code>#[repr(C)]</code> types—their layouts are completely specified, and only a change to the definition can change their layout.</p>



<a name="216747627"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/216762-project-safe-transmute/topic/%60Muckable%60%20semver%20hazard/near/216747627" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard.html#216747627">(Nov 14 2020 at 20:11)</a>:</h4>
<p>Could we just not go down that road and prevent implementations for <code>repr(Rust)</code>?</p>



<a name="216747738"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/216762-project-safe-transmute/topic/%60Muckable%60%20semver%20hazard/near/216747738" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Wrenn <a href="https://zulip-archive.rust-lang.org/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard.html#216747738">(Nov 14 2020 at 20:14)</a>:</h4>
<p>Sure, if we want <code>Muckable</code> to denote "you won't change anything about the layout" we <strong>must</strong> restrict it to <code>#[repr(C)]</code> or <code>#[repr(transparent)]</code> types where all fields are <code>Muckable</code>.</p>



<a name="216747817"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/216762-project-safe-transmute/topic/%60Muckable%60%20semver%20hazard/near/216747817" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Wrenn <a href="https://zulip-archive.rust-lang.org/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard.html#216747817">(Nov 14 2020 at 20:17)</a>:</h4>
<p>...but the constraining layout guarantees Rust might provide in the future for <code>#[repr(Rust)]</code> and other reprs is very much outside of the hands of this working group.</p>
<p>If Rust ever provides such guarantees in the future, they <em>won't</em> be usable with <code>TransmuteFrom</code> because they won't be usable with <code>Muckable</code>.</p>



<a name="216748452"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/216762-project-safe-transmute/topic/%60Muckable%60%20semver%20hazard/near/216748452" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Wrenn <a href="https://zulip-archive.rust-lang.org/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard.html#216748452">(Nov 14 2020 at 20:33)</a>:</h4>
<p>The root of the issue is that <code>Muckable</code> is intertwined with <em>both</em> safety and stability. There <em>is</em> a version of this RFC where safety and stability aren't intertwined. We might also try to disentangle the two in the <code>Muckable</code> version of the RFC.</p>
<p>Here's what this might look like:</p>
<ul>
<li><code>Muckable</code> denotes that a type does not have internal value invariants, and</li>
<li>the fields of a <code>Muckable</code> type are <em>also</em> <code>Muckable</code></li>
<li><code>Muckable</code> does <em>not</em> denote anything else about layout stability</li>
</ul>



<a name="216748670"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/216762-project-safe-transmute/topic/%60Muckable%60%20semver%20hazard/near/216748670" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Wrenn <a href="https://zulip-archive.rust-lang.org/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard.html#216748670">(Nov 14 2020 at 20:37)</a>:</h4>
<p>That might be unsatisfying for other reasons, though. Are option-like types <code>Muckable</code>? (<code>#[repr(rust)]</code> option-like types <em>do</em> have layout guarantees.) Are they only <code>Muckable</code> if their fields are <code>Muckable</code>? That rules out some really nifty conversions. <span aria-label="sad" class="emoji emoji-2639" role="img" title="sad">:sad:</span></p>



<a name="216748793"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/216762-project-safe-transmute/topic/%60Muckable%60%20semver%20hazard/near/216748793" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard.html#216748793">(Nov 14 2020 at 20:40)</a>:</h4>
<p>So something I was thinking in my head was a comment above that  currently<code>Muckable</code> was just <code>FixedLayout + InvariantFree</code>.</p>



<a name="216748836"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/216762-project-safe-transmute/topic/%60Muckable%60%20semver%20hazard/near/216748836" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard.html#216748836">(Nov 14 2020 at 20:40)</a>:</h4>
<p>Hnmm what conversions were ruled out?</p>



<a name="216748971"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/216762-project-safe-transmute/topic/%60Muckable%60%20semver%20hazard/near/216748971" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Wrenn <a href="https://zulip-archive.rust-lang.org/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard.html#216748971">(Nov 14 2020 at 20:42)</a>:</h4>
<p>Given:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">enum</span> <span class="nc">Foo</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nb">Some</span><span class="p">(</span><span class="n">T</span><span class="p">),</span><span class="w"></span>
<span class="w">  </span><span class="nb">None</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">enum</span> <span class="nc">Bar</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nb">Some</span><span class="p">(</span><span class="n">T</span><span class="p">),</span><span class="w"></span>
<span class="w">  </span><span class="nb">None</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">Baz</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">..</span><span class="p">.}</span><span class="w"></span>
</code></pre></div>
<p>then a transmute <code>Foo&lt;&amp;Baz&gt;</code> to <code>Bar&lt;&amp;Baz&gt;</code> is already permitted, IIRC. (At any rate, it <em>could</em> be permitted in the future.)</p>



<a name="216749512"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/216762-project-safe-transmute/topic/%60Muckable%60%20semver%20hazard/near/216749512" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard.html#216749512">(Nov 14 2020 at 20:51)</a>:</h4>
<p>I think we could solve that by making <code>TransmuteFrom/Into</code> an unsafe marker trait, that you could implement to say I can transmute into these given types (which is likely what the <code>Archetype</code> system was trying to do) in a more convenient way.</p>



<a name="216749587"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/216762-project-safe-transmute/topic/%60Muckable%60%20semver%20hazard/near/216749587" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Wrenn <a href="https://zulip-archive.rust-lang.org/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard.html#216749587">(Nov 14 2020 at 20:52)</a>:</h4>
<p>Yeah, this issue also disappears if you <em>manually</em> have to specify the completely set of traits your type is transmutable from/into.</p>



<a name="216749693"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/216762-project-safe-transmute/topic/%60Muckable%60%20semver%20hazard/near/216749693" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Wrenn <a href="https://zulip-archive.rust-lang.org/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard.html#216749693">(Nov 14 2020 at 20:54)</a>:</h4>
<p>However, you often <em>can't</em> list out all the types your type ought to be transmutable form. They might be in other crates, they might not even have been written yet.</p>



<a name="216749725"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/216762-project-safe-transmute/topic/%60Muckable%60%20semver%20hazard/near/216749725" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Wrenn <a href="https://zulip-archive.rust-lang.org/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard.html#216749725">(Nov 14 2020 at 20:55)</a>:</h4>
<p>This approach is great for stability (it's basically no different than <code>From</code>/<code>Into</code>), but poor for ergonomics and expressivity. <a href="https://github.com/jswrenn/rfcs/blob/ee1204c23320c33437107ff222e09afd9d5fef1d/text/0000-safer-transmute.md#manual">Check out this section of the RFC.</a></p>



<a name="216749751"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/216762-project-safe-transmute/topic/%60Muckable%60%20semver%20hazard/near/216749751" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard.html#216749751">(Nov 14 2020 at 20:55)</a>:</h4>
<p>I'm not sure i follow how saying that you can't implement muckable on repr(rust) makes a problem for the future.<br>
in the future if repr(rust) becomes better specified wouldn't we just relax the restrictions on what's muckable?</p>



<a name="216749822"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/216762-project-safe-transmute/topic/%60Muckable%60%20semver%20hazard/near/216749822" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard.html#216749822">(Nov 14 2020 at 20:56)</a>:</h4>
<p>note: repr(simd) and "the primitive repr" are technically not the same as repr(c) and so they might need listing in whatever documentation wherever (if muckable is added that is)</p>



<a name="216749920"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/216762-project-safe-transmute/topic/%60Muckable%60%20semver%20hazard/near/216749920" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Wrenn <a href="https://zulip-archive.rust-lang.org/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard.html#216749920">(Nov 14 2020 at 20:58)</a>:</h4>
<p>If <code>Muckable</code> at first denotes "fields will not be re-ordered" (which is a sensible promise when only <code>#[repr(C)]</code> types are concerned), then that promise <em>cannot</em> be safely lifted later on to accomodate <code>#[repr(rust)]</code> types — people will have come to rely on that promise.</p>



<a name="216749931"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/216762-project-safe-transmute/topic/%60Muckable%60%20semver%20hazard/near/216749931" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard.html#216749931">(Nov 14 2020 at 20:59)</a>:</h4>
<p>It would not be lifted</p>



<a name="216749980"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/216762-project-safe-transmute/topic/%60Muckable%60%20semver%20hazard/near/216749980" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Wrenn <a href="https://zulip-archive.rust-lang.org/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard.html#216749980">(Nov 14 2020 at 21:00)</a>:</h4>
<p>I don't follow what you mean by "relaxed", then.</p>



<a name="216749998"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/216762-project-safe-transmute/topic/%60Muckable%60%20semver%20hazard/near/216749998" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard.html#216749998">(Nov 14 2020 at 21:00)</a>:</h4>
<p>my point was that in some situations a repr(rust) struct might have guaranteed ordered fields via (future mechanism), and then would be muckable</p>



<a name="216750019"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/216762-project-safe-transmute/topic/%60Muckable%60%20semver%20hazard/near/216750019" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard.html#216750019">(Nov 14 2020 at 21:01)</a>:</h4>
<p>because what we <em>really</em> care about is a fixed/defined field layout, right?</p>



<a name="216750025"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/216762-project-safe-transmute/topic/%60Muckable%60%20semver%20hazard/near/216750025" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard.html#216750025">(Nov 14 2020 at 21:01)</a>:</h4>
<p>and repr(c) is just one way to have that</p>



<a name="216750027"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/216762-project-safe-transmute/topic/%60Muckable%60%20semver%20hazard/near/216750027" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Wrenn <a href="https://zulip-archive.rust-lang.org/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard.html#216750027">(Nov 14 2020 at 21:01)</a>:</h4>
<p>Oh sure. And there's also a future in which a <code>repr(rust)</code> struct might have every layout property guaranteed <em>except</em> field ordering.</p>



<a name="216750103"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/216762-project-safe-transmute/topic/%60Muckable%60%20semver%20hazard/near/216750103" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard.html#216750103">(Nov 14 2020 at 21:03)</a>:</h4>
<p>i mean iirc even repr(transparent) is supposed to be just a dumb compiler hint, and any repr(rust) single-field type is supposed to act like the repr(transparent) version even if not so marked, this just isn't a hard guarantee, hence the attribute's usage</p>



<a name="216750151"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/216762-project-safe-transmute/topic/%60Muckable%60%20semver%20hazard/near/216750151" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard.html#216750151">(Nov 14 2020 at 21:04)</a>:</h4>
<p>I mean that approach where <code>Muckable</code> doesn't need a <code>IgnoreStability</code> but <code>InvariantFree</code> does need  <code>IgnoreStability</code> would be strictly more utility (and backwards compatible), and if we specify <code>Muckable</code> right I think we can punt on these questions for later.</p>



<a name="216750183"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/216762-project-safe-transmute/topic/%60Muckable%60%20semver%20hazard/near/216750183" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard.html#216750183">(Nov 14 2020 at 21:05)</a>:</h4>
<p>Either as extensions to the RFC or something the project group tackles later when this core is done.</p>



<a name="216750267"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/216762-project-safe-transmute/topic/%60Muckable%60%20semver%20hazard/near/216750267" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Wrenn <a href="https://zulip-archive.rust-lang.org/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard.html#216750267">(Nov 14 2020 at 21:08)</a>:</h4>
<p>Hm, I think we're talking somewhat past each other <span class="user-mention" data-user-id="224471">@Lokathor</span>. We're trying to figure out what, exactly, <code>Muckable</code> should connote. The degree to which you care about the stability of field layout order depends on use-case.</p>
<ul>
<li>A struct with every layout property guaranteed <em>except</em> layout field order will still have well-defined alignment and size. If you are doing pointer-bitpacking, that's enough.</li>
<li>A struct with every layout property guaranteed, but field order is <em>only</em> guaranteed to be the same for a particular compiler version is totally fine in some serialization/deserialization contexts.</li>
</ul>
<p>An all-or-nothing stability system that's intertwined with safety doesn't accomodate these use cases.</p>



<a name="216750320"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/216762-project-safe-transmute/topic/%60Muckable%60%20semver%20hazard/near/216750320" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard.html#216750320">(Nov 14 2020 at 21:10)</a>:</h4>
<p>ah, exactly what Muckable means is up to others, i suppose i just wanted to point out that the future hazard isn't really that large</p>



<a name="216750381"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/216762-project-safe-transmute/topic/%60Muckable%60%20semver%20hazard/near/216750381" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Wrenn <a href="https://zulip-archive.rust-lang.org/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard.html#216750381">(Nov 14 2020 at 21:11)</a>:</h4>
<p>It just maybe closes off some future use-cases. Like, we define <code>Muckable</code> to mean "field layout order is fixed", and then later the Rust Language decides that <code>repr(Rust)</code> types have every layout property specified <em>except</em> for field order, you won't be able to use our work to figure out if those transmutations are safe.</p>



<a name="216750441"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/216762-project-safe-transmute/topic/%60Muckable%60%20semver%20hazard/near/216750441" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Wrenn <a href="https://zulip-archive.rust-lang.org/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard.html#216750441">(Nov 14 2020 at 21:12)</a>:</h4>
<p>Oh, and super crucially, if we made <code>Muckable</code> denote "field layout order is fixed", we would have to—via the compiler—prohibit implementations of <code>Muckable</code> for <code>repr(rust)</code> types, since <code>repr(rust)</code> types <em>could</em> eventually guarantee that every layout property <em>except</em> for field order is specified. It would be awkward if people were <em>already</em> implementing <code>Muckable</code> for such types.</p>



<a name="216750518"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/216762-project-safe-transmute/topic/%60Muckable%60%20semver%20hazard/near/216750518" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Wrenn <a href="https://zulip-archive.rust-lang.org/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard.html#216750518">(Nov 14 2020 at 21:14)</a>:</h4>
<p>(This is where I suggest <em>again</em> that reflecting layout stability in the type system is <em>really</em> complicated, and so we should limit ourselves to <em>only</em> solving safe transmutation initially. <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span>)</p>



<a name="216751151"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/216762-project-safe-transmute/topic/%60Muckable%60%20semver%20hazard/near/216751151" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard.html#216751151">(Nov 14 2020 at 21:32)</a>:</h4>
<p>we already have to prevent Muckable for repr(rust) if there's more than one field</p>



<a name="216751158"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/216762-project-safe-transmute/topic/%60Muckable%60%20semver%20hazard/near/216751158" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard.html#216751158">(Nov 14 2020 at 21:32)</a>:</h4>
<p>that's not a future hazard, that's the case today</p>



<a name="216751321"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/216762-project-safe-transmute/topic/%60Muckable%60%20semver%20hazard/near/216751321" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Wrenn <a href="https://zulip-archive.rust-lang.org/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard.html#216751321">(Nov 14 2020 at 21:35)</a>:</h4>
<p>If <code>Muckable</code> <em>only</em> denotes that the type doesn't have internal value invariants, then we do <em>not</em> have to prohibit implementations of <code>Muckable</code> for <code>repr(Rust)</code> types. Just because the source and destination types of a transmute are <code>Muckable</code> <em>doesn't</em> mean they'll be <code>TransmuteFrom</code>.</p>



<a name="216751400"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/216762-project-safe-transmute/topic/%60Muckable%60%20semver%20hazard/near/216751400" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Wrenn <a href="https://zulip-archive.rust-lang.org/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard.html#216751400">(Nov 14 2020 at 21:36)</a>:</h4>
<p>So, it'd currently be pointless to mark a <code>repr(rust)</code> type as <code>Muckable</code>, but doing so wouldn't pose any sort of hazard.</p>



<a name="216805225"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/216762-project-safe-transmute/topic/%60Muckable%60%20semver%20hazard/near/216805225" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard.html#216805225">(Nov 15 2020 at 17:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="219211">Jack Wrenn</span> <a href="#narrow/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard/near/216749920">said</a>:</p>
<blockquote>
<p>If <code>Muckable</code> at first denotes "fields will not be re-ordered" (which is a sensible promise when only <code>#[repr(C)]</code> types are concerned), then that promise <em>cannot</em> be safely lifted later on to accomodate <code>#[repr(rust)]</code> types — people will have come to rely on that promise.</p>
</blockquote>
<p>but doesn't it denote that <em>and</em> a safe constructor given safe values of all fields -- but the latter only if some layout-compatible type actually exists? I guess for <code>repr(C)</code>, one always exists.</p>



<a name="216805278"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/216762-project-safe-transmute/topic/%60Muckable%60%20semver%20hazard/near/216805278" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard.html#216805278">(Nov 15 2020 at 18:00)</a>:</h4>
<p>the latter is what I am concerned about -- it needs to be clear that <code>Muckable</code> entails publicly exposing a constructor that, given a value for each field, constructs a value of this type. this needs to be the case even if <code>Muckable</code> would, for one reason or another, be otherwise a NOP.</p>



<a name="216805503"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/216762-project-safe-transmute/topic/%60Muckable%60%20semver%20hazard/near/216805503" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Wrenn <a href="https://zulip-archive.rust-lang.org/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard.html#216805503">(Nov 15 2020 at 18:04)</a>:</h4>
<p>Yeah. I think I'm already on board with you there. The <em>primary</em> implication of <code>Muckable</code> is that you're potentially providing a safe, unchecked constructor for your type's bits.</p>



<a name="216805707"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/216762-project-safe-transmute/topic/%60Muckable%60%20semver%20hazard/near/216805707" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Wrenn <a href="https://zulip-archive.rust-lang.org/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard.html#216805707">(Nov 15 2020 at 18:09)</a>:</h4>
<p>Unrelated, but I wonder if there's a potential safe transmute stability hazard in <code>Muckable</code> if Rust <a href="https://github.com/rust-lang/rust/issues/70230">changed the validity guarantees of padding bytes</a>. It couldn't practically do so for <code>#[repr(C)]</code> types (the main purpose of which are FFI and other languages <em>don't</em> necessarily have init padding bytes), but it could for other reprs.</p>



<a name="216809712"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/216762-project-safe-transmute/topic/%60Muckable%60%20semver%20hazard/near/216809712" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard.html#216809712">(Nov 15 2020 at 19:37)</a>:</h4>
<p>what hazard do you have in mind? if we ever want to provide layout guarantees for <code>repr(Rust)</code> types with padding we need to decide we never want to have guaranteed-zero padding (or account of it), is that what you mean?</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>