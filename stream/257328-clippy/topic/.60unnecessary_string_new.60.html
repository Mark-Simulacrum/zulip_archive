<html>
<head><meta charset="utf-8"><title>`unnecessary_string_new` · clippy · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/257328-clippy/index.html">clippy</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/257328-clippy/topic/.60unnecessary_string_new.60.html">`unnecessary_string_new`</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="278197675"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/257328-clippy/topic/%60unnecessary_string_new%60/near/278197675" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Yoav Lavi <a href="https://zulip-archive.rust-lang.org/stream/257328-clippy/topic/.60unnecessary_string_new.60.html#278197675">(Apr 07 2022 at 17:19)</a>:</h4>
<p>Hey everyone, </p>
<p>Would love some guidance in how to implement <a href="https://github.com/rust-lang/rust-clippy/issues/8650">this lint</a>.</p>
<p><span class="user-mention" data-user-id="264664">@flip1995</span> suggested the following:</p>
<blockquote>
<p>This lint might be similar to the ptr_arg lint, but with the additional step of figuring out what the actual required type is. Maybe this can be done with expr_ty_adjusted, but if not this might be a bit more difficult with figuring out the actual type by looking at the function definition.<br>
But the ptr_arg lint should be a good starting point for figuring out if you're dealing with a type like &amp;String, &amp;Vec, ...</p>
</blockquote>
<p>I'm not 100% sure how to adjust <code>ptr_arg</code> for this as it's built for traits rather than free functions. Is it possible to reach function usages from a definition?</p>
<p>Would something that detects free functions work for trait / impls?</p>
<p>I did manage to reach the function definition from the usage earlier (other way around), in which case I need to be able to match an argument being <code>&amp;str</code>.</p>
<p>It's possible to detect a call to <code>String::new()</code> like so:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">impl</span><span class="o">&lt;'</span><span class="na">tcx</span><span class="o">&gt;</span><span class="w"> </span><span class="n">LateLintPass</span><span class="o">&lt;'</span><span class="na">tcx</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">UnnecessaryStringNew</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">check_expr</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">cx</span>: <span class="kp">&amp;</span><span class="nc">LateContext</span><span class="o">&lt;'</span><span class="na">tcx</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">expr</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">tcx</span> <span class="nc">Expr</span><span class="o">&lt;'</span><span class="na">tcx</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">        </span><span class="n">if_chain</span><span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="n">ExprKind</span>::<span class="n">Call</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">expr</span><span class="p">.</span><span class="n">kind</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="n">ExprKind</span>::<span class="n">Path</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">qpath</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fun</span><span class="p">.</span><span class="n">kind</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">fn_def_id</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cx</span><span class="p">.</span><span class="n">qpath_res</span><span class="p">(</span><span class="n">qpath</span><span class="p">,</span><span class="w"> </span><span class="n">fun</span><span class="p">.</span><span class="n">hir_id</span><span class="p">).</span><span class="n">opt_def_id</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">match_def_path</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span><span class="w"> </span><span class="n">fn_def_id</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">paths</span>::<span class="n">STRING_NEW</span><span class="p">);</span><span class="w"> </span><span class="c1">//  ["alloc", "string", "String", "new"]</span>
<span class="w">            </span><span class="n">then</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>But this may not be the most efficient way to do so, I'm still getting familiar with the Clippy codebase.</p>
<p>Additionally, is it possible to debug lints (interactively) using e.g. CLion?</p>
<p>Thank you!</p>



<a name="278198237"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/257328-clippy/topic/%60unnecessary_string_new%60/near/278198237" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> flip1995 <a href="https://zulip-archive.rust-lang.org/stream/257328-clippy/topic/.60unnecessary_string_new.60.html#278198237">(Apr 07 2022 at 17:23)</a>:</h4>
<p>The similarity with <code>ptr_arg</code> I suspected exists is with detecting those suspcious types, like <code>&amp;String</code>, <code>&amp;Vec</code>, .... that have a non-owned alternative. Once you found such a type the lints aren't really similar anymore I guess. </p>
<p>I assume that if you find a <code>&amp;String::new</code> and then call <code>cx.tcx.expr_ty_adjusted</code> on that expression, it might just return <code>&amp;str</code>.</p>
<p>If that doesn't work and you already managed to reach the function def from the use site, then that's the way to go.</p>



<a name="278198335"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/257328-clippy/topic/%60unnecessary_string_new%60/near/278198335" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> flip1995 <a href="https://zulip-archive.rust-lang.org/stream/257328-clippy/topic/.60unnecessary_string_new.60.html#278198335">(Apr 07 2022 at 17:24)</a>:</h4>
<p>No idea about <code>CLion</code>. I usually place many <code>dbg!()</code> macros into the lint to get a feeling for what I'm looking at</p>



<a name="278198932"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/257328-clippy/topic/%60unnecessary_string_new%60/near/278198932" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Yoav Lavi <a href="https://zulip-archive.rust-lang.org/stream/257328-clippy/topic/.60unnecessary_string_new.60.html#278198932">(Apr 07 2022 at 17:29)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="264664">@flip1995</span> !</p>
<p>A few questions if you or anyone else has the time (I don't want to flood you with too many <span aria-label="smiling face" class="emoji emoji-263a" role="img" title="smiling face">:smiling_face:</span>):</p>
<ul>
<li>What is <code>adjusted</code> referring to here?</li>
<li>I'm not sure I understand the advice regarding calling <code>cx.tcx.expr_ty_adjusted</code> on <code>&amp;String::new</code>, do you mean it wouldn't be beneficial or that it would that be an easier way of detecting <code>&amp;String::new</code> vs <code>String::new</code>?</li>
<li>Is there a way to go from <code>String::new()</code> to <code>&amp;String::new()</code>? Since I have to make sure that's what I'm matching rather than any arbitrary call to <code>String::new()</code></li>
</ul>
<p>Thank you!</p>



<a name="278199745"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/257328-clippy/topic/%60unnecessary_string_new%60/near/278199745" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> flip1995 <a href="https://zulip-archive.rust-lang.org/stream/257328-clippy/topic/.60unnecessary_string_new.60.html#278199745">(Apr 07 2022 at 17:35)</a>:</h4>
<ul>
<li>Rust is able to dereference types automatically (and some other operations on types). This is the reason why you don't need an operator like <code>-&gt;</code> that you need in C. Those automatic type transformations are called "adjustments" in the compiler.</li>
<li>It may be a way to find out, if the compiler actually needed an <code>&amp;str</code>.  So in the <code>check_expr</code> function you posted above, after you found the <code>&amp;String::new()</code> call, you can call <code>cx.tcx.expr_ty_adjusted(expr)</code> on the whole expression and check if that is <code>&amp;str</code>.</li>
<li>Good question. No, not really, BUT why not go the other way around and start the <code>if_chain</code> with checking for an <code>ExprKind::Ref(expr2)</code>, and then check <code>expr2</code> if it is <code>String::new()</code></li>
<li>You will get a <code>ty::Ty</code> from <code>expr_ty_adjusted</code>. Im pretty sure there is a <code>ty::TyKind::Str</code> or something similar you can check for.</li>
</ul>



<a name="278200058"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/257328-clippy/topic/%60unnecessary_string_new%60/near/278200058" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Yoav Lavi <a href="https://zulip-archive.rust-lang.org/stream/257328-clippy/topic/.60unnecessary_string_new.60.html#278200058">(Apr 07 2022 at 17:37)</a>:</h4>
<ul>
<li>Got it, so essentially it could have been <code>expr_ty_dereferenced</code> in terms of the meaning</li>
<li>Sounds good, that would probably be better than reaching the definition</li>
<li>Will check it out, sounds promising!</li>
<li>Same as above</li>
</ul>
<p>Thank you! Appreciate the help</p>



<a name="278200267"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/257328-clippy/topic/%60unnecessary_string_new%60/near/278200267" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> flip1995 <a href="https://zulip-archive.rust-lang.org/stream/257328-clippy/topic/.60unnecessary_string_new.60.html#278200267">(Apr 07 2022 at 17:39)</a>:</h4>
<ul>
<li>Yes, but the compiler also does other cool things with types, like unsizing. But generally that is the mental model.</li>
<li>Yeah, I hope that works.</li>
</ul>



<a name="278200696"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/257328-clippy/topic/%60unnecessary_string_new%60/near/278200696" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Yoav Lavi <a href="https://zulip-archive.rust-lang.org/stream/257328-clippy/topic/.60unnecessary_string_new.60.html#278200696">(Apr 07 2022 at 17:42)</a>:</h4>
<p><code>ExprKind::Ref</code> - does this exist in <code>rust_hir</code> or only in <code>rust_ast</code>? If not, do I need to use an early pass lint?</p>



<a name="278200858"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/257328-clippy/topic/%60unnecessary_string_new%60/near/278200858" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> flip1995 <a href="https://zulip-archive.rust-lang.org/stream/257328-clippy/topic/.60unnecessary_string_new.60.html#278200858">(Apr 07 2022 at 17:43)</a>:</h4>
<p>Oh in HIR it is <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir/enum.ExprKind.html#variant.AddrOf">ExprKind::AddrOf`</a>. You definitely need a LatePass, because you need type information. You don't have type information in an EarlyPass</p>



<a name="278200901"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/257328-clippy/topic/%60unnecessary_string_new%60/near/278200901" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Yoav Lavi <a href="https://zulip-archive.rust-lang.org/stream/257328-clippy/topic/.60unnecessary_string_new.60.html#278200901">(Apr 07 2022 at 17:44)</a>:</h4>
<p>Thanks!</p>



<a name="278202343"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/257328-clippy/topic/%60unnecessary_string_new%60/near/278202343" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Yoav Lavi <a href="https://zulip-archive.rust-lang.org/stream/257328-clippy/topic/.60unnecessary_string_new.60.html#278202343">(Apr 07 2022 at 17:54)</a>:</h4>
<p>Does the following make sense?</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">impl</span><span class="o">&lt;'</span><span class="na">tcx</span><span class="o">&gt;</span><span class="w"> </span><span class="n">LateLintPass</span><span class="o">&lt;'</span><span class="na">tcx</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">UnnecessaryStringNew</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">check_expr</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">cx</span>: <span class="kp">&amp;</span><span class="nc">LateContext</span><span class="o">&lt;'</span><span class="na">tcx</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">expr</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">tcx</span> <span class="nc">Expr</span><span class="o">&lt;'</span><span class="na">tcx</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">        </span><span class="n">if_chain</span><span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="n">ExprKind</span>::<span class="n">AddrOf</span><span class="p">(</span><span class="o">..</span><span class="p">,</span><span class="w"> </span><span class="n">inner_expr</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">expr</span><span class="p">.</span><span class="n">kind</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="n">ExprKind</span>::<span class="n">Call</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inner_expr</span><span class="p">.</span><span class="n">kind</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="n">ExprKind</span>::<span class="n">Path</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">qpath</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fun</span><span class="p">.</span><span class="n">kind</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">fn_def_id</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cx</span><span class="p">.</span><span class="n">qpath_res</span><span class="p">(</span><span class="n">qpath</span><span class="p">,</span><span class="w"> </span><span class="n">fun</span><span class="p">.</span><span class="n">hir_id</span><span class="p">).</span><span class="n">opt_def_id</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">match_def_path</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span><span class="w"> </span><span class="n">fn_def_id</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">paths</span>::<span class="n">STRING_NEW</span><span class="p">);</span><span class="w"> </span><span class="c1">//  ["alloc", "string", "String", "new"]</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="n">ty</span>::<span class="n">TyKind</span>::<span class="n">Ref</span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">inner_str</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cx</span><span class="p">.</span><span class="n">typeck_results</span><span class="p">().</span><span class="n">expr_ty_adjusted</span><span class="p">(</span><span class="n">expr</span><span class="p">).</span><span class="n">kind</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">inner_str</span><span class="p">.</span><span class="n">is_str</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="n">then</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>



<a name="278203197"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/257328-clippy/topic/%60unnecessary_string_new%60/near/278203197" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Yoav Lavi <a href="https://zulip-archive.rust-lang.org/stream/257328-clippy/topic/.60unnecessary_string_new.60.html#278203197">(Apr 07 2022 at 18:00)</a>:</h4>
<p><del>Looks like it matches for <code>&amp;String</code> as well</del></p>



<a name="278203294"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/257328-clippy/topic/%60unnecessary_string_new%60/near/278203294" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Yoav Lavi <a href="https://zulip-archive.rust-lang.org/stream/257328-clippy/topic/.60unnecessary_string_new.60.html#278203294">(Apr 07 2022 at 18:00)</a>:</h4>
<p>Oh no nevermind, it doesn't</p>



<a name="278203908"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/257328-clippy/topic/%60unnecessary_string_new%60/near/278203908" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Yoav Lavi <a href="https://zulip-archive.rust-lang.org/stream/257328-clippy/topic/.60unnecessary_string_new.60.html#278203908">(Apr 07 2022 at 18:05)</a>:</h4>
<p>With suggestion:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">impl</span><span class="o">&lt;'</span><span class="na">tcx</span><span class="o">&gt;</span><span class="w"> </span><span class="n">LateLintPass</span><span class="o">&lt;'</span><span class="na">tcx</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">UnnecessaryStringNew</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">check_expr</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">cx</span>: <span class="kp">&amp;</span><span class="nc">LateContext</span><span class="o">&lt;'</span><span class="na">tcx</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">expr</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">tcx</span> <span class="nc">Expr</span><span class="o">&lt;'</span><span class="na">tcx</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">applicability</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Applicability</span>::<span class="n">MachineApplicable</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">if_chain</span><span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="n">ExprKind</span>::<span class="n">AddrOf</span><span class="p">(</span><span class="o">..</span><span class="p">,</span><span class="w"> </span><span class="n">inner_expr</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">expr</span><span class="p">.</span><span class="n">kind</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="n">ExprKind</span>::<span class="n">Call</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inner_expr</span><span class="p">.</span><span class="n">kind</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="n">ExprKind</span>::<span class="n">Path</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">qpath</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fun</span><span class="p">.</span><span class="n">kind</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">fn_def_id</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cx</span><span class="p">.</span><span class="n">qpath_res</span><span class="p">(</span><span class="n">qpath</span><span class="p">,</span><span class="w"> </span><span class="n">fun</span><span class="p">.</span><span class="n">hir_id</span><span class="p">).</span><span class="n">opt_def_id</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">match_def_path</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span><span class="w"> </span><span class="n">fn_def_id</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">paths</span>::<span class="n">STRING_NEW</span><span class="p">);</span><span class="w"> </span><span class="c1">//  ["alloc", "string", "String", "new"]</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="n">ty</span>::<span class="n">TyKind</span>::<span class="n">Ref</span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">inner_str</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cx</span><span class="p">.</span><span class="n">typeck_results</span><span class="p">().</span><span class="n">expr_ty_adjusted</span><span class="p">(</span><span class="n">expr</span><span class="p">).</span><span class="n">kind</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">inner_str</span><span class="p">.</span><span class="n">is_str</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="n">then</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">span_lint_and_sugg</span><span class="p">(</span><span class="w"></span>
<span class="w">                    </span><span class="n">cx</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="n">UNNECESSARY_STRING_NEW</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="n">expr</span><span class="p">.</span><span class="n">span</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="s">"Detected a usage of `&amp;String::new()` for a function expecting a `&amp;str` argument"</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="s">"try"</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="s">"</span><span class="se">\"\"</span><span class="s">"</span><span class="p">.</span><span class="n">to_owned</span><span class="p">(),</span><span class="w"></span>
<span class="w">                    </span><span class="n">applicability</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>



<a name="278268394"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/257328-clippy/topic/%60unnecessary_string_new%60/near/278268394" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> flip1995 <a href="https://zulip-archive.rust-lang.org/stream/257328-clippy/topic/.60unnecessary_string_new.60.html#278268394">(Apr 08 2022 at 07:58)</a>:</h4>
<p>You probably also want to check that the <code>AddrOf</code> is immutable. I'm pretty sure that converting <code>&amp;mut String</code> to <code>&amp;mut str</code> doesn't work.</p>
<p>Otherwise this LGTM. Also no need to post code snippets of a whole lint here on Zulip <span aria-label="big smile" class="emoji emoji-1f604" role="img" title="big smile">:big_smile:</span> . You can open a WIP PR anytime. Then you also get the CI to tell you if something is wrong.</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>