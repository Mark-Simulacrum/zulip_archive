<html>
<head><meta charset="utf-8"><title>Weak provenance function pointers · t-lang/wg-unsafe-code-guidelines · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/index.html">t-lang/wg-unsafe-code-guidelines</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Weak.20provenance.20function.20pointers.html">Weak provenance function pointers</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="278230988"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Weak%20provenance%20function%20pointers/near/278230988" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Weak.20provenance.20function.20pointers.html#278230988">(Apr 07 2022 at 21:50)</a>:</h4>
<p>On non-CHERI architectures, does function pointer provenance mean anything to the optimizer/is it used for optimizations? It seems like it should be really easy to spec out something for them, as you don't have to deal with one-past-the-end or Stacked Borrows.</p>



<a name="278233336"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Weak%20provenance%20function%20pointers/near/278233336" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Weak.20provenance.20function.20pointers.html#278233336">(Apr 07 2022 at 22:12)</a>:</h4>
<p><span class="user-mention" data-user-id="303115">@Quy Nguyen</span> See the "associated with" rules in <a href="https://llvm.org/docs/LangRef.html#pointer-aliasing-rules">https://llvm.org/docs/LangRef.html#pointer-aliasing-rules</a>, which LLVM uses for optimizations.</p>



<a name="278355229"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Weak%20provenance%20function%20pointers/near/278355229" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Weak.20provenance.20function.20pointers.html#278355229">(Apr 08 2022 at 20:01)</a>:</h4>
<p>I think the answer is no, optimizers dont do anything with fn ptr provenance. but I am not sure, LLVM does lots of things...</p>



<a name="278355260"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Weak%20provenance%20function%20pointers/near/278355260" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Weak.20provenance.20function.20pointers.html#278355260">(Apr 08 2022 at 20:01)</a>:</h4>
<p>also at least in Miri we treat fn ptrs as ptrs to zero-sized allocations so they are <em>always</em> one-past-the-end ;)</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>