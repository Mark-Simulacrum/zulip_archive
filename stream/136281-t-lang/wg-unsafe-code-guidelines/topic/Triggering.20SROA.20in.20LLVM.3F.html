<html>
<head><meta charset="utf-8"><title>Triggering SROA in LLVM? · t-lang/wg-unsafe-code-guidelines · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/index.html">t-lang/wg-unsafe-code-guidelines</a></h2>
<h3>Topic: <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html">Triggering SROA in LLVM?</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://rust-lang.github.io/zulip_archive/style.css" rel="stylesheet"></head>

<a name="168067834"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168067834" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168067834">(Jun 13 2019 at 17:45)</a>:</h4>
<p>Does someone know a good way to trigger SROA in LLVM? I am trying to demonstrate concretely that in LLVM, padding can turn into <code>undef</code> any time, but I don't know how to write that example.^^</p>



<a name="168068006"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168068006" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168068006">(Jun 13 2019 at 17:47)</a>:</h4>
<p>ah I think I <a href="https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2018&amp;gist=404f1fd4e8d779d916d659923851ca02" target="_blank" title="https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2018&amp;gist=404f1fd4e8d779d916d659923851ca02">got it</a></p>



<a name="168069764"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168069764" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nagisa <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168069764">(Jun 13 2019 at 18:04)</a>:</h4>
<p>I don’t think expansion in arguments is SROA at all.</p>



<a name="168069978"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168069978" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168069978">(Jun 13 2019 at 18:06)</a>:</h4>
<p>well what I wanted to see is LLVM copying fields separately instead of doing a big <code>memcpy</code></p>



<a name="168069983"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168069983" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168069983">(Jun 13 2019 at 18:06)</a>:</h4>
<p>I thought that's SROA?</p>



<a name="168070043"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168070043" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Hanna Kruppe <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168070043">(Jun 13 2019 at 18:07)</a>:</h4>
<p>Look at the debug LLVM IR, rustc already emits it as per-field copies.</p>



<a name="168070359"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168070359" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nagisa <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168070359">(Jun 13 2019 at 18:11)</a>:</h4>
<p>it was trivial to show that padding was undef before miri, but now that we have our constants be byte arrays, that is harder</p>



<a name="168070411"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168070411" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nagisa <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168070411">(Jun 13 2019 at 18:11)</a>:</h4>
<p>before a plain <code>static A = (0u32, 0u64);</code> ended up generating something like <code>{u32, u32, u64} = {0, undef, 0}</code></p>



<a name="168070590"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168070590" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nagisa <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168070590">(Jun 13 2019 at 18:13)</a>:</h4>
<p><span class="user-mention" data-user-id="120791">@RalfJ</span> how are you expecting to show that padding is undef with SROA?</p>



<a name="168070673"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168070673" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168070673">(Jun 13 2019 at 18:14)</a>:</h4>
<blockquote>
<p>Look at the debug LLVM IR, rustc already emits it as per-field copies.</p>
</blockquote>
<p>d'oh.^^<br>
Well, ultimately the argument was about padding in Rust, not LLVM, so good enough^^</p>



<a name="168070752"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168070752" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Hanna Kruppe <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168070752">(Jun 13 2019 at 18:15)</a>:</h4>
<p><span class="user-mention" data-user-id="123586">@nagisa</span> The trickier (and more relevant to <a href="https://github.com/crossbeam-rs/crossbeam/issues/315" target="_blank" title="https://github.com/crossbeam-rs/crossbeam/issues/315">https://github.com/crossbeam-rs/crossbeam/issues/315</a>) aspect is: after you fully initialized all the <code>size_of::&lt;T&gt;()</code> bytes of a location, and then resume treating it as a <code>T</code> with padding, when (if ever) do the padding bytes get reset to undef?</p>



<a name="168070756"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168070756" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168070756">(Jun 13 2019 at 18:15)</a>:</h4>
<blockquote>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> how are you expecting to show that padding is undef with SROA?</p>
</blockquote>
<p>well like in the example above:</p>
<div class="codehilite"><pre><span></span>  %y = alloca { i32, i64 }, align 8
  %0 = bitcast { i32, i64 }* %y to i8*
  %1 = getelementptr inbounds { i32, i64 }, { i32, i64 }* %y, i64 0, i32 0
  store i32 %x.0, i32* %1, align 8
  %2 = getelementptr inbounds { i32, i64 }, { i32, i64 }* %y, i64 0, i32 1
  store i64 %x.1, i64* %2, align 8
  call void %f({ i32, i64 }* noalias nonnull readonly align 8 dereferenceable(16) %y)
</pre></div>


<p>clearly when <code>f</code> gets  called the padding in <code>%y</code> is still <code>undef</code> because it has never been written to</p>



<a name="168070913"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168070913" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168070913">(Jun 13 2019 at 18:16)</a>:</h4>
<blockquote>
<p><span class="user-mention silent" data-user-id="123586">nagisa</span> The trickier (and more relevant to <a href="https://github.com/crossbeam-rs/crossbeam/issues/315" target="_blank" title="https://github.com/crossbeam-rs/crossbeam/issues/315">https://github.com/crossbeam-rs/crossbeam/issues/315</a>) aspect is: after you fully initialized all the <code>size_of::&lt;T&gt;()</code> bytes of a location, and then resume treating it as a <code>T</code> with padding, when (if ever) do the padding bytes get reset to undef?</p>
</blockquote>
<p>actually, having any undef in padding is enough for that -- with <code>get_mut</code> we dont get a guarantee that whatever gets written was ever fully initialized</p>



<a name="168070960"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168070960" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168070960">(Jun 13 2019 at 18:17)</a>:</h4>
<p>I just realized that making it <code>Copy</code> if <code>T: Copy</code> would also break this because copying the <code>Atomic&lt;T&gt;</code> will reset to undef^^</p>



<a name="168071057"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168071057" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Hanna Kruppe <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168071057">(Jun 13 2019 at 18:18)</a>:</h4>
<p>If that's enough then even initalizers like <code>let pair = (0u16, 0u32);</code> should demonstrate undef.</p>



<a name="168071097"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168071097" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nagisa <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168071097">(Jun 13 2019 at 18:18)</a>:</h4>
<p>A trivial way to show that is <a href="https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2018&amp;gist=69d8bed54286c5eba34132b2ce36bab4" target="_blank" title="https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2018&amp;gist=69d8bed54286c5eba34132b2ce36bab4">https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2018&amp;gist=69d8bed54286c5eba34132b2ce36bab4</a> probably</p>



<a name="168071113"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168071113" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nagisa <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168071113">(Jun 13 2019 at 18:18)</a>:</h4>
<p>rather than trying to use SROA</p>



<a name="168071162"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168071162" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168071162">(Jun 13 2019 at 18:19)</a>:</h4>
<p><span class="user-mention" data-user-id="123586">@nagisa</span> not sure what that gets us? sure unsafe code can do weird stuff^^</p>



<a name="168071200"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168071200" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168071200">(Jun 13 2019 at 18:19)</a>:</h4>
<p>or do you mean because this can optimize to return <code>undef</code>? hm</p>



<a name="168071202"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168071202" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nagisa <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168071202">(Jun 13 2019 at 18:19)</a>:</h4>
<p>You see <code>undef</code> in optimised LLVM IR which is a nice way to show that "hey, padding bytes are indeed undef"</p>



<a name="168071272"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168071272" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nagisa <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168071272">(Jun 13 2019 at 18:20)</a>:</h4>
<p>and not, say, zeros.</p>



<a name="168071276"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168071276" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168071276">(Jun 13 2019 at 18:20)</a>:</h4>
<p>yeah true</p>



<a name="168071291"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168071291" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168071291">(Jun 13 2019 at 18:20)</a>:</h4>
<p>now extra points if we can do this with any incoming <code>X</code>, not just a locally initialized one.</p>



<a name="168071321"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168071321" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Hanna Kruppe <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168071321">(Jun 13 2019 at 18:20)</a>:</h4>
<p>I doubt LLVM has enough information about padding for that.</p>



<a name="168071334"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168071334" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168071334">(Jun 13 2019 at 18:20)</a>:</h4>
<p>Well that was easy: <a href="https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2018&amp;gist=ae1e2eae63468d5a9eb80f3f140fb3b9" target="_blank" title="https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2018&amp;gist=ae1e2eae63468d5a9eb80f3f140fb3b9">https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2018&amp;gist=ae1e2eae63468d5a9eb80f3f140fb3b9</a></p>



<a name="168071362"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168071362" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Hanna Kruppe <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168071362">(Jun 13 2019 at 18:21)</a>:</h4>
<p>Oh, chaining it with the move-resets-padding</p>



<a name="168071382"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168071382" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nagisa <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168071382">(Jun 13 2019 at 18:21)</a>:</h4>
<p>you can just remove the local <code>let x</code></p>



<a name="168071401"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168071401" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nagisa <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168071401">(Jun 13 2019 at 18:21)</a>:</h4>
<p>but if you pass in <code>x</code> as a reference argument, it is no longer undef.</p>



<a name="168071425"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168071425" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nagisa <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168071425">(Jun 13 2019 at 18:21)</a>:</h4>
<p>(see <a href="https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2018&amp;gist=91ade64c05ea5ca31f7ba3e970fefa92" target="_blank" title="https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2018&amp;gist=91ade64c05ea5ca31f7ba3e970fefa92">https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2018&amp;gist=91ade64c05ea5ca31f7ba3e970fefa92</a>)</p>



<a name="168071524"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168071524" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Hanna Kruppe <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168071524">(Jun 13 2019 at 18:22)</a>:</h4>
<p>Yes, the key is that passing the argument by value already resets any padding (because those bytes aren't even passed)</p>



<a name="168071704"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168071704" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168071704">(Jun 13 2019 at 18:24)</a>:</h4>
<p>well or they are passed but gets reset</p>



<a name="168071717"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168071717" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168071717">(Jun 13 2019 at 18:24)</a>:</h4>
<p>the detail is in the wording, doesnt really matter though</p>



<a name="168382229"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168382229" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> gnzlbg <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168382229">(Jun 18 2019 at 09:09)</a>:</h4>
<blockquote>
<p>Yes, the key is that passing the argument by value already resets any padding (because those bytes aren't even passed)</p>
</blockquote>
<p>That matches what I would expect. We only memcpy fields on move/copy, so the answer to:</p>
<blockquote>
<p>after you fully initialized all the size_of::&lt;T&gt;() bytes of a location, and then resume treating it as a T with padding, when (if ever) do the padding bytes get reset to undef?</p>
</blockquote>
<p>is probably something like "On every copy/undef padding fields (might) be reset to <code>undef</code>." Since one cannot really reason about when copy/moves happen (this changes with the optimization level, and the compiler is allowed to do any of these "whenever"), then it feels simpler for me to just tell people that even if you fully initialize all bytes of an allocation, the moment you start treating it as a <code>T</code>, the padding bytes are always <code>undef</code>.  I don't know how would one implement <code>AtomicCell</code> under this constraints (can it use an <code>[u8; 16]</code> internally?).</p>



<a name="168390674"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168390674" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nagisa <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168390674">(Jun 18 2019 at 11:22)</a>:</h4>
<p>It cannot use <code>[u8; 16]</code> internally if you expect to be able to compare_xchg the whole struct – it would still compare padding bytes. Basically the only thing you can compare_xchg are contiguous data (data for which all bytes have non-padding purpose).</p>



<a name="168404603"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168404603" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> gnzlbg <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168404603">(Jun 18 2019 at 14:12)</a>:</h4>
<p><span class="user-mention" data-user-id="123586">@nagisa</span> what I had in mind is that it would take <code>T</code>, <code>transmute</code> it to <code>[u8; 16]</code> which we should specify as a <code>nop</code>, <code>freeze</code> the <code>[u8; 16]</code> which should also be a <code>nop</code>, and then do a <code>compare_xchg</code> on the result of the freeze</p>



<a name="168404650"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168404650" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168404650">(Jun 18 2019 at 14:12)</a>:</h4>
<p>I assume you mean "NOP on the hardware", because it's clearly not a NOP in Rust or else why would you even do it</p>



<a name="168404683"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168404683" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nagisa <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168404683">(Jun 18 2019 at 14:13)</a>:</h4>
<p>The [u8; 16] stored in the atomiccell and your transmuted [u8; 16] will still have junk in their padding unless you explicitly keep it some particular value.</p>



<a name="168404709"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168404709" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> gnzlbg <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168404709">(Jun 18 2019 at 14:13)</a>:</h4>
<p><span class="user-mention" data-user-id="123586">@nagisa</span> the <code>freeze</code> should give the <code>undef</code> some particular indeterminate value</p>



<a name="168404829"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168404829" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nagisa <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168404829">(Jun 18 2019 at 14:15)</a>:</h4>
<p>It gives undef an arbitrary value for that particular undef. Since compare_exchange works on two distinct values, freeze does not help you there whatsoever – you’ll just be comparing two indeterminate values with a nonsensical outcome.</p>



<a name="168404857"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168404857" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> gnzlbg <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168404857">(Jun 18 2019 at 14:15)</a>:</h4>
<p><span class="user-mention" data-user-id="123586">@nagisa</span> there was a proposed algorithm that worked around that</p>



<a name="168404988"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168404988" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> gnzlbg <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168404988">(Jun 18 2019 at 14:16)</a>:</h4>
<p><span class="user-mention" data-user-id="123586">@nagisa</span>  see: <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/71#issuecomment-460097424" target="_blank" title="https://github.com/rust-lang/unsafe-code-guidelines/issues/71#issuecomment-460097424">https://github.com/rust-lang/unsafe-code-guidelines/issues/71#issuecomment-460097424</a></p>



<a name="168405089"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168405089" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168405089">(Jun 18 2019 at 14:17)</a>:</h4>
<p><span class="user-mention" data-user-id="123586">@nagisa</span> <code>AtomicCell</code> already runs this in a loop to handle that problem</p>



<a name="168405142"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168405142" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168405142">(Jun 18 2019 at 14:18)</a>:</h4>
<p>but the main issue we still have is that there might be <code>undef</code> bytes in the <em>memory</em></p>



<a name="168405152"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168405152" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168405152">(Jun 18 2019 at 14:18)</a>:</h4>
<p>so we'd need a way to "freeze" them that does not introduce a read-write race...</p>



<a name="168405174"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168405174" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nagisa <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168405174">(Jun 18 2019 at 14:18)</a>:</h4>
<p>yeah, you cannot freeze memory and I was already writing that the linked algorithm is, therefore, nonsense.</p>



<a name="168405210"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168405210" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> gnzlbg <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168405210">(Jun 18 2019 at 14:19)</a>:</h4>
<p><span class="user-mention" data-user-id="120791">@RalfJ</span> yes <code>nop</code> was a poor choice</p>



<a name="168405281"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168405281" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168405281">(Jun 18 2019 at 14:19)</a>:</h4>
<p>well maybe you can freeze memory^^ also the loop is needed for other stuff (like <code>PartialEq::eq</code> and byte-wise equality not agreeing)</p>



<a name="168405403"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168405403" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nagisa <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168405403">(Jun 18 2019 at 14:20)</a>:</h4>
<blockquote>
<p>like PartialEq::eq and byte-wise equality not agreeing</p>
</blockquote>
<p>If we’re going <em>there</em> then byte-wise equality does not imply semantic equality either.</p>



<a name="168405425"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168405425" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168405425">(Jun 18 2019 at 14:21)</a>:</h4>
<p>well that's what I said</p>



<a name="168405740"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168405740" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nagisa <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168405740">(Jun 18 2019 at 14:24)</a>:</h4>
<p>anyway, my strong opinion that, with what LLVM semantics are around compare_exchange and padding bytes, this is not currently salvageable for any "loop"</p>



<a name="168406157"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168406157" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> gnzlbg <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168406157">(Jun 18 2019 at 14:29)</a>:</h4>
<p>maybe we need a different intrinsic</p>



<a name="168406421"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168406421" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> gnzlbg <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168406421">(Jun 18 2019 at 14:31)</a>:</h4>
<p>we might need that anyways, e.g., if creating an invalid <code>usize</code> is instant UB</p>



<a name="168406513"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168406513" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168406513">(Jun 18 2019 at 14:32)</a>:</h4>
<p>even with direct access to the abstract machine I don't know how to define a compare_exchange on data involving undef that makes sense and is actually implementable...</p>



<a name="168406579"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168406579" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> gnzlbg <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168406579">(Jun 18 2019 at 14:33)</a>:</h4>
<p>not without huge drawbacks</p>



<a name="168406581"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168406581" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168406581">(Jun 18 2019 at 14:33)</a>:</h4>
<p>I mean we could say "compare frozen versions of the data" (both src and what is in memory). but then (a) there's still no guarantee to converge and (b) this rules out replacing CAS by simple comparison if the compiler can prove that the code is sequential.</p>



<a name="168406617"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168406617" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> gnzlbg <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168406617">(Jun 18 2019 at 14:33)</a>:</h4>
<p>a wild and bad idea would be to say that moves/copys do not touch padding</p>



<a name="168406680"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168406680" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> gnzlbg <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168406680">(Jun 18 2019 at 14:34)</a>:</h4>
<p>so if you have a <code>[u8; 16]</code> and you zero it, and then you move a <code>T</code> on top of it, you know the padding is zero</p>



<a name="168406709"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168406709" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> gnzlbg <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168406709">(Jun 18 2019 at 14:34)</a>:</h4>
<p>but this would mean that moving a struct isn't as simple as a <code>memcpy</code> over the whole struct</p>



<a name="168406714"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168406714" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> gnzlbg <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168406714">(Jun 18 2019 at 14:34)</a>:</h4>
<p>which would be generally bad for perf</p>



<a name="168406739"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168406739" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> gnzlbg <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168406739">(Jun 18 2019 at 14:35)</a>:</h4>
<p>Instead, a less bad idea might be to add a finer grained intrinsic that only moves/copies non-padding bytes</p>



<a name="168407320"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168407320" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> gnzlbg <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168407320">(Jun 18 2019 at 14:41)</a>:</h4>
<p>So that you can do:</p>
<div class="codehilite"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="n">value</span>: <span class="nc">T</span><span class="p">;</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">storage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0_</span><span class="k">usize</span><span class="p">;</span><span class="w"></span>
<span class="n">ptr</span>::<span class="n">write_fields</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">storage</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">);</span><span class="w"></span>
</pre></div>


<p>You would still be working with <code>storage: usize</code>, but padding bytes wouldn't be <code>undef</code>.</p>



<a name="168412240"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168412240" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168412240">(Jun 18 2019 at 15:29)</a>:</h4>
<p>how would that help <code>AtomicCell</code> though?  It can still be moved like normal variables can...</p>



<a name="168412722"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168412722" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> gnzlbg <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168412722">(Jun 18 2019 at 15:34)</a>:</h4>
<p>It would help the implementation of the <code>AtomicCell::compare_exchange</code> algorithm.</p>



<a name="168412824"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168412824" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> gnzlbg <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168412824">(Jun 18 2019 at 15:35)</a>:</h4>
<p>Right now the problem is that some of the bytes in the <code>usize</code> that's used internally for the CAS are <code>undef</code>, so a <code>compare_and_exchange</code> of an <code>usize</code> with <code>undef</code> bytes does "whatever"</p>



<a name="168412987"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168412987" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> gnzlbg <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168412987">(Jun 18 2019 at 15:37)</a>:</h4>
<p><code>AtomicCell&lt;T&gt;</code> could use <code>ptr::write_fields</code> to ensure that the padding bytes of the <code>T</code> stored inside it is always zero (or some other value), and use <code>ptr::write_fields</code> in <code>AtomicCell::compare_and_exchange</code> argument to set its padding bytes to the same value</p>



<a name="168413074"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering%20SROA%20in%20LLVM%3F/near/168413074" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> gnzlbg <a href="https://rust-lang.github.io/zulip_archive/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Triggering.20SROA.20in.20LLVM.3F.html#168413074">(Jun 18 2019 at 15:38)</a>:</h4>
<p>That is, the CAS would only fail if the non-padding bytes of <code>T</code> differ, which is better than "if any bytes differs"</p>



<hr><p>Last updated: Aug 07 2021 at 22:04 UTC</p>
</html>