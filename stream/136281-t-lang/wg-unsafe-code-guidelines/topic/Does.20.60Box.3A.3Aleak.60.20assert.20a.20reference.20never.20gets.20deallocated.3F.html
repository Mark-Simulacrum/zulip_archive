<html>
<head><meta charset="utf-8"><title>Does `Box::leak` assert a reference never gets deallocated? · t-lang/wg-unsafe-code-guidelines · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/index.html">t-lang/wg-unsafe-code-guidelines</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html">Does `Box::leak` assert a reference never gets deallocated?</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="249702746"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/249702746" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nagisa <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#249702746">(Aug 17 2021 at 11:01)</a>:</h4>
<p><code>Box::leak</code> returns a reference with an arbitrary lifetime (including <code>'static</code>). The documentation for the method also says:</p>
<blockquote>
<p>Dropping the returned reference will cause a memory leak. If this is not acceptable, the reference should first be wrapped with the Box::from_raw function producing a Box. This Box can then be dropped which will properly destroy T and release the allocated memory.</p>
</blockquote>
<p>However to me it seems that the fact that <code>'static</code> reference existed at any time in the program is in some ways an assertion that disallows deallocating underlying memory. My working example is somewhat similar to the snippet below, which looks obviously wrong…</p>
<div class="codehilite"><pre><span></span><code>let key: &amp;&#39;static str = Box::leak(format!(&quot;hello world&quot;).into_boxed_str());
match btreemap.entry(key) {
    OccupiedEntry(_) =&gt; unsafe { drop(Box::from_raw(key)); } // key wasn&#39;t used, deallocate
    VacantEntry(_) =&gt; { ...  }
}
</code></pre></div>



<a name="249703066"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/249703066" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nagisa <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#249703066">(Aug 17 2021 at 11:05)</a>:</h4>
<div class="codehilite"><pre><span></span><code>{
let key: &amp;&#39;static str = Box::leak(format!(&quot;hello world&quot;).into_boxed_str());
drop(Box::from_raw(key));
}
</code></pre></div>
<p>is kind of less sketchy but also not super useful?</p>



<a name="249703785"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/249703785" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#249703785">(Aug 17 2021 at 11:14)</a>:</h4>
<p>IMO, it is undefined behaviour, but it has nothing to do with the 'static lifetime. Rather, my argument is a provenance based one. A raw pointer returned from the allocator has sufficient provenance to be deallocated, but a reference only has provenance for the referenced value. Side note, those code snipets most likely has undefined behaviour for yet another reason: the SharedReadOnly reference.</p>



<a name="249704387"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/249704387" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#249704387">(Aug 17 2021 at 11:22)</a>:</h4>
<p><code>leak</code> returns an <code>&amp;'static mut</code>, and at least Stacked Borrows is fine with deallocating through such a pointer (and I dont know of a useful optimization that we'd lose here, so I don't see a good reason to make this UB)</p>



<a name="249704420"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/249704420" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#249704420">(Aug 17 2021 at 11:22)</a>:</h4>
<p>but indeed a <code>&amp;'static</code> (shared ref) must not be used for deallocating (with the usual <code>UnsafeCell</code> exception)</p>



<a name="249722747"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/249722747" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#249722747">(Aug 17 2021 at 14:01)</a>:</h4>
<p>The question is whether the allocator can do stuff outside the bounds of the reference (which is the case of a simple allocator like dlmalloc). That's the main argument I've seen and use myself for why unleaking is UB - the allocator may require more provenance than the mutable reference provides.</p>



<a name="249724021"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/249724021" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#249724021">(Aug 17 2021 at 14:09)</a>:</h4>
<p>hm, I see... that's basically <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/256">https://github.com/rust-lang/unsafe-code-guidelines/issues/256</a> though, right?</p>



<a name="249746819"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/249746819" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#249746819">(Aug 17 2021 at 16:53)</a>:</h4>
<p>Yeah.</p>



<a name="249748627"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/249748627" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#249748627">(Aug 17 2021 at 17:07)</a>:</h4>
<p>so if a future version of Stacked Borrows would solve the header-ptr situation, then arguably allocators could also use that and wouldnt have to rely on getting back the "base pointer"</p>



<a name="249751198"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/249751198" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#249751198">(Aug 17 2021 at 17:28)</a>:</h4>
<p>Probably.</p>



<a name="249779819"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/249779819" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#249779819">(Aug 17 2021 at 21:14)</a>:</h4>
<p>I don't think this needs to be UB even if <code>&amp;'static mut T</code> doesn't give access anywhere beyond the bounds of the <code>T</code>. Morally, the allocator owns all of memory and has loaned out bits of it to user code. So the presence of <code>&amp;mut T</code> pointers in user code indicate that the allocator is not allowed to touch the data covered by the pointer, but it never loans out the header block so it is allowed to do whatever it likes with that block, even concurrently with user code. When the user code calls the allocator to free a <code>&amp;mut T</code>, the allocator uses that pointer in order to find its own header block (which it already owns), as well as evidence that it is allowed to manipulate the memory block which was previously loaned out.</p>



<a name="249783109"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/249783109" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Thom Chiovoloni <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#249783109">(Aug 17 2021 at 21:45)</a>:</h4>
<p>my understanding was that the "uses that pointer in order to find its own header block" part which was UB (at least the manner typically implemented, e.g. direct pointer arithmetic)</p>



<a name="249783441"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/249783441" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Thom Chiovoloni <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#249783441">(Aug 17 2021 at 21:49)</a>:</h4>
<p>that said, this kind of thing pretty cleraly should be allowed in order for rust to be useful in several of the intended use cases, and also (at least for allocator-style usage, which still has seemingly straightforward ownership), doesn't seem to prevent any useful optimizations. so i've kind of just assumed it would eventually work (although i've done my best not to upset miri when taking advantage of it — although perhaps miri wouldn't notice anyway, i never can tell)</p>



<a name="249787876"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/249787876" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#249787876">(Aug 17 2021 at 22:36)</a>:</h4>
<p>Ah, you are right, you probably need some kind of <code>copy_provenance</code> primitive to be inserted there to make it work: the allocator receives the pointer from the user, changes the provenance to the allocator's own provenance, and then does direct pointer arithmetic to get to the header block</p>



<a name="249787954"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/249787954" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#249787954">(Aug 17 2021 at 22:37)</a>:</h4>
<p>That said, C/C++ usually solve this problem by making the allocator itself live kinda-sorta outside the memory model</p>



<a name="249788087"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/249788087" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#249788087">(Aug 17 2021 at 22:38)</a>:</h4>
<p>It's not hard to justify these operations at a slightly lower level memory model, but it limits your ability to write the allocator itself in rust and reason about it with rust rules</p>



<a name="249789223"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/249789223" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Thom Chiovoloni <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#249789223">(Aug 17 2021 at 22:53)</a>:</h4>
<blockquote>
<p>making the allocator itself live kinda-sorta outside the memory model</p>
</blockquote>
<p>well, c++ allows this arithmetic in many cases (since it's part of the same allocated object), although probably not all. regardless, i'm hoping similar things aren't needed for rust. allocators aren't the only case where this sort of stuff creeps in, as evidenced by the use cases in ucg/256</p>



<a name="249819513"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/249819513" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#249819513">(Aug 18 2021 at 08:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="271719">Mario Carneiro</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F/near/249787954">said</a>:</p>
<blockquote>
<p>That said, C/C++ usually solve this problem by making the allocator itself live kinda-sorta outside the memory model</p>
</blockquote>
<p>yeah but that seems like a last resort... people write custom allocators, they are already hard enough to specify without adding such extra issues ;)</p>



<a name="249819546"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/249819546" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#249819546">(Aug 18 2021 at 08:12)</a>:</h4>
<p>but indeed in my formal work I always treat the allocator as a language primitive. there are bigger things to resolve before that becomes the most interesting problem.^^</p>



<a name="249973266"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/249973266" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#249973266">(Aug 19 2021 at 11:40)</a>:</h4>
<p>I agree with <span class="user-mention" data-user-id="271719">@Mario Carneiro</span>, here: since allocators could always carry a map of pointer to pointer-with-original-provenance or something like that, it must be assumed that if they receive a pointer that has provenance over the whole <code>T</code>, then they can work their way around the necessary extended provenance for <code>[ headers | T ]</code> or whatnot. Then, at that point, this theoretical map ought not be instanced in practice, since it would be silly to do. Thus, whatever the approach may be, allocators must be assumed to have the power, <em>ideally "zero"-cost</em>, to retrieve back the original provenance, since they will never lend access to the <code>headers</code> to anything else.</p>



<a name="249973458"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/249973458" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#249973458">(Aug 19 2021 at 11:40)</a>:</h4>
<p>Btw, what I've mentioned is inspired by a now buried-deep-within-Discord post from <span class="user-mention" data-user-id="229913">@HeroicKatora</span>, so maybe they'd like to chime in</p>



<a name="252033428"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/252033428" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#252033428">(Sep 04 2021 at 23:20)</a>:</h4>
<p>I do agree that this pattern should be supported, but I cant follow your argument <span class="user-mention" data-user-id="232018">@Daniel Henry-Mantilla</span> . are you basically saying that because there is a convoluted way to do this, the naive way should also work? I cant see how that's a valid argument.</p>



<a name="252289526"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/252289526" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#252289526">(Sep 07 2021 at 11:32)</a>:</h4>
<p><span class="user-mention" data-user-id="120791">@RalfJ</span> that's a bit of a strawman, but I guess I did not polish my argument well enough. I stand by my "it would be silly to require allocators to do this convoluted map lookup thing", and I'd thus like to see either the formal model or the allocator API / contract be amended in a way that would allow for <code>Box::from_raw(Box::leak(…))</code> to work. Granted, my initial idea was born in a time predating custom allocators, and thus I allowed myself to consider that an allocation call could be seen as some kind of global / intrinsic-to-the-language call, to which the formal model could grant special semantics.</p>
<p>I do realize now that with custom allocators thrown into the mix, the formal model cannot accomodate to that without sacrificing provenance <em>everywhere</em>, since we are now dealing with arbitrary "user code".</p>
<p>In that regard, let me follow up on my initial idea. For starters, let's consider a new API, either through a new trait, an extra optional method on <code>Alloc</code>, or maybe an actual override of what the current <code>alloc()</code> function does. Be it as it may, I'll be calling this method <code>alloc_with_exact_provenance</code>. The name is pretty self-explanatory: the contract of this function would be to yield a pointer with, semantically, provenance over the <code>[ptr .. ptr + size]</code> byte range "only", so as to allow <code>{d,r}ealloc</code> to then take  a pointer with provenance potentially "shrunk" to that range (<em>e.g.</em>, because funnelled through <code>Box::leak()</code>).</p>
<ul>
<li>A kind of tangential approach would be for allocators to feature a boolean value (assoc constant, I'd say) that expresses whether their <code>alloc()</code> implementation has <code>with_exact_provenance</code> semantics. And, ideally, require that <code>GlobalAlloc</code> feature this behavior, so as to play well with <code>Box::leak</code>.</li>
</ul>
<p>Now, in order for this to be actually usable, we need a way for a header-using allocator implementation to be able to work off a pointer that with a(n exact) provenance that thus may not range over that header. While laundering through map lookups would be possible, it's definitely not a practical solution. What we need is some kind of simple launder functionality, but I can imagine how <code>ptr::launder()</code> would be a gigantic can of worms that I don't want to open. That being said, given that allocators are able to yield memory by chunking some gigantic buffer they "own" (which I've called <code>buf</code>), it's actually pretty easy for them to feature their own targeted laundering:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buf</span><span class="p">.</span><span class="n">offset</span><span class="p">(</span><span class="n">user_ptr_fed_to_dealloc</span><span class="p">.</span><span class="n">offset_from</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span><span class="w"> </span><span class="c1">// Laundered!!</span>
<span class="kd">let</span><span class="w"> </span><span class="n">at_header</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptr</span><span class="p">.</span><span class="n">sub</span><span class="p">(</span><span class="n">offset_to_header</span><span class="err">…</span><span class="p">);</span><span class="w"></span>
</code></pre></div>
<p>Since the allocations, in the SB model, would be (re)borrowing from <code>buf[..]</code>, by performing this operation we ought to be SB-friendly. And, in practice, I'd expect the <code>offset / offset_from</code> pair to be a no-op at runtime, except for having disabled incompatible-with-box-leak-provenance-based optimizations <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="252928650"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/252928650" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#252928650">(Sep 11 2021 at 19:01)</a>:</h4>
<blockquote>
<p>What we need is some kind of simple launder functionality, but I can imagine how ptr::launder() would be a gigantic can of worms that I don't want to open. That being said, given that allocators are able to yield memory by chunking some gigantic buffer they "own" (which I've called buf), it's actually pretty easy for them to feature their own targeted laundering</p>
</blockquote>
<p>So I think this is basically an instance of the idea that in Rust we can actually implement <code>copy_provenance</code> which combines the address of one ptr with the provenance of another. as long as the allocator keeps a ptr with the "root provenance" for the memory range it is using (assuming for simplicity its one range), it can then take the ptr passed to <code>dealloc</code> and equip it with the "root provenance" and continue.</p>



<a name="252929290"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/252929290" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#252929290">(Sep 11 2021 at 19:12)</a>:</h4>
<p>The downside of <code>copy_provenance</code> is that it is not zero-cost: you have to keep around a pointer to supply the root provenance (and pointers are not ZST even though provenance is, morally speaking). Using the wildcard provenance model for int-to-ptr conversions, one way to manufacture an appropriate provenance without any additional computationally relevant inputs is to convert the pointer to an int and back (assuming that ints don't have provenance; else substitute some other <code>clear_provenance</code> operation here). You get a wildcard provenance pointer out the end, which can be used as a root provenance because the allocator has ownership of the root provenance even if it doesn't supply any evidence of such.</p>



<a name="252929569"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/252929569" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#252929569">(Sep 11 2021 at 19:18)</a>:</h4>
<p>Actually, I think this is a good argument for having provenance ZSTs (i.e. "permissions") which can be stored separately from the pointers they are derived from. With a ZST provenance, you wouldn't need to use wildcard pointers, although if the allocator owns many regions it might still be cumbersome to pull out the right provenance for the situation</p>



<a name="253614373"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253614373" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253614373">(Sep 16 2021 at 16:59)</a>:</h4>
<p>given the many places where Rust semantics treat ZSTs as having no data (not even in the Abstract Machine), I dont think it would be a good idea to try to attach provenance to them.</p>



<a name="253623141"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253623141" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253623141">(Sep 16 2021 at 17:58)</a>:</h4>
<p>That's a surprise to me. ZSTs are often used as "proofs" / evidence for an assertion and needed to make safety arguments in some cases, so it seems premature to excise them completely from the AM</p>



<a name="253623543"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253623543" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253623543">(Sep 16 2021 at 18:00)</a>:</h4>
<p>To put it another way, I think that being able to attach provenance to ZSTs makes exactly as much sense as attaching provenance to usize values (aka pointers)</p>



<a name="253636601"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253636601" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253636601">(Sep 16 2021 at 19:24)</a>:</h4>
<p><span class="user-mention silent" data-user-id="271719">Mario Carneiro</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F/near/253623141">said</a>:</p>
<blockquote>
<p>That's a surprise to me. ZSTs are often used as "proofs" / evidence for an assertion and needed to make safety arguments in some cases, so it seems premature to excise them completely from the AM</p>
</blockquote>
<p>yeah and they do not need to have any operational meaning for that</p>



<a name="253636671"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253636671" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253636671">(Sep 16 2021 at 19:24)</a>:</h4>
<p>it is common in verification and proofs to have "ghost code" or "ghost variables" (they also come under many other names such as <br>
"phantom variables") -- extra things we add to the program that have no operational meaning but help the proof</p>



<a name="253636737"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253636737" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253636737">(Sep 16 2021 at 19:25)</a>:</h4>
<p>ZSTs are perfect for that. things dont have to have any operational meaning for them to be useful in soundness proofs. the relevant part for soundness proofs is that ZSTs are important <em>in the type system</em>, e.g. the compiler won't let you "fake" a value of a ZST. (we exploited that in GhostCell, just to name one example.)</p>



<a name="253636932"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253636932" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253636932">(Sep 16 2021 at 19:26)</a>:</h4>
<p>provenance is <em>not</em> "ghost code". provenance is completely real and physical, as far as Rust code running on the Abstract Machine is concerned. that is a big difference.</p>



<a name="253636967"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253636967" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253636967">(Sep 16 2021 at 19:26)</a>:</h4>
<p>in particular, ghost code cannot affect whether there is UB or not. provenance can.</p>



<a name="253639537"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253639537" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253639537">(Sep 16 2021 at 19:44)</a>:</h4>
<p>I'm glad you brought up ghost code, because that's how I think of this as well. The complication is that there are multiple levels here, and provenance is not ghost in the AM but is ghost in the hardware. I do think that this is a valuable category, although I can see some issues about how to make ZST provenance loads work correctly in the AM</p>



<a name="253641101"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253641101" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253641101">(Sep 16 2021 at 19:55)</a>:</h4>
<blockquote>
<p>provenance is not ghost in the AM but is ghost in the hardware</p>
</blockquote>
<p>I guess that is a way to see it but IMO it is a confusing way to put things. provenance is indeed lost in the refinement from AM to hardware, but I would not conflate that with verification ghost code. They are in pretty different categories; I already gave an example for that. (another example: people can add their own arbitrary kinds of ghost code when verifying Rust programs, but provenance must be part of the Rust spec and guarded by the Rust lang team.)</p>



<a name="253641176"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253641176" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253641176">(Sep 16 2021 at 19:56)</a>:</h4>
<p>I suppose one could imagine an AM where ZST accesses have meaning, but I think a lot of existing Rust code would be incompatible with that (like, unsafe code that assume ZSTs can be "copied"/"moved" without doing anything). So I dont think this is a reasonable choice for the Rust AM.</p>



<a name="253643272"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253643272" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253643272">(Sep 16 2021 at 20:10)</a>:</h4>
<p>Provenance ZSTs can be copied or moved without doing anything, though</p>



<a name="253643339"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253643339" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253643339">(Sep 16 2021 at 20:11)</a>:</h4>
<p>well I suppose it depends on what you mean by doing anything</p>



<a name="253643391"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253643391" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253643391">(Sep 16 2021 at 20:11)</a>:</h4>
<p>you need an existing provenance ZST to copy it</p>



<a name="253643471"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253643471" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253643471">(Sep 16 2021 at 20:12)</a>:</h4>
<p>which I think follows from the usual meaning of "copy"</p>



<a name="253643751"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253643751" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253643751">(Sep 16 2021 at 20:14)</a>:</h4>
<blockquote>
<p>I guess that is a way to see it but IMO it is a confusing way to put things. provenance is indeed lost in the refinement from AM to hardware, but I would not conflate that with verification ghost code. They are in pretty different categories; I already gave an example for that.</p>
</blockquote>
<p>I'm in agreement here. User ghost state is ghost in the AM and in the hardware. I'm saying that it is useful to have a category of things that are not ghost in the AM but are ghost in hardware; <code>black_box</code> comes to mind as another example of such</p>



<a name="253643830"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253643830" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253643830">(Sep 16 2021 at 20:14)</a>:</h4>
<p>and to be able to explicitly manipulate such objects using compiler intrinsics</p>



<a name="253643885"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253643885" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253643885">(Sep 16 2021 at 20:15)</a>:</h4>
<p><code>copy_provenance</code> is the sort of thing you would find in that category</p>



<a name="253644102"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253644102" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253644102">(Sep 16 2021 at 20:16)</a>:</h4>
<p>How would a Provenance ZST work when provenance is an actual runtime concept?</p>



<a name="253644139"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253644139" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253644139">(Sep 16 2021 at 20:17)</a>:</h4>
<p>(Miri, or a system with hardware provenance, such as CHERI)</p>



<a name="253644265"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253644265" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253644265">(Sep 16 2021 at 20:17)</a>:</h4>
<p><span class="user-mention" data-user-id="271719">@Mario Carneiro</span> as a concrete example, <code>Vec&lt;()&gt;</code> will AFAIK degenerate to basically a usize. there is code that outright skips doing anything other than updating the vector length for some operations. that would all be <em>wrong</em> if the abstract machine said ZSTs can have provenance.</p>



<a name="253644268"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253644268" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253644268">(Sep 16 2021 at 20:17)</a>:</h4>
<p>It would be a value you can store in a ZST field, which takes up space in the interpreter and is manipulated with intrinsics same as with SB provenance today</p>



<a name="253644347"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253644347" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253644347">(Sep 16 2021 at 20:18)</a>:</h4>
<p>that is the sense in which we currently have code that copies/moves ZSTs by not doing anything</p>



<a name="253644440"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253644440" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253644440">(Sep 16 2021 at 20:19)</a>:</h4>
<p>logically, we prove that the ZST returned from pop() satisfies the safety invariant of its type. but the "actual data" (there is none, its a ZST) is entirely unrelated to what was added to the vector previously.</p>



<a name="253644610"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253644610" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253644610">(Sep 16 2021 at 20:20)</a>:</h4>
<p>in other words, code like Vec exploits the theorem that "all values of ZST type are equal", that "if one YST value satisifies the safety invariant then they all do" (this is a separation logic thing, you still cant duplicate the safety invariant, but you can move it from one instance of a ZST to another at will)</p>



<a name="253644647"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253644647" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253644647">(Sep 16 2021 at 20:20)</a>:</h4>
<p>your proposal breaks all of that instantly. I dont think that is a reasonable choice for Rust.</p>



<a name="253644675"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253644675" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253644675">(Sep 16 2021 at 20:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="271719">Mario Carneiro</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F/near/253644268">said</a>:</p>
<blockquote>
<p>It would be a value you can store in a ZST field, which takes up space in the interpreter and is manipulated with intrinsics same as with SB provenance today</p>
</blockquote>
<p>That at most only answers for miri (although it's dubious whether it does: doesn't miri require at least a <code>Byte</code> to store a pointer value). This wouldn't answer for hardware provenance models.</p>



<a name="253644706"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253644706" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253644706">(Sep 16 2021 at 20:20)</a>:</h4>
<p>leaving aside the fact that I dont think you even gave a problem statement for why you want to break all that code -- what problem does that solve?^^</p>



<a name="253644766"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253644766" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253644766">(Sep 16 2021 at 20:21)</a>:</h4>
<p><span class="user-mention" data-user-id="120791">@RalfJ</span> How could you exploit that to get (UB seems to be the wrong word here, since the AM defines UB) counterintuitive behavior from <code>Vec::pop</code>?</p>



<a name="253644772"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253644772" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253644772">(Sep 16 2021 at 20:21)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F/near/253644675">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="271719">Mario Carneiro</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F/near/253644268">said</a>:</p>
<blockquote>
<p>It would be a value you can store in a ZST field, which takes up space in the interpreter and is manipulated with intrinsics same as with SB provenance today</p>
</blockquote>
<p>That at most only answers for miri (although it's dubious whether it does: doesn't miri require at least a <code>Byte</code> to store a pointer value). This wouldn't answer for hardware provenance models.</p>
</blockquote>
<p>it doesnt answer anything for miri; provenance is attached with data and there is no data for a ZST</p>



<a name="253644957"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253644957" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253644957">(Sep 16 2021 at 20:22)</a>:</h4>
<p>let's say that <code>Vec::pop</code> on a provenance ZST always returns wildcard provenance. What goes wrong?</p>



<a name="253644977"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253644977" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253644977">(Sep 16 2021 at 20:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="271719">Mario Carneiro</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F/near/253644766">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> How could you exploit that to get (UB seems to be the wrong word here, since the AM defines UB) counterintuitive behavior from <code>Vec::pop</code>?</p>
</blockquote>
<p>there is no counterintuitive behavior in the rust AM. but it is entirely broken in your weird "AM where ZST has provnenace". well you havent actually defined that AM and I think it is very hard to do so (a lot of ambiguity since there can be arbitrarily many ZST stored at the same address and which one does an <code>&amp;mut ZST</code> even refer to) so I have to be creative on your behalf here...</p>



<a name="253645032"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253645032" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253645032">(Sep 16 2021 at 20:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="271719">Mario Carneiro</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F/near/253644957">said</a>:</p>
<blockquote>
<p>let's say that <code>Vec::pop</code> on a provenance ZST always returns wildcard provenance. What goes wrong?</p>
</blockquote>
<p>uh, now you broke the contract that push(x) followed by let x = pop() means we got the same data back</p>



<a name="253645039"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253645039" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253645039">(Sep 16 2021 at 20:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="271719">Mario Carneiro</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F/near/253644957">said</a>:</p>
<blockquote>
<p>let's say that <code>Vec::pop</code> on a provenance ZST always returns wildcard provenance. What goes wrong?</p>
</blockquote>
<p><code>Vec</code> is now an unbound laundering tool.</p>



<a name="253645054"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253645054" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253645054">(Sep 16 2021 at 20:23)</a>:</h4>
<p>thats clearly not acceptable in the slightest^^</p>



<a name="253645073"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253645073" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253645073">(Sep 16 2021 at 20:23)</a>:</h4>
<p>Provenance is now destoryed entirely.</p>



<a name="253645099"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253645099" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253645099">(Sep 16 2021 at 20:23)</a>:</h4>
<p>there are lots of other things that destroy provenance, like casting thru usize</p>



<a name="253645188"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253645188" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253645188">(Sep 16 2021 at 20:24)</a>:</h4>
<p>no, not a lot. just casting through usize.</p>



<a name="253645189"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253645189" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253645189">(Sep 16 2021 at 20:24)</a>:</h4>
<p>I can't tell whether this is actually a problem here</p>



<a name="253645220"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253645220" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253645220">(Sep 16 2021 at 20:24)</a>:</h4>
<p>uh, you broke vec to be useless for such data. yes there is a problem.^^</p>



<a name="253645329"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253645329" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253645329">(Sep 16 2021 at 20:25)</a>:</h4>
<p>also Im afraid I have to stop here, got some other stuff to catch up on... I think I stated my case, you dont get to break fundamental promises of data structures like Vec. Vec will currently never lose provenance for you. <em>no</em> data structure will lose provenance for you. if it does, it needs to document that clearly and it would probable be a bad bug.</p>



<a name="253645336"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253645336" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253645336">(Sep 16 2021 at 20:25)</a>:</h4>
<p>You asked what the advantage of provenance ZSTs would be. One would be that you can split a pointer into a usize and a provenance and manipulate and store them separately</p>



<a name="253645364"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253645364" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253645364">(Sep 16 2021 at 20:25)</a>:</h4>
<p>You've also broken any implementation that actually maintains provenance as actual program state.</p>



<a name="253645369"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253645369" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253645369">(Sep 16 2021 at 20:25)</a>:</h4>
<p>the example with Vec shows that you at least can't just store a vec of provenance ZSTs</p>



<a name="253645529"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253645529" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253645529">(Sep 16 2021 at 20:26)</a>:</h4>
<p>(Except maybe one that works in an interpreter off of an object-based model)</p>



<a name="253645576"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253645576" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253645576">(Sep 16 2021 at 20:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="271719">Mario Carneiro</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F/near/253645336">said</a>:</p>
<blockquote>
<p>You asked what the advantage of provenance ZSTs would be. One would be that you can split a pointer into a usize and a provenance and manipulate and store them separately</p>
</blockquote>
<p>you seem to think of provenance too much as ghost state. so your intuition says, ZSTs are ghost, provenancen is ghost, surely we can attach provenance to ZST. but your intuition is wrong, provenance is <em>not</em> ghost state (while ZST are). so this just doesnt go together.<br>
IOW, this is not a problem statement, its an XY problem.</p>



<a name="253645650"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253645650" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253645650">(Sep 16 2021 at 20:27)</a>:</h4>
<p>I find this interesting, though, because C always had this weird (to me) restriction on not having types of zero size, and Rust seemingly fixed that, but it turns out now there is a restriction, and if you want to store AM data then it has to be associated with actual hardware bytes</p>



<a name="253645766"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253645766" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253645766">(Sep 16 2021 at 20:28)</a>:</h4>
<p>in separation logic style reasoning those two are entirely orthogonal</p>



<a name="253646107"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253646107" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253646107">(Sep 16 2021 at 20:30)</a>:</h4>
<blockquote>
<p>you seem to think of provenance too much as ghost state. so your intuition says, ZSTs are ghost, provenancen is ghost, surely we can attach provenance to ZST. but your intuition is wrong, provenance is not ghost state (while ZST are). so this just doesnt go together.</p>
</blockquote>
<p>The descriptor "ZST" just means there are no hardware bytes involved. It's not ghost state from the AM's perspective, like you say, but there aren't enough words to describe these things. I'm talking about AM state that has no hardware bytes tied to it</p>



<a name="253648058"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253648058" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253648058">(Sep 16 2021 at 20:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="271719">Mario Carneiro</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F/near/253645766">said</a>:</p>
<blockquote>
<p>in separation logic style reasoning those two are entirely orthogonal</p>
</blockquote>
<p>in Iris they are because iris has very powerful purely logical ghost state. in most prior separation logics "ghost variables" had to be actually added to the program so this was not orthogonal at all.</p>



<a name="253648309"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253648309" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253648309">(Sep 16 2021 at 20:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="271719">Mario Carneiro</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F/near/253645650">said</a>:</p>
<blockquote>
<p>I find this interesting, though, because C always had this weird (to me) restriction on not having types of zero size, and Rust seemingly fixed that, but it turns out now there is a restriction, and if you want to store AM data then it has to be associated with actual hardware bytes</p>
</blockquote>
<p>basically, size 0 means no data in the AM. I think everything else would be expected, size 0 indicates the absence of data so it would be rather incoherent if there could be any data there.</p>



<a name="253648700"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253648700" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253648700">(Sep 16 2021 at 20:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="271719">Mario Carneiro</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F/near/253646107">said</a>:</p>
<blockquote>
<blockquote>
<p>you seem to think of provenance too much as ghost state. so your intuition says, ZSTs are ghost, provenancen is ghost, surely we can attach provenance to ZST. but your intuition is wrong, provenance is not ghost state (while ZST are). so this just doesnt go together.</p>
</blockquote>
<p>The descriptor "ZST" just means there are no hardware bytes involved. It's not ghost state from the AM's perspective, like you say, but there aren't enough words to describe these things. I'm talking about AM state that has no hardware bytes tied to it</p>
</blockquote>
<p>"AM state that has no hardware bytes attached to it" is easy, we can just have <code>ghost static</code> variables that are guarnateed to be erased, or something like that. but you additionally want this AM state to live in the same memory space as actual bytes and presumably even have structs that mix both kinds of data -- that immediately raises at least 3 questions in my head for what several operations like ptr deref and ptr arithmetic even <em>mean</em> now. you are proposing a completely new kind of ghost state, the likes of which I have never seen before. In a high-level language with a strong object memory model (something tree-like), this would fly; in Rust where memory is observably byte-oriented (and the addresses of those bytes are physically manifest, we have very little AM wiggle room here), I dont think it does. maybe try defining it precisely in a toy language in coq and I think you will see the difficulty.</p>



<a name="253653419"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253653419" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253653419">(Sep 16 2021 at 21:23)</a>:</h4>
<blockquote>
<p>"AM state that has no hardware bytes attached to it" is easy, we can just have ghost static variables that are guarnateed to be erased, or something like that. </p>
</blockquote>
<p>That also sounds great. It is limiting though, since you can only have a fixed number of static variables, so you probably won't have enough for all the pointers you are dealing with.</p>
<blockquote>
<p>in Rust where memory is observably byte-oriented (and the addresses of those bytes are physically manifest, we have very little AM wiggle room here), I dont think it does.</p>
</blockquote>
<p>I think you are right; it is possible to make this work for local variables like in the "permissions" IR we talked about before (where loading a pointer gives you two vregs, one for the value and one for the provenance), but once you stick them in memory it becomes difficult to address them and keep them organized, unless you have some entirely separate "memory" to stash this data (like a tree). Sticking these things between the bytes is problematic since the byte address is no longer sufficient to distinguish these values.</p>



<a name="253653878"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253653878" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253653878">(Sep 16 2021 at 21:27)</a>:</h4>
<blockquote>
<p>basically, size 0 means no data in the AM. I think everything else would be strange, size 0 indicates the absence of data so it would be rather incoherent if there could be any data there.</p>
</blockquote>
<p>Well, I could just as well say "size 1 means there are 256 possible values" but we both know that's not true; AM bytes can seemingly hold an infinite quantity of information, so I don't think AM data that lives between / around / somehow stashed independently of the bytes in hardware memory is a crazy idea. But I acknowledge that retrofitting this concept onto "Rust ZST" requires some significant changes and is probably not feasible.</p>



<a name="253654375"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253654375" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253654375">(Sep 16 2021 at 21:31)</a>:</h4>
<blockquote>
<p>maybe try defining it precisely in a toy language in coq and I think you will see the difficulty.</p>
</blockquote>
<p>Well, this comes in part from my experiences doing exactly this in the language I'm developing. But there are lots of other differences too, so it's not quite as straightforward as just ZST provenance objects.</p>



<a name="253671969"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253671969" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253671969">(Sep 17 2021 at 00:35)</a>:</h4>
<blockquote>
<p>Well, I could just as well say "size 1 means there are 256 possible values" but we both know that's not true;</p>
</blockquote>
<p>Indeed it is not so what does that have to do with my statement?</p>



<a name="253672026"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253672026" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253672026">(Sep 17 2021 at 00:36)</a>:</h4>
<p>The fact that there is only a single list of length 0 is true <em>no matter the element type of the list</em>. That makes my statement very different from yours.</p>



<a name="253672117"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253672117" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253672117">(Sep 17 2021 at 00:37)</a>:</h4>
<p>I am "just" stretching the concept of a byte by making it hold more data; you are stretching (breaking?) the entire concept of memory consisting of bytes, and allocations being described by lists of bytes. That is going way further, I would say. I strongly think we should maintain the property that "(abstract) bytes" are the 'atoms' of memory in Rust, and that if you copy around all the bytes from A to B you copied all there is to copy. A <em>lot</em> of code relies on that.</p>



<a name="253672358"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%60Box%3A%3Aleak%60%20assert%20a%20reference%20never%20gets%20deallocated%3F/near/253672358" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.60Box.3A.3Aleak.60.20assert.20a.20reference.20never.20gets.20deallocated.3F.html#253672358">(Sep 17 2021 at 00:40)</a>:</h4>
<p>My idea for how to spec a MIR semantics leaves the memory model abstract, but it <em>does</em> incorporate the assumption that memory is byte-oriented. IOW, one can do all sorts of crazy provenance stuff with <a href="https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/memory-interface.md">this memory API</a>, but even that API is "too close to the hardware" to allow 'stuff between the bytes'.</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>