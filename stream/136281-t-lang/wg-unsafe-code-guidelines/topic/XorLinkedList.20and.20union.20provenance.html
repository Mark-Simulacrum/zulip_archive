<html>
<head><meta charset="utf-8"><title>XorLinkedList and union provenance · t-lang/wg-unsafe-code-guidelines · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/index.html">t-lang/wg-unsafe-code-guidelines</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html">XorLinkedList and union provenance</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="276119879"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276119879" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jacob Lifshay <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276119879">(Mar 21 2022 at 22:02)</a>:</h4>
<p>i think making union provenance be based on each byte of a pointer having separate provenance isn't the best idea---we should just have provenance of the whole pointer be the union and say the byte's provenance is just that of the whole pointer</p>



<a name="276120159"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276120159" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jacob Lifshay <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276120159">(Mar 21 2022 at 22:05)</a>:</h4>
<p>you can extend xorlists to a multiple dimensional grid, where each grid cell has just one pointer-sized field that is the xor of all pointers to adjacent grid cells...you'd need <code>2*N</code> pointers unioned where <code>N</code> is the number of dimensions</p>



<a name="276120161"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276120161" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276120161">(Mar 21 2022 at 22:05)</a>:</h4>
<p>New topic time!</p>



<a name="276120199"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276120199" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jacob Lifshay <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276120199">(Mar 21 2022 at 22:05)</a>:</h4>
<p>for when xorlist isn't cursed enough :)</p>



<a name="276120214"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276120214" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276120214">(Mar 21 2022 at 22:05)</a>:</h4>
<p>I mean, if you want to be absurd you could do some sort of crazy mixing scheme and do it bytewise</p>



<a name="276120642"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276120642" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jacob Lifshay <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276120642">(Mar 21 2022 at 22:10)</a>:</h4>
<p>well...if you want to go extra crazy, you could use <code>GF(2^64)</code> multiplication/division instead of xor, that would allow the combined pointer to be <code>NonZeroU64</code> :P</p>



<a name="276120714"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276120714" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jacob Lifshay <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276120714">(Mar 21 2022 at 22:11)</a>:</h4>
<p>Galois Fields to the rescue for all your evil pointer shenanigans!</p>



<a name="276122366"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276122366" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276122366">(Mar 21 2022 at 22:32)</a>:</h4>
<p><span class="user-mention silent" data-user-id="229517">Jacob Lifshay</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance/near/276120159">said</a>:</p>
<blockquote>
<p>you can extend xorlists to a multiple dimensional grid, where each grid cell has just one pointer-sized field that is the xor of all pointers to adjacent grid cells...you'd need <code>2*N</code> pointers unioned where <code>N</code> is the number of dimensions</p>
</blockquote>
<p>I don't see how that would work; the XOR trick only works if you have all the other pointers apart from the one you want. So that would only work if you have all the adjacent cell pointers except one.</p>



<a name="276122443"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276122443" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276122443">(Mar 21 2022 at 22:33)</a>:</h4>
<p>It'd be possible in a tree, but not a graph.</p>



<a name="276122512"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276122512" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Gankra <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276122512">(Mar 21 2022 at 22:34)</a>:</h4>
<p><a href="https://twitter.com/brooksdavis/status/1506036121020510209">https://twitter.com/brooksdavis/status/1506036121020510209</a></p>
<div class="inline-preview-twitter"><div class="twitter-tweet"><a href="https://twitter.com/brooksdavis/status/1506036121020510209"><img class="twitter-avatar" src="https://uploads.zulipusercontent.net/4db634e8b70331ac638709072b343cbf84e230fb/68747470733a2f2f7062732e7477696d672e636f6d2f70726f66696c655f696d616765732f3533353039363230313637303937393538342f41563657577574765f6e6f726d616c2e6a706567"></a><p><a href="https://twitter.com/Gankra_">@Gankra_</a> <a href="https://twitter.com/arichardson___">@arichardson___</a> <a href="https://twitter.com/MSpondee">@MSpondee</a> We know they exist, but I don’t think we’ve seen one in software we’ve cared about. I did find some use of xor to hide pointers from a leak checker in some Open Solaris code as well as xor for constant time conditionals in OpenSSL.</p><span>- brooksdavis (@brooksdavis)</span></div></div>



<a name="276123062"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276123062" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276123062">(Mar 21 2022 at 22:41)</a>:</h4>
<p>Hypothetically, would union-provenance that requires an explicit declaration (e.g. "we don't do union provenance except when you explicitly declare a pointer as subject to it") be sufficient to make XOR lists work? Is this in the category of "we don't know how to do this", or is it in the category of "we know how but it'd suck to do it for every pointer by default"?</p>



<a name="276123163"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276123163" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276123163">(Mar 21 2022 at 22:42)</a>:</h4>
<blockquote>
<p>We know they exist, but I don’t think we’ve seen one in software we’ve cared about. I did find some use of xor to hide pointers from a leak checker in some Open Solaris code</p>
</blockquote>
<p>lmao.</p>



<a name="276123167"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276123167" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276123167">(Mar 21 2022 at 22:43)</a>:</h4>
<p>I mean leak checkers are annoying af when they get it wrong so... &lt;_&lt;</p>



<a name="276123215"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276123215" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276123215">(Mar 21 2022 at 22:43)</a>:</h4>
<p>that seems like it would be better done as "we have bitops on pointers that work via non-escaping ptrtoint or new compiler builtin ops on pointers"</p>



<a name="276123288"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276123288" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276123288">(Mar 21 2022 at 22:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="143798">Talchas</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276123215">said</a>:</p>
<blockquote>
<p>that seems like it would be better done as "we have bitops on pointers that work via non-escaping ptrtoint or new compiler builtin ops on pointers"</p>
</blockquote>
<p>So, less <code>p1.addr() ^ p2.addr()</code>, more <code>p1.combine_pointers_funkily(p2)</code>?</p>



<a name="276123341"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276123341" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276123341">(Mar 21 2022 at 22:45)</a>:</h4>
<p>no I mean "<code>as</code> is still some PNVI+union escape, but you don't need to use <code>as</code> for most of the sane stuff"</p>



<a name="276123438"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276123438" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276123438">(Mar 21 2022 at 22:46)</a>:</h4>
<p>because *const T and AtomicPtr have the relevant ops built in, and maybe even good helpers for them</p>



<a name="276123775"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276123775" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276123775">(Mar 21 2022 at 22:51)</a>:</h4>
<p><span class="user-mention silent" data-user-id="239881">Josh Triplett</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance/near/276123062">said</a>:</p>
<blockquote>
<p>Hypothetically, would union-provenance that requires an explicit declaration (e.g. "we don't do union provenance except when you explicitly declare a pointer as subject to it") be sufficient to make XOR lists work? Is this in the category of "we don't know how to do this", or is it in the category of "we know how but it'd suck to do it for every pointer by default"?</p>
</blockquote>
<p>Well, there is always the fallback option of doing the full union provenance PNVI-like thing (ie int-&gt;ptr casts get the provenance of some tag, and as long as there is at least one choice that leads to DB the program behavior is defined). But that's annoying to check in MIRI at the very least, and <em>might</em> have other problems.</p>
<p>As far as know there is no completely specified alternative to this (maybe I just didn't read that conversation though). I see a number of ways to try and work towards specifying such a thing, but I definitely can't claim to understand the consequences of each</p>



<a name="276124294"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276124294" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Gankra <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276124294">(Mar 21 2022 at 22:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="239881">Josh Triplett</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance/near/276123288">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="143798">Talchas</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276123215">said</a>:</p>
<blockquote>
<p>that seems like it would be better done as "we have bitops on pointers that work via non-escaping ptrtoint or new compiler builtin ops on pointers"</p>
</blockquote>
<p>So, less <code>p1.addr() ^ p2.addr()</code>, more <code>p1.combine_pointers_funkily(p2)</code>?</p>
</blockquote>
<p>i think CHERI fundamentally cannot support this because it fucks with way too high bits</p>



<a name="276124669"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276124669" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Gankra <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276124669">(Mar 21 2022 at 23:01)</a>:</h4>
<p>oh actually they have sections dedicated to this in 3.9: <a href="https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-949.pdf">https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-949.pdf</a></p>



<a name="276124685"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276124685" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Gankra <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276124685">(Mar 21 2022 at 23:01)</a>:</h4>
<blockquote>
<p>In an architecture that uses integer pointers, it is possible to implement a doubly-linked<br>
list using only one pointer by using an exclusive-OR between the previous list element<br>
pointer and the next pointer [212]. This optimization is not compatible with CHERI<br>
capabilities, as the XOR operation would make the pointer be out-of-bounds and therefore<br>
non-dereferenceable. However, if one were to use capabilities with very large bounds, i.e.<br>
ones that span all list elements, this optimization would still be possible. Alternatively, the<br>
list could be implemented using virtual addresses and prior to dereferencing, a capability<br>
could be derived from a large ambient one. However, we do not believe it is a good idea<br>
as it prevents enforcing spatial safety and is therefore not possible by default.</p>
</blockquote>



<a name="276124788"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276124788" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Gankra <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276124788">(Mar 21 2022 at 23:02)</a>:</h4>
<p>this basically amounts to "use an arena" but also with the extremely cursed version of "what if your whole program was an arena <em>wink</em>"</p>



<a name="276124851"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276124851" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276124851">(Mar 21 2022 at 23:03)</a>:</h4>
<p>yeah it can work with a DDC but a DDC ("default data capability", i.e. "regular pointers that are actually addresses in a big internally-unprotected region") is a cop-out on CHERI anyway</p>



<a name="276124996"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276124996" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276124996">(Mar 21 2022 at 23:06)</a>:</h4>
<p>tho it does match wasm linear memory, so it could be a hardware optimization over manually addressing a wasm linear memory as a large array :P</p>



<a name="276125088"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276125088" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276125088">(Mar 21 2022 at 23:06)</a>:</h4>
<p>(but I think in practice, DDC is only used to run software that isn't portable wrt large pointers, or even as a compat mode for existing binaries - not really sure about that though)</p>



<a name="276126529"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276126529" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276126529">(Mar 21 2022 at 23:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="119009">eddyb</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance/near/276124851">said</a>:</p>
<blockquote>
<p>yeah it can work with a DDC but a DDC ("default data capability", i.e. "regular pointers that are actually addresses in a big internally-unprotected region") is a cop-out on CHERI anyway</p>
</blockquote>
<p>It is, but at the same time, the fact that that <em>exists</em> provides a good bridge for existing software.</p>



<a name="276126547"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276126547" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jacob Lifshay <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276126547">(Mar 21 2022 at 23:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="239881">Josh Triplett</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance/near/276122366">said</a>:</p>
<blockquote>
<p>I don't see how that would work; the XOR trick only works if you have all the other pointers apart from the one you want. So that would only work if you have all the adjacent cell pointers except one.</p>
</blockquote>
<p>ok, yeah...i was thinking you could move from one grid cell to another, but i forgot that you'd need the pointers to all adjacent grid cells around the new cell in the directions your moving away from.</p>



<a name="276126571"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276126571" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276126571">(Mar 21 2022 at 23:22)</a>:</h4>
<p>And in particular, the fact that they <em>can</em> operate in that mode means we could support both modes, and treat this as a portability issue.</p>



<a name="276126689"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276126689" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276126689">(Mar 21 2022 at 23:24)</a>:</h4>
<p>now I <em>really</em> wish I had a Morello board so I can see exactly what it takes in practice. presumably such a mode would just work already, and not be very interesting to Rust</p>



<a name="276126701"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276126701" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276126701">(Mar 21 2022 at 23:24)</a>:</h4>
<p>So, for instance, if we have <em>some</em> mechanism that allows XOR lists, we can compile programs that use that mechanism to use DDC, and programs that don't (the common case) to not.</p>



<a name="276126723"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276126723" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276126723">(Mar 21 2022 at 23:24)</a>:</h4>
<p>"this should be possible", not "this should be possible without tradeoffs". :)</p>



<a name="276126774"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276126774" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276126774">(Mar 21 2022 at 23:25)</a>:</h4>
<p>you can also emulate it, to be clear. it's almost like compiling to wasm64 then AOT-ing that, heh. hardware support is only needed as an optimization</p>



<a name="276126859"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276126859" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276126859">(Mar 21 2022 at 23:26)</a>:</h4>
<p>Is this a program-wide choice, or is it possible to have a whole-address-space capability as well as more constrained capabilities?</p>



<a name="276126894"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276126894" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276126894">(Mar 21 2022 at 23:27)</a>:</h4>
<p>If the latter, that seems like exactly what we'd want to use, and then there could be some mechanism to opt out of (or opt into) supporting that, via whatever the portability lint ends up being spelled like.</p>



<a name="276127048"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276127048" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276127048">(Mar 21 2022 at 23:29)</a>:</h4>
<p>If an architecture supports both "capability-aware" and "capability-unaware" load and store instructions, then the Default Data Capability is in effect the actual capability used by the latter set.</p>



<a name="276127136"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276127136" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276127136">(Mar 21 2022 at 23:30)</a>:</h4>
<p>hmm, so that's a more subtle question than just the basic "do OSes ported to this have a per-process/thread flag for this"...</p>
<p>CHERI is flexible enough that even the kernel-userspace distinction is kind of vestigial, heh<br>
(that is, you could implement an OS where none of the execution state can reach kernel memory except when you call vDSO functions they atomically transition to an execution state that is running kernel code and can see kernel memory)</p>
<p>I think some of the things they've been able to demonstrate include several protection domains <em>in one process</em></p>



<a name="276127147"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276127147" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276127147">(Mar 21 2022 at 23:30)</a>:</h4>
<blockquote>
<p>Hybrid-capability code implements pointer types using integers by default, interpreted with<br>
respect to a global default data capability (DDC) able to address code, globals, heap, and<br>
stack(s). When special language-level annotations are added to program source, specific<br>
pointers or pointer types are instead implemented using capabilities, offering additional<br>
protection. Hybrid-capability code is primarily for use in specialized environments: the<br>
boot loader, early kernel startup, and in code bridging communications between legacy<br>
code and pure-capability code (such as ABI compatibility layers).</p>
</blockquote>



<a name="276127169"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276127169" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276127169">(Mar 21 2022 at 23:31)</a>:</h4>
<p>it's again a bit like wasm64: you can have as many VMs as you want in a process, and AOT them</p>



<a name="276127200"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276127200" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276127200">(Mar 21 2022 at 23:31)</a>:</h4>
<p>I think their demonstration was taking specific C libraries and wrapping them so that they existed almost as an isolated subprocess/wasm-like-VM within the actual process</p>



<a name="276127251"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276127251" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276127251">(Mar 21 2022 at 23:32)</a>:</h4>
<p>but yeah I guess most of the concerns are around ABI</p>



<a name="276127416"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276127416" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276127416">(Mar 21 2022 at 23:35)</a>:</h4>
<p>and yes, essentially for Rust this means that e.g. a Morello target might look less like <code>morello-unknown-freebsd</code> and more like <code>aarch64-unknown-freebsd-morello</code></p>



<a name="276127805"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276127805" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276127805">(Mar 21 2022 at 23:40)</a>:</h4>
<blockquote>
<h3>CheriBSD kernel</h3>
<p>An extended version of the FreeBSD operating system whose kernel can be<br>
compiled either as hybrid-capability or pure-capability code, offering different degrees<br>
of kernel memory protection. The CheriBSD kernel is also able to host legacy, hybrid-<br>
capability, and pure-capability userspace environments. The pure-capability process en-<br>
vironment is known as CheriABI, and is a new OS ABI based on ubiquitous userspace use<br>
of architectural capabilities. CheriBSD is also able to offer optional temporal memory<br>
safety for (non-stack) allocations in pure-capability userspace applications. In addition,<br>
CheriBSD provides a libcheri intra-process compartmentalization framework, which<br>
allows library-like components to operate in compartments within a larger application<br>
process.</p>
<h3>CheriBSD hybrid userspace</h3>
<p>An extended version of the FreeBSD userspace that is mini-<br>
mally modified to support hybrid-capability code execution, including modest additions<br>
to the C runtime (CRT) and system libraries (including libc).</p>
<h3>CheriBSD CheriABI userspace</h3>
<p>An extended version of the FreeBSD userspace that supports<br>
pure-capability execution, with modest further extensions.</p>
<h3>CheriBSD applications</h3>
<p>A set of extended applications able to operate in the CheriABI pro-<br>
cess environment, including integrated FreeBSD programs such as OpenSSH, and also<br>
third-party applications such as Apple’s WebKit and the PostgreSQL database. These all<br>
operate with full spatial, referential, and temporal memory safety.</p>
</blockquote>



<a name="276127953"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276127953" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276127953">(Mar 21 2022 at 23:42)</a>:</h4>
<blockquote>
<p>In addition, CheriBSD provides a libcheri intra-process compartmentalization framework, which allows library-like components to operate in compartments within a larger application process.</p>
</blockquote>
<p>oh that's the thing I was referencing, nice</p>



<a name="276127995"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276127995" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276127995">(Mar 21 2022 at 23:43)</a>:</h4>
<blockquote>
<p>CheriBSD is also able to offer optional temporal memory safety for (non-stack) allocations in pure-capability userspace applications.</p>
</blockquote>
<p>huh, how does that work, "scan all userspace memory before allocation reuse"?</p>



<a name="276128074"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276128074" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276128074">(Mar 21 2022 at 23:44)</a>:</h4>
<p>idk.</p>



<a name="276128237"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276128237" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276128237">(Mar 21 2022 at 23:46)</a>:</h4>
<p>I mean, I suspect DDC is like "you can run 32-bit code with a 64-bit kernel... if you have an entire 32-bit copy of the userspace libraries"</p>



<a name="276128264"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276128264" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276128264">(Mar 21 2022 at 23:47)</a>:</h4>
<p>Soooorta.</p>



<a name="276128356"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276128356" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276128356">(Mar 21 2022 at 23:48)</a>:</h4>
<p>code can actually run using the full hybrid of both.</p>



<a name="276128651"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276128651" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276128651">(Mar 21 2022 at 23:52)</a>:</h4>
<p>I mean, if you _want_ to go to the land of __near and __far for the sake of not building a library twice, or more likely a lot of glue bits to convert a codebase more slowly</p>



<a name="276128673"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276128673" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276128673">(Mar 21 2022 at 23:53)</a>:</h4>
<p>Oh I meant on CheriBSD.</p>



<a name="276131332"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276131332" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Gankra <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276131332">(Mar 22 2022 at 00:34)</a>:</h4>
<p><a href="https://twitter.com/arichardson___/status/1506041671670284295">https://twitter.com/arichardson___/status/1506041671670284295</a></p>
<div class="inline-preview-twitter"><div class="twitter-tweet"><a href="https://twitter.com/arichardson___/status/1506041671670284295"><img class="twitter-avatar" src="https://uploads.zulipusercontent.net/01d2ec0d00cc478291d0d76be7347c373bcf1834/68747470733a2f2f7062732e7477696d672e636f6d2f70726f66696c655f696d616765732f313530363032363830303933333232303335342f66315f7450684a4c5f6e6f726d616c2e706e67"></a><p><a href="https://twitter.com/Gankra_">@Gankra_</a> <a href="https://twitter.com/brooksdavis">@brooksdavis</a> <a href="https://twitter.com/workingjubilee">@workingjubilee</a> <a href="https://twitter.com/MSpondee">@MSpondee</a> <a href="https://twitter.com/clarfonthey">@clarfonthey</a> I believe the last time we gathered those statistics was running the full FreeBSD testsuite using QEMU to log the out-of-bounds pointers: 155214 were out-of-bounds by more than one byte. 1205 pointed past the end and 81% were at most sizeof(void*) beyond
the bounds.</p><span>- Alex Richardson (@arichardson___)</span></div></div>



<a name="276385607"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276385607" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276385607">(Mar 23 2022 at 19:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="229517">Jacob Lifshay</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance/near/276126547">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="239881">Josh Triplett</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance/near/276122366">said</a>:</p>
<blockquote>
<p>I don't see how that would work; the XOR trick only works if you have all the other pointers apart from the one you want. So that would only work if you have all the adjacent cell pointers except one.</p>
</blockquote>
<p>ok, yeah...i was thinking you could move from one grid cell to another, but i forgot that you'd need the pointers to all adjacent grid cells around the new cell in the directions your moving away from.</p>
</blockquote>
<p>The principle of XOR lists works on grids too, but the entropy accounting says you need 2^d-1 xor-pointer-things per node, so <code>3 * size_of::&lt;*mut Node&gt;</code> space per node for a square grid. For example if you need to store pointers <code>a,b,c,d</code> you would keep the values <code>a^b, a^c, a^d</code> and if you have <code>a</code> you can xor it to get any of the others and if you have <code>b</code> then you can xor it with <code>a^b</code> to get <code>a</code> and then <code>a^c</code> or <code>a^d</code> to get the others</p>



<a name="276386175"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276386175" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276386175">(Mar 23 2022 at 19:16)</a>:</h4>
<p>Another variation would store only two pointer values per node in a square grid, say top^bottom and left^right. You could use this to do a horizontal or vertical sweep of the grid given the value across a whole frontier, in addition to diagonal sweeps</p>



<a name="276387329"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276387329" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276387329">(Mar 23 2022 at 19:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="271719">Mario Carneiro</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance/near/276385607">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="229517">Jacob Lifshay</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance/near/276126547">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="239881">Josh Triplett</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance/near/276122366">said</a>:</p>
<blockquote>
<p>I don't see how that would work; the XOR trick only works if you have all the other pointers apart from the one you want. So that would only work if you have all the adjacent cell pointers except one.</p>
</blockquote>
<p>ok, yeah...i was thinking you could move from one grid cell to another, but i forgot that you'd need the pointers to all adjacent grid cells around the new cell in the directions your moving away from.</p>
</blockquote>
<p>The principle of XOR lists works on grids too, but the entropy accounting says you need 2^d-1 xor-pointer-things per node, so <code>3 * size_of::&lt;*mut Node&gt;</code> space per node for a square grid. For example if you need to store pointers <code>a,b,c,d</code> you would keep the values <code>a^b, a^c, a^d</code> and if you have <code>a</code> you can xor it to get any of the others and if you have <code>b</code> then you can xor it with <code>a^b</code> to get <code>a</code> and then <code>a^c</code> or <code>a^d</code> to get the others</p>
</blockquote>
<p>Yeah, I've seen that done for trees, for parent and child pointers.</p>



<a name="276387362"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276387362" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276387362">(Mar 23 2022 at 19:25)</a>:</h4>
<p>Given the parent pointer that you got by descending, you can get any of the children.</p>



<a name="276507471"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276507471" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Alexander Richardson <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276507471">(Mar 24 2022 at 17:01)</a>:</h4>
<p><span class="user-mention silent" data-user-id="119009">eddyb</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance/near/276127995">said</a>:</p>
<blockquote>
<blockquote>
<p>CheriBSD is also able to offer optional temporal memory safety for (non-stack) allocations in pure-capability userspace applications.</p>
</blockquote>
<p>huh, how does that work, "scan all userspace memory before allocation reuse"?</p>
</blockquote>
<p>effectively yes, but with a bit of help from the MMU to avoid scanning everything. I.e. only pages that have had valid capabilities stored to since the last scan</p>



<a name="276507762"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276507762" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Alexander Richardson <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276507762">(Mar 24 2022 at 17:02)</a>:</h4>
<p><a href="https://www.cl.cam.ac.uk/research/security/ctsrd/pdfs/2020oakland-cornucopia.pdf">https://www.cl.cam.ac.uk/research/security/ctsrd/pdfs/2020oakland-cornucopia.pdf</a> for the details on that approach, although there is ongoing work to reduce those overheads further with more HW support.</p>



<a name="276508773"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276508773" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Alexander Richardson <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276508773">(Mar 24 2022 at 17:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="119009">eddyb</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance/near/276126689">said</a>:</p>
<blockquote>
<p>now I <em>really</em> wish I had a Morello board so I can see exactly what it takes in practice. presumably such a mode would just work already, and not be very interesting to Rust</p>
</blockquote>
<p>It might be possible that some of the boards at Cambridge will be made accessible to interested users for testing, but I believe it will still be a while until they are all delievered. In the mean time, it <em>should</em> be quite easy (maybe even easier) to get started on QEMU. Only downside is that it will be a bit slower than a real 2GHz+ CPU.</p>
<p>If you clone <a href="https://github.com/CTSRD-CHERI/cheribuild">https://github.com/CTSRD-CHERI/cheribuild</a>, running <code>./cheribuild.py run-morello-purecap -d</code> should build all the dependencies and give you a shell in a CheriBSD environment where all software is compiled as pure-capability CHERI. Alternatively <code>./cheribuild.py run-riscv64-purecap -d</code> will do the same just for CHERI-RISC-V</p>



<a name="276509731"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276509731" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Alexander Richardson <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276509731">(Mar 24 2022 at 17:15)</a>:</h4>
<p>regarding DDC, that mostly exists to constrain the region accessible by integer loads and stores. Additionally, you can use it to relocate data since it not only bounds checks, but also gets added to the integer load address. When running in pure-capability mode, it is set to NULL so that any integer load faults, but you can always install a valid capability there if you want. This is safe since that capability must be derived from a capability you already have access to so it can't grant any additional rights.</p>
<p>Some integer loads and stores are still available in pure capability mode, but to avoid using up too much encoding space most loads/stores are mode-dependent (Morello encodes the mode in the LSB of the PC like Thumb, RISC-V uses a bit in PCC), so you either capability registers or integer registers depending on that mode bit.</p>



<a name="276518769"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276518769" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276518769">(Mar 24 2022 at 18:14)</a>:</h4>
<p>Interesting!</p>



<a name="276732958"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276732958" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276732958">(Mar 26 2022 at 16:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="239881">Josh Triplett</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance/near/276115586">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="137587">Gankra</span> Hypothetically, if we <em>don't</em> have any backwards compatibility constraints at all, and we only have the requirement to make something <em>possible</em> without making it use the <em>same code</em> as it did before, and we're fine with requiring unsafe operations but we need to provide a well-defined non-UB way to do something, what APIs <em>would</em> we want people to use for something like an XOR linked list that stores only one pointer-sized value in each node (plus the data)?</p>
</blockquote>
<p>I'm not her but I'll give you my take on it anyway. ;) Also I'll ignore CHERI and focus on "Abstract Machine provenance".<br>
I think it would totally possible to add a few hacky things to Rust to make this work (so I disagree with everyone above who says this has to be UB everywhere except asm). Basically I would exploit that in my model of Rust, every <em>byte</em> in memory carries provenance. The ptr-sized field in the XOR list is multiple bytes in size so it can hold multiple provenances. We "just" need a more explicit way to work with that per-byte provenance. It's all super clunky with our current way of writing these APIs since provenance is awfully implicit, but it would be internally consistent.</p>



<a name="276732987"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276732987" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276732987">(Mar 26 2022 at 16:09)</a>:</h4>
<p>Sadly the proposal of thinking of <code>type Pointer = (Address, Provenance)</code> where <code>Provenance</code> is a ZST doesn't work, or I don't know how to work, because a ZST doesn't even have a single byte that could hold the provenance</p>



<a name="276733036"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276733036" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Gankra <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276733036">(Mar 26 2022 at 16:10)</a>:</h4>
<p><span aria-label="sob" class="emoji emoji-1f62d" role="img" title="sob">:sob:</span> that's a beautiful hack Ralf, you've really been corrupted by Make It Work after all these years</p>



<a name="276733056"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276733056" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276733056">(Mar 26 2022 at 16:11)</a>:</h4>
<p>it is many things but surely not "beautiful"^^</p>



<a name="276733244"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList%20and%20union%20provenance/near/276733244" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance.html#276733244">(Mar 26 2022 at 16:15)</a>:</h4>
<p>so concretely we could have a type like <code>Byte</code> that is <em>not</em> <code>u8</code>, it is more like <code>MaybeUninit&lt;u8&gt;</code> but lets just say it has to be initialized (but unlike <code>u8</code> may carry provenance). it works like a pair of a <code>u8</code> and provenance. and then you could have a weird function like</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="sd">/// Returns a byte with the value of `self` but the provenance of `other`</span>
<span class="k">fn</span> <span class="nf">with_provenance_of</span><span class="p">(</span><span class="bp">self</span>: <span class="nc">Byte</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="nc">Byte</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Byte</span><span class="w"></span>
</code></pre></div>
<p>and we could say that <code>*mut u8</code> round-trips losslessly through <code>[Byte; 8]</code> <em>where all bytes have the same provenance</em>.<br>
so given the two ptrs we want to XOR we turn them both into Byte arrays and XOR them lanewise but crucially we keep ptr1 provenance on the first 4 bytes and ptr2 provenance for the last 4 bytes. then we can later reconstruct either pointer (including its provnenace) if we are given the right things to XOR with.</p>
<p>and now I need to shower, I feel dirty...</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>