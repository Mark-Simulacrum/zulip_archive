<html>
<head><meta charset="utf-8"><title>Checking permissive provenance with SMT Â· t-lang/wg-unsafe-code-guidelines Â· Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/index.html">t-lang/wg-unsafe-code-guidelines</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html">Checking permissive provenance with SMT</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="277944913"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/277944913" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#277944913">(Apr 05 2022 at 21:19)</a>:</h4>
<p>(continuing from <a class="stream-topic" data-stream-id="136281" href="/#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Problems.20with.20PVI.20-.20What.20optimizations.20does.20it.20break.3F">#t-lang/wg-unsafe-code-guidelines &gt; Problems with PVI - What optimizations does it break?</a> )</p>
<p>Let's say we use an SMT solver. That makes everything easier to model than just SAT. Here's a sketch for a Miri-like checker.</p>
<p>Our world contains locations, which are each assigned a stack and values. Both stacks and values can mention tags. There is nondeterminism in these stacks and in the values. However, if we erase the tags out of values then they are the same in every nondeterministic world. This means that we can still execute the program deterministically â€” as long as we can figure out the erased value of every location.</p>
<h3>Defining the SMT model</h3>
<p>Let's reify the way in which the "spine" of values is always the same. We introduce a kind of "tag variables" ğ‘¡. Then a value becomes</p>
<div class="codehilite"><pre><span></span><code>ğ‘†ğ‘ğ‘ğ‘™ğ‘ğ‘Ÿ â‰œ Pointer(ğ‘™, ğ‘¡) | ğ‘§      where ğ‘§ âˆˆ â„¤
</code></pre></div>

<p>(swapping out ğ‘¡ for t).</p>
<p>Stacks and items stay the same, and contain ordinary natural-valued tags.</p>
<p>In our SMT model, we introduce</p>
<ul>
<li>for every location a tag variable ğ‘¡_ğ‘–  : â„•</li>
<li>for every location a stack variable ğ‘ ğ‘¡ğ‘ğ‘ğ‘˜_ğ‘™ : ğ‘†ğ‘¡ğ‘ğ‘ğ‘˜</li>
</ul>
<p>The scalar part of memory stays out of SMT-land, they do not get variables.</p>
<p>We write ğ‘ƒ((ğ‘¡), (ğ‘ ğ‘¡ğ‘ğ‘ğ‘˜)) for a predicate over this model.</p>
<h3>Execution</h3>
<p>At runtime, we keep</p>
<ol>
<li>The program under evaluation. (expression + call stack, I guess)</li>
<li>The set of live locations</li>
<li>For every live location, its current scalar value â€” with tags replaced by tag variables as above </li>
<li>A satisfiable SMT predicate over the model above.</li>
</ol>
<p>To execute the program, execute the following in a loop.</p>
<p>(5) Use (1) to determine which operation to evaluate next.<br>
(6) Let ğ‘ƒ be the current predicate (4).<br>
(7) Every operation takes (1,2,3), and produces new versions of (1,2,3), as well as a predicate relation ğ‘… between the old and the new model. <br>
(8) The new predicate becomes "âˆƒ (â€˜ğ‘¡), (â€˜ğ‘ ğ‘¡ğ‘ğ‘ğ‘˜): ğ‘ƒ((â€˜ğ‘¡), (â€˜ğ‘ ğ‘¡ğ‘ğ‘ğ‘˜)) âˆ§ ğ‘…((â€˜ğ‘¡), (â€˜ğ‘ ğ‘¡ğ‘ğ‘ğ‘˜), (ğ‘¡), (ğ‘ ğ‘¡ğ‘ğ‘ğ‘˜))"<br>
(9) Ask SMT to simplify the predicate. <br>
(10) Ask SMT whether if it is satisfiable. If not, then UB has happened in the previous step.</p>
<p>For int2ptr (the nondeterministic step), </p>
<h3>Example: semantics of USE-1 w.r.t. the relation in step (7)</h3>
<p>We are using a pointer value Pointer(ğ‘™, ğ‘¡_ğ‘–) .</p>
<p>The following stands for an SMT formula that gets conjuncted into the current relation.</p>
<blockquote>
<p>(1) âˆƒ (t âˆˆ â„•) : ğ‘¡_ğ‘– = t  âˆ§  â€˜ğ‘ ğ‘¡ğ‘ğ‘ğ‘˜_ğ‘™ contains a Unique(t) item</p>
<p>The "âˆƒ t" here is a tautology; we use it to clarify that Unique contains a number not a variable.</p>
<p>(2) And call the topmost such item "I". Pop everything above it. Then ğ‘ ğ‘¡ğ‘ğ‘ğ‘˜_ğ‘™ must equal the resulting value.</p>
<p>(3) And for all ğ‘˜ (ğ‘˜ â‰  ğ‘™), â€˜ğ‘ ğ‘¡ğ‘ğ‘ğ‘˜_ğ‘˜ = ğ‘ ğ‘¡ğ‘ğ‘ğ‘˜_ğ‘˜.</p>
</blockquote>
<h3>Example: semantics of int2ptr</h3>
<p>Introduce a new tag variable ğ‘¡_ğ‘–, and conjunct into the relation that ğ‘¡_ğ‘– is one of the permissible values. The tag variable can now safely be handled by determinism-land (1,2,3).</p>



<a name="277947120"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/277947120" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#277947120">(Apr 05 2022 at 21:38)</a>:</h4>
<p>I don't think there is necessarily any nondeterminism in the values</p>



<a name="277952994"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/277952994" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#277952994">(Apr 05 2022 at 22:37)</a>:</h4>
<p>Just in the provenance tags. When you do int2ptr, in the permissive-provenance formal model, you get a pointer with any provenance which is maximally in the favor of developer for avoiding UB.</p>



<a name="277953168"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/277953168" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#277953168">(Apr 05 2022 at 22:38)</a>:</h4>
<p>Indeed there is no nondeterminism that can affect the execution of the program, or anything thatâ€™s printed to the terminal</p>



<a name="277953205"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/277953205" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#277953205">(Apr 05 2022 at 22:38)</a>:</h4>
<p>I wonder if it is possible to have it be a pointer with a fresh tag that is <em>derived</em> from a nondeterministic pointer on the stack. That way the nondeterminism is limited to the stack itself and you can have the same tag regardless of what it binds to</p>



<a name="277953471"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/277953471" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#277953471">(Apr 05 2022 at 22:41)</a>:</h4>
<p>i.e. if you have <code>[a SRW, b Unique, c SRW]</code> where <code>a</code> and <code>c</code> are exposed and make a int2ptr, you get the value <code>Ptr(d)</code> and the stack becomes one of</p>
<ul>
<li><code>[a SRW, d SRW, b Unique, c SRW]</code></li>
<li><code>[a SRW, b Unique, c SRW, d SRW]</code></li>
</ul>
<p>where <code>d</code> is not exposed.</p>



<a name="277953873"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/277953873" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#277953873">(Apr 05 2022 at 22:44)</a>:</h4>
<p>I don't think that there is any observable difference compared to getting either <code>Ptr(a)</code> or <code>Ptr(c)</code> nondeterministically with no change in the stack, but I'm not 100%. In particular I'm not sure if writes to <code>Ptr(a)</code> would invalidate <code>Ptr(d)</code> in the first case</p>



<a name="277959598"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/277959598" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#277959598">(Apr 05 2022 at 23:55)</a>:</h4>
<p>Miri doesn't use SAT though so I dont see how SMT would help Miri</p>



<a name="277959608"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/277959608" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#277959608">(Apr 05 2022 at 23:55)</a>:</h4>
<p>sure you could build some kind of model checker or so but that's a very different game</p>



<a name="277959716"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/277959716" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#277959716">(Apr 05 2022 at 23:56)</a>:</h4>
<p>Yes, it wouldn't exactly be trivial to integrate in Miri. It seems feasible, and I think it'll work well for small examples, but I have no idea how it would scale to larger programs. People say that SMT solvers are really clever but I believe they're also a bit unpredictable</p>



<a name="277960574"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/277960574" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#277960574">(Apr 06 2022 at 00:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT/near/277959598">said</a>:</p>
<blockquote>
<p>Miri doesn't use SAT though so I dont see how SMT would help Miri</p>
</blockquote>
<p>Satisfyability checkers allow you to take n nondeterministic branches with potentially less than O(2^n) work. Additionally, they're just convenient for handling nondeterminism.</p>
<p>SMT is just SAT with a fancier expression language and more types, e.g. in addition to bools you have lists too.</p>



<a name="277960647"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/277960647" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#277960647">(Apr 06 2022 at 00:10)</a>:</h4>
<p>I mean yes but that is a VERY birds-eye view of what they do</p>



<a name="277960666"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/277960666" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#277960666">(Apr 06 2022 at 00:11)</a>:</h4>
<p>they certainly dont let me use non-determinism <em>in the middle if a big imperative program like Miri</em> and "take n nondet branches" there</p>



<a name="277960682"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/277960682" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#277960682">(Apr 06 2022 at 00:11)</a>:</h4>
<p>it's a <em>very</em> specific kind of problems in which they can do that</p>



<a name="277960738"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/277960738" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#277960738">(Apr 06 2022 at 00:12)</a>:</h4>
<p>specifically, things you can write in <em>propositional</em> logic (the weakest logic of them all)</p>



<a name="277960753"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/277960753" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#277960753">(Apr 06 2022 at 00:12)</a>:</h4>
<p>It would have to be baked into Miri. Definitely not magic</p>



<a name="277960813"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/277960813" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#277960813">(Apr 06 2022 at 00:13)</a>:</h4>
<p>I think for int2ptr, propositional logic is all you need isn't it?</p>



<a name="277960946"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/277960946" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#277960946">(Apr 06 2022 at 00:15)</a>:</h4>
<p>you realize that that state space that has to be exploded here is literally all of Stacked Borrows?</p>



<a name="277960951"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/277960951" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#277960951">(Apr 06 2022 at 00:15)</a>:</h4>
<p>like, for each "possible world" we need to have a completely independent set of borrow stacks for each allocation</p>



<a name="277961015"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/277961015" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#277961015">(Apr 06 2022 at 00:16)</a>:</h4>
<p>it is <em>probably</em> possible to do this in a per-allocation way (I dont think we can have cross-allocation correlations) but that still means all of the SB stuff needs to be "folded into" this nondet automaton</p>



<a name="277961016"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/277961016" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#277961016">(Apr 06 2022 at 00:16)</a>:</h4>
<p>Yes â€” but that's the point. With SAT you don't make <em>n</em> parallel copies â€” you add a term to your formula</p>



<a name="277961021"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/277961021" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#277961021">(Apr 06 2022 at 00:16)</a>:</h4>
<p>yes but SB isnt a SAT formula :)</p>



<a name="277961071"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/277961071" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#277961071">(Apr 06 2022 at 00:17)</a>:</h4>
<p>I think the nondeterministic part of it can be expressed in SAT, and I think it would handle it more efficiently than making <em>n</em> copies of the world</p>



<a name="277961115"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/277961115" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#277961115">(Apr 06 2022 at 00:18)</a>:</h4>
<p>Or do you mean because Miri is a bunch more complicated than the paper?</p>



<a name="277961361"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/277961361" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#277961361">(Apr 06 2022 at 00:22)</a>:</h4>
<p>Exactly Mario, that's basically what I tried to formalize. The computation only has to happen once, but at any point multiple stacks may be possible for a location. </p>
<p>(posting this example because I have it anyway, might as well get it out of my editor)</p>
<p>Suppose that we have this 1 memory location, and it has a stack</p>
<blockquote>
<p>ğ‘ ğ‘¡ğ‘ğ‘ğ‘˜â‚ = <code>[a SRW, b Unique, c SRW]</code></p>
</blockquote>
<p>Now we do int2ptr. It returns <code>Ptr(1, ğ‘¡_7)</code> where ğ‘¡_7 is a fresh tag variable that's either <code>a</code> or <code>c</code>. The predicate becomes</p>
<blockquote>
<p>ğ‘¡_7 âˆˆ {<code>a</code>, <code>c</code>}  âˆ§  ğ‘ ğ‘¡ğ‘ğ‘ğ‘˜â‚ = <code>[a SRW, b Unique, c SRW]</code></p>
</blockquote>
<p>Next, we do ptr2int on the pointer. If its tag was <code>c</code> then the stack stays the same, otherwise the last two elements are popped. The predicate becomes</p>
<blockquote>
<p>(ğ‘¡_7 = a  âˆ§  ğ‘ ğ‘¡ğ‘ğ‘ğ‘˜â‚ = <code>[a SRW]</code>)</p>
<p>âˆ¨ (ğ‘¡_7 = c  âˆ§  ğ‘ ğ‘¡ğ‘ğ‘ğ‘˜â‚ = <code>[a SRW, b Unique, c SRW]</code>)</p>
</blockquote>
<p>Next, suppose we push a <code>&amp;mut</code> on the stack, which corresponds to pushing a <code>Unique</code>. The predicate becomes</p>
<blockquote>
<p>(ğ‘¡_7 = a  âˆ§  ğ‘ ğ‘¡ğ‘ğ‘ğ‘˜â‚ = <code>[a SRW, d Unique]</code>)</p>
<p>âˆ¨ (ğ‘¡_7 = c  âˆ§  ğ‘ ğ‘¡ğ‘ğ‘ğ‘˜â‚ = <code>[a SRW, b Unique, c SRW, d Unique]</code>)</p>
</blockquote>
<p>Now the program uses the <code>&amp;mut</code> pointer for <code>b</code>. This creates the formula</p>
<blockquote>
<p>(ğ‘¡_7 = a  âˆ§  ğ‘ ğ‘¡ğ‘ğ‘ğ‘˜â‚ = <code>[a SRW, d Unique]</code>  âˆ§  false)</p>
<p>âˆ¨ (ğ‘¡_7 = c  âˆ§  ğ‘ ğ‘¡ğ‘ğ‘ğ‘˜â‚ = <code>[a SRW, b Unique, c SRW, d Unique]</code>)</p>
</blockquote>
<p>which SAT simplifies to</p>
<blockquote>
<p>ğ‘¡_7 = c  âˆ§  ğ‘ ğ‘¡ğ‘ğ‘ğ‘˜â‚ = <code>[a SRW, b Unique, c SRW, d Unique]</code></p>
</blockquote>
<p>for us.</p>



<a name="277962083"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/277962083" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#277962083">(Apr 06 2022 at 00:34)</a>:</h4>
<p>Hm, looks like SMT solvers aren't really made for simplifying. They can be part of simplifying (they can answer "is there still a feasible world" or "is it still possible that t_7 = a") but maybe they can't drive the simplifying</p>



<a name="277968843"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/277968843" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#277968843">(Apr 06 2022 at 02:38)</a>:</h4>
<p>I am sorry but this discussion is going so far into speculative territory that I can't really invest the time to dig deep enough into it to follow.<br>
I dont doubt that something <em>can</em> in theory be done, but it would be no less than a complete rewrite of the relevant parts of Miri. if someone wants to experiment with that, by all means do so. :) but I can't currently help much with designing something like that.</p>



<a name="277969233"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/277969233" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#277969233">(Apr 06 2022 at 02:46)</a>:</h4>
<p>what I am personally more interested in is a way to "approximate" SB + permissive provenance in a way that there are no false positives, but also no undue amount of loss of precision and no complete rewrite of everything (like your approach would require us to do). how do we have to handle accesses through pointers with "magic" provenance, and what do they have to do on the borrow stack, so that we will definitely not reject any correct program?<br>
in fact, forget stacked borrows, how do we do that even just for bounds checks and <code>offset</code> checking? what miri currently does here by default is wrong. it will reject the following (outrageous but correct) program:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="n">x</span><span class="p">.</span><span class="n">expose_addr</span><span class="p">();</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptr</span>::<span class="n">from_exposed_addr</span><span class="p">(</span><span class="n">y</span><span class="p">.</span><span class="n">addr</span><span class="p">()).</span><span class="n">with_addr</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">addr</span><span class="p">());</span><span class="w"></span>
<span class="fm">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="w"> </span><span class="p">});</span><span class="w"></span>
</code></pre></div>
<p>this is correct because <code>from_exposed_addr(...)</code> can pick up the provenance that was exposed by <code>x.expose_addr</code>, and then that is combined with the actual address of <code>x</code>, so provenance and address match and everything should work.</p>



<a name="277971659"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/277971659" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#277971659">(Apr 06 2022 at 03:30)</a>:</h4>
<p>What's the issue with the "intuitive" greedy behavior, such that a pointer cast from an int uses the tag that would require it to pop the least amount of items from the borrow stack?</p>



<a name="277982782"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/277982782" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#277982782">(Apr 06 2022 at 07:06)</a>:</h4>
<p>Yes, my story is indeed rather speculative</p>



<a name="277983097"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/277983097" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#277983097">(Apr 06 2022 at 07:11)</a>:</h4>
<p>I donâ€™t get it Ralf, didnâ€™t we just put in docs that from_exposed_addr on a nonexposed addr is UB?</p>



<a name="277983233"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/277983233" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#277983233">(Apr 06 2022 at 07:12)</a>:</h4>
<p>I assumed that from_exposed_addr would pick up any provenance valid <em>for that address</em>, not any provenance in general</p>



<a name="277983363"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/277983363" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#277983363">(Apr 06 2022 at 07:13)</a>:</h4>
<p>You seem to imply that the dereferencing is UB instead of the from_exposed_addr</p>



<a name="277983785"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/277983785" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#277983785">(Apr 06 2022 at 07:18)</a>:</h4>
<p>Allowing to return any provenance from _any_ addr seems theoretically nice for devs, but it makes us a lot more liberal than C, could be harder for compiler writers and I donâ€™t see why it would actually be nicer in practice</p>



<a name="277983866"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/277983866" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#277983866">(Apr 06 2022 at 07:19)</a>:</h4>
<p>Quy, I think there is an example with NLL where you actually donâ€™t want the topmost tag</p>



<a name="278032139"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278032139" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278032139">(Apr 06 2022 at 14:32)</a>:</h4>
<p><span class="user-mention silent" data-user-id="303115">Quy Nguyen</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT/near/277971659">said</a>:</p>
<blockquote>
<p>What's the issue with the "intuitive" greedy behavior, such that a pointer cast from an int uses the tag that would require it to pop the least amount of items from the borrow stack?</p>
</blockquote>
<p>as I said, forget stacked borrows. making my example work with <code>-Zmiri-disable-stacked-borrows</code> will already require some interesting changes to miri</p>



<a name="278032204"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278032204" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278032204">(Apr 06 2022 at 14:32)</a>:</h4>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT/near/277983097">said</a>:</p>
<blockquote>
<p>I donâ€™t get it Ralf, didnâ€™t we just put in docs that from_exposed_addr on a nonexposed addr is UB?</p>
</blockquote>
<p>no we didnt, please carefully read the docs :)</p>



<a name="278032233"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278032233" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278032233">(Apr 06 2022 at 14:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT/near/277983233">said</a>:</p>
<blockquote>
<p>I assumed that from_exposed_addr would pick up any provenance valid <em>for that address</em>, not any provenance in general</p>
</blockquote>
<p>oh no, it must be any provenance in general</p>



<a name="278032278"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278032278" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278032278">(Apr 06 2022 at 14:33)</a>:</h4>
<p>people do things like <code>from_exposed_addr(x.expose_addr() + 4)</code></p>



<a name="278035567"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278035567" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278035567">(Apr 06 2022 at 14:54)</a>:</h4>
<p>Ah, yes, thatâ€™s indeed a more precise reading of the docs</p>



<a name="278035637"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278035637" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278035637">(Apr 06 2022 at 14:55)</a>:</h4>
<p>It also makes a polyfill for CHERI impossible</p>



<a name="278035804"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278035804" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278035804">(Apr 06 2022 at 14:56)</a>:</h4>
<p>Not just infeasible but impossible. CHERI (like C) doesnâ€™t allow for capabilities to point to outside their valid range</p>



<a name="278040502"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278040502" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Peter Sewell <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278040502">(Apr 06 2022 at 15:24)</a>:</h4>
<p>CHERI is more liberal than ISO C here: it guarantees some space above and below (something like 1/4 and 1/8 of the region) within which any pointer value is guaranteed to be representable; we see code using some of this flexibility.</p>



<a name="278041160"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278041160" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278041160">(Apr 06 2022 at 15:29)</a>:</h4>
<p><span aria-label="+1" class="emoji emoji-1f44d" role="img" title="+1">:+1:</span>ğŸ»</p>



<a name="278041284"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278041284" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278041284">(Apr 06 2022 at 15:29)</a>:</h4>
<p>(To be pedantic, I would like to call this â€œCHERI Câ€ not just CHERI ğŸ˜‡)</p>



<a name="278041919"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278041919" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Peter Sewell <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278041919">(Apr 06 2022 at 15:33)</a>:</h4>
<p>It's actually non-trivially debatable.  The architectures allow what I say, and in many cases CHERI C will too, but I don't know for sure that the CHERI C implementations don't have analyses/optimisations that assume that more than one-past pointer construction is UB.</p>



<a name="278043091"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278043091" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Peter Sewell <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278043091">(Apr 06 2022 at 15:40)</a>:</h4>
<p>(Jess Clarke or Alex Richardson may know that already)</p>



<a name="278047787"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278047787" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jessica Clarke <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278047787">(Apr 06 2022 at 16:11)</a>:</h4>
<p>As far as the language goes it's as UB as whatever LLVM already does, whatever that is and means</p>



<a name="278060720"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278060720" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278060720">(Apr 06 2022 at 17:47)</a>:</h4>
<p><span class="user-mention" data-user-id="120791">@RalfJ</span> Ok, so I made some jank changes a while back, but I didn't exactly hit anything that changed in testing, so I shelved it.</p>
<p><a href="https://github.com/carbotaniuman/miri/blob/e7aa846ef60404b6e10e98a43cd21e12af434fb4/tests/run-pass/addr-oob.rs">https://github.com/carbotaniuman/miri/blob/e7aa846ef60404b6e10e98a43cd21e12af434fb4/tests/run-pass/addr-oob.rs</a></p>
<p>I'm not familiar enough with Miri to know why the first test case passes already, but the second one needs these changes. I also made these changes from a quick glance, so I've probably butchered a lot of the semantics.</p>



<a name="278066832"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278066832" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278066832">(Apr 06 2022 at 18:30)</a>:</h4>
<p>Despite what I say in the commit, the actual semantics are more like <code>PNVI-ae-universal</code> (<code>PNVI-ae-udi</code> does not work for us because there's no <code>wrapping_offset</code> equivalent in C), wherein any pointer casted from a nonzero integer can alias any exposed allocation (the exposed part is currently not implemented). Most of the jank comes from the fact that rustc doesn't expect AllocIds to be synthesized like this, so instead of saying I can't synthesize a valid one for this access I have to pick a random invalid one.</p>



<a name="278069151"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278069151" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278069151">(Apr 06 2022 at 18:50)</a>:</h4>
<blockquote>
<p>any pointer casted from a nonzero integer can alias any exposed allocation</p>
</blockquote>
<p>yeah for Miri we probably want that. it's not correct re: what the docs say, but it's a reasonable approximation that avoids all false positives and still is fully precise for code that does not call expose_addr.</p>



<a name="278069511"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278069511" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278069511">(Apr 06 2022 at 18:52)</a>:</h4>
<p>and yeah I think we need something like what you did for <code>AllocId</code>... basically currently a value of pointer type is a <code>Pointer&lt;Option&lt;AllocId&gt;&gt;</code> (ignoring SB) such that a <code>None</code> indicates an invalid pointer. for permissive provenance we will also somehow need a provenance that indicates a "wildcard" pointer that can access all exposed memory</p>



<a name="278072641"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278072641" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278072641">(Apr 06 2022 at 19:18)</a>:</h4>
<p>I was thinking about adding a hook <a href="https://github.com/rust-lang/rust/blob/5da76eeaad7b57eaee81fc28067952f96abf8377/compiler/rustc_const_eval/src/interpret/memory.rs#L1144">here</a>, and turning <code>into_pointer_or_addr</code> into a trait method somewhere so we can map the "maybe pointer"  (read: permissive provenance pointer) into a proper pointer in Miri. This basically lets us shove all of our "guess the right allocation" logic into this method.</p>



<a name="278073352"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278073352" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278073352">(Apr 06 2022 at 19:23)</a>:</h4>
<p>there's already a hook there, <code>ptr_get_alloc</code></p>



<a name="278074332"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278074332" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278074332">(Apr 06 2022 at 19:30)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT/near/278073352">said</a>:</p>
<blockquote>
<p>there's already a hook there, <code>ptr_get_alloc</code></p>
</blockquote>
<p>Ah, i saw that, <a href="https://github.com/rust-lang/miri/blob/fb01df538e30cf63bdcbadad61828940ca8ec578/src/machine.rs#L597">https://github.com/rust-lang/miri/blob/fb01df538e30cf63bdcbadad61828940ca8ec578/src/machine.rs#L597</a>, but Im not exactly sure how I'm supposed to return <code>None</code> here. Do I need to reintroduce the Option, or is AllocId a built-in option?</p>



<a name="278075436"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278075436" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278075436">(Apr 06 2022 at 19:39)</a>:</h4>
<p>hm, that comment might be refering to an earlier version of the API... now the conversion is always possible because the input is a <code>Pointer&lt;Self::PointerTag&gt;</code> that always has provenance. that is, until you add the wildcard provenance, then that does not work any more. ;)</p>



<a name="278075824"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278075824" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278075824">(Apr 06 2022 at 19:43)</a>:</h4>
<p>Yeah that seems like an easy-ish change. The harder one (in that I don't understand it at all) is <code>get_alloc_id</code>, <a href="https://github.com/rust-lang/rust/search?q=get_alloc_id&amp;type=">https://github.com/rust-lang/rust/search?q=get_alloc_id&amp;type=</a>, which obviously doesn't work with this, but I can't tell what it's actually used for.</p>



<a name="278087743"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278087743" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278087743">(Apr 06 2022 at 21:21)</a>:</h4>
<p>I think that one is easy, just return the absolute address<br>
EDIT: oh, looked at the wrong thing</p>



<a name="278088324"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278088324" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278088324">(Apr 06 2022 at 21:24)</a>:</h4>
<p>from what I can tell, <code>get_alloc_id</code> is only used for debug output, and for <code>try_to_int</code> <em>if</em> <code>Tag::OFFSET_IS_ADDR == false</code> (so the latter never applies for Miri)</p>



<a name="278088482"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278088482" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278088482">(Apr 06 2022 at 21:26)</a>:</h4>
<p>so, I think we can make it return an <code>Option</code></p>



<a name="278102844"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278102844" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278102844">(Apr 07 2022 at 00:05)</a>:</h4>
<p>Took a couple of compiles and it seems good now as the permissive provenance portion of the changes seem to be working. I'm not sure how I would implement exposure tracking though (iirc the base address was only generated if exposed at one point, but that got changed). </p>
<p>It also seems like Miri's definition of provenance does not narrow on subobjects, and that part is handled by SB?</p>



<a name="278103448"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278103448" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ben Kimock (Saethlin) <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278103448">(Apr 07 2022 at 00:15)</a>:</h4>
<p>Yes. Provenance is stored in the Stacks.</p>



<a name="278103519"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278103519" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ben Kimock (Saethlin) <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278103519">(Apr 07 2022 at 00:16)</a>:</h4>
<p>We think of provenance as being a property of pointers, but in Miri provenance is stored the borrow stacks. It's basically what an Item is.</p>



<a name="278103572"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278103572" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ben Kimock (Saethlin) <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278103572">(Apr 07 2022 at 00:17)</a>:</h4>
<p>Miri does have a code path for ptr_to_int btw</p>



<a name="278104100"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278104100" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278104100">(Apr 07 2022 at 00:25)</a>:</h4>
<p>Mind giving me a pointer? It seems like <code>alloc_base_addr</code> would be it, but that seems to always get called when any reference is made.</p>



<a name="278107262"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278107262" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278107262">(Apr 07 2022 at 01:21)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT/near/278032233">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT/near/277983233">said</a>:</p>
<blockquote>
<p>I assumed that from_exposed_addr would pick up any provenance valid <em>for that address</em>, not any provenance in general</p>
</blockquote>
<p>oh no, it must be any provenance in general</p>
</blockquote>
<p>Oh my goodness, this is terrible. I had a similar misconception as Bram here, or rather I noticed that all the documentation so far was a bit vague on this point. This makes the explosion <em>much</em> worse - we aren't just talking about maybe a two-way split sometimes, it's more like a 10000-way split any time you do any int2ptr, since you will pick up any exposed pointer ever done in the past, even if it is not remotely close in value to the integer you are casting. Can we make this at least be restricted to pointer provenances whose allocation contains the address we are casting? Or maybe 1 past the end if necessary. Otherwise this will really become impossible to check.</p>



<a name="278107537"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278107537" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ben Kimock (Saethlin) <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278107537">(Apr 07 2022 at 01:26)</a>:</h4>
<p><span class="user-mention" data-user-id="303115">@Quy Nguyen</span> (whoops, I was away) This function: <a href="https://github.com/rust-lang/miri/blob/0e2def5c122f3149e1d43dfc368d3d1aeeb0191b/src/intptrcast.rs#L83">https://github.com/rust-lang/miri/blob/0e2def5c122f3149e1d43dfc368d3d1aeeb0191b/src/intptrcast.rs#L83</a></p>



<a name="278108578"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278108578" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278108578">(Apr 07 2022 at 01:46)</a>:</h4>
<p>Yeah, I was looking at that function, and it appears to eagerly be called whenever I make a reference. <a href="https://github.com/rust-lang/miri/issues/1988#issuecomment-1056107051">https://github.com/rust-lang/miri/issues/1988#issuecomment-1056107051</a> says that this is an intentional refactoring, so it looks like I'll have to hook in somewhere else...</p>



<a name="278116149"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278116149" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278116149">(Apr 07 2022 at 04:26)</a>:</h4>
<p>Alright, work done for this:</p>
<p><a href="https://github.com/carbotaniuman/rust/commit/b32cc2f92cf663cbcd1a394cfb7dc5d593e8ac9a">https://github.com/carbotaniuman/rust/commit/b32cc2f92cf663cbcd1a394cfb7dc5d593e8ac9a</a><br>
<a href="https://github.com/carbotaniuman/miri/commit/a25b65e8011d99612c3796f5586d244f0dfc92ca">https://github.com/carbotaniuman/miri/commit/a25b65e8011d99612c3796f5586d244f0dfc92ca</a></p>
<p>This implements a permissive form of exposed-address provenance, wherein the only way to expose the address is with a cast to <code>usize</code> (ideally <code>expose_addr</code>). This is more restrictive than C in that stuff like reading the representation bytes (via unions, type-punning, transmute) does not expose the address, only <code>expose_addr</code>. This is less restrictive than C in that a pointer casted from an integer has union provenance of all exposed pointers, not any udi stuff. Not sure how helpful this will be for anything important, but I'll use this to try and muck around with SB.</p>



<a name="278354908"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278354908" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278354908">(Apr 08 2022 at 19:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120827">Ben Kimock (Saethlin)</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT/near/278103519">said</a>:</p>
<blockquote>
<p>We think of provenance as being a property of pointers, but in Miri provenance is stored the borrow stacks. It's basically what an Item is.</p>
</blockquote>
<p>Provenance is still a property of pointers. it's the stacked borrows tag.</p>



<a name="278355010"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278355010" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278355010">(Apr 08 2022 at 19:59)</a>:</h4>
<p><span class="user-mention" data-user-id="303115">@Quy Nguyen</span> that sounds pretty nice. :D do you want to submit PRs so that we can do proper code review?</p>



<a name="278355289"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278355289" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ben Kimock (Saethlin) <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278355289">(Apr 08 2022 at 20:01)</a>:</h4>
<p>Ah yes of course, I was thinking from the angle of where the information about what memory a pointer can access is stored.</p>



<a name="278363034"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278363034" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278363034">(Apr 08 2022 at 21:13)</a>:</h4>
<p>PRs opened, review at your leisure. I've put all of my current working thoughts and ideas in the Miri PR, but the <code>get_alloc_id</code> changes in rustc are also somewhat weird.</p>



<a name="278363851"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278363851" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278363851">(Apr 08 2022 at 21:20)</a>:</h4>
<p>thanks. :) yeah it might be a bit until I get around to reviewing them.</p>



<a name="278376331"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278376331" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278376331">(Apr 09 2022 at 00:09)</a>:</h4>
<p>I'm experimenting with semantics where ptr-to-casts get the topmost exposed tag (but this does run into <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/273">https://github.com/rust-lang/unsafe-code-guidelines/issues/273</a>, sigh), and was trying to see if this helps bring raw pointer tagging to more code. Is there a technical/model reason this wasn't done before?</p>



<a name="278379939"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278379939" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278379939">(Apr 09 2022 at 01:26)</a>:</h4>
<p>yeah -- it is important that you only match <em>exposed</em> tags, otherwise all optimizations are broken</p>



<a name="278379952"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278379952" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278379952">(Apr 09 2022 at 01:26)</a>:</h4>
<p>but I didnt want to even have such a notion (where is that state stored? when exactly does a tag get exposed? etc)</p>



<a name="278380038"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278380038" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278380038">(Apr 09 2022 at 01:28)</a>:</h4>
<p>The idea I had was int-to-ptr casts creating an pointer not only with universal provenance (union of all previously exposed pointers), but also with an universal SB tag (union of all previously exposed SB tags). For this to work, it has to be ok for there to be a pointer with multiple SB tags, which I think is fine as the justifications in the paper use the state of the stacks, and not the tag of the pointer.</p>



<a name="278380058"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278380058" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278380058">(Apr 09 2022 at 01:29)</a>:</h4>
<p>I dont think you literally want a <code>Vec&lt;Tag&gt;</code> on a pointer though</p>



<a name="278380068"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278380068" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278380068">(Apr 09 2022 at 01:29)</a>:</h4>
<p>but if you mean that <code>Wildcard</code> should act as if it had all the exposed SB tags, I agree</p>



<a name="278380084"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278380084" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278380084">(Apr 09 2022 at 01:29)</a>:</h4>
<p>Yeah, not literally a Vec but as-if.</p>



<a name="278380091"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278380091" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278380091">(Apr 09 2022 at 01:29)</a>:</h4>
<p>we'll have to make it so that <code>exposed_addr</code> exposes but <code>addr</code> doesn't, so some new intrinsic or so will be required</p>



<a name="278380146"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278380146" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278380146">(Apr 09 2022 at 01:30)</a>:</h4>
<p>So kinda something like, on every int-to-ptr cast, you would get a pointer with the aforementioned SB tag. I think every SRW directly derived from that pointer would also have this universal tag, but  a retag to anything else just use the topmost usable tag.</p>



<a name="278380154"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278380154" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278380154">(Apr 09 2022 at 01:30)</a>:</h4>
<p>I think this would also "solve" <a href="https://github.com/rust-lang/rust/issues/273">#273</a>, but I'm not sure if that works.</p>



<a name="278380258"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278380258" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278380258">(Apr 09 2022 at 01:32)</a>:</h4>
<p>that's also about as far as I got, but it doesn't satisfy the condition I think we should satisfy -- no false positives</p>



<a name="278380271"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278380271" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278380271">(Apr 09 2022 at 01:33)</a>:</h4>
<p>IMO it is okay to lose even more precision than this, if we can convince ourselves that that fixes all false positives</p>



<a name="278380309"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278380309" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278380309">(Apr 09 2022 at 01:34)</a>:</h4>
<p>What's the false positive that still exists here? (Other than ptr-int transmutes, but I don't think you're talking about those)</p>



<a name="278380353"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278380353" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278380353">(Apr 09 2022 at 01:35)</a>:</h4>
<p>the best guess I have for that is to not just have a <code>Wildcard</code> tag but also a <code>Wildcard</code> part of the borrow stack -- basically the unknown part of the stack where we cant tell what happened because wildcard pointers got used. so in general the stack has a known bottom, then an unknown part, and then a known top. and maybe that's enough? the optimization correctness arguments we have so far only rely on the top part so if this works it'd even still be good enough for the optimizations...</p>



<a name="278380408"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278380408" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278380408">(Apr 09 2022 at 01:36)</a>:</h4>
<p>the example from <a href="https://github.com/rust-lang/rust/issues/273">#273</a> would yield a false positive, no?</p>



<a name="278380418"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278380418" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278380418">(Apr 09 2022 at 01:37)</a>:</h4>
<p>if a reborrow from <code>Wildcard</code> picks the topmost exposed item as the base to reborrow from, then that might lead to false positives later</p>



<a name="278380430"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278380430" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278380430">(Apr 09 2022 at 01:37)</a>:</h4>
<p>Only for non-SRW, which I think works?</p>



<a name="278380581"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278380581" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278380581">(Apr 09 2022 at 01:42)</a>:</h4>
<p>Oh, not for Unique and SRW hmm.</p>



<a name="278380802"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278380802" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278380802">(Apr 09 2022 at 01:47)</a>:</h4>
<p>Wait, so if we have <code>[ESRW(1), U(2), ESRW(3), SRO(4)]</code> for example, where E denotes exposed.</p>
<p>If you cast an int to a pointer you would have <code>ESRW(1) | ESRW(3)</code>, and any <code>SRW</code> directly derived would have the same tag.<br>
If you derived an <code>SRO</code> or a <code>U</code> at <code>ESRW(3)</code>,  then the use of <code>U(2)</code> would invalidate the newly derived pointer.</p>
<p>If you derive an <code>SRO</code> or a <code>U</code> at <code>ESRW(1)</code>, ...</p>



<a name="278381207"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278381207" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278381207">(Apr 09 2022 at 01:57)</a>:</h4>
<p>I dont think <code>ESRW</code> works. 'escaped' is a property of the tag, not a property of the item. (I was a bit sloppy above.)</p>



<a name="278381272"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278381272" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278381272">(Apr 09 2022 at 01:58)</a>:</h4>
<p>if you now derive a <code>U</code> from a wildcard ptr, then you can choose to put it after <code>3</code> or after <code>1</code>. but either choice might later turn out to be the wrong that leads to more UB.</p>



<a name="278381300"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278381300" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278381300">(Apr 09 2022 at 01:59)</a>:</h4>
<p>so instead we could just say that the entire stack is now unknown, and a fresh unique is on top: <code>[unk, U(5)]</code>. this allows <em>all</em> accesses with <em>all</em> tags, but if the tag is not <code>5</code> they will pop the <code>U(5)</code> -- so we still enforce uniqueness of <code>5</code></p>



<a name="278381420"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278381420" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278381420">(Apr 09 2022 at 02:00)</a>:</h4>
<p>Isn't deriving a <code>U</code> from a pointer marked <code>SRW</code> treated as a write to said pointer, or am I misreading the paper?</p>



<a name="278381425"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278381425" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278381425">(Apr 09 2022 at 02:00)</a>:</h4>
<p>basically, <code>Wildcard</code> provenance reflects our ignorance wrt the true provenance value (could literally be anything that was exposed). likewise we have to find a way to reflect our ignorance about the true borrow stack, in a way correctly overapproximates all possibles stacks.</p>



<a name="278381428"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278381428" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278381428">(Apr 09 2022 at 02:00)</a>:</h4>
<p>well yeah but we dont know with SRW</p>



<a name="278381458"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278381458" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278381458">(Apr 09 2022 at 02:01)</a>:</h4>
<p>if we did the correct thing we would not split the world</p>



<a name="278381470"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278381470" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278381470">(Apr 09 2022 at 02:01)</a>:</h4>
<p>one execution treats this as if it matched SRW(1), the other one as if it matches SRW(3)</p>



<a name="278381526"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278381526" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278381526">(Apr 09 2022 at 02:02)</a>:</h4>
<p>but we don't actually want to do that, so instead we find a way to represent the set of all possible worlds in a single data structure -- the stack is "something, and then U(5) on top". that is the one thing we know for sure.</p>



<a name="278381643"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278381643" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278381643">(Apr 09 2022 at 02:04)</a>:</h4>
<p>Yeah that makes sense. Let me ask the question again, I think I might be missing something here.</p>
<p>If we chose SRW(1), then the stack would look like [SRW(1), U(5)]<br>
If we chose SRW(3), then the stack would look like [SRW(1), U(2), SRW(3), U(5)]</p>
<p>So we can either use <code>U(2)</code> and <code>SRW(3)</code>, or <code>U(5)</code>. Is this right?</p>



<a name="278381963"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278381963" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278381963">(Apr 09 2022 at 02:13)</a>:</h4>
<p>yes those are the two options. I dont understand the question in the last line.</p>



<a name="278381966"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278381966" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278381966">(Apr 09 2022 at 02:13)</a>:</h4>
<p>what does "use" mean?</p>



<a name="278381980"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278381980" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278381980">(Apr 09 2022 at 02:13)</a>:</h4>
<p>Perform an access allowed by the tag</p>



<a name="278382003"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278382003" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278382003">(Apr 09 2022 at 02:14)</a>:</h4>
<p>you can use 1 in all cases so I a confused</p>



<a name="278382020"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278382020" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278382020">(Apr 09 2022 at 02:14)</a>:</h4>
<p>using 1 will pop other tags of course but still, you can use it</p>



<a name="278382026"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278382026" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278382026">(Apr 09 2022 at 02:14)</a>:</h4>
<p>you can always use all the tags listed in the stack</p>



<a name="278382060"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278382060" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278382060">(Apr 09 2022 at 02:15)</a>:</h4>
<p>From what I've read the mere act of creating a mutable reference pops everything above on the stack.</p>



<a name="278382068"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278382068" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278382068">(Apr 09 2022 at 02:15)</a>:</h4>
<p>yes</p>



<a name="278382118"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278382118" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278382118">(Apr 09 2022 at 02:16)</a>:</h4>
<p>everything above the parent tag from which the mutable ref is being derived, to be precise</p>



<a name="278382123"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278382123" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278382123">(Apr 09 2022 at 02:16)</a>:</h4>
<p>so?</p>
<p>If we chose SRW(1), then the stack would look like [SRW(1), U(5)]. so now we can use tags 1 and 5.<br>
If we chose SRW(3), then the stack would look like [SRW(1), U(2), SRW(3), U(5)]. so now we can use tags 1, 2, 3, 5.</p>



<a name="278382396"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278382396" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278382396">(Apr 09 2022 at 02:24)</a>:</h4>
<p>So when we turn a SRW(Wildcard) into a U or SRW, using the topmost tag that allows for such a retag produces no false-negatives.</p>



<a name="278382848"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278382848" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278382848">(Apr 09 2022 at 02:34)</a>:</h4>
<p>in the <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/273">https://github.com/rust-lang/unsafe-code-guidelines/issues/273</a> example it does</p>



<a name="278382852"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278382852" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278382852">(Apr 09 2022 at 02:34)</a>:</h4>
<p>false-positives are my concern</p>



<a name="278382854"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278382854" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278382854">(Apr 09 2022 at 02:34)</a>:</h4>
<p>as in, reporting UB when there isnt UB</p>



<a name="278382881"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278382881" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278382881">(Apr 09 2022 at 02:35)</a>:</h4>
<p>Ah, my idea was when deriving SRW from SRW(Wildcard) to keep it as SRW(Wildcard).</p>



<a name="278382941"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278382941" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278382941">(Apr 09 2022 at 02:36)</a>:</h4>
<p>hm... I think it'd be good if <code>&amp;mut</code> ptrs get <code>U</code> no matter from where they are derived</p>



<a name="278382961"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278382961" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278382961">(Apr 09 2022 at 02:37)</a>:</h4>
<p>Oh I meant false positives above btw</p>



<a name="278382973"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278382973" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278382973">(Apr 09 2022 at 02:37)</a>:</h4>
<p>I am not sure, but I think the model that I sketched above -- the one with the 'unknown' part of the stack -- we could actually literally take that as the bottommost floor in Gankra's Tower of Weakenings. This allows all code that is allowed by the <code>from_exposed_addr</code>-angelic-guessing I described, while still allowing all the optimizations we verified for Stacked Borrows. Maybe.</p>



<a name="278382981"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278382981" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278382981">(Apr 09 2022 at 02:37)</a>:</h4>
<p>But what we discussed above should allow SRW(*) =&gt; U with no false positives</p>



<a name="278382983"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278382983" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278382983">(Apr 09 2022 at 02:37)</a>:</h4>
<p>How difficult implementation wise would that be?</p>



<a name="278383022"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278383022" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278383022">(Apr 09 2022 at 02:38)</a>:</h4>
<p>which one?</p>



<a name="278383028"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278383028" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278383028">(Apr 09 2022 at 02:38)</a>:</h4>
<p><code>Wildcard</code> part of the borrow stack</p>



<a name="278383374"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278383374" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278383374">(Apr 09 2022 at 02:47)</a>:</h4>
<p>I dont know</p>



<a name="278383424"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278383424" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278383424">(Apr 09 2022 at 02:48)</a>:</h4>
<p>in terms of representation it's just a <code>bool</code> in the <code>Stack</code> type indicating whether there are additional unknown things below the known things in <code>borrows</code></p>



<a name="278383428"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278383428" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278383428">(Apr 09 2022 at 02:48)</a>:</h4>
<p>but then a bunch of the logic needs to (carefully) be adjusted to take that into account properly</p>



<a name="278384091"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278384091" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278384091">(Apr 09 2022 at 03:04)</a>:</h4>
<p>so, I think two things here will need new intrinsics</p>
<ul>
<li><code>addr</code> needs to do a non-exposing ptr2int</li>
<li><code>ptr::invalid</code> needs to create a ptr without provenance (rather than one with wildcard provenance)</li>
</ul>
<p>they both can't behave like the <code>as</code> casts they are currently implemented with<br>
(or, well, they shouldn't -- that would be totally unnecessary false negatives)</p>



<a name="278384162"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278384162" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278384162">(Apr 09 2022 at 03:06)</a>:</h4>
<p>got any plans for that yet?</p>



<a name="278384176"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278384176" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278384176">(Apr 09 2022 at 03:07)</a>:</h4>
<p>Right now, <code>addr</code> is implemented via transmute in my experiments. Similarly, <code>invalid</code> is a transmute in the other direction.</p>



<a name="278384187"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278384187" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278384187">(Apr 09 2022 at 03:07)</a>:</h4>
<p>It would be cleaner to change <code>as usize</code> to <code>expose_addr</code> and <code>expose_addr</code> to <code>expose</code> intrinsic + <code>addr</code>, but that's a bit far out of my skillset.</p>



<a name="278384305"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278384305" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278384305">(Apr 09 2022 at 03:10)</a>:</h4>
<p>Current implementations are less "the right way" and more minimize changes to the compiler.</p>



<a name="278384602"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278384602" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278384602">(Apr 09 2022 at 03:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="303115">Quy Nguyen</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT/near/278384187">said</a>:</p>
<blockquote>
<p>It would be cleaner to change <code>as usize</code> to <code>expose_addr</code> and <code>expose_addr</code> to <code>expose</code> intrinsic + <code>addr</code>, but that's a bit far out of my skillset.</p>
</blockquote>
<p>well <code>as</code> casts are a MIR primitive so that doesn't really work</p>



<a name="278384616"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278384616" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278384616">(Apr 09 2022 at 03:19)</a>:</h4>
<p>so it's easier to implement <code>expose_addr</code> in terms of <code>as</code>, and then add the hooks required for <code>as</code> to do the exposing</p>



<a name="278384664"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278384664" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278384664">(Apr 09 2022 at 03:20)</a>:</h4>
<p>hm yeah <code>invalid</code> could be a transmute I guess, though that will look odd in the code. making <code>addr</code> a transmute will cause UB errors in Miri. ;)</p>



<a name="278384723"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278384723" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278384723">(Apr 09 2022 at 03:22)</a>:</h4>
<p>like, somewhere around<br>
<a href="https://github.com/rust-lang/rust/blob/f0ec783bf94a4950f6b55cb91b043ec6ff0a4b03/compiler/rustc_const_eval/src/interpret/cast.rs#L172">https://github.com/rust-lang/rust/blob/f0ec783bf94a4950f6b55cb91b043ec6ff0a4b03/compiler/rustc_const_eval/src/interpret/cast.rs#L172</a><br>
we want to add the option for the <code>Machine</code> to do extra magic on an <code>as</code> cast (exposing, and generating a wildcard provenance). and we don't want that magic to happen anywhere else.</p>



<a name="278384787"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278384787" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278384787">(Apr 09 2022 at 03:24)</a>:</h4>
<p>That part is already done in my PR :P</p>



<a name="278384792"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking%20permissive%20provenance%20with%20SMT/near/278384792" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT.html#278384792">(Apr 09 2022 at 03:24)</a>:</h4>
<p>I'm working on getting SB to cooperate now</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>