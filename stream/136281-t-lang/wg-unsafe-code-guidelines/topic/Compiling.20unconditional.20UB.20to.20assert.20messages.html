<html>
<head><meta charset="utf-8"><title>Compiling unconditional UB to assert messages · t-lang/wg-unsafe-code-guidelines · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/index.html">t-lang/wg-unsafe-code-guidelines</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages.html">Compiling unconditional UB to assert messages</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="277882315"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling%20unconditional%20UB%20to%20assert%20messages/near/277882315" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages.html#277882315">(Apr 05 2022 at 13:57)</a>:</h4>
<p>(moved everything to a new thread since I totally derailed the original topic)</p>



<a name="277886821"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling%20unconditional%20UB%20to%20assert%20messages/near/277886821" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages.html#277886821">(Apr 05 2022 at 14:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="271719">Mario Carneiro</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages/near/277881872">said</a>:</p>
<blockquote>
<p>you are right, the one in the best position to handle it would be <code>FunctionCodegen</code> itself since you want to call <code>call_fn</code>. If you can get the <code>Path</code> of lang items somehow you can call that</p>
</blockquote>
<p>That still doesn't solve "how". lang items are a frontend concept. The rust lang items have already ceased to exist as far back as irgen in frontend_rust.</p>



<a name="277887706"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling%20unconditional%20UB%20to%20assert%20messages/near/277887706" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages.html#277887706">(Apr 05 2022 at 14:33)</a>:</h4>
<p>I've also noted that the only times function calls are generated by the backend in lccc are when there is no other option (non-lock free atomics, for example, or software floating-point arithmetic) or when explicitly done by the user (the xir <code>call</code> instruction). Introducing additional calls has <em>fun</em> implications.</p>



<a name="277895708"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling%20unconditional%20UB%20to%20assert%20messages/near/277895708" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages.html#277895708">(Apr 05 2022 at 15:24)</a>:</h4>
<p>perhaps lang item isn't the right word. This would be a cross language / compiler specific "lang item", like your non-lock free atomic functions</p>



<a name="277896037"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling%20unconditional%20UB%20to%20assert%20messages/near/277896037" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages.html#277896037">(Apr 05 2022 at 15:26)</a>:</h4>
<p>Poor <span class="user-mention" data-user-id="257758">@Connor Horman</span>, you constantly have to defend your compiler design against people who don't understand it and haven't thought as much about it (including me the other day)...</p>



<a name="277896122"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling%20unconditional%20UB%20to%20assert%20messages/near/277896122" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages.html#277896122">(Apr 05 2022 at 15:26)</a>:</h4>
<p>Uh, maybe that was a little harsh.</p>



<a name="277896215"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling%20unconditional%20UB%20to%20assert%20messages/near/277896215" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages.html#277896215">(Apr 05 2022 at 15:27)</a>:</h4>
<p>I'm generally unsympathetic to arguments of the form "this isn't a good feature because my backend architecture doesn't support it easily"</p>



<a name="277896282"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling%20unconditional%20UB%20to%20assert%20messages/near/277896282" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages.html#277896282">(Apr 05 2022 at 15:27)</a>:</h4>
<p>because that sounds like a problem with your backend architecture, not with the features</p>



<a name="277896415"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling%20unconditional%20UB%20to%20assert%20messages/near/277896415" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages.html#277896415">(Apr 05 2022 at 15:28)</a>:</h4>
<p>It's true, but we readily accept such arguments when it comes to rustc and LLVM.</p>



<a name="277896592"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling%20unconditional%20UB%20to%20assert%20messages/near/277896592" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages.html#277896592">(Apr 05 2022 at 15:30)</a>:</h4>
<p>that might be an argument for "this is a low priority / is not likely to happen in the next year", but it doesn't refute the idea itself, and maybe someone will come along later and do the hard work of plumbing the feature where it needs to go</p>



<a name="277896722"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling%20unconditional%20UB%20to%20assert%20messages/near/277896722" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages.html#277896722">(Apr 05 2022 at 15:30)</a>:</h4>
<p>also you can imagine this as being part of the runtime as a SIGILL handler, and if you want you could force different <code>ud2</code> generations to remain separate and not be merged, so that you can still get separate backtraces or direct source info<br>
Of course, keeping separate unreachables from being merged means you now lose some of the optimizations they're intended to give</p>



<a name="277896772"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling%20unconditional%20UB%20to%20assert%20messages/near/277896772" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages.html#277896772">(Apr 05 2022 at 15:31)</a>:</h4>
<p>(all of this is precisely what BUG() does in the linux kernel)</p>



<a name="277896774"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling%20unconditional%20UB%20to%20assert%20messages/near/277896774" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Boxy [she/her] <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages.html#277896774">(Apr 05 2022 at 15:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="198590">comex</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages/near/277896415">said</a>:</p>
<blockquote>
<p>It's true, but we readily accept such arguments when it comes to rustc and LLVM.</p>
</blockquote>
<p>the difference there is that llvm is actually used by rustc and we're stuck with it for now wheras the lccc stuff is irrelevent to rust discussions and is just some random persons pet project</p>



<a name="277896951"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling%20unconditional%20UB%20to%20assert%20messages/near/277896951" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages.html#277896951">(Apr 05 2022 at 15:32)</a>:</h4>
<p>(and being in a SIGILL handler means that ones done early in loading won't have set the handler yet, so you can dodge all those issues)</p>



<a name="277896991"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling%20unconditional%20UB%20to%20assert%20messages/near/277896991" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages.html#277896991">(Apr 05 2022 at 15:32)</a>:</h4>
<p>ouch... I think that discussions about lccc have been helpful in isolating how Rust and rustc differ, especially as regards specification efforts</p>



<a name="277897130"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling%20unconditional%20UB%20to%20assert%20messages/near/277897130" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages.html#277897130">(Apr 05 2022 at 15:33)</a>:</h4>
<p><span class="user-mention" data-user-id="326176">@Boxy [she/her]</span> That's true, and if you become overly deferential to N different implementations and each one's pet implementation choices, then you end up hamstrung like the C++ committee often is.  But there's a balance to be struck.</p>



<a name="277897762"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling%20unconditional%20UB%20to%20assert%20messages/near/277897762" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages.html#277897762">(Apr 05 2022 at 15:37)</a>:</h4>
<p>I think that bringing up lccc is more useful in discussions here than say, on a "normal" language feature. If lccc can't support a language feature, then you basically have the issues with the C/C++ where everything takes years to get consensus. On the other hand, stuff like provenance is highly theoretical, and having some proposed optimizations/realities from an implementation helps  more than it hurts imo.</p>



<a name="277898355"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling%20unconditional%20UB%20to%20assert%20messages/near/277898355" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages.html#277898355">(Apr 05 2022 at 15:40)</a>:</h4>
<p>Anyway, I guess this particular choice between ud2 and calling a function is essentially orthogonal to any specification efforts.  Reporting UB is always best-effort at most.  Even if rustc hypothetically ends up turning unconditional UB into function calls, that would not be guaranteed by the Rust spec.  So if lccc doesn't want to call a function, that doesn't prevent the Rust spec from providing any guarantees or features it would otherwise provide.</p>



<a name="277898886"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling%20unconditional%20UB%20to%20assert%20messages/near/277898886" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages.html#277898886">(Apr 05 2022 at 15:43)</a>:</h4>
<p>(personally I think a SIGILL handler is fine)</p>



<a name="277902549"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling%20unconditional%20UB%20to%20assert%20messages/near/277902549" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages.html#277902549">(Apr 05 2022 at 16:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="271719">Mario Carneiro</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages/near/277896282">said</a>:</p>
<blockquote>
<p>because that sounds like a problem with your backend architecture, not with the features</p>
</blockquote>
<p>The issue is that this is a design feature of the architecture. It's designed not to know the optimization level. It's designed to be discouraged from inspecting the target beyond what it's given in TargetProperties. One of my issues with having <code>puts</code> in TargetProperties is "Where does it end" - what functions do I not need to put in the TargetProperties.</p>



<a name="277903235"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling%20unconditional%20UB%20to%20assert%20messages/near/277903235" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages.html#277903235">(Apr 05 2022 at 16:08)</a>:</h4>
<p>I have the same issue with having a "This target does/doesn't exist on Rust" property.<br>
Where does that end? If it never ends, then it's an ABI problem. If it does end with Rust, then why is Rust special in this regard. </p>
<p>Same thing here, where does "Magic symbol that may/may not exist that the target knows about" end. Does it end with <code>puts</code>? What's special about <code>puts</code>.</p>



<a name="277904992"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling%20unconditional%20UB%20to%20assert%20messages/near/277904992" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages.html#277904992">(Apr 05 2022 at 16:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages/near/277903235">said</a>:</p>
<blockquote>
<p>Same thing here, where does "Magic symbol that may/may not exist that the target knows about" end. Does it end with <code>puts</code>? What's special about <code>puts</code>.</p>
</blockquote>
<p>It's special in the same way that <code>core::panicking::panic</code> is special. The compiler chooses to produce calls to an output function for diagnostic purposes, it is not obligated to do so because it is in UB land and can do whatever it wants, but this function is built into the compiler as an intrinsic.</p>



<a name="277905130"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling%20unconditional%20UB%20to%20assert%20messages/near/277905130" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages.html#277905130">(Apr 05 2022 at 16:21)</a>:</h4>
<p>I would probably not call puts but rather <code>lccc::intrinsics::abort_with_msg</code> or whatever you want to call it, which delegates to <code>puts</code> or does a syscall or whatever is appropriate for the target</p>



<a name="277905221"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling%20unconditional%20UB%20to%20assert%20messages/near/277905221" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages.html#277905221">(Apr 05 2022 at 16:22)</a>:</h4>
<p>As mentioned <code>core::panicking::panic</code> is special only to the frontend. Everything below the frontend just sees <code>std::panicking::panic</code> (yes <code>std::</code>, lccc mangles all of <code>core</code>, <code>alloc</code>, and <code>std</code> as just <code>std</code> to benefit from Itanium's <code>St</code> compression).</p>



<a name="277905289"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling%20unconditional%20UB%20to%20assert%20messages/near/277905289" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages.html#277905289">(Apr 05 2022 at 16:22)</a>:</h4>
<p>What makes <code>puts</code> special for the entire architecture that it has to live in <code>TargetProperties</code>.</p>



<a name="277905353"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling%20unconditional%20UB%20to%20assert%20messages/near/277905353" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages.html#277905353">(Apr 05 2022 at 16:23)</a>:</h4>
<p>I assume you have other target-specific intrinsics as well, for stuff like memcpy</p>



<a name="277905475"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling%20unconditional%20UB%20to%20assert%20messages/near/277905475" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages.html#277905475">(Apr 05 2022 at 16:24)</a>:</h4>
<p>Fair enough.</p>



<a name="277905535"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling%20unconditional%20UB%20to%20assert%20messages/near/277905535" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages.html#277905535">(Apr 05 2022 at 16:24)</a>:</h4>
<p>Though memcpy checks <code>preferred_vector_size</code> and does a bunch of those or smaller moves.</p>



<a name="277905596"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling%20unconditional%20UB%20to%20assert%20messages/near/277905596" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages.html#277905596">(Apr 05 2022 at 16:25)</a>:</h4>
<p>sure, it's intrinsically tied in to the IR generation because you want to optimize it to register moves and such</p>



<a name="277905688"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling%20unconditional%20UB%20to%20assert%20messages/near/277905688" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages.html#277905688">(Apr 05 2022 at 16:25)</a>:</h4>
<p>but that means that it's not just a <code>Call</code> in the IR, even though for some types it might need to be compiled to a literal function call</p>



<a name="277905902"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling%20unconditional%20UB%20to%20assert%20messages/near/277905902" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages.html#277905902">(Apr 05 2022 at 16:27)</a>:</h4>
<p>this abort with message thing is pretty similar in that regard. In the IR it might be represented as a specific IR instruction like <code>Unreachable(msg)</code> and you decide later whether you want to produce a function call or a <code>ud2</code> or remove it entirely</p>



<a name="277906347"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling%20unconditional%20UB%20to%20assert%20messages/near/277906347" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages.html#277906347">(Apr 05 2022 at 16:30)</a>:</h4>
<p><span class="user-mention silent" data-user-id="271719">Mario Carneiro</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages/near/277905688">said</a>:</p>
<blockquote>
<p>but that means that it's not just a <code>Call</code> in the IR, even though for some types it might need to be compiled to a literal function call</p>
</blockquote>
<p>It is (still) a call. It just doesn't codegen to one (usually).</p>



<a name="277907917"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling%20unconditional%20UB%20to%20assert%20messages/near/277907917" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages.html#277907917">(Apr 05 2022 at 16:40)</a>:</h4>
<p>if you store it as a <code>Call</code>, it still needs to be one where the function's name/behavior is known to the optimizer, since I assume you aren't just inlining it since it probably has a weird assembly definition</p>



<a name="277914456"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling%20unconditional%20UB%20to%20assert%20messages/near/277914456" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages.html#277914456">(Apr 05 2022 at 17:25)</a>:</h4>
<p>So I've only read like... half of this, but skimmed the rest. One option that we always have is to warn on functions that are unconditional UB and have a body that is not <code>unreachable_unchecked()</code>. That should at least cover a lot of the potential cases. We can try extending this to more general parts of the CFG that we prove are UB, but tracking that information is hard and also it's not clear how we can avoid getting false positives there</p>



<a name="277925417"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling%20unconditional%20UB%20to%20assert%20messages/near/277925417" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages.html#277925417">(Apr 05 2022 at 18:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages/near/277873331">said</a>:</p>
<blockquote>
<p>(It also again comes down to "The backend doesn't know what <code>printf</code> is")</p>
</blockquote>
<p>FWIW some backends do. the rustc LLVM backend emits panics in a few places. it even has to have that knowledge to codegen array bounds checks.<br>
other backends can be structured differently, of course. but just because some backends cant do it doesnt mean no backend should do it. ;)<br>
(EDIT: and it looks like the same arguments were already rehashed above so never mind.^^)</p>



<a name="277925744"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling%20unconditional%20UB%20to%20assert%20messages/near/277925744" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages.html#277925744">(Apr 05 2022 at 18:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="133247">bjorn3</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages/near/277878254">said</a>:</p>
<blockquote>
<p>I just remember LLVM has an option to turn the unreachable instruction into ud2. It was enabled by default for a while to mitigate loop {} being UB in LLVM in the past. I believe it has since been disabled though.</p>
</blockquote>
<p>hm, I thought it is still enabled?</p>
<p>there are also some places in the LLVM backend that could codegen <code>unreachable</code> but emit <code>abort</code> instead.<br>
see e.g. <a href="https://github.com/rust-lang/rust/issues/59793">https://github.com/rust-lang/rust/issues/59793</a></p>



<a name="277926265"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling%20unconditional%20UB%20to%20assert%20messages/near/277926265" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages.html#277926265">(Apr 05 2022 at 18:44)</a>:</h4>
<blockquote>
<p>hm, I thought it is still enabled?</p>
</blockquote>
<p>Indeed: <a href="https://github.com/rust-lang/rust/blob/6af09d2505f38e4f1df291df56d497fb2ad935ed/compiler/rustc_target/src/spec/mod.rs#L1532">https://github.com/rust-lang/rust/blob/6af09d2505f38e4f1df291df56d497fb2ad935ed/compiler/rustc_target/src/spec/mod.rs#L1532</a> Maybe I was thinking of a PR that didn't end up getting merged?</p>



<a name="277926787"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling%20unconditional%20UB%20to%20assert%20messages/near/277926787" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages.html#277926787">(Apr 05 2022 at 18:48)</a>:</h4>
<p>besides the <code>loop {}</code> issue, another argument was that we don't want LLVM to codegen an unreachable function into a label that just "falls through" to the next function</p>



<a name="277926843"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling%20unconditional%20UB%20to%20assert%20messages/near/277926843" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages.html#277926843">(Apr 05 2022 at 18:48)</a>:</h4>
<p>like, "UB calling random code" should be scoped to 'inside the same function' where possible (not possible with indirect calls, obviously)</p>



<a name="277927034"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling%20unconditional%20UB%20to%20assert%20messages/near/277927034" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages.html#277927034">(Apr 05 2022 at 18:50)</a>:</h4>
<p><span class="user-mention" data-user-id="133247">@bjorn3</span> do you know where in the LLVM pipeline <code>trap_unreachable</code> applies? like, could fixing <a href="https://github.com/rust-lang/rust/issues/59793">https://github.com/rust-lang/rust/issues/59793</a> make any difference at all as long as that flag is set (because some optimizations <em>will</em> use <code>unreachable</code> as a useful hint, and the flag only applies when lowering LLVM IR to assembly later)?</p>



<a name="277927193"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling%20unconditional%20UB%20to%20assert%20messages/near/277927193" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages.html#277927193">(Apr 05 2022 at 18:51)</a>:</h4>
<p>I suspect it is during lowering from llvm ir to whatever machine specific ir is used. In any case we pass the option to LLVM at <a href="https://github.com/rust-lang/rust/blob/86b1581ea0e0e47196e1ea70b2d980b3eee72623/compiler/rustc_llvm/llvm-wrapper/PassWrapper.cpp#L510-L516">https://github.com/rust-lang/rust/blob/86b1581ea0e0e47196e1ea70b2d980b3eee72623/compiler/rustc_llvm/llvm-wrapper/PassWrapper.cpp#L510-L516</a></p>



<a name="277932638"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling%20unconditional%20UB%20to%20assert%20messages/near/277932638" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages.html#277932638">(Apr 05 2022 at 19:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages/near/277925417">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages/near/277873331">said</a>:</p>
<blockquote>
<p>(It also again comes down to "The backend doesn't know what <code>printf</code> is")</p>
</blockquote>
<p>FWIW some backends do. the rustc LLVM backend emits panics in a few places. it even has to have that knowledge to codegen array bounds checks.<br>
other backends can be structured differently, of course. but just because some backends cant do it doesnt mean no backend should do it. ;)<br>
(EDIT: and it looks like the same arguments were already rehashed above so never mind.^^)</p>
</blockquote>
<p>Yeah, different backends do different things. rustc backends are more involved than xlang backends, since rustc backends are (usually) stepping down to another IR, and running stuff on the IR, whereas xlang backends are there to go right into machine code, so they see less and know less. xlang backends are more equivalent to LLVM backends, in this respect.</p>



<a name="277932851"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling%20unconditional%20UB%20to%20assert%20messages/near/277932851" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages.html#277932851">(Apr 05 2022 at 19:36)</a>:</h4>
<p>And this is not to say that an xlang backend could know about a few specific symbols either - it's just that I'd rather not have the in-tree ones rely on that, because of how the entire compilation pipeline is architectured - you could indeed write a <code>codegen-debugx86</code>that emits diagnostics when it traps unreachable code if you had cause to.</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>