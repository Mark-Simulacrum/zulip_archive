<html>
<head><meta charset="utf-8"><title>strict provenance in dwarf::eh · t-lang/wg-unsafe-code-guidelines · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/index.html">t-lang/wg-unsafe-code-guidelines</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/strict.20provenance.20in.20dwarf.3A.3Aeh.html">strict provenance in dwarf::eh</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="276196625"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/strict%20provenance%20in%20dwarf%3A%3Aeh/near/276196625" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/strict.20provenance.20in.20dwarf.3A.3Aeh.html#276196625">(Mar 22 2022 at 14:29)</a>:</h4>
<p><span class="user-mention" data-user-id="137587">@Gankra</span> wait you ~never need <code>union { *u8, usize }</code>, you can just do what CHERI <code>uintptr_t</code> does and switch code to pointers en-masse, use <code>wrapping_offset</code> for addition, <code>ptr::invalid</code> for injecting a raw integer, and <code>.addr()</code> for extracting a raw integer back out, heh</p>
<p>(I <em>really</em> wish we had at least one Morello board between the two of us, so we can check actual in-practice behavior - although... they do have a working <code>qemu</code>, I just don't have a beefy enough machine atm to attempt using something like that for porting Rust)</p>



<a name="276196661"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/strict%20provenance%20in%20dwarf%3A%3Aeh/near/276196661" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/strict.20provenance.20in.20dwarf.3A.3Aeh.html#276196661">(Mar 22 2022 at 14:29)</a>:</h4>
<p>Pointers encoded as DW_EH_PE_absptr are directly included as bytes without ULEB128 encoding.</p>



<a name="276196689"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/strict%20provenance%20in%20dwarf%3A%3Aeh/near/276196689" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Gankra <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/strict.20provenance.20in.20dwarf.3A.3Aeh.html#276196689">(Mar 22 2022 at 14:29)</a>:</h4>
<p>NB symbolic probably has its own implementations of these formats for dump_syms</p>



<a name="276196792"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/strict%20provenance%20in%20dwarf%3A%3Aeh/near/276196792" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/strict.20provenance.20in.20dwarf.3A.3Aeh.html#276196792">(Mar 22 2022 at 14:30)</a>:</h4>
<p>yeah <code>DW_EH_PE_absptr</code> is like the one case where I would maybe expect a real pointer and not just some kind of address/offset</p>



<a name="276196812"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/strict%20provenance%20in%20dwarf%3A%3Aeh/near/276196812" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/strict.20provenance.20in.20dwarf.3A.3Aeh.html#276196812">(Mar 22 2022 at 14:30)</a>:</h4>
<p>(and <code>DW_EH_PE_aligned</code>)</p>



<a name="276197173"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/strict%20provenance%20in%20dwarf%3A%3Aeh/near/276197173" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/strict.20provenance.20in.20dwarf.3A.3Aeh.html#276197173">(Mar 22 2022 at 14:32)</a>:</h4>
<p>Re DW_EH_PE_{textrel,datarel} the current code already takes two functions to get from encoded pointer to actual pointer. These can use a capability covering the entire .text/.data sections and derive the new pointer.</p>



<a name="276197290"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/strict%20provenance%20in%20dwarf%3A%3Aeh/near/276197290" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/strict.20provenance.20in.20dwarf.3A.3Aeh.html#276197290">(Mar 22 2022 at 14:33)</a>:</h4>
<p>basically what I'm saying (for the more serious suggestion, not the "put everything in a pointer") is:</p>
<ol>
<li><a href="https://github.com/rust-lang/rust/blob/3ea44938e21f0de8ae7d4f6399a8a30f97867c70/library/panic_unwind/src/dwarf/eh.rs#L161-L169">https://github.com/rust-lang/rust/blob/3ea44938e21f0de8ae7d4f6399a8a30f97867c70/library/panic_unwind/src/dwarf/eh.rs#L161-L169</a> should be handled by a separate integer-focused function that returns <code>usize</code>/<code>isize</code></li>
<li><a href="https://github.com/rust-lang/rust/blob/3ea44938e21f0de8ae7d4f6399a8a30f97867c70/library/panic_unwind/src/dwarf/eh.rs#L172-L185">https://github.com/rust-lang/rust/blob/3ea44938e21f0de8ae7d4f6399a8a30f97867c70/library/panic_unwind/src/dwarf/eh.rs#L172-L185</a> should be nested within that "I just read an integer offset" case, and offset their respective base pointers</li>
<li><code>DW_EH_PE_aligned</code>/<code>DW_EH_PE_absptr</code>/<code>DW_EH_PE_indirect</code> should all read a whole pointer</li>
</ol>



<a name="276197515"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/strict%20provenance%20in%20dwarf%3A%3Aeh/near/276197515" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/strict.20provenance.20in.20dwarf.3A.3Aeh.html#276197515">(Mar 22 2022 at 14:35)</a>:</h4>
<p>by calling the 1. function directly you can bypass something being mistreated as a pointer when it's an offset (like the call site table fields)<br>
then 2. handles all the "derived capability" cases<br>
and 3. deals with "this is already a pointer" without having to take an address and make a pointer out of it</p>



<a name="276197557"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/strict%20provenance%20in%20dwarf%3A%3Aeh/near/276197557" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/strict.20provenance.20in.20dwarf.3A.3Aeh.html#276197557">(Mar 22 2022 at 14:35)</a>:</h4>
<p>now someone has to rewrite that code and get it through review</p>



<a name="276197659"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/strict%20provenance%20in%20dwarf%3A%3Aeh/near/276197659" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/strict.20provenance.20in.20dwarf.3A.3Aeh.html#276197659">(Mar 22 2022 at 14:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="133247">bjorn3</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/strict.20provenance.20std.20compat.20notes/near/276197173">said</a>:</p>
<blockquote>
<p>Re DW_EH_PE_{textrel,datarel} the current code already takes two functions to get from encoded pointer to actual pointer. These can use a capability covering the entire .text/.data sections and derive the new pointer.</p>
</blockquote>
<p>yupp. I was telling <span class="user-mention" data-user-id="137587">@Gankra</span> earlier that those functions should be changed from <code>-&gt; usize</code> to <code>-&gt; *const u8</code></p>



<a name="276197700"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/strict%20provenance%20in%20dwarf%3A%3Aeh/near/276197700" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/strict.20provenance.20in.20dwarf.3A.3Aeh.html#276197700">(Mar 22 2022 at 14:36)</a>:</h4>
<p>every <code>usize</code> here basically <a href="https://github.com/rust-lang/rust/blob/3ea44938e21f0de8ae7d4f6399a8a30f97867c70/library/panic_unwind/src/dwarf/eh.rs#L38-L50">https://github.com/rust-lang/rust/blob/3ea44938e21f0de8ae7d4f6399a8a30f97867c70/library/panic_unwind/src/dwarf/eh.rs#L38-L50</a></p>



<a name="276198684"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/strict%20provenance%20in%20dwarf%3A%3Aeh/near/276198684" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/strict.20provenance.20in.20dwarf.3A.3Aeh.html#276198684">(Mar 22 2022 at 14:43)</a>:</h4>
<p><span class="user-mention silent" data-user-id="119009">eddyb</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/strict.20provenance.20in.20dwarf.3A.3Aeh/near/276196625">said</a>:</p>
<blockquote>
<p>(I <em>really</em> wish we had at least one Morello board between the two of us, so we can check actual in-practice behavior - although... they do have a working <code>qemu</code>, I just don't have a beefy enough machine atm to attempt using something like that for porting Rust)</p>
</blockquote>
<p>my other regret is not being able to test this kind of code in miri because there's not really any way to compile to something that has this kind of GCC EH data, but which still has miri semantics</p>



<a name="276198826"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/strict%20provenance%20in%20dwarf%3A%3Aeh/near/276198826" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/strict.20provenance.20in.20dwarf.3A.3Aeh.html#276198826">(Mar 22 2022 at 14:44)</a>:</h4>
<p>closest thing I can think of is some kind of ubsan that doubles your memory usage so it can store miri-like information in the shadow side (but LLVM would have to be cooperating a lot with it, and I'm not sure existing sanitizers are strict enough)</p>



<a name="276200861"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/strict%20provenance%20in%20dwarf%3A%3Aeh/near/276200861" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/strict.20provenance.20in.20dwarf.3A.3Aeh.html#276200861">(Mar 22 2022 at 14:56)</a>:</h4>
<p>(the existing ubsan itself is very limited to pretty much non-asan like situations sadly <a href="https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html">https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html</a>)</p>



<a name="276315499"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/strict%20provenance%20in%20dwarf%3A%3Aeh/near/276315499" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/strict.20provenance.20in.20dwarf.3A.3Aeh.html#276315499">(Mar 23 2022 at 10:53)</a>:</h4>
<p><a href="https://twitter.com/arichardson___/status/1506427082737340416">https://twitter.com/arichardson___/status/1506427082737340416</a></p>
<div class="inline-preview-twitter"><div class="twitter-tweet"><a href="https://twitter.com/arichardson___/status/1506427082737340416"><img class="twitter-avatar" src="https://uploads.zulipusercontent.net/01d2ec0d00cc478291d0d76be7347c373bcf1834/68747470733a2f2f7062732e7477696d672e636f6d2f70726f66696c655f696d616765732f313530363032363830303933333232303335342f66315f7450684a4c5f6e6f726d616c2e706e67"></a><p><a href="https://twitter.com/Gankra_">@Gankra_</a> Currently our LLVM emits .gcc_except_table targets as capabilities instead of offsets (<a href="https://t.co/HaIDj0HvFX">https://cheri-compiler-explorer.cl.cam.ac.uk/z/n6GhhW</a>). And in some cases libunwind derives provenance from program header capabilities, using dl_iterate_phdrs (RTLD sets them up to span the DSO).</p><span>- Alex Richardson (@arichardson___)</span></div></div>



<a name="276315610"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/strict%20provenance%20in%20dwarf%3A%3Aeh/near/276315610" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/strict.20provenance.20in.20dwarf.3A.3Aeh.html#276315610">(Mar 23 2022 at 10:54)</a>:</h4>
<p>this was linked elsewhere by <span class="user-mention" data-user-id="137587">@Gankra</span> but I just want to say that this confirms what I was hoping for (CHERI caps in <code>.gcc_except_table</code>, that the linker and/or dynamic loader accounts for)</p>



<a name="276794686"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/strict%20provenance%20in%20dwarf%3A%3Aeh/near/276794686" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nagisa <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/strict.20provenance.20in.20dwarf.3A.3Aeh.html#276794686">(Mar 27 2022 at 15:56)</a>:</h4>
<p>Huh, this now makes me think… what happens when the stack is non-linear (<code>stacker</code>)?</p>



<a name="276794693"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/strict%20provenance%20in%20dwarf%3A%3Aeh/near/276794693" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nagisa <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/strict.20provenance.20in.20dwarf.3A.3Aeh.html#276794693">(Mar 27 2022 at 15:56)</a>:</h4>
<p>it is quite plausible that the two distinct parts of the stack will be on the different sides of the address space and… see the <code>wrapping_offset</code> discussion.</p>



<a name="276794700"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/strict%20provenance%20in%20dwarf%3A%3Aeh/near/276794700" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/strict.20provenance.20in.20dwarf.3A.3Aeh.html#276794700">(Mar 27 2022 at 15:57)</a>:</h4>
<p>The stack contains a pointer to the previous stack segment. Stacker would just have to make sure that the pointer provenance covers enough of the stack segment.</p>



<a name="276794751"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/strict%20provenance%20in%20dwarf%3A%3Aeh/near/276794751" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nagisa <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/strict.20provenance.20in.20dwarf.3A.3Aeh.html#276794751">(Mar 27 2022 at 15:58)</a>:</h4>
<p>It does, yeah.</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>