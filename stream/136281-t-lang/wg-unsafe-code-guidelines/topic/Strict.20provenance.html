<html>
<head><meta charset="utf-8"><title>Strict provenance ¬∑ t-lang/wg-unsafe-code-guidelines ¬∑ Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/index.html">t-lang/wg-unsafe-code-guidelines</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html">Strict provenance</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="277295704"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277295704" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277295704">(Mar 31 2022 at 15:08)</a>:</h4>
<p>I would like to continue <a href="https://github.com/rust-lang/rust/issues/95228">95228</a> here. </p>
<p><span class="user-mention" data-user-id="295632">@Diggsey</span> <a href="https://github.com/rust-lang/rust/issues/95228#issuecomment-1084672019">wrote</a>:</p>
<blockquote>
<p>Right, I think we'd still want to be clear that (assuming this all goes through) we think the strict provenance model is the future - that it's something that all crates should aspire to support, but it at least gives us a way to guarantee that existing code can continue to work.</p>
</blockquote>
<p>I see it differently ‚Äî I want <code>strict</code> to be the default in some future edition, with PNVI-whatever still supported.</p>
<p><span class="user-mention" data-user-id="120791">@RalfJ</span> <a href="https://github.com/rust-lang/rust/issues/95228#issuecomment-1084651137">wrote</a>:</p>
<blockquote>
<p>Strict provenance is a memory model question, which means it is a global choice.</p>
</blockquote>
<p>Specifying a Rust with strict_provenance semantics would be much <del>harder</del> easier than one with PNVI semantics ‚Äî am I understanding that correctly?</p>
<hr>
<p>If C/Clang/LLVM adopt PNVI-AE-*, then I suspect we can simply add a non-exposing <code>ptr2int</code> to LLVM IR. That is, we don't vary the optimization passes, but the optimization passes "know" where they are safe to apply and where they aren't safe to apply.</p>
<p>Then</p>
<ul>
<li>we get miri / formal specifications for devs who put in the work to avoid <code>ptr2int2ptr</code> altogether</li>
<li>the ecosystem can use <code>ptr2int2ptr</code></li>
<li>in practice we get all the speed of <code>strict</code></li>
<li>CHERI works for everyone</li>
<li>Rust-on-CHERI has negligible performance overhead for devs who put in the work to avoid <code>ptr2int2ptr</code> altogether</li>
</ul>



<a name="277297327"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277297327" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277297327">(Mar 31 2022 at 15:19)</a>:</h4>
<p>I'm proposing that Rust (the standard that defines execution for programs) would have two logical memory models:</p>
<ul>
<li><code>strict</code>, which is used when all crates have <code>ptr2int2ptr = false</code>, and which we aim to formally specify</li>
<li><code>pnvi</code>, which is used otherwise, and which may be infeasible to formally specify.</li>
</ul>
<p>As I understand it, execution of a <code>strict</code> program without UB is faithfully mimiced by execution of the same program under <code>pnvi</code> semantics.</p>



<a name="277300872"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277300872" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277300872">(Mar 31 2022 at 15:43)</a>:</h4>
<blockquote>
<p>Specifying a Rust with strict_provenance semantics would be much harder than one with PNVI semantics ‚Äî am I understanding that correctly?</p>
</blockquote>
<p>No, its the other way around. strict provenance makes specifying things a lot simpler.</p>



<a name="277300953"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277300953" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277300953">(Mar 31 2022 at 15:43)</a>:</h4>
<p>I dont think we can use PNVI for anything, it's designed for C</p>



<a name="277300957"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277300957" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277300957">(Mar 31 2022 at 15:43)</a>:</h4>
<p>Yes, that‚Äôs what I meant =)</p>



<a name="277301025"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277301025" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277301025">(Mar 31 2022 at 15:44)</a>:</h4>
<p>unless you mean PNVI in the broad sense of "models that support ptr2int2ptr"^^ (while integers themselves do not have provenance)</p>



<a name="277301048"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277301048" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277301048">(Mar 31 2022 at 15:44)</a>:</h4>
<p>but the Rust version of that will look very different from the PNVI proposals I think</p>



<a name="277301122"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277301122" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277301122">(Mar 31 2022 at 15:44)</a>:</h4>
<p><span aria-label="shrug" class="emoji emoji-1f937" role="img" title="shrug">:shrug:</span>üèª some people like to do evil inttoptr tricks. If some people can identify C with PVNI Rust, the barrier to adoption becomes lower</p>



<a name="277301240"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277301240" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277301240">(Mar 31 2022 at 15:45)</a>:</h4>
<p>PNVI is a great proposal for C, but</p>
<ul>
<li>it relies on strict aliasing</li>
<li>it is currently incompatible with LLVM</li>
</ul>
<p>as long as those remain open, I dont think it is a useful model for Rust</p>



<a name="277301245"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277301245" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277301245">(Mar 31 2022 at 15:45)</a>:</h4>
<p>Or maybe some people need e.g. pointer compression for some application</p>



<a name="277301326"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277301326" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277301326">(Mar 31 2022 at 15:46)</a>:</h4>
<p>I think we can have int2ptr2int in a Rust way and we shouldnt just copy what C does</p>



<a name="277301422"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277301422" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277301422">(Mar 31 2022 at 15:47)</a>:</h4>
<p>I think we pretty much agree. I want mostly the strict_provenance execution model. I just want it in a way that integrates okay with old / loose code (you just lose all the formal specification)</p>



<a name="277301504"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277301504" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277301504">(Mar 31 2022 at 15:47)</a>:</h4>
<p>so, like <a href="https://github.com/rust-lang/rust/issues/95228#issuecomment-1084037392">https://github.com/rust-lang/rust/issues/95228#issuecomment-1084037392</a> ? ;)</p>



<a name="277301963"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277301963" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277301963">(Mar 31 2022 at 15:51)</a>:</h4>
<p>Pretty much! But (assuming LLVM will switch to PNVI) I want extra optimizations as well that are opt-in per crate.</p>



<a name="277302112"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277302112" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277302112">(Mar 31 2022 at 15:52)</a>:</h4>
<p>Opt-in per crate doesn't really work though, since Rust will inline things from one crate into another crate, and really relies on this for zero-cost abstractions to work.</p>



<a name="277302124"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277302124" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277302124">(Mar 31 2022 at 15:52)</a>:</h4>
<p>Not to mention the issue of cross-language LTO.</p>



<a name="277302496"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277302496" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dan Gohman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277302496">(Mar 31 2022 at 15:55)</a>:</h4>
<p>Opt-in per crate would be more about opt-in within in the ecosystem, than within a program. Crate authors could opt in, or not, and then people wanting to use the stricter model at runtime would need to ensure all their dependencies opt in, so that the whole program agrees.</p>



<a name="277302584"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277302584" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277302584">(Mar 31 2022 at 15:55)</a>:</h4>
<p>It‚Äôs not obvious to me that it can‚Äôt work. We could vary the meaning of ptrtoint (in terms of its lowering to LLVM IR) as per my GitHub comment</p>



<a name="277302591"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277302591" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Thom Chiovoloni <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277302591">(Mar 31 2022 at 15:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277301326">said</a>:</p>
<blockquote>
<p>I think we can have int2ptr2int in a Rust way and we shouldnt just copy what C does</p>
</blockquote>
<p>What about ptr2int2ptr?</p>
<p>I think int2ptr2int basically has to work, since it's doable from fully safe code -- maybe we can say it's nondeterministic, but that would honestly be very surprising.</p>



<a name="277302670"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277302670" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277302670">(Mar 31 2022 at 15:56)</a>:</h4>
<p>To expose its input only when the crate is PVNI</p>



<a name="277302722"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277302722" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277302722">(Mar 31 2022 at 15:56)</a>:</h4>
<p>This is assuming C/C++ settle on some variant of PVNI-AE</p>



<a name="277302823"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277302823" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277302823">(Mar 31 2022 at 15:57)</a>:</h4>
<p>If we're going to do that, it doesn't need to be a per-crate flag.  We could just say that "<code>.addr()</code> doesn't expose its input, but legacy <code>as usize</code> does".</p>



<a name="277303208"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277303208" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277303208">(Mar 31 2022 at 16:00)</a>:</h4>
<p>Ah, yes. Very nice</p>



<a name="277303660"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277303660" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277303660">(Mar 31 2022 at 16:02)</a>:</h4>
<blockquote>
<p>What about ptr2int2ptr? I think int2ptr2int basically has to work, since it's doable from fully safe code -- maybe we can say it's nondeterministic, but that would honestly be very surprising.</p>
</blockquote>
<p>What do you mean by "work"? You certainly can't dereference pointers in safe code, and the UB here is only when you dereference a pointer - you can still create invalid pointers under strict provenance.</p>



<a name="277304298"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277304298" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277304298">(Mar 31 2022 at 16:06)</a>:</h4>
<p>I guess we all agree that int2ptr2int is fine (cannot cause UB). I think we also agree that you should get the original int back (‚Äúdeterministic‚Äù?).</p>
<p>IIUC we‚Äôre trying to make ptr2int2ptr work in certain cases for code that cannot be strict.</p>



<a name="277305681"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277305681" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277305681">(Mar 31 2022 at 16:15)</a>:</h4>
<p><span class="user-mention" data-user-id="120791">@RalfJ</span> </p>
<blockquote>
<p>so, like <a href="https://github.com/rust-lang/rust/issues/95228#issuecomment-1084037392">https://github.com/rust-lang/rust/issues/95228#issuecomment-1084037392</a> ? ;)</p>
</blockquote>
<p>That certainly makes sense to me as the "most incremental" step that could be taken next, and it allows us to answer the question "is this unsafe code sound?" with a definite "yes" in more cases, but it doesn't help answer the question "is this optimization pass sound?" with a "yes" in more cases.</p>
<p>My suggestion of explicitly defining optimization levels based on which provenance model can be used, could be the next step after that, which might be more palatable than fully committing to strict provenance. I don't think it would be good if we stayed permanently in the limbo of being unable to answer if some programs are UB.</p>



<a name="277306312"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277306312" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277306312">(Mar 31 2022 at 16:21)</a>:</h4>
<p>I think it's important to distinguish two things: what LLVM does today and what LLVM hypothetically could do.</p>



<a name="277306367"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277306367" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277306367">(Mar 31 2022 at 16:21)</a>:</h4>
<p>Right now I suspect LLVM's optimizations are not sound even for code that follows strict_provenance (although I can't prove it).</p>



<a name="277306459"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277306459" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277306459">(Mar 31 2022 at 16:22)</a>:</h4>
<p>And there's little bandwidth from the Rust side to work on this, and from the LLVM core side, they want to adopt a sound model for C but it's not particularly urgent.</p>



<a name="277306564"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277306564" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277306564">(Mar 31 2022 at 16:23)</a>:</h4>
<p>Actually, I can prove it: AFAIK LLVM does global value numbering on pointers and that messes up provenance.</p>



<a name="277306824"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277306824" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277306824">(Mar 31 2022 at 16:25)</a>:</h4>
<p>Making LLVM sound for any of strict_provenance, PNVI, or "PNVI without strict aliasing" would result in some loss of optimization potential.  We know the loss is probably minimal in the case of strict_provenance.  We also know that PNVI should be easier to optimize than "PNVI without strict aliasing" because of issues like being unable to remove dead loads.  But we don't really know how much optimization potential is lost in each case.  Personally I've never actually written a compiler optimization, but I suspect even a true expert wouldn't know for sure without trying to implement it.</p>



<a name="277307043"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277307043" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277307043">(Mar 31 2022 at 16:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="295632">Diggsey</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277305681">said</a>:</p>
<blockquote>
<p>My suggestion of explicitly defining optimization levels based on which provenance model can be used, could be the next step after that, which might be more palatable than fully committing to strict provenance. I don't think it would be good if we stayed permanently in the limbo of being unable to answer if some programs are UB.</p>
</blockquote>
<p>If we have separate functions for <code>strict_ptr2int</code> and <code>pnvi_ae_ptr2int</code>, then we can specify UB precisely for all programs that don't use <code>pnvi_ae_ptr2int</code></p>



<a name="277307132"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277307132" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277307132">(Mar 31 2022 at 16:27)</a>:</h4>
<p>In particular, regarding "PNVI without strict aliasing", I speculated the other day about how, even if you can't literally eliminate dead stores (the same principle would apply to dead loads), you could replace them with a "might have leaked provenance" annotation, or do a different transformation‚Ä¶ But that was just speculation.  It seems possible to me that "PNVI without strict aliasing" is simply infeasible as a compiler model, but also possible that it is feasible.</p>



<a name="277307156"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277307156" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277307156">(Mar 31 2022 at 16:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="198590">comex</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277306564">said</a>:</p>
<blockquote>
<p>Actually, I can prove it: AFAIK LLVM does global value numbering on pointers and that messes up provenance.</p>
</blockquote>
<p>I would love to see this worked out in an example</p>



<a name="277307251"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277307251" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277307251">(Mar 31 2022 at 16:28)</a>:</h4>
<p>Maybe we just have to deal with the fact that nobody is going to spend the time to implement that right now, so for the foreseeable future, we just don't know.  And perhaps have to assume the worst, which is arguably what strict_provenance is.</p>



<a name="277307261"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277307261" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277307261">(Mar 31 2022 at 16:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277307156">said</a>:</p>
<blockquote>
<p>I would love to see this worked out in an example</p>
</blockquote>
<p>Sure, let me try.</p>



<a name="277307540"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277307540" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277307540">(Mar 31 2022 at 16:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="198590">comex</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277307132">said</a>:</p>
<blockquote>
<p>a "might have leaked provenance" annotation</p>
</blockquote>
<p>In my understanding, this is what <code>-ae-</code> means: they are proposing that <code>ptr2int</code> means (1) please compute an integer, (2) please mark the pointer as <code>address exposed</code></p>



<a name="277307605"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277307605" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277307605">(Mar 31 2022 at 16:31)</a>:</h4>
<p>So if LLVM wants to be sound, then it seems easy for me to have a separate instruction (variant) in LLVM IC that does only (1) and not (2)</p>



<a name="277307675"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277307675" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277307675">(Mar 31 2022 at 16:32)</a>:</h4>
<p>I used PNVI-AE-UDI because it seemed like the most promising model that allowed ptr&lt;-&gt;int round-trips, but you can substitute that with whatever "weaker than strict provenance" model makes the most sense to keep existing unsafe code working and reasonably well optimized</p>



<a name="277307754"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277307754" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277307754">(Mar 31 2022 at 16:33)</a>:</h4>
<p>Are there PNVI models on the table for C/C++ that aren't PNVI-AE?</p>



<a name="277308029"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277308029" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277308029">(Mar 31 2022 at 16:35)</a>:</h4>
<blockquote>
<p>So if LLVM wants to be sound, then it seems easy for me to have a separate instruction (variant) in LLVM IC that does only (1) and not (2)</p>
</blockquote>
<p>At some point we might actually want to be able to do optimizations assuming strict provenance though.</p>



<a name="277308129"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277308129" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277308129">(Mar 31 2022 at 16:35)</a>:</h4>
<p>Not really. WG14 is looking to move forward with PNVI-ae-udi.</p>



<a name="277308614"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277308614" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277308614">(Mar 31 2022 at 16:39)</a>:</h4>
<blockquote>
<p>At some point we might actually want to be able to do optimizations assuming strict provenance though.</p>
</blockquote>
<p>I mean we could presumably always enable those optimizations, if they just shut themselves down whenever <code>pvni_ae_ptr2int</code> appears nearby</p>



<a name="277308647"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277308647" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277308647">(Mar 31 2022 at 16:39)</a>:</h4>
<p>So the optimizations could work on parts of a translation unit</p>



<a name="277308748"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277308748" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277308748">(Mar 31 2022 at 16:40)</a>:</h4>
<p>Well "nearby" is the problem. The optimizations don't work if <code>pvni_ae_ptr2int</code> is used anywhere in the program, not just "nearby".</p>



<a name="277308810"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277308810" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277308810">(Mar 31 2022 at 16:41)</a>:</h4>
<p>And by "don't work" I mean, they are unsound - may change the program into one that does something completely different</p>



<a name="277309056"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277309056" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277309056">(Mar 31 2022 at 16:43)</a>:</h4>
<p>Really? What kind of optimization are you thinking about?</p>



<a name="277309254"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277309254" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277309254">(Mar 31 2022 at 16:45)</a>:</h4>
<p>presumably strict provenance means that int2ptr cannot be used to access memory even if pointers to that memory went into "unknown code"</p>



<a name="277309462"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277309462" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277309462">(Mar 31 2022 at 16:47)</a>:</h4>
<p>so something like this I'm guessing?</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span> <span class="nf">example</span><span class="p">(</span><span class="n">opaque</span>: <span class="nc">fn</span><span class="p">(</span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">ptr</span>::<span class="n">addr_of_mut</span><span class="o">!</span><span class="p">(</span><span class="n">x</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">addr</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>



<a name="277309487"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277309487" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277309487">(Mar 31 2022 at 16:47)</a>:</h4>
<p>Correct, strict provenance means that int2ptr pointers cannot be used to access memory</p>



<a name="277309633"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277309633" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277309633">(Mar 31 2022 at 16:48)</a>:</h4>
<p>now that example feels silly because of the int2ptr cast and I just mentioned strict provenance... but I think some variation on it must be relevant</p>



<a name="277309638"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277309638" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277309638">(Mar 31 2022 at 16:48)</a>:</h4>
<p><span class="user-mention" data-user-id="465167">@Bram Geron</span> Here is an example of how LLVM currently does global value numbering on pointers in a way that's unsound, even with no pointer-integer casts involved: <a href="https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2021&amp;gist=65a08ab926a212da05b2577c62b6c0fb">https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2021&amp;gist=65a08ab926a212da05b2577c62b6c0fb</a></p>



<a name="277309805"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277309805" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277309805">(Mar 31 2022 at 16:50)</a>:</h4>
<p>wait, GVN takes <code>icmp</code>s into account?</p>



<a name="277309903"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277309903" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277309903">(Mar 31 2022 at 16:51)</a>:</h4>
<p>are you saying that inside <code>if xs.len() == 5 {...}</code> every further use of <code>xs.len()</code> would be replaced with <code>5</code> by GVN itself? that's... IMO very strange interpretation of what "GVN" means on LLVM's part</p>



<a name="277310111"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277310111" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277310111">(Mar 31 2022 at 16:52)</a>:</h4>
<p>presumably this is one of those things where LLVM overloading things too much leads to "type confusion". <code>==</code> should probably be something like <code>ptr_addr_cmp</code>, and <em>not</em> be considered to imply anything about the pointers as a whole (tho ideally LLVM should just encode the <code>.addr()</code> operation directly and maybe use <code>icmp</code> on that - I wonder what CHERI does here?)</p>



<a name="277310189"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277310189" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277310189">(Mar 31 2022 at 16:53)</a>:</h4>
<p>Actually, I'm not sure if it calls it GVN; in that case it's <code>SimplifyCFGPass</code> that does the simplification.</p>



<a name="277310194"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277310194" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277310194">(Mar 31 2022 at 16:53)</a>:</h4>
<p>len is a usize, not a pointer. I don‚Äôt see why it wouldn‚Äôt participate in GVN</p>



<a name="277310348"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277310348" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277310348">(Mar 31 2022 at 16:55)</a>:</h4>
<p>GVN's job is to deduplicate (pure) <em>work</em>, so it should turn:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">if</span><span class="w"> </span><span class="n">xs</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xs</span><span class="p">.</span><span class="n">len</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>into:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xs</span><span class="p">.</span><span class="n">len</span><span class="p">();</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">len</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>



<a name="277310350"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277310350" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277310350">(Mar 31 2022 at 16:55)</a>:</h4>
<p>Oops, I lied.</p>



<a name="277310368"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277310368" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277310368">(Mar 31 2022 at 16:55)</a>:</h4>
<p>It's <code>InstCombinePass</code>.</p>



<a name="277310388"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277310388" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277310388">(Mar 31 2022 at 16:55)</a>:</h4>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="o">***</span><span class="w"> </span><span class="n">IR</span><span class="w"> </span><span class="n">Dump</span><span class="w"> </span><span class="n">After</span><span class="w"> </span><span class="n">SimplifyCFGPass</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">_ZN9stale_ptr12write_to_one17h13990181c4a3c8eeE</span><span class="w"> </span><span class="o">***</span><span class="w"></span>
<span class="p">;</span><span class="w"> </span><span class="n">Function</span><span class="w"> </span><span class="n">Attrs</span>: <span class="nc">mustprogress</span><span class="w"> </span><span class="n">nofree</span><span class="w"> </span><span class="n">norecurse</span><span class="w"> </span><span class="n">nosync</span><span class="w"> </span><span class="n">nounwind</span><span class="w"> </span><span class="n">uwtable</span><span class="w"> </span><span class="n">willreturn</span><span class="w"> </span><span class="n">writeonly</span><span class="w"></span>
<span class="n">define</span><span class="w"> </span><span class="n">internal</span><span class="w"> </span><span class="n">fastcc</span><span class="w"> </span><span class="n">noundef</span><span class="w"> </span><span class="n">zeroext</span><span class="w"> </span><span class="n">i1</span><span class="w"> </span><span class="o">@</span><span class="n">_ZN9stale_ptr12write_to_one17h13990181c4a3c8eeE</span><span class="p">(</span><span class="kt">i32</span><span class="o">*</span><span class="w"> </span><span class="n">writeonly</span><span class="w"> </span><span class="o">%</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="o">*</span><span class="w"> </span><span class="n">writeon</span><span class="w"></span>
<span class="n">ly</span><span class="w"> </span><span class="o">%</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">unnamed_addr</span><span class="w"> </span>#<span class="mi">7</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="o">%</span><span class="mi">3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">icmp</span><span class="w"> </span><span class="n">eq</span><span class="w"> </span><span class="kt">i32</span><span class="o">*</span><span class="w"> </span><span class="o">%</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="mi">1</span><span class="w"></span>
<span class="w">  </span><span class="o">%</span><span class="mi">4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">select</span><span class="w"> </span><span class="n">i1</span><span class="w"> </span><span class="o">%</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="o">*</span><span class="w"> </span><span class="o">%</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="o">*</span><span class="w"> </span><span class="o">%</span><span class="mi">1</span><span class="w"></span>
<span class="w">  </span><span class="n">store</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="mi">200</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="o">*</span><span class="w"> </span><span class="o">%</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">align</span><span class="w"> </span><span class="mi">4</span><span class="w"></span>
<span class="w">  </span><span class="n">ret</span><span class="w"> </span><span class="n">i1</span><span class="w"> </span><span class="o">%</span><span class="mi">3</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="o">***</span><span class="w"> </span><span class="n">IR</span><span class="w"> </span><span class="n">Dump</span><span class="w"> </span><span class="n">After</span><span class="w"> </span><span class="n">InstCombinePass</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">_ZN9stale_ptr12write_to_one17h13990181c4a3c8eeE</span><span class="w"> </span><span class="o">***</span><span class="w"></span>
<span class="p">;</span><span class="w"> </span><span class="n">Function</span><span class="w"> </span><span class="n">Attrs</span>: <span class="nc">mustprogress</span><span class="w"> </span><span class="n">nofree</span><span class="w"> </span><span class="n">norecurse</span><span class="w"> </span><span class="n">nosync</span><span class="w"> </span><span class="n">nounwind</span><span class="w"> </span><span class="n">uwtable</span><span class="w"> </span><span class="n">willreturn</span><span class="w"> </span><span class="n">writeonly</span><span class="w"></span>
<span class="n">define</span><span class="w"> </span><span class="n">internal</span><span class="w"> </span><span class="n">fastcc</span><span class="w"> </span><span class="n">noundef</span><span class="w"> </span><span class="n">zeroext</span><span class="w"> </span><span class="n">i1</span><span class="w"> </span><span class="o">@</span><span class="n">_ZN9stale_ptr12write_to_one17h13990181c4a3c8eeE</span><span class="p">(</span><span class="kt">i32</span><span class="o">*</span><span class="w"> </span><span class="n">writeonly</span><span class="w"> </span><span class="o">%</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="o">*</span><span class="w"> </span><span class="n">writeon</span><span class="w"></span>
<span class="n">ly</span><span class="w"> </span><span class="o">%</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">unnamed_addr</span><span class="w"> </span>#<span class="mi">7</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="o">%</span><span class="mi">3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">icmp</span><span class="w"> </span><span class="n">eq</span><span class="w"> </span><span class="kt">i32</span><span class="o">*</span><span class="w"> </span><span class="o">%</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="mi">1</span><span class="w"></span>
<span class="w">  </span><span class="n">store</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="mi">200</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="o">*</span><span class="w"> </span><span class="o">%</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">align</span><span class="w"> </span><span class="mi">4</span><span class="w"></span>
<span class="w">  </span><span class="n">ret</span><span class="w"> </span><span class="n">i1</span><span class="w"> </span><span class="o">%</span><span class="mi">3</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>



<a name="277310591"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277310591" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277310591">(Mar 31 2022 at 16:57)</a>:</h4>
<p>(whereas replacing <code>y = len</code> with <code>y = 5</code> is some form of predicated reasoning. I'm not sure what it's typically called but you can generally "assume" a condition holds true on paths that require that condition to hold, and that can have a plethora of consequences)</p>



<a name="277310621"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277310621" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277310621">(Mar 31 2022 at 16:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="198590">comex</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277310368">said</a>:</p>
<blockquote>
<p>It's <code>InstCombinePass</code>.</p>
</blockquote>
<p>ah hah, looks like a <code>select (icmp eq x, y), x, y</code> to <code>y</code> rule</p>



<a name="277310683"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277310683" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277310683">(Mar 31 2022 at 16:58)</a>:</h4>
<p>so yeah the issue is the overload of <code>icmp</code>. presumably it doesn't even bother checking any types</p>



<a name="277311009"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277311009" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277311009">(Mar 31 2022 at 17:00)</a>:</h4>
<p>But‚Ä¶ it looks like LLVM's 'GVN' pass can do something like that as well.  This is from <code>lib/Transforms/Scalar/GVN.cpp</code>:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="w">  </span><span class="c1">// If we find an equality fact, canonicalize all dominated uses in this block</span>
<span class="w">  </span><span class="c1">// to one of the two values.  We heuristically choice the "oldest" of the</span>
<span class="w">  </span><span class="c1">// two where age is determined by value number. (Note that propagateEquality</span>
<span class="w">  </span><span class="c1">// above handles the cross block case.)</span>
<span class="w">  </span><span class="c1">//</span>
<span class="w">  </span><span class="c1">// Key case to cover are:</span>
<span class="w">  </span><span class="c1">// 1)</span>
<span class="w">  </span><span class="c1">// %cmp = fcmp oeq float 3.000000e+00, %0 ; const on lhs could happen</span>
<span class="w">  </span><span class="c1">// call void @llvm.assume(i1 %cmp)</span>
<span class="w">  </span><span class="c1">// ret float %0 ; will change it to ret float 3.000000e+00</span>
<span class="w">  </span><span class="c1">// 2)</span>
<span class="w">  </span><span class="c1">// %load = load float, float* %addr</span>
<span class="w">  </span><span class="c1">// %cmp = fcmp oeq float %load, %0</span>
<span class="w">  </span><span class="c1">// call void @llvm.assume(i1 %cmp)</span>
<span class="w">  </span><span class="c1">// ret float %load ; will change it to ret float %0</span>
</code></pre></div>



<a name="277312584"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277312584" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277312584">(Mar 31 2022 at 17:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="209168">Thom Chiovoloni</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277302591">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277301326">said</a>:</p>
<blockquote>
<p>I think we can have int2ptr2int in a Rust way and we shouldnt just copy what C does</p>
</blockquote>
<p>What about ptr2int2ptr?</p>
<p>I think int2ptr2int basically has to work, since it's doable from fully safe code -- maybe we can say it's nondeterministic, but that would honestly be very surprising.</p>
</blockquote>
<p>sorry, I meant ptr2int2ptr</p>



<a name="277312654"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277312654" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277312654">(Mar 31 2022 at 17:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="198590">comex</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277311009">said</a>:</p>
<blockquote>
<p>But‚Ä¶ it looks like LLVM's 'GVN' pass can do something like that as well.  This is from <code>lib/Transforms/Scalar/GVN.cpp</code>:</p>
</blockquote>
<p>oh dear, <code>llvm.assume</code> is even wilder than branch predication</p>



<a name="277312717"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277312717" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277312717">(Mar 31 2022 at 17:15)</a>:</h4>
<p><span class="user-mention" data-user-id="465167">@Bram Geron</span> </p>
<blockquote>
<p>Bram Geron: Really? What kind of optimization are you thinking about?</p>
</blockquote>
<p>For example:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="n">cond</span>: <span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="n">arg</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">total</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="p">.</span><span class="mi">1000000</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">cond</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">total</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">arg</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">total</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="o">*</span><span class="n">int2ptr</span><span class="p">(</span><span class="n">arg</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">total</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>Let's assume this results through inlining or something - obviously you wouldn't write this code by hand. With strict provenance you can optimize this to just multiplying <code>arg</code> by 1000000. Under weaker models you can't because <code>arg</code> may have originated from <code>ptr2int</code> to a large enough array.</p>



<a name="277312898"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277312898" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277312898">(Mar 31 2022 at 17:16)</a>:</h4>
<p><span class="user-mention silent" data-user-id="198590">comex</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277306367">said</a>:</p>
<blockquote>
<p>Right now I suspect LLVM's optimizations are not sound even for code that follows strict_provenance (although I can't prove it).</p>
</blockquote>
<p>I think it might be fine actually. all the nasty examples I am ware of rely on ptr2int2ptr.</p>



<a name="277313059"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277313059" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277313059">(Mar 31 2022 at 17:17)</a>:</h4>
<blockquote>
<p>That certainly makes sense to me as the "most incremental" step that could be taken next, and it allows us to answer the question "is this unsafe code sound?" with a definite "yes" in more cases, but it doesn't help answer the question "is this optimization pass sound?" with a "yes" in more cases.</p>
</blockquote>
<p>Well, yeah.<br>
But I don't think having <em>two different memory models</em> with a per-crate choice is going to make anything any simpler. cross-memory-model interactions is a hugely complicated subject. it would probably be easier to work out the memory model with ptr2int2ptr roundtrips than to work out this hybrid thing.</p>



<a name="277313194"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277313194" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277313194">(Mar 31 2022 at 17:18)</a>:</h4>
<p>Cross-crate memory model means that the implementation needs to support the union of all of them at once.</p>



<a name="277313210"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277313210" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277313210">(Mar 31 2022 at 17:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="198590">comex</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277306564">said</a>:</p>
<blockquote>
<p>Actually, I can prove it: AFAIK LLVM does global value numbering on pointers and that messes up provenance.</p>
</blockquote>
<p>oh yeah, there's that. that is still unsound and they know it for years and don't fix it<br>
<a href="https://bugs.llvm.org/show_bug.cgi?id=35229">https://bugs.llvm.org/show_bug.cgi?id=35229</a><br>
I love how that bug got retitled from my "LLVM miscompiles program with ptr comparison" to "memory model needs more rigor" <span aria-label="joy" class="emoji emoji-1f602" role="img" title="joy">:joy:</span></p>



<a name="277313282"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277313282" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277313282">(Mar 31 2022 at 17:19)</a>:</h4>
<p>As long as strict provenance <em>is</em> strictly stricter than the weaker model, and the decision is made for the whole crate graph then I don't see why you'd need to worry about interactions between the two models.</p>



<a name="277313389"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277313389" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277313389">(Mar 31 2022 at 17:19)</a>:</h4>
<p>I suppose you might have to worry about MIR optimizations</p>



<a name="277313546"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277313546" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277313546">(Mar 31 2022 at 17:21)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277313194">said</a>:</p>
<blockquote>
<p>Cross-crate memory model means that the implementation needs to support the union of all of them at once.</p>
</blockquote>
<p>except that "union" is not even a well-defined term here</p>



<a name="277313567"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277313567" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277313567">(Mar 31 2022 at 17:21)</a>:</h4>
<p>it's more like their product. but in a way that they stay coherently in sync.</p>



<a name="277313622"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277313622" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277313622">(Mar 31 2022 at 17:21)</a>:</h4>
<p>And while you could have a separate flag, I was imaging something possibly tied to edition, so eg. we bring in strict provenance with edition 2025, and then if any crates are on prior editions we only run optimizations that are compatible with the weaker memory model.</p>



<a name="277313656"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277313656" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277313656">(Mar 31 2022 at 17:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="295632">Diggsey</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277313282">said</a>:</p>
<blockquote>
<p>As long as strict provenance <em>is</em> strictly stricter than the weaker model, and the decision is made for the whole crate graph then I don't see why you'd need to worry about interactions between the two models.</p>
</blockquote>
<p>yes sorry some people are saying this should be a per-crate thing. if it's a whole-program thing it works. but it means we have two language dialects.</p>



<a name="277313696"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277313696" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277313696">(Mar 31 2022 at 17:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="119009">eddyb</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277309462">said</a>:</p>
<blockquote>
<p>so something like this I'm guessing?</p>
<p><div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span> <span class="nf">example</span><span class="p">(</span><span class="n">opaque</span>: <span class="nc">fn</span><span class="p">(</span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">ptr</span>::<span class="n">addr_of_mut</span><span class="o">!</span><span class="p">(</span><span class="n">x</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">addr</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><br>
</p>
</blockquote>
<p>ah wait I can fix this, lol:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span> <span class="nf">example</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">ptr2int</span>: <span class="nc">fn</span><span class="p">(</span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">int2ptr</span>: <span class="nc">fn</span><span class="p">(</span><span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"></span>
<span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptr2int</span><span class="p">(</span><span class="n">ptr</span>::<span class="n">addr_of_mut</span><span class="o">!</span><span class="p">(</span><span class="n">x</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">*</span><span class="n">int2ptr</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>



<a name="277313734"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277313734" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277313734">(Mar 31 2022 at 17:22)</a>:</h4>
<p>which is I guess what the other example was doing</p>



<a name="277313771"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277313771" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277313771">(Mar 31 2022 at 17:22)</a>:</h4>
<p>though, funnily enough, that actually can't be optimized</p>



<a name="277313812"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277313812" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277313812">(Mar 31 2022 at 17:23)</a>:</h4>
<p>because you could emulate a global <code>BTreeMap&lt;usize, *mut u8&gt;</code> or w/e</p>



<a name="277313892"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277313892" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277313892">(Mar 31 2022 at 17:23)</a>:</h4>
<p>so in some sense, strict provenance still allows some modular reasoning without explicit knowledge of "lurking" ptr2int2ptr</p>



<a name="277313907"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277313907" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277313907">(Mar 31 2022 at 17:23)</a>:</h4>
<blockquote>
<p>but it means we have two language dialects</p>
</blockquote>
<p>Well.. we already have no_std/std crates. I think as long as we keep a strict hierarchy (ie. everything that works with strict provenance also works without it) then it's an acceptable cost in order to maintain backwards compatibility, whilst also allowing us to get real benefits from strict provenance</p>



<a name="277314026"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277314026" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277314026">(Mar 31 2022 at 17:24)</a>:</h4>
<p>(as long as the ptr2int2ptr model can be "emulated", which <em>some</em> can, though accurate allocation ranges aren't directly available without e.g. CHERI metadata)</p>



<a name="277314200"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277314200" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277314200">(Mar 31 2022 at 17:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="295632">Diggsey</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277313622">said</a>:</p>
<blockquote>
<p>And while you could have a separate flag, I was imaging something possibly tied to edition, so eg. we bring in strict provenance with edition 2025, and then if any crates are on prior editions we only run optimizations that are compatible with the weaker memory model.</p>
</blockquote>
<p>"any" being a predicate only Cargo can compute, and then rustc just enforces that the choice is globally uniform (i.e. cannot depend on a crate with a different setting)?</p>



<a name="277314281"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277314281" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277314281">(Mar 31 2022 at 17:26)</a>:</h4>
<p>that's not really practical -- it means no codegen until the final binary is produced</p>



<a name="277314305"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277314305" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277314305">(Mar 31 2022 at 17:27)</a>:</h4>
<p>also some crates have extreme MSRV and will probably never go to a new edition</p>



<a name="277314449"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277314449" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277314449">(Mar 31 2022 at 17:28)</a>:</h4>
<p>you can do codegen before but only if what I described happens (Cargo computes the "worst case" and rustc forces much stricter "everything must agree" semantics)</p>



<a name="277314471"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277314471" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277314471">(Mar 31 2022 at 17:28)</a>:</h4>
<p>it still isn't great though</p>



<a name="277315011"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277315011" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277315011">(Mar 31 2022 at 17:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277313210">said</a>:<br>
oh yeah, there's that. that is still unsound and they know it for years and don't fix it<br>
<a href="https://bugs.llvm.org/show_bug.cgi?id=35229">https://bugs.llvm.org/show_bug.cgi?id=35229</a></p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">So</span><span class="w"> </span><span class="err">‚Äî</span><span class="w"> </span><span class="n">maybe</span><span class="w"> </span><span class="n">realistically</span><span class="w"> </span><span class="n">we</span><span class="w"> </span><span class="n">can</span><span class="w"> </span><span class="n">only</span><span class="w"> </span><span class="n">have</span><span class="w"> </span><span class="err">`</span><span class="n">strict_provenance</span><span class="err">`</span><span class="o">-</span><span class="n">specific</span><span class="w"> </span><span class="n">optimizations</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">MIR</span><span class="w"> </span><span class="n">level</span><span class="w"> </span>:<span class="nc">thinking</span>:
</code></pre></div>



<a name="277315306"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277315306" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277315306">(Mar 31 2022 at 17:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="295632">Diggsey</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277312717">said</a>:</p>
<blockquote>
<blockquote>
<p>Bram Geron: Really? What kind of optimization are you thinking about?</p>
</blockquote>
<p>For example: [example]</p>
</blockquote>
<p>I think you could optimize this to <code>arg*1000000</code> without any global toggle, because <code>*strict_int2ptr(..)</code> is just plain UB so the if..then..else goes away. This seems feasible on the MIR level as well.</p>



<a name="277315401"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277315401" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277315401">(Mar 31 2022 at 17:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="119009">eddyb</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277314449">said</a>:</p>
<blockquote>
<p>you can do codegen before but only if what I described happens (Cargo computes the "worst case" and rustc forces much stricter "everything must agree" semantics)</p>
</blockquote>
<p>well it's somewhat non-trivial to argue that a codegen pass is correct under both semantics. you basically need to have two separate correctness arguments then...</p>



<a name="277315474"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277315474" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277315474">(Mar 31 2022 at 17:37)</a>:</h4>
<blockquote>
<p>So ‚Äî maybe realistically we can only have <code>strict_provenance</code>-specific optimizations on the MIR level <span aria-label="thinking" class="emoji emoji-1f914" role="img" title="thinking">:thinking:</span></p>
</blockquote>
<p>no, we just need to get LLVM to fix their stuff if this becomes a problem</p>



<a name="277315511"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277315511" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277315511">(Mar 31 2022 at 17:37)</a>:</h4>
<p>everything in the LLVM LangRef indicates that strict provenance is compatible with LLVM, they don't have an excuse here</p>



<a name="277315621"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277315621" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277315621">(Mar 31 2022 at 17:38)</a>:</h4>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277315306">said</a>:</p>
<blockquote>
<p>I think you could optimize this to <code>arg*1000000</code> without any global toggle, because <code>*strict_int2ptr(..)</code> is just plain UB so the if..then..else goes away. This seems feasible on the MIR level as well.</p>
</blockquote>
<p>Again, my goal is to support both PNVI-AE and <code>strict</code> crates inside the PNVI-AE memory model, by just extending PNVI-AE with a non-exposing int2ptr</p>



<a name="277315661"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277315661" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277315661">(Mar 31 2022 at 17:39)</a>:</h4>
<p>So no union or product of memory models needed</p>



<a name="277315702"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277315702" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277315702">(Mar 31 2022 at 17:39)</a>:</h4>
<p>But that means any implementation needs to support PNVI-ae, instead of just supporting strict-provenance.</p>



<a name="277315872"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277315872" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277315872">(Mar 31 2022 at 17:40)</a>:</h4>
<p>Which effectively means that all implementations are PNVI-ae, and not strict-provenance, it just pretending for some crates to be strict-provenance.</p>



<a name="277315879"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277315879" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277315879">(Mar 31 2022 at 17:40)</a>:</h4>
<p>I mean realistically any implementation needs to support both anyways because of C (sigh).</p>



<a name="277315886"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277315886" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277315886">(Mar 31 2022 at 17:41)</a>:</h4>
<p>And there, what's the point?</p>



<a name="277315906"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277315906" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277315906">(Mar 31 2022 at 17:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="303115">Quy Nguyen</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277315879">said</a>:</p>
<blockquote>
<p>I mean realistically any implementation needs to support both anyways because of C (sigh).</p>
</blockquote>
<p>I mean, you could have a just-rust implementation.</p>



<a name="277315914"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277315914" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277315914">(Mar 31 2022 at 17:41)</a>:</h4>
<p>Correct.</p>
<p>I think <code>rustc</code> cannot ditch PNVI-AE without massive backwards incompatibility*.</p>
<p>*backwards compatibility can't formally be defined because we don't have a formal spec</p>



<a name="277316041"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277316041" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277316041">(Mar 31 2022 at 17:42)</a>:</h4>
<p>Also, still supporting PNVI-ae means we rule out CHERI.</p>



<a name="277316077"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277316077" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277316077">(Mar 31 2022 at 17:42)</a>:</h4>
<p>Which I'm pretty sure was the whole point.</p>



<a name="277316081"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277316081" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277316081">(Mar 31 2022 at 17:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="119009">eddyb</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277313696">said</a>:</p>
<blockquote>
<p>ah wait I can fix this, lol</p>
</blockquote>
<p>I think this code is also UB in <code>strict_provenance</code></p>



<a name="277316406"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277316406" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277316406">(Mar 31 2022 at 17:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277315906">said</a>:</p>
<blockquote>
<p>I mean, you could have a just-rust implementation.</p>
</blockquote>
<p>I don't think it's possible to have a just-rust implementation of OS primitives.</p>



<a name="277316545"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277316545" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277316545">(Mar 31 2022 at 17:46)</a>:</h4>
<p>1) Not on current systems, no.<br>
2) I'm referring to something that will never see non-Rust code as anything other than a pure black_box.</p>



<a name="277316570"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277316570" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277316570">(Mar 31 2022 at 17:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277315906">said</a>:</p>
<blockquote>
<p>I mean, you could have a just-rust implementation.</p>
</blockquote>
<p>I feel like something like this is an instance where you could have this as an extension to the Rust standard.</p>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277316406">said</a>:</p>
<blockquote>
<p>I don't think it's possible to have a just-rust implementation of OS primitives.</p>
</blockquote>
<p>Mustang and relibc/redox beg to differ.</p>



<a name="277316618"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277316618" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277316618">(Mar 31 2022 at 17:47)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277316041">said</a>:</p>
<blockquote>
<p>Also, still supporting PNVI-ae means we rule out CHERI.</p>
</blockquote>
<p>That's not my understanding. IIUC CHERI can be made to support PNVI-ae, but any pointer that may come from <code>pvni_ae_int2ptr</code> must be dereferenced in an incredibly slow way</p>



<a name="277316674"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277316674" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277316674">(Mar 31 2022 at 17:47)</a>:</h4>
<p>Which means if you <em>don't</em> use <code>pvni_ae_int2ptr</code>, then everything is fast as normal on CHERI</p>



<a name="277316749"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277316749" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277316749">(Mar 31 2022 at 17:48)</a>:</h4>
<p>I think there's value in teaching and simplicity for pure Rust crates to have strict provenance even if the implementation might be using platform provenance semantics.</p>



<a name="277316803"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277316803" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277316803">(Mar 31 2022 at 17:48)</a>:</h4>
<p>I thought that one of the features of CHERI is the fact that one a pointer goes invalid, it doesn't get restored.</p>



<a name="277317047"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277317047" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277317047">(Mar 31 2022 at 17:50)</a>:</h4>
<p>For example, one could maybe polyfill inttoptr casts in CHERI with broadcast semantics, a <code>TreeMap</code>, and a bit of luck/pain/effort. Now of course no sane implementation would do that, but it might be possible.</p>



<a name="277317060"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277317060" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277317060">(Mar 31 2022 at 17:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="303115">Quy Nguyen</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277316570">said</a>:</p>
<blockquote>
<blockquote>
<p>I don't think it's possible to have a just-rust implementation of OS primitives.</p>
</blockquote>
<p>Mustang and relibc/redox beg to differ.</p>
</blockquote>
<p>Let me rephrase. Then we could only support OSes whose kernel interface is specified on the binary level. Not a generix Unix OS.</p>



<a name="277317212"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277317212" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277317212">(Mar 31 2022 at 17:51)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277316803">said</a>:</p>
<blockquote>
<p>I thought that one of the features of CHERI is the fact that one a pointer goes invalid, it doesn't get restored.</p>
</blockquote>
<p>In this scheme, the result of <code>int2ptr</code> would be an integer, which is then compared to any number of reference pointers, and provenance is restored in a complicated way just before dereferencing.</p>



<a name="277317287"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277317287" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dan Gohman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277317287">(Mar 31 2022 at 17:52)</a>:</h4>
<p>Mustang makes syscalls with inline asm, and I'm in the process of converting it to preserve provenance all the way up to the inline asm operand. Unless compilers are going to peek inside inline asm, that seems like it should be sufficient.</p>



<a name="277317383"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277317383" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277317383">(Mar 31 2022 at 17:52)</a>:</h4>
<p><span class="user-mention silent" data-user-id="404395">Dan Gohman</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277317287">said</a>:</p>
<blockquote>
<p>Mustang makes syscalls with inline asm, and I'm in the process of converting it to preserve provenance all the way up to the inline asm operand. Unless compilers are going to peek inside inline asm, that seems like it should be sufficient.</p>
</blockquote>
<p>And compilers are not allowed to rely on the content of an asm invocation,</p>



<a name="277317443"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277317443" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277317443">(Mar 31 2022 at 17:53)</a>:</h4>
<p>(To my somewhat dismay at wanting to be smart)</p>



<a name="277317573"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277317573" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277317573">(Mar 31 2022 at 17:54)</a>:</h4>
<p>And by rust-only impl I mean an implementation that sees only rust code. Everything else is just non-analyzed (no cross-lang LTO to worry about), thus it only has to worry about rust semantics, and not C, C++, FORTRAN, or w/e other semantics.</p>



<a name="277317634"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277317634" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277317634">(Mar 31 2022 at 17:54)</a>:</h4>
<p>So, uh... rustc itself (MIR opts).</p>



<a name="277317797"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277317797" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277317797">(Mar 31 2022 at 17:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="404395">Dan Gohman</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277317287">said</a>:</p>
<blockquote>
<p>Mustang makes syscalls with inline asm, and I'm in the process of converting it to preserve provenance all the way up to the inline asm operand. Unless compilers are going to peek inside inline asm, that seems like it should be sufficient.</p>
</blockquote>
<p><a href="https://developer.apple.com/library/archive/qa/qa1118/_index.html">macOS does not support static binaries</a>. So Rust-only binaries are possible for a version of macOS, but they would break on different versions.</p>



<a name="277317827"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277317827" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277317827">(Mar 31 2022 at 17:56)</a>:</h4>
<p>Oh hi Dan I didn't know you were here :P. Also, <code>extern "C"</code> functions might be in for a fun time too... I suppose a lot of this comes down to C being quite bad at being a platform type definition, due to the mixing of like XXX different C dialects.</p>



<a name="277317890"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277317890" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277317890">(Mar 31 2022 at 17:57)</a>:</h4>
<p>Maybe we could still do it just with FFI ‚Äî only linking to a C ABI. But that wouldn't help us execute in a strict-provenance memory model</p>



<a name="277317918"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277317918" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277317918">(Mar 31 2022 at 17:57)</a>:</h4>
<p>Also, not every implementation needs to be rust-only.</p>



<a name="277317949"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277317949" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277317949">(Mar 31 2022 at 17:57)</a>:</h4>
<p>And certainly not every implemenation needs to only support (transitively) only calling rust code.</p>



<a name="277318236"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277318236" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277318236">(Mar 31 2022 at 18:00)</a>:</h4>
<p>I think most of this comes down to what exact optimizations we're talking about. If Rust assumes that any function pointer argument is a strict-provenance pointer, you're in for some fun times. If you merely optimize the body of a function, via reordering or loop elimination or hoisting or w/e, that would be a lot less problematic.</p>



<a name="277319485"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277319485" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277319485">(Mar 31 2022 at 18:10)</a>:</h4>
<p><span class="user-mention silent" data-user-id="295632">Diggsey</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277313622">said</a>:</p>
<blockquote>
<p>And while you could have a separate flag, I was imaging something possibly tied to edition, so eg. we bring in strict provenance with edition 2025, and then if any crates are on prior editions we only run optimizations that are compatible with the weaker memory model.</p>
</blockquote>
<p>libc is still in the 2015 edition. libc is used by libstd, so that would mean basically every crate would only run optimizations compatible with the weaker memory model.</p>



<a name="277319538"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277319538" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277319538">(Mar 31 2022 at 18:11)</a>:</h4>
<p>On rustc at least.</p>



<a name="277319619"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277319619" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277319619">(Mar 31 2022 at 18:11)</a>:</h4>
<p>True, although many crates directly or indirectly depend on libc from <a href="http://crates.io">crates.io</a> too.</p>



<a name="277319674"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277319674" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277319674">(Mar 31 2022 at 18:12)</a>:</h4>
<p>Yeah.</p>



<a name="277320183"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277320183" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277320183">(Mar 31 2022 at 18:17)</a>:</h4>
<p>I mean, implementation-wise you can have separate crates with (these two) different provenance rules by treating them as FFI boundaries, as sorta implied, for any implementation which supports C FFI</p>



<a name="277320215"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277320215" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277320215">(Mar 31 2022 at 18:17)</a>:</h4>
<p>and "does not support platforms that don't support C" is not exactly a particularly restrictive position</p>



<a name="277320288"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277320288" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277320288">(Mar 31 2022 at 18:18)</a>:</h4>
<p>That's worse.</p>



<a name="277320310"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277320310" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277320310">(Mar 31 2022 at 18:18)</a>:</h4>
<p>How would you prevent cross-crate inlining in the presence of LTO? And what about generics that get codegened in a crate different from their definition?</p>



<a name="277320337"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277320337" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277320337">(Mar 31 2022 at 18:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277315914">said</a>:</p>
<blockquote>
<p>Correct.</p>
<p>I think <code>rustc</code> cannot ditch PNVI-AE without massive backwards incompatibility*.</p>
<p>*backwards compatibility can't formally be defined because we don't have a formal spec</p>
</blockquote>
<p>I dont see why that would be. "ditch" would imply that we would have currently adopted it which we surely don't.<br>
but I also repeat my question from before -- do you mean very specifically PNVI-ae-udi as described for C? that model just doesn't make sense for Rust, it is designed with C (and its strict aliasing) in mind.<br>
or do you mean "any kind of model that has provenance but not via integers but allows ptr2int2ptr roundtrips"? <em>that</em> we probably need for backwards compatibility, indeed.</p>



<a name="277320451"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277320451" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277320451">(Mar 31 2022 at 18:19)</a>:</h4>
<p>I mean any pnvi-ae-* model that allows for reasonable backwards compatibility guarantees. I don't care what they are in particular.</p>



<a name="277320521"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277320521" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277320521">(Mar 31 2022 at 18:20)</a>:</h4>
<p>there is a <em>huge</em> space of such models, and I dont think we should pick the one C picked. (not that that statement would even be well-typed since a C model inherently cannot answer Rust questions like which of our reference and raw ptr operations do what with the provenance.)</p>



<a name="277320591"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277320591" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277320591">(Mar 31 2022 at 18:20)</a>:</h4>
<p>like even the "ae-" terminology is already not applicable for a Rust aliasing model, whee "exposed" can't just be a <code>bool</code> but needs to be more tightly integrated</p>



<a name="277320608"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277320608" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277320608">(Mar 31 2022 at 18:20)</a>:</h4>
<p>(as it would have to be for <code>restrict</code> as well)</p>



<a name="277320622"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277320622" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Thom Chiovoloni <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277320622">(Mar 31 2022 at 18:21)</a>:</h4>
<blockquote>
<p>or do you mean "any kind of model that has provenance but not via integers but allows ptr2int2ptr roundtrips"? that we probably need for backwards compatibility, indeed.</p>
</blockquote>
<p>I'm really just glad that this is being agreed on. I think a lot of the, erm, "heat" in the last discussion was from it seeming like there was disagreement here.</p>



<a name="277320686"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277320686" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277320686">(Mar 31 2022 at 18:21)</a>:</h4>
<p><span class="user-mention silent" data-user-id="133247">bjorn3</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277320310">said</a>:</p>
<blockquote>
<p>How would you prevent cross-crate inlining in the presence of LTO? And what about generics that get codegened in a crate different from their definition?</p>
</blockquote>
<p>I mean, all of that is absolutely easily describable/implementable via ugliness - it's an ABI parameter that is part of the mangled name and gets codegenned separately for each. And LTO has to treat this as a boundary in the same way that any theoretical/experimental cross-lang LTO would, probably at least to start with via being separate compiler invocations.</p>



<a name="277320814"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277320814" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277320814">(Mar 31 2022 at 18:22)</a>:</h4>
<p>My view is it's easiest if</p>
<ul>
<li>Rust adopts some pnvi-ae memory model, and we separate <code>{pnvi_ae,strict}_ptr2int</code> and<code>{pnvi_ae,strict}_int2ptr</code></li>
<li>We make a formal specification for the sublanguage that forbids <code>pnvi_ae_*</code></li>
<li>In MIR, we e.g. color allocations green when we know for sure  <code>pnvi_ae_ptr2int</code> won't be called on it. Function arguments can't be green.</li>
<li>On MIR, we may do stronger alias analysis on green allocations</li>
<li>On MIR, we optimize read and write to <code>pnvi_ae_int2ptr(..)</code> to UB. This handles <span class="user-mention" data-user-id="295632">@Diggsey</span>'s <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277312717">example</a></li>
<li>LTO now keeps working as usual</li>
</ul>
<p>But <span class="user-mention" data-user-id="120791">@RalfJ</span> , you think it's not possible to do any reasonable handwavey definition of Rust including this <code>pnvi_ae_*</code>? It doesn't have to be more formal than C imo</p>



<a name="277320914"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277320914" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277320914">(Mar 31 2022 at 18:23)</a>:</h4>
<p>I haven't seen anyone very interested in a formal spec for a Rust that allows for any ptr2int2ptr</p>



<a name="277321009"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277321009" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277321009">(Mar 31 2022 at 18:24)</a>:</h4>
<p>(p.s. I don't actually know MIR)</p>



<a name="277321043"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277321043" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277321043">(Mar 31 2022 at 18:24)</a>:</h4>
<p><span class="user-mention silent" data-user-id="209168">Thom Chiovoloni</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277320622">said</a>:</p>
<blockquote>
<blockquote>
<p>or do you mean "any kind of model that has provenance but not via integers but allows ptr2int2ptr roundtrips"? that we probably need for backwards compatibility, indeed.</p>
</blockquote>
<p>I'm really just glad that this is being agreed on. I think a lot of the, erm, "heat" in the last discussion was from it seeming like there was disagreement here.</p>
</blockquote>
<p>well, to be frank I would <em>love</em> to disallow these roundtrips, and I expect some (a lot?) of the formal Rust work will.<br>
but I also doubt the lang team would let me get away with that 'for real' so I am not sure what my play for "full Rust" and Miri should be.<br>
like, there actually is kind of a generic recipe to turn any strict provenance model into a model that supports roundtrips, but it makes Miri basically impossible. (and I am not sure what it does with optimizations.) so</p>
<ul>
<li>we could follow that recipe and say that code that does roundtrips will just not be accepted by Miri because doing so is impractical and plase fix your code</li>
<li>we could try to find an alternative way that supports roundtrips while still making miri feasible (the suffering is real)</li>
<li>we could disallow roundtrips entirely (I doubt people will let me get away with this one)</li>
</ul>



<a name="277321115"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277321115" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277321115">(Mar 31 2022 at 18:25)</a>:</h4>
<p>I'd personally be fine with # 1</p>



<a name="277321252"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277321252" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277321252">(Mar 31 2022 at 18:26)</a>:</h4>
<p><span class="user-mention" data-user-id="465167">@Bram Geron</span> I dont think pnvi-ae is a useful stepping stone for Rust because of our aliasing model</p>



<a name="277321304"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277321304" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277321304">(Mar 31 2022 at 18:26)</a>:</h4>
<p>if you look at Stacked Borrows careful enough it <em>does</em> have 'exposed' flags, they are called "untagged" and live in the borrow stack</p>



<a name="277321342"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277321342" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277321342">(Mar 31 2022 at 18:27)</a>:</h4>
<p>if you call such a model pnvi-ae then I guess I agree but I think that is rather bad terminology^^</p>



<a name="277321481"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277321481" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Thom Chiovoloni <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277321481">(Mar 31 2022 at 18:28)</a>:</h4>
<p>I'm okay you needing to not do roundtrips in order for miri to work. That would produce gentle pressure for people to update their code to the newer model (so that they can work under miri), without breaking large swaths of unsafe code in the wild.</p>



<a name="277321484"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277321484" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277321484">(Mar 31 2022 at 18:28)</a>:</h4>
<p>I have no idea what it would mean to "forbid pnvi-ae". what does it mean to forbid a model? do you mean "forbid roundtrips", aka strict provenance?</p>



<a name="277321567"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277321567" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277321567">(Mar 31 2022 at 18:29)</a>:</h4>
<p>given how vague the sketches for models that support roundtrips are, I dont think it is worth discussing hybrid models that combine those with strict provenance</p>



<a name="277321584"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277321584" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277321584">(Mar 31 2022 at 18:29)</a>:</h4>
<p>also I dont think those would actually be any different</p>



<a name="277321615"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277321615" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277321615">(Mar 31 2022 at 18:29)</a>:</h4>
<p>like, any model that supports roundtrips should accept all programs that follow strict provenance (otherwise the model is just broken)</p>



<a name="277321637"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277321637" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277321637">(Mar 31 2022 at 18:29)</a>:</h4>
<p>so, the search for a hybrid model <em>is</em> the search for a model that supports roundtrips</p>



<a name="277321701"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277321701" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277321701">(Mar 31 2022 at 18:30)</a>:</h4>
<p>no need to think explicitly about "two different worlds interacting" or anything like that</p>



<a name="277323005"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277323005" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277323005">(Mar 31 2022 at 18:41)</a>:</h4>
<p><code>pub fn this_makes_miri_sad(addr: usize) -&gt; *mut c_void { ... }</code></p>



<a name="277323478"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277323478" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277323478">(Mar 31 2022 at 18:44)</a>:</h4>
<p>I think we should call it <code>make_miri_sad</code>. force programmers to explicitly state their intent here. ;)</p>



<a name="277324069"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277324069" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> riking <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277324069">(Mar 31 2022 at 18:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="295632">Diggsey</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277312717">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> </p>
<blockquote>
<p>Bram Geron: Really? What kind of optimization are you thinking about?<br>
For example: [...]<br>
Let's assume this results through inlining or something - obviously you wouldn't write this code by hand. With strict provenance you can optimize this to just multiplying <code>arg</code> by 1000000. Under weaker models you can't because <code>arg</code> may have originated from <code>ptr2int</code> to a large enough array.</p>
</blockquote>
</blockquote>
<p>Wait, under strict provenance your <code>int2ptr</code> function could just be doing a wrapping index into a global array it can access and everything would be fine. So you can't optimize the function to that without peeking into <code>int2ptr</code> and declaring its contents as UB.</p>



<a name="277324919"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277324919" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277324919">(Mar 31 2022 at 18:55)</a>:</h4>
<p><span class="user-mention" data-user-id="264702">@riking</span> int2ptr is just a cast - it's not UB on its own under any proposed model, because integers are allowed to be cast to pointers as long as you don't try to dereference the pointer</p>



<a name="277325274"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277325274" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> riking <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277325274">(Mar 31 2022 at 18:57)</a>:</h4>
<p>But you did dereference the pointer. Sorry, "declaring its contents as returning an always-invalid pointer"</p>



<a name="277325406"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277325406" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277325406">(Mar 31 2022 at 18:58)</a>:</h4>
<p>right, but that code path only happens if <code>cond</code> is false, therefore the compiler knows that (for this particular inlining) <code>cond</code> must be true</p>



<a name="277325501"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277325501" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> riking <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277325501">(Mar 31 2022 at 18:59)</a>:</h4>
<p>I'm talking the same as the stuff above where <code>int2ptr</code> has external linkage and we swap it out for the TreeMap polyfill</p>



<a name="277325555"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277325555" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> riking <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277325555">(Mar 31 2022 at 18:59)</a>:</h4>
<p>it returns a valid pointer if it finds one</p>



<a name="277325961"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277325961" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> riking <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277325961">(Mar 31 2022 at 19:02)</a>:</h4>
<p>Basically, under the non-strict models that function could be valid on both branches. Under the strict model, it's only collapsed to a single branch if we know the other branch does Guaranteed Evil. If <code>int2ptr</code> is an opaque function instead of a builtin, it's not guaranteed evil. If <code>int2ptr</code> is a builtin that does Guaranteed Evil, why was it provided.</p>



<a name="277325992"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277325992" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277325992">(Mar 31 2022 at 19:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277321252">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> I dont think pnvi-ae is a useful stepping stone for Rust because of our aliasing model</p>
</blockquote>
<p>Hmmz. I forgot that Stacked Borrows isn't just for Miri, it's also how we think about Mir. This complicates matters indeed</p>



<a name="277326032"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277326032" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> riking <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277326032">(Mar 31 2022 at 19:03)</a>:</h4>
<p>We have <code>unreachable_unchecked()</code> already, or just <code>pointer::invalid_mut(1)</code>, for when you want Guaranteed Evil</p>



<a name="277326084"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277326084" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277326084">(Mar 31 2022 at 19:03)</a>:</h4>
<p>Also for that example a) the compiler can still optimize it to <code>if cond { total += lots * arg; } else { do the actual loop }</code> so you're really not gaining much, and b) yes, it can't "optimize" away a perfectly valid and plausible operation, that's a feature</p>



<a name="277326302"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277326302" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277326302">(Mar 31 2022 at 19:05)</a>:</h4>
<p>(yes, it's not /likely/ if max is huge, but it is entirely plausible for smaller max, or a passed in one, or whatever, and the optimization does not depend on that in the slightest)</p>



<a name="277326321"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277326321" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277326321">(Mar 31 2022 at 19:06)</a>:</h4>
<blockquote>
<p>If int2ptr is a builtin that does Guaranteed Evil, why was it provided</p>
</blockquote>
<p>I don't know what you mean by Guaranteed Evil. It's provided because often you want to store an integer in a pointer - it's how <code>ptr::invalid_mut</code> would be implemented. There's nothing wrong with that operation?</p>



<a name="277326403"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277326403" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> riking <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277326403">(Mar 31 2022 at 19:06)</a>:</h4>
<p>Sorry, yeah, I meant guaranteed evil once dereferenced</p>



<a name="277326468"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277326468" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277326468">(Mar 31 2022 at 19:07)</a>:</h4>
<p>also at the moment like 50% of time when you have a union of integer and pointer you put it in usize/uintptr_t rather than <code>*const ()</code></p>



<a name="277326521"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277326521" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277326521">(Mar 31 2022 at 19:07)</a>:</h4>
<p><span class="user-mention" data-user-id="143798">@Talchas</span> <br>
a) Sure there may be other ways to optimize it, it was just supposed to be one example.<br>
b) It's not valid and plausible under strict provenance, which is why it can be optimized away.</p>



<a name="277326605"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277326605" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277326605">(Mar 31 2022 at 19:08)</a>:</h4>
<p>yes, but this is supposed to be something you /gain/ from strict provenance</p>



<a name="277326627"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277326627" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277326627">(Mar 31 2022 at 19:08)</a>:</h4>
<p>so it should be an optimization you'd /like/ to have happen under weaker provenance, but can't prove</p>



<a name="277326657"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277326657" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277326657">(Mar 31 2022 at 19:08)</a>:</h4>
<p>and this is not a removal you want to have happen</p>



<a name="277326723"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277326723" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277326723">(Mar 31 2022 at 19:09)</a>:</h4>
<p>you don't know that? The point is this code results from other optimizations (such as inlining) that the compiler has done - I would definitely want it to remove a branch if that branch can't happen?</p>



<a name="277326769"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277326769" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277326769">(Mar 31 2022 at 19:10)</a>:</h4>
<p>for example, the <code>int2ptr</code> part may be inlined from something else</p>



<a name="277326839"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277326839" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277326839">(Mar 31 2022 at 19:10)</a>:</h4>
<p>it is a branch, which as a human, looks like it should be able to happen unless cond's value is known</p>



<a name="277326867"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277326867" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277326867">(Mar 31 2022 at 19:10)</a>:</h4>
<p>this is not the code that a human wrote though</p>



<a name="277326884"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277326884" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277326884">(Mar 31 2022 at 19:10)</a>:</h4>
<p>this is the result of previous optimization passes</p>



<a name="277326940"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277326940" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277326940">(Mar 31 2022 at 19:11)</a>:</h4>
<p>and there is nothing in there that says that branch probably can't happen other than that 1000000 is large</p>



<a name="277326949"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277326949" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277326949">(Mar 31 2022 at 19:11)</a>:</h4>
<p>in this case everywhere I pass <code>cond = false</code>, some other expression may have been used there instead of <code>int2ptr</code></p>



<a name="277327045"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277327045" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277327045">(Mar 31 2022 at 19:11)</a>:</h4>
<p>the number 1000000 has nothing to do with it? It's just there to show that this optimization may be valuable</p>



<a name="277327193"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277327193" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277327193">(Mar 31 2022 at 19:12)</a>:</h4>
<p>yes, and if the compiler /knows/ cond = false, whether from inlining this function or deciding to specialize it on arg values or exhaustive knowledge of a local function, then it can do this without strict provenance</p>



<a name="277327241"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277327241" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277327241">(Mar 31 2022 at 19:13)</a>:</h4>
<p>but in this case it can only infer it from the fact that the alternative is UB</p>



<a name="277327271"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277327271" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277327271">(Mar 31 2022 at 19:13)</a>:</h4>
<p>even if the programmer "knows" it to be true due to eg. the type system</p>



<a name="277327279"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277327279" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277327279">(Mar 31 2022 at 19:13)</a>:</h4>
<p>if it doesn't then you're saying "this int2ptr deref isn't what the programmer ever wants because it's UB, and it should be UB because of this example"</p>



<a name="277327339"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277327339" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277327339">(Mar 31 2022 at 19:14)</a>:</h4>
<p><em>for this inlining</em> it's never what they want</p>



<a name="277327349"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277327349" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277327349">(Mar 31 2022 at 19:14)</a>:</h4>
<p>the function may be generic over that expression</p>



<a name="277327404"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277327404" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277327404">(Mar 31 2022 at 19:14)</a>:</h4>
<p>and this whole thing isn't an argument for strict provenance at all?</p>



<a name="277327445"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277327445" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277327445">(Mar 31 2022 at 19:15)</a>:</h4>
<p>the reason for the example is to show that you can't just mix and match strict provenance with a weaker provenance model</p>



<a name="277327577"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277327577" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277327577">(Mar 31 2022 at 19:16)</a>:</h4>
<p>whether an optimization is valid is a global thing that can't just look at whether "special ptr2int is used nearby"</p>



<a name="277327701"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277327701" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277327701">(Mar 31 2022 at 19:17)</a>:</h4>
<p>ok, I was understanding it as an argument for optimizations you in general would want to get from strict provenance, which looking back on it probably wasn't quite what riking was saying</p>



<a name="277327864"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277327864" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277327864">(Mar 31 2022 at 19:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277321304">said</a>:</p>
<blockquote>
<p>if you look at Stacked Borrows careful enough it <em>does</em> have 'exposed' flags, they are called "untagged" and live in the borrow stack</p>
</blockquote>
<p>Yes, from a cursory reading, SB-untagged matches my intuition. So <code>sb_untagged_{ptr2int,int2ptr}</code>.</p>
<p>I guess for the purpose of defining the language, we don't need to distinguish between <code>sb_untagged_*</code> and <code>strict_*</code>, but distinguishing would unlock more optimizations.</p>



<a name="277327866"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277327866" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277327866">(Mar 31 2022 at 19:18)</a>:</h4>
<p>but inlining a <code>int2ptr</code> from a pnvi function and then later treating it as <code>strict_int2ptr</code> and not <code>pnvi_int2ptr</code> is just wrong</p>



<a name="277327877"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277327877" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277327877">(Mar 31 2022 at 19:18)</a>:</h4>
<p>and not an unavoidable wrong</p>



<a name="277327983"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277327983" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277327983">(Mar 31 2022 at 19:20)</a>:</h4>
<p>you could still do pnvi-satisfying optimizations separately (whatever those are, maybe it's too close to "nothing") and then on substitution you treat it as an unknown <code>fn(usize)-&gt;*const T</code></p>



<a name="277328935"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277328935" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277328935">(Mar 31 2022 at 19:29)</a>:</h4>
<p>We definitely need to distinguish between <code>{strict,sb_untagged}_x2y</code> to make CHERI feasible.</p>



<a name="277329499"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277329499" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277329499">(Mar 31 2022 at 19:34)</a>:</h4>
<p>And I think <span class="user-mention" data-user-id="303115">@Quy Nguyen</span> 's <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277317047">polyfill</a> (though horrible) could be an acceptable polyfill for <code>sb_untagged_{ptr2int,int2ptr}</code>. We could add some SB-inspired counting to prune garbage in the TreeMap.</p>



<a name="277329731"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277329731" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277329731">(Mar 31 2022 at 19:36)</a>:</h4>
<p>I mean it's ok if you don't care about silent absolutely massive performance degredation on code that someone thought was performance-relevant</p>



<a name="277329758"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277329758" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277329758">(Mar 31 2022 at 19:37)</a>:</h4>
<p>(now, programmers are fairly often /wrong/ about what is performance-relevant, but still)</p>



<a name="277329920"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277329920" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277329920">(Mar 31 2022 at 19:38)</a>:</h4>
<p>If you need CHERI, then better avoid crates that use <code>sb_untagged_*</code> <span aria-label="shrug" class="emoji emoji-1f937" role="img" title="shrug">:shrug:</span>üèªü§∑üèª I don‚Äôt really think there‚Äôs a reason around it</p>



<a name="277329937"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277329937" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277329937">(Mar 31 2022 at 19:38)</a>:</h4>
<p>CHERI comes with implications</p>



<a name="277329966"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277329966" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277329966">(Mar 31 2022 at 19:38)</a>:</h4>
<p>It‚Äôs not a maximum performance architecture</p>



<a name="277334151"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277334151" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277334151">(Mar 31 2022 at 20:14)</a>:</h4>
<p>Hi, I'm catching up on this thread</p>



<a name="277334598"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277334598" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277334598">(Mar 31 2022 at 20:18)</a>:</h4>
<p>To restart what I was talking about on the thread in a way that will hopefully come through better:<br>
Why are we doing this work? Is it (a) to unblock MIR- and/or LLVM-level optimizations that depend on being able to reason about provenance we would like to do in the future? Is it (b) to support real deployments of architectures based on CHERI that we have reason to think will be practical requirements for domains we care about? Or (c) to provide a more formal grounding for proofs we would like to make about the soundness of unsafe code in the academic literature? Other reasons?</p>



<a name="277334660"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277334660" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277334660">(Mar 31 2022 at 20:19)</a>:</h4>
<p>Yes.</p>



<a name="277334844"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277334844" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277334844">(Mar 31 2022 at 20:21)</a>:</h4>
<p>(d) All of the above.</p>



<a name="277334869"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277334869" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277334869">(Mar 31 2022 at 20:21)</a>:</h4>
<p>I would argue that we need to be clear about what the concrete goals are, because that's the only way we can make decisions about the tradeoffs.</p>



<a name="277335005"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277335005" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277335005">(Mar 31 2022 at 20:22)</a>:</h4>
<p>I have concerns with all of the reasons above.</p>



<a name="277335007"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277335007" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277335007">(Mar 31 2022 at 20:22)</a>:</h4>
<p>Clear to who, exactly? We can never be fully clear to those who do not invest enough time to read the extensive discussions and documentation. Who, concretely, must we be clear to? Because that is also a tradeoff.</p>



<a name="277335088"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277335088" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277335088">(Mar 31 2022 at 20:23)</a>:</h4>
<p>Also (c part 2) to provide more formal grounding for proofs we would like to make about the soundness of unsafe code in the context of libraries trying to provide sound APIs</p>



<a name="277335162"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277335162" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277335162">(Mar 31 2022 at 20:23)</a>:</h4>
<p>It's not about me not investing enough time to read discussions and documentation. I'm coming at this from the point of view of someone who has to maintain a lot of code that has to stay working when we upgrade Rust.</p>



<a name="277335297"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277335297" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277335297">(Mar 31 2022 at 20:24)</a>:</h4>
<p>That is precisely the problem. We would like to make it easier to make it possible to maintain code so it remains stable across upgrades. We cannot do so when our model is fundamentally Vibes, because subtle changes in the Vibes will miscompile things. Yes, this may mean an up-front cost.</p>



<a name="277335359"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277335359" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277335359">(Mar 31 2022 at 20:25)</a>:</h4>
<p>The point of this work is to start making it possible to pay that cost down at all.</p>



<a name="277335387"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277335387" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277335387">(Mar 31 2022 at 20:25)</a>:</h4>
<p>My concern is that this "up-front cost" is actually far too high for many users of Rust, including me.</p>



<a name="277335512"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277335512" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277335512">(Mar 31 2022 at 20:26)</a>:</h4>
<p>This conversation began with the very conversation to pick usize, and the cost is only as high as it is because people shrugged off the concerns then.</p>



<a name="277335531"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277335531" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277335531">(Mar 31 2022 at 20:26)</a>:</h4>
<p>I'm concerned that the reaction to people who bring this up is (in this case) snarky dismissal.</p>



<a name="277335565"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277335565" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277335565">(Mar 31 2022 at 20:27)</a>:</h4>
<p>I'm concerned that you are offering snarky dismissal also?</p>



<a name="277335638"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277335638" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277335638">(Mar 31 2022 at 20:27)</a>:</h4>
<p>I'm not being snarky. I'm just the messenger. I don't have the choice to pay the up-front cost you want me to pay.</p>



<a name="277335651"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277335651" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277335651">(Mar 31 2022 at 20:27)</a>:</h4>
<p>From my perspective, we'd pick <code>ptr as usize</code> and <code>usize as ptr</code> to be <code>sb_untagged_{ptr2int,int2ptr}</code> above by default, at least in this edition, and then we get very reasonable optimizations, all code keeps working, and we just get a bit of a shit compilation under CHERI</p>



<a name="277335661"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277335661" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277335661">(Mar 31 2022 at 20:27)</a>:</h4>
<p>I don't think there would be a downside to you</p>



<a name="277335741"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277335741" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277335741">(Mar 31 2022 at 20:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277335651">said</a>:</p>
<blockquote>
<p>From my perspective, we'd pick <code>ptr as usize</code> and <code>usize as ptr</code> to be <code>sb_untagged_{ptr2int,int2ptr}</code> above by default, at least in this edition, and then we get very reasonable optimizations, all code keeps working, and we just get a bit of a shit compilation under CHERI</p>
</blockquote>
<p>From a glance, this sounds like a great solution.</p>



<a name="277335842"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277335842" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277335842">(Mar 31 2022 at 20:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277335651">said</a>:</p>
<blockquote>
<p>From my perspective, we'd pick <code>ptr as usize</code> and <code>usize as ptr</code> to be <code>sb_untagged_{ptr2int,int2ptr}</code> above by default, at least in this edition, and then we get very reasonable optimizations, all code keeps working, and we just get a bit of a shit compilation under CHERI</p>
</blockquote>
<p>I mean, I'm not clear that this is actually an option - SB without raw pointer tagging is broken in some pretty bad ways, and I wouldn't really want to see it land. Probably Ralf knows thigns that I don't here, but I'm not sure how to migrate this to a model with raw pointer tagging</p>



<a name="277335843"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277335843" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277335843">(Mar 31 2022 at 20:29)</a>:</h4>
<p>Maybe we can even strike through <code>by default</code> and just make a lint against legacy <code>ptr as usize</code>, <code>usize as ptr</code>. The lint would be <code>allow</code> by default in the current edition</p>



<a name="277335884"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277335884" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277335884">(Mar 31 2022 at 20:29)</a>:</h4>
<p>To be concrete, with some of the proposals going around here, <em>if</em> Rust starts shipping optimizations that depend on some form of strict pointer provenance, then my options are (1) don't upgrade Rust and pin ourselves to an earlier version; (2) fork the compiler to remove those optimizations.</p>



<a name="277335936"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277335936" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277335936">(Mar 31 2022 at 20:30)</a>:</h4>
<p>If you are saying that you are a messenger then you are speaking for Facebook, Walton, and your threats to fork are Facebook's threats to fork, and your threats to disinvest are Facebook's threats to disinvest.</p>



<a name="277335957"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277335957" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277335957">(Mar 31 2022 at 20:30)</a>:</h4>
<p>I would like to read more about how SB without tagging is broken. From how I understand the paper, there are no tags for <code>*T</code></p>



<a name="277335992"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277335992" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277335992">(Mar 31 2022 at 20:30)</a>:</h4>
<p>Let me open a new thread for that</p>



<a name="277336014"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277336014" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277336014">(Mar 31 2022 at 20:30)</a>:</h4>
<p>I'm not making any sort of threat, and in particular I'm not threatening any sort of disinvestment.</p>



<a name="277336027"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277336027" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277336027">(Mar 31 2022 at 20:30)</a>:</h4>
<p>I'm <em>already</em> maintaining a private fork of Rust.</p>



<a name="277336079"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277336079" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277336079">(Mar 31 2022 at 20:31)</a>:</h4>
<p>Because Rust dropped support for old versions of LLVM that we need to maintain interoperability with our C++ LTO toolchain, I have to maintain that internally.</p>



<a name="277336084"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277336084" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277336084">(Mar 31 2022 at 20:31)</a>:</h4>
<p>Then there is nothing to be gained by serving Facebook's interests, not even for Facebook.</p>



<a name="277336224"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277336224" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277336224">(Mar 31 2022 at 20:32)</a>:</h4>
<p>That's not true. The farther we drift from upstream, the harder it is to stay up to date.</p>



<a name="277336230"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277336230" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277336230">(Mar 31 2022 at 20:32)</a>:</h4>
<p>I do think that there was a tone of snarky dismissal in past discussions. But from what I've seen today, nobody is seriously considering breaking legacy code</p>



<a name="277336255"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277336255" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277336255">(Mar 31 2022 at 20:32)</a>:</h4>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277336230">said</a>:</p>
<blockquote>
<p>I do think that there was a tone of snarky dismissal in past discussions. But from what I've seen today, nobody is seriously considering breaking legacy code</p>
</blockquote>
<p>I hope that's the case, but it seems otherwise based on this conversation.</p>



<a name="277336285"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277336285" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277336285">(Mar 31 2022 at 20:33)</a>:</h4>
<p>"Yes, this may mean an up-front cost" sounds like breaking code.</p>



<a name="277336356"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277336356" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277336356">(Mar 31 2022 at 20:33)</a>:</h4>
<p>I have absolutely no problem with experiments for cleaner models in the future as long as we aren't going to break existing code.</p>



<a name="277336448"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277336448" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277336448">(Mar 31 2022 at 20:34)</a>:</h4>
<p>IMO all the "up-front cost" can be done away with by just putting the strict provenance stuff in new functions. And nobody seems to see a problem with this (any more)</p>



<a name="277336462"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277336462" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277336462">(Mar 31 2022 at 20:34)</a>:</h4>
<p>It is in new functions already.</p>



<a name="277336596"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277336596" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277336596">(Mar 31 2022 at 20:36)</a>:</h4>
<p>How does that interoperate with existing code? Is it a case in which any use of non-strict provenance anywhere in the crate graph globally disables all optimizations based on strict provenance?</p>



<a name="277336660"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277336660" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277336660">(Mar 31 2022 at 20:36)</a>:</h4>
<p>Currently, it doesn't.</p>



<a name="277336669"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277336669" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277336669">(Mar 31 2022 at 20:36)</a>:</h4>
<p>That is in the thread.</p>



<a name="277336723"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277336723" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277336723">(Mar 31 2022 at 20:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277336448">said</a>:</p>
<blockquote>
<p>IMO all the "up-front cost" can be done away with by just putting the strict provenance stuff in new functions. And nobody seems to see a problem with this (any more)</p>
</blockquote>
<p>I don't think this is the case - the question of "what, then, is the memory model for non-strict provenance" is entirely unanswered</p>



<a name="277336970"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277336970" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277336970">(Mar 31 2022 at 20:39)</a>:</h4>
<p>You have to understand, the C code you are talking about cross-lang LTO with is already at risk of spontaneously beginning to miscompile. The transition cost for an upgrade is high, but if we can make something coherent in Rust, then the projection of C into Rust can be made coherent also, and not a source of other spontaneous miscompiling.</p>



<a name="277337108"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277337108" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277337108">(Mar 31 2022 at 20:40)</a>:</h4>
<p>That would increase, not decrease, the ability to upgrade clang.</p>



<a name="277337142"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277337142" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277337142">(Mar 31 2022 at 20:41)</a>:</h4>
<p>For some definition of "risk" that pretty much only applies to pathological code written to demonstrate the problem.</p>



<a name="277337158"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277337158" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277337158">(Mar 31 2022 at 20:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="198590">comex</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277337142">said</a>:</p>
<blockquote>
<p>For some definition of "risk" that pretty much only applies to pathological code written to demonstrate the problem.</p>
</blockquote>
<p>That's exactly what I'm getting at.</p>



<a name="277337171"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277337171" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277337171">(Mar 31 2022 at 20:41)</a>:</h4>
<p>The way everyone talks about it, that pathological code is everywhere.</p>



<a name="277337199"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277337199" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277337199">(Mar 31 2022 at 20:41)</a>:</h4>
<p>Code that violates strict_provenance is everywhere.  Code that "what LLVM currently does" breaks is almost nowhere.</p>



<a name="277337200"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277337200" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277337200">(Mar 31 2022 at 20:41)</a>:</h4>
<p>In practice, the cost of the spontaneous miscompiles for all upgrades of Clang that we might possibly do in the future is far lower than the cost of rewriting all our unsafe Rust code to conform to stacked borrows + strict provenance.</p>



<a name="277337216"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277337216" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277337216">(Mar 31 2022 at 20:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="198590">comex</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277337199">said</a>:</p>
<blockquote>
<p>Code that violates strict_provenance is everywhere.  Code that "what LLVM currently does" breaks is almost nowhere.</p>
</blockquote>
<p>Exactly this.</p>



<a name="277337263"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277337263" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277337263">(Mar 31 2022 at 20:42)</a>:</h4>
<p>Despite the fact that "what LLVM currently does" is unsound in some cases.</p>



<a name="277337265"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277337265" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277337265">(Mar 31 2022 at 20:42)</a>:</h4>
<p>"what LLVM does" is subject to change without notice.</p>



<a name="277337297"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277337297" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277337297">(Mar 31 2022 at 20:42)</a>:</h4>
<p>This fact does in fact break real codebases.</p>



<a name="277337311"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277337311" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277337311">(Mar 31 2022 at 20:42)</a>:</h4>
<p>In practice it is not. Because if LLVM breaks us, we can raise objections and revert it upstream.</p>



<a name="277337342"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277337342" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277337342">(Mar 31 2022 at 20:43)</a>:</h4>
<p>This is regularly done in LLVM without pushback, because LLVM understands that you can't break real working code.</p>



<a name="277337388"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277337388" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277337388">(Mar 31 2022 at 20:43)</a>:</h4>
<p>Beyond that, LLVM needs to support form of unrestricted ptr2int2ptr in order to support C, and that is not going to change.</p>



<a name="277337423"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277337423" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277337423">(Mar 31 2022 at 20:43)</a>:</h4>
<p>(Including C with <code>-fno-strict-aliasing</code>, because some important codebases use that and also have a ton of pointer&lt;-&gt;int casts!)</p>



<a name="277337473"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277337473" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277337473">(Mar 31 2022 at 20:44)</a>:</h4>
<p>Based on everything I have seen, the Rust project gets a lot of pushback, even just on preserving currently-stable behaviors, so that is not really an option for us and if Facebook does not see it as important to make sure Rust has an easy time of things, that is fine, but that is not the reality the rest of the world lives in.</p>



<a name="277337559"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277337559" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277337559">(Mar 31 2022 at 20:45)</a>:</h4>
<p>Again, this is the same behavior that people rely on in C.</p>



<a name="277337561"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277337561" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277337561">(Mar 31 2022 at 20:45)</a>:</h4>
<p>This sounds like an explicit statement that Rust has decided to break one of its largest customers' codebases.</p>



<a name="277337612"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277337612" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277337612">(Mar 31 2022 at 20:45)</a>:</h4>
<p>Merely an observation, Walton.</p>



<a name="277337677"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277337677" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277337677">(Mar 31 2022 at 20:46)</a>:</h4>
<p>Unless you are also no longer "merely a messenger".</p>



<a name="277337913"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277337913" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277337913">(Mar 31 2022 at 20:48)</a>:</h4>
<p>Please calm down everyone.</p>



<a name="277337915"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277337915" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277337915">(Mar 31 2022 at 20:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="281757">Jubilee</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277336462">said</a>:</p>
<blockquote>
<p>It is in new functions already.</p>
</blockquote>
<p>There are new functions, but my proposal is different from the current <code>sptr</code> / nightly <code>std::ptr</code>:</p>
<p>I propose that </p>
<ul>
<li>
<p><code>usize as ptr</code> remains permissive as is, and is defined as something like Stacked Borrows untagged. On CHERI, it would do something horribly expensive (the TreeSet approach)</p>
</li>
<li>
<p><code>ptr.addr()</code> / <code>ptr as usize</code> remain permissive as is. On CHERI, they would do something horribly expensive.</p>
</li>
<li>
<p>we introduce <code>ptr.addr_strict()</code> which is fast on CHERI -- but <code>ptr.addr_strict() as ptr</code> may not work.</p>
</li>
<li>
<p>we keep <code>std::ptr::invalid</code> as in nightly</p>
</li>
</ul>
<p><span class="user-mention silent" data-user-id="281757">Jubilee</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277336660">said</a>:</p>
<blockquote>
<p>Currently, it doesn't.</p>
</blockquote>
<p>Incorrect, my proposal would interoperate perfectly fine with legacy code. Nothing changes for that.</p>



<a name="277337970"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277337970" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277337970">(Mar 31 2022 at 20:49)</a>:</h4>
<p>I'm not in any official position so take my statements however you will, but I don't think we're going to planning to break any Rust code until possibly far in the future.</p>



<a name="277337981"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277337981" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277337981">(Mar 31 2022 at 20:49)</a>:</h4>
<p>I would really like to avoid breaking existing code. Let's not jump to "we must break existing code" please.</p>



<a name="277338011"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277338011" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277338011">(Mar 31 2022 at 20:49)</a>:</h4>
<p>I don't know what that means. All I've been saying is that the only option that I can see if Rust starts being aggressive with optimizations that require strict provenance is to revert it internally. So I'm arguing in favor of not breaking existing code, so that I don't have to do that. I don't see what's wrong with advocating for the thing that will make our life easier, but maybe the Rust community sees it differently.</p>



<a name="277338029"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277338029" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277338029">(Mar 31 2022 at 20:49)</a>:</h4>
<p>No additional optimizations would apply to legacy code.</p>



<a name="277338040"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277338040" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277338040">(Mar 31 2022 at 20:49)</a>:</h4>
<p>My point is that it might actually be convenient if Facebook saw aligning how LLVM views things with Rust's needs more important.<br>
But saying "Facebook can use power to get its way" is not the same as "Rust can use power to get its way".</p>



<a name="277338041"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277338041" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277338041">(Mar 31 2022 at 20:49)</a>:</h4>
<p>That's great to hear then.</p>



<a name="277338047"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277338047" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277338047">(Mar 31 2022 at 20:50)</a>:</h4>
<p>From what I understand, the translation to LLVM is still a bit shaky, but that's because LLVM is just not so well documented.</p>



<a name="277338122"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277338122" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277338122">(Mar 31 2022 at 20:50)</a>:</h4>
<p>From my perspective, the relationship between Facebook and LLVM is off topic</p>



<a name="277338125"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277338125" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277338125">(Mar 31 2022 at 20:50)</a>:</h4>
<p>Stating Facebook and everyone else live in two different universes is merely a fact.</p>



<a name="277338134"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277338134" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277338134">(Mar 31 2022 at 20:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277338122">said</a>:</p>
<blockquote>
<p>From my perspective, the relationship between Facebook and LLVM is off topic</p>
</blockquote>
<p>I agree.</p>



<a name="277338142"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277338142" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277338142">(Mar 31 2022 at 20:50)</a>:</h4>
<p>Apparently Walton believes it is immediately material.</p>



<a name="277338145"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277338145" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277338145">(Mar 31 2022 at 20:50)</a>:</h4>
<p>And I don't have any power :)</p>



<a name="277338205"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277338205" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277338205">(Mar 31 2022 at 20:51)</a>:</h4>
<p>It seems what you say does have power, since you speak for Facebook, and Facebook can get its way.</p>



<a name="277338267"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277338267" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277338267">(Mar 31 2022 at 20:51)</a>:</h4>
<p>Please let's stop talking about Facebook‚ÄîLLVM</p>



<a name="277338271"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277338271" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277338271">(Mar 31 2022 at 20:51)</a>:</h4>
<p>I don't know how we got here at all</p>



<a name="277338428"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277338428" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277338428">(Mar 31 2022 at 20:52)</a>:</h4>
<p>Again, the point is moot.  The ptr&lt;-&gt;int behavior Rust is currently relying on is the same behavior that /most major C codebases/ rely on.  LLVM is not going to randomly break it, regardless of who has power or who doesn't.</p>



<a name="277338506"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277338506" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277338506">(Mar 31 2022 at 20:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="198590">comex</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277338428">said</a>:</p>
<blockquote>
<p>Again, the point is moot.  The ptr&lt;-&gt;int behavior Rust is currently relying on is the same behavior that /most major C codebases/ rely on.  LLVM is not going to randomly break it, regardless of who has power or who doesn't.</p>
</blockquote>
<p>Yeah, in practice I'm more worried about MIR optimizations.</p>



<a name="277338591"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277338591" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277338591">(Mar 31 2022 at 20:54)</a>:</h4>
<p>(One of which I wrote, and in fact hasn't landed because it's unsound) :)</p>



<a name="277338715"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277338715" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277338715">(Mar 31 2022 at 20:55)</a>:</h4>
<p><a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277320814">here</a> I proposed an approach to MIR optimizations that optimizes one strict-provenance function in a nice way, and which is a noop on legacy code</p>



<a name="277338879"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277338879" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277338879">(Mar 31 2022 at 20:57)</a>:</h4>
<p>(<code>pnvi_ae</code> should be read as the existing stuff; <code>strict_ptr2int(ptr)</code> = <code>ptr.addr_strict()</code>, <code>strict_int2ptr</code> = <code>ptr::invalid</code>)</p>



<a name="277338937"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277338937" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277338937">(Mar 31 2022 at 20:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277338715">said</a>:</p>
<blockquote>
<p><a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277320814">here</a> I proposed an approach to MIR optimizations that optimizes one strict-provenance function in a nice way, and which is a noop on legacy code</p>
</blockquote>
<p>This looks good to me</p>



<a name="277338993"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277338993" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277338993">(Mar 31 2022 at 20:58)</a>:</h4>
<p>To be clear I would love to be able to do these optimizations too</p>



<a name="277339033"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277339033" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277339033">(Mar 31 2022 at 20:58)</a>:</h4>
<p>I just also have to keep our legacy code working.</p>



<a name="277339079"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277339079" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277339079">(Mar 31 2022 at 20:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277338715">said</a>:</p>
<blockquote>
<p><a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277320814">here</a> I proposed an approach to MIR optimizations that optimizes one strict-provenance function in a nice way, and which is a noop on legacy code</p>
</blockquote>
<p>I don't see how that approach works. You're restricted to doing these optimizations on allocations that never leave the current function, and alias analysis is not that hard on those</p>



<a name="277339092"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277339092" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277339092">(Mar 31 2022 at 20:59)</a>:</h4>
<p><span class="user-mention" data-user-id="120791">@RalfJ</span> noted that <code>pnvi-ae-*</code> doesn't make sense in the Rust story, so instead we'd presumably use the Stacked Borrows untagged model, as we do now</p>



<a name="277339128"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277339128" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277339128">(Mar 31 2022 at 20:59)</a>:</h4>
<p><span class="user-mention" data-user-id="465167">@Bram Geron</span> I cant really make sense of your various <code>*_int2ptr</code>. Stacked borrows with/without untagged, the various forms of PNVI, strict provenance are all <em>different memory models</em>. they are not functions you can all.<br>
it makes sense to ask "what does this code do when executed under model X".<br>
it makes no sense to ask "what does this operation from model X do when we are executing the rest of the code under model Y". the result is the same as running a Linux binary on Windows -- nothing happens as the model X operation is simply not defined in the universe created by model Y.</p>



<a name="277339379"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277339379" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277339379">(Mar 31 2022 at 21:01)</a>:</h4>
<p>has there even been a single proposal of an optimization that we might want to add that would break real code that does ptr2int2ptr roundtrips? (not the crazy code I write to demonstrate how broken everything is, but realistic code.)</p>



<a name="277339521"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277339521" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277339521">(Mar 31 2022 at 21:02)</a>:</h4>
<p>I mean</p>
<ul>
<li><code>sb_untagged_int2ptr</code> is as it is now</li>
<li><code>strict_int2ptr</code> = <code>std::ptr::invalid</code> constructs an invalid pointer. So ‚Äî we need to loosen up Stacked Borrows a bit so that <code>ptr</code>-sized things can also be invalid pointers, which will UB when dereferenced</li>
</ul>



<a name="277339593"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277339593" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277339593">(Mar 31 2022 at 21:02)</a>:</h4>
<p>so basically the memory model is SB with untagged pointers but there exists a form of int2ptr cast that deliberately puts an 'invalid' provenance on the ptr? okay that makes sense.</p>



<a name="277339609"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277339609" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277339609">(Mar 31 2022 at 21:03)</a>:</h4>
<p>'invalid' provenance is easy to add to any model</p>



<a name="277339647"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277339647" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277339647">(Mar 31 2022 at 21:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277339379">said</a>:</p>
<blockquote>
<p>has there even been a single proposal of an optimization that we might want to add that would break real code that does ptr2int2ptr roundtrips? (not the crazy code I write to demonstrate how broken everything is, but realistic code.)</p>
</blockquote>
<p>I think not really. But it's important for CHERI to have a separate <code>ptr.addr_strict()</code> method, which is able to be quick</p>



<a name="277340272"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277340272" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277340272">(Mar 31 2022 at 21:06)</a>:</h4>
<p>I propose (only 5% my own proposal) that CHERI <code>ptr.addr()</code> would insert the pointer into a TreeMap. Or something more complicated that allows for pruning when the Stacked Borrows protector is popped / something like that</p>



<a name="277340519"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277340519" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277340519">(Mar 31 2022 at 21:08)</a>:</h4>
<p>you basically want a "broadcasting" and a "non-broadcasting" ptr2int cast?<br>
well <code>ptr as usize</code> might just be the broadcasting version then. <span aria-label="shrug" class="emoji emoji-1f937" role="img" title="shrug">:shrug:</span></p>



<a name="277340532"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277340532" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277340532">(Mar 31 2022 at 21:08)</a>:</h4>
<p>Indeed :D</p>



<a name="277340540"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277340540" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277340540">(Mar 31 2022 at 21:08)</a>:</h4>
<p><span class="user-mention" data-user-id="384014">@Patrick Walton</span> I can't speak for anyone else, but for me the point of this experiment is to figure out how much of the Rust ecosystem we can get into the nice well-behaved room that is "strict provenance". Since I never expected to actually be able to eliminate ptr2int2ptr roundtrips (and the reactions here confirmed that), I think the worst case scenario here is that when you write <code>ptr as usize</code> or <code>usize as ptr</code> you "opt-out" of the fragment of Rust that can be checked by Miri, compiled to CHERI, or be understood with a precise spec. You opt-in to a vague memory model that we can't reason formally about. That's basically the status quo for all of Rust today. So like today: if you show us real code that is 'reasonable' (whatever that means) and gets miscompiled it will be considered a bug (in particular if it is a regression, i.e., code that worked before).</p>



<a name="277340572"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277340572" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277340572">(Mar 31 2022 at 21:09)</a>:</h4>
<p><span class="user-mention" data-user-id="120791">@RalfJ</span>  I think that's pretty reasonable.</p>



<a name="277340695"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277340695" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277340695">(Mar 31 2022 at 21:10)</a>:</h4>
<p>Personally, I'm unsure how much actual real-world relevance CHERI is going to have, but if it makes our memory model simpler in general then that's fine.</p>



<a name="277340715"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277340715" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277340715">(Mar 31 2022 at 21:10)</a>:</h4>
<p>yeah CHERI is just one item in the list here</p>



<a name="277340749"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277340749" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277340749">(Mar 31 2022 at 21:10)</a>:</h4>
<p>this doesn't just affect Miri either, it affects all formal tools for checking Rust (model checkers, etc.)</p>



<a name="277340798"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277340798" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brooks Davis <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277340798">(Mar 31 2022 at 21:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277340272">said</a>:</p>
<blockquote>
<p>I propose (only 5% my own proposal) that CHERI <code>ptr.addr()</code> would insert the pointer into a TreeMap. Or something more complicated that allows for pruning when the Stacked Borrows protector is popped / something like that</p>
</blockquote>
<p>From a CHERI and exploit mitigation perspective I'm horrified. <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span> We've talked about such things to support awful C idioms (e.g., round tripping a pointer through <code>sprintf("%p")</code> and <code>sscanf("%p")</code>) but never as something anyone would actually implement.</p>



<a name="277340801"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277340801" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277340801">(Mar 31 2022 at 21:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277340519">said</a>:</p>
<blockquote>
<p>you basically want a "broadcasting" and a "non-broadcasting" ptr2int cast?<br>
well <code>ptr as usize</code> might just be the broadcasting version then. <span aria-label="shrug" class="emoji emoji-1f937" role="img" title="shrug">:shrug:</span></p>
</blockquote>
<p>Basically. But for runtime would be reeeeally nice to know when to "undo" the broadcast. I imagine the protectors might be trigger points for this</p>



<a name="277340882"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277340882" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277340882">(Mar 31 2022 at 21:12)</a>:</h4>
<p>It would be nice to be able to localize the effects of ptr-&gt;int-&gt;ptr conversions to at least the "FFI" level. i.e. at the very least, if you cross from strict provenance Rust to non-strict-provenance Rust, then it's like calling an extern C function from the perspective of the API. It doesn't turn off all optimizations based on strict provenance for the entire compilation graph.</p>



<a name="277340913"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277340913" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277340913">(Mar 31 2022 at 21:12)</a>:</h4>
<p>if the experiment goes really well and strict provenance is sufficiently expressive we might be able to deprecate <code>usize as ptr</code> and <code>ptr as usize</code>, which would help ensure new code is within "strict Rust". but the experiment also might show that there are some things we can't do inside "struct Rust" even if people rewrote everything and then deprecation wouldn't make a ton of sense. we'll see.</p>



<a name="277340957"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277340957" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277340957">(Mar 31 2022 at 21:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="490906">Brooks Davis</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277340798">said</a>:</p>
<blockquote>
<p>From a CHERI and exploit mitigation perspective I'm horrified. <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span> We've talked about such things to support awful C idioms (e.g., round tripping a pointer through <code>sprintf("%p")</code> and <code>sscanf("%p")</code>) but never as something anyone would actually implement.</p>
</blockquote>
<p>Unfortunately there's no silver bullet! We can't keep all existing code working _and_ find all the bugs at the same time. But a lint as described above would help massively</p>



<a name="277340974"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277340974" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277340974">(Mar 31 2022 at 21:12)</a>:</h4>
<p><span class="user-mention" data-user-id="384014">@Patrick Walton</span> well see above, I literally dont know of any optimization this would even affect</p>



<a name="277341005"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277341005" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277341005">(Mar 31 2022 at 21:13)</a>:</h4>
<p>the current vague memory model means "lets just do optimizations it'll be fine"</p>



<a name="277341038"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277341038" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277341038">(Mar 31 2022 at 21:13)</a>:</h4>
<p>and that seems to work for you... I dont see how that would become any worse if we can actually say "oh btw, for strict Rust programs these optimizations are actually definitely correct"</p>



<a name="277341049"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277341049" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277341049">(Mar 31 2022 at 21:13)</a>:</h4>
<p>Isn't the current memory model Stacked Borrows?</p>



<a name="277341129"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277341129" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277341129">(Mar 31 2022 at 21:14)</a>:</h4>
<p>Stacked Borrows is a proposed memory model, not official. unclear relationship to LLVM (mostly because LLVM's model is -- surprise -- unclear)</p>



<a name="277341165"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277341165" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277341165">(Mar 31 2022 at 21:14)</a>:</h4>
<p>Right, and there's Polonius as well. <span aria-label="thinking" class="emoji emoji-1f914" role="img" title="thinking">:thinking:</span> Does it have a similar notion of untagged?</p>



<a name="277341212"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277341212" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277341212">(Mar 31 2022 at 21:15)</a>:</h4>
<p>Interesting. Sounds like it'd be valuable to enumerate the specific optimizations we'd like to be able to do and what requirements they place on the memory model.</p>



<a name="277341222"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277341222" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277341222">(Mar 31 2022 at 21:15)</a>:</h4>
<p>Also, note that there are at least two variants of SB (with or without raw pointer tagging) and that there will likely be more in the future</p>



<a name="277341293"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277341293" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277341293">(Mar 31 2022 at 21:16)</a>:</h4>
<p>Even if just scoped to the MIR level so we can avoid the thorny questions about what LLVM plans to do.</p>



<a name="277341328"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277341328" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277341328">(Mar 31 2022 at 21:16)</a>:</h4>
<p>I imagine the rules for ptr2int2ptr might be that</p>
<ul>
<li><code>ptr as usize</code> "broadcasts" that pointer's provenance</li>
<li><code>usize as ptr</code> picks <em>some</em> 'broadcast' provenance, namely the one that works. (basically: speculatively execute the program with each possible choice, pick the one that is not UB. formally: angelic non-determinism.)</li>
</ul>
<p>under these rules, if we can get the compiler to honor that "broadcasting" (treat ptr2int as having a sort of side-effect), I don't see how we could misoptimize. it's just a hideous model to check a program against (in miri, CHERI, a model checker, really any context), so it'd be great if we could avoid using it except for 'legacy' applications. :D</p>



<a name="277341370"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277341370" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277341370">(Mar 31 2022 at 21:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277341165">said</a>:</p>
<blockquote>
<p>Right, and there's Polonius as well. <span aria-label="thinking" class="emoji emoji-1f914" role="img" title="thinking">:thinking:</span> Does it have a similar notion of untagged?</p>
</blockquote>
<p>polonious is just an analysis, not affecting optimizations or UB</p>



<a name="277341496"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277341496" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ben Kimock (Saethlin) <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277341496">(Mar 31 2022 at 21:18)</a>:</h4>
<p>Stacked borrows is particularly notable because it's the only proposed model that we have a checker for. I would not mind seeing some kind of checker for rustc's use of LLVM <code>noalias</code>, because I've once or twice found code that doesn't pass Miri and I really wasn't sure if it was UB with respect to <code>noalias</code>.</p>



<a name="277341533"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277341533" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277341533">(Mar 31 2022 at 21:18)</a>:</h4>
<p>yeah well that would mean someone has to first define noalias precisely enough that a checker can even theoretically be implemented :D</p>



<a name="277343658"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277343658" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277343658">(Mar 31 2022 at 21:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277341328">said</a>:</p>
<blockquote>
<p>I imagine the rules for ptr2int2ptr might be that</p>
<ul>
<li><code>ptr as usize</code> "broadcasts" that pointer's provenance</li>
<li><code>usize as ptr</code> picks <em>some</em> 'broadcast' provenance, namely the one that works. (basically: speculatively execute the program with each possible choice, pick the one that is not UB. formally: angelic non-determinism.)</li>
</ul>
<p>under these rules, if we can get the compiler to honor that "broadcasting" (treat ptr2int as having a sort of side-effect), I don't see how we could misoptimize. it's just a hideous model to check a program against (in miri, CHERI, a model checker, really any context), so it'd be great if we could avoid using it except for 'legacy' applications. :D</p>
</blockquote>
<p>so <span class="user-mention" data-user-id="384014">@Patrick Walton</span> regarding this model there is a possible surprise left... what this would not let you do is <em>transmute</em> a pointer to an integer and then cast that back and do anything with it. transmutes rather than casts are their own can of worms... but that seems even less common that doing the casts?<br>
(note that by transmute I mean any form of type punning, via <code>mem::transmute</code>, via unions, or via pointer type punning).</p>



<a name="277343766"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277343766" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277343766">(Mar 31 2022 at 21:40)</a>:</h4>
<p>that is because <code>ptr as usize</code> is required to do the "broadcast"; a transmute doesn't do that</p>



<a name="277343938"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277343938" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277343938">(Mar 31 2022 at 21:42)</a>:</h4>
<p>Does "broadcasting" here mean something other than "escaping" in PNVI-ae?</p>



<a name="277344062"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277344062" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277344062">(Mar 31 2022 at 21:44)</a>:</h4>
<p>they're the same</p>



<a name="277344487"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277344487" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277344487">(Mar 31 2022 at 21:49)</a>:</h4>
<p>I'm still not sure if we need an address-exposure model in Rust. Even PNVI-plain is sufficient to compile most C code without miscompilation, and I can understand needing to allow some fast and loose stuff, but PNVI-plain genuinely seems sufficient because er, well</p>
<p>as mentioned, most code is simply not actually that pathological.</p>



<a name="277344676"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277344676" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277344676">(Mar 31 2022 at 21:50)</a>:</h4>
<p>I'm open to <span class="user-mention" data-user-id="120791">@RalfJ</span>  telling me it can't work like that tho'.</p>



<a name="277344705"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277344705" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277344705">(Mar 31 2022 at 21:51)</a>:</h4>
<p>hm I'll have to check what PNVI-plain does on int2ptr...</p>



<a name="277344841"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277344841" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277344841">(Mar 31 2022 at 21:52)</a>:</h4>
<p>wait, ISTR that PNVI-plain is even more permissive than -ae, it allows magicking up any provenance more or less</p>



<a name="277344908"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277344908" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277344908">(Mar 31 2022 at 21:53)</a>:</h4>
<p>Sortof. :D</p>



<a name="277345035"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277345035" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277345035">(Mar 31 2022 at 21:54)</a>:</h4>
<p>oh that's broken</p>



<a name="277345052"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277345052" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277345052">(Mar 31 2022 at 21:54)</a>:</h4>
<p>So... it makes a bunch of optimizations illegal that we want to do?</p>



<a name="277345076"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277345076" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277345076">(Mar 31 2022 at 21:54)</a>:</h4>
<p>all of the optimization arguments for Stacked Borrows proceed by "I generated this provenance and it is wholly impossible for any other part of the program to have a pointer with that same provenance"</p>



<a name="277345093"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277345093" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277345093">(Mar 31 2022 at 21:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277345052">said</a>:</p>
<blockquote>
<p>So... it makes a bunch of optimizations illegal that we want to do?</p>
</blockquote>
<p>yes. where "a bunch" = all of them.^^</p>



<a name="277345096"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277345096" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277345096">(Mar 31 2022 at 21:55)</a>:</h4>
<p>Ah okay. :D</p>



<a name="277345107"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277345107" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277345107">(Mar 31 2022 at 21:55)</a>:</h4>
<p>Nevermind then. :D</p>



<a name="277345134"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277345134" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277345134">(Mar 31 2022 at 21:55)</a>:</h4>
<p>We can try making CPUs faster instead :D</p>



<a name="277345232"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277345232" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277345232">(Mar 31 2022 at 21:56)</a>:</h4>
<p>you'll see me out here with an FPGA working on a new CPU design, mark my words</p>



<a name="277345275"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277345275" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277345275">(Mar 31 2022 at 21:56)</a>:</h4>
<p>there might be super complicated ways to avoid having an explicit 'expose' (that's what <a href="https://www.ralfj.de/research/twinsem/twinsem.pdf">https://www.ralfj.de/research/twinsem/twinsem.pdf</a> does). but honestly, if strict provenance works out sufficiently well that means we'll not have many 'expose' so making those expensive (for optimizations) seems fine...</p>



<a name="277345278"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277345278" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277345278">(Mar 31 2022 at 21:56)</a>:</h4>
<blockquote>
<p>checks whether the pointer points into a live object and if so, recreates the appropriate provenance</p>
</blockquote>
<p>yes, that allows address guessing, I think it's out</p>



<a name="277345308"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277345308" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277345308">(Mar 31 2022 at 21:57)</a>:</h4>
<p>got-cha.</p>



<a name="277345328"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277345328" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277345328">(Mar 31 2022 at 21:57)</a>:</h4>
<p>"portable assembly", some people would be very happy with this</p>



<a name="277345345"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277345345" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277345345">(Mar 31 2022 at 21:57)</a>:</h4>
<p>of the named PNVI variants, I believe -ae is actually the strictest</p>



<a name="277345462"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277345462" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277345462">(Mar 31 2022 at 21:58)</a>:</h4>
<p>I actually full-on believe that "C is bad" (insofar as I believe that... it's more like "eh, kinda") mostly because it is not as good a portable assembler as it could be.</p>



<a name="277345515"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277345515" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277345515">(Mar 31 2022 at 21:59)</a>:</h4>
<p>in one of the papers they had PNVI-wildcard which is like -plain except the pointer gets superpowers and you can now even offset (without any further casts) OOB and into another live object then use it</p>



<a name="277345538"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277345538" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277345538">(Mar 31 2022 at 21:59)</a>:</h4>
<p>yeah that one seemed mostly just funny.</p>



<a name="277345548"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277345548" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277345548">(Mar 31 2022 at 21:59)</a>:</h4>
<p>the main concerns with 'expose' are</p>
<ul>
<li>do people think that anything else (besides ptr2int <em>casts</em>) does expose? like, does a ptr2int <em>transmute</em> (or a load of a ptr value at int type) expose? if the answer is yes then it's broken again because basically every load could be type-punning and thus expose. [This is the very problem PNVI-ae-udi does not have since they can rule this out via C's strict alias.]</li>
<li>also, LLVM treats ptr2int as not having a side-effect, which is incompatible with 'expose'.</li>
</ul>
<p>so, my thinking on this right now is</p>
<ul>
<li>no transmutes dont expose, transmutes are just UB.</li>
<li>LLVM is broken but that's okay since code that does expose is 'outside of strict Rust' and is supported on a "Vibes Memory Model best effort" kind of basis. meanwhile I can have my beautiful formal garden next door where 'expose' doesn't exist and so LLVM's lack of it does not concern me. ;)</li>
</ul>



<a name="277345648"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277345648" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277345648">(Mar 31 2022 at 22:00)</a>:</h4>
<p>But also is why I mentioned "please do not conflate PNVI-{x} with PNVI-{y}."</p>



<a name="277345789"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277345789" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277345789">(Mar 31 2022 at 22:01)</a>:</h4>
<p>"PNVI-roll-a-die breaks your intuitions. What, you say no one is discussing it? Well, now I am! cope."</p>



<a name="277345826"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277345826" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277345826">(Mar 31 2022 at 22:01)</a>:</h4>
<p>yeah but nobody can remember PNVI-ae-udi^^</p>



<a name="277345853"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277345853" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277345853">(Mar 31 2022 at 22:01)</a>:</h4>
<p>I'll accept PNVI-C, tbh.</p>



<a name="277345854"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277345854" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277345854">(Mar 31 2022 at 22:02)</a>:</h4>
<p>strict provenance could reasonably be called PNVI-UB.<br>
under strict provenance, integers also have no provenance</p>



<a name="277345896"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277345896" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277345896">(Mar 31 2022 at 22:02)</a>:</h4>
<p>right.</p>



<a name="277345904"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277345904" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277345904">(Mar 31 2022 at 22:02)</a>:</h4>
<p>PNVI-strict</p>



<a name="277345918"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277345918" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277345918">(Mar 31 2022 at 22:02)</a>:</h4>
<p>but then SB would be PNVI-SB</p>



<a name="277345921"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277345921" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277345921">(Mar 31 2022 at 22:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="281757">Jubilee</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277345853">said</a>:</p>
<blockquote>
<p>I'll accept PNVI-C, tbh.</p>
</blockquote>
<p>maybe "PNVI-gcc"</p>



<a name="277345937"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277345937" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277345937">(Mar 31 2022 at 22:02)</a>:</h4>
<p>I mean we arent even considering giving provenance to integers</p>



<a name="277345951"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277345951" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277345951">(Mar 31 2022 at 22:02)</a>:</h4>
<p>so the PNVI prefix isnt even conveying any information</p>



<a name="277345952"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277345952" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277345952">(Mar 31 2022 at 22:02)</a>:</h4>
<p>right.</p>



<a name="277345971"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277345971" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277345971">(Mar 31 2022 at 22:02)</a>:</h4>
<p>Well, sorta.</p>



<a name="277346047"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277346047" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277346047">(Mar 31 2022 at 22:03)</a>:</h4>
<p>I think it's important that we all agree that integers do not have provenance, even if we believe that somehow provenance can jump the gap where a pointer briefly roleplays as an integer.</p>



<a name="277346127"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277346127" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277346127">(Mar 31 2022 at 22:04)</a>:</h4>
<p>Thus even though it conveys no additional information I would like that people continue using it, because it signals that we are on an initial page.</p>



<a name="277346270"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277346270" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277346270">(Mar 31 2022 at 22:06)</a>:</h4>
<p>We can probably, with more or less effort, find somewhere we agree on in this page.<br>
But that initial agreement step matters, and is not actually trivial, for realsies.</p>



<a name="277346346"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277346346" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277346346">(Mar 31 2022 at 22:06)</a>:</h4>
<p>doesn't C still have a bunch of type punning to contend with if it wants PNVI-ae? or does it really stop at memcpy?</p>



<a name="277346417"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277346417" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Thom Chiovoloni <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277346417">(Mar 31 2022 at 22:07)</a>:</h4>
<p>it has unions too</p>



<a name="277346427"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277346427" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Thom Chiovoloni <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277346427">(Mar 31 2022 at 22:07)</a>:</h4>
<p>but only in some cases</p>



<a name="277346442"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277346442" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277346442">(Mar 31 2022 at 22:07)</a>:</h4>
<p>PNVIplain doesn't allow address guessing, but it does this by introducing allocation address nondeterminism... Yeah.</p>



<a name="277346578"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277346578" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277346578">(Mar 31 2022 at 22:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="303115">Quy Nguyen</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277346442">said</a>:</p>
<blockquote>
<p>PNVIplain doesn't allow address guessing, but it does this by introducing allocation address nondeterminism... Yeah.</p>
</blockquote>
<p>oh hm.</p>



<a name="277346674"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277346674" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277346674">(Mar 31 2022 at 22:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="218745">Wanja Hentze</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277346346">said</a>:</p>
<blockquote>
<p>doesn't C still have a bunch of type punning to contend with if it wants PNVI-ae? or does it really stop at memcpy?</p>
</blockquote>
<p>right, there is C out there that is basically just broken according to the rules of C and miscompiles if pointed at the wrong architecture (and it's not always "weird arches like CHERI" doing the breaking, mind)</p>



<a name="277346851"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277346851" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277346851">(Mar 31 2022 at 22:11)</a>:</h4>
<p>like it's not even "under optimizations" broken, it's just "lol it doesn't work"<br>
this is not necessarily an issue ofc for C on a typical x86-64 machine, I can cheerfully acknowledge that.</p>



<a name="277346880"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277346880" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277346880">(Mar 31 2022 at 22:11)</a>:</h4>
<p>Right, but I was under the impression that at least certain forms of union punning were legal.</p>



<a name="277347004"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277347004" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277347004">(Mar 31 2022 at 22:12)</a>:</h4>
<p>plain pointer casting to an incompatible type (followed by an access) is UB, that much I know</p>



<a name="277347086"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277347086" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277347086">(Mar 31 2022 at 22:13)</a>:</h4>
<p>I think talking about platform provenance or PNVI-ae-udi is probably the most clear. In C, union type punning is legal in C proper, so union reads are implicit expose points. Under Cereberus (the checker for PNVI), it allows no strict aliasing semantics, and redundant loads and stores cannot be removed.</p>



<a name="277347228"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277347228" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277347228">(Mar 31 2022 at 22:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="218745">Wanja Hentze</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277346880">said</a>:</p>
<blockquote>
<p>Right, but I was under the impression that at least certain forms of union punning were legal.</p>
</blockquote>
<p><a href="https://trofi.github.io/posts/191-ghc-on-m68k.html">https://trofi.github.io/posts/191-ghc-on-m68k.html</a><br>
only darkness now <em>gazes into the distance</em></p>



<a name="277347731"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277347731" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277347731">(Mar 31 2022 at 22:20)</a>:</h4>
<p>That's not a union pun, it's a function-pointer pun.</p>



<a name="277347816"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277347816" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277347816">(Mar 31 2022 at 22:21)</a>:</h4>
<p>by which I mean calling a function pointer with the wrong function type.</p>



<a name="277347901"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277347901" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277347901">(Mar 31 2022 at 22:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277343658">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277341328">said</a>:</p>
<blockquote>
<p>I imagine the rules for ptr2int2ptr might be that</p>
<ul>
<li><code>ptr as usize</code> "broadcasts" that pointer's provenance</li>
<li><code>usize as ptr</code> picks <em>some</em> 'broadcast' provenance, namely the one that works. (basically: speculatively execute the program with each possible choice, pick the one that is not UB. formally: angelic non-determinism.)</li>
</ul>
<p>under these rules, if we can get the compiler to honor that "broadcasting" (treat ptr2int as having a sort of side-effect), I don't see how we could misoptimize. it's just a hideous model to check a program against (in miri, CHERI, a model checker, really any context), so it'd be great if we could avoid using it except for 'legacy' applications. :D</p>
</blockquote>
<p>so <span class="user-mention silent" data-user-id="384014">Patrick Walton</span> regarding this model there is a possible surprise left... what this would not let you do is <em>transmute</em> a pointer to an integer and then cast that back and do anything with it. transmutes rather than casts are their own can of worms... but that seems even less common that doing the casts?<br>
(note that by transmute I mean any form of type punning, via <code>mem::transmute</code>, via unions, or via pointer type punning).</p>
</blockquote>
<p>This might work. Another possibility would be special case the function <code>mem::transmute</code> and make it an intrinsic</p>



<a name="277347941"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277347941" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277347941">(Mar 31 2022 at 22:23)</a>:</h4>
<p>It could be that 99% of ptr-to-int casts are either through <code>as</code> or through <code>mem::transmute</code>.</p>



<a name="277347979"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277347979" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277347979">(Mar 31 2022 at 22:23)</a>:</h4>
<p>Then we could declare other ways UB and only have a couple of stragglers to fix up. I don't love this solution but it could work in practice.</p>



<a name="277347993"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277347993" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277347993">(Mar 31 2022 at 22:23)</a>:</h4>
<p>What about <code>ptr::cast</code>?</p>



<a name="277348062"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277348062" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277348062">(Mar 31 2022 at 22:24)</a>:</h4>
<p>Is that an <code>as</code> internally?</p>



<a name="277348067"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277348067" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277348067">(Mar 31 2022 at 22:24)</a>:</h4>
<p><span class="user-mention silent" data-user-id="218745">Wanja Hentze</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277347993">said</a>:</p>
<blockquote>
<p>What about <code>ptr::cast</code>?</p>
</blockquote>
<p>That too. Basically I mean just allowlist a special set of commonly-used "cast-like" functions</p>



<a name="277348139"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277348139" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277348139">(Mar 31 2022 at 22:25)</a>:</h4>
<p>This is like what C ended up doing with strict-aliasing. <code>char</code> becomes the allowlisted "magic type punny type" because that's what people were doing in practice.</p>



<a name="277348144"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277348144" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277348144">(Mar 31 2022 at 22:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="218745">Wanja Hentze</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277347993">said</a>:</p>
<blockquote>
<p>What about <code>ptr::cast</code>?</p>
</blockquote>
<p>It's an <code>as</code>, but it's <a href="https://doc.rust-lang.org/std/primitive.pointer.html#method.cast">only ptr-to-ptr</a>, not ptr-to-int.</p>



<a name="277348191"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277348191" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277348191">(Mar 31 2022 at 22:25)</a>:</h4>
<p>We could probably analyze which functions people cast with in the wild.</p>



<a name="277348192"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277348192" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277348192">(Mar 31 2022 at 22:25)</a>:</h4>
<p>right, but you can use it for ptr-ptr to int-ptr</p>



<a name="277348193"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277348193" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277348193">(Mar 31 2022 at 22:25)</a>:</h4>
<p><code>mem::transmute</code> is actually the one that pretty much has to be UB to do the ptr-&gt;int conversion</p>



<a name="277348196"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277348196" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277348196">(Mar 31 2022 at 22:25)</a>:</h4>
<p><span class="user-mention" data-user-id="120791">@RalfJ</span> I'm a bit confused what exactly you're proposing.  Are you saying we would generate more-conservative LLVM IR, or are you talking about hypothetical changes to LLVM optimizations?  In the former case I don't see why transmutes would be any /more/ broken than they are today.</p>



<a name="277348287"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277348287" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277348287">(Mar 31 2022 at 22:26)</a>:</h4>
<p>It's easier to preserve <code>ptr as int</code> than <code>transmute(ptr) -&gt; int</code></p>



<a name="277348296"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277348296" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277348296">(Mar 31 2022 at 22:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="281757">Jubilee</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277348287">said</a>:</p>
<blockquote>
<p>It's easier to preserve <code>ptr as int</code> than <code>transmute(ptr) -&gt; int</code></p>
</blockquote>
<p>Why?</p>



<a name="277348323"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277348323" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277348323">(Mar 31 2022 at 22:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="384014">Patrick Walton</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277347901">said</a>:</p>
<blockquote>
<p>This might work. Another possibility would be special case the function <code>mem::transmute</code> and make it an intrinsic</p>
</blockquote>
<p>Seems a potential can of worms. How about transmute to <code>[*T]</code>? Could be &gt; O(n) on CHERI</p>



<a name="277348341"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277348341" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277348341">(Mar 31 2022 at 22:27)</a>:</h4>
<p>If you make transmute an intrinsic then the compiler is free to optimize <code>transmute(ptr) -&gt; int</code> identically to <code>ptr as int</code></p>



<a name="277348351"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277348351" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277348351">(Mar 31 2022 at 22:27)</a>:</h4>
<p>transmute and its moral equivalents would have to expose any addresses converted arbitrarily deep into the hierarchy, right?</p>



<a name="277348372"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277348372" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277348372">(Mar 31 2022 at 22:27)</a>:</h4>
<p>(It would just be that avoiding transmutes would put you in the "known-good formalizable subset", but not avoiding them would still put you in today's safe-other-than-pathological-examples subset‚Ä¶?)</p>



<a name="277348466"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277348466" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277348466">(Mar 31 2022 at 22:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277348323">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="384014">Patrick Walton</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277347901">said</a>:</p>
<blockquote>
<p>This might work. Another possibility would be special case the function <code>mem::transmute</code> and make it an intrinsic</p>
</blockquote>
<p>Seems a potential can of worms. How about transmute to <code>[*T]</code>? Could be &gt; O(n) on CHERI</p>
</blockquote>
<p>In general, I'm not sure we should hold back our semantics because of O(n) behavior on CHERI, unless we know there is some concrete use case that needs CHERI (e.g. if Google says "all Android apps must be CHERI compliant").</p>



<a name="277348476"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277348476" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277348476">(Mar 31 2022 at 22:28)</a>:</h4>
<p>you can transmute [&amp;*const (); 15] to [&usize; 15] or something</p>



<a name="277348479"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277348479" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277348479">(Mar 31 2022 at 22:28)</a>:</h4>
<p><span class="user-mention" data-user-id="218745">@Wanja Hentze</span> Nah - it's just that if you write a pointer to some memory and then read it from a pointer-to-integer, that has to count as a provenance broadcast (or else converting the integer back to a pointer would be UB).</p>



<a name="277348520"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277348520" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277348520">(Mar 31 2022 at 22:29)</a>:</h4>
<p>if the exposure happens on the read, not the cast, doesn't that mean we kinda have typed memory then?</p>



<a name="277348525"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277348525" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277348525">(Mar 31 2022 at 22:29)</a>:</h4>
<p>But in any case, you could imagine something like semantics that say transmute of a raw pointer <em>only</em> is defined (e.g. <code>*T -&gt; usize</code> is OK, <code>(*T, *T) -&gt; (usize, usize)</code> is not). You can be as messy as you want.</p>



<a name="277348551"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277348551" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277348551">(Mar 31 2022 at 22:29)</a>:</h4>
<p>The point is to keep currently-working code working.</p>



<a name="277348702"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277348702" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277348702">(Mar 31 2022 at 22:31)</a>:</h4>
<p>are direct ptr/int transmutes that common? they really serve no good purpose as far as I can tell</p>



<a name="277348765"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277348765" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277348765">(Mar 31 2022 at 22:32)</a>:</h4>
<blockquote>
<p>This might work. Another possibility would be special case the function mem::transmute and make it an intrinsic</p>
</blockquote>
<p><code>transmute</code> works on <em>all</em> types though, so it's somewhat hard to define such an exception.<br>
also, if we allow them we very quickly see that things just <em>obviously</em> don't work: <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/286#issuecomment-1085144431">https://github.com/rust-lang/unsafe-code-guidelines/issues/286#issuecomment-1085144431</a>. like, ptr2int2ptr roundtrips with explicit casts can be salvaged with some work, but the transmutes are a lost cause I think.<br>
EDIT: well I guess we'd have to <em>also</em> special-case int2ptr transmutes. that could work. but... ugh.</p>



<a name="277348768"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277348768" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277348768">(Mar 31 2022 at 22:32)</a>:</h4>
<blockquote>
<p>But in any case, you could imagine something like semantics that say transmute of a raw pointer <em>only</em> is defined (e.g. <code>*T -&gt; usize</code> is OK, <code>(*T, *T) -&gt; (usize, usize)</code> is not). You can be as messy as you want.</p>
</blockquote>
<p>That seems very hard to learn</p>



<a name="277348770"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277348770" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277348770">(Mar 31 2022 at 22:32)</a>:</h4>
<p>the cases where the cast happens behind some indirection are much more interesting imo because those are not served by <code>as</code></p>



<a name="277348775"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277348775" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277348775">(Mar 31 2022 at 22:32)</a>:</h4>
<p><span class="user-mention silent" data-user-id="198590">comex</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277348372">said</a>:</p>
<blockquote>
<p>(It would just be that avoiding transmutes would put you in the "known-good formalizable subset", but not avoiding them would still put you in today's safe-other-than-pathological-examples subset‚Ä¶?)</p>
</blockquote>
<p>This is an important point. I think it would be helpful to be clear about whether we're talking about using this memory model to introduce aggressive optimizations that may break existing code. Because if it's "just formalizability", then we can break things.</p>



<a name="277348798"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277348798" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277348798">(Mar 31 2022 at 22:32)</a>:</h4>
<p><span class="user-mention silent" data-user-id="198590">comex</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277348196">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> I'm a bit confused what exactly you're proposing.  Are you saying we would generate more-conservative LLVM IR, or are you talking about hypothetical changes to LLVM optimizations?  In the former case I don't see why transmutes would be any /more/ broken than they are today.</p>
</blockquote>
<p>sorry, which proposal are you referring to?</p>



<a name="277348828"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277348828" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277348828">(Mar 31 2022 at 22:33)</a>:</h4>
<p><span class="user-mention" data-user-id="218745">@Wanja Hentze</span> Well, I should say, @RalfJ was just advocating for having it be UB not to do the *read itself, but to convert the resulting integer back to a pointer.  But if you want this to not be UB, then the broadcast has to happen at the time of the read.</p>



<a name="277348838"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277348838" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277348838">(Mar 31 2022 at 22:33)</a>:</h4>
<p>Note that IIUC, in C with PNVI, transmute of an array pointer also doesn't work</p>



<a name="277348843"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277348843" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277348843">(Mar 31 2022 at 22:33)</a>:</h4>
<p>right.</p>



<a name="277348867"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277348867" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277348867">(Mar 31 2022 at 22:33)</a>:</h4>
<p>We don't necessarily have to be holier than C</p>



<a name="277348868"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277348868" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277348868">(Mar 31 2022 at 22:33)</a>:</h4>
<p>transmute basically works because it does a bit-copy and asserts this is the new type.</p>



<a name="277348881"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277348881" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277348881">(Mar 31 2022 at 22:33)</a>:</h4>
<p>as opposed to a potentially lossy Magic Conversion Operation</p>



<a name="277348885"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277348885" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277348885">(Mar 31 2022 at 22:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277348768">said</a>:</p>
<blockquote>
<blockquote>
<p>But in any case, you could imagine something like semantics that say transmute of a raw pointer <em>only</em> is defined (e.g. <code>*T -&gt; usize</code> is OK, <code>(*T, *T) -&gt; (usize, usize)</code> is not). You can be as messy as you want.</p>
</blockquote>
<p>That seems very hard to learn</p>
</blockquote>
<p>Not breaking code is more important than learnability, if we're talking about doing optimizations. (If it's just formalizability, then that might not be the case)</p>



<a name="277348937"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277348937" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277348937">(Mar 31 2022 at 22:34)</a>:</h4>
<p><code>as</code> is, in a sense, our Magic Conversion, as opposed to Transmute.</p>



<a name="277348943"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277348943" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277348943">(Mar 31 2022 at 22:34)</a>:</h4>
<p>I guess we should investigate how much <code>transmute</code> is being used to a pointer</p>



<a name="277348967"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277348967" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277348967">(Mar 31 2022 at 22:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277348798">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="198590">comex</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277348196">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> I'm a bit confused what exactly you're proposing.  Are you saying we would generate more-conservative LLVM IR, or are you talking about hypothetical changes to LLVM optimizations?  In the former case I don't see why transmutes would be any /more/ broken than they are today.</p>
</blockquote>
<p>sorry, which proposal are you referring to?</p>
</blockquote>
<p>The regime you're talking about where ptr2int2ptr is okay, but doing the same with transmutes loses provenance.</p>



<a name="277348990"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277348990" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277348990">(Mar 31 2022 at 22:35)</a>:</h4>
<p>my point was: direct int/ptr transmute is silly, you can immediately replace it with <code>as</code> in 100% of cases so if it isn't already, it should be a default clippy lint</p>



<a name="277349016"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277349016" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277349016">(Mar 31 2022 at 22:35)</a>:</h4>
<p>Right.</p>



<a name="277349017"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277349017" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277349017">(Mar 31 2022 at 22:35)</a>:</h4>
<p><span class="user-mention" data-user-id="465167">@Bram Geron</span> Definitely worthwhile. I can look into doing a crater run if people think this is worthwhile</p>



<a name="277349020"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277349020" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277349020">(Mar 31 2022 at 22:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="384014">Patrick Walton</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277348296">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="281757">Jubilee</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277348287">said</a>:</p>
<blockquote>
<p>It's easier to preserve <code>ptr as int</code> than <code>transmute(ptr) -&gt; int</code></p>
</blockquote>
<p>Why?</p>
</blockquote>
<p><code>as</code> is a very targeted primitive that it is easy to ascribe special rules for, that only works with certain very specific types.<br>
<code>transmutes</code> works for arbitrary input output types, so we'd have to either make wild lists of exceptions or find some generic rule that makes any sense.</p>



<a name="277349041"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277349041" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277349041">(Mar 31 2022 at 22:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="218745">Wanja Hentze</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277348990">said</a>:</p>
<blockquote>
<p>my point was: direct int/ptr transmute is silly, you can immediately replace it with <code>as</code> in 100% of cases so if it isn't already, it should be a default clippy lint</p>
</blockquote>
<p>ah yes that is also a very good argument :)</p>



<a name="277349046"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277349046" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277349046">(Mar 31 2022 at 22:35)</a>:</h4>
<p><em>if</em> transmute that turns ptrs to ints is to be supported, then it only makes sense if the nontrivial cases work</p>



<a name="277349047"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277349047" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277349047">(Mar 31 2022 at 22:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="218745">Wanja Hentze</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277348990">said</a>:</p>
<blockquote>
<p>my point was: direct int/ptr transmute is silly, you can immediately replace it with <code>as</code> in 100% of cases so if it isn't already, it should be a default clippy lint</p>
</blockquote>
<p>Be that as it may, if people are using <code>mem::transmute</code> instead of <code>as</code>, we should continue supporting it if we don't want to break code.</p>



<a name="277349115"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277349115" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277349115">(Mar 31 2022 at 22:36)</a>:</h4>
<p>I think "not breaking code" is a two-way conversation, for code like this that lives "on the edge"</p>



<a name="277349133"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277349133" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277349133">(Mar 31 2022 at 22:37)</a>:</h4>
<p>Still unclear to me what concrete change we're talking about that would cause this to break.</p>



<a name="277349142"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277349142" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277349142">(Mar 31 2022 at 22:37)</a>:</h4>
<p>IMO, if we tell you "here's an easy change you can apply basically automatically to avoid breaking your code". that's a reasonable ask from our side</p>



<a name="277349148"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277349148" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277349148">(Mar 31 2022 at 22:37)</a>:</h4>
<p>I would really like to not break code, but for me it's not a 100% absolute.</p>



<a name="277349151"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277349151" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277349151">(Mar 31 2022 at 22:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277349142">said</a>:</p>
<blockquote>
<p>IMO, if we tell you "here's an easy change you can apply basically automatically to avoid breaking your code". that's a reasonable ask from our side</p>
</blockquote>
<p>I strongly disagree.</p>



<a name="277349182"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277349182" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277349182">(Mar 31 2022 at 22:37)</a>:</h4>
<p>FWIW <a href="https://github.com/rust-lang/rust/pull/95516">https://github.com/rust-lang/rust/pull/95516</a> fixes one of those transmutes, and it's not <code>*const</code> to <code>usize</code>, it is some opaque assoc type top <code>usize</code>.</p>



<a name="277349190"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277349190" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277349190">(Mar 31 2022 at 22:37)</a>:</h4>
<p><span class="user-mention" data-user-id="198590">@comex</span> strict provenance breaks both this and <code>int as ptr</code>. PNVI-ae with special casing for <code>as</code> breaks the transmute</p>



<a name="277349257"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277349257" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277349257">(Mar 31 2022 at 22:38)</a>:</h4>
<p><span class="user-mention silent" data-user-id="198590">comex</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277349133">said</a>:</p>
<blockquote>
<p>Still unclear to me what concrete change we're talking about that would cause this to break.</p>
</blockquote>
<p>I think <code>transmute</code> from a ptr (with provenance) to an int is UB (as in, it is already broken as of today and we might just get lucky that LLVM hasn't broken anything yet). also see <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/286#issuecomment-1085144431for">https://github.com/rust-lang/unsafe-code-guidelines/issues/286#issuecomment-1085144431for</a> why.</p>



<a name="277349293"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277349293" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277349293">(Mar 31 2022 at 22:38)</a>:</h4>
<p>The spirit of the Rust 1.0 compatibility promise is that Rust will not make changes that will break code, outside of a specifically delineated set of exceptions. In particular, there's no "it's an easy fix" exception.</p>



<a name="277349309"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277349309" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277349309">(Mar 31 2022 at 22:38)</a>:</h4>
<p>I know that unsafe code is one of those specifically-delimited set of exceptions.</p>



<a name="277349324"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277349324" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277349324">(Mar 31 2022 at 22:39)</a>:</h4>
<p>And transmute is <code>unsafe fn</code>.</p>



<a name="277349377"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277349377" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277349377">(Mar 31 2022 at 22:39)</a>:</h4>
<p>But the reasoning behind that decision applies to unsafe code at this point too, whether we explicitly acknowledge it or not.</p>



<a name="277349380"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277349380" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277349380">(Mar 31 2022 at 22:39)</a>:</h4>
<p>I mean we certainly won't be able to preserve all code that is UB but 'happens to work'.<br>
we also have no precise spec for UB. so we're going to have to break <em>some</em> code that people think doesn't have UB (but actually does), that is just inevitable.</p>



<a name="277349447"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277349447" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277349447">(Mar 31 2022 at 22:40)</a>:</h4>
<p>this has nothing to do with strict provenance</p>



<a name="277349466"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277349466" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277349466">(Mar 31 2022 at 22:40)</a>:</h4>
<p>We're having this whole discussion because we want to provide (at least _some_) backwards compatibility for Unsafe Rust.</p>



<a name="277349475"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277349475" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277349475">(Mar 31 2022 at 22:40)</a>:</h4>
<p>each LLVM update will break some code with UB, whether or not the author agrees that the code has UB or not</p>



<a name="277349507"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277349507" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277349507">(Mar 31 2022 at 22:41)</a>:</h4>
<p>I don't want to start this point again ‚Äî we all want to keep some/most/all backwards compatibility here</p>



<a name="277349513"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277349513" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277349513">(Mar 31 2022 at 22:41)</a>:</h4>
<p>Okay.  But if you're just saying 'LLVM might break this in the future', rather than 'let's go ahead and add Rust-specific optimizations that break this', then pcwalton has nothing to be afraid of from this effort in particular.</p>



<a name="277349545"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277349545" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277349545">(Mar 31 2022 at 22:41)</a>:</h4>
<p>well, I should say -</p>



<a name="277349570"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277349570" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277349570">(Mar 31 2022 at 22:41)</a>:</h4>
<p><span class="user-mention" data-user-id="120791">@RalfJ</span> what does miri currently do with ptr-to-int transmute?</p>



<a name="277349579"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277349579" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277349579">(Mar 31 2022 at 22:41)</a>:</h4>
<p>'LLVM might break this in less-pathological code than it currently does, and/or someone might write code that LLVM currently breaks'</p>



<a name="277349583"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277349583" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277349583">(Mar 31 2022 at 22:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277349475">said</a>:</p>
<blockquote>
<p>each LLVM update will break some code with UB, whether or not the author agrees that the code has UB or not</p>
</blockquote>
<p>Correct. But that's not a license for LLVM to break code willy-nilly. For LLVM it ends up being a subjective judgment call depending on whether there's a lot of important code that will break.</p>



<a name="277349597"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277349597" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277349597">(Mar 31 2022 at 22:42)</a>:</h4>
<p>I think it's the same for us</p>



<a name="277349640"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277349640" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277349640">(Mar 31 2022 at 22:42)</a>:</h4>
<p>Agreed.</p>



<a name="277349657"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277349657" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277349657">(Mar 31 2022 at 22:42)</a>:</h4>
<p>well, whether or not you transmute directly from pointer to int is a statically checkable property of a rust program, right? can we count how often people do that to put some data to this discussion?</p>



<a name="277349707"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277349707" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277349707">(Mar 31 2022 at 22:42)</a>:</h4>
<p>crater runs are often used in the case of technically-but-maybe-not-morally-breaking changes</p>



<a name="277349711"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277349711" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277349711">(Mar 31 2022 at 22:42)</a>:</h4>
<p><span class="user-mention" data-user-id="120791">@RalfJ</span> Your new example makes me more convinced that what we actually need is PVI :)</p>



<a name="277349714"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277349714" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277349714">(Mar 31 2022 at 22:43)</a>:</h4>
<p>yeah totally. but I think this kind of working with each other to move the langue towards a better understanding of UB has to be a two-way street.  when a certain coding pattern is clearly cursed and not supportable, I dont think it is reasonable for programmers to refuse to move by even an inch and expect the compiler to do all the heavy lifting.</p>



<a name="277349747"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277349747" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277349747">(Mar 31 2022 at 22:43)</a>:</h4>
<p>And yes, I know that has its own problems.</p>



<a name="277349766"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277349766" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277349766">(Mar 31 2022 at 22:43)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277349714">said</a>:</p>
<blockquote>
<p>yeah totally. but I think this kind of working with each other to move the langue towards a better understanding of UB has to be a two-way street.  when a certain coding pattern is clearly cursed and not supportable, I dont think it is reasonable for programmers to refuse to move bt even an inch and expect the compiler to do all the heavy lifting.</p>
</blockquote>
<p>Yeah. To be clear: my position isn't "if there's a single line of code internally that breaks I'll stand in the way". It's "we have too much code to feasibly make <em>large</em> breaking changes".</p>



<a name="277349842"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277349842" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277349842">(Mar 31 2022 at 22:44)</a>:</h4>
<p>like, I dont have synmpathy for compiler and lang devs that ignore programmer concerns and just say "the law says its UB so not-a-bug".<br>
I also dont have sympathy for developers that ignore compiler and language devs and just say "but this happened to work in the past and I insist it keeps working no matter what".</p>



<a name="277349851"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277349851" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277349851">(Mar 31 2022 at 22:44)</a>:</h4>
<p>We have and consistently do work to remove UB from our code.</p>



<a name="277349872"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277349872" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277349872">(Mar 31 2022 at 22:44)</a>:</h4>
<p>I just think there has to be a limit.</p>



<a name="277349876"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277349876" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277349876">(Mar 31 2022 at 22:44)</a>:</h4>
<p>I agree with what Ralf said.</p>



<a name="277349893"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277349893" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277349893">(Mar 31 2022 at 22:44)</a>:</h4>
<p>FWIW, I know for a fact that people also transmute (directly and via pointer cast) byte arrays to structs-with-pointers-in-them</p>



<a name="277349924"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277349924" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277349924">(Mar 31 2022 at 22:45)</a>:</h4>
<p>we basically broke <code>mem::uninitialized</code> and (to my great surprise) got away with that</p>



<a name="277349939"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277349939" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277349939">(Mar 31 2022 at 22:45)</a>:</h4>
<p>I can't imagine that ptr int transmutes are more common than that...</p>



<a name="277349959"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277349959" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277349959">(Mar 31 2022 at 22:45)</a>:</h4>
<p>which is why the solution to special case only the trivial ptr/int transmutes feels off to me</p>



<a name="277349973"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277349973" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277349973">(Mar 31 2022 at 22:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277349924">said</a>:</p>
<blockquote>
<p>we basically broke <code>mem::uninitialized</code> and (to my great surprise) got away with that</p>
</blockquote>
<p>Do you have a link to more details here? I'd be very interested. Sounds like an important data point.</p>



<a name="277349988"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277349988" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277349988">(Mar 31 2022 at 22:45)</a>:</h4>
<p>What does miri currently do with ptr-to-int transmute?</p>



<a name="277350064"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277350064" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277350064">(Mar 31 2022 at 22:46)</a>:</h4>
<p>The reason in particular I think people may <code>mem::transmute</code> pointer to int is that it lets you avoid double-<code>as</code> in some cases.</p>



<a name="277350068"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277350068" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277350068">(Mar 31 2022 at 22:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="384014">Patrick Walton</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277349973">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277349924">said</a>:</p>
<blockquote>
<p>we basically broke <code>mem::uninitialized</code> and (to my great surprise) got away with that</p>
</blockquote>
<p>Do you have a link to more details here? I'd be very interested. Sounds like an important data point.</p>
</blockquote>
<p>this was years ago...<br>
<a href="https://github.com/rust-lang/rust/issues/66151">https://github.com/rust-lang/rust/issues/66151</a><br>
<a href="https://gankra.github.io/blah/initialize-me-maybe/">https://gankra.github.io/blah/initialize-me-maybe/</a></p>



<a name="277350088"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277350088" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277350088">(Mar 31 2022 at 22:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277349988">said</a>:</p>
<blockquote>
<p>What does miri currently do with ptr-to-int transmute?</p>
</blockquote>
<p>by default, it creates an integer with provenance.<br>
with <code>-Zmiri-check-number-validity</code>, it says this is UB.</p>



<a name="277350111"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277350111" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277350111">(Mar 31 2022 at 22:47)</a>:</h4>
<p><span class="user-mention silent" data-user-id="384014">Patrick Walton</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277350064">said</a>:</p>
<blockquote>
<p>The reason in particular I think people may <code>mem::transmute</code> pointer to int is that it lets you avoid double-<code>as</code> in some cases.</p>
</blockquote>
<p>that sounds like a really bad reason to use the bazooka that is <code>transmute</code> :(</p>



<a name="277350119"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277350119" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277350119">(Mar 31 2022 at 22:47)</a>:</h4>
<p>From my perspective, the goal should be essentially to make the changes necessary to establish a model that we can establish, yes, as formally as possible, is not something LLVM should ever break, and then demand they support us. They seem inclined to wave off anything less, and they do wibble a lot on what is sound and unsound. I want us to be able to preempt LLVM's attempts to figure out their own stuff and "outbid" them: to present so compelling an argument that it should always win.</p>



<a name="277350142"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277350142" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277350142">(Mar 31 2022 at 22:47)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277350068">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="384014">Patrick Walton</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277349973">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277349924">said</a>:</p>
<blockquote>
<p>we basically broke <code>mem::uninitialized</code> and (to my great surprise) got away with that</p>
</blockquote>
<p>Do you have a link to more details here? I'd be very interested. Sounds like an important data point.</p>
</blockquote>
<p>this was years ago...<br>
<a href="https://github.com/rust-lang/rust/issues/66151">https://github.com/rust-lang/rust/issues/66151</a><br>
<a href="https://gankra.github.io/blah/initialize-me-maybe/">https://gankra.github.io/blah/initialize-me-maybe/</a></p>
</blockquote>
<p>Ah yes. As I recall this required a not insignificant amount of work from our side.</p>



<a name="277350168"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277350168" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277350168">(Mar 31 2022 at 22:47)</a>:</h4>
<p>Right up to the limit of what was feasible.</p>



<a name="277350236"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277350236" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277350236">(Mar 31 2022 at 22:48)</a>:</h4>
<p>it required a lot of work from many people. <span aria-label="heart" class="emoji emoji-2764" role="img" title="heart">:heart:</span> for being part of the effort. :)</p>



<a name="277350241"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277350241" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277350241">(Mar 31 2022 at 22:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277350111">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="384014">Patrick Walton</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277350064">said</a>:</p>
<blockquote>
<p>The reason in particular I think people may <code>mem::transmute</code> pointer to int is that it lets you avoid double-<code>as</code> in some cases.</p>
</blockquote>
<p>that sounds like a really bad reason to use the bazooka that is <code>transmute</code> :(</p>
</blockquote>
<p>Good or bad, it's what people do. I know I've done it.</p>



<a name="277350256"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277350256" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277350256">(Mar 31 2022 at 22:48)</a>:</h4>
<p>After all, we haven't told people <em>not</em> to.</p>



<a name="277350272"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277350272" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277350272">(Mar 31 2022 at 22:48)</a>:</h4>
<p>yeah</p>



<a name="277350289"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277350289" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277350289">(Mar 31 2022 at 22:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="198590">comex</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277349711">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> Your new example makes me more convinced that what we actually need is PVI :)</p>
</blockquote>
<p>lol I thought we were over that ;)</p>



<a name="277350291"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277350291" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277350291">(Mar 31 2022 at 22:49)</a>:</h4>
<p>And we've given people syntactic salt with double-<code>as</code>, so people will pick the sugary thing. Which is <code>mem::transmute</code> in this case.</p>



<a name="277350311"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277350311" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277350311">(Mar 31 2022 at 22:49)</a>:</h4>
<p>double-<code>as</code> is safe though</p>



<a name="277350324"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277350324" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277350324">(Mar 31 2022 at 22:49)</a>:</h4>
<p>so I am surprised people would reach for the unsafe thing</p>



<a name="277350329"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277350329" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277350329">(Mar 31 2022 at 22:49)</a>:</h4>
<p>And also, I believe that relying on Vibes does incredible damage to learnability, to a point that people really, really underestimate.</p>



<a name="277350406"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277350406" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277350406">(Mar 31 2022 at 22:50)</a>:</h4>
<p>but yeah I mean I cant argue with the reality of people doing it, I can just say it's a bad surprise to me</p>



<a name="277350427"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277350427" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277350427">(Mar 31 2022 at 22:50)</a>:</h4>
<p>we could have lints to start moving people away from that, the cases where it's literally usize ‚Üí ptr or vice versa should be easy to detect</p>



<a name="277350451"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277350451" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277350451">(Mar 31 2022 at 22:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="281757">Jubilee</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277350119">said</a>:</p>
<blockquote>
<p>From my perspective, the goal should be essentially to make the changes necessary to establish a model that we can establish, yes, as formally as possible, is not something LLVM should ever break, and then demand they support us. They seem inclined to wave off anything less, and they do wibble a lot on what is sound and unsound. I want us to be able to preempt LLVM's attempts to figure out their own stuff and "outbid" them: to present so compelling an argument that it should always win.</p>
</blockquote>
<p>Sounds good to me.  But if establishing a subset is <em>all</em> we're doing ‚Äì that is, we're not actively changing anything (e.g. adding MIR optimizations) in a way that breaks code that currently works outside of the model, it's just that <em>LLVM</em> might break it ‚Äì then we should make that clear.  Because there is a big difference between 'what LLVM might do' and 'what LLVM is likely to do', especially when it comes to potentially breaking legacy code.</p>



<a name="277350454"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277350454" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277350454">(Mar 31 2022 at 22:50)</a>:</h4>
<p>clippy might already do that...</p>



<a name="277350464"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277350464" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277350464">(Mar 31 2022 at 22:50)</a>:</h4>
<p>true, but from my experience people start out with a very naive mental model</p>



<a name="277350493"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277350493" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277350493">(Mar 31 2022 at 22:51)</a>:</h4>
<p>like, I have trouble teaching people that unaligned references are UB</p>



<a name="277350509"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277350509" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277350509">(Mar 31 2022 at 22:51)</a>:</h4>
<p>I just want to avoid ending up in a Python 3 situation, where Python 3 was simpler in all aspects but there was too much code in Python 2 that it ended up making things worse in practice for a very long time.</p>



<a name="277350515"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277350515" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277350515">(Mar 31 2022 at 22:51)</a>:</h4>
<p><span class="user-mention" data-user-id="384014">@Patrick Walton</span>  Just out of curiosity, what if it turns out there needs to be a performance regression in order to make "stuff we think is UB but is too commonly used to break" continue to work in all cases? At what point is the performance regression itself a breaking change?</p>



<a name="277350524"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277350524" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277350524">(Mar 31 2022 at 22:51)</a>:</h4>
<p><span class="user-mention" data-user-id="198590">@comex</span> well I'd really love to at least have an idea for a model that also accounts for the remaining language outside the 'strict' subset. something that gives a chance of evaluating whether an optimization is correct, even if the details are somewhat fuzzy and LLVM won't tell us enough to be sure we use their IR correctly.</p>



<a name="277350532"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277350532" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277350532">(Mar 31 2022 at 22:51)</a>:</h4>
<p><span class="user-mention" data-user-id="120791">@RalfJ</span> But code that uses raw pointers is likely to already have unsafe blocks in it, and newbies may not be aware that the double cast is even possible.  (As in, they try to do a single cast, see the compiler error, and fall back to transmute.)</p>



<a name="277350534"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277350534" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277350534">(Mar 31 2022 at 22:51)</a>:</h4>
<p><span class="user-mention silent" data-user-id="218745">Wanja Hentze</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277350464">said</a>:</p>
<blockquote>
<p>true, but from my experience people start out with a very naive mental model</p>
</blockquote>
<p>true dat</p>



<a name="277350654"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277350654" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277350654">(Mar 31 2022 at 22:52)</a>:</h4>
<p>So if at all possible, I would love something that not only breaks little existing code, but doesn't break the naive mental model <em>too much</em> (yes, that is a very big ask I realize)</p>



<a name="277350676"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277350676" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277350676">(Mar 31 2022 at 22:53)</a>:</h4>
<p>but with <code>transmute</code> that's... very tricky to say the last? if we ignore LLVM I guess we can go wild and just say "okay all provenancnes in the transmuted data are exposed". but then no MIR opt may remove a <code>transmute</code> whose result is unused...</p>



<a name="277350706"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277350706" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277350706">(Mar 31 2022 at 22:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="198590">comex</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277350451">said</a>:</p>
<blockquote>
<p>Sounds good to me.  But if establishing a subset is <em>all</em> we're doing ‚Äì that is, we're not actively changing anything (e.g. adding MIR optimizations) in a way that breaks code that currently works outside of the model, it's just that <em>LLVM</em> might break it ‚Äì then we should make that clear.  Because there is a big difference between 'what LLVM might do' and 'what LLVM is likely to do', especially when it comes to potentially breaking legacy code.</p>
</blockquote>
<p>I suppose. I am fine with admitting I basically have what other people might consider an unrealistically cynical position on LLVM in many cases.</p>



<a name="277350737"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277350737" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277350737">(Mar 31 2022 at 22:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="295632">Diggsey</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277350515">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="384014">Patrick Walton</span>  Just out of curiosity, what if it turns out there needs to be a performance regression in order to make "stuff we think is UB but is too commonly used to break" continue to work in all cases? At what point is the performance regression itself a breaking change?</p>
</blockquote>
<p>There are no hard and fast rules here. In practice it's "if it's big and important enough of a regression, LLVM reverts it".</p>



<a name="277350744"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277350744" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277350744">(Mar 31 2022 at 22:53)</a>:</h4>
<p>also what about pinter-based or union-based type punning? should that be legal too? (I can easily replace the example to use that instead of <code>transmute</code>)</p>



<a name="277350804"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277350804" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277350804">(Mar 31 2022 at 22:54)</a>:</h4>
<p>But again, I speak from the PoV of someone who sees LLVM devs tending to fight rather than accept requests from the Rust project.</p>



<a name="277350817"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277350817" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277350817">(Mar 31 2022 at 22:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277350676">said</a>:</p>
<blockquote>
<p>but with <code>transmute</code> that's... very tricky to say the last? if we ignore LLVM I guess we can go wild and just say "okay all provenancnes in the transmuted data are exposed". but then no MIR opt may remove a <code>transmute</code> whose result is unused...</p>
</blockquote>
<p>Well, not just a transmute, but /any/ read at integer type of some memory that might possibly have pointers in it.  But I'm definitely not objecting to being able to remove those‚Ä¶</p>



<a name="277350841"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277350841" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277350841">(Mar 31 2022 at 22:54)</a>:</h4>
<p><span class="user-mention" data-user-id="120791">@RalfJ</span> well, if the source type has no pointers, you can still optimize out the unused transmute, no?</p>



<a name="277350847"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277350847" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277350847">(Mar 31 2022 at 22:54)</a>:</h4>
<p>well, no MIR opt may remove an unused <code>transmute</code> <em>when it is pointer vs integer</em></p>



<a name="277350855"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277350855" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277350855">(Mar 31 2022 at 22:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="218745">Wanja Hentze</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277350841">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> well, if the source type has no pointers, you can still optimize out the unused transmute, no?</p>
</blockquote>
<p>only if you know that the source <em>value</em> will also indeed have no provenance</p>



<a name="277350860"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277350860" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277350860">(Mar 31 2022 at 22:54)</a>:</h4>
<p>you can't <code>mem::transmute</code> T and U generically</p>



<a name="277350871"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277350871" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277350871">(Mar 31 2022 at 22:55)</a>:</h4>
<p>which under these fast-and-loose rules I dont think you can conclude from the type</p>



<a name="277350874"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277350874" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277350874">(Mar 31 2022 at 22:55)</a>:</h4>
<p>welll</p>



<a name="277350895"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277350895" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277350895">(Mar 31 2022 at 22:55)</a>:</h4>
<p><code>mem::transmute::&lt;T, U&gt;</code> kinda... does... work?</p>



<a name="277350914"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277350914" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277350914">(Mar 31 2022 at 22:55)</a>:</h4>
<p>like IIRC that's literally how the function is defined?</p>



<a name="277350925"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277350925" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277350925">(Mar 31 2022 at 22:55)</a>:</h4>
<p>I may be missing something here.</p>



<a name="277350930"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277350930" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277350930">(Mar 31 2022 at 22:55)</a>:</h4>
<p>no, it gives you an error saying "T and U aren't known to be the same size"</p>



<a name="277350935"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277350935" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277350935">(Mar 31 2022 at 22:55)</a>:</h4>
<p>under PNVI-ae-alikes, isn't it exactly pointer types who can have provenance?</p>



<a name="277350936"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277350936" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277350936">(Mar 31 2022 at 22:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="143798">Talchas</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277350847">said</a>:</p>
<blockquote>
<p>well, no MIR opt may remove an unused <code>transmute</code> <em>when it is pointer vs integer</em></p>
</blockquote>
<p>it's super hard to say what could still be allowed because there is no precise model. that's the entire point though.^^</p>



<a name="277350938"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277350938" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277350938">(Mar 31 2022 at 22:56)</a>:</h4>
<p>Ahhh.</p>



<a name="277350987"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277350987" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277350987">(Mar 31 2022 at 22:56)</a>:</h4>
<p>all of this applies for transmute_copy/literal memcpy/pointer pun/union pun</p>



<a name="277350998"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277350998" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277350998">(Mar 31 2022 at 22:56)</a>:</h4>
<p>it does not apply for literally just <code>mem::transmute</code></p>



<a name="277351003"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277351003" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277351003">(Mar 31 2022 at 22:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="143798">Talchas</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277350987">said</a>:</p>
<blockquote>
<p>all of this applies for transmute_copy/literal memcpy/pointer pun/union pun</p>
</blockquote>
<p>or maybe <code>mem::transmute</code> is special to support legacy code</p>



<a name="277351006"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277351006" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277351006">(Mar 31 2022 at 22:56)</a>:</h4>
<p>so you're saying the implicit <code>where</code></p>



<a name="277351008"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277351008" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277351008">(Mar 31 2022 at 22:56)</a>:</h4>
<p>At least, as long as LLVM keeps removing those.  I think there may be a possible future where LLVM implements PNVI by removing unused loads/stores but keeping around some kind of marker, and in that case perhaps Rust should follow its lead and use the same aprpoach in MIR optimizations, but that's far off.</p>



<a name="277351027"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277351027" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277351027">(Mar 31 2022 at 22:56)</a>:</h4>
<p>(at least until/unless we get <code>where size_of::&lt;T&gt;() == size_of::&lt;U&gt;()</code> permitting transmute!)</p>



<a name="277351045"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277351045" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277351045">(Mar 31 2022 at 22:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="218745">Wanja Hentze</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277350935">said</a>:</p>
<blockquote>
<p>under PNVI-ae-alikes, isn't it exactly pointer types who can have provenance?</p>
</blockquote>
<p>we're talking about code that does not follow any precise rules we know, so... not sure?</p>



<a name="277351054"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277351054" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277351054">(Mar 31 2022 at 22:57)</a>:</h4>
<p>C has strict aliasing so we can't apply its rules either</p>



<a name="277351139"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277351139" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277351139">(Mar 31 2022 at 22:58)</a>:</h4>
<p>Right, half of our trouble is Rust is <code>-fno-strict-aliasing</code></p>



<a name="277351169"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277351169" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277351169">(Mar 31 2022 at 22:58)</a>:</h4>
<p>I mean C does have the strict aliasing exception for bytes anyway, which still has to work somehow...</p>



<a name="277351175"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277351175" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277351175">(Mar 31 2022 at 22:58)</a>:</h4>
<p>I don't want to overfocus on <code>mem::transmute</code> in particular ‚Äî I mostly used special-casing it as an example of where some targeted inelegant/messy things we could do might go a long way toward bringing us to a better model while avoiding breaking most code.</p>



<a name="277351184"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277351184" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277351184">(Mar 31 2022 at 22:59)</a>:</h4>
<p>the current proposal's section for bytes is "handwave"</p>



<a name="277351209"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277351209" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277351209">(Mar 31 2022 at 22:59)</a>:</h4>
<p>like, if you let it be an expose it's trivial as far as a model goes</p>



<a name="277351220"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277351220" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277351220">(Mar 31 2022 at 22:59)</a>:</h4>
<p>I actually love that rust has no TBAA, C's rules are quite weird</p>



<a name="277351230"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277351230" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277351230">(Mar 31 2022 at 22:59)</a>:</h4>
<p>but they very much want memcpy(pointer, pointer) to not be an expose</p>



<a name="277351240"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277351240" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277351240">(Mar 31 2022 at 22:59)</a>:</h4>
<p>and also would like some way to implement memcpy in C</p>



<a name="277351325"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277351325" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277351325">(Mar 31 2022 at 23:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="218745">Wanja Hentze</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277351220">said</a>:</p>
<blockquote>
<p>I actually love that rust has no TBAA, C's rules are quite weird</p>
</blockquote>
<p>to be fair we do have TBAA it's just not on that kind.</p>



<a name="277351370"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277351370" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277351370">(Mar 31 2022 at 23:00)</a>:</h4>
<p>(JavaScript for example managed to get true lexical scoping by special-casing the identifier <code>eval</code>, which is hilariously ugly, but the only alternative would be no lexical scoping, as Web browsers wouldn't ship anything that broke Web pages, so it ended up being a great solution all around.)</p>



<a name="277351378"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277351378" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277351378">(Mar 31 2022 at 23:00)</a>:</h4>
<p>and doing that without a magic flag on memcpy, or provenance in integers, or provenance in this integer type in particular, is ???</p>



<a name="277351382"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277351382" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277351382">(Mar 31 2022 at 23:00)</a>:</h4>
<p>(Similar story with C <code>strict-aliasing</code> and the <code>char</code> special case.)</p>



<a name="277351388"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277351388" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277351388">(Mar 31 2022 at 23:01)</a>:</h4>
<p>it turns out every other kind of TBAA is easier to understand. <span aria-label="shrug" class="emoji emoji-1f937" role="img" title="shrug">:shrug:</span></p>



<a name="277351441"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277351441" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick12 <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277351441">(Mar 31 2022 at 23:01)</a>:</h4>
<p><span class="user-mention silent" data-user-id="384014">Patrick Walton</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277349872">said</a>:</p>
<blockquote>
<p>I just think there has to be a limit.</p>
</blockquote>
<p>In case you haven't seen it, there's a t-lang topic discussing stability gurantees of unsafe code <a href="#narrow/stream/213817-t-lang/topic/Stability.20guarantees.20of.20.60unsafe.60.20code">https://rust-lang.zulipchat.com/#narrow/stream/213817-t-lang/topic/Stability.20guarantees.20of.20.60unsafe.60.20code</a></p>



<a name="277351644"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277351644" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277351644">(Mar 31 2022 at 23:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="384014">Patrick Walton</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277351382">said</a>:</p>
<blockquote>
<p>(Similar story with C <code>strict-aliasing</code> and the <code>char</code> special case.)</p>
</blockquote>
<p>well, I'd say strict aliasing is actually breaking tons of previously working code. just nobody noticed yet as optimizers didnt get there yet.</p>



<a name="277351672"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277351672" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277351672">(Mar 31 2022 at 23:05)</a>:</h4>
<p>if there was Miri for strict aliasing it'd be red all over the place</p>



<a name="277351678"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277351678" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277351678">(Mar 31 2022 at 23:05)</a>:</h4>
<p>the <code>char</code> special case was meant to fix this but didnt</p>



<a name="277351689"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277351689" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277351689">(Mar 31 2022 at 23:05)</a>:</h4>
<p>there's a reason many big projects just <code>-fno-strict-aliasing</code></p>



<a name="277351699"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277351699" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277351699">(Mar 31 2022 at 23:05)</a>:</h4>
<p>so I wouldnt use strict aliasing as a successful example ;)</p>



<a name="277351850"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277351850" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277351850">(Mar 31 2022 at 23:07)</a>:</h4>
<p>So, scapegoat idea: <code>rustc -fno-strict-provenance</code></p>



<a name="277351939"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277351939" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277351939">(Mar 31 2022 at 23:08)</a>:</h4>
<p>Probably very gnarly to tease out which LLVM opts exactly to disable then</p>



<a name="277352007"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277352007" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick12 <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277352007">(Mar 31 2022 at 23:09)</a>:</h4>
<p>That would be as underspecified as <code>-fno-strict-aliasing</code> right? Just a best-effort extension</p>



<a name="277352019"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277352019" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277352019">(Mar 31 2022 at 23:09)</a>:</h4>
<p>Yes</p>



<a name="277352122"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277352122" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277352122">(Mar 31 2022 at 23:10)</a>:</h4>
<p>But with miri and such you actually have a fighting chance to figure out when exactly you're compliant with the strict model and get to ditch that flag</p>



<a name="277352274"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277352274" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277352274">(Mar 31 2022 at 23:12)</a>:</h4>
<p>with strict aliasing, nobody would dare suggesting turning that loose on e.g. Linux. who knows what would happen</p>



<a name="277352295"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277352295" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277352295">(Mar 31 2022 at 23:12)</a>:</h4>
<p>If you're going to have that flag, why make the user guess whether to pass it - why not track which crates actually require it to ensure it can't be accidentally missed. In which case we're back to my original proposal which started this whole discussion :P</p>



<a name="277352325"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277352325" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277352325">(Mar 31 2022 at 23:13)</a>:</h4>
<p>also we dont want to have flags that split the language</p>



<a name="277352477"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277352477" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277352477">(Mar 31 2022 at 23:15)</a>:</h4>
<p>Nobody wants that, but also nobody wants UB nor perf regresions. To me it is a question of the lesser evil</p>



<a name="277352524"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277352524" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277352524">(Mar 31 2022 at 23:16)</a>:</h4>
<p>(to which I have no answer)</p>



<a name="277352625"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277352625" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277352625">(Mar 31 2022 at 23:17)</a>:</h4>
<p>We have editions that already kind of split the language, so it's not like it's a complete non-starter</p>



<a name="277352686"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277352686" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277352686">(Mar 31 2022 at 23:18)</a>:</h4>
<p>yeah, I think splitting is... acceptable as long as there is a strict subset/superset relationship</p>



<a name="277352706"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277352706" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277352706">(Mar 31 2022 at 23:18)</a>:</h4>
<p>You can't always get what you want<br>
<a href="https://www.youtube.com/watch?v=Ef9QnZVpVd8">https://www.youtube.com/watch?v=Ef9QnZVpVd8</a></p>
<div class="youtube-video message_inline_image"><a data-id="Ef9QnZVpVd8" href="https://www.youtube.com/watch?v=Ef9QnZVpVd8"><img src="https://uploads.zulipusercontent.net/8acfd845a89c1819414ed41aef86a46afdc77a19/68747470733a2f2f692e7974696d672e636f6d2f76692f456639516e5a56705664382f64656661756c742e6a7067"></a></div>



<a name="277352726"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277352726" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277352726">(Mar 31 2022 at 23:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="295632">Diggsey</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277352686">said</a>:</p>
<blockquote>
<p>yeah, I think splitting is... acceptable as long as there is a strict subset/superset relationship</p>
</blockquote>
<p>I fairly strongly disagree, because then we will end up in the world where there are libraries that document "requires <code>-fno-strict-provenance</code>"</p>



<a name="277352749"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277352749" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277352749">(Mar 31 2022 at 23:19)</a>:</h4>
<p>we already have that in effect though</p>



<a name="277352763"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277352763" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277352763">(Mar 31 2022 at 23:20)</a>:</h4>
<p>as in, there's already code that requires this that we don't want to break</p>



<a name="277352814"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277352814" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277352814">(Mar 31 2022 at 23:20)</a>:</h4>
<p>it could be an actual crate option rather than just docs</p>



<a name="277352815"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277352815" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277352815">(Mar 31 2022 at 23:20)</a>:</h4>
<p>Yes, but that's not the same thing</p>



<a name="277352823"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277352823" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277352823">(Mar 31 2022 at 23:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="218745">Wanja Hentze</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277352814">said</a>:</p>
<blockquote>
<p>it could be an actual crate option rather than just docs</p>
</blockquote>
<p>That's worse imo, not better</p>



<a name="277352839"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277352839" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277352839">(Mar 31 2022 at 23:20)</a>:</h4>
<p>well, it would fit in with editions</p>



<a name="277352850"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277352850" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277352850">(Mar 31 2022 at 23:21)</a>:</h4>
<p>Like "let's keep this already written code from miscompiling as long as it's not too crazy" is a far ways off from actually trying to <em>support</em> the broken thing</p>



<a name="277352865"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277352865" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277352865">(Mar 31 2022 at 23:21)</a>:</h4>
<p>and you could write a tool that crawls your dependency graph to show you who's naughty so you can haunt their issue trackers</p>



<a name="277352882"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277352882" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277352882">(Mar 31 2022 at 23:21)</a>:</h4>
<p>what is the difference? If someone says it broke a load of their code, and we don't want to do that, then we are supporting it</p>



<a name="277352926"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277352926" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277352926">(Mar 31 2022 at 23:22)</a>:</h4>
<p>No one should ever be putting <code>no-strict-provenance</code> into their cargo.toml - if they are doing maintenance on their repo, they should fix the code, not mark it permanently broken</p>



<a name="277352946"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277352946" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277352946">(Mar 31 2022 at 23:22)</a>:</h4>
<p>yes, these kinds of things must always work the other way around, the default is the broken thing</p>



<a name="277352968"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277352968" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277352968">(Mar 31 2022 at 23:23)</a>:</h4>
<p>Well to refer to my original proposal, we'd have the older edition be the opt-in for effectively <code>no-strict-provenance</code></p>



<a name="277352972"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277352972" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277352972">(Mar 31 2022 at 23:23)</a>:</h4>
<p>in the extreme, you end up like Perl, where the base language is throughly broken but after 20 or so lines of boilerplate you can get sane semantics</p>



<a name="277352976"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277352976" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277352976">(Mar 31 2022 at 23:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="218745">Wanja Hentze</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277351850">said</a>:</p>
<blockquote>
<p>So, scapegoat idea: <code>rustc -fno-strict-provenance</code></p>
</blockquote>
<p>Consensus seems to be that we can just introduce <code>ptr.addr_strict()</code> ‚Äî you can't use the result to convert back into a pointer. And then there's no reason to add a compiler flag. Much simpler.</p>



<a name="277353032"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277353032" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277353032">(Mar 31 2022 at 23:24)</a>:</h4>
<p><span class="user-mention" data-user-id="295632">@Diggsey</span> right, piggybacking on the edition mechanism doesn't seem so bad at face value</p>



<a name="277353058"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277353058" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277353058">(Mar 31 2022 at 23:24)</a>:</h4>
<p>Perhaps this doesn't address every use case but then let's talk about it. Let's only propose a compiler flag please if it fixes something that <code>.addr_strict()</code> doesn't fix</p>



<a name="277353072"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277353072" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277353072">(Mar 31 2022 at 23:24)</a>:</h4>
<p><span class="user-mention" data-user-id="465167">@Bram Geron</span> That's not consensus, I think it satisfies neither the desire to avoid breaking existing code, nor does it actually allow us to do anything with strict provenance</p>



<a name="277353118"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277353118" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277353118">(Mar 31 2022 at 23:25)</a>:</h4>
<p>It's not about defaults, it's about having the option at all. People may need to be able to "opt in" to the broken thing, but the procedure for this should be <em>precisely nothing</em>. Having old unsafe code that does stuff like <code>as</code> casts gets you special treatment in the form of "I'll do my best to not miscompile"</p>



<a name="277353151"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277353151" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277353151">(Mar 31 2022 at 23:25)</a>:</h4>
<p>also, telling people "if your entire dep graph is on edition 2024+, you'll get crazy provenance opts" is a nicer story to tell than "we're breaking your stuff, fix it or suffer"</p>



<a name="277353168"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277353168" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277353168">(Mar 31 2022 at 23:25)</a>:</h4>
<p>I'm proposing to keep <code>ptr as usize</code> and <code>usize as ptr</code> intact, so yes it doesn't break existing code</p>



<a name="277353232"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277353232" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277353232">(Mar 31 2022 at 23:26)</a>:</h4>
<p>To be clear, what I very much would like to avoid is to give people writing <em>new</em> code the impression that they have an option to go "I'll just write against the old broken thing and flip the compiler flag"</p>



<a name="277353242"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277353242" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277353242">(Mar 31 2022 at 23:26)</a>:</h4>
<p>How is the old thing broken please?</p>



<a name="277353282"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277353282" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277353282">(Mar 31 2022 at 23:26)</a>:</h4>
<p>because we say so</p>



<a name="277353289"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277353289" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277353289">(Mar 31 2022 at 23:26)</a>:</h4>
<p>not helpful</p>



<a name="277353330"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277353330" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277353330">(Mar 31 2022 at 23:27)</a>:</h4>
<p>sorry that was a bit too laconic.</p>



<a name="277353335"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277353335" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277353335">(Mar 31 2022 at 23:27)</a>:</h4>
<p>We have no memory model against which to determine that something is sound, that is the definition of broken</p>



<a name="277353338"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277353338" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277353338">(Mar 31 2022 at 23:27)</a>:</h4>
<p>It's okay</p>



<a name="277353401"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277353401" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277353401">(Mar 31 2022 at 23:28)</a>:</h4>
<p><span class="user-mention" data-user-id="310518">@Jak{e,ob} Degen</span> yes, that's not license to introduce arbitrary amounts of UB into unsafe code</p>



<a name="277353417"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277353417" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277353417">(Mar 31 2022 at 23:28)</a>:</h4>
<p>I never suggested that</p>



<a name="277353447"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277353447" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277353447">(Mar 31 2022 at 23:28)</a>:</h4>
<p>if being underspecified is enough to be broken, all unsafe code is broken</p>



<a name="277353470"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277353470" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277353470">(Mar 31 2022 at 23:29)</a>:</h4>
<p>there's more to it than that</p>



<a name="277353472"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277353472" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277353472">(Mar 31 2022 at 23:29)</a>:</h4>
<p>Above, I propose the thing that miri is doing with Stacked Borrows. This is more permissive than strict-provenance. But strict-provenance seems to fit in well w.r.t. compiler optimizations.</p>
<p>In <a class="stream-topic" data-stream-id="136281" href="/#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/SB.20Without.20Raw.20Pointer.20Tagging">#t-lang/wg-unsafe-code-guidelines &gt; SB Without Raw Pointer Tagging</a> , we've been talking about which specific variant of Stacked Borrows this should be.</p>



<a name="277353504"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277353504" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277353504">(Mar 31 2022 at 23:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="218745">Wanja Hentze</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277353470">said</a>:</p>
<blockquote>
<p>there's more to it than that</p>
</blockquote>
<p>I never claimed that there wasn't, but I do stand by the claim that the lack of a sound memory model is indeed fundamentally broken and needs to be fixed</p>



<a name="277353509"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277353509" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277353509">(Mar 31 2022 at 23:29)</a>:</h4>
<p>As far as I understand, this has a good shot at formalizing how raw pointers work, in a way that fits into Rust (because pnvi-* doesn't fit)</p>



<a name="277353517"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277353517" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277353517">(Mar 31 2022 at 23:29)</a>:</h4>
<p>yes, it does</p>



<a name="277353518"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277353518" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277353518">(Mar 31 2022 at 23:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="218745">Wanja Hentze</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277353401">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="310518">Jak{e,ob} Degen</span> yes, that's not license to introduce arbitrary amounts of UB into unsafe code</p>
</blockquote>
<p>The UB basically already exists, we're just stating it.</p>



<a name="277353527"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277353527" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277353527">(Mar 31 2022 at 23:30)</a>:</h4>
<p><span class="user-mention" data-user-id="465167">@Bram Geron</span> SB already breaks plenty of existing code - don't get me wrong, it's amazing how much it does work on, but it's not a panacea</p>



<a name="277353594"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277353594" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277353594">(Mar 31 2022 at 23:30)</a>:</h4>
<p><span class="user-mention" data-user-id="257758">@Connor Horman</span> what code exactly already has UB is exactly the point of discussion</p>



<a name="277353646"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277353646" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277353646">(Mar 31 2022 at 23:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="218745">Wanja Hentze</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277353517">said</a>:</p>
<blockquote>
<p>yes, it does</p>
</blockquote>
<p>It doesn't. PNVI-ae actually has problems in rust.</p>



<a name="277353675"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277353675" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277353675">(Mar 31 2022 at 23:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277353646">said</a>:</p>
<blockquote>
<p>It doesn't. PNVI-ae actually has problems in rust.</p>
</blockquote>
<p>We mean Stacked Borrows</p>



<a name="277353683"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277353683" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277353683">(Mar 31 2022 at 23:31)</a>:</h4>
<p>I would like this topic to be about how we integrate strict-provenance with non-strict-provenance Rust.</p>
<p>If we want to discuss formal semantics of non-strict-provenance Rust, let's create a new topic for that.</p>



<a name="277353749"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277353749" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277353749">(Mar 31 2022 at 23:32)</a>:</h4>
<p>If we want to switch to something other than Stacked Borrows, I mean</p>



<a name="277353769"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277353769" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277353769">(Mar 31 2022 at 23:32)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277353646">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="218745">Wanja Hentze</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277353517">said</a>:</p>
<blockquote>
<p>yes, it does</p>
</blockquote>
<p>It doesn't. PNVI-ae actually has problems in rust.</p>
</blockquote>
<p>sorry I'm bad at zulip, that was in response to "the lack of a model needs to be fixed"</p>



<a name="277353776"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277353776" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick12 <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277353776">(Mar 31 2022 at 23:32)</a>:</h4>
<p><span class="user-mention silent" data-user-id="218745">Wanja Hentze</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277353470">said</a>:</p>
<blockquote>
<p>there's more to it than that</p>
</blockquote>
<p>Is "No one knows a coherent model in which all the things some people want to be sound are actually sound that does not introduce regressions by making optimizations done today invalid" an accurate description?</p>



<a name="277353786"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277353786" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277353786">(Mar 31 2022 at 23:33)</a>:</h4>
<p><span class="user-mention" data-user-id="465167">@Bram Geron</span>  To be clear: every known formal model short of "no provenance" breaks some amount of existing code, because existing code was written without a formal model. The only way to guarantee no breakage would be to basically freeze all current optimization passes as they are for eternity.</p>



<a name="277353873"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277353873" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277353873">(Mar 31 2022 at 23:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="219940">Nick12</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277353776">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="218745">Wanja Hentze</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277353470">said</a>:</p>
<blockquote>
<p>there's more to it than that</p>
</blockquote>
<p>Is "No one knows a coherent model in which the things some people want to be sound are actually sound that does not introduce regressions by making optimizations done today invalid" an accurate description?</p>
</blockquote>
<p>yeah, but I'd add the additional concern that other people want to build tools that verify the rules dynamically and that also clashes with the others</p>



<a name="277353890"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277353890" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277353890">(Mar 31 2022 at 23:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277353683">said</a>:</p>
<blockquote>
<p>I would like this topic to be about how we integrate strict-provenance with non-strict-provenance Rust.</p>
<p>If we want to discuss formal semantics of non-strict-provenance Rust, let's create a new topic for that.</p>
</blockquote>
<p>Integrating strict-provenance with non-strict-provenance is the same as not having strict-provenance.</p>



<a name="277353928"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277353928" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277353928">(Mar 31 2022 at 23:35)</a>:</h4>
<blockquote>
<p>Integrating strict-provenance with non-strict-provenance is the same as not having strict-provenance.</p>
</blockquote>
<p>Within a compiled program yes you can only have one. You could in principle have both in the language.</p>



<a name="277353943"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277353943" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277353943">(Mar 31 2022 at 23:35)</a>:</h4>
<p>but you would have to choose when compiling</p>



<a name="277354014"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277354014" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277354014">(Mar 31 2022 at 23:36)</a>:</h4>
<p>And you could choose differently between crates.</p>



<a name="277354021"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277354021" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277354021">(Mar 31 2022 at 23:36)</a>:</h4>
<p>uh.. not so sure about that</p>



<a name="277354024"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277354024" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277354024">(Mar 31 2022 at 23:36)</a>:</h4>
<p>Which becomes a problem.</p>



<a name="277354026"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277354026" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick12 <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277354026">(Mar 31 2022 at 23:36)</a>:</h4>
<p>You could forbid that</p>



<a name="277354035"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277354035" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277354035">(Mar 31 2022 at 23:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="295632">Diggsey</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277354021">said</a>:</p>
<blockquote>
<p>uh.. not so sure about that</p>
</blockquote>
<p>Sure, just compile one crate with the flag off, and one crate with it on.</p>



<a name="277354054"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277354054" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277354054">(Mar 31 2022 at 23:37)</a>:</h4>
<p>sorry I thought you were saying it <em>could</em> be different between crates - as in that would be allowed, I'm agreeing that may not be possible</p>



<a name="277354059"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277354059" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277354059">(Mar 31 2022 at 23:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277353890">said</a>:</p>
<blockquote>
<p>Integrating strict-provenance with non-strict-provenance is the same as not having strict-provenance.</p>
</blockquote>
<p>Then ~every actual non-CHERI compilation target does not have strict-provenance, because of FFI.</p>



<a name="277354122"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277354122" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277354122">(Mar 31 2022 at 23:38)</a>:</h4>
<p>you can already shoot your whole leg off in a myriad ways if you start messing with compiler flags for individual crates</p>



<a name="277354146"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277354146" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277354146">(Mar 31 2022 at 23:38)</a>:</h4>
<p>(if you then link them together that is)</p>



<a name="277354192"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277354192" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277354192">(Mar 31 2022 at 23:39)</a>:</h4>
<blockquote>
<p>Then ~every actual non-CHERI compilation target does not have strict-provenance, because of FFI.</p>
</blockquote>
<p>I don't think that follows. As long as the FFI <em>interface</em> is compatible with strict-provenance then it can work fine. Obviously if the FFI code materializes an address to your local variable, then it will be UB</p>



<a name="277354251"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277354251" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277354251">(Mar 31 2022 at 23:40)</a>:</h4>
<p>FFI can do whatever it wanns.</p>



<a name="277354261"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277354261" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277354261">(Mar 31 2022 at 23:40)</a>:</h4>
<p>FFI interfaces with things outside the Abstract Machine, that says nothing about what happens inside the Abstract Machine</p>



<a name="277354275"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277354275" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277354275">(Mar 31 2022 at 23:40)</a>:</h4>
<p>If it's doing stupid stuff, then I can observe that that stupid stuff isn't possible and ignore that case.</p>



<a name="277354303"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277354303" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277354303">(Mar 31 2022 at 23:41)</a>:</h4>
<p>The issue is that, functionally, it's impossible to treat code in a different rust crate that is linked as an rlib/dylib as being a total blackbox.</p>



<a name="277354305"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277354305" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277354305">(Mar 31 2022 at 23:41)</a>:</h4>
<p>provenance isn't the only "weird stuff" that the Abstract Machine has that the underlying hardware does not; uninit memory is another example. no problem with FFI there either.<br>
see <a href="https://www.ralfj.de/blog/2019/07/14/uninit.html">https://www.ralfj.de/blog/2019/07/14/uninit.html</a> for details.</p>



<a name="277354317"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277354317" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277354317">(Mar 31 2022 at 23:41)</a>:</h4>
<p>I mean, some hardware has uninit.</p>



<a name="277354327"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277354327" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277354327">(Mar 31 2022 at 23:41)</a>:</h4>
<p>you must place limits on what FFI can soundly do, otherwise there are no rules at all (every program does FFI)</p>



<a name="277354389"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277354389" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277354389">(Mar 31 2022 at 23:42)</a>:</h4>
<p>(For example, when you mode-switch upwards in x86, the high bits of each register are uninit in the same sense llvm uses)</p>



<a name="277354426"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277354426" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277354426">(Mar 31 2022 at 23:43)</a>:</h4>
<p>individual counterexamples dont affect my point at all, it remains true in general</p>



<a name="277354432"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277354432" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277354432">(Mar 31 2022 at 23:43)</a>:</h4>
<p>so they dont really help the discussion :D</p>



<a name="277354500"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277354500" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277354500">(Mar 31 2022 at 23:44)</a>:</h4>
<p>does passing memory to FFI "freeze" it? I'd think not.</p>



<a name="277354515"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277354515" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277354515">(Mar 31 2022 at 23:44)</a>:</h4>
<p>right, "hardware UB" or at least "hardware poison" and "hardware undef" are real.</p>



<a name="277354541"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277354541" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277354541">(Mar 31 2022 at 23:45)</a>:</h4>
<p>Hardware UB is also real in some cases.</p>



<a name="277354562"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277354562" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277354562">(Mar 31 2022 at 23:45)</a>:</h4>
<p>I'm happy with saying "this happens outside of the AM so we don't care" w.r.t. FFI but you still need to decide where that actually starts</p>



<a name="277354639"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277354639" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277354639">(Mar 31 2022 at 23:46)</a>:</h4>
<p>I think that the idea of an FFI call has been discussed before, but I would just call it an unspecified operation on the abstract machine, or the behaviour is undefined.</p>



<a name="277354668"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277354668" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277354668">(Mar 31 2022 at 23:47)</a>:</h4>
<p>If the behavior is undefined, there exists almost no rust program with defined behavior</p>



<a name="277354761"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277354761" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277354761">(Mar 31 2022 at 23:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="218745">Wanja Hentze</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277354668">said</a>:</p>
<blockquote>
<p>If the behavior is undefined, there exists almost no rust program with defined behavior</p>
</blockquote>
<p>I can LD_PRELOAD a library that replaces every libc function with <code>_Noreturn void foo(void){}</code></p>



<a name="277354772"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277354772" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277354772">(Mar 31 2022 at 23:49)</a>:</h4>
<p>and all the handwaving doesn't help you if you start miscompiling code that passes pointers into and out of FFI</p>



<a name="277354787"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277354787" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277354787">(Mar 31 2022 at 23:49)</a>:</h4>
<p>My headcanon is that an FFI call <em>synchronizes</em>, to a certain extent, the abstract machine with the concrete machine.</p>



<a name="277354800"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277354800" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277354800">(Mar 31 2022 at 23:49)</a>:</h4>
<p>Well, as concrete as a process's state is.  Somewhat concrete.</p>



<a name="277354881"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277354881" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277354881">(Mar 31 2022 at 23:50)</a>:</h4>
<p>Define "synchronizes"?</p>



<a name="277354884"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277354884" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277354884">(Mar 31 2022 at 23:50)</a>:</h4>
<p>That sounds like a gigantic optimization barrier</p>



<a name="277354889"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277354889" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277354889">(Mar 31 2022 at 23:50)</a>:</h4>
<p>Well, that's the hard part. ;)</p>



<a name="277354891"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277354891" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277354891">(Mar 31 2022 at 23:50)</a>:</h4>
<p>And yeah.</p>



<a name="277354897"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277354897" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277354897">(Mar 31 2022 at 23:51)</a>:</h4>
<p>It basically says "LTO doesn't exist".</p>



<a name="277354906"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277354906" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277354906">(Mar 31 2022 at 23:51)</a>:</h4>
<p>Well, I would say LTO is an exception.</p>



<a name="277354919"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277354919" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277354919">(Mar 31 2022 at 23:51)</a>:</h4>
<p>Which is, uh, definately not true.</p>



<a name="277354933"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277354933" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277354933">(Mar 31 2022 at 23:51)</a>:</h4>
<p>And I hope it <em>remains</em> not true, because all of lccc's runtime libraries will be compiled with mixed LTO.</p>



<a name="277354940"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277354940" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277354940">(Mar 31 2022 at 23:52)</a>:</h4>
<p>But, for example, if you write a value to some address in the abstract machine, that address may not correspond to any actual concrete-machine address, or it may correspond to multiple different concrete-machine addresses, etc.</p>



<a name="277354990"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277354990" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277354990">(Mar 31 2022 at 23:52)</a>:</h4>
<p>Cross-lang LTO can happen if a language exists that rationalizes the interactions.</p>



<a name="277355002"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277355002" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277355002">(Mar 31 2022 at 23:52)</a>:</h4>
<p>In effect, this is what LLVM, GIMPLE, etc. <strong>are</strong></p>



<a name="277355013"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277355013" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277355013">(Mar 31 2022 at 23:53)</a>:</h4>
<p>However, once you enter an FFI call ‚Äì I'm excluding LTO in this ‚Äì you have to have a concrete address and concrete bytes written there.</p>



<a name="277355019"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277355019" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277355019">(Mar 31 2022 at 23:53)</a>:</h4>
<p>Indeed, same with XIR.</p>



<a name="277355042"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277355042" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277355042">(Mar 31 2022 at 23:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="198590">comex</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277355013">said</a>:</p>
<blockquote>
<p>However, once you enter an FFI call ‚Äì I'm excluding LTO in this ‚Äì you have to have a concrete address and concrete bytes written there.</p>
</blockquote>
<p>That still seems like a a huge optimization barrier.</p>



<a name="277355046"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277355046" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277355046">(Mar 31 2022 at 23:54)</a>:</h4>
<p>LTO is functionality of the backend, ie. LLVM - AIUI you can't do LTO between two things that use a different compiler backend. Therefore the only difference from non-LTO FFI is that you are synchronizing the Rust abstract machine to the LLVM abstract machine, instead of to the concrete machine</p>



<a name="277355087"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277355087" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277355087">(Mar 31 2022 at 23:54)</a>:</h4>
<p>The job of Rust should be to "get our own house in order" as much as possible such that cross-lang LTO has an easy time of rationalizing the interactions and that it is not order-dependent.</p>



<a name="277355092"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277355092" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277355092">(Mar 31 2022 at 23:54)</a>:</h4>
<p>BTW, this is much more obviously true in weird implementations like concolic execution</p>



<a name="277355103"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277355103" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277355103">(Mar 31 2022 at 23:54)</a>:</h4>
<p>I mean, this is rather my point - C is pretty much absolutely definitely not going to be using strict provenance</p>



<a name="277355121"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277355121" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277355121">(Mar 31 2022 at 23:54)</a>:</h4>
<p>You really need to physically cough up actual bytes before each FFI call</p>



<a name="277355133"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277355133" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277355133">(Mar 31 2022 at 23:55)</a>:</h4>
<p><span class="user-mention" data-user-id="257758">@Connor Horman</span> Sorry, I should also say - it only needs to be in concrete memory to the extent it's been exposed to the FFI call, directly or indirectly.  This is, of course, what compilers already do.</p>



<a name="277355150"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277355150" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277355150">(Mar 31 2022 at 23:55)</a>:</h4>
<p>so if you can FFI call to C which does things like <code>uintptr_t ptr2int(void *x) { return (uintptr_t)x; }</code> you could interface two different rust crates with different rules in the same way</p>



<a name="277355165"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277355165" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277355165">(Mar 31 2022 at 23:55)</a>:</h4>
<p>whatever that actually looks like in the backend</p>



<a name="277355216"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277355216" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277355216">(Mar 31 2022 at 23:56)</a>:</h4>
<p>(which yes, means no LTO between those crate sets unless you have a cross-lang LTO that can handle that somehow)</p>



<a name="277355263"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277355263" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277355263">(Mar 31 2022 at 23:57)</a>:</h4>
<p>Having "synchronized only if exposed" as a normative rule, as opposed to the normal case where the notion of escaping is purely a compiler concept and has no place to the spec, may sound unmotivated.</p>



<a name="277355273"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277355273" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277355273">(Mar 31 2022 at 23:57)</a>:</h4>
<p>the C FFI is much simpler than the interface a Rust crate can expose, and compiler backends generally have knowledge of the C interface, whereas they wouldn't have particular knowledge about all the things you can do in Rust</p>



<a name="277355279"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277355279" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277355279">(Mar 31 2022 at 23:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="198590">comex</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277355133">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> Sorry, I should also say - it only needs to be in concrete memory to the extent it's been exposed to the FFI call, directly or indirectly.  This is, of course, what compilers already do.</p>
</blockquote>
<p>Yes, and to do this, they need rules about what exactly a foreign function could possibly see/touch</p>



<a name="277355284"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277355284" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277355284">(Mar 31 2022 at 23:57)</a>:</h4>
<p>so you can still have both <code>strict-provenance=yes</code> and <code>no</code> crates in the same executable to the exact same extent you could have <code>strict-provenance=yes</code> and C in the same executable</p>



<a name="277355299"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277355299" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277355299">(Mar 31 2022 at 23:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="143798">Talchas</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277355284">said</a>:</p>
<blockquote>
<p>so you can still have both <code>strict-provenance=yes</code> and <code>no</code> crates in the same executable to the exact same extent you could have <code>strict-provenance=yes</code> and C in the same executable</p>
</blockquote>
<p>The issue is what happens if you inline strict-provenance=no into strict-provenacne=yes.</p>



<a name="277355356"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277355356" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277355356">(Mar 31 2022 at 23:58)</a>:</h4>
<p>yes, that is what you cannot do without cross-lang LTO equivalents</p>



<a name="277355367"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277355367" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277355367">(Mar 31 2022 at 23:58)</a>:</h4>
<p>Ok, so you can't instantiate any generics either.</p>



<a name="277355376"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277355376" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277355376">(Mar 31 2022 at 23:58)</a>:</h4>
<p>you can compile them with separate settings</p>



<a name="277355380"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277355380" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277355380">(Mar 31 2022 at 23:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277355299">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="143798">Talchas</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277355284">said</a>:</p>
<blockquote>
<p>so you can still have both <code>strict-provenance=yes</code> and <code>no</code> crates in the same executable to the exact same extent you could have <code>strict-provenance=yes</code> and C in the same executable</p>
</blockquote>
<p>The issue is what happens if you inline strict-provenance=no into strict-provenacne=yes.</p>
</blockquote>
<p>Doesn't it suffice to pass pointers between the two?</p>



<a name="277355381"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277355381" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277355381">(Mar 31 2022 at 23:58)</a>:</h4>
<p>Or call an <code>#[inline]</code> function.</p>



<a name="277355396"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277355396" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277355396">(Mar 31 2022 at 23:59)</a>:</h4>
<p><span class="user-mention" data-user-id="143798">@Talchas</span> that definitely seems possible if the two crates only communicate via C API, but I feel like native Rust interop makes that more complicated</p>



<a name="277355405"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277355405" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277355405">(Mar 31 2022 at 23:59)</a>:</h4>
<p>Also, compiling them separately has <em>fun</em> times.</p>



<a name="277355406"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277355406" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277355406">(Mar 31 2022 at 23:59)</a>:</h4>
<p>right.</p>



<a name="277355407"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277355407" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277355407">(Mar 31 2022 at 23:59)</a>:</h4>
<p>...But I think it's important to allow FFI to perform the full range of operations that people expect it to support.  For example, the FFI call might actually pause the process, at which point you might, say, inspect values in a debugger (this should be guaranteed to work for stuff that has been exposed to FFI), or send it to another machine with checkpoint-restore, etc‚Ä¶</p>



<a name="277355433"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277355433" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277355433">(Mar 31 2022 at 23:59)</a>:</h4>
<p>I think that Connor has the right of things, "that's actually way more """fun""" than you imagine."</p>



<a name="277355439"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277355439" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277355439">(Mar 31 2022 at 23:59)</a>:</h4>
<p>The alternative is to either not model FFI at all (unsatisfying), or model FFI by trying to translate the FFI code itself into the abstract machine, which causes a lot of problems.</p>



<a name="277355443"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277355443" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277355443">(Apr 01 2022 at 00:00)</a>:</h4>
<p>like, you need to be able to somehow compile separate functions with separate optimization settings, which is maybe a little bit of effort to do /fast/, but is not any real effort to do in general</p>



<a name="277355624"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277355624" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277355624">(Apr 01 2022 at 00:01)</a>:</h4>
<p><span class="user-mention" data-user-id="198590">@comex</span> but unless you have <em>some</em> model of what forein code can do to memory (e.g. it can't guess your locals' addresses), you lose all your fancy provenance optimizations</p>



<a name="277355638"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277355638" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277355638">(Apr 01 2022 at 00:01)</a>:</h4>
<p>inline(always) already does not actually mean really truly always, so even that's fine</p>



<a name="277355642"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277355642" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277355642">(Apr 01 2022 at 00:01)</a>:</h4>
<p>In lccc, it's guaranteed that an <code>#[inline]</code> function is instantiated in every crate that contains an instantiated call to it, then all instantiations are merged into a single copy per final link target ({c,}dylib/exec).</p>



<a name="277355742"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277355742" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277355742">(Apr 01 2022 at 00:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="143798">Talchas</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277355443">said</a>:</p>
<blockquote>
<p>like, you need to be able to somehow compile separate functions with separate optimization settings, which is maybe a little bit of effort to do /fast/, but is not any real effort to do in general</p>
</blockquote>
<p>Sure, unless you have a limited-by-design compilation pipeline.</p>



<a name="277355911"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277355911" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277355911">(Apr 01 2022 at 00:05)</a>:</h4>
<p><span class="user-mention" data-user-id="218745">@Wanja Hentze</span> Agreed.  Though, I think it's important to clarify what it means that it can't guess your locals' addresses.  Rust 'owns' some subset of concrete machine memory, like its stack frames and whatever heap memory it allocates.  Except for whatever subset of that it properly exposes to FFI, that memory is not guaranteed to contain anything sensible, and you get UB if you modify it and pass execution back to Rust.</p>



<a name="277355912"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277355912" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277355912">(Apr 01 2022 at 00:05)</a>:</h4>
<p>like the simple model is that every rust crate compilation separates all visible (ie current crate / generics / #[inline]) code into "strict" and "nostrict" compilations each with the functions from the other one only provided as <code>extern fn</code>s</p>



<a name="277355966"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277355966" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277355966">(Apr 01 2022 at 00:06)</a>:</h4>
<p>this does mean that inline(always) will be more like inline(never) if it's called from something with the wrong provenance setting</p>



<a name="277356019"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277356019" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277356019">(Apr 01 2022 at 00:07)</a>:</h4>
<p>But it's important to not just say things like "it's UB even to read it", which can fly in the abstract machine but not the concrete one.  Since it's a valid use case to dump all the memory in the process, e.g. to checkpoint the process or do a core dump.</p>



<a name="277356022"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277356022" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277356022">(Apr 01 2022 at 00:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="198590">comex</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277355911">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="218745">Wanja Hentze</span> Agreed.  Though, I think it's important to clarify what it means that it can't guess your locals' addresses.  Rust 'owns' some subset of concrete machine memory, like its stack frames and whatever heap memory it allocates.  Except for whatever subset of that it properly exposes to FFI, that memory is not guaranteed to contain anything sensible, and you get UB if you modify it and pass execution back to Rust.</p>
</blockquote>
<p>formalizing what "you can't guess pointers" means is exactly what provenance is meant to do <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span> it feels natural to apply it here too</p>



<a name="277356130"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277356130" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277356130">(Apr 01 2022 at 00:08)</a>:</h4>
<p>IoW, if you assume foreign code plays by some rules but not by strict provenance rules, what optimizations do you still get to keep?</p>



<a name="277356284"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277356284" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277356284">(Apr 01 2022 at 00:10)</a>:</h4>
<p>In theory, all of them.  Provenance can affect whether or not some memory is considered exposed to FFI.  It's just that if it is exposed, FFI is allowed to work at the lower level where pointers are integers.  Because that's really a matter of what the FFI code does internally, and none of Rust's business.</p>



<a name="277356311"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277356311" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277356311">(Apr 01 2022 at 00:11)</a>:</h4>
<p>Like, in theory, the only optimizations that should be excluded are hypothetical ones involving actually inspecting the FFI machine code and checking what it does.</p>



<a name="277356319"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277356319" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277356319">(Apr 01 2022 at 00:11)</a>:</h4>
<p>that supposes Rust can consider addresses "exposed" but strict provenance wants to do away with that</p>



<a name="277356423"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277356423" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277356423">(Apr 01 2022 at 00:14)</a>:</h4>
<p>if all of FFI is one big black box, Rust code can hand arbitrary pointers to it and receive them back at any time. that looks and acts exactly like a ptr2intr2ptr round trip</p>



<a name="277356482"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277356482" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277356482">(Apr 01 2022 at 00:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="143798">Talchas</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277355966">said</a>:</p>
<blockquote>
<p>this does mean that inline(always) will be more like inline(never) if it's called from something with the wrong provenance setting</p>
</blockquote>
<p>You can't make an FFI call to an <code>#[inline]</code> function.</p>



<a name="277356501"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277356501" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277356501">(Apr 01 2022 at 00:15)</a>:</h4>
<p>yes you can, you generate the code for the inline function, compile it on the other side of the strict/no-strict barrier, and then FFI call that</p>



<a name="277356504"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277356504" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ben Kimock (Saethlin) <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277356504">(Apr 01 2022 at 00:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="218745">Wanja Hentze</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277352274">said</a>:</p>
<blockquote>
<p>with strict aliasing, nobody would dare suggesting turning that loose on e.g. Linux. who knows what would happen</p>
</blockquote>
<p>It looks like the TySan work has been active recently, so I wouldn't be too sure.</p>



<a name="277356507"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277356507" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277356507">(Apr 01 2022 at 00:15)</a>:</h4>
<p>there is no guarantee ever that it is actually inlined</p>



<a name="277356525"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277356525" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277356525">(Apr 01 2022 at 00:15)</a>:</h4>
<p>No, but the machine code is generated <em>in</em> the translation unit itself.</p>



<a name="277356577"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277356577" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277356577">(Apr 01 2022 at 00:16)</a>:</h4>
<p><span class="user-mention" data-user-id="120827">@Ben Kimock (Saethlin)</span> TIL about TySan</p>



<a name="277356581"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277356581" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277356581">(Apr 01 2022 at 00:16)</a>:</h4>
<p>Same with Generic Functions, Generic Impls, VTables for Generic Impls, destructors (when generic or no <code>Drop</code> impl), etc.</p>



<a name="277356590"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277356590" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277356590">(Apr 01 2022 at 00:16)</a>:</h4>
<p>Why? It certainly doesn't /need/ to be</p>



<a name="277356615"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277356615" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277356615">(Apr 01 2022 at 00:17)</a>:</h4>
<p>like rust in particular makes no guarantees or talk about translation unit at all</p>



<a name="277356622"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277356622" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277356622">(Apr 01 2022 at 00:17)</a>:</h4>
<p>Well, partly because that's how I've chosen to specify it, partly because it's easy, partly because it works when you can only generate one ir output?</p>



<a name="277356624"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277356624" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277356624">(Apr 01 2022 at 00:17)</a>:</h4>
<p>For what it's worth, we basically LTO everything between Rust and C++ today on enormous binaries and I maintain a backport of Rust to LLVM 9 to enable us to do so. So we're pretty reliant on things that work today in cross-language LTO continuing to work. (I'm not implying that anything under discussion right now is going to break us, just putting that out there)</p>



<a name="277356679"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277356679" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277356679">(Apr 01 2022 at 00:18)</a>:</h4>
<p>heck, clang and gcc have the whole per-function optimization settings thing even</p>



<a name="277356693"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277356693" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277356693">(Apr 01 2022 at 00:18)</a>:</h4>
<p><span class="user-mention" data-user-id="218745">@Wanja Hentze</span>  Yep, but this is unavoidable.  If you pass some memory containing pointers to FFI (assuming it is mutable memory), if you imagine that provenance exists over FFI, then the FFI code could replace the provenances without changing the pointers ‚Äì but there is no way to know whether it did that or not, so your side of the FFI call must be optimized assuming it might have done that.</p>



<a name="277356695"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277356695" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277356695">(Apr 01 2022 at 00:18)</a>:</h4>
<p>Yeah, that won't work well for lccc.</p>



<a name="277356696"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277356696" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277356696">(Apr 01 2022 at 00:18)</a>:</h4>
<p>which depending on how that's actually implemented, might let you do better than "call into LLVM with two completely separate setups"</p>



<a name="277356707"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277356707" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277356707">(Apr 01 2022 at 00:18)</a>:</h4>
<p><span class="user-mention" data-user-id="198590">@comex</span> exactly</p>



<a name="277356709"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277356709" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277356709">(Apr 01 2022 at 00:18)</a>:</h4>
<p>Optimization level determines what optimization plugins are run on the IR the frontend generates.</p>



<a name="277356812"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277356812" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277356812">(Apr 01 2022 at 00:20)</a>:</h4>
<p>*without changing the addresses</p>



<a name="277356836"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277356836" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277356836">(Apr 01 2022 at 00:21)</a>:</h4>
<p>so any implementation must already be able to cope with pointers escaping into a big black box pools of provenances</p>



<a name="277356845"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277356845" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277356845">(Apr 01 2022 at 00:21)</a>:</h4>
<p>Sounds like we're in violent agreement...</p>



<a name="277356899"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277356899" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277356899">(Apr 01 2022 at 00:22)</a>:</h4>
<p>to me, that makes <em>something like</em> PNVI-ae inescapable</p>



<a name="277356906"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277356906" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277356906">(Apr 01 2022 at 00:22)</a>:</h4>
<p>troubles with formalizing that notwithstanding</p>



<a name="277356911"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277356911" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277356911">(Apr 01 2022 at 00:22)</a>:</h4>
<p>An implementation could also just not support FFI.</p>



<a name="277356920"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277356920" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277356920">(Apr 01 2022 at 00:22)</a>:</h4>
<p>Or only support a subset.</p>



<a name="277356921"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277356921" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277356921">(Apr 01 2022 at 00:23)</a>:</h4>
<p>miri is such an implementation.</p>



<a name="277356947"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277356947" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277356947">(Apr 01 2022 at 00:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="218745">Wanja Hentze</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277356899">said</a>:</p>
<blockquote>
<p>to me, that makes <em>something like</em> PNVI-ae inescapable</p>
</blockquote>
<p>Exactly my conclusion too.</p>



<a name="277356999"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277356999" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277356999">(Apr 01 2022 at 00:24)</a>:</h4>
<p>sure, but we will always need implementations that support FFI, the vast majority of production Rust code uses FFI</p>



<a name="277357043"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277357043" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277357043">(Apr 01 2022 at 00:24)</a>:</h4>
<p>FFI is necessary for I/O, so any program that doesn't use FFI can be trivially optimized away to nothing :)</p>



<a name="277357055"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277357055" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277357055">(Apr 01 2022 at 00:24)</a>:</h4>
<p><span class="user-mention silent" data-user-id="384014">Patrick Walton</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277357043">said</a>:</p>
<blockquote>
<p>FFI is necessary for I/O, so any program that doesn't use FFI can be trivially optimized away to nothing :)</p>
</blockquote>
<p>Well, volatile operations can be done in the AM directly.</p>



<a name="277357059"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277357059" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277357059">(Apr 01 2022 at 00:24)</a>:</h4>
<p>if you want to support FFI but also have strict provenance in miri, isn't that splitting the language?</p>



<a name="277357082"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277357082" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277357082">(Apr 01 2022 at 00:25)</a>:</h4>
<p>I mean, miri is functionally broken with PNVI-ae.</p>



<a name="277357146"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277357146" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277357146">(Apr 01 2022 at 00:26)</a>:</h4>
<p>There is code that is guaranteed to be valid that miri doesn't support because it's basically impossible to support using PNVI-ae.</p>



<a name="277357180"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277357180" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277357180">(Apr 01 2022 at 00:27)</a>:</h4>
<p>is there more to it for miri than having a global hash set or so of escaped provenances?</p>



<a name="277357191"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277357191" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277357191">(Apr 01 2022 at 00:27)</a>:</h4>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">p</span><span class="p">;</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="k">u32</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="cm">/*guess allocation of x, this is actually trivial with miri*/</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="k">unsafe</span><span class="p">{</span><span class="n">p</span><span class="p">.</span><span class="n">read</span><span class="p">()}</span><span class="w"></span>
</code></pre></div>



<a name="277357197"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277357197" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277357197">(Apr 01 2022 at 00:27)</a>:</h4>
<p>and perhaps merging overlapping ones</p>



<a name="277357215"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277357215" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277357215">(Apr 01 2022 at 00:27)</a>:</h4>
<p>If you properly guess the address of <code>x</code>, IIRC, miri reports UB here.</p>



<a name="277357270"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277357270" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277357270">(Apr 01 2022 at 00:28)</a>:</h4>
<p>However</p>
<blockquote>
<p>An nonzero literal cast to a pointer will allways be valid for accesses of size 0.</p>
</blockquote>



<a name="277357271"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277357271" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277357271">(Apr 01 2022 at 00:28)</a>:</h4>
<p>and this is impossible to support?</p>



<a name="277357294"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277357294" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277357294">(Apr 01 2022 at 00:29)</a>:</h4>
<p>Without making miri even more complex, slow, and memory hungry? I'd assume so.</p>



<a name="277357298"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277357298" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277357298">(Apr 01 2022 at 00:29)</a>:</h4>
<p>If miri is reporting UB for a dereference of a ZST, then I think that is just a bug in miri.</p>



<a name="277357300"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277357300" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277357300">(Apr 01 2022 at 00:29)</a>:</h4>
<p>oh, access of size zero. let us not have this discussion again</p>



<a name="277357312"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277357312" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277357312">(Apr 01 2022 at 00:29)</a>:</h4>
<p>Dereferencing a deallocated ZST pointer is still UB.</p>



<a name="277357318"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277357318" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277357318">(Apr 01 2022 at 00:29)</a>:</h4>
<p>Why?</p>



<a name="277357320"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277357320" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277357320">(Apr 01 2022 at 00:29)</a>:</h4>
<p>That is news to me.</p>



<a name="277357331"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277357331" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277357331">(Apr 01 2022 at 00:30)</a>:</h4>
<p>Read <code>core::ptr</code> # Safety in the stdlib docs.</p>



<a name="277357384"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277357384" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277357384">(Apr 01 2022 at 00:30)</a>:</h4>
<blockquote>
<p>Even for accesses of size zero, <code>p</code> must not be null or pointing to deallocated memory.</p>
</blockquote>



<a name="277357393"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277357393" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277357393">(Apr 01 2022 at 00:30)</a>:</h4>
<p>Okay, but why? (<span class="user-mention" data-user-id="120791">@RalfJ</span>)</p>



<a name="277357403"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277357403" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277357403">(Apr 01 2022 at 00:30)</a>:</h4>
<p>It makes the model far more consistent, especially pre-mono.</p>



<a name="277357442"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277357442" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277357442">(Apr 01 2022 at 00:31)</a>:</h4>
<p>there is no pre-mono memory model</p>



<a name="277357443"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277357443" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277357443">(Apr 01 2022 at 00:31)</a>:</h4>
<p>I, for one, would like to be able to reason about pointers in xir without having to write something 500 times the length of stacked borrows.</p>



<a name="277357500"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277357500" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277357500">(Apr 01 2022 at 00:32)</a>:</h4>
<p>If you make some optimization pre-mono based on a no-aliasing assumption that would be valid for non-ZSTs but isn't valid for ZSTs because (hypothetically) dereferencing 0 bytes is always valid‚Ä¶ then as a result of that optimization, you might assume the ZST has the wrong value‚Ä¶ and it doesn't matter because ZSTs have only one value.</p>



<a name="277357516"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277357516" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277357516">(Apr 01 2022 at 00:32)</a>:</h4>
<p><span class="user-mention silent" data-user-id="218745">Wanja Hentze</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277357442">said</a>:</p>
<blockquote>
<p>there is no pre-mono memory model</p>
</blockquote>
<p>And this is news to me. So basically, I can't genreate <code>indirect</code> instructions in generic code. Good to know. IDK how else to dereference a pointer in xir.</p>



<a name="277357528"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277357528" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277357528">(Apr 01 2022 at 00:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="198590">comex</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277357500">said</a>:</p>
<blockquote>
<p>If you make some optimization pre-mono based on a no-aliasing assumption that would be valid for non-ZSTs but isn't valid for ZSTs because (hypothetically) dereferencing 0 bytes is always valid‚Ä¶ then as a result of that optimization, you might assume the ZST has the wrong value‚Ä¶ and it doesn't matter because ZSTs have only one value.</p>
</blockquote>
<p>Well, unless it folds <code>undef invalid</code> as that value.</p>



<a name="277357532"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277357532" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277357532">(Apr 01 2022 at 00:33)</a>:</h4>
<p>Do you have a concrete example of a case where this makes a difference?</p>



<a name="277357549"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277357549" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277357549">(Apr 01 2022 at 00:33)</a>:</h4>
<p>I don't know what <code>undef invalid</code> means, but zero bytes of <code>undef</code> should be a perfectly fine value.</p>



<a name="277357552"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277357552" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277357552">(Apr 01 2022 at 00:33)</a>:</h4>
<p>Not a specific example, other than the length of the xir spec.</p>



<a name="277357592"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277357592" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277357592">(Apr 01 2022 at 00:34)</a>:</h4>
<p>I mean, LLVM <code>undef</code>.</p>



<a name="277357597"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277357597" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277357597">(Apr 01 2022 at 00:34)</a>:</h4>
<p>Even LLVM <code>poison</code>.</p>



<a name="277357609"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277357609" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277357609">(Apr 01 2022 at 00:34)</a>:</h4>
<p>Well, I don't think LLVM has zero-size values.</p>



<a name="277357641"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277357641" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277357641">(Apr 01 2022 at 00:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="198590">comex</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277357549">said</a>:</p>
<blockquote>
<p>I don't know what <code>undef invalid</code> means, but zero bytes of <code>undef</code> should be a perfectly fine value.</p>
</blockquote>
<p><code>undef</code> is a class of values in xir, which has two members: <code>undef uninit</code> which is the "cannonical" uninitialized value of some type (equivalent to llvm <code>poison</code>), and <code>undef invalid</code> which is the "cannonical" invalid value of some type.<br>
The easiest explanation is that <code>undef invalid</code> is <em>the</em> value of type <code>!</code> - it's production is immediate undefined behaviour.</p>



<a name="277357696"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277357696" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277357696">(Apr 01 2022 at 00:36)</a>:</h4>
<p>Well, ZSTs have no invalid values.</p>



<a name="277357707"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277357707" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277357707">(Apr 01 2022 at 00:36)</a>:</h4>
<p>In xir, every type has at least one invalid value - <code>undef invalid</code>.</p>



<a name="277357712"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277357712" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277357712">(Apr 01 2022 at 00:36)</a>:</h4>
<p>Then xir is wrong :)</p>



<a name="277357735"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277357735" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277357735">(Apr 01 2022 at 00:37)</a>:</h4>
<p><code>const undef invalid T</code> is the same as producing a value of type <code>!</code>, then coercing it to <code>T</code>.</p>



<a name="277357763"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277357763" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277357763">(Apr 01 2022 at 00:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="198590">comex</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277357712">said</a>:</p>
<blockquote>
<p>Then xir is wrong :)</p>
</blockquote>
<p>I mean, is it? You can't reach it in rust w/o UB.</p>



<a name="277357831"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277357831" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277357831">(Apr 01 2022 at 00:38)</a>:</h4>
<p>Well, maybe I'm overstating my case.  If you have something which is nominally a value, but is really just a representation of the fact that being at this point in the code is UB, then there's nothing inherently invalid about that.</p>



<a name="277357837"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277357837" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277357837">(Apr 01 2022 at 00:38)</a>:</h4>
<p>But again, need a more concrete example where this matters.</p>



<a name="277357874"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277357874" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277357874">(Apr 01 2022 at 00:39)</a>:</h4>
<p>My concrete example is the xir pointer spec. That becomes far too overcomplicated if I have to special case every single pointer operation on zero-sized types.</p>



<a name="277357937"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277357937" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277357937">(Apr 01 2022 at 00:40)</a>:</h4>
<p>I guess if you want to optimize <code>fn foo&lt;T&gt;(ptr: *mut T) -&gt; T { dealloc(ptr); *ptr }</code> into <code>fn foo&lt;T&gt;(ptr: *mut T) -&gt; T { abort() }</code>...</p>



<a name="277357939"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277357939" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277357939">(Apr 01 2022 at 00:40)</a>:</h4>
<p>Like rust, I want a model that makes sense, and that doesn't take an essay to say what it currently says in one sentance.</p>



<a name="277357956"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277357956" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277357956">(Apr 01 2022 at 00:40)</a>:</h4>
<p><span class="user-mention silent" data-user-id="198590">comex</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277357937">said</a>:</p>
<blockquote>
<p>I guess if you want to optimize <code>fn foo&lt;T&gt;(ptr: *mut T) -&gt; T { dealloc(ptr); *ptr }</code> into <code>fn foo&lt;T&gt;(ptr: *mut T) -&gt; T { abort() }</code>...</p>
</blockquote>
<p>This would be a case of "folding invalid".</p>



<a name="277357963"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277357963" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277357963">(Apr 01 2022 at 00:41)</a>:</h4>
<p>Okay, fine.  So the real problem is that you're being too aggressive about optimizations done pre-mono :)</p>



<a name="277357976"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277357976" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277357976">(Apr 01 2022 at 00:41)</a>:</h4>
<p>(Also, the backend currently checks certain kinds of validity w/o checking sizes - because size checking every single instruction would be garbage).</p>



<a name="277358029"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277358029" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277358029">(Apr 01 2022 at 00:42)</a>:</h4>
<p>(Size checking potentially involves computing aggregate layout)</p>



<a name="277358073"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277358073" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277358073">(Apr 01 2022 at 00:44)</a>:</h4>
<p>Before I log off, I would like to summarize the position that I arrived at after interesting discussions here. So that it can be linked to.</p>



<a name="277358112"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277358112" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277358112">(Apr 01 2022 at 00:44)</a>:</h4>
<p>Inspired by <a href="https://gankra.github.io/blah/fix-rust-pointers/">(1)</a> <a href="https://github.com/rust-lang/rust/issues/95228">(2)</a> We would like</p>
<ul>
<li>a pathway to a formally-defined execution model</li>
<li>compilation to fast code ‚Äî meaning that powerful alias analysis applies to common Rust code</li>
<li>to support CHERI</li>
<li>that a lot of existing unsafe code keeps working</li>
<li>to keep supporting <code>inttoptr</code> for some niche use cases, like pointer compression</li>
<li>to avoid weird miscompilations like <a href="https://www.ralfj.de/blog/2020/12/14/provenance.html">https://www.ralfj.de/blog/2020/12/14/provenance.html</a> </li>
</ul>
<p>I think the following approach gets us everything or 99% of what we want.</p>
<ul>
<li>
<p>We keep <code>usize as ptr</code> permissive as is, and we discourage its use. We don't change its meaning, so perhaps it's defined as something like Stacked Borrows (~ the Rust analog of pnvi-ae). What the semantics is exactly of <code>usize as ptr</code> is outside the scope of this topic ‚Äî but it is <em>not</em> strict.</p>
</li>
<li>
<p>On CHERI, <code>usize as ptr</code> compiles to something horribly expensive (like the <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277317047">TreeMap</a> approach)</p>
</li>
<li>
<p>We keep <code>ptr.addr()</code> / <code>ptr as usize</code> permissive as is, and we discourage their use. On CHERI, they compile to something horribly expensive.</p>
</li>
<li>
<p>We introduce <code>ptr.addr_strict()</code> which is fast on CHERI -- but <code>ptr.addr_strict() as ptr</code> is principally UB.</p>
</li>
<li>
<p>With the new <code>#[feature(strict_provenance)]</code> functions in <code>std::ptr</code>, we can convert <code>ptr.addr_strict()</code>-based addresses back into real pointers, even on CHERI. </p>
</li>
<li>
<p>We keep <code>std::ptr::invalid</code> as in nightly. This corresponds to "strict" <code>inttoptr</code>. It is UB to dereference these.</p>
</li>
<li>
<p>We introduce a lint against <code>usize as ptr</code> and <code>ptr as usize</code> ‚Äî because they are horribly slow on some platforms and merely slower on most others.</p>
</li>
<li>
<p>All other ways to create a pointer (in particular various transmutes) are UB. </p>
</li>
<li>
<p>For our future "abstract machine", we keep aiming for something like Stacked Borrows. </p>
</li>
</ul>
<p>Then</p>
<ul>
<li>We don't need no compiler flag, no opt-in, no opt-out</li>
<li>We break pretty much nothing (presumably, to be <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277349017">investigated</a>)</li>
<li>This doesn't create new questions around FFI</li>
<li>We make CHERI work</li>
<li>We plan to rewrite crates so <code>usize as ptr</code> and <code>ptr as usize</code> is no longer used. This is only a performance improvement ‚Äî the original still works.</li>
<li>CHERI is fast after the ecosystem transitions over</li>
<li>Compressed pointers keep working as they do now ‚Äî and pretty fast on x64.</li>
<li>Our relation with LLVM stays principally the same. </li>
<li>Transmuting / memory semantics <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/286">needs to be refined further</a>.</li>
</ul>



<a name="277358115"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277358115" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277358115">(Apr 01 2022 at 00:44)</a>:</h4>
<p>That's it, please carry on</p>



<a name="277358233"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277358233" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277358233">(Apr 01 2022 at 00:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="198590">comex</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277357393">said</a>:</p>
<blockquote>
<p>Okay, but why? (<span class="user-mention silent" data-user-id="120791">RalfJ</span>)</p>
</blockquote>
<p>originally, because LLVM</p>



<a name="277358410"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277358410" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277358410">(Apr 01 2022 at 00:48)</a>:</h4>
<p>nothing in the langref permits us to GEPi by 0 on a dangling pointer after it got deallocated. in C this would be UB (because pointers to deallocated locations become indeterminate). when I asked on the llvm-dev list I think they didn't really understand the question but the general vibe was "better dont do that".<br>
also it is indeed more consistent under strict aliasing -- when an allocation is <code>free</code>d, its provenance is killed, and any interaction with that provenance now is UB. in Miri we would need a special case to allow this.</p>



<a name="277358456"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277358456" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277358456">(Apr 01 2022 at 00:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="198590">comex</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277357963">said</a>:</p>
<blockquote>
<p>Okay, fine.  So the real problem is that you're being too aggressive about optimizations done pre-mono :)</p>
</blockquote>
<p>One of the benefits to xir is supposed to be that you can run all opts pre-mono instead of post-mono and it's still correct.</p>



<a name="277358541"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277358541" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277358541">(Apr 01 2022 at 00:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="218745">Wanja Hentze</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277357442">said</a>:</p>
<blockquote>
<p>there is no pre-mono memory model</p>
</blockquote>
<p>FWIW, I agree. the semantics of pre-mono code is defined by "pick a monomorphization, and then run it with that".<br>
pre-mono optimizations are correct if they are correct for each possible monomorphization.</p>



<a name="277358552"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277358552" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277358552">(Apr 01 2022 at 00:50)</a>:</h4>
<p>Part of that involves specifying the IR far better than LLVM has done.</p>



<a name="277358580"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277358580" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277358580">(Apr 01 2022 at 00:51)</a>:</h4>
<p>Rust doesn't have a uniform representation or so, so I dont see how pre-mono execution even makes sense.</p>



<a name="277358688"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277358688" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277358688">(Apr 01 2022 at 00:52)</a>:</h4>
<p>like, it has to return <em>something</em> for queries like "what is the size of this" or "what is the offset of that"</p>



<a name="277358692"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277358692" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277358692">(Apr 01 2022 at 00:52)</a>:</h4>
<p>that all only makes sense post-mono</p>



<a name="277358716"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277358716" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277358716">(Apr 01 2022 at 00:53)</a>:</h4>
<p><code>size_of %0</code>is good enough for optimizations.</p>



<a name="277358906"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277358906" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277358906">(Apr 01 2022 at 00:56)</a>:</h4>
<p>sure but that doesnt need a pre-mono memory model or anything like that</p>



<a name="277358913"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277358913" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277358913">(Apr 01 2022 at 00:56)</a>:</h4>
<p>In any case, I'm less concerned about the loss of pre-mono opts then I am of the spec work underlying that. I rely heavily on being able to not insert properties of types into most pointer operations (and talking mostly about properties of objects) to be able to write anything at all. There's currently one special case for ZSTs.</p>



<a name="277358918"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277358918" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277358918">(Apr 01 2022 at 00:56)</a>:</h4>
<p>that's equivalent to saying "optimizations need to be correct for all possible mono"</p>



<a name="277359222"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277359222" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277359222">(Apr 01 2022 at 01:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277358906">said</a>:</p>
<blockquote>
<p>sure but that doesnt need a pre-mono memory model or anything like that</p>
</blockquote>
<p>Right, what I need is a coherent memory model that I can express, preferably in less text that comprises the entire lccc codebase.</p>



<a name="277359277"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277359277" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277359277">(Apr 01 2022 at 01:01)</a>:</h4>
<p>Having ZSTs not be special cased wrt. deallocated pointers makes that job a heck of a lot easier.</p>



<a name="277361400"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277361400" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jessica Clarke <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277361400">(Apr 01 2022 at 01:40)</a>:</h4>
<p><span class="user-mention silent" data-user-id="490906">Brooks Davis</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277340798">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277340272">said</a>:</p>
<blockquote>
<p>I propose (only 5% my own proposal) that CHERI <code>ptr.addr()</code> would insert the pointer into a TreeMap. Or something more complicated that allows for pruning when the Stacked Borrows protector is popped / something like that</p>
</blockquote>
<p>From a CHERI and exploit mitigation perspective I'm horrified. <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span> We've talked about such things to support awful C idioms (e.g., round tripping a pointer through <code>sprintf("%p")</code> and <code>sscanf("%p")</code>) but never as something anyone would actually implement.</p>
</blockquote>
<p>It's also genuinely impossible to make work. You can have two pointers with the same address but different bounds, permissions, whatever. How then do you know which of the pointers with that address to use? You can't. So this just isn't productive to talk about, even aside from the atrocious performance and security consequences of it.</p>



<a name="277361456"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277361456" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jessica Clarke <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277361456">(Apr 01 2022 at 01:42)</a>:</h4>
<p>If you want concrete examples:</p>
<ol>
<li>A pointer to the array and a pointer to just the first element alias but have different bounds</li>
<li>A JIT could have RW and RX pointers to the same memory (you don't need W^X in your page tables any more, just map RWX and only give out disjoint capabilities)</li>
</ol>



<a name="277361515"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277361515" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jessica Clarke <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277361515">(Apr 01 2022 at 01:42)</a>:</h4>
<p>Magicking up capabilities from some mysterious hidden set of leaked addresses only works in the simple cases, it doesn't work in the general case, so it's not worth viewing as a serious proposal IMO.</p>



<a name="277361750"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277361750" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jessica Clarke <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277361750">(Apr 01 2022 at 01:47)</a>:</h4>
<p>Oh or another even more fun example:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">;</span><span class="w"></span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%p %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">);</span><span class="w"></span>
<span class="n">scanf</span><span class="p">(</span><span class="s">"%p"</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">p</span><span class="p">);</span><span class="w"></span>
</code></pre></div>
<p>If <code>p == a + 1 == b</code>, what bounds does p have? a's or b's?</p>



<a name="277361866"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277361866" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277361866">(Apr 01 2022 at 01:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="439664">Jessica Clarke</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277361400">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="490906">Brooks Davis</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277340798">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277340272">said</a>:</p>
<blockquote>
<p>I propose (only 5% my own proposal) that CHERI <code>ptr.addr()</code> would insert the pointer into a TreeMap. Or something more complicated that allows for pruning when the Stacked Borrows protector is popped / something like that</p>
</blockquote>
<p>From a CHERI and exploit mitigation perspective I'm horrified. <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span> We've talked about such things to support awful C idioms (e.g., round tripping a pointer through <code>sprintf("%p")</code> and <code>sscanf("%p")</code>) but never as something anyone would actually implement.</p>
</blockquote>
<p>It's also genuinely impossible to make work. You can have two pointers with the same address but different bounds, permissions, whatever. How then do you know which of the pointers with that address to use? You can't. So this just isn't productive to talk about, even aside from the atrocious performance and security consequences of it.</p>
</blockquote>
<p>But in practice round tripping a pointer through sprintf/sscanf works today in most C++ environments. (Programs do the moral equivalent of that when they load binaries from disk into memory.) So I don't see why it's not productive to talk about how we're going to support it.</p>



<a name="277361953"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277361953" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277361953">(Apr 01 2022 at 01:50)</a>:</h4>
<p>I know that you can come up with some examples that LLVM miscompiles. But in practice hiding pointers in ints works, and there's code out there that relies on it.</p>



<a name="277362264"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277362264" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277362264">(Apr 01 2022 at 01:57)</a>:</h4>
<p>If CHERI is unable to support idioms that hide pointers in integers, then I would argue that that is a practicality issue that needs to be addressed in CHERI, and not something we need to break code in service of. Not to take this too far off topic, but there are real concerns inside the Android team that CHERI is too restrictive for them.</p>



<a name="277362327"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277362327" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277362327">(Apr 01 2022 at 01:58)</a>:</h4>
<p>This is not to bash CHERI, just to say that it may not be best to treat CHERI's current semantics as sacrosanct.</p>



<a name="277363757"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277363757" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277363757">(Apr 01 2022 at 02:24)</a>:</h4>
<p>CHERI has done pretty well at modifying its semantics to be, in practice, looser than what the majority of C or C++ code really needs, while still being reasonably strict. They have one of the BSDs, Postgres, and WebKit working, last I checked. I find it hard to believe an Android app, or even Android itself, does anything so exotic that it is actually infeasible.</p>



<a name="277363771"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277363771" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277363771">(Apr 01 2022 at 02:24)</a>:</h4>
<p><span class="user-mention silent" data-user-id="384014">Patrick Walton</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277362264">said</a>:</p>
<blockquote>
<p>If CHERI is unable to support idioms that hide pointers in integers, then I would argue that that is a practicality issue that needs to be addressed in CHERI, and not something we need to break code in service of. Not to take this too far off topic, but there are real concerns inside the Android team that CHERI is too restrictive for them.</p>
</blockquote>
<p>I mean, CHERI works, so clearly they support it well enough to at least get a program loader of sorts working. :D</p>
<p>In the context of Rust I think it is fine if CHERI does not support software that does not comply with 'strict provenance'. a new architecture like CHERI is a great time to admit that some decisions made in the past were a mistake. we can use legacy code on legacy platforms and make sure it works there, but maybe we can do better for new ones. They actually managed to do way more than that for C (though that involves things that would be harder to do in Rust, like a 128bit uintptr_t).</p>



<a name="277363872"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277363872" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277363872">(Apr 01 2022 at 02:27)</a>:</h4>
<p>okay "legacy" is too strong here but you see what I mean.</p>



<a name="277364080"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277364080" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277364080">(Apr 01 2022 at 02:30)</a>:</h4>
<p>I strongly believe the way pointers are treated in C is a horrible mistake. we barely keep it working kinda but if you look close enough it's all sorts of broken (as my many examples show). sure, we have to keep this old stuff running along somehow and we'll keep adding crutches to prevent it from falling over, but that shouldn't stop us from figuring out how to do this <em>properly</em>.</p>
<p>this is not to bash C, just to say that it may not be best to treat the mess that is pointers in C as sacrosanct.</p>



<a name="277364105"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277364105" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Thom Chiovoloni <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277364105">(Apr 01 2022 at 02:31)</a>:</h4>
<blockquote>
<p>I find it hard to believe an Android app, or even Android itself, does anything so exotic that it is actually infeasible.</p>
</blockquote>
<p>you, uh, may be underestimating the sketchy things games do.</p>



<a name="277364168"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277364168" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277364168">(Apr 01 2022 at 02:32)</a>:</h4>
<p>I am aware of the monstrosities games perpetrate, actually!</p>



<a name="277364186"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277364186" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Thom Chiovoloni <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277364186">(Apr 01 2022 at 02:33)</a>:</h4>
<p>i have little hope for them on cheri</p>



<a name="277364200"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277364200" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Thom Chiovoloni <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277364200">(Apr 01 2022 at 02:33)</a>:</h4>
<p>doesn't mean cheri is bad, though. especially since iirc it has a model for software that completely disregards the rules</p>



<a name="277364252"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277364252" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277364252">(Apr 01 2022 at 02:34)</a>:</h4>
<p>Yes, it allows sandboxing essentially an entire process away from Da Rules.</p>



<a name="277364270"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277364270" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277364270">(Apr 01 2022 at 02:34)</a>:</h4>
<p>Which is actually why I think games will be mmmostly fine on CHERI since usually they're just perpetrating their crimes against <strong>themselves</strong>.</p>



<a name="277364286"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277364286" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277364286">(Apr 01 2022 at 02:35)</a>:</h4>
<p>Or using a lot of arenas.</p>



<a name="277364372"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277364372" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277364372">(Apr 01 2022 at 02:37)</a>:</h4>
<p>( and, functionally, the CHERI model for Mischievous Software that does Pointer Crimes is... hard to distinguish from "so we drop all this into an arena and create a valid capability for the entire arena". )</p>



<a name="277364561"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277364561" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277364561">(Apr 01 2022 at 02:41)</a>:</h4>
<p>I mean, the CHERI model for "basically not using CHERI for this app" is mostly irrelevant to a discussion about provenance, because then CHERI is a non-factor</p>



<a name="277364662"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277364662" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277364662">(Apr 01 2022 at 02:43)</a>:</h4>
<p>like rust could say it supports CHERI in a PNVI-like provenance world, where it only supports it when all capabilities are the maximum-for-address-space one or whatever</p>



<a name="277364838"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277364838" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277364838">(Apr 01 2022 at 02:46)</a>:</h4>
<p>That is indeed true. Unlike CHERI, programming languages tend to actually assign responsibility to programmers. They actually have less options than hardware like CHERI does for... condescension to programs that refuse responsibility.</p>



<a name="277364950"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277364950" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277364950">(Apr 01 2022 at 02:49)</a>:</h4>
<p>I mean, -fno-strict-aliasing/-fwrapv/etc for prior examples of programming languages doing that</p>



<a name="277365018"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277365018" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277365018">(Apr 01 2022 at 02:50)</a>:</h4>
<p>Ah, yes.<br>
But at extreme cost to self, by comparison.</p>



<a name="277365489"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277365489" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277365489">(Apr 01 2022 at 03:01)</a>:</h4>
<p>A CHERI architecture agreeing to carve out a zone wherein all pointers are interpreted as having a capability entitling them to dereference anywhere in that zone maintains the integrity of the rule, "under CHERI, all pointers obey these boundary conditions". That code cannot then wander outside and cause mischief, even if it is very mischievous within those bounds.</p>
<p>But the examples you cite are not "integrity preserving" in the same way, and so cause considerably more issues.</p>



<a name="277365507"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277365507" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277365507">(Apr 01 2022 at 03:01)</a>:</h4>
<p>Not all escape hatches are created equal, unfortunately.</p>



<a name="277366560"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277366560" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277366560">(Apr 01 2022 at 03:25)</a>:</h4>
<p>-fwrapv is, but it's also super trivial; I believe strict-aliasing code can still call into -fno-strict-aliasing code? (the reverse requires being more careful around the boundary, but that's also true for nesting CHERI capabilities)</p>



<a name="277366641"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277366641" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277366641">(Apr 01 2022 at 03:26)</a>:</h4>
<p>unless you just mean that CHERI capabilities are a stronger statement than strict-aliasing, sure, but that doesn't seem like what you mean?</p>



<a name="277369011"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277369011" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277369011">(Apr 01 2022 at 04:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277364080">said</a>:</p>
<blockquote>
<p>I strongly believe the way pointers are treated in C is a horrible mistake. we barely keep it working kinda but if you look close enough it's all sorts of broken (as my many examples show). sure, we have to keep this old stuff running along somehow and we'll keep adding crutches to prevent it from falling over, but that shouldn't stop us from figuring out how to do this <em>properly</em>.</p>
<p>this is not to bash C, just to say that it may not be best to treat the mess that is pointers in C as sacrosanct.</p>
</blockquote>
<p>The difference, of course, is that nobody is using CHERI while everyone is using C.</p>



<a name="277369027"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277369027" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277369027">(Apr 01 2022 at 04:12)</a>:</h4>
<p>And orders of magnitude more people are using unsafe Rust than are using CHERI.</p>



<a name="277369106"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277369106" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277369106">(Apr 01 2022 at 04:13)</a>:</h4>
<p>And we have a Rust 1.0 compatibility promise for currently-working code. We have made no promise that we are going to make Rust compatible with CHERI. Given that Rust has far more users than CHERI, I could reasonably argue that it's CHERI's responsibility to be compatible with <em>us</em>.</p>



<a name="277369398"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277369398" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277369398">(Apr 01 2022 at 04:20)</a>:</h4>
<p>I also disagree that it's important to figure out how to do pointers properly, if "properly" means "incompatible with existing Rust code". Rust isn't a research project.</p>



<a name="277369506"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277369506" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277369506">(Apr 01 2022 at 04:22)</a>:</h4>
<p>I'm all for improvements that we can make to the status quo given the compatibility constraint, though.</p>



<a name="277369524"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277369524" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277369524">(Apr 01 2022 at 04:23)</a>:</h4>
<p>(which, again, doesn't mean "no code at all breaks" -- it means "the vast majority of reasonable unsafe code keeps working", with the acknowledgment that "vast majority" and "reasonable" are subjective terms).</p>



<a name="277369793"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277369793" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Thom Chiovoloni <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277369793">(Apr 01 2022 at 04:31)</a>:</h4>
<p>It's worth noting there's an ongoing discussion about what stability guarantees unsafe code has in <a href="#narrow/stream/213817-t-lang/topic/Stability.20guarantees.20of.20.60unsafe.60.20code">https://rust-lang.zulipchat.com/#narrow/stream/213817-t-lang/topic/Stability.20guarantees.20of.20.60unsafe.60.20code</a>, which may be a better place for some of this discussion</p>



<a name="277370025"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277370025" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277370025">(Apr 01 2022 at 04:37)</a>:</h4>
<p>Good point, I'll continue the discussion there.</p>



<a name="277372760"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277372760" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Florian Gilcher <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277372760">(Apr 01 2022 at 05:38)</a>:</h4>
<p><span class="user-mention" data-user-id="384014">@Patrick Walton</span> I called you out on the GH issue on this before and I‚Äòll call you out again: being dismissive of CHERI is not getting us anywhere. I understand that support is hard, but it isn‚Äòt as niche as you make it to me and we should avoid arguments that boil down to grandeur.</p>



<a name="277372783"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277372783" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Florian Gilcher <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277372783">(Apr 01 2022 at 05:39)</a>:</h4>
<p>Please drop your tone a little bit, you are literally a person of social discussion currently and I know you can do better then that.</p>



<a name="277372874"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277372874" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Florian Gilcher <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277372874">(Apr 01 2022 at 05:40)</a>:</h4>
<p>I understand your issue, but just to be clear: there‚Äòs currently an initiative about Rust out there by MISRA and the _other_ danger is a MISRA-Rust dialect.</p>



<a name="277373029"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277373029" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Florian Gilcher <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277373029">(Apr 01 2022 at 05:43)</a>:</h4>
<p>Also, your statement on the size of Rust is overstated and CHERI is literally the model for all new arm based automotive-platforms. Which is not a loud community, but a surprisingly big one and one currently adopting Rust.</p>



<a name="277374710"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277374710" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Christopher Durham <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277374710">(Apr 01 2022 at 06:14)</a>:</h4>
<p><span class="user-mention" data-user-id="465167">@Bram Geron</span> curious: why should <code>ptr.addr()</code> be the permissive? I would think it should be the strict one, and e.g. <code>ptr.broadcast()</code> be the weak one (and <code>ptr as usize</code> disallowed in edition 203X)</p>



<a name="277377967"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277377967" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277377967">(Apr 01 2022 at 07:10)</a>:</h4>
<p>Yes, <code>ptr.addr()</code> was just added in the strict-provenance PR so it would be weird to immediately deprecate it and replace it with <code>ptr.addr_strict()</code></p>



<a name="277380820"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277380820" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277380820">(Apr 01 2022 at 07:48)</a>:</h4>
<p>Good point. Yeah, might as well spell it addr. <span aria-label="raised hands" class="emoji emoji-1f64c" role="img" title="raised hands">:raised_hands:</span>üèª</p>



<a name="277381358"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277381358" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277381358">(Apr 01 2022 at 07:54)</a>:</h4>
<p>That was hardly dismissive given the general arguments in favor of breaking things to support CHERI (as opposed to some of the other arguments)</p>



<a name="277384483"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277384483" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> riking <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277384483">(Apr 01 2022 at 08:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277352976">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="218745">Wanja Hentze</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277351850">said</a>:</p>
<blockquote>
<p>So, scapegoat idea: <code>rustc -fno-strict-provenance</code></p>
</blockquote>
<p>Consensus seems to be that we can just introduce <code>ptr.addr_strict()</code> ‚Äî you can't use the result to convert back into a pointer. And then there's no reason to add a compiler flag. Much simpler.</p>
</blockquote>
<p>We should probably just make <code>.addr()</code>, the _new thing we're adding_, be strict.</p>



<a name="277384584"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277384584" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277384584">(Apr 01 2022 at 08:30)</a>:</h4>
<blockquote>
<p>Yes, <code>ptr.addr()</code> was just added in the strict-provenance PR so it would be weird to immediately deprecate it and replace it with <code>ptr.addr_strict()</code></p>
</blockquote>
<p>Actually, with Aria's arguments (and I agree) there should be <em>two</em> methods on pointers ‚Äî one permissive and one strict. The permissive method replaces <code>ptr as usize</code>. Because you can put documentation &amp; caveats on docstrings, and <em>both methods</em> need explanation. One is UB in more cases, one is super slow on some platforms.</p>
<p>We can bikeshed about the names.</p>



<a name="277384594"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277384594" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> riking <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277384594">(Apr 01 2022 at 08:30)</a>:</h4>
<p><code>ptr.addr() as *mut T</code> is not something that someone should be writing, if you're using <code>.addr()</code> then you need to use <code>.with_addr()</code></p>



<a name="277384636"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277384636" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277384636">(Apr 01 2022 at 08:31)</a>:</h4>
<p>That makes visual sense</p>



<a name="277384647"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277384647" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277384647">(Apr 01 2022 at 08:31)</a>:</h4>
<p>So ‚Äî <code>addr</code> and <code>addr_permissive</code>?</p>



<a name="277384949"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277384949" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277384949">(Apr 01 2022 at 08:34)</a>:</h4>
<p><code>addr</code> and <code>addr_for_pointer_crimes</code>?</p>



<a name="277385405"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277385405" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277385405">(Apr 01 2022 at 08:38)</a>:</h4>
<p><span class="user-mention" data-user-id="215333">@Florian Gilcher</span> I'm not being dismissive of CHERI. I'm saying that we should not break existing code in order to support CHERI.</p>



<a name="277385453"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277385453" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277385453">(Apr 01 2022 at 08:39)</a>:</h4>
<p>And I wish I could say just how much Rust code we have, but I'm not allowed to. It is not at all correct to characterize it as small.</p>



<a name="277385507"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277385507" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277385507">(Apr 01 2022 at 08:39)</a>:</h4>
<p>I am fine if there is a MISRA-Rust dialect. The number of people who will write in it is so small that it won't matter.</p>



<a name="277385617"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277385617" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277385617">(Apr 01 2022 at 08:40)</a>:</h4>
<p>I'm confused as to why arguing that existing code is more important than CHERI support has anything to do with "grandeur".</p>



<a name="277385793"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277385793" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277385793">(Apr 01 2022 at 08:42)</a>:</h4>
<p>Honestly, as I said before, just judging by number of users, CHERI should be catering to us, not the other way around.</p>



<a name="277386070"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277386070" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277386070">(Apr 01 2022 at 08:45)</a>:</h4>
<p>Sorry, but I completely fail to see how I should interpret your messages as anything but dismissive of all concerns that aren't the ones favoring your desired outcome</p>



<a name="277386188"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277386188" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277386188">(Apr 01 2022 at 08:46)</a>:</h4>
<p>I'm arguing a point of view, I'm not being dismissive.</p>



<a name="277386240"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277386240" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277386240">(Apr 01 2022 at 08:46)</a>:</h4>
<blockquote>
<p>Honestly, as I said before, just judging by number of users, CHERI should be catering to us, not the other way around.</p>
</blockquote>
<p>This could change rapidly</p>



<a name="277386264"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277386264" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277386264">(Apr 01 2022 at 08:47)</a>:</h4>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277386240">said</a>:</p>
<blockquote>
<blockquote>
<p>Honestly, as I said before, just judging by number of users, CHERI should be catering to us, not the other way around.</p>
</blockquote>
<p>This could change rapidly</p>
</blockquote>
<p>Given the track record of academic research projects in this space, it will probably not.</p>



<a name="277386272"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277386272" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277386272">(Apr 01 2022 at 08:47)</a>:</h4>
<p>And I see more future in CHERI than in amd64, for instance</p>



<a name="277386328"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277386328" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277386328">(Apr 01 2022 at 08:48)</a>:</h4>
<blockquote>
<p>Given the track record of academic research projects in this space, it will probably not.</p>
</blockquote>
<p>You don't know. Automotive is not small. And ‚Äî this is exactly dismissing what you're doing =)</p>



<a name="277386376"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277386376" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277386376">(Apr 01 2022 at 08:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277386272">said</a>:</p>
<blockquote>
<p>And I see more future in CHERI than in amd64, for instance</p>
</blockquote>
<p>I'm not sure how to respond to this other than to say that this is way, way, way off from the industry consensus.</p>



<a name="277386430"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277386430" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277386430">(Apr 01 2022 at 08:48)</a>:</h4>
<p>So you are okay with us dismissing AMD64 when it stops being the industry consensus?</p>



<a name="277386483"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277386483" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277386483">(Apr 01 2022 at 08:49)</a>:</h4>
<p>You're making it sound like "industry consensus" is the purpose of Rust</p>



<a name="277386498"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277386498" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277386498">(Apr 01 2022 at 08:49)</a>:</h4>
<p>Being useful to industry <em>is</em> the purpose of Rust.</p>



<a name="277386509"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277386509" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277386509">(Apr 01 2022 at 08:49)</a>:</h4>
<p>I strongly disagree</p>



<a name="277386510"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277386510" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277386510">(Apr 01 2022 at 08:49)</a>:</h4>
<p>That's why it was created.</p>



<a name="277386518"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277386518" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277386518">(Apr 01 2022 at 08:49)</a>:</h4>
<p>Open source is also a thing</p>



<a name="277386538"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277386538" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277386538">(Apr 01 2022 at 08:49)</a>:</h4>
<p>Industry including open source.</p>



<a name="277386539"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277386539" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Boxy [she/her] <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277386539">(Apr 01 2022 at 08:49)</a>:</h4>
<p>I thought it was letting people write software that was safe and correct but sure I guess sucking up to capitalism is a good purpose too</p>



<a name="277386545"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277386545" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277386545">(Apr 01 2022 at 08:49)</a>:</h4>
<p>And a very different sphere</p>



<a name="277386670"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277386670" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277386670">(Apr 01 2022 at 08:50)</a>:</h4>
<p>I'm very concerned with the direction of Rust if the consensus is that AMD64 support is not a concern going forward.</p>



<a name="277386682"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277386682" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277386682">(Apr 01 2022 at 08:50)</a>:</h4>
<p>I would like to put the "heated" discussion yesterday in context ‚Äî there was intense arguing from one side to break compatibility as a first attempt, and from another to keep compatibility to a large extent where compatible with other goals. </p>
<p>I think we've now realized that <em>probably</em> we don't need to break compatibility very much at all</p>



<a name="277386702"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277386702" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277386702">(Apr 01 2022 at 08:51)</a>:</h4>
<p>Yes, that is a very good outcome.</p>



<a name="277386803"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277386803" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277386803">(Apr 01 2022 at 08:51)</a>:</h4>
<p>amd64 support will always stay relevant. Surely tier1 for decades.</p>



<a name="277386855"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277386855" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277386855">(Apr 01 2022 at 08:52)</a>:</h4>
<p>Yeah, uh. Insofar as I am concerned, the purpose of Rust is to be functional.<br>
An elevator didn't work and that was too pathetic to let stand.<br>
And that was the "industry consensus" not long ago.</p>



<a name="277386917"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277386917" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277386917">(Apr 01 2022 at 08:52)</a>:</h4>
<p>Really, basically still is.</p>



<a name="277386963"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277386963" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277386963">(Apr 01 2022 at 08:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="281757">Jubilee</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277386855">said</a>:</p>
<blockquote>
<p>Yeah, uh. Insofar as I am concerned, the purpose of Rust is to be functional.<br>
An elevator didn't work and that was too pathetic to let stand.<br>
And that was the "industry consensus" not long ago.</p>
</blockquote>
<p>The purpose of Rust is to be a useful language for programmers, not to be a research language.</p>



<a name="277386970"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277386970" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277386970">(Apr 01 2022 at 08:53)</a>:</h4>
<p>By your choice of words, computers nowadays are pathetic and don't work..?</p>



<a name="277386996"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277386996" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Boxy [she/her] <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277386996">(Apr 01 2022 at 08:53)</a>:</h4>
<p>i would definitely describe computers that way</p>



<a name="277387007"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277387007" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277387007">(Apr 01 2022 at 08:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="384014">Patrick Walton</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277386963">said</a>:</p>
<blockquote>
<p>The purpose of Rust is to be a useful language for programmers, not to be a research language.</p>
</blockquote>
<p>And Florian's point is that CHERI is rapidly exiting the research sphere</p>



<a name="277387147"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277387147" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277387147">(Apr 01 2022 at 08:54)</a>:</h4>
<p>I would say that computers currently work by accident. We want to make them work on purpose. But (even with strict provenance) we're veeerrry far off from that, although the direction is desirable and brings real gains</p>



<a name="277387148"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277387148" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> riking <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277387148">(Apr 01 2022 at 08:54)</a>:</h4>
<p>Oh, I see Mario beat me to it</p>



<a name="277387150"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277387150" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277387150">(Apr 01 2022 at 08:54)</a>:</h4>
<p>Let's be concrete: I see the chances that CHERI support will be useful to more people in the next 5 years than keeping existing unsafe code working to be basically zero.</p>



<a name="277387174"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277387174" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277387174">(Apr 01 2022 at 08:54)</a>:</h4>
<p>I think it's unhelpful to phrase it as an either/or</p>



<a name="277387187"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277387187" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277387187">(Apr 01 2022 at 08:54)</a>:</h4>
<p>But that is the dichotomy we're discussing.</p>



<a name="277387205"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277387205" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277387205">(Apr 01 2022 at 08:54)</a>:</h4>
<p>I have no idea how you've come to that conclusion</p>



<a name="277387212"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277387212" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277387212">(Apr 01 2022 at 08:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277387147">said</a>:</p>
<blockquote>
<p>I would say that computers currently work by accident. We want to make them work on purpose.</p>
</blockquote>
<p>I would accept this, yes.</p>



<a name="277387237"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277387237" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277387237">(Apr 01 2022 at 08:55)</a>:</h4>
<p>That's the dichotomy we keep coming back to ‚Äî but I think now the burden of proof is on showing that we can't reasonably have both</p>



<a name="277387243"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277387243" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277387243">(Apr 01 2022 at 08:55)</a>:</h4>
<p>As like... mission statement-y and description of reality.</p>



<a name="277387298"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277387298" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277387298">(Apr 01 2022 at 08:55)</a>:</h4>
<p>Compilers work and are useful because problems that occur from issues like the lack of strict provenance are very rare in practice.</p>



<a name="277387304"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277387304" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277387304">(Apr 01 2022 at 08:56)</a>:</h4>
<p>I have stared into the abyssal horror of the System V AMD64 ABI and I am Forever Scarred by that knowledge.</p>



<a name="277387420"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277387420" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> riking <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277387420">(Apr 01 2022 at 08:56)</a>:</h4>
<p>I would also like to state that I have some issues with the [tone / rhetoric strategy / choose a name for it] you have been using, Patrick.<br>
Expanding on this is not a productive use of this channel, DM me if you want the long version.</p>



<a name="277387438"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277387438" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277387438">(Apr 01 2022 at 08:57)</a>:</h4>
<p>every even mildly "accelerated" program is a breath away from abstract-seeming "ABI Problems" utterly annihilating it.</p>



<a name="277387481"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277387481" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277387481">(Apr 01 2022 at 08:57)</a>:</h4>
<p>Pure assembler is actually better off.</p>



<a name="277387503"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277387503" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277387503">(Apr 01 2022 at 08:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="281757">Jubilee</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277387438">said</a>:</p>
<blockquote>
<p>every even mildly "accelerated" program is a breath away from abstract-seeming "ABI Problems" utterly annihilating it.</p>
</blockquote>
<p>This is not true.</p>



<a name="277387547"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277387547" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277387547">(Apr 01 2022 at 08:58)</a>:</h4>
<p>In practice, optimizations work very well.</p>



<a name="277387562"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277387562" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277387562">(Apr 01 2022 at 08:58)</a>:</h4>
<p>I am not talking about optimizations.</p>



<a name="277387598"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277387598" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277387598">(Apr 01 2022 at 08:58)</a>:</h4>
<p>I am talking about what optimizations cannot give you. And I am talking about linkage.</p>



<a name="277387769"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277387769" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277387769">(Apr 01 2022 at 09:00)</a>:</h4>
<p>Anyway, I know that nobody wants to hear "I'm opposed to this change because it breaks code". Nobody ever wants to hear that. It's intensely frustrating when you've worked on something a long time, I get it. But we've decided as a project that we care about not breaking people's code, so it's a thing that should be brought up.</p>



<a name="277387944"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277387944" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277387944">(Apr 01 2022 at 09:01)</a>:</h4>
<p>Believe me, I used to hear proposed JavaScript features get shot down practically every week because of backwards compatibility concerns (often related to small things like automatic semicolon insertion).</p>



<a name="277388016"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277388016" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277388016">(Apr 01 2022 at 09:02)</a>:</h4>
<p>But aggressively maintaining backwards compatibility is the only way such features would ever ship.</p>



<a name="277388021"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277388021" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277388021">(Apr 01 2022 at 09:02)</a>:</h4>
<p>Frankly, not a lot of stuff has actually been worked on for a long time because every time someone tries to advance anything a step forward on this matter, hundreds of people step forth to tear them down.</p>



<a name="277388057"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277388057" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277388057">(Apr 01 2022 at 09:02)</a>:</h4>
<p>Often without even getting so far as seeing what is possible.</p>



<a name="277388089"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277388089" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> riking <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277388089">(Apr 01 2022 at 09:03)</a>:</h4>
<p>I've been assuming for this entire discussion that people have been aware of the Rust 1.0 compatibility promise, which relevantly says Rust reserves the right to break code that never worked, and the only real room for philosophical argument is around the definition of "never worked".</p>



<a name="277388100"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277388100" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277388100">(Apr 01 2022 at 09:03)</a>:</h4>
<p>So don't worry, it's just another Rust dev being burnt out and ripped apart, nothing of real concern like features shipping.</p>



<a name="277388305"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277388305" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277388305">(Apr 01 2022 at 09:05)</a>:</h4>
<p>I'm not "hundreds of people". In fact, Gankra and the others have done such a great job eloquently explaining the benefits of strict pointer provenance and similar proposals that they've generated a lot of excitement in the community.</p>



<a name="277388319"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277388319" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277388319">(Apr 01 2022 at 09:05)</a>:</h4>
<p>And in fact that's great!</p>



<a name="277388518"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277388518" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277388518">(Apr 01 2022 at 09:06)</a>:</h4>
<p><span class="user-mention silent" data-user-id="264702">riking</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277388089">said</a>:</p>
<blockquote>
<p>I've been assuming for this entire discussion that people have been aware of the Rust 1.0 compatibility promise, which relevantly says Rust reserves the right to break code that never worked, and the only real room for philosophical argument is around the definition of "never worked".</p>
</blockquote>
<p>Yes, that's why I talked about the "spirit" of the promise. Strictly interpreted, the text of the Rust 1.0 promise would allow any sort of change to unsafe code, even if it breaks every piece of unsafe code in the world, because there wasn't a memory model at all.</p>



<a name="277388624"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277388624" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> riking <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277388624">(Apr 01 2022 at 09:07)</a>:</h4>
<p>I don't think that's a defensible interpretation.</p>



<a name="277388633"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277388633" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277388633">(Apr 01 2022 at 09:07)</a>:</h4>
<p>Right.</p>



<a name="277388700"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277388700" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277388700">(Apr 01 2022 at 09:08)</a>:</h4>
<p>The actual text of the promise isn't what's relevant here. What I'm more focused on is the reasoning behind the Rust 1.0 promise. Rust has such a compatibility guarantee because it's necessary for Rust's customers to have the confidence to adopt Rust that there be a promise that code won't break.</p>



<a name="277388782"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277388782" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> riking <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277388782">(Apr 01 2022 at 09:09)</a>:</h4>
<p>Practically, how that has turned out has been extensive linting and automatic fix tools being provided for potentially breaking changes and future incompatibilities.</p>



<a name="277388900"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277388900" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277388900">(Apr 01 2022 at 09:10)</a>:</h4>
<p>That's only part of it. The other part is just not making changes that break people's code.</p>



<a name="277388926"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277388926" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277388926">(Apr 01 2022 at 09:10)</a>:</h4>
<p>This is, notably, why editions exist.</p>



<a name="277388956"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277388956" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> riking <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277388956">(Apr 01 2022 at 09:10)</a>:</h4>
<p>Crater gets run to get statistics like Chrome's UsageCounters to get a sense of "how much" a proposed change would break</p>



<a name="277388987"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277388987" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277388987">(Apr 01 2022 at 09:11)</a>:</h4>
<p>Yes, and that's what I'm arguing for here.</p>



<a name="277389047"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277389047" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277389047">(Apr 01 2022 at 09:11)</a>:</h4>
<p>I've never argued that unsafe code semantics changes that we make should never break any code ever.</p>



<a name="277389072"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277389072" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> riking <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277389072">(Apr 01 2022 at 09:11)</a>:</h4>
<p>I think that a productive path forward would be a design for a version of Crater that can be run in a secrecy-preserving way on private codebases</p>



<a name="277389190"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277389190" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277389190">(Apr 01 2022 at 09:12)</a>:</h4>
<p>It doesn't even need to be based on crater as long as it's something that we can check. I'm more than happy to figure out how to hook tools up to our build system, I don't expect the community to do that.</p>



<a name="277389206"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277389206" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> riking <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277389206">(Apr 01 2022 at 09:13)</a>:</h4>
<p>that way, the language developers get visibility into how bad the change would be, without the whole world getting visibility into Business Sensitive Numbers</p>



<a name="277389239"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277389239" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277389239">(Apr 01 2022 at 09:13)</a>:</h4>
<p>Yes, that's exactly what I'm advocating :)</p>



<a name="277389365"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277389365" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> riking <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277389365">(Apr 01 2022 at 09:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="384014">Patrick Walton</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277389190">said</a>:</p>
<blockquote>
<p>It doesn't even need to be based on crater as long as it's something that we can check. I'm more than happy to figure out how to hook tools up to our build system, I don't expect the community to do that.</p>
</blockquote>
<p>Ah, I was thinking of something that could be built once and deployed at N organizations, rather than per-org per-issue efforts.</p>



<a name="277389477"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277389477" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277389477">(Apr 01 2022 at 09:15)</a>:</h4>
<p>In practice that might be hard because of organization-specific build systems, but it could be helpful to have Google, etc. at the table to figure out what the best UI of a build-system-agnostic Crater would look like.</p>



<a name="277389524"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277389524" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277389524">(Apr 01 2022 at 09:16)</a>:</h4>
<p>I'd be happy to start this conversation.</p>



<a name="277389549"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277389549" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> riking <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277389549">(Apr 01 2022 at 09:16)</a>:</h4>
<p>(Per-org + Per-issue) must be the goal if it's going to be tractable</p>



<a name="277389639"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277389639" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277389639">(Apr 01 2022 at 09:17)</a>:</h4>
<p>half of the point of this exercise is to make code miri-checkable</p>



<a name="277389905"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277389905" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277389905">(Apr 01 2022 at 09:20)</a>:</h4>
<p>miri can't do FFI, or can it?</p>



<a name="277389934"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277389934" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277389934">(Apr 01 2022 at 09:20)</a>:</h4>
<p>It actually sorta can, it often has to be taught specifically what some code means.</p>



<a name="277389988"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277389988" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277389988">(Apr 01 2022 at 09:21)</a>:</h4>
<p>One of the advantages of a recent glibc update that is proposed is that it will move our thread spawn call off something... less comprehensible to Miri.</p>



<a name="277397717"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277397717" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277397717">(Apr 01 2022 at 10:36)</a>:</h4>
<p>I think characterizing this effort as being solely to support Cheri is a red herring. As far as I can foresee I have no intention of ever writing code that targets Cheri. What I want is to be able to teach Rust to a new user and when we get to <code>unsafe</code>, I want to be able to convey to them the following:</p>
<ol>
<li>What are the rules of unsafe code?</li>
<li>How do the Rust developers, who claim to care rigorously about memory safety, know that these rules are sufficient to enforce memory safety?</li>
</ol>
<p>Currently we don't have either of these, and I see that as a problem. If this effort gets us closer to that world, then I'm for it.</p>



<a name="277398243"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277398243" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277398243">(Apr 01 2022 at 10:42)</a>:</h4>
<p>And as <span class="user-mention" data-user-id="384014">@Patrick Walton</span> notes Rust does have a compatibility promise. The problem is that Rust <em>also</em> has another promise, perhaps less explicit but still completely tangible and arguably even more important: the promise to be memory-safe. The fact that this promise supersedes the stability promise is precisely why the latter carves out exceptions for soundness bugs. Obviously nobody <em>wants</em> to break code spuriously. I want as much code to continue working as possible, and I see that as important for Rust's adoption, which is important for moving us towards a memory-safe world. But if fundamentally Rust doesn't <em>work</em>, then frankly I don't care if it gets adopted, and if we can't write down the rules of unsafe code then arguably Rust does not work.</p>



<a name="277398440"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277398440" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277398440">(Apr 01 2022 at 10:44)</a>:</h4>
<p>I am optimistic about <span class="user-mention" data-user-id="465167">@Bram Geron</span>'s proposals and I would like to see them pursued. In the meantime I see nothing wrong with continuing to push on and expand the proposed APIs for std that will hopefully make it easy for some people to someday say that they can know with confidence that their unsafe code is actually correct. I also am extremely wary of forking the language, but if we <em>must</em> fork the language in order to have any sort of version of Rust that actually keeps its memory-safety promise, then I will tolerate that.</p>



<a name="277401054"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277401054" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277401054">(Apr 01 2022 at 11:12)</a>:</h4>
<p>Indeed - Rust being broken gives rust a license to break code relying on the broken parts.<br>
I'd similarily assume that if Rust is impossible to correctly implement, it has license to break the parts that cannot be correctly implemented. <br>
Also, the promise isn't "as works today", it's "as stable", which mostly overlaps, but they aren't the same thing. For example, if you rely in unsafe code on a repr(Rust) structure being layed out in a particular way, it's not a violation of the stability promise for rustc or for any other implementation to lay it out in an entirely different way in an update. Where the guarantee isn't stable, it isn't a guarantee. In stablizing a proper guarantee, it may be considered where people are relying on "what works today" but it's not required.</p>



<a name="277410720"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277410720" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277410720">(Apr 01 2022 at 12:39)</a>:</h4>
<p>Unsafe code is &lt;1% of Rust code according to <a href="http://crates.io">crates.io</a>. Of that, even <em>strict</em> provenance probably makes &lt;1% of it UB. Given that CHERI has managed to get such large projects working, a weaker provenance model would probably make only 0.1% of unsafe code UB. Of that, actual breakage (miscompilation due to new optimization passes) is likely to be even smaller, let's say 1/10th of that. If we made such a change it would take <em>at least</em> two editions (6 years) of incremental deprecations/warnings. That would mean a single programmer who only fixed 10 lines of broken unsafe code a year, could keep a 60 million line Rust project working.</p>
<p>These numbers are somewhat arbitrary, but the main point is that due to the separation of unsafe/safe code, we're already 100x better off than if similar breakage were going to happen in C, which will happen even if they don't manage to adopt a formal provenance model, simply as new optimizations get added to LLVM which individually don't quite break enough code to justify rolling back.</p>



<a name="277411170"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277411170" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277411170">(Apr 01 2022 at 12:43)</a>:</h4>
<p>I suspect if we redefine <code>ptr as usize</code>, <code>usize as ptr</code> to be strict, then &gt;10% of unsafe crates on <a href="http://crates.io">crates.io</a> become UB. Not &lt;1%</p>



<a name="277411240"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277411240" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277411240">(Apr 01 2022 at 12:43)</a>:</h4>
<p>But I like your idea of a back-of-the-envelope calculation</p>



<a name="277413063"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277413063" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277413063">(Apr 01 2022 at 12:57)</a>:</h4>
<p>I don't feel good about redefining the operations. As soon as possible, provide a comprehensive set of fixed and stable alternatives, then deprecate the casts. Propose removing the casts in the 2024 edition. But let them continue to operate as they currently do, and if at all possible let them "infect" a codebase with the current underspecified model, even if it means pessimizing certain optimizations for the entire crate graph; avoid the UB outcome. Maybe that means that you only get great optimization if every single crate in your graph is on the 2024 edition. Maybe that means somehow updating the libc crate to a modern MSRV. Maybe that means it takes 20 years for the majority of Rust code in the wild to benefit from this. That's acceptable, if it also means that people who <em>do</em> actually care about having a sound and understood model of unsafe code can use that to properly guarantee memory safety in their codebase, even if it takes a great deal of effort on their part.</p>



<a name="277413969"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277413969" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277413969">(Apr 01 2022 at 13:03)</a>:</h4>
<p>+1 on removing the cast syntax in a future edition. </p>
<p>To get The Good Speed, we just need as much code as possible to avoid <code>ptr as usize</code> and its alias <code>ptr.addr_permissive()</code>. But IIUC the speed benefits are gradual ‚Äî a bit of non-strict provenance doesn't "poison" performance for the rest of the program.</p>
<p>IMO editions are unrelated to performance, here. They just help to deprecate syntax in favor of a different spelling.</p>



<a name="277414209"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277414209" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277414209">(Apr 01 2022 at 13:05)</a>:</h4>
<p>As far as I understand, "old"/"permissive" provenance isn't an issue in particular for having a good model of unsafe code.</p>



<a name="277414280"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277414280" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277414280">(Apr 01 2022 at 13:05)</a>:</h4>
<p>Well, it isn't for Stacked Borrows, which seems the best we have now.</p>



<a name="277422742"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277422742" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ben Kimock (Saethlin) <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277422742">(Apr 01 2022 at 14:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="295632">Diggsey</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277410720">said</a>:</p>
<blockquote>
<p>These numbers are somewhat arbitrary...</p>
</blockquote>
<p>We don't need to pull numbers out of thin air here. I've written a little crater-like system that runs existing Miri with a bunch of strict checks on published crates. At present 1% of crates encounter something that Miri (before Ralf patched up the ptr-int transmute check) thinks is UB, based on the strict checking of <code>-Zmiri-tag-raw-pointers -Zmiri-check-number-validity</code>. That number may be higher, because about half of crates encounter an error in execution but also do not encounter any UB (per this very picky definition). The leading cause of UB reports is int-to-ptr casts. So far I'm only running the top 10,000 crates. Of those, 1,034 crates report UB, 310 crates encounter an int-to-ptr cast.<br>
This is all still very WIP, but you can browse the results at <a href="https://miri.saethlin.dev/">https://miri.saethlin.dev/</a> or just the crates where Miri reports UB at <a href="https://miri.saethlin.dev/ub">https://miri.saethlin.dev/ub</a> the site subject to change because I'm bad at this, etc. etc.</p>



<a name="277422833"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277422833" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ben Kimock (Saethlin) <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277422833">(Apr 01 2022 at 14:03)</a>:</h4>
<p>Oh also the Miri errors you see in the site are from a prototype branch of Miri that I'm working on, so if you try to repro locally you won't get exactly the same output</p>



<a name="277423123"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277423123" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ben Kimock (Saethlin) <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277423123">(Apr 01 2022 at 14:05)</a>:</h4>
<p>And the source for the tool is here: <a href="https://github.com/saethlin/miri-tools/">https://github.com/saethlin/miri-tools/</a><br>
Oli is helping me improve it a bit. I wouldn't mind such a thing being used to assess internal codebases.</p>



<a name="277423900"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277423900" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277423900">(Apr 01 2022 at 14:11)</a>:</h4>
<p>This means that ~1% of crates have UB respective to <em>permissive</em> provenance (as it is now).</p>
<p>If we aim for strict provenance in the ecosystem, then <em>every</em> int-to-ptr cast has to be rewritten.</p>
<p>Can you see how many crates use an int-to-ptr cast?</p>



<a name="277424198"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277424198" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277424198">(Apr 01 2022 at 14:13)</a>:</h4>
<p>(Not every cast has to be rewritten per se. But that's what "strict provenance" proposes ‚Äî to minimize any use of permissive provenance)</p>



<a name="277424765"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277424765" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ben Kimock (Saethlin) <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277424765">(Apr 01 2022 at 14:17)</a>:</h4>
<p>No, that is not what that means. Miri with <code>-Zmiri-tag-raw-pointers</code> is checking a far stricter model of provenance than the strict-provenance feature.</p>
<p>I cannot see for sure how many crates use an int-to-ptr cast. I can see that 310 crates <em>execute</em> one, then try to deref the pointer. Of those cases, it can only be attributed to a dependency about half of the time, but 112 of those 310 cases can be attributed to <code>bytes</code>. In 124 cases I can't attribute the error to a dependency.</p>



<a name="277424952"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277424952" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ben Kimock (Saethlin) <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277424952">(Apr 01 2022 at 14:18)</a>:</h4>
<p>There's no rocket science here, I'm just doing ctrl+f on the pages I linked</p>



<a name="277424975"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277424975" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277424975">(Apr 01 2022 at 14:19)</a>:</h4>
<p>Oh, that‚Äôs pretty approachable actually</p>



<a name="277425540"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277425540" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ben Kimock (Saethlin) <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277425540">(Apr 01 2022 at 14:23)</a>:</h4>
<p>Miri has some pretty steep biases though, so you should be wary in interpreting these results too much. For example, it's basically useless at assessing platform interface code, which is where Gankra found a lot of squirrely casts in the standard library. There's no reason to believe that we can extrapolate from the crates where we do have results to the crates where we don't.</p>



<a name="277430636"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277430636" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277430636">(Apr 01 2022 at 14:57)</a>:</h4>
<p>Yeah, Miri has to be taught what given actually-a-syscall APIs mean.</p>



<a name="277432029"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277432029" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277432029">(Apr 01 2022 at 15:06)</a>:</h4>
<p>And yeah, a lot of crates probably actually get fixed if we can push a patch to one major dependency, since Rust is... er... the language that encapsulates unsafe code in safe abstractions</p>



<a name="277439127"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277439127" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277439127">(Apr 01 2022 at 15:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120827">Ben Kimock (Saethlin)</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277424765">said</a>:</p>
<blockquote>
<p>No, that is not what that means. Miri with <code>-Zmiri-tag-raw-pointers</code> is checking a far stricter model of provenance than the strict-provenance feature.</p>
</blockquote>
<p>I disagree. It seems that under <code>-Zmiri-tag-raw-pointers</code>, some ptr-to-int-to-ptr conversions can still be fine. Whereas with strict provenance, <code>*(ptr as usize as ptr)</code> is always illegal.</p>
<p>So the problem is bigger than it seemed.</p>



<a name="277439313"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277439313" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277439313">(Apr 01 2022 at 15:56)</a>:</h4>
<p>Note that <code>#[feature(strict_provenance)]</code> itself just <em>provides</em> strict provenance operations, it does not <em>enforce</em> strict provenance</p>



<a name="277440193"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277440193" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ben Kimock (Saethlin) <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277440193">(Apr 01 2022 at 16:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277439127">said</a>:</p>
<blockquote>
<p>It seems that under <code>-Zmiri-tag-raw-pointers</code>, some ptr-to-int-to-ptr conversions can still be fine.</p>
</blockquote>
<p>Can you come up with a program that dereferences a pointer from an int-to-ptr cast which passes <code>-Zmiri-tag-raw-pointers</code>?</p>



<a name="277440729"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277440729" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ben Kimock (Saethlin) <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277440729">(Apr 01 2022 at 16:06)</a>:</h4>
<p>I agree that a few patches may have large impact on the ecosystem, but the tail is very long here, and the rate at which major dependencies take patches like this varies massively.</p>



<a name="277440871"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277440871" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277440871">(Apr 01 2022 at 16:06)</a>:</h4>
<p>Doesn't something like <code>*(&amp;42 as *const i8 as usize as *const i8)</code> pass Miri?</p>



<a name="277440889"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277440889" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277440889">(Apr 01 2022 at 16:06)</a>:</h4>
<p>Because that would be UB in strict provenance</p>



<a name="277440984"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277440984" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277440984">(Apr 01 2022 at 16:07)</a>:</h4>
<p>I don't think it passes unless an allocation covering address 42 previously had their address leaked.</p>



<a name="277441062"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277441062" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277441062">(Apr 01 2022 at 16:07)</a>:</h4>
<p>Well, that's what I mean. In strict provenance, it's not possible to (usefully) leak an address.</p>



<a name="277441158"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277441158" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ben Kimock (Saethlin) <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277441158">(Apr 01 2022 at 16:08)</a>:</h4>
<p>That code passes Miri <em>without</em> <code>-Zmiri-tag-raw-pointers</code>. With that flag, you get this:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">error</span>: <span class="nc">Undefined</span><span class="w"> </span><span class="n">Behavior</span>: <span class="nc">attempting</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">read</span><span class="w"> </span><span class="n">access</span><span class="w"> </span><span class="n">using</span><span class="w"> </span><span class="o">&lt;</span><span class="n">untagged</span><span class="o">&gt;</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">alloc954</span><span class="p">[</span><span class="mh">0x0</span><span class="p">],</span><span class="w"> </span><span class="n">but</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">tag</span><span class="w"> </span><span class="n">does</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">exist</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">borrow</span><span class="w"> </span><span class="n">stack</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">location</span><span class="w"></span>
<span class="w"> </span><span class="o">-</span>-&gt; <span class="nc">src</span><span class="o">/</span><span class="n">main</span><span class="p">.</span><span class="n">rs</span>:<span class="mi">3</span>:<span class="mi">18</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w"></span>
<span class="mi">3</span><span class="w"> </span><span class="o">|</span><span class="w">         </span><span class="kd">let</span><span class="w"> </span><span class="n">_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">42</span><span class="k">i8</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="kt">i8</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w">                  </span><span class="o">^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w">                  </span><span class="o">|</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w">                  </span><span class="n">attempting</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">read</span><span class="w"> </span><span class="n">access</span><span class="w"> </span><span class="n">using</span><span class="w"> </span><span class="o">&lt;</span><span class="n">untagged</span><span class="o">&gt;</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">alloc954</span><span class="p">[</span><span class="mh">0x0</span><span class="p">],</span><span class="w"> </span><span class="n">but</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">tag</span><span class="w"> </span><span class="n">does</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">exist</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">borrow</span><span class="w"> </span><span class="n">stack</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">location</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w">                  </span><span class="n">this</span><span class="w"> </span><span class="n">error</span><span class="w"> </span><span class="n">occurs</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">part</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">access</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">alloc954</span><span class="p">[</span><span class="mh">0x0</span><span class="o">..</span><span class="mh">0x1</span><span class="p">]</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w"></span>
</code></pre></div>



<a name="277441202"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277441202" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277441202">(Apr 01 2022 at 16:08)</a>:</h4>
<p>How about if <code>42</code> goes in a variable?</p>



<a name="277441249"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277441249" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ben Kimock (Saethlin) <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277441249">(Apr 01 2022 at 16:09)</a>:</h4>
<p>You should try this out for yourself ;)</p>



<a name="277441448"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277441448" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ben Kimock (Saethlin) <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277441448">(Apr 01 2022 at 16:10)</a>:</h4>
<p><span class="user-mention" data-user-id="133247">@bjorn3</span> Are you thinking of PNVI-ae? I don't think Miri has any particular notion of leaking an address.</p>



<a name="277441464"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277441464" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277441464">(Apr 01 2022 at 16:10)</a>:</h4>
<p><span class="user-mention silent" data-user-id="133247">bjorn3</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277440984">said</a>:</p>
<blockquote>
<p>I don't think it passes unless an allocation covering address 42 previously had their address leaked.</p>
</blockquote>
<p>I missed the <code>&amp;</code>in <code>&amp;42i8</code>. I thought I saw the address 42 being dereferenced and not a pointer to the value 42.</p>



<a name="277442120"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277442120" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277442120">(Apr 01 2022 at 16:15)</a>:</h4>
<p>ah probably I misunderstood <code>-Zmiri-tag-raw-pointers</code></p>



<a name="277442521"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277442521" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277442521">(Apr 01 2022 at 16:18)</a>:</h4>
<p>Nice. Yes, I support your finding</p>



<a name="277445581"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277445581" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277445581">(Apr 01 2022 at 16:40)</a>:</h4>
<p><span class="user-mention" data-user-id="384014">@Patrick Walton</span> Is <code>MIRIFLAGS=-Zmiri-tag-raw-pointers cargo miri run</code> something you can run on your codebase?</p>



<a name="277446005"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277446005" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ben Kimock (Saethlin) <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277446005">(Apr 01 2022 at 16:43)</a>:</h4>
<p>If we just want to locate int-ptr casts I'm sure there is a more effective way than running Miri</p>



<a name="277446148"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277446148" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277446148">(Apr 01 2022 at 16:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="256342">bstrie</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277398243">said</a>:</p>
<blockquote>
<p>But if fundamentally Rust doesn't <em>work</em>, then frankly I don't care if it gets adopted, and if we can't write down the rules of unsafe code then arguably Rust does not work.</p>
</blockquote>
<p>I don't understand this at all. Rust empirically does work! It massively reduces memory safety problems in the wild.</p>



<a name="277446511"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277446511" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277446511">(Apr 01 2022 at 16:47)</a>:</h4>
<p>Rust's unsafe code semantics are currently inconsistent (as they're based on LLVM's, which are likewise inconsistent), but that doesn't mean Rust doesn't "work". That would imply that nobody should care if Rust as of today gets adopted, because we haven't fixed the problem yet.</p>



<a name="277447025"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277447025" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277447025">(Apr 01 2022 at 16:51)</a>:</h4>
<p><span class="user-mention silent" data-user-id="256342">bstrie</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277413063">said</a>:</p>
<blockquote>
<p>I don't feel good about redefining the operations. As soon as possible, provide a comprehensive set of fixed and stable alternatives, then deprecate the casts. Propose removing the casts in the 2024 edition. But let them continue to operate as they currently do, and if at all possible let them "infect" a codebase with the current underspecified model, even if it means pessimizing certain optimizations for the entire crate graph; avoid the UB outcome.</p>
</blockquote>
<p>I'd be fine with this idea.</p>



<a name="277447506"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277447506" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277447506">(Apr 01 2022 at 16:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="384014">Patrick Walton</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277446148">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="256342">bstrie</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277398243">said</a>:<br>
I don't understand this at all. Rust empirically does work! It massively reduces memory safety problems in the wild.</p>
</blockquote>
<ol>
<li>
<p>It's a hypothetical. No need to be alarmed.</p>
</li>
<li>
<p>People's definitions of "works" vary. I think industry's definition of "works" is often a lot looser than the definition for people who want to keep improving a language. Some people would say that <code>std::mem::uninitialized</code> "works" (under <code>-O0</code>), but we still got rid of it</p>
</li>
</ol>



<a name="277447621"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277447621" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277447621">(Apr 01 2022 at 16:55)</a>:</h4>
<p>Personally I'm in the camp that thinks <code>std::mem::uninitialized</code> didn't work</p>



<a name="277447804"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277447804" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277447804">(Apr 01 2022 at 16:56)</a>:</h4>
<p>And I think future optimizations were more important than keeping the Rust 1 "guarantee" working for <code>std::mem::uninitialized</code></p>



<a name="277447856"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277447856" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277447856">(Apr 01 2022 at 16:56)</a>:</h4>
<p>To be clear, I'm not proposing compromising memory safety. It would be painful to lose optimizations that LLVM can currently do based on unsound provenance, by adopting something like PNVI-ae-udi without strict aliasing, but if that's what we have to do to remain memory safe then so be it</p>



<a name="277449194"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277449194" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277449194">(Apr 01 2022 at 17:06)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120827">Ben Kimock (Saethlin)</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277446005">said</a>:</p>
<blockquote>
<p>If we just want to locate int-ptr casts I'm sure there is a more effective way than running Miri</p>
</blockquote>
<p>Good point, we could just make a trivial lint against that syntax and run <code>crater</code> with that lint forbidden</p>



<a name="277449272"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277449272" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277449272">(Apr 01 2022 at 17:07)</a>:</h4>
<p>I looked through our internal code for usize-to-pointer casts just now and there are a lot of them.</p>



<a name="277449540"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277449540" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277449540">(Apr 01 2022 at 17:09)</a>:</h4>
<p>One issue I realized is that it's not just how many there are: it's how hard they are to update. Looking through the strict-provenance APIs, it doesn't seem to be possible to adopt a very localized fix in the same way <code>mem::uninitialized</code> was. You have to know the domain of the program to figure out where provenance comes from, and in the worst case even store the provenance in some kind of data structure so you can use the <code>with_</code> APIs.</p>



<a name="277450084"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277450084" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277450084">(Apr 01 2022 at 17:13)</a>:</h4>
<p>Thanks! That's important data</p>



<a name="277450109"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277450109" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277450109">(Apr 01 2022 at 17:13)</a>:</h4>
<p>It might be helpful to look at <span class="user-mention silent" data-user-id="137587">Gankra</span> 's std update PR. My understanding is that most of the updates were local-ish, but you do need to have some understanding of what is going on in the bit of code you are modifying, it's not totally automatic</p>



<a name="277450121"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277450121" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277450121">(Apr 01 2022 at 17:13)</a>:</h4>
<p>I think the "normal" fix would be to replace the integer type with either a pointer or a union of pointer/integer, but obv. I can't tell how easy/applicable that would be in these contexts. This is also assuming that these casted pointers are actually later dereferenced - if not then nothing really needs to change.</p>



<a name="277450318"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277450318" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277450318">(Apr 01 2022 at 17:15)</a>:</h4>
<p>This sounds like <code>PVI</code> (the opposite of <code>PNVI</code>). My understanding is nobody thinks it can really work in practice</p>



<a name="277450381"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277450381" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277450381">(Apr 01 2022 at 17:15)</a>:</h4>
<p>In large organizations you can have the teams that are responsible for upgrading the compiler, and keeping code running with newer versions, be at some distance from the actual teams maintaining the code.</p>



<a name="277450416"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277450416" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277450416">(Apr 01 2022 at 17:15)</a>:</h4>
<p>I think Aria said that 80% of uses were only ptr2int with no need for a roundtrip</p>



<a name="277450484"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277450484" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277450484">(Apr 01 2022 at 17:16)</a>:</h4>
<p>In the worst case the teams maintaining the code might not even exist anymore‚Ä¶</p>



<a name="277450582"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277450582" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277450582">(Apr 01 2022 at 17:16)</a>:</h4>
<p>the fact that all of std was converted (or at least triaged) in a few days gives me hope that this can be scaled up, but I don't know your code of course</p>



<a name="277450644"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277450644" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277450644">(Apr 01 2022 at 17:17)</a>:</h4>
<p>well that was for strict provenance - a weaker provenance model should require fewer changes</p>



<a name="277450673"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277450673" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277450673">(Apr 01 2022 at 17:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="384014">Patrick Walton</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277449540">said</a>:</p>
<blockquote>
<p>One issue I realized is that it's not just how many there are: it's how hard they are to update.</p>
</blockquote>
<p>Also</p>
<ul>
<li>not every Rust programmer is able to tackle this kind of work</li>
<li>something like pointer compression can't really work with strict-only provenance (but I <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277358112">repeat myself</a>)</li>
</ul>



<a name="277450849"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277450849" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277450849">(Apr 01 2022 at 17:18)</a>:</h4>
<p>there is a cop-out in strict-only provenance where everything points into one arena. This is how CHERI supports code that can't conform to the capability rules</p>



<a name="277450854"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277450854" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277450854">(Apr 01 2022 at 17:18)</a>:</h4>
<p>I echo Patrick that this is very application-dependent, this may not realistically be feasible for some applications. Like something big and hairy like Firefox.</p>



<a name="277450874"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277450874" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277450874">(Apr 01 2022 at 17:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="295632">Diggsey</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277450644">said</a>:</p>
<blockquote>
<p>well that was for strict provenance - a weaker provenance model should require fewer changes</p>
</blockquote>
<p>Just to be clear, I'm <em>very</em> open to some sort of weaker provenance model that requires few changes. I don't want to sound like I'm opposed to all progress :)</p>



<a name="277450915"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277450915" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277450915">(Apr 01 2022 at 17:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="271719">Mario Carneiro</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277450849">said</a>:</p>
<blockquote>
<p>there is a cop-out in strict-only provenance where everything points into one arena. This is how CHERI supports code that can't conform to the capability rules</p>
</blockquote>
<p>Making this easy to use would go a long way toward making it easy to update code.</p>



<a name="277451136"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277451136" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277451136">(Apr 01 2022 at 17:21)</a>:</h4>
<p>The view <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277358112">in my summary</a> indeed proposes translating the existing primitives to horribly-slow-but-working code for CHERI</p>



<a name="277451152"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277451152" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277451152">(Apr 01 2022 at 17:21)</a>:</h4>
<p>I don't know how that would work for rust, but I believe CHERI has something like this already that allows them to basically plug and play old stuff. But I am no expert on CHERI</p>



<a name="277451187"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277451187" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277451187">(Apr 01 2022 at 17:21)</a>:</h4>
<p>My understanding is it's something that would live in the language runtime</p>



<a name="277451252"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277451252" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277451252">(Apr 01 2022 at 17:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="384014">Patrick Walton</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277450915">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="271719">Mario Carneiro</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277450849">said</a>:</p>
<blockquote>
<p>there is a cop-out in strict-only provenance where everything points into one arena. This is how CHERI supports code that can't conform to the capability rules</p>
</blockquote>
<p>Making this easy to use would go a long way toward making it easy to update code.</p>
</blockquote>
<p>oh okay.</p>



<a name="277451255"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277451255" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277451255">(Apr 01 2022 at 17:22)</a>:</h4>
<p><span class="user-mention" data-user-id="465167">@Bram Geron</span> I'm pretty sure the horribly-slow option is actually unviable (not just slow but actually impossible)</p>



<a name="277451278"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277451278" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277451278">(Apr 01 2022 at 17:22)</a>:</h4>
<p>Why?</p>



<a name="277451304"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277451304" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277451304">(Apr 01 2022 at 17:22)</a>:</h4>
<p>so you're saying your price is std::arena, then.</p>



<a name="277451318"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277451318" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277451318">(Apr 01 2022 at 17:22)</a>:</h4>
<p>can do.</p>



<a name="277451332"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277451332" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277451332">(Apr 01 2022 at 17:22)</a>:</h4>
<p>it was brought up <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277361400">in that thread</a>, it requires you to execute with angelic nondeterminism</p>



<a name="277451352"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277451352" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277451352">(Apr 01 2022 at 17:23)</a>:</h4>
<p>It sounds like we can approach this from both sides:</p>
<ul>
<li>have everything disallowed by the weaker provenance model be "definitely unsupported"</li>
<li>have everything allowed by strict provenance be "definitely supported"<br>
And then try to keep everything in the middle (that previously worked) working (at least for the foreseeable future)</li>
</ul>



<a name="277451596"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277451596" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277451596">(Apr 01 2022 at 17:24)</a>:</h4>
<p>I would like to move from "break&amp;fix the ecosystem" to "probably we don't have to break anything in the ecosystem"</p>



<a name="277451659"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277451659" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277451659">(Apr 01 2022 at 17:25)</a>:</h4>
<p>I don't think it's necessary to make old code work on CHERI without changes</p>



<a name="277451680"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277451680" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277451680">(Apr 01 2022 at 17:25)</a>:</h4>
<p>unless it's safe code</p>



<a name="277451706"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277451706" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277451706">(Apr 01 2022 at 17:25)</a>:</h4>
<p>and even then some changes may be ok</p>



<a name="277451943"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277451943" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277451943">(Apr 01 2022 at 17:27)</a>:</h4>
<p>oh lol I just realized that's the same thread as this one. keeping up with these threads is becoming a full time job</p>



<a name="277452079"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277452079" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277452079">(Apr 01 2022 at 17:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="295632">Diggsey</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277451659">said</a>:</p>
<blockquote>
<p>I don't think it's necessary to make old code work on CHERI without changes</p>
</blockquote>
<p>I think it's _really preferable_, otherwise either (1) we don't support CHERI fully, or (2) we're dealing with a language fork / compiler option</p>



<a name="277452139"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277452139" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277452139">(Apr 01 2022 at 17:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="295632">Diggsey</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277451706">said</a>:</p>
<blockquote>
<p>and even then some changes may be ok</p>
</blockquote>
<p>For safe code, doesn't that violate the Rust 1.0 compatibility promise?</p>



<a name="277452179"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277452179" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277452179">(Apr 01 2022 at 17:28)</a>:</h4>
<p>not if there is no old code running on cheri</p>



<a name="277452194"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277452194" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277452194">(Apr 01 2022 at 17:29)</a>:</h4>
<p>yeah it's a new platform</p>



<a name="277452196"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277452196" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277452196">(Apr 01 2022 at 17:29)</a>:</h4>
<p>There is no "if needed to work on CHERI" exception to the Rust 1.0 compatibility promise.</p>



<a name="277452222"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277452222" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277452222">(Apr 01 2022 at 17:29)</a>:</h4>
<p>That's fair.</p>



<a name="277452227"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277452227" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277452227">(Apr 01 2022 at 17:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="281757">Jubilee</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277451304">said</a>:</p>
<blockquote>
<p>so you're saying your price is std::arena, then.</p>
</blockquote>
<p>I think it can be a lot better ‚Äî only pointers have to be tracked that had their address exposed with <code>ptr as usize</code>.  Not your average <code>Box</code>.</p>



<a name="277452254"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277452254" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277452254">(Apr 01 2022 at 17:29)</a>:</h4>
<p>right the spirit of the promise is to not break existing code</p>



<a name="277452387"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277452387" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277452387">(Apr 01 2022 at 17:30)</a>:</h4>
<p>And ideally we don't have to fork <code>split</code> into a part that works everywhere and a part that doesn't work on CHERI</p>



<a name="277452391"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277452391" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277452391">(Apr 01 2022 at 17:30)</a>:</h4>
<p>That does mean that we won't be able to do optimizations that assume that code is "CHERI-clean".</p>



<a name="277452430"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277452430" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277452430">(Apr 01 2022 at 17:30)</a>:</h4>
<p>right, that would require some kind of split</p>



<a name="277452496"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277452496" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277452496">(Apr 01 2022 at 17:30)</a>:</h4>
<p>I don't think those optimizations are likely to ever happen though</p>



<a name="277452555"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277452555" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277452555">(Apr 01 2022 at 17:31)</a>:</h4>
<p>I don't really agree with that tbh...</p>



<a name="277452563"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277452563" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277452563">(Apr 01 2022 at 17:31)</a>:</h4>
<p>even if all rust code went full strict-provenance there is still FFI to consider</p>



<a name="277452584"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277452584" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277452584">(Apr 01 2022 at 17:31)</a>:</h4>
<p>but I don't think it's a question we need to answer yet</p>



<a name="277452743"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277452743" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277452743">(Apr 01 2022 at 17:32)</a>:</h4>
<p>maybe we can do the optimizations in restricted circumstances but anything involving "unknown functions" will have to be pessimistic regarding strictness</p>



<a name="277452882"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277452882" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277452882">(Apr 01 2022 at 17:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="271719">Mario Carneiro</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277451332">said</a>:</p>
<blockquote>
<p>it was brought up <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277361400">in that thread</a>, it requires you to execute with angelic nondeterminism</p>
</blockquote>
<p>Interesting, thanks. If I understand correctly, the conflict is that we can't decide if we need the read-only CHERI ptr for a big chunk of memory, or the read-write ptr for less memory.</p>
<p>We still have multiple pathways. We could support CHERI but not support read-only pointers. That would get rid of the conflict.</p>



<a name="277452886"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277452886" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277452886">(Apr 01 2022 at 17:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="271719">Mario Carneiro</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277452743">said</a>:</p>
<blockquote>
<p>maybe we can do the optimizations in restricted circumstances but anything involving "unknown functions" will have to be pessimistic regarding strictness</p>
</blockquote>
<p>Yeah, as I mentioned yesterday this could be a model for interactions between non-strict-provenance Rust functions and strict-provenance Rust functions</p>



<a name="277453026"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277453026" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277453026">(Apr 01 2022 at 17:34)</a>:</h4>
<p>I guess there's always the possibility that we do strict-provenance-based optimizations only on CHERI architectures and leave x86-64 and current ARM/AArch64 alone.</p>



<a name="277453047"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277453047" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277453047">(Apr 01 2022 at 17:34)</a>:</h4>
<p>I don't think anyone loves that possibility, but it is an option.</p>



<a name="277453083"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277453083" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277453083">(Apr 01 2022 at 17:35)</a>:</h4>
<p><span class="user-mention" data-user-id="465167">@Bram Geron</span> It's more than that. You can have a whole collection of mutually incomparable valid provenances to access a given location, and no obvious way to pick between them but potential spurious UB later if you pick the wrong one</p>



<a name="277453122"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277453122" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277453122">(Apr 01 2022 at 17:35)</a>:</h4>
<p><span class="user-mention" data-user-id="465167">@Bram Geron</span> no, it's not to do with whether it's read/write that's just an example. Your solution requires on being able to map an address to a single provenance value, and that is in general impossible, since there may be multiple possible provenances for a given address</p>



<a name="277453247"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277453247" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277453247">(Apr 01 2022 at 17:36)</a>:</h4>
<p>and there isn't a subset/superset relationship on provenances that would allow you to just pick the "most general" one</p>



<a name="277453281"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277453281" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277453281">(Apr 01 2022 at 17:36)</a>:</h4>
<p>What could be a conflicting pair?</p>



<a name="277453284"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277453284" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277453284">(Apr 01 2022 at 17:36)</a>:</h4>
<p>at best you can make it so that all pointers have the same provenance, and can read/write anywhere in the exposed address space</p>



<a name="277453513"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277453513" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277453513">(Apr 01 2022 at 17:38)</a>:</h4>
<p>We could also do something horrible on CHERI like make <code>usize as ptr</code> do <code>std::ptr::invalid</code>, and resolve when casting to a reference or when using <code>std::ptr::{read,write}</code></p>



<a name="277453554"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277453554" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277453554">(Apr 01 2022 at 17:38)</a>:</h4>
<p>well, you could have two provenances for address 0x10 that either allow writing to 0x10-0x20 or 0x20-0x30</p>



<a name="277453692"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277453692" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277453692">(Apr 01 2022 at 17:39)</a>:</h4>
<p>I guess you could have one for <code>0x10-0x30</code> and one for <code>0x20-0x40</code>, then <code>0x25</code> is ambiguous so the obvious solution doesn't work indeed</p>



<a name="277453693"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277453693" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277453693">(Apr 01 2022 at 17:39)</a>:</h4>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">ref1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">2</span><span class="p">];</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">ref2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">];</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">ref1</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">]</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="kt">u8</span><span class="p">).</span><span class="n">wrapping_add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">ref2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">]</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="kt">u8</span><span class="p">);</span><span class="w"></span>
<span class="p">(</span><span class="n">p1</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span><span class="w"></span>
</code></pre></div>
<p><code>p1</code> and <code>p2</code> have equal value, and if they are exposed then a matching int2ptr could match with either one</p>



<a name="277453778"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277453778" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277453778">(Apr 01 2022 at 17:40)</a>:</h4>
<p>To be honest I don't have any objections to even extreme breakage of existing code on CHERI architectures. My compatibility concerns are about existing architectures only.</p>



<a name="277453807"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277453807" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277453807">(Apr 01 2022 at 17:40)</a>:</h4>
<p>well you can't have breakage if there's no existing code</p>



<a name="277453819"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277453819" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277453819">(Apr 01 2022 at 17:40)</a>:</h4>
<p>Right. :)</p>



<a name="277453830"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277453830" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277453830">(Apr 01 2022 at 17:40)</a>:</h4>
<p>By the way, wouldn't CHERI support merging <code>ref1</code> with <code>ref2</code>?</p>



<a name="277453844"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277453844" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277453844">(Apr 01 2022 at 17:41)</a>:</h4>
<p>no</p>



<a name="277453877"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277453877" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277453877">(Apr 01 2022 at 17:41)</a>:</h4>
<p>those operations actually decrease the capability</p>



<a name="277453902"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277453902" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277453902">(Apr 01 2022 at 17:41)</a>:</h4>
<p><code>ref1</code> only has access to <code>[1, 2]</code></p>



<a name="277453943"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277453943" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277453943">(Apr 01 2022 at 17:41)</a>:</h4>
<p>on CHERI you can only reduce the accessible area</p>



<a name="277453953"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277453953" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277453953">(Apr 01 2022 at 17:41)</a>:</h4>
<p>you can't make it bigger</p>



<a name="277454001"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277454001" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277454001">(Apr 01 2022 at 17:42)</a>:</h4>
<p>in stacked borrows it is <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/256">still under discussion</a> whether this behavior is desirable, but in cheri it's a fact</p>



<a name="277454098"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277454098" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277454098">(Apr 01 2022 at 17:42)</a>:</h4>
<p>so, either you defer mapping until you actually need to read/write the memory (which would make <em>all</em> code prohibitively slow) or you do the arena approach</p>



<a name="277454590"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277454590" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277454590">(Apr 01 2022 at 17:46)</a>:</h4>
<p>I think you're right.</p>
<p>A third option may be to make <code>ptr</code> contain _two_ machine pointers, one "current" one and one "maximal" one which represents the whole allocation. Then still only "permissively exposed" <code>ptr</code>s need to be tracked.</p>



<a name="277454594"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277454594" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277454594">(Apr 01 2022 at 17:46)</a>:</h4>
<p>Anyway, I'm not sure why strict-provenance optimizations keep getting brought up since they are not in the current proposal and I don't think there has even been any design work on such optimizations</p>



<a name="277454697"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277454697" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277454697">(Apr 01 2022 at 17:47)</a>:</h4>
<p>Yeah, half of the point is to be able to just lay the groundwork for making code that is truly coherent under any sane model.<br>
Sorry, but even in the most permissive case, <code>ptr as usize</code> is a sketch operation.</p>



<a name="277454763"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277454763" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277454763">(Apr 01 2022 at 17:48)</a>:</h4>
<p>I think because the original proposal didn't want to exclude any options on principle. IMO it's how <a href="https://github.com/rust-lang/rust/issues/95228">https://github.com/rust-lang/rust/issues/95228</a> was formulated, a bit aggressively</p>



<a name="277454825"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277454825" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277454825">(Apr 01 2022 at 17:48)</a>:</h4>
<p>for now it's just a bunch of "say what you mean" library APIs, which can only be a good thing. Maybe someday when these percolate we will be in a better position to propose optimizations, but we can't deprecate a thing until we have an alternative</p>



<a name="277454853"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277454853" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277454853">(Apr 01 2022 at 17:49)</a>:</h4>
<p><span class="user-mention" data-user-id="281757">@Jubilee</span>, you think we should not support pointer compression in Rust?</p>



<a name="277454911"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277454911" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277454911">(Apr 01 2022 at 17:49)</a>:</h4>
<blockquote>
<p>A third option may</p>
</blockquote>
<p>That is just the arena approach but using more memory for pointers :P You only need to allocate things from the arena if their address is exposed.</p>



<a name="277454976"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277454976" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277454976">(Apr 01 2022 at 17:50)</a>:</h4>
<p>Ah, I thought the arena approach was to keep every live allocation in an arena</p>



<a name="277455047"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277455047" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277455047">(Apr 01 2022 at 17:50)</a>:</h4>
<p><span class="user-mention" data-user-id="465167">@Bram Geron</span> I mean that "as" is a pretty sketch operation.</p>



<a name="277455083"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277455083" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277455083">(Apr 01 2022 at 17:50)</a>:</h4>
<p>Ah, I agree</p>



<a name="277455136"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277455136" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277455136">(Apr 01 2022 at 17:50)</a>:</h4>
<p><code>ptr.addr()</code> says the correct thing, which is basically<br>
<code>ptr.get(addr)</code></p>



<a name="277455164"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277455164" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277455164">(Apr 01 2022 at 17:51)</a>:</h4>
<p>I think 100% the _syntax_ <code>ptr as usize</code> and <code>usize as ptr</code> will be deprecated in a version, and we should use a different spelling</p>



<a name="277455170"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277455170" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277455170">(Apr 01 2022 at 17:51)</a>:</h4>
<p>people don't think of pointers as containers but they really basically are.</p>



<a name="277455188"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277455188" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277455188">(Apr 01 2022 at 17:51)</a>:</h4>
<p>Maybe the spelling should be <code>ptr.addr_permissive()</code></p>



<a name="277455252"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277455252" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277455252">(Apr 01 2022 at 17:51)</a>:</h4>
<p>eh.</p>



<a name="277455259"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277455259" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277455259">(Apr 01 2022 at 17:51)</a>:</h4>
<p>I don't really see the problem with pointer compression under any model. In pointer compression you are storing an offset (ie. an integer) instead of a pointer. You just need to make sure that the provenance on your "base" pointer has access to the whole space.</p>



<a name="277455287"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277455287" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277455287">(Apr 01 2022 at 17:51)</a>:</h4>
<p>Yeah.</p>



<a name="277455397"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277455397" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277455397">(Apr 01 2022 at 17:52)</a>:</h4>
<p>regarding the bikeshed on that one, I thought about <code>ptr.expose{_addr}()</code> or <code>ptr.broadcast{_addr}()</code></p>



<a name="277455530"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277455530" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277455530">(Apr 01 2022 at 17:53)</a>:</h4>
<p><code>expose</code> is probably better since it matches PVNI-a<strong>e</strong> terminology</p>



<a name="277455573"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277455573" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277455573">(Apr 01 2022 at 17:53)</a>:</h4>
<p>but it's jargon no matter how you slice it</p>



<a name="277455936"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277455936" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277455936">(Apr 01 2022 at 17:56)</a>:</h4>
<p>I guess I mean the model of pointer compression where you don't keep a magic base pointer. Minimal-overhead pointer compression.</p>



<a name="277455985"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277455985" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277455985">(Apr 01 2022 at 17:56)</a>:</h4>
<p>Perhaps everyone uses a base pointer in practice</p>



<a name="277456012"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277456012" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277456012">(Apr 01 2022 at 17:57)</a>:</h4>
<p>the magic base pointer doesn't cause any storage overhead, it's a global resource</p>



<a name="277456024"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277456024" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277456024">(Apr 01 2022 at 17:57)</a>:</h4>
<p>I don't know what it would mean to not have a base pointer?</p>



<a name="277456076"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277456076" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277456076">(Apr 01 2022 at 17:57)</a>:</h4>
<p>Basically <code>*((compressed_ptr &lt;&lt; 3) as *T)</code> for reading</p>



<a name="277456103"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277456103" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277456103">(Apr 01 2022 at 17:57)</a>:</h4>
<p>besides, 99% of the time the compression savings come from <em>having</em> a base pointer, since all your pointers are close to each other on the heap</p>



<a name="277456201"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277456201" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277456201">(Apr 01 2022 at 17:58)</a>:</h4>
<p>what type is <code>compressed_ptr</code> htere?</p>



<a name="277456217"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277456217" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277456217">(Apr 01 2022 at 17:58)</a>:</h4>
<p>u32</p>



<a name="277456285"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277456285" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277456285">(Apr 01 2022 at 17:58)</a>:</h4>
<p>And it only works if you can decide which part of the address space is allocated</p>



<a name="277456325"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277456325" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277456325">(Apr 01 2022 at 17:59)</a>:</h4>
<p>Ok, so you are assuming that your whole address space is 0...32GB?</p>



<a name="277456333"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277456333" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277456333">(Apr 01 2022 at 17:59)</a>:</h4>
<p>Yep</p>



<a name="277456373"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277456373" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277456373">(Apr 01 2022 at 17:59)</a>:</h4>
<p>(Maybe nobody does it like this in practice. But it seems <em>slightly</em> more efficient than having a base pointer)</p>



<a name="277456674"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277456674" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277456674">(Apr 01 2022 at 18:00)</a>:</h4>
<p>In that case I think it is possible for current or near future apis to store the provenance in the compressed pointer itself</p>



<a name="277456775"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277456775" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277456775">(Apr 01 2022 at 18:01)</a>:</h4>
<p>yeah on non-CHERI it can still work fine, but you'd need a 32-bit type with provenance</p>



<a name="277456781"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277456781" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277456781">(Apr 01 2022 at 18:01)</a>:</h4>
<p>You think integers with provenance can work, Mario?</p>



<a name="277456891"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277456891" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277456891">(Apr 01 2022 at 18:02)</a>:</h4>
<p>My understanding is it'd horrible to optimize</p>



<a name="277456938"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277456938" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277456938">(Apr 01 2022 at 18:02)</a>:</h4>
<p>you can store anything in <code>MaybeUninit</code>, the only thing that is missing is a function to smash provenance into a smaller box</p>



<a name="277456956"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277456956" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277456956">(Apr 01 2022 at 18:02)</a>:</h4>
<p>yeah you'd need a special type - in <span class="user-mention" data-user-id="120791">@RalfJ</span> 's current model I believe each byte has it's own provenance, so that wouldn't be an issue</p>



<a name="277457103"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277457103" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277457103">(Apr 01 2022 at 18:03)</a>:</h4>
<p>but it's a bit academic unless you're aware of this actually being used in practice - I don't think most programs have this level of control over their address space</p>



<a name="277457197"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277457197" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277457197">(Apr 01 2022 at 18:04)</a>:</h4>
<p>see <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance/near/276733244">https://rust-lang.zulipchat.com/#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance/near/276733244</a></p>



<a name="277457333"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277457333" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277457333">(Apr 01 2022 at 18:05)</a>:</h4>
<p>on CHERI this wouldn't work without just using an arena, since the area a pointer can access needs to be sufficiently "near" to its address AIUI</p>



<a name="277457400"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277457400" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277457400">(Apr 01 2022 at 18:06)</a>:</h4>
<p>You could go even more nuts with this and have a function <code>fn pair(Provenance, Provenance) -&gt; Provenance</code> where <code>Provenance</code> is a one byte type, so that you can construct hyper-pointers with arbitrarily many provenances in a single byte</p>



<a name="277457607"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277457607" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277457607">(Apr 01 2022 at 18:07)</a>:</h4>
<p>but at that point you are just literally programming the AM, the code will look extremely weird for a regular machine</p>



<a name="277457697"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277457697" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277457697">(Apr 01 2022 at 18:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="295632">Diggsey</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277457103">said</a>:</p>
<blockquote>
<p>but it's a bit academic unless you're aware of this actually being used in practice - I don't think most programs have this level of control over their address space</p>
</blockquote>
<p>Looks like <a href="https://users.rust-lang.org/t/32-bit-pointers-to-the-heap/58255/4">https://users.rust-lang.org/t/32-bit-pointers-to-the-heap/58255/4</a> is using this exactly (but without compression)</p>



<a name="277457777"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277457777" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277457777">(Apr 01 2022 at 18:08)</a>:</h4>
<p>Found it via <a class="stream-topic" data-stream-id="136281" href="/#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Use-cases.20for.20unrestricted.20ptr2int2ptr">#t-lang/wg-unsafe-code-guidelines &gt; Use-cases for unrestricted ptr2int2ptr</a> at the top</p>



<a name="277457866"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277457866" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277457866">(Apr 01 2022 at 18:08)</a>:</h4>
<p>yeah, if they're using the "real address", then they just need the special 32-bit type with provenance and everything else should just work fine even on CHERI</p>



<a name="277457902"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277457902" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277457902">(Apr 01 2022 at 18:09)</a>:</h4>
<p>ok, maybe not CHERI actually since you can't make pointers shorter</p>



<a name="277457914"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277457914" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277457914">(Apr 01 2022 at 18:09)</a>:</h4>
<p>for what it's worth, CHERI 32-bit exists</p>



<a name="277457924"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277457924" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277457924">(Apr 01 2022 at 18:09)</a>:</h4>
<blockquote>
<p>It seems to work so far.</p>
</blockquote>
<p>It's the C national anthem</p>



<a name="277457952"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277457952" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277457952">(Apr 01 2022 at 18:09)</a>:</h4>
<p>or rather, CHERI with a compression to 64, thus a 32-bit address space.</p>



<a name="277458002"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277458002" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277458002">(Apr 01 2022 at 18:09)</a>:</h4>
<p>Can we fork pointer compression into its own thread, though?</p>



<a name="277458003"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277458003" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277458003">(Apr 01 2022 at 18:09)</a>:</h4>
<p>right, but then you're just using normal pointers :P</p>



<a name="277458109"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277458109" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277458109">(Apr 01 2022 at 18:10)</a>:</h4>
<p>sure but maybe CHERI would support compressed caps on aarch64? idk.</p>



<a name="277458136"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277458136" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277458136">(Apr 01 2022 at 18:10)</a>:</h4>
<p>I only brought up pointer compression to argue that we shouldn't lose permissive provenance</p>



<a name="277458210"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277458210" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277458210">(Apr 01 2022 at 18:11)</a>:</h4>
<p>(as per <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277358112">my standpoint/summary</a>)</p>



<a name="277458219"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277458219" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277458219">(Apr 01 2022 at 18:11)</a>:</h4>
<p>I wasn't aware programs actually could control their address space enough to use 32 bits without an "origin pointer"</p>



<a name="277458418"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277458418" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277458418">(Apr 01 2022 at 18:12)</a>:</h4>
<p>I think this makes a lot of sense on e.g. microcontrollers where there's only 1 program, but only a small part of the address space is used</p>



<a name="277458458"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277458458" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277458458">(Apr 01 2022 at 18:12)</a>:</h4>
<p>Note that ARM's implementation of CHERI does have a 'default data capability' for backwards compatibility with existing ARM code.</p>



<a name="277458486"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277458486" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277458486">(Apr 01 2022 at 18:13)</a>:</h4>
<p>yeah.</p>



<a name="277458517"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277458517" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277458517">(Apr 01 2022 at 18:13)</a>:</h4>
<p>that's what we've been alluding to as "basically an arena"</p>



<a name="277458579"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277458579" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277458579">(Apr 01 2022 at 18:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277458418">said</a>:</p>
<blockquote>
<p>I think this makes a lot of sense on e.g. microcontrollers where there's only 1 program, but only a small part of the address space is used</p>
</blockquote>
<p>well you get a lot more permission re: provenance if you are also the allocator</p>



<a name="277458603"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277458603" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277458603">(Apr 01 2022 at 18:13)</a>:</h4>
<p>It seems there are multiple viable uses of the word "arena" for CHERI</p>



<a name="277458674"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277458674" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277458674">(Apr 01 2022 at 18:14)</a>:</h4>
<p>ish.</p>



<a name="277458743"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277458743" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277458743">(Apr 01 2022 at 18:14)</a>:</h4>
<p>the DDC lets you use "normal" load/store within the bounds of the DDC.</p>



<a name="277458751"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277458751" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277458751">(Apr 01 2022 at 18:14)</a>:</h4>
<p>Hmyeah the "default data capability" is a pretty sweet concept</p>



<a name="277458832"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277458832" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277458832">(Apr 01 2022 at 18:15)</a>:</h4>
<p>But I can also imagine that automotive wants something safer than that</p>



<a name="277458869"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277458869" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277458869">(Apr 01 2022 at 18:15)</a>:</h4>
<p>Right, you can typically just use pure capabilities.</p>



<a name="277458883"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277458883" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277458883">(Apr 01 2022 at 18:15)</a>:</h4>
<p>(the "TreeMap" approach where you only expose individual allocations)</p>



<a name="277458951"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277458951" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Alexander Richardson <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277458951">(Apr 01 2022 at 18:16)</a>:</h4>
<p>If you want to use "global" pointer compression with CHERI you'll have to rely on DDC. But I would assume that you'd generally have a base region (e.g. the JavaScript heap)</p>



<a name="277459048"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277459048" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Alexander Richardson <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277459048">(Apr 01 2022 at 18:17)</a>:</h4>
<p>TreeMap breaks security properties though and you can't guess which element is correct.</p>



<a name="277459116"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277459116" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brooks Davis <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277459116">(Apr 01 2022 at 18:17)</a>:</h4>
<p>FWIW  for CHERI C, our philosophy is roughly:</p>
<ul>
<li>Most code should Just Work<span aria-label="tm" class="emoji emoji-2122" role="img" title="tm">:tm:</span> (this is true to a somewhat shocking degree)</li>
<li>Most required modifications should be about clarifying the programmer's intent so provenance can be preserved (hence <code>__builtin_align_down()</code> and <code>ptraddr_t</code>) or removing incorrect assumptions (<code>sizeof size_t == size_of void *</code>)</li>
<li>It should be possible for programmers without access to CHERI to write code that works on CHERI (perhaps with the aid of warnings and static analysis)</li>
<li>We're ok with a few idioms breaking completely (e.g., XOR linked lists, round tripping pointers though <code>printf</code>/<code>scanf</code>)<br>
One the whole we want to transition to pure-capability code is be no worse that 32-bit -&gt; 64-bit. Ideally we'll make it better.</li>
</ul>



<a name="277459541"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277459541" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277459541">(Apr 01 2022 at 18:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="473929">Alexander Richardson</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277459048">said</a>:</p>
<blockquote>
<p>TreeMap breaks security properties though and you can't guess which element is correct.</p>
</blockquote>
<p>I don't necessarily agree (yet), but we're also veering from the topic. I think we agree that we want to keep supporting permissive provenance, also on CHERI.</p>



<a name="277459764"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277459764" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Alexander Richardson <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277459764">(Apr 01 2022 at 18:21)</a>:</h4>
<p>I'd be happier with just disabling the permissive casts for CHERI. There isn't really a sane way of implementing them safely.</p>



<a name="277459890"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277459890" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277459890">(Apr 01 2022 at 18:22)</a>:</h4>
<p>This would fork the language</p>



<a name="277459969"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277459969" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277459969">(Apr 01 2022 at 18:23)</a>:</h4>
<p>I think it's better as an (allow-by-default) lint</p>



<a name="277460238"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277460238" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277460238">(Apr 01 2022 at 18:24)</a>:</h4>
<p>I would like there to be Rust, not Normal Rust vs. CHERI Rust</p>



<a name="277460310"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277460310" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277460310">(Apr 01 2022 at 18:25)</a>:</h4>
<p>And I think the ecosystem will move so that only <em>very</em> niche crates will use permissive provenance any more</p>



<a name="277460761"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277460761" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brooks Davis <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277460761">(Apr 01 2022 at 18:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="198590">comex</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277458458">said</a>:</p>
<blockquote>
<p>Note that ARM's implementation of CHERI does have a 'default data capability' for backwards compatibility with existing ARM code.</p>
</blockquote>
<p>The compatibility that comes from DDC is fundamental to the CHERI design. We're quite aware that no one would ever adopt this (at least on general purpose CPUs)  if they had to move 100% of their code to pure-capability CHERI from day one so we aim for complete compatibility with aarch64/riscv64 until you start using capabilities.<br>
On we support two C environments: hybrid C where DDC covers the address space and pointers are integers unless annotated otherwise and pure-capability  (CheriABI) where DDC is NULL and all pointers have strict provenance. In the latter case, initial capabilities come from the kernel via the initial register set and transitively though the ELF auxargs vector to <code>argv</code> and <code>envv</code>. Additional capabilities come from <code>mmap</code> and <code>shmat</code>.</p>



<a name="277460839"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277460839" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277460839">(Apr 01 2022 at 18:29)</a>:</h4>
<p>And the DDC is, in terms of "provenance alone", without recourse to CHERI's physical manifestation of provenance, almost exactly analogous to creating an arena, holding a pointer to it, and then regenerating provenance from it.</p>



<a name="277461011"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277461011" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brooks Davis <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277461011">(Apr 01 2022 at 18:30)</a>:</h4>
<p>Yes, I think there have been some uses to DDC specifically for that purpose in an otherwise pure-capability environment (maybe in the webkit port).</p>



<a name="277461070"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277461070" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277461070">(Apr 01 2022 at 18:31)</a>:</h4>
<p>...you know, we could allow overriding the global allocator in a way that follows that logic.</p>



<a name="277461127"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277461127" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277461127">(Apr 01 2022 at 18:31)</a>:</h4>
<p>Or well, not quite overriding.</p>



<a name="277461315"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277461315" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277461315">(Apr 01 2022 at 18:32)</a>:</h4>
<p>I think there's a big difference.</p>
<ul>
<li>DDC negates the use of strict-provenance casts; there is <del>no</del> hardly any extra CHERI safety</li>
<li>With a big arena pointer <em>outside of DDC</em>, strict-provenance makes a lot of sense. But you could also still use that one weird crate that refuses to update to strict-provenance</li>
</ul>



<a name="277461340"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277461340" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277461340">(Apr 01 2022 at 18:32)</a>:</h4>
<p>Yeah one of the ideas I floated at the start of this was an allocator that was capable of ptr-to-int shenanigans. But that interacts weirdly with provenance so not too sure how fun it is.</p>



<a name="277461606"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277461606" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277461606">(Apr 01 2022 at 18:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277459890">said</a>:</p>
<blockquote>
<p>This would fork the language</p>
</blockquote>
<p>Strict Provenance doesn't fork the language. It's not like we have two incompatible variants here, it's a subset: you can have high standards or low standards and you can freely choose which one you find appropriate. CHERI can only run code with high standards</p>



<a name="277461686"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277461686" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277461686">(Apr 01 2022 at 18:35)</a>:</h4>
<p>We already have plenty of this with e.g. clippy lints and rustfmt</p>



<a name="277461697"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277461697" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277461697">(Apr 01 2022 at 18:35)</a>:</h4>
<p>How is this better than making all code work on CHERI?</p>



<a name="277461744"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277461744" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277461744">(Apr 01 2022 at 18:36)</a>:</h4>
<p>We don't have to use DDC for that.</p>



<a name="277462120"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277462120" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277462120">(Apr 01 2022 at 18:39)</a>:</h4>
<p>"Strict Provenance" has multiple meanings. I'm against the "break the world" interpretation of <a href="https://github.com/rust-lang/rust/issues/95228">https://github.com/rust-lang/rust/issues/95228</a>, but for adding all the benefits as per <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277358112">my standpoint</a> and migrating the ecosystem over voluntarily</p>



<a name="277462189"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277462189" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277462189">(Apr 01 2022 at 18:39)</a>:</h4>
<p>I did not see "break the world" anywhere on that PR</p>



<a name="277462406"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277462406" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277462406">(Apr 01 2022 at 18:41)</a>:</h4>
<p>Nothing was actively broken by that effort.<br>
What was done was something that unfortunately was doomed to get hilarious pushback, <strong>no matter how mildly phrased</strong>, because people catastrophize in response to the very idea.</p>



<a name="277462454"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277462454" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Alexander Richardson <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277462454">(Apr 01 2022 at 18:42)</a>:</h4>
<p>Making the permissive casts an error for Cheri targets would make it extremely easy to find all lines of code that need adjustments at compile time. This is an infinite improvement over C/C++ where we sometimes only notice the problems at runtime.</p>



<a name="277462502"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277462502" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277462502">(Apr 01 2022 at 18:42)</a>:</h4>
<p>strict provenance casts are useful even with DDC, because pointers are still 128 bits (I think) so <code>with_addr</code> is needed to copy the other bits</p>



<a name="277462532"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277462532" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277462532">(Apr 01 2022 at 18:42)</a>:</h4>
<blockquote>
<p>This is an unofficial experiment to see How Bad it would be if Rust had <strong>extremely strict pointer provenance rules that require you to always dynamically preserve provenance information.</strong></p>
</blockquote>
<p>(emphasis mine)</p>
<p>I'm reading this, and I think multiple people are reading this as "we modify the provenance rules to be more strict". It doesn't say "what if we had more operations"</p>



<a name="277462556"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277462556" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277462556">(Apr 01 2022 at 18:42)</a>:</h4>
<p>I realize that.</p>



<a name="277462619"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277462619" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277462619">(Apr 01 2022 at 18:43)</a>:</h4>
<p>I believe the actual process was that they implemented a lint to point out such uses and fixed them</p>



<a name="277462634"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277462634" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277462634">(Apr 01 2022 at 18:43)</a>:</h4>
<p>Correct.</p>



<a name="277462668"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277462668" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277462668">(Apr 01 2022 at 18:44)</a>:</h4>
<p>The original PR included a lint, the API was separated out when it became clear we wanted to carry through with the experiment.</p>



<a name="277462724"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277462724" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277462724">(Apr 01 2022 at 18:44)</a>:</h4>
<p>so it's not "breakage" so much as "warnage"</p>



<a name="277462757"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277462757" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277462757">(Apr 01 2022 at 18:44)</a>:</h4>
<p>and it would probably be allow-by-default in any possible future where this lands, at least for the current edition</p>



<a name="277463065"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277463065" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277463065">(Apr 01 2022 at 18:47)</a>:</h4>
<p>There's no reason to not warn by default for such a lint. If you're using it so much it matters just disable it at the crate level (and code readers will see you disabled the lint and know what's up).</p>



<a name="277463223"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277463223" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277463223">(Apr 01 2022 at 18:49)</a>:</h4>
<p>I realize you may be more new-ish to this conversation, but many programmers who are following the Rust unsafe conversation and are deeply interested in writing correct code, are also aware of the <strong>many</strong> issues with <code>ptr as usize</code> and such, and aware of how... poor it is, as a model. And they really, really want to be able to write code that doesn't have this "well, I GUESS it works" standard underlying it.</p>



<a name="277463269"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277463269" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277463269">(Apr 01 2022 at 18:49)</a>:</h4>
<p>I would put this under future-incompatibility and make it warn by default only after we are committed to deprecating it</p>



<a name="277463346"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277463346" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277463346">(Apr 01 2022 at 18:50)</a>:</h4>
<p>getting this experiment merged in nightly is not such a commitment AFAIK</p>



<a name="277463365"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277463365" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277463365">(Apr 01 2022 at 18:50)</a>:</h4>
<p>this would need an RFC</p>



<a name="277463378"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277463378" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277463378">(Apr 01 2022 at 18:50)</a>:</h4>
<p>But people conflate making new, Actually Sound code possible with Instantly Miscompiling Old Code.</p>



<a name="277463414"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277463414" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277463414">(Apr 01 2022 at 18:51)</a>:</h4>
<p>And then you suddenly have to argue why the current standard isn't good enough.</p>



<a name="277463623"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277463623" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277463623">(Apr 01 2022 at 18:52)</a>:</h4>
<p>And this whole thing started because <span class="user-mention silent" data-user-id="137587">Gankra</span> actually <a href="https://gankra.github.io/blah/fix-rust-pointers/">did that</a></p>



<a name="277463688"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277463688" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277463688">(Apr 01 2022 at 18:53)</a>:</h4>
<p>it's very helpful to have a coherent document to point to to explain these things</p>



<a name="277463920"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277463920" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277463920">(Apr 01 2022 at 18:55)</a>:</h4>
<p>And yes,<br>
it would be nice to be able to use a new, actually sound standard for a few opts!</p>



<a name="277464004"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277464004" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277464004">(Apr 01 2022 at 18:56)</a>:</h4>
<p>And it's exhausting to have people tell you that such must definitely be off the table, when you're thinking about like<br>
Rust 2030<br>
Rust 2060</p>



<a name="277464077"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277464077" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277464077">(Apr 01 2022 at 18:56)</a>:</h4>
<p>Yes, I am thinking about Rust 2060. No joke. Not an exaggeration.</p>



<a name="277464203"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277464203" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277464203">(Apr 01 2022 at 18:57)</a>:</h4>
<p>Not about "when to implement an opt or a lint", but "what should we care about when designing new stuff for Rust?"</p>



<a name="277464676"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277464676" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277464676">(Apr 01 2022 at 19:01)</a>:</h4>
<p>I am thinking about the next 1 billion programmers. Not just Rust programmers, but the ecosystem we can create for everyone else.</p>



<a name="277466599"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277466599" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277466599">(Apr 01 2022 at 19:19)</a>:</h4>
<p>I updated my <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277358112">summary post</a>.</p>
<blockquote>
<p>Clarify the TreeMap/collection approach ("option 1"); add possibility for an arena pointer on CHERI ("option 2"). Additionally, propose aliases for ptr as usize and usize as ptr that don't use the as keyword, and deprecating the spelling with as. Mention the "pointer in u32" use case.</p>
</blockquote>



<a name="277467019"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277467019" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277467019">(Apr 01 2022 at 19:23)</a>:</h4>
<p>And it's important, I think, to note:</p>
<p>People in 2015, back around 1.0, were aware of a lot of the decisions they were about to make were going to make were perhaps... not the best, and these issues were raised. The entire story of why we have <code>usize</code> and <code>isize</code> instead of, say, <code>uptr</code> and <code>iptr</code> is that. A decision was made to do exactly what is happening now: pick a model, indeed, arguably the simplest model, over simplistic, and try to make it happen and carve out an exception in the stability promise <strong>precisely so</strong> for if they got it wrong.</p>
<p>Now the verdict is in.</p>



<a name="277467148"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277467148" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277467148">(Apr 01 2022 at 19:24)</a>:</h4>
<p><span class="user-mention silent" data-user-id="281757">Jubilee</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277464676">said</a>:</p>
<blockquote>
<p>I am thinking about the next 1 billion programmers. Not just Rust programmers, but the ecosystem we can create for everyone else.</p>
</blockquote>
<p>^^ this. And in a similar vein, I would like to point out that for the purpose of this conversation, LLVM is not always that relevant a point. It is of course important that we can lower MIR to LLVM IR soundly (to the extent that is well-defined), but I don't think we should ever be using "well LLVM is already broken" or "LLVM can't do these opts anyway" as a reason. If Rust is (or becomes) as awesome as we're all trying to make it, I think we have to realize that we will eventually eg have significant influence in what LLVM supports, or have powerful optimization frameworks that are tailored specifically to Rust. Wasting the amazing things that could come from that would be quite unfortunate</p>



<a name="277468380"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277468380" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Christopher Durham <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277468380">(Apr 01 2022 at 19:37)</a>:</h4>
<p>And it's worth adding that we're already at a point where both the cranelift and gccjit backends are functional enough to compile real code, so even today we're not exclusively tied to the LLVM backend</p>



<a name="277470312"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277470312" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277470312">(Apr 01 2022 at 19:57)</a>:</h4>
<p>My perspective is different: if not for CHERI, I would think strict provenance is a compromise, an unnecessarily restrictive ruleset used because the Rust project doesn't have enough bandwidth to have someone spend enough time hacking on compiler optimizations to figure out how hard it would be to do a less restrictive one soundly.</p>



<a name="277470393"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277470393" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277470393">(Apr 01 2022 at 19:58)</a>:</h4>
<p>CHERI does make me more sympathetic to strict provenance though.</p>



<a name="277470472"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277470472" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277470472">(Apr 01 2022 at 19:59)</a>:</h4>
<p>But yeah, I see it less as "getting it right" and more as "giving up".</p>



<a name="277470772"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277470772" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277470772">(Apr 01 2022 at 20:01)</a>:</h4>
<p><span class="user-mention silent" data-user-id="198590">comex</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277470312">said</a>:</p>
<blockquote>
<p>My perspective is different: if not for CHERI, I would think strict provenance is a compromise, an unnecessarily restrictive ruleset used because the Rust project doesn't have enough bandwidth to have someone spend enough time hacking on compiler optimizations to figure out how hard it would be to do a less restrictive one soundly.</p>
</blockquote>
<p>It's not an optimization problem; before we can even begin to talk about those, we need a memory model to write them against, and Ralf - the one person who definitely has done a huge amount of work on trying to find a memory model that works for Rust - says that he doesn't see how it's possible.</p>



<a name="277470901"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277470901" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277470901">(Apr 01 2022 at 20:02)</a>:</h4>
<p><span aria-label="thinking" class="emoji emoji-1f914" role="img" title="thinking">:thinking:</span> What's wrong with Stacked Borrows as is? Do you have a pointer/link?</p>



<a name="277471071"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277471071" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277471071">(Apr 01 2022 at 20:04)</a>:</h4>
<p>Sorry, I meant that it is my impression that <span class="user-mention" data-user-id="120791">@RalfJ</span> said that he can't figure out how to do non-strict provenance with stacked borrows</p>



<a name="277471171"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277471171" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277471171">(Apr 01 2022 at 20:05)</a>:</h4>
<p>My understanding was that there's simply a bunch still to be defined. For instance, transmutes from ptr (which should probably be UB, it seems now).</p>
<p>But if he said it that directly, then fair enough</p>



<a name="277471382"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277471382" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277471382">(Apr 01 2022 at 20:07)</a>:</h4>
<p>Ralf says it's not possible without being unable to remove dead stores and dead loads.  Which is a very valid point.  But it's also overly simplistic, because even if you can't literally remove them at the IR level, you can still turn them into some kind of marker which doesn't produce any machine code but constrains future optimizations.  Now, if it constrains future optimizations too much, then that's still a non-workable outcome.  But it may be possible to keep most of the optimization potential by carefully taking these markers into account.  I don't know.</p>



<a name="277471452"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277471452" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277471452">(Apr 01 2022 at 20:07)</a>:</h4>
<p>Alternately, it may be possible to make a model work where integers do have provenance (PVI), which removes most of the hard parts of PNVI at the cost of making other things hard.</p>



<a name="277471622"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277471622" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277471622">(Apr 01 2022 at 20:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277471171">said</a>:</p>
<blockquote>
<p>My understanding was that there's simply a bunch still to be defined. For instance, transmutes from ptr (which should probably be UB, it seems now).</p>
<p>But if he said it that directly, then fair enough</p>
</blockquote>
<p>So 1) that's not exactly a SB issue, but a more general memory model issue. 2) "Still to be defined" is one way of putting it - as I understand it, the reason that things like integer to pointer casts are not defined is because we have no idea how to define them in a workable way. I'll try and let Ralf speak for himself though when he gets back</p>



<a name="277471945"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277471945" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277471945">(Apr 01 2022 at 20:11)</a>:</h4>
<p>(In particular, the biggest obstacles to PVI I've seen are: 1. You can't do global value numbering ‚Äî but really, it's only certain types of GVN-ish optimizations you can't do, and even those can still be performed on any integer you are sure doesn't come from a pointer.  2. Issues with things like <code>x - x</code> not being optimizable to <code>0</code> because they still carry provenance ‚Äî 'just' say that mangling the value drops the provenance.)</p>



<a name="277472532"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277472532" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277472532">(Apr 01 2022 at 20:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="198590">comex</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277471382">said</a>:</p>
<blockquote>
<p>Ralf says it's not possible without being unable to remove dead stores and dead loads.</p>
</blockquote>
<p>You mean something like <a href="https://www.ralfj.de/blog/2020/12/14/provenance.html">https://www.ralfj.de/blog/2020/12/14/provenance.html</a> ?</p>
<p>In my understanding, we can do such optimizations fine in Stacked Borrows + strict provenance functions, just not anywhere near <code>ptr as usize</code> / <code>broadcasting_ptr2int</code> . Details: <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277320814">https://rust-lang.zulipchat.com/#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277320814</a></p>



<a name="277472697"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277472697" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277472697">(Apr 01 2022 at 20:18)</a>:</h4>
<p>No, I don't think those are related. Not being able to remove dead stores is an issue that comes up if you allow ptr to int transmutes to implicitly broadcast</p>



<a name="277472765"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277472765" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277472765">(Apr 01 2022 at 20:19)</a>:</h4>
<p>And, because Rust does not have typed memory/strict aliasing, every store to a type that is not a pointer is potentially such a store. So basically this means we can eliminate no dead stores except if the type is a pointer</p>



<a name="277472829"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277472829" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277472829">(Apr 01 2022 at 20:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="198590">comex</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277471945">said</a>:</p>
<blockquote>
<p>(In particular, the biggest obstacles to PVI I've seen are: 1. You can't do global value numbering ‚Äî but really, it's only certain types of GVN-ish optimizations you can't do, and even those can still be performed on any integer you are sure doesn't come from a pointer.  2. Issues with things like <code>x - x</code> not being optimizable to <code>0</code> because they still carry provenance ‚Äî 'just' say that mangling the value drops the provenance.)</p>
</blockquote>
<p>Let's open a new thread for this actually</p>



<a name="277472874"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277472874" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277472874">(Apr 01 2022 at 20:20)</a>:</h4>
<p>I believe there is consensus that pointer-to-int <strong>transmute</strong> cannot work and has to break. Even though pointer-to-int <em>conversions</em> like <code>ptr as usize</code> would still work. And we believe that very little code in practice uses such transmutes</p>



<a name="277473168"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277473168" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277473168">(Apr 01 2022 at 20:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277472874">said</a>:</p>
<blockquote>
<p>I believe there is consensus that pointer-to-int <strong>transmute</strong> cannot work and has to break. Even though pointer-to-int <em>conversions</em> like <code>ptr as usize</code> would still work. And we believe that very little code in practice uses such transmutes</p>
</blockquote>
<p>I think there's no such consensus. I pointed out a way that the transmutes could actually work (just not broadcast), and someone on the issue said they believed that the transmutes are actually common enough to be a problem</p>



<a name="277473217"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277473217" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277473217">(Apr 01 2022 at 20:23)</a>:</h4>
<p>currently there's things like tearor/bytemuck (where bytemuck removed Pod impls for pointers because of the discussion iirc)</p>



<a name="277473296"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277473296" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277473296">(Apr 01 2022 at 20:24)</a>:</h4>
<p><span class="user-mention" data-user-id="198590">@comex</span> I think there are other reasons to prefer strict provenance: namely simplicity. In that respect, it's the other models that are compromises between something that won't break too much code, vs what will allow us to keep most of our optimizations. If we were starting from scratch with no existing code, then IMO strict provenance is clearly the better model.</p>



<a name="277473300"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277473300" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277473300">(Apr 01 2022 at 20:24)</a>:</h4>
<p>(though tearor/atomiccell/etc could certainly certainly just use AtomicPtr for anything pointer sized)</p>



<a name="277473331"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277473331" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277473331">(Apr 01 2022 at 20:24)</a>:</h4>
<p><span class="user-mention silent" data-user-id="143798">Talchas</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277473217">said</a>:</p>
<blockquote>
<p>currently there's things like tearor/bytemuck (where bytemuck removed Pod impls for pointers because of the discussion iirc)</p>
</blockquote>
<p>Yes; it would be interesting to see what code actually made use of that</p>



<a name="277473375"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277473375" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277473375">(Apr 01 2022 at 20:24)</a>:</h4>
<p>but if it's not better for users and maybe not better for compilers (given FFI exists), what benefit is the nicer model</p>



<a name="277473386"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277473386" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277473386">(Apr 01 2022 at 20:24)</a>:</h4>
<p>Given that bytemuck's pod impl is not really "using" ptr to int transmutes so much as letting other people use them</p>



<a name="277473484"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277473484" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277473484">(Apr 01 2022 at 20:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="143798">Talchas</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277473375">said</a>:</p>
<blockquote>
<p>but if it's not better for users and maybe not better for compilers (given FFI exists), what benefit is the nicer model</p>
</blockquote>
<p>I think model simplicity is necessarily a benefit to users. Whether this benefit is a worthwhile tradeoff with the additional DB that you get from other models is of course more complicated</p>



<a name="277473539"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277473539" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277473539">(Apr 01 2022 at 20:26)</a>:</h4>
<blockquote>
<p>I believe there is consensus that pointer-to-int transmute cannot work and has to break. </p>
</blockquote>
<p>Well, the outcome I'm thinking of is one where it broadcasts.  This is (at least in part) what creates the problems with dead loads and dead stores.  Though, Ralf had another test case which is supposed to show another problem with pointer-to-int transmute, but I don't really understand what it's meant to demonstrate.</p>



<a name="277473556"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277473556" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277473556">(Apr 01 2022 at 20:26)</a>:</h4>
<p>(having strict variants of <code>ptrtoint</code> is likely valuable, but it seems unlikely for compilers to be able to take advantage of a global lack of them, because FFI/extern code still exists)</p>



<a name="277473680"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277473680" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277473680">(Apr 01 2022 at 20:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="198590">comex</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277473539">said</a>:</p>
<blockquote>
<blockquote>
<p>I believe there is consensus that pointer-to-int transmute cannot work and has to break. </p>
</blockquote>
<p>Well, the outcome I'm thinking of is one where it broadcasts.  This is (at least in part) what creates the problems with dead loads and dead stores.  Though, Ralf had another test case which is supposed to show another problem with pointer-to-int transmute, but I don't really understand what it's meant to demonstrate.</p>
</blockquote>
<p>I mean, pointer to int transmutes broadcasting means that it is unsound for an optimization to remove any move/copy that is not of a pointer type</p>



<a name="277473699"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277473699" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277473699">(Apr 01 2022 at 20:27)</a>:</h4>
<p>That seems very bad</p>



<a name="277473813"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277473813" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277473813">(Apr 01 2022 at 20:28)</a>:</h4>
<p>Does it make the model simpler to reason about than the non-strict model when you are never doing a ptrtoint, or is the complexity entirely/nearly entirely in the ptrtoint/inttoptr operations?</p>



<a name="277473818"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277473818" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277473818">(Apr 01 2022 at 20:28)</a>:</h4>
<p>And it's not really recoverable by inserting <code>broadcast_value(...);</code> statements either, for reasons that I can explain (if no one else has) once I am back from this scheduled break</p>



<a name="277473854"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277473854" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277473854">(Apr 01 2022 at 20:28)</a>:</h4>
<p>Sure, explain it.</p>



<a name="277473857"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277473857" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277473857">(Apr 01 2022 at 20:28)</a>:</h4>
<p>because it certainly is my impression that the english description of the model is about the same</p>



<a name="277474038"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277474038" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277474038">(Apr 01 2022 at 20:30)</a>:</h4>
<p>(the math model I'm sure winds up with more boilerplate because you can't say "if every possible choice of provenance will cause UB, then this is UB", you have to actually write that out)</p>



<a name="277474087"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277474087" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277474087">(Apr 01 2022 at 20:31)</a>:</h4>
<p>but if it means you can throw out entire possible states in the borrow stack or something, then you are actually gaining some simplicity</p>



<a name="277474143"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277474143" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277474143">(Apr 01 2022 at 20:31)</a>:</h4>
<p>(you regardless gain some simplicity in the sense that "library code you need to understand has fewer operations available to it" but that is a very different thing)</p>



<a name="277474412"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277474412" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277474412">(Apr 01 2022 at 20:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="295632">Diggsey</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277473296">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="198590">comex</span> I think there are other reasons to prefer strict provenance: namely simplicity. In that respect, it's the other models that are compromises between something that won't break too much code, vs what will allow us to keep most of our optimizations. If we were starting from scratch with no existing code, then IMO strict provenance is clearly the better model.</p>
</blockquote>
<p>Maybe.  I think there is a concern that we don't have a good story for things like memory allocators and garbage collectors.  I thought this was more of a Stacked Borrows problem, but really it is a strict provenance problem to some extent, since strict provenance special-cases the allocator as handing out freshly-provenanced chunks of memory (otherwise you can't use provenance to justify noalias), and then it's unclear what rules the allocator itself has to follow.</p>



<a name="277475064"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277475064" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277475064">(Apr 01 2022 at 20:40)</a>:</h4>
<p>Really. My hunch is allocators fit into Stacked Borrows. But <code>free</code> would need to be defined obviously.</p>



<a name="277475203"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277475203" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277475203">(Apr 01 2022 at 20:41)</a>:</h4>
<p>I tweaked <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277358112">my standpoint</a> to forbid pointer-to-int transmutes.</p>
<p>But if there really are important places where people have to use pointer-to-int transmutes, we can consider it. It seems we have a choice of that, or keeping backwards compatibility with a lot of permissive-provenance code, but not both.</p>



<a name="277475464"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277475464" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277475464">(Apr 01 2022 at 20:44)</a>:</h4>
<p><span class="user-mention" data-user-id="198590">@comex</span> I agree there are some unresolved questions, but they do seem quite solvable. For example: what would an allocator look like in CHERI? Well, you'd take a pointer with access to a large slab of memory, and then you create smaller pointers from that, and give them out to the application. In "free" you'll again be starting from your pointer to the slab of memory, and use the offset within that of the pointer you're given to modify some data structures. I think a similar layered approach works for the provenance model itself.</p>



<a name="277475572"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277475572" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277475572">(Apr 01 2022 at 20:45)</a>:</h4>
<p>So the malloc implementation follows exactly the same provenance rules, it just lives at a different layer.</p>



<a name="277476531"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277476531" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277476531">(Apr 01 2022 at 20:55)</a>:</h4>
<p>If we're searching for a clear / easy-to-understand execution model, then between Stacked Borrows (allows permissive provenance) and something that allows ptr-to-int transmute, I think actually both would be very complicated.</p>
<p>(For the second one: <a class="stream-topic" data-stream-id="136281" href="/#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Problems.20with.20PVI.20-.20What.20optimizations.20does.20it.20break.3F">#t-lang/wg-unsafe-code-guidelines &gt; Problems with PVI - What optimizations does it break?</a> )</p>



<a name="277477720"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277477720" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277477720">(Apr 01 2022 at 21:07)</a>:</h4>
<p>yeah, SB's baseline complexity is high, and as far as I've heard strict provenance wouldn't let you rip out any of the complexity of the raw pointer handling parts</p>



<a name="277477899"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277477899" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277477899">(Apr 01 2022 at 21:08)</a>:</h4>
<p>(ptrtoint transmutes shouldn't have much addition to the model or programmer difficulty; compiler difficulty is the problem there)</p>



<a name="277477948"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277477948" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277477948">(Apr 01 2022 at 21:09)</a>:</h4>
<p><span class="user-mention" data-user-id="295632">@Diggsey</span> You might be right, but there is a problem with layering it: What is stopping the allocator from keeping a backup pointer of literally all the memory it hands out, and then accessing the memory whenever it wants?  From a CHERI perspective, nothing; it's fine (but not very secure) to do that.  But from a compiler perspective, that's like allowing unrestricted <code>int2ptr</code> without even having to do a <code>ptr2int</code> first.  So it must be disallowed.  Makes sense - the allocator shouldn't be mucking with memory it handed out.  But what about things like metadata, or what about garbage collectors that actually do want to access the contents of allocations sometimes?  You could say these questions are all in the Stacked Borrows category rather than the strict-provenance category, but they're not truly that separate: from a compiler perspective, the whole point of provenance is to make aliasing assumptions.</p>



<a name="277477958"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277477958" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277477958">(Apr 01 2022 at 21:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="295632">Diggsey</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277473296">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="198590">comex</span> I think there are other reasons to prefer strict provenance: namely simplicity. In that respect, it's the other models that are compromises between something that won't break too much code, vs what will allow us to keep most of our optimizations. If we were starting from scratch with no existing code, then IMO strict provenance is clearly the better model.</p>
</blockquote>
<p>This is something I'm unsure about. The advantage of a weak provenance model is that programmers don't have to think about it as much and things generally work when you pretend that memory is just a bag of bytes with integer addresses. Yes, I know there are lots of test cases in which this assumption breaks, but in general it works. That's why C++ has been so successful.</p>



<a name="277478129"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277478129" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277478129">(Apr 01 2022 at 21:11)</a>:</h4>
<ul>
<li>Though, to be fair, provenance-based aliasing assumptions are mostly (not entirely) for stack memory, while garbage collectors mostly (not entirely) care about the heap.  But the stack does have to be allocated somewhere.</li>
</ul>



<a name="277478130"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277478130" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277478130">(Apr 01 2022 at 21:11)</a>:</h4>
<p>Now if you introduce strict provenance, then programmers have to keep provenance at the top of their mind all the time, or risk UB (or outright breakage on CHERI). This allows the programmers who have mastered the idea of provenance to use that to write correct code, which is great. But it also adds complexity to the <em>mental</em> model (though not the underlying formalism).</p>



<a name="277478165"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277478165" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277478165">(Apr 01 2022 at 21:11)</a>:</h4>
<p>Note that I'm genuinely conflicted here! I see the advantages of both sides.</p>



<a name="277478235"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277478235" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277478235">(Apr 01 2022 at 21:12)</a>:</h4>
<p><span class="user-mention" data-user-id="198590">@comex</span> I guess the difference is that the compiler is relying on the contract of malloc, and it's up to the implementation to fulfill that contract. This leaves a gap in what a tool like MIRI could check, so to check this, you'd need additional rules in MIRI to check that the implementation does in fact fulfill its contract, and these would be specific rules for malloc/free.</p>



<a name="277478274"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277478274" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277478274">(Apr 01 2022 at 21:12)</a>:</h4>
<p>IOW I don't have the right answer here. But I do think that explicit provenance is a tradeoff even without the constraint of backwards compatibility with existing code.</p>



<a name="277478292"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277478292" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277478292">(Apr 01 2022 at 21:12)</a>:</h4>
<p>ie. that the implementation doesn't randomly write to areas which it has handed out</p>



<a name="277478358"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277478358" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277478358">(Apr 01 2022 at 21:13)</a>:</h4>
<p>no one actually "pretends that memory is just a bag of bytes with integer addresses" tho' because if they do their programs segfault. they tend to act in a fairly well-behaved manner, even when they're committing crimes.</p>



<a name="277478365"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277478365" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277478365">(Apr 01 2022 at 21:13)</a>:</h4>
<p><span class="user-mention" data-user-id="384014">@Patrick Walton</span> Having provenance is certainly more complicated to the programmer than not having it, but I do think that strict provenance is easier to understand <em>if you're going to have provenance at all</em></p>



<a name="277478431"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277478431" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277478431">(Apr 01 2022 at 21:14)</a>:</h4>
<p>And the reason that a stricter model is simpler is because the pretense that provenance doesn't exist is a very leaky abstraction.</p>



<a name="277478459"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277478459" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277478459">(Apr 01 2022 at 21:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="281757">Jubilee</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277478358">said</a>:</p>
<blockquote>
<p>no one actually "pretends that memory is just a bag of bytes with integer addresses" tho' because if they do their programs segfault. they tend to act in a fairly well-behaved manner, even when they're committing crimes.</p>
</blockquote>
<p>Most C++ programmers do and their programs work.</p>



<a name="277478475"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277478475" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277478475">(Apr 01 2022 at 21:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="281757">Jubilee</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277478431">said</a>:</p>
<blockquote>
<p>And the reason that a stricter model is simpler is because the pretense that provenance doesn't exist is a very leaky abstraction.</p>
</blockquote>
<p>It's not really a leaky abstraction in practice.</p>



<a name="277478478"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277478478" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277478478">(Apr 01 2022 at 21:14)</a>:</h4>
<p>They don't, lol.</p>



<a name="277478526"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277478526" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277478526">(Apr 01 2022 at 21:15)</a>:</h4>
<p>If you truly try to write to random addresses, you die on virtual memory.</p>



<a name="277478601"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277478601" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277478601">(Apr 01 2022 at 21:16)</a>:</h4>
<p>There are a lot of provenance-derived rules that C++ programmers follow so that they don't need to understand that provenance exists, and if they follow those rules, then things mostly work...</p>



<a name="277478604"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277478604" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277478604">(Apr 01 2022 at 21:16)</a>:</h4>
<p>I'm not talking about writing to memory you didn't allocate. I'm talking about treating pointers and integers as interchangeable.</p>



<a name="277478632"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277478632" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277478632">(Apr 01 2022 at 21:16)</a>:</h4>
<p>Writing to memory you didn't allocate versus not is in fact what we are talking about tho'</p>



<a name="277478637"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277478637" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277478637">(Apr 01 2022 at 21:16)</a>:</h4>
<p>that is literally the property that differentiates those integers</p>



<a name="277478666"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277478666" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277478666">(Apr 01 2022 at 21:16)</a>:</h4>
<p>Yeah allocators and provenance has been an issue for as long as time itself. Rust's allocator API (the unstable one) I don't think actually deals with provenance at all iirc.</p>



<a name="277478674"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277478674" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277478674">(Apr 01 2022 at 21:17)</a>:</h4>
<p>but even wrote learning those rules is much more complicated than strict provenance, and it still doesn't protect you completely</p>



<a name="277478685"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277478685" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brooks Davis <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277478685">(Apr 01 2022 at 21:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="295632">Diggsey</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277475464">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="198590">comex</span> I agree there are some unresolved questions, but they do seem quite solvable. For example: what would an allocator look like in CHERI? Well, you'd take a pointer with access to a large slab of memory, and then you create smaller pointers from that, and give them out to the application. In "free" you'll again be starting from your pointer to the slab of memory, and use the offset within that of the pointer you're given to modify some data structures. I think a similar layered approach works for the provenance model itself.</p>
</blockquote>
<p>The basic list of things a CHERI-aware allocator does are:</p>
<ul>
<li>Round up the size of allocations so they are representable given compressed bounds</li>
<li>Allocate from some sort of slab of memory (in practice on Unix allocated by <code>mmap</code>) and set bounds appropriately</li>
<li>Provide a mechanism to get from the pointer passed to "free" back to the allocator's internal data structures without relying on anything but the address (some malloc's already do this, some like dlmalloc provide no efficient mechanism)</li>
</ul>



<a name="277478720"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277478720" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277478720">(Apr 01 2022 at 21:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="295632">Diggsey</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277478235">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="198590">comex</span> I guess the difference is that the compiler is relying on the contract of malloc, and it's up to the implementation to fulfill that contract. This leaves a gap in what a tool like MIRI could check, so to check this, you'd need additional rules in MIRI to check that the implementation does in fact fulfill its contract, and these would be specific rules for malloc/free.</p>
</blockquote>
<p>Sure, but there are questions that are more subtle than "don't randomly write to allocations", and my point is: if you want to reason about what the allocator is allowed to do, it's more complicated than just handing out chunks of provenance.  Maybe this is orthogonal to random integer-pointer casts.  Except not really, since allocators tend to do a lot of integer-pointer casts :)</p>



<a name="277478721"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277478721" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277478721">(Apr 01 2022 at 21:17)</a>:</h4>
<p>As a program evolves over time, allocating and deallocating memory, the same integer, cast to a pointer, can be a legal or an illegal pointer to use.</p>



<a name="277478858"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277478858" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277478858">(Apr 01 2022 at 21:18)</a>:</h4>
<p>And it is that extra bit of knowledge, that exists in actual fact even on systems without CHERI or whatnot, that means Provenance Is Real.</p>



<a name="277478862"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277478862" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277478862">(Apr 01 2022 at 21:18)</a>:</h4>
<p>In particular, keeping one big "backup" provenance works for CHERI but doesn't really help under a compiler-optimization model.</p>



<a name="277478886"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277478886" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277478886">(Apr 01 2022 at 21:18)</a>:</h4>
<p>No, learning <br>
<span class="user-mention silent" data-user-id="281757">Jubilee</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277478637">said</a>:</p>
<blockquote>
<p>that is literally the property that differentiates those integers</p>
</blockquote>
<p>No, we're talking about whether an address that you read or write to is derived from (as the compiler, or runtime architecture in the case of CHERI) a pointer that came from the allocation.</p>



<a name="277478889"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277478889" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277478889">(Apr 01 2022 at 21:18)</a>:</h4>
<p><strong>very weakly</strong>, perhaps.</p>



<a name="277478962"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277478962" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277478962">(Apr 01 2022 at 21:19)</a>:</h4>
<p>All pointers that a program ever sees are just allocations by the OS. <span aria-label="relieved" class="emoji emoji-1f60c" role="img" title="relieved">:relieved:</span></p>



<a name="277479036"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277479036" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277479036">(Apr 01 2022 at 21:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="281757">Jubilee</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277478721">said</a>:</p>
<blockquote>
<p>As a program evolves over time, allocating and deallocating memory, the same integer, cast to a pointer, can be a legal or an illegal pointer to use.</p>
</blockquote>
<p>Validity changing over time doesn't require provenance.  What requires provenance is when you have two pointers /with the same integer value/ where one is legal and the other is illegal.  Which can happen in any reasonable optimizing-compiler model, but not in e.g. WebAssembly.</p>



<a name="277479073"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277479073" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277479073">(Apr 01 2022 at 21:20)</a>:</h4>
<p>I mean, one is legal and the other is illegal, at the same time.</p>



<a name="277479195"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277479195" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277479195">(Apr 01 2022 at 21:21)</a>:</h4>
<p><span class="user-mention silent" data-user-id="281757">Jubilee</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277478889">said</a>:</p>
<blockquote>
<p><strong>very weakly</strong>, perhaps.</p>
</blockquote>
<p>I suppose there's a way in which a program's memory mappings can be viewed as a form of provenance, but that isn't the provenance we're talking about here. When I say "a bag of bits" I mean one in which there are a set of memory mappings that you see from <code>cat /proc/self/maps</code> that have integer ranges and protections and it's legal to forge a pointer from an integer in any way you want and access memory, so long as you land in one of those address ranges and you don't violate the permissions.</p>



<a name="277479213"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277479213" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277479213">(Apr 01 2022 at 21:21)</a>:</h4>
<blockquote>
<p>if you want to reason about what the allocator is allowed to do, it's more complicated than just handing out chunks of provenance</p>
</blockquote>
<p>Well, there are some additional constraints when writing an allocator, but you still have the normal provenance rules as a foundation. It's not like there's a completely different model, it's that logic errors in the allocator layer can make programs in the layer below unsound. And I don't think the rules an allocator has to follow are actually that complicated...</p>



<a name="277479339"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277479339" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277479339">(Apr 01 2022 at 21:22)</a>:</h4>
<p>For the most part, this is the model that C++ programmers have in their head when writing code and it generally works.</p>



<a name="277479423"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277479423" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277479423">(Apr 01 2022 at 21:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="384014">Patrick Walton</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277479339">said</a>:</p>
<blockquote>
<p>For the most part, this is the model that C++ programmers have in their head when writing code and it generally works.</p>
</blockquote>
<p>To be quite frank, I - and presumably many other rust programmers - am hoping for a higher bar than what C++ programs consider to "generally work"</p>



<a name="277479429"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277479429" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277479429">(Apr 01 2022 at 21:23)</a>:</h4>
<p>Honestly I rarely encounter programmers who truly reason from the same God's eye view of the Operating System, but I am willing to believe you.</p>



<a name="277479443"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277479443" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277479443">(Apr 01 2022 at 21:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="295632">Diggsey</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277478674">said</a>:</p>
<blockquote>
<p>but even wrote learning those rules is much more complicated than strict provenance, and it still doesn't protect you completely</p>
</blockquote>
<p>Yes, it's simpler because you've removed the ability to do that. Removing any features makes any language simpler at a first approximation. The question is if it makes things simpler <em>even if you weren't using that feature</em>. (And in the other direction, if working around the lack of feature winds up making the code more complex than you gained)</p>



<a name="277479452"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277479452" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277479452">(Apr 01 2022 at 21:23)</a>:</h4>
<p>I would actually suggest that most programmers tend to manipulate objects they believe it is safe to manipulate.</p>



<a name="277479474"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277479474" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277479474">(Apr 01 2022 at 21:24)</a>:</h4>
<p>Rust doesn't have any <code>malloc</code> attribute currently so no user-space (non-GlobalAlloc) allocators currently deal with provenance issues.</p>



<a name="277479525"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277479525" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brooks Davis <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277479525">(Apr 01 2022 at 21:24)</a>:</h4>
<p><span class="user-mention silent" data-user-id="384014">Patrick Walton</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277478604">said</a>:</p>
<blockquote>
<p>I'm not talking about writing to memory you didn't allocate. I'm talking about treating pointers and integers as interchangeable.</p>
</blockquote>
<p>Porting work C/C++ code to CHERI suggests most programmer don't treat pointers and integers as interchangeable. Programmers use the expected methods of allocating language objects (global objects, stack allocations, malloc/new) and try not to get it wrong. There are of course  notable exceptions like the Linux kernel's rampant use of casts via <code>long</code>, but most code doesn't do that sort of thing except perhaps in allocators.</p>



<a name="277479542"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277479542" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277479542">(Apr 01 2022 at 21:24)</a>:</h4>
<p>Yeah.</p>



<a name="277479576"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277479576" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277479576">(Apr 01 2022 at 21:24)</a>:</h4>
<p><span class="user-mention silent" data-user-id="295632">Diggsey</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277479213">said</a>:</p>
<blockquote>
<p>And I don't think the rules an allocator has to follow are actually that complicated...</p>
</blockquote>
<p>You may be right.  I am not sure.</p>



<a name="277479650"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277479650" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277479650">(Apr 01 2022 at 21:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="281757">Jubilee</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277479452">said</a>:</p>
<blockquote>
<p>I would actually suggest that most programmers tend to manipulate objects they believe it is safe to manipulate.</p>
</blockquote>
<p>they may have more sophisticated goals, like "making concurrency work"</p>



<a name="277479678"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277479678" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277479678">(Apr 01 2022 at 21:25)</a>:</h4>
<p>Which can go pretty badly if you don't respect "who is allowed to go now" and instead contend forever on a resource.</p>



<a name="277479690"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277479690" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ben Kimock (Saethlin) <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277479690">(Apr 01 2022 at 21:25)</a>:</h4>
<p>I worry that reasoning like "C++ programs tend to work" is circular, because C++ compilers are deliberately conservative with what aliasing optimizations they implement to avoid the implicit standard-extending contract that's been forged by legacy code written in the absence of any kind of checker.</p>



<a name="277479748"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277479748" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277479748">(Apr 01 2022 at 21:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310518">Jak{e,ob} Degen</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277479423">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="384014">Patrick Walton</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277479339">said</a>:</p>
<blockquote>
<p>For the most part, this is the model that C++ programmers have in their head when writing code and it generally works.</p>
</blockquote>
<p>To be quite frank, I - and presumably many other rust programmers - am hoping for a higher bar than what C++ programs consider to "generally work"</p>
</blockquote>
<p>Me too, and that's why I'm conflicted. The practical advantage of the status quo in C++ is a simple mental model for the programmer, which allows them to write working code with less effort <em>most</em> of the time. The practical disadvantage is that, sometimes (rarely, to be honest) there are bugs that arise from the fact that the programmer's mental model doesn't match the formal model that the optimizer is optimizing under.</p>



<a name="277479751"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277479751" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277479751">(Apr 01 2022 at 21:26)</a>:</h4>
<blockquote>
<p>Yes, it's simpler because you've removed the ability to do that.</p>
</blockquote>
<p>I don't know what you mean by that. I'm saying that as a C++ programmer I had to learn a bunch of "things not to do" to avoid falling into optimization pitfalls indirectly due to provenance (which I didn't understand at the time). Those rules served as a proxy for the "real provenance rules" which are still not well defined in C/C++ that prevented most miscompilations. Under strict provenance, the <em>actual</em> provenance rules are even simpler than those "simply proxy rules" that I had to learn for C++.</p>



<a name="277479762"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277479762" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277479762">(Apr 01 2022 at 21:26)</a>:</h4>
<p>Also most programs execute on x86's TSO memory model.</p>



<a name="277479811"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277479811" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277479811">(Apr 01 2022 at 21:27)</a>:</h4>
<p>Of course, it's completely valid to pick one side or the other of the tradeoff, but there is a tradeoff.</p>



<a name="277479829"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277479829" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brooks Davis <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277479829">(Apr 01 2022 at 21:27)</a>:</h4>
<p>I think most "know" that pointers are integers, but on the whole only rely on that when solving a difficult problem or just being overly clever (e.g., Solaris devs storing pointers XORd to a key to hide them from a leak checker.)</p>



<a name="277479884"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277479884" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277479884">(Apr 01 2022 at 21:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="490906">Brooks Davis</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277479829">said</a>:</p>
<blockquote>
<p>I think most "know" that pointers are integers, but on the whole only rely on that when solving a difficult problem or just being overly clever (e.g., Solaris devs storing pointers XORd to a key to hide them from a leak checker.)</p>
</blockquote>
<p>Right, that's why LLVM/GCC does optimizations based on provenance in the first place.</p>



<a name="277479953"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277479953" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277479953">(Apr 01 2022 at 21:28)</a>:</h4>
<p>Okay, so can we at least admit there's a lot of asterisks on "programmers treating integers as pointers"?</p>



<a name="277479957"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277479957" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277479957">(Apr 01 2022 at 21:28)</a>:</h4>
<p>like five?</p>



<a name="277480022"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277480022" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277480022">(Apr 01 2022 at 21:29)</a>:</h4>
<p>I guess allocators don't really /need/ to convert integers to pointers most of the time.  When I write allocators in C I tend to do that a lot, in an attempt to limit UB in C, but this is not C‚Ä¶  I guess allocators need a different way to guarantee that they can do things like 'do pointer arithmetic on allocations to walk out of bounds to where the metadata is stored', which really shouldn't have anything to do with integers.  Therefore this issue is orthogonal to strict provenance versus integer broadcasting.  Maybe.</p>



<a name="277480058"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277480058" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277480058">(Apr 01 2022 at 21:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="281757">Jubilee</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277479953">said</a>:</p>
<blockquote>
<p>Okay, so can we at least admit there's a lot of asterisks on "programmers treating integers as pointers"?</p>
</blockquote>
<p>it really depends on the type of code. :p</p>



<a name="277480078"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277480078" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277480078">(Apr 01 2022 at 21:29)</a>:</h4>
<p>I mean yes.</p>



<a name="277480166"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277480166" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277480166">(Apr 01 2022 at 21:30)</a>:</h4>
<p><span class="user-mention silent" data-user-id="295632">Diggsey</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277479751">said</a>:</p>
<blockquote>
<blockquote>
<p>Yes, it's simpler because you've removed the ability to do that.</p>
</blockquote>
<p>I don't know what you mean by that. I'm saying that as a C++ programmer I had to learn a bunch of "things not to do" to avoid falling into optimization pitfalls indirectly due to provenance (which I didn't understand at the time). Those rules served as a proxy for the "real provenance rules" which are still not well defined in C/C++ that prevented most miscompilations. Under strict provenance, the <em>actual</em> provenance rules are even simpler than those "simply proxy rules" that I had to learn for C++.</p>
</blockquote>
<p>I mean that the "things not to do" that strict provenance does is "<code>(void*)integer</code> no longer exists, so you can't get it wrong"</p>



<a name="277480177"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277480177" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277480177">(Apr 01 2022 at 21:30)</a>:</h4>
<p>I mean, yes, in most cases programmers don't think about the integer-ness of their pointers, but also there are a lot of pointer-to-int and int-to-pointer casts in our codebase. Not sure what else to say.</p>



<a name="277480183"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277480183" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277480183">(Apr 01 2022 at 21:30)</a>:</h4>
<p>and this is... true, but not really what people mean by simpler</p>



<a name="277480204"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277480204" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277480204">(Apr 01 2022 at 21:30)</a>:</h4>
<p>I hear and understand your concern.</p>



<a name="277480245"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277480245" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277480245">(Apr 01 2022 at 21:31)</a>:</h4>
<p>But half of the point is that if we don't even add methods like <code>pointer::addr</code> then we are stuck with your codebase having <code>ptr as usize</code></p>



<a name="277480254"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277480254" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277480254">(Apr 01 2022 at 21:31)</a>:</h4>
<p>forever.</p>



<a name="277480271"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277480271" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277480271">(Apr 01 2022 at 21:31)</a>:</h4>
<blockquote>
<p>I mean that the "things not to do" that strict provenance does is "(void*)integer no longer exists, so you can't get it wrong"</p>
</blockquote>
<p>Well... It does, it's <code>ptr::invalid_mut</code>, but yes if you lose provenance then you can't dereference anymore.</p>



<a name="277480274"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277480274" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277480274">(Apr 01 2022 at 21:31)</a>:</h4>
<p>and we are not allowed to upgrade them.</p>



<a name="277480291"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277480291" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277480291">(Apr 01 2022 at 21:31)</a>:</h4>
<p>because adding new APIs that would not have any questions about how to interpret them would be...</p>



<a name="277480341"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277480341" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277480341">(Apr 01 2022 at 21:32)</a>:</h4>
<p>...breaking that code somehow?</p>



<a name="277480363"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277480363" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277480363">(Apr 01 2022 at 21:32)</a>:</h4>
<p>I'm arguing that <code>ptr as usize</code> is something that should not ever be broken until Rust 2.0, yes.</p>



<a name="277480373"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277480373" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277480373">(Apr 01 2022 at 21:32)</a>:</h4>
<p>Thus you can never pay down the technical debt.</p>



<a name="277480408"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277480408" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277480408">(Apr 01 2022 at 21:32)</a>:</h4>
<p>Whatever, there are a lot of people who aren't happy with the status quo.</p>



<a name="277480430"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277480430" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277480430">(Apr 01 2022 at 21:33)</a>:</h4>
<p><code>ptr as usize</code> is safe and stable, squarely within the stability promise</p>



<a name="277480440"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277480440" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277480440">(Apr 01 2022 at 21:33)</a>:</h4>
<p>Yeah, it seems like Rust 2.0 would be the prime place for most of these changes.</p>



<a name="277480459"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277480459" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277480459">(Apr 01 2022 at 21:33)</a>:</h4>
<p>I intend to  outlive Facebook's codebase anyways.</p>



<a name="277480471"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277480471" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277480471">(Apr 01 2022 at 21:33)</a>:</h4>
<p>And I think it's fine for us to talk about the future, without having to be bound by stability guarantees of today, as long as we recognize those still exist.</p>



<a name="277480476"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277480476" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277480476">(Apr 01 2022 at 21:33)</a>:</h4>
<p>and yes, there are design mistakes in Rust that we can never fix, this is a fact of life</p>



<a name="277480561"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277480561" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277480561">(Apr 01 2022 at 21:34)</a>:</h4>
<p>That's what the spirit of the compatibility promise is: there are changes we'd like to make, but we won't for the sake of backwards compatibility, and we hate it but we promised to do that.</p>



<a name="277480588"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277480588" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277480588">(Apr 01 2022 at 21:34)</a>:</h4>
<p>this is the ancient story of immovable object (backwards compat) vs unstoppable force (design evolution)</p>



<a name="277480626"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277480626" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277480626">(Apr 01 2022 at 21:34)</a>:</h4>
<p>Also re simplicity, you still have all the narrowing and borrow error things that tend to be the actual hard parts (ie, why split_at_mut's impl was wrong (twice iirc?), why <code>(&amp;vec[0] as *const T).add(5)</code> is wrong, etc)</p>



<a name="277480710"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277480710" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277480710">(Apr 01 2022 at 21:35)</a>:</h4>
<p>I have several crates that, if strict provenance becomes normative, I'm just gonna yank forever. I don't even know in how many ways they'd break</p>



<a name="277480788"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277480788" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ben Kimock (Saethlin) <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277480788">(Apr 01 2022 at 21:36)</a>:</h4>
<p>To be clear, I don't think there is any plan to break <code>(&amp;vec[0] as *const T).add(5)</code>, I just personally really want it to be wrong</p>



<a name="277480876"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277480876" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277480876">(Apr 01 2022 at 21:37)</a>:</h4>
<p>isn't that already broken?</p>



<a name="277480914"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277480914" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277480914">(Apr 01 2022 at 21:37)</a>:</h4>
<p>(personally, I want it to be wrong, but I /also/ want an opt-out for the equivalent on struct fields, on a per-struct or per-field basis, so that I can use container_of)</p>



<a name="277480916"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277480916" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ben Kimock (Saethlin) <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277480916">(Apr 01 2022 at 21:37)</a>:</h4>
<p>It is only broken under SB with raw pointer tagging</p>



<a name="277480928"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277480928" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277480928">(Apr 01 2022 at 21:37)</a>:</h4>
<p>"already broken" is a tired trope</p>



<a name="277480939"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277480939" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277480939">(Apr 01 2022 at 21:37)</a>:</h4>
<p>As an asterisk, I think that just refusing to compile <code>ptr as usize</code> under CHERI wouldn't violate the compatibility promise.</p>



<a name="277480946"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277480946" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277480946">(Apr 01 2022 at 21:37)</a>:</h4>
<p>That's what I thought.</p>



<a name="277480980"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277480980" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277480980">(Apr 01 2022 at 21:37)</a>:</h4>
<p>You're borrowing a place, which gives only provenance to that place.</p>



<a name="277480993"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277480993" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Boxy [she/her] <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277480993">(Apr 01 2022 at 21:37)</a>:</h4>
<p>refusing to compile <code>ptr as usize</code> also isnt a violation if its done over an edition boundary <span aria-label="shrug" class="emoji emoji-1f937" role="img" title="shrug">:shrug:</span></p>



<a name="277481094"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277481094" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277481094">(Apr 01 2022 at 21:38)</a>:</h4>
<p>Rust 1.x can not drop the 2015 edition</p>



<a name="277481097"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277481097" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277481097">(Apr 01 2022 at 21:38)</a>:</h4>
<p>(yeah I should clarify that all of those were "wrong according to SB")</p>



<a name="277481106"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277481106" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277481106">(Apr 01 2022 at 21:38)</a>:</h4>
<p><span class="user-mention silent" data-user-id="326176">Boxy [she/her]</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277480993">said</a>:</p>
<blockquote>
<p>refusing to compile <code>ptr as usize</code> also isnt a violation if its done over an edition boundary <span aria-label="shrug" class="emoji emoji-1f937" role="img" title="shrug">:shrug:</span></p>
</blockquote>
<p>Yeah, I was going to bring that up too. There's a possibility of fixing it in an edition here. Though, if you fix it in an edition, you still need to support it.</p>



<a name="277481208"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277481208" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277481208">(Apr 01 2022 at 21:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="218745">Wanja Hentze</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277480928">said</a>:</p>
<blockquote>
<p>"already broken" is a tired trope</p>
</blockquote>
<p>I mean "already broken" here as in "already known to be incorrect" at least under the current SB rules.</p>



<a name="277481219"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277481219" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277481219">(Apr 01 2022 at 21:39)</a>:</h4>
<p>And because provenance optimizations are all about global reasoning from local facts, as long as you must assume <em>any</em> code doesn't play by the strict rules, you can't rely on the strict rules</p>



<a name="277481249"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277481249" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277481249">(Apr 01 2022 at 21:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277481208">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="218745">Wanja Hentze</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277480928">said</a>:</p>
<blockquote>
<p>"already broken" is a tired trope</p>
</blockquote>
<p>I mean "already broken" here as in "already known to be incorrect" at least under the current SB rules.</p>
</blockquote>
<p>Stacked borrows aren't normative yet, per my understanding.</p>



<a name="277481339"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277481339" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ben Kimock (Saethlin) <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277481339">(Apr 01 2022 at 21:40)</a>:</h4>
<p>, thus this whole topic</p>



<a name="277481348"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277481348" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277481348">(Apr 01 2022 at 21:40)</a>:</h4>
<p>It's not, but it's also (close to) what is implemented by rustc, so...</p>



<a name="277481388"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277481388" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277481388">(Apr 01 2022 at 21:40)</a>:</h4>
<p>I couldn't land an optimization that assumes SB right now. If it broke existing code I'd have to back it out, no?</p>



<a name="277481389"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277481389" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277481389">(Apr 01 2022 at 21:40)</a>:</h4>
<p>The main thing is that if you still have to complicate your compiler/model/optimizations with <code>ptr as usize</code> and the inverse, edition-gating it doesn't gain you much. And sufficiently clever people will just smuggle code under a <code>2015</code> crate, which makes your life even more fun.</p>



<a name="277481442"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277481442" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ben Kimock (Saethlin) <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277481442">(Apr 01 2022 at 21:41)</a>:</h4>
<p><code>noalias</code> on <code>&amp;mut</code> and <code>Box</code> basically requires SB</p>



<a name="277481445"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277481445" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277481445">(Apr 01 2022 at 21:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="384014">Patrick Walton</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277481388">said</a>:</p>
<blockquote>
<p>I couldn't land an optimization that assumes SB right now. If it broke existing code I'd have to back it out, no?</p>
</blockquote>
<p>I think <code>noalias</code> optimizations are "proven" by SB, so SB is de facto if not de jure normative.</p>



<a name="277481453"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277481453" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277481453">(Apr 01 2022 at 21:41)</a>:</h4>
<p>As is <code>dereferenceable</code>.</p>



<a name="277481468"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277481468" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277481468">(Apr 01 2022 at 21:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="218745">Wanja Hentze</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277481219">said</a>:</p>
<blockquote>
<p>And because provenance optimizations are all about global reasoning from local facts, as long as you must assume <em>any</em> code doesn't play by the strict rules, you can't rely on the strict rules</p>
</blockquote>
<p>I don't believe this is actually true for ptrtoint/inttoptr <em>as long as no optimizations are performed across the boundary</em> (and maybe LLVM can even do better than that if people actually wanted to put in work for this setup)</p>



<a name="277481533"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277481533" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277481533">(Apr 01 2022 at 21:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="143798">Talchas</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277481468">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="218745">Wanja Hentze</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277481219">said</a>:</p>
<blockquote>
<p>And because provenance optimizations are all about global reasoning from local facts, as long as you must assume <em>any</em> code doesn't play by the strict rules, you can't rely on the strict rules</p>
</blockquote>
<p>I don't believe this is actually true for ptrtoint/inttoptr <em>as long as no optimizations are performed across the boundary</em> (and maybe LLVM can even do better than that)</p>
</blockquote>
<p>Which I noted yesterday is <em>hard</em>.</p>



<a name="277481538"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277481538" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277481538">(Apr 01 2022 at 21:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277481348">said</a>:</p>
<blockquote>
<p>It's not, but it's also (close to) what is implemented by rustc, so...</p>
</blockquote>
<p>what rustc implements is a couple conservative MIR opts and then LLVM. LLVM does not care about provenance narrower than an allocated object</p>



<a name="277481542"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277481542" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277481542">(Apr 01 2022 at 21:42)</a>:</h4>
<p>yeah, we can probably build a slightly more permissive model than SB, but uhhh</p>



<a name="277481546"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277481546" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277481546">(Apr 01 2022 at 21:42)</a>:</h4>
<p>My understanding, which could be wrong, is that SB is one model that soundly allows the optimizations that rustc does today, but it's not the only such imaginable model.</p>



<a name="277481580"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277481580" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277481580">(Apr 01 2022 at 21:42)</a>:</h4>
<p>As such SB is not normative yet.</p>



<a name="277481602"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277481602" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277481602">(Apr 01 2022 at 21:42)</a>:</h4>
<p>Yes, that seems correct</p>



<a name="277481603"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277481603" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ben Kimock (Saethlin) <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277481603">(Apr 01 2022 at 21:42)</a>:</h4>
<p>And with respect to "breaking existing code", that's kind of already done at every new LLVM release, and those aren't backed out</p>



<a name="277481623"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277481623" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277481623">(Apr 01 2022 at 21:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120827">Ben Kimock (Saethlin)</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277481603">said</a>:</p>
<blockquote>
<p>And with respect to "breaking existing code", that's kind of already done at every new LLVM release, and those aren't backed out</p>
</blockquote>
<p>It's really not.</p>



<a name="277481635"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277481635" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277481635">(Apr 01 2022 at 21:43)</a>:</h4>
<p>Yes it is.</p>



<a name="277481653"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277481653" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ben Kimock (Saethlin) <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277481653">(Apr 01 2022 at 21:43)</a>:</h4>
<p>My employer suffered huge issues with the last 2 LLVM releases<br>
We couldn't take the new toolchains.</p>



<a name="277481676"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277481676" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277481676">(Apr 01 2022 at 21:43)</a>:</h4>
<p>we've backed out of noalias because it broke stuff how many times now?</p>



<a name="277481679"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277481679" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277481679">(Apr 01 2022 at 21:43)</a>:</h4>
<p>Generally, LLVM optimizations that break lots of existing code are backed out.</p>



<a name="277481715"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277481715" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277481715">(Apr 01 2022 at 21:43)</a>:</h4>
<p><span class="user-mention silent" data-user-id="218745">Wanja Hentze</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277481676">said</a>:</p>
<blockquote>
<p>we've backed out of noalias because it broke stuff how many times now?</p>
</blockquote>
<p>IIRC, noalias still is applied today, continous since rustc 1.56 in october.</p>



<a name="277481718"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277481718" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277481718">(Apr 01 2022 at 21:43)</a>:</h4>
<p>Although I would point out that when you say "it's not the only such imaginable model," this is probably true in theory, but it is the only model we <em>have</em> that has these properties</p>



<a name="277481779"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277481779" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277481779">(Apr 01 2022 at 21:44)</a>:</h4>
<p>It is very frustrating to see what appears to be deliberate dismissal and downplaying of the rather large amount of work that it takes to keep up with LLVM's nonsense.</p>



<a name="277481785"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277481785" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277481785">(Apr 01 2022 at 21:44)</a>:</h4>
<p>It was backed out several times because it miscompiled well-defined code.</p>



<a name="277481807"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277481807" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277481807">(Apr 01 2022 at 21:44)</a>:</h4>
<p>I want to believe it is not deliberate.</p>



<a name="277481843"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277481843" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277481843">(Apr 01 2022 at 21:44)</a>:</h4>
<p>And I want to acknowledge that LLVM is not always Shenanigans.</p>



<a name="277481864"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277481864" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277481864">(Apr 01 2022 at 21:45)</a>:</h4>
<p>But that's a LOT OF SHENANIGANS people are glossing over.</p>



<a name="277481911"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277481911" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277481911">(Apr 01 2022 at 21:45)</a>:</h4>
<p><span class="user-mention" data-user-id="384014">@Patrick Walton</span> maybe the thing to consider is that given the size and importance of your employer, your experience with LLVM's... compliance, has been much better than everyone else's</p>



<a name="277481992"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277481992" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277481992">(Apr 01 2022 at 21:46)</a>:</h4>
<p>And there's no guarantees that the shenangigans end after we ban int2ptr. LLVM will continue to ship new bugs, shenanigans will continue to be necesssary</p>



<a name="277482023"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277482023" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277482023">(Apr 01 2022 at 21:46)</a>:</h4>
<p>That is true, but that does not mean we cannot improve things.</p>



<a name="277482032"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277482032" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277482032">(Apr 01 2022 at 21:46)</a>:</h4>
<p>FWIW, I've only had terrible experiences with LLVM (albeit not in rustc, I haven't touched codegen)</p>



<a name="277482040"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277482040" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277482040">(Apr 01 2022 at 21:46)</a>:</h4>
<p>And one of the ways people improve things w/r/t LLVM is formalizations.</p>



<a name="277482064"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277482064" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277482064">(Apr 01 2022 at 21:47)</a>:</h4>
<p>It is absolutely not true that everyone's code breaks all the time when upgrading LLVM. Linux distros regularly upgrade Clang and they work. Yes, there are pains, but in general the LLVM project does a great job of considering stakeholders, which is why it's been as successful as it has been.</p>



<a name="277482098"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277482098" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277482098">(Apr 01 2022 at 21:47)</a>:</h4>
<p>Not everyone's code does break.</p>



<a name="277482099"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277482099" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277482099">(Apr 01 2022 at 21:47)</a>:</h4>
<p>There are too many stakeholders at this point for LLVM to actually hear or care about them all.</p>



<a name="277482127"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277482127" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277482127">(Apr 01 2022 at 21:47)</a>:</h4>
<p>But code relying on undefined behaviour is very susceptable to breakage in an LLVM update.</p>



<a name="277482133"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277482133" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277482133">(Apr 01 2022 at 21:47)</a>:</h4>
<p>Yes, I realize that's like<br>
an embarrassment of success.</p>



<a name="277482179"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277482179" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277482179">(Apr 01 2022 at 21:48)</a>:</h4>
<p><span class="user-mention" data-user-id="384014">@Patrick Walton</span> that statement is not incompatible with a small number of people having a large amount of code break on every release</p>



<a name="277482237"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277482237" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277482237">(Apr 01 2022 at 21:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277482127">said</a>:</p>
<blockquote>
<p>But code relying on undefined behaviour is very susceptable to breakage in an LLVM update.</p>
</blockquote>
<p>Honestly, not really. Pretty much every C++ codebase relies on UB in various ways and in general they continue to work.</p>



<a name="277482255"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277482255" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277482255">(Apr 01 2022 at 21:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="218745">Wanja Hentze</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277481992">said</a>:</p>
<blockquote>
<p>And there's no guarantees that the shenangigans end after we ban int2ptr. LLVM will continue to ship new bugs, shenanigans will continue to be necesssary</p>
</blockquote>
<p>Absolutely, but no one is trying to argue that adopting strict provenance will fix all our LLVM problems. We're trying to argue that the hand-wavey nature of LLVM's current approach is not actually a feasible solution</p>



<a name="277482285"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277482285" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277482285">(Apr 01 2022 at 21:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277482127">said</a>:</p>
<blockquote>
<p>But code relying on undefined behaviour is very susceptable to breakage in an LLVM update.</p>
</blockquote>
<p>And this is the nature of relying on undefined behaviour: Just because it works today does not mean a compiler won't be smarter tomorrow.</p>



<a name="277482299"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277482299" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277482299">(Apr 01 2022 at 21:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="295632">Diggsey</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277478365">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="384014">Patrick Walton</span> Having provenance is certainly more complicated to the programmer than not having it, but I do think that strict provenance is easier to understand <em>if you're going to have provenance at all</em></p>
</blockquote>
<p>The great thing here is: some programmers can just pretend that Rust has only strict provenance. Even if Rust in reality <em>also</em> permits more permissive provenance</p>



<a name="277482357"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277482357" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277482357">(Apr 01 2022 at 21:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277482299">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="295632">Diggsey</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277478365">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="384014">Patrick Walton</span> Having provenance is certainly more complicated to the programmer than not having it, but I do think that strict provenance is easier to understand <em>if you're going to have provenance at all</em></p>
</blockquote>
<p>The great thing here is: some programmers can just pretend that Rust has only strict provenance. Even if Rust in reality <em>also</em> permits more permissive provenance</p>
</blockquote>
<p>That doesn't help implementors, though.</p>



<a name="277482474"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277482474" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277482474">(Apr 01 2022 at 21:51)</a>:</h4>
<p>My belief is that the presence of a Rust model for proving certain things sound would allow strengthening LLVM's own models.</p>



<a name="277482483"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277482483" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277482483">(Apr 01 2022 at 21:51)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310518">Jak{e,ob} Degen</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277482255">said</a>:<br>
Absolutely, but no one is trying to argue that adopting strict provenance will fix all our LLVM problems. We're trying to argue that the hand-wavey nature of LLVM's current approach is not actually a feasible solution</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">I</span><span class="w"> </span><span class="n">mean</span><span class="p">,</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">clear</span><span class="p">,</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">we</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="n">nothing</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">all</span><span class="p">,</span><span class="w"> </span><span class="n">then</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">current</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">affairs</span><span class="p">,</span><span class="w"> </span><span class="n">which</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">Rust</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">fantastic</span><span class="w"> </span><span class="n">tool</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">massively</span><span class="w"> </span><span class="n">reducing</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="n">safety</span><span class="w"> </span><span class="n">problems</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">plague</span><span class="w"> </span><span class="n">C</span><span class="o">++</span><span class="w"> </span><span class="n">without</span><span class="w"> </span><span class="n">sacrificing</span><span class="w"> </span><span class="n">performance</span><span class="p">,</span><span class="w"> </span><span class="n">will</span><span class="w"> </span><span class="k">continue</span><span class="p">.</span><span class="w"></span>
</code></pre></div>



<a name="277482487"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277482487" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277482487">(Apr 01 2022 at 21:51)</a>:</h4>
<p>of which it does have some.</p>



<a name="277482529"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277482529" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277482529">(Apr 01 2022 at 21:51)</a>:</h4>
<p>I frankly do not see Rust as merely a better C++, sorry.</p>



<a name="277482600"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277482600" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277482600">(Apr 01 2022 at 21:52)</a>:</h4>
<p><span class="user-mention silent" data-user-id="384014">Patrick Walton</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277482064">said</a>:</p>
<blockquote>
<p>It is absolutely not true that everyone's code breaks all the time when upgrading LLVM. Linux distros regularly upgrade Clang and they work. Yes, there are pains, but in general the LLVM project does a great job of considering stakeholders, which is why it's been as successful as it has been.</p>
</blockquote>
<p>The problems that do arise are not unique to LLVM either. Watch a Fedora mass rebuild sometime and see all the pain a new GCC can cause...</p>



<a name="277482624"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277482624" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Boxy [she/her] <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277482624">(Apr 01 2022 at 21:52)</a>:</h4>
<p>the current state of affairs is a complete disaster where it is not _generally_ possible to write correct code ther are of course some cases where it is but so much is not specified..</p>



<a name="277482669"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277482669" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277482669">(Apr 01 2022 at 21:52)</a>:</h4>
<p>I also would like a well-specified rust model that doesn't handwave away important details that affect soundness, that I need to implement properly.</p>



<a name="277482670"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277482670" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277482670">(Apr 01 2022 at 21:52)</a>:</h4>
<p>The current state of affairs is not a complete disaster. It works well, which is why Rust has been so successful in the first place.</p>



<a name="277482682"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277482682" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Boxy [she/her] <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277482682">(Apr 01 2022 at 21:52)</a>:</h4>
<p>the status quo isnt "fine" the status quo is horrifiyng and completely undermines the entire "safety" promise of rust</p>



<a name="277482691"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277482691" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277482691">(Apr 01 2022 at 21:52)</a>:</h4>
<p>I can't implement "Things may be valid sometimes" properly.</p>



<a name="277482719"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277482719" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277482719">(Apr 01 2022 at 21:53)</a>:</h4>
<p>It's not horrifying. It's a huge improvement over C++.</p>



<a name="277482723"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277482723" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Boxy [she/her] <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277482723">(Apr 01 2022 at 21:53)</a>:</h4>
<p>if you are okay with relying on UB all the time and just rolling the dice that your stuff wont get miscompiled then enjoy that I guess but I would like to actually be writing correct code :/</p>



<a name="277482773"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277482773" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277482773">(Apr 01 2022 at 21:53)</a>:</h4>
<p>I'm OK with rolling the dice that my code won't be miscompiled. I have to do that anyway, because LLVM can have bugs.</p>



<a name="277482836"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277482836" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277482836">(Apr 01 2022 at 21:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="326176">Boxy [she/her]</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277482723">said</a>:</p>
<blockquote>
<p>if you are okay with relying on UB all the time and just rolling the dice that your stuff wont get miscompiled then enjoy that I guess but I would like to actually be writing correct code :/</p>
</blockquote>
<p>Especially true in the (possibly quite near) future.</p>



<a name="277482856"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277482856" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Boxy [she/her] <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277482856">(Apr 01 2022 at 21:54)</a>:</h4>
<p>Ok great then why are you in this conversation <span class="user-mention" data-user-id="384014">@Patrick Walton</span></p>



<a name="277482859"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277482859" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Boxy [she/her] <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277482859">(Apr 01 2022 at 21:54)</a>:</h4>
<p>like</p>



<a name="277482860"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277482860" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Boxy [she/her] <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277482860">(Apr 01 2022 at 21:54)</a>:</h4>
<p>just let us declare stuff UB?</p>



<a name="277482873"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277482873" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Boxy [she/her] <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277482873">(Apr 01 2022 at 21:54)</a>:</h4>
<p>hope things dont get miscompiled!</p>



<a name="277482874"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277482874" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277482874">(Apr 01 2022 at 21:54)</a>:</h4>
<p>In fact, miscompilations due to LLVM bugs are empirically significantly more common than miscompilations due to soundness issues in the LLVM model.</p>



<a name="277482880"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277482880" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Boxy [she/her] <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277482880">(Apr 01 2022 at 21:54)</a>:</h4>
<p>seems to be the status quo then</p>



<a name="277482890"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277482890" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277482890">(Apr 01 2022 at 21:54)</a>:</h4>
<p>When the semantics under discussion aren't just implemented by rustc-&gt;llvm</p>



<a name="277482973"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277482973" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277482973">(Apr 01 2022 at 21:55)</a>:</h4>
<p>Oh yeah, how does <code>gccrs</code>'s like backend compare with LLVM? Iirc it has many of the same issues.</p>



<a name="277482979"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277482979" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277482979">(Apr 01 2022 at 21:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="384014">Patrick Walton</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277482670">said</a>:</p>
<blockquote>
<p>The current state of affairs is not a complete disaster. It works well, which is why Rust has been so successful in the first place.</p>
</blockquote>
<p>Like, I can promise you that I will do my best to not miscompile your code. But at the same time, I see having a sound memory model as essentially a hard requirement for Rust, and I am not willing to give it up for anything else. We can certainly talk about the degree to which we try and work with people that don't adhere by it (for whatever reason), but I don't think this is relevant for this conversation</p>



<a name="277483044"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277483044" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277483044">(Apr 01 2022 at 21:56)</a>:</h4>
<p>I agree.</p>



<a name="277483087"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277483087" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277483087">(Apr 01 2022 at 21:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="326176">Boxy [she/her]</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277482860">said</a>:</p>
<blockquote>
<p>just let us declare stuff UB?</p>
</blockquote>
<p>Because one of the main effects of declaring things UB historically has been, and I believe would be in the future, to justify the implementation of MIR optimizations that would not be implementable today. Then a lot of code that used to work will no longer work.</p>



<a name="277483095"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277483095" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277483095">(Apr 01 2022 at 21:56)</a>:</h4>
<p>I've been pushing to see a spec for rust for the past year and a half, and a well-defined and well-behaved memory model is probably half of that.</p>



<a name="277483111"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277483111" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277483111">(Apr 01 2022 at 21:57)</a>:</h4>
<p>Here is the thing: there is still no formal (or even informal) spec for what's UB in Rust.<br>
There will still not be one once we ban int2ptr.<br>
As long as this is the case, there will be some uncertainty involved in writing unsafe Rust.</p>



<a name="277483125"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277483125" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277483125">(Apr 01 2022 at 21:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="384014">Patrick Walton</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277483087">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="326176">Boxy [she/her]</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277482860">said</a>:</p>
<blockquote>
<p>just let us declare stuff UB?</p>
</blockquote>
<p>Because one of the main effects of declaring things UB historically has been, and I believe would be in the future, to justify the implementation of MIR optimizations that would not be implementable today. Then a lot of code that used to work will no longer work.</p>
</blockquote>
<p>We can work on how much code this breaks. There are a huge amount of halfway solutions that can cover the vast majority of the problems</p>



<a name="277483135"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277483135" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277483135">(Apr 01 2022 at 21:57)</a>:</h4>
<p>But it is a total non-statement, in the context of <em>trying to come up with such a spec</em> to declare something "broken all along"</p>



<a name="277483136"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277483136" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277483136">(Apr 01 2022 at 21:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="384014">Patrick Walton</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277483087">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="326176">Boxy [she/her]</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277482860">said</a>:</p>
<blockquote>
<p>just let us declare stuff UB?</p>
</blockquote>
<p>Because one of the main effects of declaring things UB historically has been, and I believe would be in the future, to justify the implementation of MIR optimizations that would not be implementable today. Then a lot of code that used to work will no longer work.</p>
</blockquote>
<p>The effect of declaring things UB here is that we can define a better-specified memory model.</p>



<a name="277483150"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277483150" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277483150">(Apr 01 2022 at 21:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310518">Jak{e,ob} Degen</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277482979">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="384014">Patrick Walton</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277482670">said</a>:</p>
<blockquote>
<p>The current state of affairs is not a complete disaster. It works well, which is why Rust has been so successful in the first place.</p>
</blockquote>
<p>Like, I can promise you that I will do my best to not miscompile your code. But at the same time, I see having a sound memory model as essentially a hard requirement for Rust, and I am not willing to give it up for anything else. We can certainly talk about the degree to which we try and work with people that don't adhere by it (for whatever reason), but I don't think this is relevant for this conversation</p>
</blockquote>
<p>I never said I didn't want a sound memory model. There are many ways to have a sound memory model that involve, for example, more permissive, weaker forms of provenance. Those ways don't involve breaking existing code.</p>



<a name="277483218"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277483218" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277483218">(Apr 01 2022 at 21:58)</a>:</h4>
<p>And there are plenty of explanations why they don't work.</p>



<a name="277483241"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277483241" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277483241">(Apr 01 2022 at 21:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="218745">Wanja Hentze</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277483111">said</a>:</p>
<blockquote>
<p>Here is the thing: there is still no formal (or even informal) spec for what's UB in Rust.<br>
There will still not be one once we ban int2ptr.<br>
As long as this is the case, there will be some uncertainty involved in writing unsafe Rust.</p>
</blockquote>
<p>FWIW I would not want to normatively ban int2ptr without a very good understanding of the memory model that we will adopt</p>



<a name="277483310"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277483310" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277483310">(Apr 01 2022 at 21:59)</a>:</h4>
<p>PNVI-ae is the most practical one for rust, but it has some issues with rust.</p>



<a name="277483418"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277483418" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277483418">(Apr 01 2022 at 22:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277483218">said</a>:</p>
<blockquote>
<p>And there are plenty of explanations why they don't work.</p>
</blockquote>
<p>Strict provenance isn't required for soundness. You could easily imagine something like Wasm's model, where pointers have no provenance at all, and we do no optimizations based on aliasing, and we don't work on CHERI. I'm not arguing for such a model, but clearly it could exist and be sound.</p>



<a name="277483467"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277483467" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277483467">(Apr 01 2022 at 22:00)</a>:</h4>
<p>It could exist.</p>



<a name="277483520"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277483520" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277483520">(Apr 01 2022 at 22:01)</a>:</h4>
<p>And compilers could simply take the garbage input code that takes forever to run, and produce slow af binary that also takes forever to run, and have users complain the the compiled code is too slow.</p>



<a name="277483537"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277483537" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277483537">(Apr 01 2022 at 22:01)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277483520">said</a>:</p>
<blockquote>
<p>And compilers could simply take the garbage input code that takes forever to run, and produce slow af binary that also takes forever to run, and have users complain the the compiled code is too slow.</p>
</blockquote>
<p>Yes. But the implications of this aren't what you think they are.</p>



<a name="277483573"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277483573" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277483573">(Apr 01 2022 at 22:01)</a>:</h4>
<p>The implication of this is that the <em>unsound</em> model we have today is <em>practically</em> superior to either stacked borrows or the Wasm model.</p>



<a name="277483581"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277483581" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277483581">(Apr 01 2022 at 22:01)</a>:</h4>
<p>PNVI-ae however, has major buy-in with GCC and LLVM. It has a decent chance of becoming <em>the</em> provenance model</p>



<a name="277483632"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277483632" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277483632">(Apr 01 2022 at 22:02)</a>:</h4>
<p>Not superior in theory. But in practice, it's better.</p>



<a name="277483638"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277483638" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277483638">(Apr 01 2022 at 22:02)</a>:</h4>
<p>PNVI-ae w/o union provenance in rust is invalid.</p>



<a name="277483652"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277483652" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277483652">(Apr 01 2022 at 22:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="384014">Patrick Walton</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277483573">said</a>:</p>
<blockquote>
<p>The implication of this is that the <em>unsound</em> model we have today is <em>practically</em> superior to either stacked borrows or the Wasm model.</p>
</blockquote>
<p>Until a compiler exploits the unsound model.</p>



<a name="277483658"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277483658" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277483658">(Apr 01 2022 at 22:02)</a>:</h4>
<p>Now I don't want us to be unsound any more than anyone else, but I think we need to be clear about the tradeoffs here.</p>



<a name="277483665"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277483665" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277483665">(Apr 01 2022 at 22:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277483652">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="384014">Patrick Walton</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277483573">said</a>:</p>
<blockquote>
<p>The implication of this is that the <em>unsound</em> model we have today is <em>practically</em> superior to either stacked borrows or the Wasm model.</p>
</blockquote>
<p>Until a compiler exploits the unsound model.</p>
</blockquote>
<p>And the solution is for compilers to not do that.</p>



<a name="277483693"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277483693" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277483693">(Apr 01 2022 at 22:02)</a>:</h4>
<p>Ok, then tell me precisely what I cannot do.</p>



<a name="277483697"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277483697" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277483697">(Apr 01 2022 at 22:03)</a>:</h4>
<p>I cannot!</p>



<a name="277483707"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277483707" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277483707">(Apr 01 2022 at 22:03)</a>:</h4>
<p>That's what I'm trying to get across here.</p>



<a name="277483729"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277483729" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277483729">(Apr 01 2022 at 22:03)</a>:</h4>
<p>Then how do I know what optimizations not to apply?</p>



<a name="277483743"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277483743" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277483743">(Apr 01 2022 at 22:03)</a>:</h4>
<p>All of the things you can't do across (even an LTO) C call.</p>



<a name="277483760"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277483760" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277483760">(Apr 01 2022 at 22:03)</a>:</h4>
<p>The status quo is that adding optimizations to LLVM involves subjective judgement calls about what code we deem acceptable to break.</p>



<a name="277483764"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277483764" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277483764">(Apr 01 2022 at 22:03)</a>:</h4>
<p>How do I know what optimizations not to make architectural to xir?</p>



<a name="277483769"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277483769" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277483769">(Apr 01 2022 at 22:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277483729">said</a>:</p>
<blockquote>
<p>Then how do I know what optimizations not to apply?</p>
</blockquote>
<p>You don't that's the problem we're trying to solve</p>



<a name="277483843"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277483843" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277483843">(Apr 01 2022 at 22:04)</a>:</h4>
<p>This is bad! But I want to make sure that the cure that we propose is not worse than the disease.</p>



<a name="277483848"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277483848" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277483848">(Apr 01 2022 at 22:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="384014">Patrick Walton</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277483760">said</a>:</p>
<blockquote>
<p>The status quo is that adding optimizations to LLVM involves subjective judgement calls about what code we deem acceptable to break.</p>
</blockquote>
<p>This isn't llvm, which is part of the problem.</p>



<a name="277483854"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277483854" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277483854">(Apr 01 2022 at 22:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277483310">said</a>:</p>
<blockquote>
<p>PNVI-ae is the most practical one for rust, but it has some issues with rust.</p>
</blockquote>
<p>We <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277321304">talked about this with Ralf yesterday</a>. "pvni-ae" doesn't make any sense in the Rust context, but Stacked Borrows seems a pretty similar substitute that makes sense for Rust.</p>



<a name="277483871"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277483871" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277483871">(Apr 01 2022 at 22:04)</a>:</h4>
<p>Replace LLVM with MIR in this case.</p>



<a name="277483888"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277483888" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277483888">(Apr 01 2022 at 22:04)</a>:</h4>
<p>Nor MIR.</p>



<a name="277483923"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277483923" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277483923">(Apr 01 2022 at 22:05)</a>:</h4>
<p>I'm not working on rustc or it's tree at all, I have &lt;<a href="https://github.com/LightningCreations/lccc">https://github.com/LightningCreations/lccc</a>&gt;</p>



<a name="277483956"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277483956" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277483956">(Apr 01 2022 at 22:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="384014">Patrick Walton</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277483418">said</a>:</p>
<blockquote>
<p>You could easily imagine something like Wasm's model, where pointers have no provenance at all</p>
</blockquote>
<p>Please. I think we're all on the same page that no provenance means a really shitty compiler. For those who are not on this page, please read the FAQ here <a href="https://github.com/rust-lang/rust/issues/95228">https://github.com/rust-lang/rust/issues/95228</a></p>



<a name="277484000"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277484000" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277484000">(Apr 01 2022 at 22:06)</a>:</h4>
<p>We need provenance.</p>



<a name="277484074"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277484074" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277484074">(Apr 01 2022 at 22:06)</a>:</h4>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277483854">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277483310">said</a>:</p>
<blockquote>
<p>PNVI-ae is the most practical one for rust, but it has some issues with rust.</p>
</blockquote>
<p>We <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277321304">talked about this with Ralf yesterday</a>. "pvni-ae" doesn't make any sense in the Rust context, but Stacked Borrows seems a pretty similar substitute that makes sense for Rust.</p>
</blockquote>
<p>SB doesn't do anything with int2ptr casts, other than defining what happens when you do restore the provenance, IIRC.</p>



<a name="277484095"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277484095" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277484095">(Apr 01 2022 at 22:06)</a>:</h4>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277483956">said</a>:</p>
<blockquote>
<p>Please. I think we're all on the same page that no provenance means a really shitty compiler. For those who are not on this page, please read the FAQ here <a href="https://github.com/rust-lang/rust/issues/95228">https://github.com/rust-lang/rust/issues/95228</a></p>
</blockquote>
<p>I offered that only by way of argument, to illustrate that strict provenance isn't the only imaginable semantics that's sound.</p>



<a name="277484134"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277484134" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277484134">(Apr 01 2022 at 22:07)</a>:</h4>
<p>Yes, but I think it's not helpful for the discussion to mention unviable options</p>



<a name="277484146"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277484146" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277484146">(Apr 01 2022 at 22:07)</a>:</h4>
<p>Because then we start talking about unviable options</p>



<a name="277484148"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277484148" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277484148">(Apr 01 2022 at 22:07)</a>:</h4>
<p>Again, even with strict provenance this has to be valid (on non-CHERI) or Rust as a systems language breaks down:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">extern</span><span class="w"> </span><span class="s">"C"</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">fn</span> <span class="nf">ptrtoint</span><span class="p">(</span><span class="n">p</span>: <span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">fn</span> <span class="nf">inttoptr</span><span class="p">(</span><span class="n">p</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="kt">i32</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="k">fn</span> <span class="nf">example</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="fm">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">inttoptr</span><span class="p">(</span><span class="n">ptrtoint</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">)));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>So I don't think problems with backwards compatibility will be anywhere as bad as you think Patrick. There has to be an out for code that needs it/can't be ported.</p>



<a name="277484189"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277484189" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277484189">(Apr 01 2022 at 22:07)</a>:</h4>
<p>Also, miri's impl of PNVI-ae is unsound wrt. zero sized accesses.</p>



<a name="277484192"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277484192" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277484192">(Apr 01 2022 at 22:07)</a>:</h4>
<p>An "out" is what I've been arguing for this whole time :)</p>



<a name="277484216"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277484216" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277484216">(Apr 01 2022 at 22:07)</a>:</h4>
<p>It violates an actual documented rule of rust.</p>



<a name="277484295"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277484295" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277484295">(Apr 01 2022 at 22:08)</a>:</h4>
<p>(And it's a rule that is fairly integral to the soundness of pretty much all rust code)</p>



<a name="277484302"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277484302" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277484302">(Apr 01 2022 at 22:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484134">said</a>:</p>
<blockquote>
<p>Yes, but I think it's not helpful for the discussion to mention unviable options</p>
</blockquote>
<p>My point is simply that it doesn't have to be a binary "strict provenance" vs "unsound". At least, right now I don't see any reason why it does.</p>



<a name="277484333"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277484333" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277484333">(Apr 01 2022 at 22:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484074">said</a>:</p>
<blockquote>
<p>SB doesn't do anything with int2ptr casts, other than defining what happens when you do restore the provenance, IIRC.</p>
</blockquote>
<p>Not sure what you mean. SB is a definition for when int2ptr results in a valid pointer, and when it results in an invalid pointer.</p>



<a name="277484335"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277484335" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277484335">(Apr 01 2022 at 22:08)</a>:</h4>
<p>I think this thread has gotten so long, we've missed the point :P. But I don't think anyone is in disagreement that there will be some way to have int2ptr casts in some form, even if it's just because "we have to" and not because we want to.</p>



<a name="277484366"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277484366" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277484366">(Apr 01 2022 at 22:09)</a>:</h4>
<p><span class="user-mention" data-user-id="303115">@Quy Nguyen</span> strong disagree - we only need to support that for backwards compatibility, there's no need for that construct to exist <em>if we were starting from a blank slate</em></p>



<a name="277484375"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277484375" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277484375">(Apr 01 2022 at 22:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484333">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484074">said</a>:</p>
<blockquote>
<p>SB doesn't do anything with int2ptr casts, other than defining what happens when you do restore the provenance, IIRC.</p>
</blockquote>
<p>Not sure what you mean. SB is a definition for when int2ptr results in a valid pointer, and when it results in an invalid pointer.</p>
</blockquote>
<p>SB talks about what accesses a valid pointer can perform on certain memory.</p>



<a name="277484396"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277484396" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277484396">(Apr 01 2022 at 22:09)</a>:</h4>
<p>I have basically no objections against anything that isn't going to be used for MIR or LLVM optimizations.</p>



<a name="277484471"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277484471" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277484471">(Apr 01 2022 at 22:10)</a>:</h4>
<p><span class="user-mention" data-user-id="295632">@Diggsey</span> Correct, but the whole point here is we are not - Rust interops with C, and as much as I would love a Rust-only userland/libc/platofrm libraries (looks at Mustang), that is not the world we live in.</p>



<a name="277484474"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277484474" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277484474">(Apr 01 2022 at 22:10)</a>:</h4>
<p><span class="user-mention silent" data-user-id="303115">Quy Nguyen</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484335">said</a>:</p>
<blockquote>
<p>I think this thread has gotten so long, we've missed the point :P. But I don't think anyone is in disagreement that there will be some way to have int2ptr casts in some form, even if it's just because "we have to" and not because we want to.</p>
</blockquote>
<p>The important question is "what form" - the compiler is aware of them and tries not to break that code? <span aria-label="check" class="emoji emoji-2705" role="img" title="check">:check:</span> they become officially supported for any meaningful definition of "officially supported"? Ehhhh....</p>



<a name="277484479"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277484479" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277484479">(Apr 01 2022 at 22:10)</a>:</h4>
<p>If changes to declare things UB are just a formalism that means the vast majority of existing code, compiled on newer versions of rustc on x86-64, continues to work, then hey, no problem.</p>



<a name="277484502"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277484502" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277484502">(Apr 01 2022 at 22:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="384014">Patrick Walton</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484396">said</a>:</p>
<blockquote>
<p>I have basically no objections against anything that isn't going to be used for MIR or LLVM optimizations.</p>
</blockquote>
<p>What about optimizations from other implementations.</p>



<a name="277484507"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277484507" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277484507">(Apr 01 2022 at 22:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="384014">Patrick Walton</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484396">said</a>:</p>
<blockquote>
<p>I have basically no objections against anything that isn't going to be used for MIR or LLVM optimizations.</p>
</blockquote>
<p>On the other hand... you keep talking about how awesome the status quo of Rust is. No one is forcing you to update rustc</p>



<a name="277484520"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277484520" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277484520">(Apr 01 2022 at 22:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310518">Jak{e,ob} Degen</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484474">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="303115">Quy Nguyen</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484335">said</a>:</p>
<blockquote>
<p>I think this thread has gotten so long, we've missed the point :P. But I don't think anyone is in disagreement that there will be some way to have int2ptr casts in some form, even if it's just because "we have to" and not because we want to.</p>
</blockquote>
<p>The important question is "what form" - the compiler is aware of them and tries not to break that code? <span aria-label="check" class="emoji emoji-2705" role="img" title="check">:check:</span> they become officially supported for any meaningful definition of "officially supported"? Ehhhh....</p>
</blockquote>
<p>I should reiterate that <code>ptr as usize</code> is officially supported under the 1.0 compatibility promise, as it's a safe operation.</p>



<a name="277484535"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277484535" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277484535">(Apr 01 2022 at 22:11)</a>:</h4>
<p><span class="user-mention" data-user-id="303115">@Quy Nguyen</span> you said the absence of that would make Rust a non-starter for systems programming, which I disagree with. I want to continue to support that for backwards compatibility, but systems programming works just fine without ptr2int2ptr</p>



<a name="277484566"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277484566" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277484566">(Apr 01 2022 at 22:11)</a>:</h4>
<p>See <a class="stream-topic" data-stream-id="136281" href="/#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Use-cases.20for.20unrestricted.20ptr2int2ptr">#t-lang/wg-unsafe-code-guidelines &gt; Use-cases for unrestricted ptr2int2ptr</a></p>



<a name="277484577"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277484577" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277484577">(Apr 01 2022 at 22:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="384014">Patrick Walton</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484520">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="310518">Jak{e,ob} Degen</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484474">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="303115">Quy Nguyen</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484335">said</a>:</p>
<blockquote>
<p>I think this thread has gotten so long, we've missed the point :P. But I don't think anyone is in disagreement that there will be some way to have int2ptr casts in some form, even if it's just because "we have to" and not because we want to.</p>
</blockquote>
<p>The important question is "what form" - the compiler is aware of them and tries not to break that code? <span aria-label="check" class="emoji emoji-2705" role="img" title="check">:check:</span> they become officially supported for any meaningful definition of "officially supported"? Ehhhh....</p>
</blockquote>
<p>I should reiterate that <code>ptr as usize</code> is officially supported under the 1.0 compatibility promise, as it's a safe operation.</p>
</blockquote>
<p>Sure it is, but the semantics of it aren't necessarily fixed, wrt. to casting back and then using to access the memory.</p>



<a name="277484623"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277484623" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277484623">(Apr 01 2022 at 22:12)</a>:</h4>
<p>claiming to be a systems language and not having ptr2int2ptr is at best stretching the definition</p>



<a name="277484640"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277484640" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277484640">(Apr 01 2022 at 22:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="384014">Patrick Walton</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484520">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="310518">Jak{e,ob} Degen</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484474">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="303115">Quy Nguyen</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484335">said</a>:</p>
<blockquote>
<p>I think this thread has gotten so long, we've missed the point :P. But I don't think anyone is in disagreement that there will be some way to have int2ptr casts in some form, even if it's just because "we have to" and not because we want to.</p>
</blockquote>
<p>The important question is "what form" - the compiler is aware of them and tries not to break that code? <span aria-label="check" class="emoji emoji-2705" role="img" title="check">:check:</span> they become officially supported for any meaningful definition of "officially supported"? Ehhhh....</p>
</blockquote>
<p>I should reiterate that <code>ptr as usize</code> is officially supported under the 1.0 compatibility promise, as it's a safe operation.</p>
</blockquote>
<p>I mean... sure. But there is no obligation for the pointer to be dereferenceable</p>



<a name="277484655"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277484655" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277484655">(Apr 01 2022 at 22:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484577">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="384014">Patrick Walton</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484520">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="310518">Jak{e,ob} Degen</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484474">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="303115">Quy Nguyen</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484335">said</a>:</p>
<blockquote>
<p>I think this thread has gotten so long, we've missed the point :P. But I don't think anyone is in disagreement that there will be some way to have int2ptr casts in some form, even if it's just because "we have to" and not because we want to.</p>
</blockquote>
<p>The important question is "what form" - the compiler is aware of them and tries not to break that code? <span aria-label="check" class="emoji emoji-2705" role="img" title="check">:check:</span> they become officially supported for any meaningful definition of "officially supported"? Ehhhh....</p>
</blockquote>
<p>I should reiterate that <code>ptr as usize</code> is officially supported under the 1.0 compatibility promise, as it's a safe operation.</p>
</blockquote>
<p>Sure it is, but the semantics of it aren't necessarily fixed, wrt. to casting back and then using to access the memory.</p>
</blockquote>
<p>That is a ridiculously disingenuous abuse of the wording of any guarantee</p>



<a name="277484661"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277484661" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277484661">(Apr 01 2022 at 22:12)</a>:</h4>
<p>@Diggsey Sorry, I was little less than clear than I wanted to be on that statement. I'm basically saying that supporting it in <em>the exact form</em> I showed above has to happen, or else you can't interop with C, ergo, I wouldn't consider that a systems language.</p>



<a name="277484688"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277484688" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277484688">(Apr 01 2022 at 22:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="143798">Talchas</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484623">said</a>:</p>
<blockquote>
<p>claiming to be a systems language and not having ptr2int2ptr is at best stretching the definition</p>
</blockquote>
<p>At the same time, I'm definately getting close to agreeing that the semantics of "Restores the provenance of <code>ptr</code> from... uh... somewhere" is too handwavy to be sound fundamentally.</p>



<a name="277484695"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277484695" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277484695">(Apr 01 2022 at 22:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="143798">Talchas</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484655">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484577">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="384014">Patrick Walton</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484520">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="310518">Jak{e,ob} Degen</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484474">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="303115">Quy Nguyen</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484335">said</a>:</p>
<blockquote>
<p>I think this thread has gotten so long, we've missed the point :P. But I don't think anyone is in disagreement that there will be some way to have int2ptr casts in some form, even if it's just because "we have to" and not because we want to.</p>
</blockquote>
<p>The important question is "what form" - the compiler is aware of them and tries not to break that code? <span aria-label="check" class="emoji emoji-2705" role="img" title="check">:check:</span> they become officially supported for any meaningful definition of "officially supported"? Ehhhh....</p>
</blockquote>
<p>I should reiterate that <code>ptr as usize</code> is officially supported under the 1.0 compatibility promise, as it's a safe operation.</p>
</blockquote>
<p>Sure it is, but the semantics of it aren't necessarily fixed, wrt. to casting back and then using to access the memory.</p>
</blockquote>
<p>That is a ridiculously disingenuous abuse of the wording of any guarantee</p>
</blockquote>
<p>So is the "<code>ptr as usize</code> is safe code" thing. Presumably you're going to dereference that pointer later...</p>



<a name="277484719"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277484719" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277484719">(Apr 01 2022 at 22:13)</a>:</h4>
<p>Therefore, if you want to kill all optimizations, you could desugar casts to those function calls, and it would have to work / be an out for codebases.</p>



<a name="277484761"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277484761" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277484761">(Apr 01 2022 at 22:14)</a>:</h4>
<p>Oh wait, <code>ptr as usize</code>, not <code>usize as ptr</code>, I misread that</p>



<a name="277484762"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277484762" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277484762">(Apr 01 2022 at 22:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310518">Jak{e,ob} Degen</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484507">said</a>:</p>
<blockquote>
<p>On the other hand... you keep talking about how awesome the status quo of Rust is. No one is forcing you to update rustc</p>
</blockquote>
<p>The problem with not updating rustc is that you get stranded on earlier versions of the crate ecosystem, as newer versions of crates tend to require newer compiler versions. That's why, for example, I maintain an internal backport of rustc to LLVM 9, which we need for LTO, rather than just freezing our version of rustc at the last supported version that was compatible with LLVM 9.</p>



<a name="277484791"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277484791" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277484791">(Apr 01 2022 at 22:14)</a>:</h4>
<p>IIRC, there is no documentation anywhere that says what <code>p  as usize as *mut ()</code> yields a pointer that has the same validity as <code>p</code>.</p>



<a name="277484793"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277484793" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277484793">(Apr 01 2022 at 22:14)</a>:</h4>
<p>I mean, there's no problem with continuing to support all the safe uses of <code>ptr as usize</code>. We can just give it <code>.addr()</code> semantics and deprecate it in some edition</p>



<a name="277484831"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277484831" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277484831">(Apr 01 2022 at 22:15)</a>:</h4>
<p><span class="user-mention" data-user-id="384014">@Patrick Walton</span> why, did LLVM 10 break something? <span aria-label="stuck out tongue" class="emoji emoji-1f61b" role="img" title="stuck out tongue">:stuck_out_tongue:</span></p>



<a name="277484837"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277484837" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277484837">(Apr 01 2022 at 22:15)</a>:</h4>
<p>There isn't<br>
<span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484791">said</a>:</p>
<blockquote>
<p>IIRC, there is no documentation anywhere that says what <code>p  as usize as *mut ()</code> yields a pointer that has the same validity as <code>p</code>.</p>
</blockquote>
<p>There isn't, but in practice it tends to work and I think that "in practice it tends to work" should be considered in any decisions that we make.</p>



<a name="277484838"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277484838" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277484838">(Apr 01 2022 at 22:15)</a>:</h4>
<p>Yeah.</p>



<a name="277484865"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277484865" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277484865">(Apr 01 2022 at 22:15)</a>:</h4>
<p>See: <code>c-unwind</code></p>



<a name="277484866"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277484866" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277484866">(Apr 01 2022 at 22:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="281757">Jubilee</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277481779">said</a>:</p>
<blockquote>
<p>It is very frustrating to see what appears to be deliberate dismissal and downplaying of the rather large amount of work that it takes to keep up with LLVM's nonsense.</p>
</blockquote>
<p>I (and I think many others) recognize this. It's important to have some formal model, even if it doesn't reach all the way through FFI.</p>
<p>Which is why <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277358112">my standpoint</a> proposes adopting something like (plain) Stacked Borrows.</p>
<p>Question: would this help on the compiler side? Or does it actually help the compiler to outlaw permissive provenance?</p>



<a name="277484869"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277484869" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277484869">(Apr 01 2022 at 22:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="295632">Diggsey</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484831">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="384014">Patrick Walton</span> why, did LLVM 10 break something? <span aria-label="stuck out tongue" class="emoji emoji-1f61b" role="img" title="stuck out tongue">:stuck_out_tongue:</span></p>
</blockquote>
<p>The concerns about LLVM 10 weren't miscompilation but performance.</p>



<a name="277484879"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277484879" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277484879">(Apr 01 2022 at 22:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="384014">Patrick Walton</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484837">said</a>:</p>
<blockquote>
<p>There isn't<br>
<span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484791">said</a>:</p>
<blockquote>
<p>IIRC, there is no documentation anywhere that says what <code>p  as usize as *mut ()</code> yields a pointer that has the same validity as <code>p</code>.</p>
</blockquote>
<p>There isn't, but in practice it tends to work and I think that "in practice it tends to work" should be considered in any decisions that we make.</p>
</blockquote>
<p>It shouldn't be taken as an absolute, though.</p>



<a name="277484883"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277484883" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277484883">(Apr 01 2022 at 22:15)</a>:</h4>
<p>interesting</p>



<a name="277484937"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277484937" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277484937">(Apr 01 2022 at 22:16)</a>:</h4>
<p>I think that there shows that the Rust lang/lib team is more than willing  to understand that code that is currently working should not just be unilaterally broken.</p>



<a name="277484946"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277484946" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277484946">(Apr 01 2022 at 22:16)</a>:</h4>
<p>I can write some code that "in practice tends to work" right now, that involves relying on the layout of a repr(Rust) structure.</p>



<a name="277484959"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277484959" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277484959">(Apr 01 2022 at 22:16)</a>:</h4>
<p><span class="user-mention silent" data-user-id="384014">Patrick Walton</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484762">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="310518">Jak{e,ob} Degen</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484507">said</a>:</p>
<blockquote>
<p>On the other hand... you keep talking about how awesome the status quo of Rust is. No one is forcing you to update rustc</p>
</blockquote>
<p>The problem with not updating rustc is that you get stranded on earlier versions of the crate ecosystem, as newer versions of crates tend to require newer compiler versions. That's why, for example, I maintain an internal backport of rustc to LLVM 9, which we need for LTO, rather than just freezing our version of rustc at the last supported version that was compatible with LLVM 9.</p>
</blockquote>
<p>I mean... libraries are just as capable of exploiting UB as the compiler is. Are you going to fight all the library authors over their adoption of the Rust memory model too?</p>



<a name="277484973"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277484973" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277484973">(Apr 01 2022 at 22:16)</a>:</h4>
<p>Does that mean that the layout of repr(Rust) is <em>de facto</em> stable forever?</p>



<a name="277484978"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277484978" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277484978">(Apr 01 2022 at 22:17)</a>:</h4>
<p>In particular for something as simple as <code>p  as usize as *mut ()</code> there is no legitimate argument that it wasn't intended to work, and any lack of docs is "1.0 rust didn't have docs for tons and tons of things"</p>



<a name="277484999"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277484999" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277484999">(Apr 01 2022 at 22:17)</a>:</h4>
<p>(rust right now doesn't have docs for plenty of language things)</p>



<a name="277485006"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277485006" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Boxy [she/her] <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277485006">(Apr 01 2022 at 22:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484973">said</a>:</p>
<blockquote>
<p>Does that mean that the layout of repr(Rust) is <em>de facto</em> stable forever?</p>
</blockquote>
<p>YOu would hope not but in practice yes, did you see that we backed out on icnreasing the size of <code>TypeId</code> because people were doing a nice little bit of UB despite it being so clearly UB <span aria-label="face palm" class="emoji emoji-1f926" role="img" title="face palm">:face_palm:</span></p>



<a name="277485009"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277485009" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277485009">(Apr 01 2022 at 22:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310518">Jak{e,ob} Degen</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484959">said</a>:</p>
<blockquote>
<p>I mean... libraries are just as capable of exploiting UB as the compiler is. Are you going to fight all the library authors over their adoption of the Rust memory model too?</p>
</blockquote>
<p>It's perfectly valid to raise concerns about upstream library changes that in practice break code, yes.</p>



<a name="277485018"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277485018" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277485018">(Apr 01 2022 at 22:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484973">said</a>:</p>
<blockquote>
<p>Does that mean that the layout of repr(Rust) is <em>de facto</em> stable forever?</p>
</blockquote>
<p>Honestly? It might be, in at least some circumstances.</p>



<a name="277485024"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277485024" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277485024">(Apr 01 2022 at 22:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484973">said</a>:</p>
<blockquote>
<p>Does that mean that the layout of repr(Rust) is <em>de facto</em> stable forever?</p>
</blockquote>
<p>We've given a ~2-year deprecation period for crates assuming the internals of <code>IpAddr</code>.</p>



<a name="277485033"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277485033" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277485033">(Apr 01 2022 at 22:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="326176">Boxy [she/her]</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277485006">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484973">said</a>:</p>
<blockquote>
<p>Does that mean that the layout of repr(Rust) is <em>de facto</em> stable forever?</p>
</blockquote>
<p>YOu would hope not but in practice yes, did you see that we backed out on icnreasing the size of <code>TypeId</code> because people were doing a nice little bit of UB despite it being so clearly UB <span aria-label="face palm" class="emoji emoji-1f926" role="img" title="face palm">:face_palm:</span></p>
</blockquote>
<p>Oh joy. I can't wait to make TypeId sound.</p>



<a name="277485080"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277485080" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277485080">(Apr 01 2022 at 22:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484973">said</a>:</p>
<blockquote>
<p>Does that mean that the layout of repr(Rust) is <em>de facto</em> stable forever?</p>
</blockquote>
<p>That is at least explicitly spelled out to break arbitrarily, which considerably weakens the "happens to work" aspect of it.</p>



<a name="277485111"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277485111" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277485111">(Apr 01 2022 at 22:18)</a>:</h4>
<p>And have everyone that ever uses lccc complain that I broke their code relying on TypeId's layout.</p>



<a name="277485137"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277485137" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277485137">(Apr 01 2022 at 22:19)</a>:</h4>
<p>No snark: How many people are using lccc?</p>



<a name="277485138"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277485138" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277485138">(Apr 01 2022 at 22:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="384014">Patrick Walton</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277485009">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="310518">Jak{e,ob} Degen</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484959">said</a>:</p>
<blockquote>
<p>I mean... libraries are just as capable of exploiting UB as the compiler is. Are you going to fight all the library authors over their adoption of the Rust memory model too?</p>
</blockquote>
<p>It's perfectly valid to raise concerns about upstream library changes that in practice break code, yes.</p>
</blockquote>
<p>To be clear, if someone filed such an issue on my repo I would close it with a brief remark about not supporting UB</p>



<a name="277485153"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277485153" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277485153">(Apr 01 2022 at 22:19)</a>:</h4>
<p>Those kind of problems are the long tail of problems.</p>



<a name="277485197"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277485197" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277485197">(Apr 01 2022 at 22:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="303115">Quy Nguyen</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277485137">said</a>:</p>
<blockquote>
<p>No snark: How many people are using lccc?</p>
</blockquote>
<p>None yet (unless you count myself and the others working on it running the test suite), it's not yet complete.</p>



<a name="277485254"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277485254" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277485254">(Apr 01 2022 at 22:20)</a>:</h4>
<p>There are a bunch of specific areas where Rust has explicitly carved out forward-compat niches for itself, and repr(rust) is one of these.<br>
The provenance stuff is different because we never told people that ptr-int-ptr wouldn't work.</p>



<a name="277485269"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277485269" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277485269">(Apr 01 2022 at 22:20)</a>:</h4>
<p>Makes sense.</p>



<a name="277485308"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277485308" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277485308">(Apr 01 2022 at 22:21)</a>:</h4>
<p>And the "oral tradition" (which is the best you have in the face of an absent spec) of Rust's raw pointers has been that they work like they do in C</p>



<a name="277485317"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277485317" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277485317">(Apr 01 2022 at 22:21)</a>:</h4>
<p><span class="user-mention silent" data-user-id="218745">Wanja Hentze</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277485254">said</a>:</p>
<blockquote>
<p>There are a bunch of specific areas where Rust has explicitly carved out forward-compat niches for itself, and repr(rust) is one of these.<br>
The provenance stuff is different because we never told people that ptr-int-ptr wouldn't work.</p>
</blockquote>
<p>It's also carved out a soundness exemption.</p>



<a name="277485331"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277485331" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277485331">(Apr 01 2022 at 22:21)</a>:</h4>
<p>Where it can even break explicit guarantees to fix soundness issues.</p>



<a name="277485442"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277485442" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277485442">(Apr 01 2022 at 22:22)</a>:</h4>
<p>In the face of an absent spec, what is a soundness issue? That is not at all an easy question</p>



<a name="277485619"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277485619" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277485619">(Apr 01 2022 at 22:24)</a>:</h4>
<p>A soundness issue is an issue where code that has all preconditions satisified has undefined behaviour (this is an extension of what rust calls a soundness issue, "safe code causing UB", as safe code has all preconditions vacuously satisfied).</p>



<a name="277485653"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277485653" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277485653">(Apr 01 2022 at 22:24)</a>:</h4>
<p>You can break soundness issues into Implementation Soundness (miscompilation) and Fundmental Soundness.</p>



<a name="277485869"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277485869" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277485869">(Apr 01 2022 at 22:27)</a>:</h4>
<p>I would define a Fundmental Soundness issue as one that cannot be specified in a way that is sound.</p>



<a name="277485903"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277485903" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277485903">(Apr 01 2022 at 22:27)</a>:</h4>
<p>(And I'm leaning towards the current state of ptr2int2ptr falling into that category)</p>



<a name="277485994"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277485994" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277485994">(Apr 01 2022 at 22:28)</a>:</h4>
<p>At the very least, it's close to "Impossible to implement in a way that is sound", which is just as bad, if not worse.</p>



<a name="277486145"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277486145" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277486145">(Apr 01 2022 at 22:30)</a>:</h4>
<p>I agree that the formal text of the 1.0 compatibility promise allows us to break ptr to int to ptr as much as we want, but I believe that actually doing that (for example, by declaring that all ptr to int to ptr casts are UB and doing MIR optimizations that break code relying on it) violates its spirit, because it causes a lot of practical problems for Rust's users of the kind that motivated the 1.0 compatibility promise to begin with.</p>



<a name="277486304"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277486304" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277486304">(Apr 01 2022 at 22:32)</a>:</h4>
<p>Breaking some uses of ptr-&gt;int-&gt;ptr would be fine as long as they don't impact too much code and/or can be done with a deprecation period. I know that's fuzzy and subjective, but, well, it's engineering.</p>



<a name="277486365"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277486365" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277486365">(Apr 01 2022 at 22:33)</a>:</h4>
<p>Also I don't think anyone cares if ptr-&gt;int-&gt;ptr is completely banned on CHERI architectures, since there's no legacy to worry about on them.</p>



<a name="277486499"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277486499" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277486499">(Apr 01 2022 at 22:35)</a>:</h4>
<p>I'm still waiting for any reason to make Rust strict-provenance-<strong>only</strong>.</p>



<a name="277487044"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277487044" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277487044">(Apr 01 2022 at 22:42)</a>:</h4>
<p>The main problem with discussing this tradeoff perf-wise is that what optimizations we gain by memory model X compared to memory model Y cannot assume all else equal. For example, we knowing going looser than C kills a bunch of optimizations that we would really rather have, but how strict do we have to go for a good strict/perf ratio is not really answerable. Even if we have strict provenance, I'm fairly confident that there will still be more work on making PNVI-ae-udi better and more optimizable simply due to the resources involved.</p>



<a name="277487256"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277487256" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277487256">(Apr 01 2022 at 22:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310518">Jak{e,ob} Degen</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277473168">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277472874">said</a>:</p>
<blockquote>
<p>I believe there is consensus that pointer-to-int <strong>transmute</strong> cannot work and has to break. Even though pointer-to-int <em>conversions</em> like <code>ptr as usize</code> would still work. And we believe that very little code in practice uses such transmutes</p>
</blockquote>
<p>I think there's no such consensus. I pointed out a way that the transmutes could actually work (just not broadcast), and someone on the issue said they believed that the transmutes are actually common enough to be a problem</p>
</blockquote>
<p>I don't know of a way to salvage that common code I am afraid. Your proposal does not help with that since that code assumes it can transmute the ptrs to ints and back 'unharmed', whereas your proposal produces pointers with invalid provenance.<br>
There <em>is</em> an alternative though that code can migrate to, transmute to <code>MaybeUninit&lt;int&gt;</code>. if you dont know whether your data contains pointers, you probably also dont know whether it contains padding, and then you should use MaybeUninit anyway.</p>



<a name="277487329"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277487329" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277487329">(Apr 01 2022 at 22:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="143798">Talchas</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277477720">said</a>:</p>
<blockquote>
<p>yeah, SB's baseline complexity is high, and as far as I've heard strict provenance wouldn't let you rip out any of the complexity of the raw pointer handling parts</p>
</blockquote>
<p>it lets us rip out <code>Untagged</code>. That's quite a big win IMO.</p>



<a name="277487503"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277487503" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277487503">(Apr 01 2022 at 22:49)</a>:</h4>
<p>Is it? I thought in a different place you said we hardly get additional optimizations without <code>Untagged</code></p>



<a name="277487530"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277487530" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277487530">(Apr 01 2022 at 22:49)</a>:</h4>
<p>But maybe that was someone else's understanding</p>



<a name="277487996"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277487996" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277487996">(Apr 01 2022 at 22:54)</a>:</h4>
<p>I had an idea for a set of guidelines to avoid future optimizations breaking code.</p>



<a name="277488069"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277488069" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277488069">(Apr 01 2022 at 22:55)</a>:</h4>
<p>Strawperson proposal: Any new MIR optimization that relies on strict provenance to be sound must be (1) intraprocedural; (2) disable itself if the function it's optimizing uses <code>ptr as usize</code> or <code>usize as ptr</code>.</p>



<a name="277488191"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277488191" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277488191">(Apr 01 2022 at 22:56)</a>:</h4>
<p>Intraprocedural requirement is there to ensure that a function-local check for int-to-ptr or ptr-to-int is sufficient, because an intraprocedural optimization by definition only looks at a single function and has to be sound regardless of what the rest of the program does.</p>



<a name="277488269"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277488269" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277488269">(Apr 01 2022 at 22:57)</a>:</h4>
<p>Of course, inlining converts intraprocedural optimizations to interprocedural ones. This is fine, because the conservative check for int-to-ptr and ptr-to-int casts remains sound if performed after inlining.</p>



<a name="277488401"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277488401" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277488401">(Apr 01 2022 at 22:59)</a>:</h4>
<p>This assumes that ptr2int and int2ptr transmutes become UB. If this is a problem in practice we could allowlist direct calls to <code>mem::transmute</code> or do some other sort of hack, but hopefully it won't be an issue.</p>



<a name="277488448"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277488448" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277488448">(Apr 01 2022 at 23:00)</a>:</h4>
<p>I think that's a bit of a conservative check, but "vibes-wise" it makes sense</p>



<a name="277488454"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277488454" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277488454">(Apr 01 2022 at 23:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="384014">Patrick Walton</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277479339">said</a>:</p>
<blockquote>
<p>For the most part, this is the model that C++ programmers have in their head when writing code and it generally works.</p>
</blockquote>
<p>I have to admit I am surprised how well it works, yes. the fact that computers do anything at all is astounding.<br>
But to my knowledge, there is no rigorous reason for why it works. it's being held together by sweat, blood and tears (of many compiler devs) and it's impossible to say if any change you want to make breaks the world because there is not even a coherent contract that 'the world' relies on.<br>
I think we can do better. I think we can actually have a coherent contract on which we can build a real-world systems programming language. I think Rust can do that. I hope programmers consider this sufficiently valuable that they are willing to adjust how they write programs -- e.g., using arrays of <code>MaybeUninit&lt;u8&gt;</code> (instead of <code>u8</code>) to hold arbitrary data. Rust makes me hopeful because Rust already asks a lot from programmers (fighting the borrow checker is a meme!) and yet people go with it because it brings them value. I think there is value in knowing that there is a rigorous contract that underpins Rust and if you follow that contract you dont have to enter the twilight zone that is "just hoping that the compiler doesn't see my crimes and break my code", and I hope programmers agree.<br>
including ptr-int-ptr roundtrips in that contract is very feasible I think <em>if</em> it is okay that programs using them are not going to get the full benefits of tools like Miri (or they might not run at all). I hope large swaths of the ecosystem will not have to resort to this as otherwise Miri would become a lot less useful. including ptr-to-int transmutes is a lot harder and I don't have good ideas here.</p>
<p>but maybe that is a pipe dream, and maybe parts of Rust will never have a rigorous contract and we'll have to continue using sweat, blood, and tears to hold those parts together. but then we can at least have a safe heaven called 'strict provenance' and know that <em>that part</em> is safe from the daemons.</p>



<a name="277488522"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277488522" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277488522">(Apr 01 2022 at 23:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277488448">said</a>:</p>
<blockquote>
<p>I think that's a bit of a conservative check, but "vibes-wise" it makes sense</p>
</blockquote>
<p>Yeah, this is a baseline known-good proposal.</p>



<a name="277488531"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277488531" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277488531">(Apr 01 2022 at 23:00)</a>:</h4>
<p>We could loosen it over time.</p>



<a name="277488571"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277488571" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277488571">(Apr 01 2022 at 23:01)</a>:</h4>
<p>Also, such optimizations are free to always run on CHERI (though ptr-to-int/int-to-ptr might not even be supported at all there).</p>



<a name="277488575"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277488575" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277488575">(Apr 01 2022 at 23:01)</a>:</h4>
<p>I don't think we're in any position to set red lines right now, even though I understand that you would like peace of mind</p>



<a name="277488592"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277488592" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277488592">(Apr 01 2022 at 23:01)</a>:</h4>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277487503">said</a>:</p>
<blockquote>
<p>Is it? I thought in a different place you said we hardly get additional optimizations without <code>Untagged</code></p>
</blockquote>
<p>it's a big win in complexity and coherence. e.g. a masters student tried to develop a reasonable logic to verify correctness of programs written against stacked borrows and <code>untagged</code> kind of broke everything.</p>



<a name="277488607"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277488607" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277488607">(Apr 01 2022 at 23:01)</a>:</h4>
<p>IMO one of the most important things to get right now, _the_ most important thing to get right now, is closer to a formal model</p>



<a name="277488649"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277488649" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277488649">(Apr 01 2022 at 23:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="384014">Patrick Walton</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277488191">said</a>:</p>
<blockquote>
<p>Intraprocedural requirement is there to ensure that a function-local check for int-to-ptr or ptr-to-int is sufficient, because an intraprocedural optimization by definition only looks at a single function and has to be sound regardless of what the rest of the program does.</p>
</blockquote>
<p>intraprocedural gets fuzzy when you deal with inlining.</p>



<a name="277488685"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277488685" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277488685">(Apr 01 2022 at 23:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277488649">said</a>:</p>
<blockquote>
<p>intraprocedural gets fuzzy when you deal with inlining.</p>
</blockquote>
<p>Note my comment about inlining -- if the check is done post-inlining then it should be sound by construction.</p>



<a name="277488692"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277488692" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277488692">(Apr 01 2022 at 23:03)</a>:</h4>
<p>Yes. Besides "makes sense vibes-wise" I'm not convinced that it's <em>a useful red line</em></p>



<a name="277488737"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277488737" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277488737">(Apr 01 2022 at 23:03)</a>:</h4>
<p>It'd be extremely useful for me to have at least loose consensus that this is the way forward.</p>



<a name="277488802"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277488802" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277488802">(Apr 01 2022 at 23:04)</a>:</h4>
<p>In practice these sorts of optimizations are all intraprocedural anyway because of compile time concerns.</p>



<a name="277488810"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277488810" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277488810">(Apr 01 2022 at 23:04)</a>:</h4>
<p><span class="user-mention" data-user-id="384014">@Patrick Walton</span> I dont even know of a useful MIR optimization that relies on strict provenance being sound.^^<br>
OTOH, I would <em>not</em> put my hand in the fire to promise that the LLVM we create is sound without strict provenance... compatibility with LLVM is certainly a lot easier under strict provenance. (though some issue remain open, like carrying provenance through iN types but also doing GVN on iN types...)</p>



<a name="277488842"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277488842" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277488842">(Apr 01 2022 at 23:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277488810">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="384014">Patrick Walton</span> I dont even know of a useful MIR optimization that relies on strict provenance being sound.^^</p>
</blockquote>
<p>Dead load/dead store elimination? GVN?</p>



<a name="277488882"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277488882" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277488882">(Apr 01 2022 at 23:06)</a>:</h4>
<p>GVN on pointers is cursed and never okay, not even under strict provenance. GVN on integers should be fine under any model, it's other things that are broken.</p>



<a name="277488960"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277488960" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277488960">(Apr 01 2022 at 23:06)</a>:</h4>
<p>dead load/store elimination is only a problem if you want to allow code like <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/286#issuecomment-1085144431">https://github.com/rust-lang/unsafe-code-guidelines/issues/286#issuecomment-1085144431</a></p>



<a name="277489017"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277489017" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277489017">(Apr 01 2022 at 23:07)</a>:</h4>
<p>IOW, if you accept that ptr2int transmutes are UB, dead load/store elim is fine</p>



<a name="277489129"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277489129" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277489129">(Apr 01 2022 at 23:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="384014">Patrick Walton</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277488737">said</a>:</p>
<blockquote>
<p>It'd be extremely useful for me to have at least loose consensus that this is the way forward.</p>
</blockquote>
<p>In my view you can feel safe that Rust (the language + compiler) will continue to support permissive provenance for a very long time ‚Äî with probably slightly better codegen when all code is strict-provenance. But it's not helpful to formalize this as constraints of the code of rustc at this point, that's just too low-level.</p>
<p>It's not just your employer that wants permissive provenance for legacy code, it reduces the applicability of Rust in general IMO</p>



<a name="277489161"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277489161" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277489161">(Apr 01 2022 at 23:09)</a>:</h4>
<p>you also have to accept that ptr2int casts <em>do</em> have side-effects. LLVM doesn't accept that so until it does we might get weird breakage there. but I no longer think we should let that affect our Rust model. rather we should lobby for LLVM to accept this. this might only happen after actual code breaks in the wild, but that's at least no worse than how we currently do things...</p>



<a name="277489181"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277489181" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277489181">(Apr 01 2022 at 23:09)</a>:</h4>
<p><em>sigh at LLVM</em></p>



<a name="277489194"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277489194" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277489194">(Apr 01 2022 at 23:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277489129">said</a>:</p>
<blockquote>
<p>It's not just your employer that wants permissive provenance for legacy code, it reduces the applicability of Rust in general IMO</p>
</blockquote>
<p>Yep. I'm very aware that I'm probably speaking for many others here, but I can only say <em>for sure</em> about the code I work with, so I've limited to that to avoid saying anything that I don't know to be true.</p>



<a name="277489201"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277489201" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277489201">(Apr 01 2022 at 23:09)</a>:</h4>
<p>How is LLVM intending to support pnvi-ae, then?</p>



<a name="277489220"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277489220" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277489220">(Apr 01 2022 at 23:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277489201">said</a>:</p>
<blockquote>
<p>How is LLVM intending to support pnvi-ae, then?</p>
</blockquote>
<p>I dont know. I might not be up-to-date on that.</p>



<a name="277489282"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277489282" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277489282">(Apr 01 2022 at 23:10)</a>:</h4>
<p>also, PNVI-ae <em>might</em>  be soundly compilable to twinsem, which <em>does</em> make ptr2int side-effect-free</p>



<a name="277489303"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277489303" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277489303">(Apr 01 2022 at 23:10)</a>:</h4>
<p>just because PNVI-ae says casts have side-effects, doesnt mean the IR needs to do that. the IR just needs to have less UB than PNVI-ae.</p>



<a name="277489310"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277489310" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277489310">(Apr 01 2022 at 23:10)</a>:</h4>
<p>and since PNVI-ae ignores <code>restrict</code>, this <em>might</em> work</p>



<a name="277489324"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277489324" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277489324">(Apr 01 2022 at 23:11)</a>:</h4>
<p>it all falls apart with <code>restrict</code> though</p>



<a name="277489331"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277489331" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277489331">(Apr 01 2022 at 23:11)</a>:</h4>
<p>Patrick, I explicitly call out "pointer in u32" in <a href="https://hackmd.io/I-zHe9bZTJOY78orP1aYIA?view">my position</a> as an example of <del>something I want to keep supporting</del> why I want to keep supporting permissive provenance. Because it's documented that people actually do this</p>



<a name="277489375"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277489375" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277489375">(Apr 01 2022 at 23:11)</a>:</h4>
<p>Ooh. Twinsem could be a very interesting paper to read ‚Äî another time, though</p>



<a name="277489457"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277489457" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277489457">(Apr 01 2022 at 23:12)</a>:</h4>
<p>It feels like the LLVM people are simply still in denial of reality.</p>



<a name="277489485"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277489485" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277489485">(Apr 01 2022 at 23:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277489331">said</a>:</p>
<blockquote>
<p>Patrick, I explicitly call out "pointer in u32" in <a href="https://hackmd.io/I-zHe9bZTJOY78orP1aYIA?view">my position</a> as an example of <del>something I want to keep supporting</del> why I want to keep supporting permissive provenance. Because it's documented that people actually do this</p>
</blockquote>
<p>Yeah, I certainly won't complain if y'all end up going with a weaker provenance model even for new code :)</p>



<a name="277489704"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277489704" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277489704">(Apr 01 2022 at 23:17)</a>:</h4>
<p>so I think we have 3 layers here:</p>
<ul>
<li>strict provenance:  no ptr2int2ptr casts nor ptr2int transmutes. coherent models are fairly easy to define (as in, the fact that we have integer casts puts zero additional burden on the memory model -- it's 'only' the actual complexity of handling the aliasing contraints), Miri can run your code, CHERI is happy. we also avoid some of the incoherence of LLVM. <span aria-label="sunny" class="emoji emoji-2600" role="img" title="sunny">:sunny:</span> </li>
<li>permissive provenance: ptr2int2ptr is allowed, but no ptr2int transmutes. ptr2int casts <em>do</em> have a side-effect, which LLVM fails to acknowledge so that's "fun" but whatever. (int2ptr casts also might be impure in other ways.) the memory model becomes more complicated but I think this is always possible in a generic way ("guess a suitable exposed provenance at int2ptr time, if any guess can work your program is fine"). this model is not realistically implementable in Miri though. seems very reasonable to guarantee that we will not miscompile these programs but we won't be held liable for LLVM's bugs ;) . <span aria-label="rainy" class="emoji emoji-1f327" role="img" title="rainy">:rainy:</span> </li>
<li>yolo provenance: ptr2int transmutes allowed. I dont know what's going on. I wouldnt be willing to guarantee anything about these programs, though I guess we can still do a best effort thing to not break them too much maybe? it's hard to say. <span aria-label="thunderstorm" class="emoji emoji-26c8" role="img" title="thunderstorm">:thunderstorm:</span> <span aria-label="explosion" class="emoji emoji-1f4a5" role="img" title="explosion">:explosion:</span> <span aria-label="fire" class="emoji emoji-1f525" role="img" title="fire">:fire:</span></li>
</ul>



<a name="277489812"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277489812" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277489812">(Apr 01 2022 at 23:18)</a>:</h4>
<blockquote>
<p>this model is not realistically implementable in Miri though</p>
</blockquote>
<p>Can you elaborate? I was under the impression that plain Stacked Borrows is permissive provenance</p>



<a name="277489836"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277489836" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277489836">(Apr 01 2022 at 23:19)</a>:</h4>
<p>"this model" refers specifically to "guess a suitable exposed provenance at int2ptr time, if any guess can work your program is fine". that's not what Stacked Borrows with <code>untagged</code> does.</p>



<a name="277489927"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277489927" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277489927">(Apr 01 2022 at 23:20)</a>:</h4>
<p>this is a <em>generic</em> way to turn any strict provenance model into a permissive provenance model. (I think.) it relies on angelic non-determinism so it might confuse people a lot...<br>
there are other ways to achieve permissive provenance models, like what plain SB does. but what plain SB does here has issues that I don't know how to fix so I am not hopeful about that avenue.</p>



<a name="277489949"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277489949" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277489949">(Apr 01 2022 at 23:21)</a>:</h4>
<p>Thanks Ralf, that's very helpful!</p>



<a name="277490064"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277490064" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277490064">(Apr 01 2022 at 23:22)</a>:</h4>
<p>I think it's still worth thinking about keeping hacks like "special case direct calls to <code>mem::transmute</code> that really just <code>ptr as int</code> written in a different way" in our back pocket. I'm definitely not advocating using those hacks without data showing that they will bring benefit, but they're worth thinking about if adding some targeted hacks like this would make more existing code strict-provenance-compatible.</p>



<a name="277490125"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277490125" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277490125">(Apr 01 2022 at 23:23)</a>:</h4>
<p>yeah such hacks are always an option. we could literally say that on old editions, such a <code>transmute</code> generates the cast during MIR building...</p>



<a name="277490132"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277490132" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277490132">(Apr 01 2022 at 23:23)</a>:</h4>
<p>Yep</p>



<a name="277490200"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277490200" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277490200">(Apr 01 2022 at 23:24)</a>:</h4>
<p>if we keep this in the frontend before MIR then our optimizations and backends wouldnt even have to be aware of them so I could live with that rather well</p>



<a name="277490216"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277490216" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277490216">(Apr 01 2022 at 23:24)</a>:</h4>
<p>but that wont help for code that transmutes large structs that contain pointers, into arrays of integers</p>



<a name="277490249"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277490249" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277490249">(Apr 01 2022 at 23:25)</a>:</h4>
<p><span class="user-mention" data-user-id="465167">@Bram Geron</span> could I get you to include something like what I wrote above into the summary? :D not sure how coherent it is with your understanding</p>



<a name="277490255"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277490255" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277490255">(Apr 01 2022 at 23:25)</a>:</h4>
<p>Yeah, definitely not a comprehensive solution, but if we can do little targeted things then it could go a long way toward easing the pain.</p>



<a name="277490275"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277490275" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277490275">(Apr 01 2022 at 23:26)</a>:</h4>
<p>sounds plausible</p>



<a name="277490314"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277490314" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277490314">(Apr 01 2022 at 23:26)</a>:</h4>
<p>I keep thinking about how JavaScript clawed lexical scoping out by observing that people never rename the function <code>eval</code> and special casing functions that are spelled e-v-a-l in the semantics.</p>



<a name="277490323"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277490323" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277490323">(Apr 01 2022 at 23:26)</a>:</h4>
<p>Truly evil, but saved JS from a world of hurt.</p>



<a name="277490345"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277490345" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277490345">(Apr 01 2022 at 23:26)</a>:</h4>
<p>So, what Ralf wrote looks good to me, the one thing I am worried about is this:</p>
<blockquote>
<p>seems very reasonable to guarantee that we will not miscompile these programs</p>
</blockquote>
<p>Depending on what you mean by <em>guarantee</em> that might be just a little too strong for me. For example, I would like to have a spec that declares such code UB, because I think future implementations should make use of that. That being said, if this means "we consider miscompilations of this form that we introduce bugs in rustc," I would be perfectly content with that - maybe under the additional condition that they affect real world code and not just pathological examples</p>



<a name="277490358"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277490358" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277490358">(Apr 01 2022 at 23:27)</a>:</h4>
<p>I should emphasize how stoked I am about strict provenance because that is what (for me) made it possible to seriously consider the "guess a suitable exposed provenance at int2ptr time, if any guess can work your program is fine" angelic-nondeterminism kind of model for ptr2int2ptr. previously I ruled that out because of Miri, but if we can actually get almost all (new) Rust code to not need ptr2int2ptr roundtrips, this becomes much less of a concern.</p>



<a name="277490430"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277490430" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277490430">(Apr 01 2022 at 23:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310518">Jak{e,ob} Degen</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277490345">said</a>:</p>
<blockquote>
<p>So, what Ralf wrote looks good to me, the one thing I am worried about is this:</p>
<blockquote>
<p>seems very reasonable to guarantee that we will not miscompile these programs</p>
</blockquote>
<p>Depending on what you mean by <em>guarantee</em> that might be just a little too strong for me. For example, I would like to have a spec that declares such code UB, because I think future implementations should make use of that. That being said, if this means "we consider miscompilations of this form that we introduce bugs in rustc," I would be perfectly content with that - maybe under the additional condition that they affect real world code and not just pathological examples</p>
</blockquote>
<p>I explicitly do <em>not</em> want to declare such code UB because if I do Patrick will hire some assassins to come get me ;)</p>



<a name="277490437"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277490437" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277490437">(Apr 01 2022 at 23:28)</a>:</h4>
<p>lmao</p>



<a name="277490451"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277490451" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277490451">(Apr 01 2022 at 23:29)</a>:</h4>
<p>and because I am not convinced that there is much benefit to declaring them UB</p>



<a name="277490457"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277490457" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277490457">(Apr 01 2022 at 23:29)</a>:</h4>
<p>Will he? I assumed his concern was mostly with keeping existing code working, and if that's something we can do...</p>



<a name="277490470"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277490470" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277490470">(Apr 01 2022 at 23:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277490451">said</a>:</p>
<blockquote>
<p>and because I am not convinced that there is much benefit to declaring them UB</p>
</blockquote>
<p>This is a fair separate issue. This would need to be investigated, and if indeed it doesn't get us anything than I don't mind either</p>



<a name="277490476"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277490476" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277490476">(Apr 01 2022 at 23:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277490249">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> could I get you to include something like what I wrote above into the summary? :D not sure how coherent it is with your understanding</p>
</blockquote>
<p>In principle yes, but I would much much rather have that Rust adopts a formal model that <em>includes</em> permissive provenance. Perhaps a supermodel of a strict-provenance model, with fewer optimizations, and conditions for those "missing optimizations" so that we can just shut off the optimizations when they don't apply (as Patrick has attempted to suggest)</p>



<a name="277490479"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277490479" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277490479">(Apr 01 2022 at 23:29)</a>:</h4>
<p>well so far I think zero examples have been brought up of such optimizations :)</p>



<a name="277490551"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277490551" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277490551">(Apr 01 2022 at 23:30)</a>:</h4>
<p>Well, yes, but there is also an imbalance here - we have tested a lot of code under MIRI to find problems with writing code against the model, there is not one SB specific optimizations to figure out what kind of problems <em>that</em> runs into</p>



<a name="277490555"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277490555" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277490555">(Apr 01 2022 at 23:30)</a>:</h4>
<p>If no good model for permissive-provenance exists, then I would like to understand the details of that more before I make it my position</p>



<a name="277490572"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277490572" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277490572">(Apr 01 2022 at 23:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277490476">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277490249">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> could I get you to include something like what I wrote above into the summary? :D not sure how coherent it is with your understanding</p>
</blockquote>
<p>In principle yes, but I would much much rather have that Rust adopts a formal model that <em>includes</em> permissive provenance. Perhaps a supermodel of a strict-provenance model, with fewer optimizations, and conditions for those "missing optimizations" so that we can just shut off the optimizations when they don't apply (as Patrick has attempted to suggest)</p>
</blockquote>
<p>yes that's what I said I think? I suggested we guarantee that rustc does not miscompile permissive provenance programs. that means that this is our ultimate formal model, our spec. we might just spec the strict provenance subset first as that's easier.</p>



<a name="277490575"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277490575" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277490575">(Apr 01 2022 at 23:31)</a>:</h4>
<p>But I have a constraint ‚Äî which is my eyelid are slowly starting to fall shut</p>



<a name="277490594"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277490594" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277490594">(Apr 01 2022 at 23:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277490572">said</a>:</p>
<blockquote>
<p>I suggested we guarantee that rustc does not miscompile permissive provenance programs. that means that this is our ultimate formal model, our spec. we might just spec the strict provenance subset first as that's easier.</p>
</blockquote>
<p>Ah! <span aria-label="raised hands" class="emoji emoji-1f64c" role="img" title="raised hands">:raised_hands:</span> <span aria-label="raised hands" class="emoji emoji-1f64c" role="img" title="raised hands">:raised_hands:</span> <span aria-label="raised hands" class="emoji emoji-1f64c" role="img" title="raised hands">:raised_hands:</span></p>



<a name="277490600"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277490600" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277490600">(Apr 01 2022 at 23:31)</a>:</h4>
<p>so, not even fewer optimizations or so</p>



<a name="277490601"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277490601" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277490601">(Apr 01 2022 at 23:31)</a>:</h4>
<p>In general I definitely like this approach, kudos to Ralf for putting it forward</p>



<a name="277490651"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277490651" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277490651">(Apr 01 2022 at 23:32)</a>:</h4>
<p>in this vision, strict provenance exists as a sublanguage that is useful for miri and cheri and friends (and easier specs), but absolutely irrelevant for rustc</p>



<a name="277490699"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277490699" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277490699">(Apr 01 2022 at 23:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="384014">Patrick Walton</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277490601">said</a>:</p>
<blockquote>
<p>In general I definitely like this approach, kudos to Ralf for putting it forward</p>
</blockquote>
<p>okay that is good to hear. :) I am still very worried about the ptr2int transmute ban. even if we add frontend hacks like you suggested.</p>



<a name="277490710"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277490710" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277490710">(Apr 01 2022 at 23:34)</a>:</h4>
<p>Works for me. We can always reopen the discussion if we come up with MIR optzns we'd like to do that require some stricter level of provenance.</p>



<a name="277490769"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277490769" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277490769">(Apr 01 2022 at 23:34)</a>:</h4>
<p>so you'd sign off on <a href="https://github.com/rust-lang/rust/pull/95547">https://github.com/rust-lang/rust/pull/95547</a> ? ;)</p>



<a name="277490780"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277490780" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277490780">(Apr 01 2022 at 23:34)</a>:</h4>
<p>(I know its not your decision)</p>



<a name="277490798"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277490798" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277490798">(Apr 01 2022 at 23:35)</a>:</h4>
<p>hm looking at it again, I will add a sentence asking people to use <code>MaybeUninit</code> instead</p>



<a name="277490815"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277490815" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277490815">(Apr 01 2022 at 23:35)</a>:</h4>
<p>Hmm, generally seems fine to me, though "should always be done" maybe overstates how final these decisions are right now</p>



<a name="277490821"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277490821" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Boxy [she/her] <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277490821">(Apr 01 2022 at 23:36)</a>:</h4>
<p>is this a guarantee that we can use an array of <code>MaybeUninit&lt;u8&gt;</code> to losslessly store pointers</p>



<a name="277490880"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277490880" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277490880">(Apr 01 2022 at 23:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="326176">Boxy [she/her]</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277490821">said</a>:</p>
<blockquote>
<p>is this a guarantee that we can use an array of <code>MaybeUninit&lt;u8&gt;</code> to losslessly store pointers</p>
</blockquote>
<p>I think we should guarantee that, yes. not sure if t-lang thinks we already do guarantee that.</p>



<a name="277490900"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277490900" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277490900">(Apr 01 2022 at 23:37)</a>:</h4>
<p>MaybeUninit&lt;u8&gt; == a byte in the abstract machine, so I would expect so</p>



<a name="277490906"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277490906" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277490906">(Apr 01 2022 at 23:37)</a>:</h4>
<p>it's kind of a hack as calling <code>assume_init</code> might be UB even though the array is <em>initialized</em> (just to pointer values, which is wrong)</p>



<a name="277490909"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277490909" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277490909">(Apr 01 2022 at 23:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277490249">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> could I get you to include something like what I wrote above into the summary? :D not sure how coherent it is with your understanding</p>
</blockquote>
<p>On it.</p>



<a name="277490947"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277490947" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277490947">(Apr 01 2022 at 23:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277490906">said</a>:</p>
<blockquote>
<p>it's kind of a hack as calling <code>assume_init</code> might be UB even though the array is <em>initialized</em> (just to pointer values, which is wrong)</p>
</blockquote>
<p>but that is not very different from how calling <code>assume_init</code> on <code>MaybeUninit&lt;bool&gt;</code> can be UB even if the thing is initialized (but to the wrong value)</p>



<a name="277491002"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277491002" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277491002">(Apr 01 2022 at 23:38)</a>:</h4>
<p>Maybe <code>assume_valid</code> would have been a better name, but too late for that <span aria-label="laughing" class="emoji emoji-1f606" role="img" title="laughing">:laughing:</span></p>



<a name="277491015"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277491015" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277491015">(Apr 01 2022 at 23:38)</a>:</h4>
<p>then the type should have been <code>MaybeValid</code></p>



<a name="277491028"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277491028" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277491028">(Apr 01 2022 at 23:38)</a>:</h4>
<p>something like this was discussed pre-stabilization</p>



<a name="277491041"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277491041" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277491041">(Apr 01 2022 at 23:38)</a>:</h4>
<p>but "valid" can mean many different things...</p>



<a name="277491055"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277491055" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277491055">(Apr 01 2022 at 23:38)</a>:</h4>
<p>Yeah</p>



<a name="277491058"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277491058" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277491058">(Apr 01 2022 at 23:39)</a>:</h4>
<p>Oh well, can't have everything</p>



<a name="277491081"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277491081" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277491081">(Apr 01 2022 at 23:39)</a>:</h4>
<p>does validity for an integer mean that it <em>doesn't</em> have provenance, or does it just mean that provenance is ignored for all operations like copy/move/etc?</p>



<a name="277491096"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277491096" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277491096">(Apr 01 2022 at 23:39)</a>:</h4>
<p>It does not have provenance</p>



<a name="277491164"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277491164" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277491164">(Apr 01 2022 at 23:40)</a>:</h4>
<p>so a pointer to int transmute is UB even if you don't attempt to cast it back?</p>



<a name="277491170"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277491170" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277491170">(Apr 01 2022 at 23:40)</a>:</h4>
<p>Yes</p>



<a name="277491212"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277491212" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277491212">(Apr 01 2022 at 23:41)</a>:</h4>
<p>I don't know if this is possible, but it'd be lovely if we had carrots and not just sticks here -- i.e. if there were some new MIR optimization where we could say "you only get this if you start using strict provenance"</p>



<a name="277491225"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277491225" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277491225">(Apr 01 2022 at 23:41)</a>:</h4>
<p>Fixing code is always more exciting when there's better performance to be had :)</p>



<a name="277491264"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277491264" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277491264">(Apr 01 2022 at 23:42)</a>:</h4>
<p>but transmuting an "invalid_mut" ptr to an int is fine?</p>



<a name="277491273"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277491273" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277491273">(Apr 01 2022 at 23:42)</a>:</h4>
<p>(I like Ralf's proposal either way, it's just a wishlist thing)</p>



<a name="277491306"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277491306" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277491306">(Apr 01 2022 at 23:43)</a>:</h4>
<p><span class="user-mention" data-user-id="384014">@Patrick Walton</span> the carrot for strict provenance is Miri, CHERI, and hopefully more formals methods tools in the future ;)</p>



<a name="277491318"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277491318" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Boxy [she/her] <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277491318">(Apr 01 2022 at 23:43)</a>:</h4>
<p>and no more threat of the compiler trashing your code :)</p>



<a name="277491329"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277491329" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277491329">(Apr 01 2022 at 23:43)</a>:</h4>
<p>well, modulo compiler bugs. of which there are many.</p>



<a name="277491375"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277491375" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Boxy [she/her] <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277491375">(Apr 01 2022 at 23:44)</a>:</h4>
<p>true, not much users can do about that though ^^'</p>



<a name="277491382"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277491382" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277491382">(Apr 01 2022 at 23:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="295632">Diggsey</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277491264">said</a>:</p>
<blockquote>
<p>but transmuting an "invalid_mut" ptr to an int is fine?</p>
</blockquote>
<p>yes</p>



<a name="277491447"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277491447" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277491447">(Apr 01 2022 at 23:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="295632">Diggsey</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277491164">said</a>:</p>
<blockquote>
<p>so a pointer to int transmute is UB even if you don't attempt to cast it back?</p>
</blockquote>
<p>there is a more permissible alternative by <span class="user-mention" data-user-id="310518">@Jak{e,ob} Degen</span> where it's not UB and you can even transmute it back but then you have a ptr with 'invalid' provenance. I doubt that will help a lot of real-world code though so I think it's better to have UB early, so we can have Miri error early.</p>



<a name="277491535"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277491535" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277491535">(Apr 01 2022 at 23:47)</a>:</h4>
<p>I think it's quite surprising that's all</p>



<a name="277491603"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277491603" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277491603">(Apr 01 2022 at 23:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="384014">Patrick Walton</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277491212">said</a>:</p>
<blockquote>
<p>I don't know if this is possible, but it'd be lovely if we had carrots and not just sticks here -- i.e. if there were some new MIR optimization where we could say "you only get this if you start using strict provenance"</p>
</blockquote>
<p>Yeah, I've brought this up, and definitely agree. I'm slowly working towards that goal, but there are a lot of things that need to be done before MIR opts can be at that point</p>



<a name="277491821"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277491821" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277491821">(Apr 01 2022 at 23:52)</a>:</h4>
<p><span class="user-mention silent" data-user-id="295632">Diggsey</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277491535">said</a>:</p>
<blockquote>
<p>I think it's quite surprising that's all</p>
</blockquote>
<p>yes I know. :( I wish I knew a way to avoid it. but <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/286#issuecomment-1085144431">this example</a> does not give us a lot of wiggle room.</p>



<a name="277491852"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277491852" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277491852">(Apr 01 2022 at 23:52)</a>:</h4>
<p>well I don't have an issue with round-trips being UB</p>



<a name="277491891"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277491891" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277491891">(Apr 01 2022 at 23:53)</a>:</h4>
<p>that is not too surprising to me, but even the initial ptr-to-int transmute being immediately UB is quite surprising</p>



<a name="277491908"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277491908" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277491908">(Apr 01 2022 at 23:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="384014">Patrick Walton</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277491212">said</a>:</p>
<blockquote>
<p>I don't know if this is possible, but it'd be lovely if we had carrots and not just sticks here -- i.e. if there were some new MIR optimization where we could say "you only get this if you start using strict provenance"</p>
</blockquote>
<p>that's funny, I actually thought we should explicitly <em>not</em> have optimizations that require strict provenance and I expected you to be very happy about that.^^<br>
for permissive vs yolo provenance OTOH, it's hard to even say since yolo provenance is just entirely incoherent...</p>



<a name="277491938"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277491938" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277491938">(Apr 01 2022 at 23:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="295632">Diggsey</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277491891">said</a>:</p>
<blockquote>
<p>that is not too surprising to me, but even the initial ptr-to-int transmute being immediately UB is quite surprising</p>
</blockquote>
<p>so you think it would be less surprising if the roundtrip is allowed but produces an 'invalid' pointer?</p>



<a name="277491999"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277491999" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277491999">(Apr 01 2022 at 23:54)</a>:</h4>
<p>I don't care what round-trip does - even if transmuting it back was immediately UB that would be less surprising to me</p>



<a name="277492011"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277492011" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277492011">(Apr 01 2022 at 23:54)</a>:</h4>
<p>making the transmute back UB is quite hard, not sure how to achieve that ;)</p>



<a name="277492025"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277492025" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277492025">(Apr 01 2022 at 23:54)</a>:</h4>
<p>I mean I'm not saying I <em>want</em> that</p>



<a name="277492030"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277492030" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277492030">(Apr 01 2022 at 23:54)</a>:</h4>
<p>yeah I understand</p>



<a name="277492047"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277492047" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277492047">(Apr 01 2022 at 23:55)</a>:</h4>
<p>now, this is surprising to me -- isn't the entire point of transmuting a ptr to int that you'd want to transmute it back later?</p>



<a name="277492068"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277492068" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277492068">(Apr 01 2022 at 23:55)</a>:</h4>
<p>like, the typical usecase I imagine is someone implementing <code>memcpy</code> by copying data one <code>u8</code> at a time (maybe with some <code>u64</code> in the middle for extra efficiency)</p>



<a name="277492265"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277492265" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277492265">(Apr 01 2022 at 23:58)</a>:</h4>
<p>you might just be writing stuff to a file (some kind of crash dump say) and you don't care if pointer values get in there</p>



<a name="277492321"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277492321" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Diggsey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277492321">(Apr 01 2022 at 23:59)</a>:</h4>
<p>but yeah, I'm not saying this is super useful, just that this aspect of the model was surprising</p>



<a name="277494118"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277494118" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277494118">(Apr 02 2022 at 00:30)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277490249">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> could I get you to include something like what I wrote above into the summary? :D not sure how coherent it is with your understanding</p>
</blockquote>
<p>I gave it a go! <a href="https://hackmd.io/I-zHe9bZTJOY78orP1aYIA?view">https://hackmd.io/I-zHe9bZTJOY78orP1aYIA?view</a></p>
<p><a href="/user_uploads/4715/MhqzXrC_xs_tuQnbxAqOtkB6/image.png">image.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/4715/MhqzXrC_xs_tuQnbxAqOtkB6/image.png" title="image.png"><img src="/user_uploads/4715/MhqzXrC_xs_tuQnbxAqOtkB6/image.png"></a></div>



<a name="277494547"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277494547" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277494547">(Apr 02 2022 at 00:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="295632">Diggsey</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277492265">said</a>:</p>
<blockquote>
<p>you might just be writing stuff to a file (some kind of crash dump say) and you don't care if pointer values get in there</p>
</blockquote>
<p>Perhaps here it make sense to have a kind of raw pointer that's semantically limited to reading data (non-pointers). Because if you can only read, then you can't randomly put a pointer where one wasn't expected ‚Äî avoiding this example <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/286">https://github.com/rust-lang/unsafe-code-guidelines/issues/286</a></p>



<a name="277495114"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277495114" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277495114">(Apr 02 2022 at 00:51)</a>:</h4>
<p>I mean as far as I am aware, reading 16 bytes in an aligned condition works on every 64-bit platform on the planet.</p>



<a name="277495172"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277495172" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277495172">(Apr 02 2022 at 00:52)</a>:</h4>
<p>this might be mostly historical accident.</p>



<a name="277506974"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277506974" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277506974">(Apr 02 2022 at 05:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277490947">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277490906">said</a>:</p>
<blockquote>
<p>it's kind of a hack as calling <code>assume_init</code> might be UB even though the array is <em>initialized</em> (just to pointer values, which is wrong)</p>
</blockquote>
<p>but that is not very different from how calling <code>assume_init</code> on <code>MaybeUninit&lt;bool&gt;</code> can be UB even if the thing is initialized (but to the wrong value)</p>
</blockquote>
<p>Just to comment on this: I don't think we need to declare ptr&lt;-&gt;int transmutes UB directly at all. We can just have ptr-&gt;int transmute be <code>.addr()</code> (non-broadcast), and int-&gt;ptr transmute be <code>invalid{_mut}()</code>. As far as I know there are no modeling issues with this interpretation, although it's still basically useless for the programmer, but the transmute itself, even reading the new bytes, is not UB.</p>
<p>... of course I keep reading and this has been brought up. Anyway I think we should not do UB upfront here, it will limit some Pod-like implementations</p>



<a name="277508761"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277508761" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Christopher Durham <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277508761">(Apr 02 2022 at 05:50)</a>:</h4>
<p>I know Flags aren't great, but...<br>
How would a world where formally, ptr2int2ptr transmutes give invalid_ptr, <em>but</em> Miri has a <code>-Zmiri-warn-me-about-ptr-tranamutes</code> which immediately errors (or maybe warns and continues?) for diagnostic purposes be?</p>



<a name="277508783"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277508783" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Christopher Durham <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277508783">(Apr 02 2022 at 05:51)</a>:</h4>
<p>Miri could even enable this by default</p>



<a name="277508793"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277508793" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Christopher Durham <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277508793">(Apr 02 2022 at 05:51)</a>:</h4>
<p>If the considered alternative is banning such transmutes outright, then Good Citizen Miri Runners will be avoiding the transmute anyway</p>



<a name="277508894"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277508894" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Christopher Durham <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277508894">(Apr 02 2022 at 05:53)</a>:</h4>
<p>But if we're only forbidding it so Miri can check it, and just having it strip provenance is an O(1) addition to the formal model, then, why not <em>just</em> have Miri check it, and allow the treatment as Pod</p>



<a name="277509056"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277509056" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Christopher Durham <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277509056">(Apr 02 2022 at 05:56)</a>:</h4>
<p>(I guess I should <span class="user-mention" data-user-id="120791">@RalfJ</span> so this has a chance to be seen. Low priority what-if about Miri + ptr2int diagnosis flag.)</p>



<a name="277509348"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277509348" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277509348">(Apr 02 2022 at 06:02)</a>:</h4>
<p>Which direction specifically are you talking about? Just ptr2int, or the other way too?</p>



<a name="277509804"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277509804" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277509804">(Apr 02 2022 at 06:13)</a>:</h4>
<p>I think it is possible to support the weak-provenance model in Miri if we are okay with some false negatives. The result of a int2ptr is a "wildcard" pointer, which tracks no provenance like <code>invalid_mut</code>, but if you use it to dereference memory then it only flags UB if the borrow stack is such that no possible raw pointer could access this location, otherwise it just accepts it (maybe logs?) and moves on</p>



<a name="277509920"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277509920" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277509920">(Apr 02 2022 at 06:16)</a>:</h4>
<p>this works because the actual value being read or written does not depend on the borrow stack; the only effect is possible popping of the borrow stack (more popping means more UB), so if we don't pop the stack or only pop things we know to be invalidated by any raw pointer write, then we know we are not spuriously rejecting good programs</p>



<a name="277509980"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277509980" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277509980">(Apr 02 2022 at 06:18)</a>:</h4>
<p>(Note that these "wildcard" pointers are not part of the formal model, they are an underapproximation of the model so that miri doesn't just completely fall over on ptr2int2ptr.)</p>



<a name="277510203"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277510203" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277510203">(Apr 02 2022 at 06:23)</a>:</h4>
<p>You can handle ptr&lt;-&gt;int transmutes in exactly the same way, although I would put it under a different flag since the current leading proposal here would make <code>*(ptr as int as ptr)</code> defined but <code>*(transmute&lt;ptr, int&gt;(_) as ptr)</code> UB</p>



<a name="277522327"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277522327" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277522327">(Apr 02 2022 at 10:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="132829">Christopher Durham</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277508761">said</a>:</p>
<blockquote>
<p>I know Flags aren't great, but...<br>
How would a world where formally, ptr2int2ptr transmutes give invalid_ptr, <em>but</em> Miri has a <code>-Zmiri-warn-me-about-ptr-tranamutes</code> which immediately errors (or maybe warns and continues?) for diagnostic purposes be?</p>
</blockquote>
<p>This is implied by <code>-Zmiri-strict-provenance</code> (just landed). It also makes ptr2int2ptr <em>casts</em> return invalid pointers. Does that flag work for you?</p>



<a name="277524840"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277524840" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277524840">(Apr 02 2022 at 11:49)</a>:</h4>
<p>I added a section on proposed memory models to my position document <a href="https://hackmd.io/I-zHe9bZTJOY78orP1aYIA?view">https://hackmd.io/I-zHe9bZTJOY78orP1aYIA?view</a> .</p>
<p><span class="user-mention" data-user-id="198590">@comex</span> , you may be interested in this phrase:</p>
<blockquote>
<p>The advantage of [the proposed memory for Rust] is that ptr2int2ptr is still allowed as it is today. (...) <strong>Developers are allowed to ‚Äúpretend‚Äù that ptr and usize are the same and that integers have provenance.</strong></p>
</blockquote>
<p>(Perhaps there are errors, this shit is hard. :) Ralf, you have permission to fix such things in the document if you feel like it)</p>



<a name="277526648"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277526648" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jessica Clarke <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277526648">(Apr 02 2022 at 12:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277454590">said</a>:</p>
<blockquote>
<p>I think you're right.</p>
<p>A third option may be to make <code>ptr</code> contain _two_ machine pointers, one "current" one and one "maximal" one which represents the whole allocation. Then still only "permissively exposed" <code>ptr</code>s need to be tracked.</p>
</blockquote>
<p>This doesn't work with one-past-the-end pointers, never mind the privilege amplification it provides.</p>



<a name="277526904"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277526904" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277526904">(Apr 02 2022 at 12:35)</a>:</h4>
<p>I don't know that Rust supports those, but you're right. Another case which Rust definitely supports and which someone else mentioned, is that this doesn't work when you have pointers to overlapping slices [10..30] and [20..40]; you can't take the union of pointers in CHERI</p>



<a name="277526928"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277526928" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277526928">(Apr 02 2022 at 12:36)</a>:</h4>
<p>Which is why I propose the "double pointer" approach in my position document linked just above.</p>
<p>Privilege amplification... if you want maximally secure Rust on CHERI then you need strict provenance</p>



<a name="277527206"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277527206" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277527206">(Apr 02 2022 at 12:40)</a>:</h4>
<p>I've been refining my position document as I learn more</p>



<a name="277528799"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277528799" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277528799">(Apr 02 2022 at 13:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277522327">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="132829">Christopher Durham</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277508761">said</a>:</p>
<blockquote>
<p>I know Flags aren't great, but...<br>
How would a world where formally, ptr2int2ptr transmutes give invalid_ptr, <em>but</em> Miri has a <code>-Zmiri-warn-me-about-ptr-tranamutes</code> which immediately errors (or maybe warns and continues?) for diagnostic purposes be?</p>
</blockquote>
<p>This is implied by <code>-Zmiri-strict-provenance</code> (just landed). It also makes ptr2int2ptr <em>casts</em> return invalid pointers. Does that flag work for you?</p>
</blockquote>
<p>no it is not implied by that. miri-strict-provenance only affects <em>casts</em>, not <em>transmutes</em>.</p>



<a name="277528820"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277528820" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277528820">(Apr 02 2022 at 13:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277524840">said</a>:</p>
<blockquote>
<p>I added a section on proposed memory models to my position document <a href="https://hackmd.io/I-zHe9bZTJOY78orP1aYIA?view">https://hackmd.io/I-zHe9bZTJOY78orP1aYIA?view</a> .</p>
<p><span class="user-mention silent" data-user-id="198590">comex</span> , you may be interested in this phrase:</p>
<blockquote>
<p>The advantage of [the proposed memory for Rust] is that ptr2int2ptr is still allowed as it is today. (...) <strong>Developers are allowed to ‚Äúpretend‚Äù that ptr and usize are the same and that integers have provenance.</strong></p>
</blockquote>
<p>(Perhaps there are errors, this shit is hard. :) Ralf, you have permission to fix such things in the document if you feel like it)</p>
</blockquote>
<p>oh no integers definitely do not have provenance I don't think we should say things like that^^</p>



<a name="277528870"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277528870" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277528870">(Apr 02 2022 at 13:12)</a>:</h4>
<blockquote>
<p>no it is not implied by that. miri-strict-provenance only affects <em>casts</em>, not <em>transmutes</em>.</p>
</blockquote>
<p>Oops yeah. I keep not reading the word <code>transmute</code></p>



<a name="277528901"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277528901" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277528901">(Apr 02 2022 at 13:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277528820">said</a>:</p>
<blockquote>
<p>oh no integers definitely do not have provenance I don't think we should say things like that^^</p>
</blockquote>
<p>I agree with you from a compiler / machine model perspective. But is there any code that can break by doing ptr2int2ptr too often, in the nondeterminism model?</p>



<a name="277528922"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277528922" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277528922">(Apr 02 2022 at 13:13)</a>:</h4>
<p>If not, then I think we can put some people at ease who now understand why their existing code won't break</p>



<a name="277528973"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277528973" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277528973">(Apr 02 2022 at 13:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="271719">Mario Carneiro</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277509804">said</a>:</p>
<blockquote>
<p>I think it is possible to support the weak-provenance model in Miri if we are okay with some false negatives. The result of a int2ptr is a "wildcard" pointer, which tracks no provenance like <code>invalid_mut</code>, but if you use it to dereference memory then it only flags UB if the borrow stack is such that no possible raw pointer could access this location, otherwise it just accepts it (maybe logs?) and moves on</p>
</blockquote>
<p>well, there's basically always going to be <em>some</em> pointer that is allowed to make an access, so this would basically mean -- just allow all accesses from 'wildcard' pointers. sure that would be possible.<br>
note that restricting this to "raw ptr provenance" (whatever that even might be, there might not be such a distinction) is not necessarily correct -- someone could transmute a reference to a raw ptr and then int-roundtrip that.</p>



<a name="277529012"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277529012" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277529012">(Apr 02 2022 at 13:14)</a>:</h4>
<p>Of course from the efficiency and CHERI-security point of view there is a difference between ptr and int. From the compiler side there is a "side-effect", as you say. But AFAICT there is no observable side effect for devs</p>



<a name="277529027"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277529027" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277529027">(Apr 02 2022 at 13:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="132829">Christopher Durham</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277508761">said</a>:</p>
<blockquote>
<p>I know Flags aren't great, but...<br>
How would a world where formally, ptr2int2ptr transmutes give invalid_ptr, <em>but</em> Miri has a <code>-Zmiri-warn-me-about-ptr-tranamutes</code> which immediately errors (or maybe warns and continues?) for diagnostic purposes be?</p>
</blockquote>
<p>I mean yes that would work. I just feel like allowing the transmutes in a way that they 'lose' data is more surprising/confusing than outright disallowing them via validity invariants.</p>



<a name="277529113"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277529113" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277529113">(Apr 02 2022 at 13:16)</a>:</h4>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277528922">said</a>:</p>
<blockquote>
<p>If not, then I think we can put some people at ease who now understand why their existing code won't break</p>
</blockquote>
<p>saying integers have provenance puts me on the edge, not at ease at all. I strongly oppose saying anything like that.^^<br>
we shouldn't say <strong>wrong</strong> things in the name of making things simpler. that's just bad communication.</p>



<a name="277529137"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277529137" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277529137">(Apr 02 2022 at 13:17)</a>:</h4>
<p>there are observable effects of integers not having provenance, e.g. the issue with transmutes</p>



<a name="277529168"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277529168" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277529168">(Apr 02 2022 at 13:18)</a>:</h4>
<blockquote>
<p>we shouldn't say <strong>wrong</strong> things in the name of making things simpler. </p>
</blockquote>
<p>Fair point</p>



<a name="277529241"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277529241" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277529241">(Apr 02 2022 at 13:18)</a>:</h4>
<blockquote>
<p>there are observable effects of integers not having provenance, e.g. the issue with transmutes</p>
</blockquote>
<p>Is that still an issue if transmute between ptr and int is UB?</p>



<a name="277529312"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277529312" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277529312">(Apr 02 2022 at 13:20)</a>:</h4>
<p>I would like to arrive at a <del>wording</del> guideline that tells devs when they can legally do <code>*(usize to ptr)</code>, and when that is UB. For instance, "you can dereference <code>usize to ptr</code> if the original cast from ref to <code>ptr</code> isn't hidden behind the creation of <code>&amp;mut</code>"</p>



<a name="277529333"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277529333" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277529333">(Apr 02 2022 at 13:21)</a>:</h4>
<p>So that they can still understand their code to some degree, even if they don't understand nondeterministically-tagged-SB itself</p>



<a name="277529647"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277529647" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277529647">(Apr 02 2022 at 13:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277529241">said</a>:</p>
<blockquote>
<blockquote>
<p>there are observable effects of integers not having provenance, e.g. the issue with transmutes</p>
</blockquote>
<p>Is that still an issue if transmute between ptr and int is UB?</p>
</blockquote>
<p>well you have to explain that it is UB. it is UB because integers cannot -- must not -- carry provenance.</p>



<a name="277529749"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277529749" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277529749">(Apr 02 2022 at 13:28)</a>:</h4>
<p>you can dereference <code>usize to ptr</code> if there <em>exists</em> some provenance that was previously 'exposed' (i.e. fed to a <code>ptr to usize</code>) that allows this access. or more precisely, with <code>let p = usize to ptr</code>, there has to exist an exposed provenance that allows <em>all</em> accesses done with <code>p</code> (i.e., you dont get to say "on the first access <code>p</code> has this provenance and on the second it has that").</p>



<a name="277529768"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277529768" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277529768">(Apr 02 2022 at 13:29)</a>:</h4>
<p>basically, imagine that when <code>usize to ptr</code> is executed, a previously exposed provenance is being <em>guessed</em>, but the guess is magic and always works maximally in your favor</p>



<a name="277529850"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277529850" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277529850">(Apr 02 2022 at 13:31)</a>:</h4>
<p>FWIW this is literally what the 'udi' part in PNVI-ae-udi does, except they have an explicit algorithm that you could implement in miri that tracks this 'guessing'. this is possible because their provenance is very simple. for SB, that algorithm is basically -- duplicate the entire state of everything for every possible guess and run them all in parallel and see which one survives. not very pretty. ;)</p>



<a name="277530031"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277530031" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277530031">(Apr 02 2022 at 13:35)</a>:</h4>
<p>I think we can treat nondeterministically-tagged-SB as not-machine-checkable. Because it's hard. Perhaps we'll find a way to check it in the future but probably not.</p>



<a name="277530237"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277530237" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jessica Clarke <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277530237">(Apr 02 2022 at 13:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277526904">said</a>:</p>
<blockquote>
<p>I don't know that Rust supports those, but you're right. Another case which Rust definitely supports and which someone else mentioned, is that this doesn't work when you have pointers to overlapping slices [10..30] and [20..40]; you can't take the union of pointers in CHERI</p>
</blockquote>
<p>I would hope it does given C often does that and you want to be able to wrap C APIs with (unsafe) Rust FFI bindings.</p>



<a name="277530559"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277530559" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277530559">(Apr 02 2022 at 13:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277526928">said</a>:</p>
<blockquote>
<p>Which is why I propose the "double pointer" approach in my position document linked just above.</p>
<p>Privilege amplification... if you want maximally secure Rust on CHERI then you need strict provenance</p>
</blockquote>
<p>I don't understand what the 'double pointer' approach achieves?</p>



<a name="277530892"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277530892" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277530892">(Apr 02 2022 at 13:53)</a>:</h4>
<p>Jessica, I checked, CHERI cannot take the union of machine integers</p>



<a name="277531092"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277531092" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277531092">(Apr 02 2022 at 13:57)</a>:</h4>
<p>There‚Äôs no instruction</p>



<a name="277531249"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277531249" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277531249">(Apr 02 2022 at 14:00)</a>:</h4>
<p>Ralf, besides CHERI option (2) which uses a global pointer for int2ptr (and thus allows int2ptr even when ptr2int didn‚Äôt happen), I would like a more secure option which prevents accidental int2ptr of memory that‚Äôs only touched by strict provenance code</p>



<a name="277531287"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277531287" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277531287">(Apr 02 2022 at 14:01)</a>:</h4>
<p>A ‚Äúkeep your fingers off my allocations‚Äù approach so that strict provenance crates actually become safer</p>



<a name="277531294"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277531294" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277531294">(Apr 02 2022 at 14:01)</a>:</h4>
<p>my proposals all disallow int2ptr on memory that was only touched by strict provenance</p>



<a name="277531296"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277531296" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277531296">(Apr 02 2022 at 14:01)</a>:</h4>
<p>int2ptr guesses an <em>exposed</em> provenance</p>



<a name="277531299"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277531299" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277531299">(Apr 02 2022 at 14:01)</a>:</h4>
<p>strict provenance conforming code never exposes any provenance</p>



<a name="277531300"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277531300" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277531300">(Apr 02 2022 at 14:01)</a>:</h4>
<p>done</p>



<a name="277531302"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277531302" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jessica Clarke <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277531302">(Apr 02 2022 at 14:01)</a>:</h4>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277530892">said</a>:</p>
<blockquote>
<p>Jessica, I checked, CHERI cannot take the union of machine integers</p>
</blockquote>
<p>Yes that's correct (and required in order to be able to implement heap temporal safety on top of CHERI)</p>



<a name="277531306"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277531306" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277531306">(Apr 02 2022 at 14:01)</a>:</h4>
<p>How would you prevent it at runtime though, Ralf</p>



<a name="277531315"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277531315" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277531315">(Apr 02 2022 at 14:02)</a>:</h4>
<p>We want a crash</p>



<a name="277531355"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277531355" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277531355">(Apr 02 2022 at 14:02)</a>:</h4>
<p>since when is that a goal? we dont prevent unsafe code bugs at runtime</p>



<a name="277531361"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277531361" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jessica Clarke <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277531361">(Apr 02 2022 at 14:02)</a>:</h4>
<p>Implement a sanitiser?</p>



<a name="277531363"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277531363" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277531363">(Apr 02 2022 at 14:02)</a>:</h4>
<p>The goal of CHERI is to catch such things at runtime</p>



<a name="277531374"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277531374" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277531374">(Apr 02 2022 at 14:02)</a>:</h4>
<p>I wouldnt spend energy on making permissive provenance code work on CHERI</p>



<a name="277531375"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277531375" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277531375">(Apr 02 2022 at 14:02)</a>:</h4>
<p>I would like not only to compile to CHERI, but to help prevent car hacking</p>



<a name="277531377"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277531377" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jessica Clarke <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277531377">(Apr 02 2022 at 14:02)</a>:</h4>
<p>Well it's not <em>the</em> goal of CHERI</p>



<a name="277531380"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277531380" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277531380">(Apr 02 2022 at 14:02)</a>:</h4>
<p>if you want CHERI, follow strict provenance</p>



<a name="277531385"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277531385" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277531385">(Apr 02 2022 at 14:03)</a>:</h4>
<p>That‚Äôs a radical approach</p>



<a name="277531390"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277531390" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277531390">(Apr 02 2022 at 14:03)</a>:</h4>
<p>it's what I have been saying for days <span aria-label="shrug" class="emoji emoji-1f937" role="img" title="shrug">:shrug:</span></p>



<a name="277531392"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277531392" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jessica Clarke <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277531392">(Apr 02 2022 at 14:03)</a>:</h4>
<p>It's what memory safety requires</p>



<a name="277531396"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277531396" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277531396">(Apr 02 2022 at 14:03)</a>:</h4>
<p>like it's literally <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277489704">in my overview here</a></p>



<a name="277531397"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277531397" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jessica Clarke <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277531397">(Apr 02 2022 at 14:03)</a>:</h4>
<p>If you don't want memory safety you can do something else, but then that goes against what CHERI stands for</p>



<a name="277531464"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277531464" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277531464">(Apr 02 2022 at 14:05)</a>:</h4>
<p>in Miri we can implement permissive provenance with false negatives in a way that accessing never-exposed memory with 'wildcard' provenance is still flagged</p>



<a name="277531479"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277531479" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277531479">(Apr 02 2022 at 14:05)</a>:</h4>
<p>so, it'd still have some false negatives but those cases it would catch</p>



<a name="277531480"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277531480" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277531480">(Apr 02 2022 at 14:05)</a>:</h4>
<p>I think we can do better than a binary choice between ‚Äúall permissive‚Äù and ‚Äúall strict‚Äù, and I think there will be industry demand for this</p>



<a name="277531482"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277531482" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277531482">(Apr 02 2022 at 14:05)</a>:</h4>
<p>But let‚Äôs not focus on option 1 then if you don‚Äôt like it</p>



<a name="277531483"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277531483" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277531483">(Apr 02 2022 at 14:05)</a>:</h4>
<p>It‚Äôs optional</p>



<a name="277531485"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277531485" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277531485">(Apr 02 2022 at 14:05)</a>:</h4>
<p>on CHERI I dont think I agree</p>



<a name="277531528"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277531528" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jessica Clarke <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277531528">(Apr 02 2022 at 14:06)</a>:</h4>
<p>Option 1 is unimplementable on CHERI, so if your goal is CHERI compatibility it's not productive to talk about</p>



<a name="277531529"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277531529" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277531529">(Apr 02 2022 at 14:06)</a>:</h4>
<p>in C they did something like this by making intptr_t 128bits. but that's not an option for Rust. strict provenance is literally the proposal that was designed as the alternative to that.</p>



<a name="277531531"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277531531" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277531531">(Apr 02 2022 at 14:06)</a>:</h4>
<p>Jessica, I think it‚Äôs an unnecessarily radical approach. Why is it unimplementable?</p>



<a name="277531540"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277531540" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277531540">(Apr 02 2022 at 14:06)</a>:</h4>
<p>so, CHERI on permissive provenance is basically -- forget everything we did the last 2 weeks and reset from the start. please do that some other time. ;)</p>



<a name="277531586"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277531586" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277531586">(Apr 02 2022 at 14:07)</a>:</h4>
<p>I am strongly in the camp of ‚Äúlets keep all code working‚Äù, like <span class="user-mention" data-user-id="384014">@Patrick Walton</span> is. Even for CHERI.</p>



<a name="277531596"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277531596" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277531596">(Apr 02 2022 at 14:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277531480">said</a>:</p>
<blockquote>
<p>I think we can do better than a binary choice between ‚Äúall permissive‚Äù and ‚Äúall strict‚Äù, and I think there will be industry demand for this</p>
</blockquote>
<p>some sanitizers can have okay-ish support for 'mixed mode'. Miri, for example. I just dont think CHERI is one of them.</p>



<a name="277531654"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277531654" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277531654">(Apr 02 2022 at 14:08)</a>:</h4>
<p>I think the idea of forking the language (even just for CHERI) is leading to unnecessary conflict</p>



<a name="277531661"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277531661" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277531661">(Apr 02 2022 at 14:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277531586">said</a>:</p>
<blockquote>
<p>I am strongly in the camp of ‚Äúlets keep all code working‚Äù, like <span class="user-mention silent" data-user-id="384014">Patrick Walton</span> is. Even for CHERI.</p>
</blockquote>
<p>fair but please keep that strictly separate from the general strict provenance effort where I think this is a non-goal.<br>
like, literally if you solve that problem you made strict provenance unnecessary.</p>



<a name="277531685"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277531685" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277531685">(Apr 02 2022 at 14:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277531654">said</a>:</p>
<blockquote>
<p>I think the idea of forking the language (even just for CHERI) is leading to unnecessary conflict</p>
</blockquote>
<p>it's more like, some platforms only support a subset of the language. it's not a fork.</p>



<a name="277531695"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277531695" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277531695">(Apr 02 2022 at 14:09)</a>:</h4>
<p>some platforms also only have liballoc but not libstd.</p>



<a name="277531769"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277531769" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277531769">(Apr 02 2022 at 14:10)</a>:</h4>
<p>so while I certainly applaud your goal of superseding strict provenance, I think that is a discussion strictly separate from fleshing out the story of strict provenance itself. :)</p>



<a name="277531775"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277531775" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277531775">(Apr 02 2022 at 14:10)</a>:</h4>
<p>From my perspective it‚Äôs not set in stone what this ‚Äústrict provenance effort‚Äù is, sorry</p>



<a name="277531782"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277531782" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277531782">(Apr 02 2022 at 14:10)</a>:</h4>
<p>But I understand a desire to focus effort</p>



<a name="277531797"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277531797" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277531797">(Apr 02 2022 at 14:10)</a>:</h4>
<p>But I also think it‚Äôs valuable to point out potential future extensions</p>



<a name="277531807"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277531807" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277531807">(Apr 02 2022 at 14:11)</a>:</h4>
<p>I can add an option 3 in the document later, which is fast+secure when the whole world is strict.</p>



<a name="277531812"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277531812" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277531812">(Apr 02 2022 at 14:11)</a>:</h4>
<p>That seems to be what you want</p>



<a name="277531862"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277531862" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277531862">(Apr 02 2022 at 14:12)</a>:</h4>
<p>yeah, I think I'd like to treat permissive provenance on CHERI as more of a future extension than a part of strict provenance</p>



<a name="277531867"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277531867" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jessica Clarke <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277531867">(Apr 02 2022 at 14:12)</a>:</h4>
<p><code>ptr as usize as u32 as usize as ptr</code> works on some architectures but not others, in a way this is just a case like that I guess</p>



<a name="277531870"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277531870" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277531870">(Apr 02 2022 at 14:12)</a>:</h4>
<p>though ofc feel free to start a separate zulip thread hear that discusses this</p>



<a name="277531878"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277531878" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277531878">(Apr 02 2022 at 14:12)</a>:</h4>
<p>but this thread here is already a monster without expanding its scope even more like that^^</p>



<a name="277531891"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277531891" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277531891">(Apr 02 2022 at 14:13)</a>:</h4>
<p>and it's also confusing to have so many different things disucssed all in this thread</p>



<a name="277531896"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277531896" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277531896">(Apr 02 2022 at 14:13)</a>:</h4>
<p>For me, the high-prio thing is to define the language, and to enable the ecosystem to migrate</p>



<a name="277531948"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277531948" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277531948">(Apr 02 2022 at 14:14)</a>:</h4>
<p>well for strict provenance that is done, right? or do you think the PR landing the APIs leaves something insufficiently defined?</p>



<a name="277531960"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277531960" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277531960">(Apr 02 2022 at 14:14)</a>:</h4>
<p>the next step would be things like clippy lints that help ensure conformance with strict provenance (by flagging ptr2int and int2ptr casts)</p>



<a name="277531984"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277531984" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277531984">(Apr 02 2022 at 14:15)</a>:</h4>
<p>I think we should have alias ptr as usize and usize as ptr to specific functions for permissive provenance.</p>



<a name="277531994"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277531994" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277531994">(Apr 02 2022 at 14:15)</a>:</h4>
<p>As per my position</p>



<a name="277532001"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277532001" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277532001">(Apr 02 2022 at 14:15)</a>:</h4>
<p>sure. but as you said, that's for permissive provenance, so no effect on strict provenance conforming code.</p>



<a name="277532043"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277532043" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277532043">(Apr 02 2022 at 14:16)</a>:</h4>
<p>True</p>



<a name="277532045"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277532045" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277532045">(Apr 02 2022 at 14:16)</a>:</h4>
<p>that's why I described this in layers in my summary</p>



<a name="277532049"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277532049" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277532049">(Apr 02 2022 at 14:16)</a>:</h4>
<p>each layer down includes more code and is harder to spec</p>



<a name="277532053"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277532053" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Francesco Dainese <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277532053">(Apr 02 2022 at 14:17)</a>:</h4>
<p>I was thinking of opening an issue and labeling it <code>A-strict provenance</code> since I actually have a valid use case that would break strict provenance, it's an intersection of embedded, LLVM buggy support for ROPI, and function pointers... But since I only have a rough understanding, I'd like to get some more minds on it first  to maybe iron out the details or discard it as non-issue, or even label it properly.<br>
<span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277531878">said</a>:</p>
<blockquote>
<p>but this thread here is already a monster without expanding its scope even more like that^^</p>
</blockquote>
<p>should I open a separate thread then?</p>



<a name="277532059"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277532059" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277532059">(Apr 02 2022 at 14:17)</a>:</h4>
<p>I also think we should change the spec of pointer::addr because now it says that ‚Äúptr as usize‚Äù is strict. I think ‚Äúptr as usize‚Äù should remain permissive</p>



<a name="277532063"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277532063" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277532063">(Apr 02 2022 at 14:17)</a>:</h4>
<p>this topic is called 'strict provenance' so one would assume it is only concerned with strict provenance conforming code. though the thread has long become a monster that talks about everything. ;) so maybe it's time to fork of some new subthreads for reamining topics. whatever those might be?</p>



<a name="277532067"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277532067" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277532067">(Apr 02 2022 at 14:17)</a>:</h4>
<p>And I think that documentation is harmful</p>



<a name="277532068"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277532068" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277532068">(Apr 02 2022 at 14:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="230304">Francesco Dainese</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277532053">said</a>:</p>
<blockquote>
<p>I was thinking of opening an issue and labeling it <code>A-strict provenance</code> since I actually have a valid use case that would break strict provenance, it's an intersection of embedded, LLVM buggy support for ROPI, and function pointers... But since I only have a rough understanding, I'd like to get some more minds on it first  to maybe iron out the details or discard it as non-issue, or even label it properly.<br>
<span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277531878">said</a>:</p>
<blockquote>
<p>but this thread here is already a monster without expanding its scope even more like that^^</p>
</blockquote>
<p>should I open a separate thread then?</p>
</blockquote>
<p>yes please :)</p>



<a name="277532112"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277532112" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277532112">(Apr 02 2022 at 14:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277532059">said</a>:</p>
<blockquote>
<p>I also think we should change the spec of pointer::addr because now it says that ‚Äúptr as usize‚Äù is strict. I think ‚Äúptr as usize‚Äù should remain permissive</p>
</blockquote>
<p>hm yeah that could probably be worded better</p>



<a name="277532115"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277532115" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277532115">(Apr 02 2022 at 14:18)</a>:</h4>
<p>Thanks :)</p>



<a name="277532761"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277532761" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277532761">(Apr 02 2022 at 14:32)</a>:</h4>
<p>opened <a href="https://github.com/rust-lang/rust/pull/95588">https://github.com/rust-lang/rust/pull/95588</a> to fix that</p>



<a name="277548526"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277548526" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nyanpasu64 <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277548526">(Apr 02 2022 at 19:58)</a>:</h4>
<p>Does container_of-based code which casts a pointer-to-field to pointer-to-container (pipewire, maybe linux kernel) work on CHERI?</p>



<a name="277548552"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277548552" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277548552">(Apr 02 2022 at 19:59)</a>:</h4>
<p>If you restrict the metadata provenance when making the inner pointer then no, so it all depends on how compilers do it. You might need to explicitly mark such areas as capable of container of operations.</p>



<a name="277548616"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277548616" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277548616">(Apr 02 2022 at 20:00)</a>:</h4>
<p>But given the kernel does run on CHERI, I'd imagine they've already done the work needed.</p>



<a name="277548640"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277548640" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nyanpasu64 <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277548640">(Apr 02 2022 at 20:00)</a>:</h4>
<p>the linux or bsd kernel?</p>



<a name="277548668"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277548668" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nyanpasu64 <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277548668">(Apr 02 2022 at 20:00)</a>:</h4>
<p>i only hear news about the bsd kernel running on CHERI, and I do hear BSD is less keen on container_of trickery</p>



<a name="277548821"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277548821" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277548821">(Apr 02 2022 at 20:04)</a>:</h4>
<p>Yeah BSD kernel, should have specified. But capability compression means that <code>container_of</code> of a few bytes isn't really a thing the architecture can stop.</p>



<a name="277548920"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277548920" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nyanpasu64 <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277548920">(Apr 02 2022 at 20:06)</a>:</h4>
<p>Also was thinking about ways to (on non-CHERI architectures) preserve current Rust int-to-ptr semantics, and perform <em>most</em> optimizations soundly, without requiring alias analysis or provenance to implement safely. Perhaps int-to-ptr casts can generate pointers allowed to immutably alias all &amp; or <code>*const/*mut</code> types, and write through all <code>*const/*mut</code> and also &amp;T with interior mutability? And additionally &amp;mut-to-int casts effectively "reborrow" the &amp;mut, producing an integer which is legal to cast to pointer and use until the &amp;mut is next accessed (at which point the &amp;mut's user is required to reload the backing memory since it might've been modified)?</p>



<a name="277550491"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277550491" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Alexander Richardson <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277550491">(Apr 02 2022 at 20:40)</a>:</h4>
<p>Yes container_of works by default with CHERI. However we have a more strict compilation mode (using a -cheri-bounds compiler flag) to narrow the bounds for subobjects. If you use that mode (we enable it for the FreeBSD kernel), you have to annotate fields that are used with container_of to opt-out of the bounds narrowing</p>



<a name="277550599"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277550599" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Alexander Richardson <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277550599">(Apr 02 2022 at 20:43)</a>:</h4>
<p>It doesn't break too much code enabling that flag by default but it is an additional porting cost so we don't do it by default. Chapter 5 of <a href="https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-949.pdf">https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-949.pdf</a> has a lot more details on it</p>



<a name="277550677"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277550677" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Alexander Richardson <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277550677">(Apr 02 2022 at 20:45)</a>:</h4>
<p>There is definitely quite a lot of container_of  in the FreeBSD kernel but since you only have to annotate the structures rather than each call site the number of changes is very small</p>



<a name="277633331"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277633331" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277633331">(Apr 03 2022 at 14:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257532">nyanpasu64</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277548920">said</a>:</p>
<blockquote>
<p>Also was thinking about ways to (on non-CHERI architectures) preserve current Rust int-to-ptr semantics, and perform <em>most</em> optimizations soundly, without requiring alias analysis or provenance to implement safely. Perhaps int-to-ptr casts can generate pointers allowed to immutably alias all &amp; or <code>*const/*mut</code> types, and write through all <code>*const/*mut</code> and also &amp;T with interior mutability? And additionally &amp;mut-to-int casts effectively "reborrow" the &amp;mut, producing an integer which is legal to cast to pointer and use until the &amp;mut is next accessed (at which point the &amp;mut's user is required to reload the backing memory since it might've been modified)?</p>
</blockquote>
<p>I think that would be too permissive. the proposal I have been floating around means int-to-ptr can generate pointers that can do <em>anything that a pointer that was previously cast to an int can do</em>. specifically, each int-to-ptr cast has to pick a <em>specific</em> other pointer that it gets the provenance from. you don't get to say "it's like pointer X here and like pointer Y there". yes this means that</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">ptr1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u8</span><span class="p">;</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">ptr2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u8</span><span class="p">;</span><span class="w"></span>
</code></pre></div>
<p>and</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">ptr1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u8</span><span class="p">;</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">ptr2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptr1</span><span class="p">;</span><span class="w"></span>
</code></pre></div>
<p>are <em>not equivalent</em>. FWIW this is also the case in PNVI-ae-udi.</p>



<a name="277640785"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277640785" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Alexander Richardson <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277640785">(Apr 03 2022 at 15:17)</a>:</h4>
<p>Another thing regarding subobject provenance: it looks like LLVM will get intrinsics to restrict the accessible range for  subobjects in the near future: <a href="https://reviews.llvm.org/D115274">https://reviews.llvm.org/D115274</a>, so if rust wants to go down that route upcoming versions of llvm may give better optimizations</p>



<a name="277651507"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277651507" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wanja Hentze <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277651507">(Apr 03 2022 at 17:38)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277633331">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="257532">nyanpasu64</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277548920">said</a>:</p>
<blockquote>
<p>Also was thinking about ways to (on non-CHERI architectures) preserve current Rust int-to-ptr semantics, and perform <em>most</em> optimizations soundly, without requiring alias analysis or provenance to implement safely. Perhaps int-to-ptr casts can generate pointers allowed to immutably alias all &amp; or <code>*const/*mut</code> types, and write through all <code>*const/*mut</code> and also &amp;T with interior mutability? And additionally &amp;mut-to-int casts effectively "reborrow" the &amp;mut, producing an integer which is legal to cast to pointer and use until the &amp;mut is next accessed (at which point the &amp;mut's user is required to reload the backing memory since it might've been modified)?</p>
</blockquote>
<p>I think that would be too permissive. the proposal I have been floating around means int-to-ptr can generate pointers that can do <em>anything that a pointer that was previously cast to an int can do</em>. specifically, each int-to-ptr cast has to pick a <em>specific</em> other pointer that it gets the provenance from. you don't get to say "it's like pointer X here and like pointer Y there". yes this means that</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">ptr1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u8</span><span class="p">;</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">ptr2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u8</span><span class="p">;</span><span class="w"></span>
</code></pre></div>
<p>and</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">ptr1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u8</span><span class="p">;</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">ptr2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptr1</span><span class="p">;</span><span class="w"></span>
</code></pre></div>
<p>are <em>not equivalent</em>. FWIW this is also the case in PNVI-ae-udi.</p>
</blockquote>
<p>That would mean that "slice-merging" still can not be done, right?</p>



<a name="277652660"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277652660" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ben Kimock (Saethlin) <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277652660">(Apr 03 2022 at 18:02)</a>:</h4>
<p>Doesn't that mean you could expose the original provenance of the slice, then when merging do a ptr-int-ptr cast and select the provenance of the original slice?<br>
I suppose my question is if you can just pull the provenance out of ethereal AM state, or if you need to carry around a pointer to transmit the original provenance, which is what you need to do currently to merge slices.</p>



<a name="277653485"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277653485" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277653485">(Apr 03 2022 at 18:21)</a>:</h4>
<blockquote>
<p>That would mean that "slice-merging" still can not be done, right?</p>
</blockquote>
<p>correct.</p>



<a name="277653492"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277653492" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277653492">(Apr 03 2022 at 18:21)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120827">Ben Kimock (Saethlin)</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277652660">said</a>:</p>
<blockquote>
<p>Doesn't that mean you could expose the original provenance of the slice, then when merging do a ptr-int-ptr cast and select the provenance of the original slice?<br>
I suppose my question is if you can just pull the provenance out of ethereal AM state, or if you need to carry around a pointer to transmit the original provenance, which is what you need to do currently to merge slices.</p>
</blockquote>
<p>you currently cannot merge slices so I am confused^^</p>



<a name="277653534"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277653534" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277653534">(Apr 03 2022 at 18:22)</a>:</h4>
<p>but I hope the docs I just added in <a href="https://github.com/rust-lang/rust/issues/95588">#95588</a> answer your question. :)</p>



<a name="277655510"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277655510" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ben Kimock (Saethlin) <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277655510">(Apr 03 2022 at 19:05)</a>:</h4>
<p>Yes, they do :)<br>
I was basically referring to using a manual <code>with_addr</code>, which I did a few times before the strict provenance features appeared</p>



<a name="277662338"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277662338" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277662338">(Apr 03 2022 at 21:36)</a>:</h4>
<p>Realistically most code sites will be possible to fix by a MachineApplicable rustfix.</p>



<a name="277839883"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277839883" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nyanpasu64 <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277839883">(Apr 05 2022 at 07:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277633331">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="257532">nyanpasu64</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277548920">said</a>:</p>
<blockquote>
<p>Also was thinking about ways to (on non-CHERI architectures) preserve current Rust int-to-ptr semantics, and perform <em>most</em> optimizations soundly, without requiring alias analysis or provenance to implement safely. Perhaps int-to-ptr casts can generate pointers allowed to immutably alias all &amp; or <code>*const/*mut</code> types, and write through all <code>*const/*mut</code> and also &amp;T with interior mutability? And additionally &amp;mut-to-int casts effectively "reborrow" the &amp;mut, producing an integer which is legal to cast to pointer and use until the &amp;mut is next accessed (at which point the &amp;mut's user is required to reload the backing memory since it might've been modified)?</p>
</blockquote>
<p>I think that would be too permissive. the proposal I have been floating around means int-to-ptr can generate pointers that can do <em>anything that a pointer that was previously cast to an int can do</em>. specifically, each int-to-ptr cast has to pick a <em>specific</em> other pointer that it gets the provenance from. you don't get to say "it's like pointer X here and like pointer Y there". yes this means that</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">ptr1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u8</span><span class="p">;</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">ptr2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u8</span><span class="p">;</span><span class="w"></span>
</code></pre></div>
<p>and</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">ptr1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u8</span><span class="p">;</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">ptr2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptr1</span><span class="p">;</span><span class="w"></span>
</code></pre></div>
<p>are <em>not equivalent</em>. FWIW this is also the case in PNVI-ae-udi.</p>
</blockquote>
<p>Why do you consider my idea too permissive, and what negative effects do you consider unacceptable? (Though both this idea and my dream language are closer to being a "portable assembly", and Rust is explicitly not setting out to be one.)</p>



<a name="277918439"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277918439" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277918439">(Apr 05 2022 at 17:54)</a>:</h4>
<p><span class="user-mention" data-user-id="257532">@nyanpasu64</span> <br>
your idea means that we can no longer pretend that <code>ptr2int</code> and <code>int2ptr</code> are just FFI calls that the compiler cannot 'look into'. this is a valid compilation strategy for my proposal: pretend that int2ptr casts <em>do not exist</em> and justify all your optimizations without even taking those into account, and then add support for <code>ptr2int</code> (aka <code>expose_addr</code>) and <code>int2ptr</code> (aka <code>from_exposed_addr</code>) by just making them "opaque foreign functions" to the compiler. this has the great benefit that code which does not use these operations can be aggressively optimized as if the operations did not exist (which is basically how LLVM compiles code today!). in other words, supporting these casts has a <em>purely local</em> cost, that is paid only by code that uses them.</p>
<p>with your proposal, this no longer works, so I am fairly sure that your proposal puts a <em>global</em> cost on all code by making it harder to optimize even code that does not use them.</p>



<a name="277957414"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/277957414" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#277957414">(Apr 05 2022 at 23:23)</a>:</h4>
<p>Gankra has published a blog post: <a href="https://gankra.github.io/blah/tower-of-weakenings/">https://gankra.github.io/blah/tower-of-weakenings/</a></p>



<a name="278210028"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/278210028" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Zoey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#278210028">(Apr 07 2022 at 18:55)</a>:</h4>
<p>I‚Äôm reading through all the strict provenance docs and I can‚Äôt see how we‚Äôre supposed to create pointers out of thin air under it. Example of why I want/need to do this: on an embedded microcontroller there will be a peripheral located at some address X. I don‚Äôt have a preexisting pointer with the provenance of that peripheral. So I cant use <code>with_addr</code>. What is the solution for this class of issue?</p>



<a name="278214050"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/278214050" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#278214050">(Apr 07 2022 at 19:23)</a>:</h4>
<p>The answer might just be you're at the <a href="https://gankra.github.io/blah/tower-of-weakenings/">bottom of the tower</a> in those cases, using some target-specific magic.  And you just <strong>can't</strong> use the <em>strict</em> version of all this for that use case.</p>
<p>To get a few floors above the ground (albeit still not to the top), it might be possible to make a model like "your target has implicitly <em>exposed</em> a few addresses as part of starting your executable", and thus you can use <code>ptr::from_exposed_addr</code> on those pre-exposed addresses.</p>
<p>But I think the best solution is change your model so that you don't think "I have a peripheral at a know address" at any point when writing rust code.  To me, that seems like artificial specificity.  <em>To your Rust code</em>, you <em>could</em> be strict about the provenance if, say, you wrote everything against an <code>extern "magic" { static FOO: Foo; }</code>.  Then the "it's at a specific address" part would be dealt with not in Rust at all, but at a ground-floor-of-the-tower thing like a linker script to force that <code>static</code> to be in a particular place for the concrete machine.</p>



<a name="278214473"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/278214473" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Zoey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#278214473">(Apr 07 2022 at 19:27)</a>:</h4>
<p>Hmm. I guess that makes sense. I‚Äôll play around with linkers to see if I can create statics to <code>*mut Foo</code> of the peripherals I need</p>



<a name="278214549"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/278214549" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Zoey <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#278214549">(Apr 07 2022 at 19:27)</a>:</h4>
<p>My mind is pretty warped on what UB is by all the embedded magic that happens on microcontrollers.</p>



<a name="278218354"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/278218354" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ben Kimock (Saethlin) <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#278218354">(Apr 07 2022 at 19:59)</a>:</h4>
<p>Strict provenance is not so much about UB. It's about seeing if we can ruthlessly cut things away so that we can have a simple model. In reality, to ship all the software we want to, we probably can't make the simple model be The Model.</p>
<p>The messy model has a carve-out for magicking up a pointer to any memory that you are absolutely certain will never be part of your normal memory. This is of course difficult/impossible to validate. Thus, the desire to write code against a simpler one.</p>



<a name="278218543"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/278218543" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ben Kimock (Saethlin) <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#278218543">(Apr 07 2022 at 20:00)</a>:</h4>
<p>So if you can't do the magic static, you can still be free from UB, you'll just be much more on your own with that.</p>



<a name="278235082"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/278235082" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chayim Refael Friedman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#278235082">(Apr 07 2022 at 22:32)</a>:</h4>
<blockquote>
<p>Strict provenance is not so much about UB. It's about seeing if we can ruthlessly cut things away so that we can have a simple model. In reality, to ship all the software we want to, we probably can't make the simple model be The Model.</p>
</blockquote>
<p>Not alone, especially not now because we already have non-conforming code, but the strictness of <code>addr()</code>/<code>with_addr()</code> <em>can</em> be exploited for optimizations.</p>



<a name="278235276"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/278235276" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ben Kimock (Saethlin) <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#278235276">(Apr 07 2022 at 22:34)</a>:</h4>
<p><em>can</em> be, but I do not think it will be</p>



<a name="278237857"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/278237857" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chayim Refael Friedman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#278237857">(Apr 07 2022 at 23:06)</a>:</h4>
<p>Why not? Provenance is a nightmare for compiler developers, they'll be happy to get rid of it as much as they can.</p>



<a name="278238124"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/278238124" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chayim Refael Friedman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#278238124">(Apr 07 2022 at 23:10)</a>:</h4>
<p>Anyway, it is clearly stated that breaking the rules is UB:</p>
<p><code>ptr::addr()</code>:</p>
<blockquote>
<p>However, unlike self as usize, casting the returned address back to a pointer yields <code>invalid</code>, which is undefined behavior to dereference.</p>
</blockquote>
<p><code>ptr::with_addr()</code>(though I think we need to be more clear):</p>
<blockquote>
<p>This is equivalent to using <code>wrapping_offset</code> to offset self to the given address, and therefore has all the same capabilities and restrictions.</p>
</blockquote>
<p>And in the <code>wrapping_offset()</code> docs:</p>
<blockquote>
<p>The resulting pointer ‚Äúremembers‚Äù the allocated object that <code>self</code> points to; it must not be used to read or write other allocated objects.</p>
</blockquote>



<a name="278238472"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/278238472" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#278238472">(Apr 07 2022 at 23:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="491181">Zoey</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/278210028">said</a>:</p>
<blockquote>
<p>What is the solution for this class of issue?</p>
</blockquote>
<p>I wouldn't be worried. Provenance etc. is about making it illegal to guess the address of a local variable. Nobody wants to take your ability to use memory-mapped I/O.</p>
<p>In due time, we should complete the narrative though so that this is <em>documented</em>.</p>



<a name="278239976"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/278239976" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ben Kimock (Saethlin) <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#278239976">(Apr 07 2022 at 23:35)</a>:</h4>
<p><span class="user-mention" data-user-id="340138">@Chayim Refael Friedman</span> Strict Provenance is an experiment, and none of it is normative over the language. If we taught the compiler backend about the library contracts, sure, it could be exploited for optimizations. But it won't be baked into the language because even Stacked Borrows all on its own declares so much code UB that I do not think that a vastly stricter model has a chance of being used by an optimizer.</p>
<p>The reason it <em>won't</em> be has been discussed to death in this very topic. There is a lot of code that does not conform to strict provenance, and there is no known way to draw boundaries for an optimizer to prevent non-strict-provenance code from being miscompiled. If nothing else, LTO and particularly cross-language LTO destroy even crate boundaries.</p>



<a name="278240175"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/278240175" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#278240175">(Apr 07 2022 at 23:38)</a>:</h4>
<p>I think the precise behavior should be well-documented though. Because I suspect <code>int as ptr</code> will be redefined as <code>from_exposed_addr</code>, and MMIO addresses were never explicitly exposed from Rust</p>



<a name="278240460"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/278240460" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chayim Refael Friedman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#278240460">(Apr 07 2022 at 23:42)</a>:</h4>
<blockquote>
<p>Strict Provenance is an experiment, and none of it is normative over the language.</p>
</blockquote>
<p>Of course I was talking only about the case we'll decide we want it as part of the language.</p>
<blockquote>
<p>But it won't be baked into the language because even Stacked Borrows all on its own declares so much code UB that I do not think that a vastly stricter model has a chance of being used by an optimizer.</p>
</blockquote>
<p>But this is not just a model: this is a library API. This is something SB cannot handle alone, because it doesn't have the required information to restore provenance and has to assume things like PNVI.</p>
<blockquote>
<p>There is a lot of code that does not conform to strict provenance</p>
</blockquote>
<p>This is why we have <code>expose_addr()</code> and <code>from_exposed_addr()</code> (or <code>as</code> casts which are less clear about the intention but do the same). Do you think optimizing solely based on <code>addr()</code>/<code>with_addr()</code> calls will break existing code?</p>



<a name="278243542"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/278243542" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ben Kimock (Saethlin) <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#278243542">(Apr 08 2022 at 00:26)</a>:</h4>
<p>Optimizing just based on those function calls would be fine, but I do not think it is likely to ever optimize based on those function calls.</p>



<a name="278324929"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/278324929" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brooks Davis <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#278324929">(Apr 08 2022 at 16:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="491181">Zoey</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/278210028">said</a>:</p>
<blockquote>
<p>I‚Äôm reading through all the strict provenance docs and I can‚Äôt see how we‚Äôre supposed to create pointers out of thin air under it. Example of why I want/need to do this: on an embedded microcontroller there will be a peripheral located at some address X. I don‚Äôt have a preexisting pointer with the provenance of that peripheral. So I cant use <code>with_addr</code>. What is the solution for this class of issue?</p>
</blockquote>
<p>In the world of CHERI, there's always a capability covering the whole address space at CPU reset (currently it's in both the default data capability (DDC) and program counter capability (PCC) registers). In early startup, the kernel will save (and probably subdivide) that capability for later use for things like creating a pointer to MMIO regions.<br>
For example, in CheriBSD we carve it into user space, kernel, device space, etc in <code>cheri_init_capabilities()</code> which is called from <code>_start()</code> <a href="https://github.com/CTSRD-CHERI/cheribsd/blob/2681a143af26941d54997cfd47e645dcdfbdf3ea/sys/arm64/cheri/cheri_machdep.c#L49">https://github.com/CTSRD-CHERI/cheribsd/blob/2681a143af26941d54997cfd47e645dcdfbdf3ea/sys/arm64/cheri/cheri_machdep.c#L49</a><br>
I'd expect that if strict provenance became the default you'd expose this mechanism as a bit of (effectively no-op) magic at the bottom of the target implementations.</p>



<a name="278330140"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict%20provenance/near/278330140" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Strict.20provenance.html#278330140">(Apr 08 2022 at 16:38)</a>:</h4>
<p>There was some discussion towards the beginning about an API that acts like <code>malloc</code> but claims some memory with a specified address that is not otherwise used by rust, which would be usable by things like MMIO. I think it was called <code>fake_alloc</code>? It got dropped from the version of strict provenance that made it to nightly, but I would like to see it come back in some form, because I do think we need a better story for these kinds of allocations in strict provenance</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>