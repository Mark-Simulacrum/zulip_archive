<html>
<head><meta charset="utf-8"><title>Question about addr_of! and nested derefs · t-lang/wg-unsafe-code-guidelines · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/index.html">t-lang/wg-unsafe-code-guidelines</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Question.20about.20addr_of!.20and.20nested.20derefs.html">Question about addr_of! and nested derefs</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="269950800"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Question%20about%20addr_of%21%20and%20nested%20derefs/near/269950800" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick12 <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Question.20about.20addr_of!.20and.20nested.20derefs.html#269950800">(Jan 30 2022 at 19:23)</a>:</h4>
<p>Is the following UB?</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">core</span>::<span class="n">ptr</span>::<span class="p">{</span><span class="n">addr_of</span><span class="p">,</span><span class="w"> </span><span class="n">addr_of_mut</span><span class="p">};</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">core</span>::<span class="n">mem</span>::<span class="n">MaybeUninit</span><span class="p">;</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="cp">#[derive(Copy, Clone)]</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span> <span class="nc">X</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">field</span>: <span class="kt">u8</span> <span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span>: <span class="nc">MaybeUninit</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MaybeUninit</span>::<span class="n">uninit</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">x_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">X</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="fm">dbg!</span><span class="p">(</span><span class="n">addr_of</span><span class="o">!</span><span class="p">((</span><span class="o">*</span><span class="n">x_ptr</span><span class="p">).</span><span class="n">field</span><span class="p">));</span><span class="w"></span>

<span class="w">        </span><span class="cp">#[derive(Copy, Clone)]</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span> <span class="nc">Y</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">ptr</span>: <span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">X</span><span class="p">,</span><span class="w"> </span><span class="n">_r</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="nb">static</span> <span class="kt">u8</span> <span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">y</span>: <span class="nc">MaybeUninit</span><span class="o">&lt;</span><span class="n">Y</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MaybeUninit</span>::<span class="n">uninit</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">y_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">Y</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">addr_of_mut</span><span class="o">!</span><span class="p">((</span><span class="o">*</span><span class="n">y_ptr</span><span class="p">).</span><span class="n">ptr</span><span class="p">).</span><span class="n">write</span><span class="p">(</span><span class="n">x_ptr</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Is this UB?</span>
<span class="w">        </span><span class="c1">// Does the deref in (*y_ptr).ptr assert _r is init and nonnull?</span>
<span class="w">        </span><span class="fm">dbg!</span><span class="p">(</span><span class="n">addr_of</span><span class="o">!</span><span class="p">((</span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">y_ptr</span><span class="p">).</span><span class="n">ptr</span><span class="p">).</span><span class="n">field</span><span class="p">));</span><span class="w"></span>

<span class="w">        </span><span class="k">fn</span> <span class="nf">f</span><span class="p">(</span><span class="n">_y</span>: <span class="nc">Y</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="w">        </span><span class="c1">// MIRI does consider this to be UB</span>
<span class="w">        </span><span class="c1">// Undefined Behavior: type validation failed at ._r: encountered uninitialized reference</span>
<span class="w">        </span><span class="c1">//f(*y_ptr);</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>



<a name="269954100"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Question%20about%20addr_of%21%20and%20nested%20derefs/near/269954100" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Frank Steffahn <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Question.20about.20addr_of!.20and.20nested.20derefs.html#269954100">(Jan 30 2022 at 20:14)</a>:</h4>
<p>Assuming you don’t mean the commented-out part that MIRI rightfully complains about, as far as my intuition about these things goes, this should indeed <em>not</em> be UB.</p>
<p>The deref of <code>*y_ptr</code> (in a place expression context!) doesn’t assert anything about <code>y_ptr</code> being initialized, it’s only important that it’s “dereferenceable”, characterized in the standard library docs as “the memory range of the given size starting at the pointer must all be within the bounds of a single allocated object”. Now of course it’s important what the respective place-expression context does with <code>*y_ptr</code>. Field projections (that don’t involve deref coercions) should always be safe when the original dereferencing was safe, so <code>(*y_ptr).ptr</code> is a fine place expression. In the expression in question, it’s used for yet-another dereference expression. Dereferencing operation takes a <em>value</em>, so the <em>place</em> <code>(*y_ptr).ptr</code> is <em>read</em>, hence the location must be <em>valid</em> for reading. As far as I can tell, it <em>is valid</em>, because the location is just a value on the stack that happens to be initialized due to the previous call to <code>.write</code> on a pointer to the same place. The resulting _value_ of evaluating/reading (i.e. copying) <code>(*y_ptr).ptr</code> is the value of <code>x_ptr</code> that was written there, and this pointer is being dereferenced then… the remaining considerations are then the same as for the soundness of <code>dbg!(addr_of!((*x_ptr).field))</code>.</p>
<p>To rephrase / summarize and directly answer the question “<code>Does the deref in (*y_ptr).ptr assert _r is init and nonnull?</code>”: First, I’m not 100% sure which of the two derefs you mean… probably the inner one… a deref alone doesn’t assert anything beyond the fact that the pointer being dereferenced points to some resonable memory location that’s “within the bounds of a single allocated object”, so dereferencing doesn’t care about initialization; but dereferencing creates a <em>place expression</em> and using place expressions in value expression contexts will move or copy the value out of the place. The place expression <code>*y_ptr</code> however is used in a place expression context (a field projection) so there’s no reading from the whole place <code>*y_ptr</code> refers to, only the value at the place <code>(*y_ptr).ptr</code> is accessed/copied, because of the outer deref… not because it’s a deref operation but merely because the pointer argument of a pointer-deref operation is a value expression context. (At least I think it is… <a href="https://doc.rust-lang.org/reference/expressions.html#place-expressions-and-value-expressions">the reference explains more background</a> about place expressions and value expressions, and while it lists “operand of dereference operator” as a place expression context, I think this only applies to the overloaded case, i.e. <em>not</em> to dereference operator on pointers or <code>&amp;T</code> or <code>&amp;mut T</code>.)</p>
<p>The function call <code>f(*y_ptr)</code> evaluates <code>*y_ptr</code> in a value expression context, so – similar to above – this means that the value at this place is read (i.e. copied). But the place here is the entire struct <code>y</code> whose <code>_r</code> field is still uninitialized, resulting in UB because we’re creating an uninitialized <code>&amp;'static u8</code>.</p>
<p>Note that this is just my understanding of the situation from reading standard library docs or previous discussions online, so I might be wrong about things.</p>



<a name="269956410"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Question%20about%20addr_of%21%20and%20nested%20derefs/near/269956410" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Question.20about.20addr_of!.20and.20nested.20derefs.html#269956410">(Jan 30 2022 at 20:48)</a>:</h4>
<p>Another argument here is that if we imagine there being no maybe-uninits, and consider borrows instead, if you have an outstanding <code>&amp;mut</code> borrow to a <code>_r</code> field, then you can still do <code>&amp;mut (*(*y_ptr).ptr).field</code>. So this really "proves" that these place accesses only relate to the mentioned fields, not the others.</p>



<a name="271009631"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Question%20about%20addr_of%21%20and%20nested%20derefs/near/271009631" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Question.20about.20addr_of!.20and.20nested.20derefs.html#271009631">(Feb 07 2022 at 17:07)</a>:</h4>
<p><span class="user-mention" data-user-id="280891">@Frank Steffahn</span> that's a great description, I could not have said it better :)</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>