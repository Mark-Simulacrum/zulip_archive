<html>
<head><meta charset="utf-8"><title>Does == have to ignore provenance? · t-lang/wg-unsafe-code-guidelines · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/index.html">t-lang/wg-unsafe-code-guidelines</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.3D.3D.20have.20to.20ignore.20provenance.3F.html">Does == have to ignore provenance?</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="250478591"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%3D%3D%20have%20to%20ignore%20provenance%3F/near/250478591" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> hannahE2 <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.3D.3D.20have.20to.20ignore.20provenance.3F.html#250478591">(Aug 24 2021 at 12:43)</a>:</h4>
<p><a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/286#issue-913788476">https://github.com/rust-lang/unsafe-code-guidelines/issues/286#issue-913788476</a> shows an example in which <code>==</code> is assumed to ignore provenance when comparing <code>usize</code> at least. </p>
<p>Does it have to?</p>



<a name="250483547"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%3D%3D%20have%20to%20ignore%20provenance%3F/near/250483547" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.3D.3D.20have.20to.20ignore.20provenance.3F.html#250483547">(Aug 24 2021 at 13:20)</a>:</h4>
<p>It would be extremely shocking and in my opinion broken if equality on usize was anything other than a numeric value comparison.</p>



<a name="250487512"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%3D%3D%20have%20to%20ignore%20provenance%3F/near/250487512" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Kestrer <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.3D.3D.20have.20to.20ignore.20provenance.3F.html#250487512">(Aug 24 2021 at 13:50)</a>:</h4>
<p>Provenance isn't really a runtime thing so I don't know if it even makes sense to compare it</p>



<a name="250495309"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%3D%3D%20have%20to%20ignore%20provenance%3F/near/250495309" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.3D.3D.20have.20to.20ignore.20provenance.3F.html#250495309">(Aug 24 2021 at 14:44)</a>:</h4>
<blockquote>
<p>Provenance isn't really a runtime thing so I don't know if it even makes sense to compare it</p>
</blockquote>
<p>Well, for pointers, there is an argument to be made that it can. For example, the C++ standard states that the result of comparing a pointer past-the-end of one object with a pointer to another is unspecified - even if it would otherwise be true (because the two pointers represent the same address, either by chance or by abi requirement). Whether or not this is intended to be true of rust, I don't know (llvm may make doing that difficult, though). Though for integers, this should not impact the result at all.</p>



<a name="250505417"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%3D%3D%20have%20to%20ignore%20provenance%3F/near/250505417" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nagisa <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.3D.3D.20have.20to.20ignore.20provenance.3F.html#250505417">(Aug 24 2021 at 15:52)</a>:</h4>
<p>yeah, the compiler can utilize provenance of the pointer to optimize out the comparison entirely.</p>



<a name="250505433"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%3D%3D%20have%20to%20ignore%20provenance%3F/near/250505433" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nagisa <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.3D.3D.20have.20to.20ignore.20provenance.3F.html#250505433">(Aug 24 2021 at 15:52)</a>:</h4>
<p>that's what allows to elide e.g. null checks.</p>



<a name="250505593"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%3D%3D%20have%20to%20ignore%20provenance%3F/near/250505593" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nagisa <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.3D.3D.20have.20to.20ignore.20provenance.3F.html#250505593">(Aug 24 2021 at 15:53)</a>:</h4>
<p>Compiler may also elide various ptrtoint conversions if it deems that possible for some reason, which would make provenance-free usize comparison into a provenance-aware ptr comparison.</p>



<a name="250552380"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%3D%3D%20have%20to%20ignore%20provenance%3F/near/250552380" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> hannahE2 <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.3D.3D.20have.20to.20ignore.20provenance.3F.html#250552380">(Aug 24 2021 at 21:34)</a>:</h4>
<blockquote>
<p>It would be extremely shocking and in my opinion broken if equality on usize was anything other than a numeric value comparison.</p>
</blockquote>
<p>The same argument can be made about comparing pointers, e.g., "It would be extremely shocking and broken if equality on pointers was anything other than a comparison of the pointer address bit representation".</p>



<a name="250552612"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%3D%3D%20have%20to%20ignore%20provenance%3F/near/250552612" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> hannahE2 <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.3D.3D.20have.20to.20ignore.20provenance.3F.html#250552612">(Aug 24 2021 at 21:36)</a>:</h4>
<p>If we were to allow provenance to play a role in integers that are actually pointer addresses, we would need a way to remove that. We could add a <code>freeze</code>-like operation that explicitly removes it.</p>



<a name="250565875"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%3D%3D%20have%20to%20ignore%20provenance%3F/near/250565875" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.3D.3D.20have.20to.20ignore.20provenance.3F.html#250565875">(Aug 25 2021 at 00:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="409057">hannahE2</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Does.20.3D.3D.20have.20to.20ignore.20provenance.3F/near/250552380">said</a>:</p>
<blockquote>
<blockquote>
<p>It would be extremely shocking and in my opinion broken if equality on usize was anything other than a numeric value comparison.</p>
</blockquote>
<p>The same argument can be made about comparing pointers, e.g., "It would be extremely shocking and broken if equality on pointers was anything other than a comparison of the pointer address bit representation".</p>
</blockquote>
<p>I believe that is also the case, though</p>



<a name="250565885"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%3D%3D%20have%20to%20ignore%20provenance%3F/near/250565885" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.3D.3D.20have.20to.20ignore.20provenance.3F.html#250565885">(Aug 25 2021 at 00:03)</a>:</h4>
<p>using the <code>==</code> function on two pointers compares them bitwise</p>



<a name="250566095"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%3D%3D%20have%20to%20ignore%20provenance%3F/near/250566095" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.3D.3D.20have.20to.20ignore.20provenance.3F.html#250566095">(Aug 25 2021 at 00:06)</a>:</h4>
<p>However it may be the case that comparing pointers of different provenance is UB. This is how it is in C/C++, and probably what you get by default from LLVM, but I'm not sure if Rust has decided whether to use this or specify always defined bitwise comparison. In any case, a bitwise comparison is always a correct implementation, but having UB there also allows the compiler to optimize some such comparisons to <code>false</code> instead of comparing anything.</p>



<a name="250566109"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%3D%3D%20have%20to%20ignore%20provenance%3F/near/250566109" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.3D.3D.20have.20to.20ignore.20provenance.3F.html#250566109">(Aug 25 2021 at 00:07)</a>:</h4>
<p>I think it isn't possible for Rust to allow <code>==</code> on two source level <code>*const T</code>s to be UB because this operation is safe</p>



<a name="250576317"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%3D%3D%20have%20to%20ignore%20provenance%3F/near/250576317" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.3D.3D.20have.20to.20ignore.20provenance.3F.html#250576317">(Aug 25 2021 at 03:21)</a>:</h4>
<blockquote>
<p>However it may be the case that comparing pointers of different provenance is UB. This is how it is in C/C++, and probably what you get by default from LLVM, but I'm not sure if Rust has decided whether to use this or specify always defined bitwise comparison. In any case, a bitwise comparison is always a correct implementation, but having UB there also allows the compiler to optimize some such comparisons to <code>false</code> instead of comparing anything.</p>
</blockquote>
<p>It is not UB in C++. In fact, equality comparison is well-defined in C++ on valid pointer values pairwise, except when comparing a past-the-end pointer with a pointer to a different object. I noted this above.</p>



<a name="250576413"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%3D%3D%20have%20to%20ignore%20provenance%3F/near/250576413" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.3D.3D.20have.20to.20ignore.20provenance.3F.html#250576413">(Aug 25 2021 at 03:23)</a>:</h4>
<p>So, given</p>
<div class="codehilite" data-code-language="C++"><pre><span></span><code><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">;</span>
</code></pre></div>
<p>p==q is well-defined (false) and (p+1)==q is unspecified (not undefined). The optimization you mentioned is still allowed, though.</p>



<a name="250576551"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%3D%3D%20have%20to%20ignore%20provenance%3F/near/250576551" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.3D.3D.20have.20to.20ignore.20provenance.3F.html#250576551">(Aug 25 2021 at 03:26)</a>:</h4>
<p>I presume rust inherited this rule, though whether or not it was by choice, I wouldn't know.</p>



<a name="252033578"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%3D%3D%20have%20to%20ignore%20provenance%3F/near/252033578" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.3D.3D.20have.20to.20ignore.20provenance.3F.html#252033578">(Sep 04 2021 at 23:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="360486">Kestrer</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Does.20.3D.3D.20have.20to.20ignore.20provenance.3F/near/250487512">said</a>:</p>
<blockquote>
<p>Provenance isn't really a runtime thing so I don't know if it even makes sense to compare it</p>
</blockquote>
<p>it is a thing in the runtime of the Abstract Machine. the actual runtime on a real CPU has to be a correct simulation of that abstract machine behavior.</p>



<a name="252033626"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%3D%3D%20have%20to%20ignore%20provenance%3F/near/252033626" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.3D.3D.20have.20to.20ignore.20provenance.3F.html#252033626">(Sep 04 2021 at 23:24)</a>:</h4>
<p><span class="user-mention silent" data-user-id="123586">nagisa</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Does.20.3D.3D.20have.20to.20ignore.20provenance.3F/near/250505417">said</a>:</p>
<blockquote>
<p>yeah, the compiler can utilize provenance of the pointer to optimize out the comparison entirely.</p>
</blockquote>
<p>hm, no I dont think it can actually</p>



<a name="252033667"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%3D%3D%20have%20to%20ignore%20provenance%3F/near/252033667" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.3D.3D.20have.20to.20ignore.20provenance.3F.html#252033667">(Sep 04 2021 at 23:25)</a>:</h4>
<p>for integers, there is (almost certainly) no provenance anyway, so the question is moot</p>



<a name="252033694"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%3D%3D%20have%20to%20ignore%20provenance%3F/near/252033694" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.3D.3D.20have.20to.20ignore.20provenance.3F.html#252033694">(Sep 04 2021 at 23:26)</a>:</h4>
<p>but for pointers, it is a good question. my understanding is that in LLVM, ptr comparison (both equality but also greater/less) is always well-defined and ignores provenance. that would be the intended semantics for Rust as well, I'd say.</p>



<a name="252034565"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%3D%3D%20have%20to%20ignore%20provenance%3F/near/252034565" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.3D.3D.20have.20to.20ignore.20provenance.3F.html#252034565">(Sep 04 2021 at 23:43)</a>:</h4>
<p>That's a relief.</p>



<a name="252034571"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%3D%3D%20have%20to%20ignore%20provenance%3F/near/252034571" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.3D.3D.20have.20to.20ignore.20provenance.3F.html#252034571">(Sep 04 2021 at 23:44)</a>:</h4>
<p>It's important to be able to compare arbitrary unrelated pointers.</p>



<a name="252034624"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%3D%3D%20have%20to%20ignore%20provenance%3F/near/252034624" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.3D.3D.20have.20to.20ignore.20provenance.3F.html#252034624">(Sep 04 2021 at 23:44)</a>:</h4>
<p>For instance, consider the approach of avoiding ABBA deadlocks by sorting lock acquisition by address.</p>



<a name="252088269"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%3D%3D%20have%20to%20ignore%20provenance%3F/near/252088269" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.3D.3D.20have.20to.20ignore.20provenance.3F.html#252088269">(Sep 05 2021 at 16:58)</a>:</h4>
<p>yeah I know this is done in real life, but it's also UB in C (and maybe C++) which makes the situation tricky given that we are basically using a C compiler as a backend^^</p>



<a name="252088328"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%3D%3D%20have%20to%20ignore%20provenance%3F/near/252088328" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.3D.3D.20have.20to.20ignore.20provenance.3F.html#252088328">(Sep 05 2021 at 17:00)</a>:</h4>
<p>and LLVM does some... shady... things around ptr comparison. however I think they still intent to uphold the semantics as I described it above. It will be interesting what happens if/when it ever turns out that that is fundamentally incompatible with an optimization they want to perform...</p>



<a name="252089384"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%3D%3D%20have%20to%20ignore%20provenance%3F/near/252089384" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.3D.3D.20have.20to.20ignore.20provenance.3F.html#252089384">(Sep 05 2021 at 17:17)</a>:</h4>
<p>I noted that C++ makes it well-defined to compare pointers for equality <em>except</em> comparing a past-the-end pointer to a pointer-to-object (which is unspecified, not undefined).<br>
See <a href="http://eel.is/c++draft/expr.eq#3">http://eel.is/c++draft/expr.eq#3</a>.<br>
Relational operators on pointers from different arrays/objects are only unspecified</p>



<a name="252089537"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%3D%3D%20have%20to%20ignore%20provenance%3F/near/252089537" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Gary Guo <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.3D.3D.20have.20to.20ignore.20provenance.3F.html#252089537">(Sep 05 2021 at 17:20)</a>:</h4>
<p>Equality comparison is well-defined, but &lt; &gt; are not.</p>



<a name="252917880"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%3D%3D%20have%20to%20ignore%20provenance%3F/near/252917880" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.3D.3D.20have.20to.20ignore.20provenance.3F.html#252917880">(Sep 11 2021 at 15:50)</a>:</h4>
<blockquote>
<p>I noted that C++ makes it well-defined to compare pointers for equality except comparing a past-the-end pointer to a pointer-to-object (which is unspecified, not undefined).</p>
</blockquote>
<p><span class="user-mention" data-user-id="257758">@Connor Horman</span> doesnt C++ do "pointer lifetime end zapping", whereby pointers to an object become indeterminate when that object is deallocated? (C does that, not sure about C++) and then comparing indeterminate pointers is... UB or unspecified I guess? So that would be another case for this list.</p>



<a name="252920011"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%3D%3D%20have%20to%20ignore%20provenance%3F/near/252920011" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.3D.3D.20have.20to.20ignore.20provenance.3F.html#252920011">(Sep 11 2021 at 16:26)</a>:</h4>
<p>I believe so. Specifically, I believe deallocating an object turns pointers into an indeterminate value. It's at the end of the object's storage duration, though, not lifetime (which is different since C++ lets you forcibly end object lifetimes, then create new ones in that storage)</p>



<a name="252920125"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%3D%3D%20have%20to%20ignore%20provenance%3F/near/252920125" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.3D.3D.20have.20to.20ignore.20provenance.3F.html#252920125">(Sep 11 2021 at 16:28)</a>:</h4>
<p>(Though outside of doing allocator stuff, or stuff that's cursed for C++ standards, the only real difference for automatic objects is the length of the destructor - if any).</p>



<a name="252920194"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%3D%3D%20have%20to%20ignore%20provenance%3F/near/252920194" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.3D.3D.20have.20to.20ignore.20provenance.3F.html#252920194">(Sep 11 2021 at 16:29)</a>:</h4>
<p>If I'm correct about it being an indeterminate value (and not just an indeterminate pointer), the question about comparing them is that you won't even get that far before UB.</p>



<a name="252920283"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%3D%3D%20have%20to%20ignore%20provenance%3F/near/252920283" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.3D.3D.20have.20to.20ignore.20provenance.3F.html#252920283">(Sep 11 2021 at 16:30)</a>:</h4>
<p>Oh, should have checked. I'm wrong, it becomes an invalid pointer value<br>
<a href="http://eel.is/c++draft/basic.stc#general-4">http://eel.is/c++draft/basic.stc#general-4</a><br>
Indirecting it is UB, everything else is implementation-defined.</p>



<a name="252920462"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does%20%3D%3D%20have%20to%20ignore%20provenance%3F/near/252920462" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Does.20.3D.3D.20have.20to.20ignore.20provenance.3F.html#252920462">(Sep 11 2021 at 16:34)</a>:</h4>
<p>(Although, the footnote implies trivial copying is included in "everything else", so, uh, a well-documented indeterminate value I guess)</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>