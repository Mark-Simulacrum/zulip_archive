<html>
<head><meta charset="utf-8"><title>`offset/wrapping_offset` pointer methods and `isize::MAX` · t-lang/wg-unsafe-code-guidelines · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/index.html">t-lang/wg-unsafe-code-guidelines</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/.60offset.2Fwrapping_offset.60.20pointer.20methods.20and.20.60isize.3A.3AMAX.60.html">`offset/wrapping_offset` pointer methods and `isize::MAX`</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="257815577"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/%60offset/wrapping_offset%60%20pointer%20methods%20and%20%60isize%3A%3AMAX%60/near/257815577" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/.60offset.2Fwrapping_offset.60.20pointer.20methods.20and.20.60isize.3A.3AMAX.60.html#257815577">(Oct 16 2021 at 08:56)</a>:</h4>
<p>I was reading <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/.60usize.60.20vs.20.60size_t.60">this Zulip thread</a>, where a <a href="https://internals.rust-lang.org/t/pre-rfc-usize-is-not-size-t/15369">pre-RFC</a> was spawned related to the question of usize/isize vs size_t/ssize_t. In the documentation for <a href="https://doc.rust-lang.org/std/primitive.pointer.html#method.offset-1"><code>&lt;*mut T&gt;::offset()</code></a> it mentions:</p>
<blockquote>
<p>...<br>
The computed offset, in bytes, cannot overflow an <code>isize</code>.<br>
...<br>
some 32-bit and 16-bit platforms may successfully serve a request for more than <code>isize::MAX</code> bytes with things like Physical Address Extension. As such, memory acquired directly from allocators or memory mapped files may be too large to handle with this function.<br>
...</p>
</blockquote>
<p>If the above mentioned (pre-)RFC eventually gets accepted, would the description in the documentation still be accurate? If I read the <a href="https://llvm.org/docs/GetElementPtr.html">LLVM documentation</a> about <code>GEP</code>, it seems that LLVM hints that it expects an <code>ssize_t</code> as the offset parameter:</p>
<blockquote>
<p>...<br>
GEP does use target-dependent parameters for the size and layout of data types, which targets can customize.<br>
...<br>
Indexing into an array only depends on the size of the array element, not the number of elements.<br>
...<br>
As such, there are some ramifications of this for inbounds GEPs: scales implied by array/vector/pointer indices are always known to be “nsw” since they are signed values that are scaled by the element size.<br>
...</p>
</blockquote>
<p>This then would seem to conflict with the Rust documentation for <code>offset()</code> if:</p>
<ul>
<li><code>isize</code> is not guaranteed to be equal to <code>ssize_t</code> and</li>
<li><code>isize</code> is the same as <code>intptr_t</code> and</li>
<li><code>ssize_t != intptr_t</code> on the target platform, because informally stated, this implies that <code>isize::MAX &gt; ssize_t::MAX</code>.</li>
</ul>
<p>Is this a correct observation? Should I use <a href="https://doc.rust-lang.org/std/primitive.pointer.html#method.wrapping_offset-1"><code>&lt;*mut T&gt;::wrapping_offset()</code></a> already instead to protect against this possible future incompatibility? Or will <code>&lt;*mut T&gt;::wrapping_offset()</code> have the same problem when eventually dereferencing the resulting pointer?</p>



<a name="257818737"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/%60offset/wrapping_offset%60%20pointer%20methods%20and%20%60isize%3A%3AMAX%60/near/257818737" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/.60offset.2Fwrapping_offset.60.20pointer.20methods.20and.20.60isize.3A.3AMAX.60.html#257818737">(Oct 16 2021 at 09:50)</a>:</h4>
<blockquote>
<p>Or will &lt;*mut T&gt;::wrapping_offset() have the same problem when eventually dereferencing the resulting pointer?</p>
</blockquote>
<p>Assuming my other observations are correct, I think I can already answer this part of my own question. The <a href="https://llvm.org/docs/LangRef.html#id233">LLVM reference says</a>:</p>
<blockquote>
<p>If the inbounds keyword is not present, the offsets are added to the base address with silently-wrapping two’s complement arithmetic. If the offsets have a different width from the pointer, they are sign-extended or truncated to the width of the pointer. The result value of the getelementptr may be outside the object pointed to by the base pointer. The result value may not necessarily be used to access memory though, <strong>even if it happens to point into allocated storage</strong>. See the Pointer Aliasing Rules section for more information.</p>
</blockquote>



<a name="257818902"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/%60offset/wrapping_offset%60%20pointer%20methods%20and%20%60isize%3A%3AMAX%60/near/257818902" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/.60offset.2Fwrapping_offset.60.20pointer.20methods.20and.20.60isize.3A.3AMAX.60.html#257818902">(Oct 16 2021 at 09:53)</a>:</h4>
<p>Oh wait, I think I read that wrong. "allocated storage" means something different than "the same allocated object or one past the end", I think. So, I believe that answer is still inconclusive :)</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>