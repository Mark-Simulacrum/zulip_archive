<html>
<head><meta charset="utf-8"><title>Formal memory models · t-lang/wg-unsafe-code-guidelines · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/index.html">t-lang/wg-unsafe-code-guidelines</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal.20memory.20models.html">Formal memory models</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="277532517"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal%20memory%20models/near/277532517" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal.20memory.20models.html#277532517">(Apr 02 2022 at 14:27)</a>:</h4>
<p>In <a href="https://hackmd.io/I-zHe9bZTJOY78orP1aYIA">https://hackmd.io/I-zHe9bZTJOY78orP1aYIA</a> , I wrote down my understanding of the formal memory models under consideration, with two specific programs that are(n’t) UB. Is my understanding about (non)-UB correct?</p>



<a name="277532706"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal%20memory%20models/near/277532706" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal.20memory.20models.html#277532706">(Apr 02 2022 at 14:31)</a>:</h4>
<p>For those programs specifically</p>



<a name="277629308"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal%20memory%20models/near/277629308" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal.20memory.20models.html#277629308">(Apr 03 2022 at 13:33)</a>:</h4>
<p>the 2nd example <em>is</em> UB under permissive provenance</p>



<a name="277629322"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal%20memory%20models/near/277629322" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal.20memory.20models.html#277629322">(Apr 03 2022 at 13:33)</a>:</h4>
<p>under the version I have been promoting the last week, anyway</p>



<a name="277629421"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal%20memory%20models/near/277629421" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal.20memory.20models.html#277629421">(Apr 03 2022 at 13:34)</a>:</h4>
<p>the following is not UB:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">storage</span><span class="w"> </span>: <span class="kt">i8</span> <span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">x_int</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">storage</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">;</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">y</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">storage</span><span class="p">;</span><span class="w"></span>

<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="sd">//! ------------------------------------</span>
<span class="w">    </span><span class="sd">//!</span>
<span class="w">    </span><span class="sd">//!   - x_int : usize</span>
<span class="w">    </span><span class="sd">//!   - y :     &amp;mut i8</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">y_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">i8</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="n">y_ptr</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">// The raw pointer receives provenance from y_ptr! 🤯</span>
<span class="w">    </span><span class="o">*</span><span class="p">(</span><span class="n">x_int</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">i8</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">12</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="o">*</span><span class="n">y_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">34</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">storage</span><span class="w"></span>
</code></pre></div>



<a name="277629493"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal%20memory%20models/near/277629493" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal.20memory.20models.html#277629493">(Apr 03 2022 at 13:35)</a>:</h4>
<p><code>x_int as *mut i8</code> needs to be able to pick some <em>previously exposed</em> provenance, and in your version of the code no suitable provenance has been exposed. in my version, the <code>y_ptr as usize</code> does the exposing.</p>



<a name="277647609"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal%20memory%20models/near/277647609" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal.20memory.20models.html#277647609">(Apr 03 2022 at 16:18)</a>:</h4>
<p>Cool, that’s also a version that I could imagine a formalization for</p>



<a name="277647628"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal%20memory%20models/near/277647628" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal.20memory.20models.html#277647628">(Apr 03 2022 at 16:18)</a>:</h4>
<p>These alternative memory models are mostly not written up mathematically, only in code (or only informally), right?</p>



<a name="277647705"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal%20memory%20models/near/277647705" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal.20memory.20models.html#277647705">(Apr 03 2022 at 16:20)</a>:</h4>
<p>yeah</p>



<a name="277647709"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal%20memory%20models/near/277647709" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal.20memory.20models.html#277647709">(Apr 03 2022 at 16:20)</a>:</h4>
<p><span aria-label="+1" class="emoji emoji-1f44d" role="img" title="+1">:+1:</span>🏻 Thanks</p>



<a name="277647717"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal%20memory%20models/near/277647717" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal.20memory.20models.html#277647717">(Apr 03 2022 at 16:21)</a>:</h4>
<p>I will adjust the document when I have time</p>



<a name="277663658"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal%20memory%20models/near/277663658" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal.20memory.20models.html#277663658">(Apr 03 2022 at 22:05)</a>:</h4>
<p>I read the twinsem paper, and I think it's pretty ingenuous. It seems a minimal change required to LLVM to make "all" sensible C/C++ programs compile, and compile almost everything well. </p>
<p>Twinsem is a very different approach than SB/pnvi-ae — I'd call it extrinsic instead of intrinsic. In both cases there is a cost to ptr2int2ptr (what you call a "side-effect"), but Twinsem ascribes the cost to specific runtime behavior while SB/pnvi-ae ascribes it to language constructs. I think that's why LLVM refuse to call ptr2int side-effecting — because a clever compiler _doesn't_ incur a cost if you throw away the int immediately after. They can't call any construct side-effecting because the cost is in ""emergent behavior of the instructions"". </p>
<p>Intrinsic has the advantage that you can give guidance: "try to avoid ptr2int". And it seems compiling SB to Twinsem should be fine — then SB's formulation of the cost is just a bit pessimistic, it gives an overestimate of the costs you're incurring. If you follow the guidance "avoid ptr2int" then you also avoid all the costs on the LLVM side.</p>



<a name="277665383"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal%20memory%20models/near/277665383" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal.20memory.20models.html#277665383">(Apr 03 2022 at 22:43)</a>:</h4>
<p>yeah I am quite fond of twinsem. sadly the twinsem approach stops working once you have <code>restrict</code>/<code>noalias</code>/Stacked Borrows, as demonstrated by <a href="https://lists.llvm.org/pipermail/llvm-dev/2021-June/151521.html">this example</a>. I hope to finish a blog post on that soon-ish.</p>



<a name="277666562"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal%20memory%20models/near/277666562" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal.20memory.20models.html#277666562">(Apr 03 2022 at 23:10)</a>:</h4>
<p>Interesting. I'm curious for the blog post.</p>
<p>I would think that <code>foo(ptr, (uintptr_t)ptr);</code> is not legal, because under a twinsem semantics, <code>x=ptr</code> is guessable from <code>y=(uintptr_t)ptr</code>.</p>



<a name="277667482"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal%20memory%20models/near/277667482" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal.20memory.20models.html#277667482">(Apr 03 2022 at 23:33)</a>:</h4>
<p>but why would that make the call not legal?</p>



<a name="277670614"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal%20memory%20models/near/277670614" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal.20memory.20models.html#277670614">(Apr 04 2022 at 00:44)</a>:</h4>
<p>Well, we need a formal definition of <code>noalias</code>.</p>
<p><code>noalias</code> is currently informally defined as</p>
<blockquote>
<p>[noalias] indicates that memory locations accessed via pointer values based on the argument or return value are not also accessed, during the execution of the function, via pointer values not based on the argument or return value. (..) The caller shares the responsibility with the callee for ensuring that these requirements are met. (..)</p>
</blockquote>
<p>I posit the following "twinsem" definition of <code>noalias</code>.</p>
<hr>
<p>Suppose that we have</p>
<div class="codehilite" data-code-language="C"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">bar</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">noalias</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">noalias</span><span class="w"> </span><span class="n">z</span><span class="p">);</span><span class="w"></span>
</code></pre></div>
<p><code>noalias</code> puts an obligation on every execution of the whole program.</p>
<p>So let an execution of the whole program be given. In Twinsem, this execution of a program is really a set of traces.</p>
<p>Let <code>check1</code>, <code>check2</code> range over syntactic procedures that are always successful, with the following signatures</p>
<div class="codehilite" data-code-language="C"><pre><span></span><code><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="nf">check1</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">z</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="nf">check2</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">y</span><span class="p">);</span><span class="w"></span>
</code></pre></div>
<p>Suppose that as part of the execution, <code>bar</code> is called.</p>
<p>When instead of <code>bar(val_x, val_y, val_z)</code> we substitute <code>{check1(val_x, val_z); check2(val_x, val_y); bar(val1, val_y, val_z)}</code> for every call in the program, then</p>
<ul>
<li>
<p>the call to <code>check1(val_x, val_z)</code> may not reliably (in every trace of the execution) compute an address into the allocation for <code>val_y</code>,</p>
</li>
<li>
<p>the call to <code>check2(val_x, val_y)</code> may not reliably (in every trace of the execution) compute an address into the allocation for <code>val_z</code>.</p>
</li>
</ul>
<p>Otherwise, this call to <code>bar</code> generates UB.</p>
<hr>
<p>(Is this <em>the</em> formal definition? Is there a simpler one?)</p>
<p>For your <code>foo</code>, if it runs, then I think the call site fails the requirement.</p>
<p>What a mess, though.</p>



<a name="277672156"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal%20memory%20models/near/277672156" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal.20memory.20models.html#277672156">(Apr 04 2022 at 01:23)</a>:</h4>
<p>This does not match with the actual definition of <code>noalias</code> unfortunately. <code>noalias</code> is about <em>accesses</em>, not about values of pointers. It is defined behavior to pass two aliasing pointers into <code>void bar(void * noalias x, void * noalias y)</code> as long as at least one of the pointers is never dereferenced</p>



<a name="277674664"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal%20memory%20models/near/277674664" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal.20memory.20models.html#277674664">(Apr 04 2022 at 02:21)</a>:</h4>
<p>Ah, yes. Then I have no idea what <code>noalias</code> could mean formally. </p>
<p>Is <code>while (++x != y) ; *x</code> an access via x, via y, or both?</p>



<a name="277674704"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal%20memory%20models/near/277674704" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal.20memory.20models.html#277674704">(Apr 04 2022 at 02:22)</a>:</h4>
<p>Because it essentially sets x to the value of y</p>



<a name="277674723"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal%20memory%20models/near/277674723" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal.20memory.20models.html#277674723">(Apr 04 2022 at 02:22)</a>:</h4>
<p>What about <code>while (x != y) x = random()</code></p>



<a name="277674913"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal%20memory%20models/near/277674913" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal.20memory.20models.html#277674913">(Apr 04 2022 at 02:26)</a>:</h4>
<p>If x and y are the same, what about <code>(x+y) / 2</code> (disregarding overflow)</p>



<a name="277675075"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal%20memory%20models/near/277675075" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal.20memory.20models.html#277675075">(Apr 04 2022 at 02:30)</a>:</h4>
<p>LLVM doesn't support most of those operations on pointers</p>



<a name="277675083"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal%20memory%20models/near/277675083" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal.20memory.20models.html#277675083">(Apr 04 2022 at 02:31)</a>:</h4>
<p>The closest thing it has is GEP, and that only accepts one pointer argument, so things are unambiguous</p>



<a name="277675358"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal%20memory%20models/near/277675358" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal.20memory.20models.html#277675358">(Apr 04 2022 at 02:38)</a>:</h4>
<p>We can insert pointer-integer-pointer casts as needed to make the examples work</p>



<a name="277675675"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal%20memory%20models/near/277675675" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal.20memory.20models.html#277675675">(Apr 04 2022 at 02:44)</a>:</h4>
<p>Yes, but at that point you're just once more observing that LLVM's semantics around ptr2int and int2ptr casts are broken...</p>



<a name="277675697"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal%20memory%20models/near/277675697" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal.20memory.20models.html#277675697">(Apr 04 2022 at 02:45)</a>:</h4>
<p>And as far as I know, there's no published model for how PNVI-ae-udi can work with restrict/noalias</p>



<a name="277676653"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal%20memory%20models/near/277676653" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal.20memory.20models.html#277676653">(Apr 04 2022 at 03:02)</a>:</h4>
<p>I mean, you can have two entirely disjoint restrictions, like C does today; the question is whether that allows the optimizations <code>restrict</code> is intended to allow</p>



<a name="277676669"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal%20memory%20models/near/277676669" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal.20memory.20models.html#277676669">(Apr 04 2022 at 03:02)</a>:</h4>
<p>(though first you'd also need to do something about how the spec definition of <code>restrict</code> is probably more generous to programmers than anything a compiler will implement)</p>



<a name="277707536"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal%20memory%20models/near/277707536" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal.20memory.20models.html#277707536">(Apr 04 2022 at 09:53)</a>:</h4>
<p>Maybe the point of <code>noalias</code> is merely to give examples of execution patterns that are Obviously Bad, and LLVM promises to be conservative for anything that’s not Obviously Bad.</p>



<a name="277707794"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal%20memory%20models/near/277707794" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal.20memory.20models.html#277707794">(Apr 04 2022 at 09:55)</a>:</h4>
<p>The problem that Ralf is pointing out, being that optimization turns not-Obviously-Bad code into Obviously Bad</p>



<a name="277922562"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal%20memory%20models/near/277922562" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal.20memory.20models.html#277922562">(Apr 05 2022 at 18:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="465167">Bram Geron</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Formal.20memory.20models/near/277674664">said</a>:</p>
<blockquote>
<p>Ah, yes. Then I have no idea what <code>noalias</code> could mean formally. </p>
</blockquote>
<p>it's loosely something like Stacked Borrows, I think. well, without the stacks and the borrows. ;)<br>
you generate a fresh provenance for each <code>restrict</code> parameter (like SB retagging). you track which provenances are used to access each location in memory. if two 'conflicting' provenances (whatever that mean) access the same location, that is UB.</p>



<a name="277926279"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal%20memory%20models/near/277926279" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal.20memory.20models.html#277926279">(Apr 05 2022 at 18:44)</a>:</h4>
<p>Hm, that could be the start to an answer</p>



<a name="277926325"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal%20memory%20models/near/277926325" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal.20memory.20models.html#277926325">(Apr 05 2022 at 18:44)</a>:</h4>
<p>What happens here? In the first statement, we "access a memory location via a pointer value based on"... perhaps both <code>hi</code> and <code>lo1</code> arguments I guess? Is the second statement allowed? (When pointer values are based on multiple arguments, what's the boolean formula here?)</p>
<div class="codehilite" data-code-language="C"><pre><span></span><code><span class="kt">char</span><span class="w"> </span><span class="n">ptr</span><span class="p">;</span><span class="w"></span>
<span class="kt">uintptr_t</span><span class="w"> </span><span class="n">ptri</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">;</span><span class="w"></span>

<span class="n">f</span><span class="p">(</span><span class="n">ptri</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="o">~</span><span class="mh">0xff</span><span class="p">),</span><span class="w"> </span><span class="n">ptri</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="mh">0xff</span><span class="p">),</span><span class="w"> </span><span class="n">ptri</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="mh">0xff</span><span class="p">))</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="kt">uintptr_t</span><span class="w"> </span><span class="kr">restrict</span><span class="w"> </span><span class="n">hi</span><span class="p">,</span><span class="w"> </span><span class="kt">uintptr_t</span><span class="w"> </span><span class="kr">restrict</span><span class="w"> </span><span class="n">lo1</span><span class="p">,</span><span class="w"> </span><span class="kt">uintptr_t</span><span class="w"> </span><span class="n">lo2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="o">*</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">hi</span><span class="o">|</span><span class="n">lo1</span><span class="p">));</span><span class="w"> </span><span class="c1">// allowed?</span>
<span class="w">    </span><span class="o">*</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">hi</span><span class="o">|</span><span class="n">lo2</span><span class="p">));</span><span class="w"> </span><span class="c1">// allowed?</span>

<span class="w">    </span><span class="kt">uintptr_t</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">new</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">hi</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">lo1</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="n">new</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">// What is the provenance of new?</span>
<span class="w">    </span><span class="c1">//</span>
<span class="w">    </span><span class="c1">// Perhaps it has empty or fresh provenance.</span>
<span class="w">    </span><span class="c1">//</span>
<span class="w">    </span><span class="c1">// Then presumably it cannot be optimized to</span>
<span class="w">    </span><span class="c1">//</span>
<span class="w">    </span><span class="c1">//     uintptr_t new = hi | lo1</span>
<span class="w">    </span><span class="c1">//</span>
<span class="w">    </span><span class="c1">// because that would change provenance.</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>



<a name="277926829"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal%20memory%20models/near/277926829" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal.20memory.20models.html#277926829">(Apr 05 2022 at 18:48)</a>:</h4>
<p>restrict is invalid except on pointer types</p>



<a name="277926967"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal%20memory%20models/near/277926967" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal.20memory.20models.html#277926967">(Apr 05 2022 at 18:50)</a>:</h4>
<p>if they were pointers instead, I believe /currently/ accessing through <code>hi|lo2</code> is invalid if you ever access through <code>hi|lo1</code> as well</p>



<a name="277927167"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal%20memory%20models/near/277927167" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal.20memory.20models.html#277927167">(Apr 05 2022 at 18:51)</a>:</h4>
<p>the question is ill-formed since there is no <code>|</code> on pointer types ;)</p>



<a name="277927227"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal%20memory%20models/near/277927227" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal.20memory.20models.html#277927227">(Apr 05 2022 at 18:51)</a>:</h4>
<p>this goes into union provenance again which as I keep saying is a very non-trivial extension for complicated aliasing models</p>



<a name="277927249"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal%20memory%20models/near/277927249" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal.20memory.20models.html#277927249">(Apr 05 2022 at 18:52)</a>:</h4>
<p>which is why I dont think we should have it ;)</p>



<a name="277927330"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal%20memory%20models/near/277927330" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal.20memory.20models.html#277927330">(Apr 05 2022 at 18:52)</a>:</h4>
<p>and the C proposal's stance in other places is that control flow dependencies like <code>switch (*ptr) { case 0: return 0; ... }</code> should not be expected to preserve provenance (while they'd like <code>*char_x = *char_y</code> to do so that transforming manual char copies to just memcpy is valid).</p>



<a name="277927461"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal%20memory%20models/near/277927461" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal.20memory.20models.html#277927461">(Apr 05 2022 at 18:53)</a>:</h4>
<p>and for pointers <code>==</code> is not actual full equality in general anyways, so once you change hi/lo1 to pointer types that's less surprising</p>



<a name="277931638"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal%20memory%20models/near/277931638" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal.20memory.20models.html#277931638">(Apr 05 2022 at 19:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="143798">Talchas</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Formal.20memory.20models/near/277926829">said</a>:</p>
<blockquote>
<p>restrict is invalid except on pointer types</p>
</blockquote>
<p>I should have written <code>noalias</code>, the question was about <code>noalias</code>. I don't see anywhere that <code>noalias</code> applies only to pointer arguments.</p>



<a name="277933604"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal%20memory%20models/near/277933604" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal.20memory.20models.html#277933604">(Apr 05 2022 at 19:43)</a>:</h4>
<p>llc on</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">define</span><span class="w"> </span><span class="n">void</span><span class="w"> </span><span class="o">@</span><span class="n">f</span><span class="p">(</span><span class="kt">i64</span><span class="w"> </span><span class="n">noalias</span><span class="w"> </span><span class="o">%</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="n">void</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>gives "Attribute 'noalias' applied to incompatible type!" Though I agree that LangRef doesn't state that.</p>



<a name="277934308"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal%20memory%20models/near/277934308" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal.20memory.20models.html#277934308">(Apr 05 2022 at 19:50)</a>:</h4>
<p>so I guess LLVM also gets to dodge that by forcing them to be pointers and then not having <code>pointer = pointer op pointer</code></p>



<a name="277936201"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal%20memory%20models/near/277936201" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal.20memory.20models.html#277936201">(Apr 05 2022 at 20:04)</a>:</h4>
<p>Ah! This helps a lot. This kinda implies that they mean “based on” specifically as GEP</p>



<a name="277936424"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal%20memory%20models/near/277936424" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal.20memory.20models.html#277936424">(Apr 05 2022 at 20:06)</a>:</h4>
<p>Hm, I still don’t know that that’s formal. But it’s closer: I can now carve out a space of “definitely UB” and “definitely fine”</p>



<a name="277936551"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal%20memory%20models/near/277936551" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal.20memory.20models.html#277936551">(Apr 05 2022 at 20:07)</a>:</h4>
<p>yeah, they list exactly the operations for their "based on" in <a href="https://llvm.org/docs/LangRef.html#pointeraliasing">https://llvm.org/docs/LangRef.html#pointeraliasing</a> complete with pure handwave for "what about inttoptr"</p>



<a name="277938053"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal%20memory%20models/near/277938053" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Formal.20memory.20models.html#277938053">(Apr 05 2022 at 20:19)</a>:</h4>
<p>Oh, nice, thanks!</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>