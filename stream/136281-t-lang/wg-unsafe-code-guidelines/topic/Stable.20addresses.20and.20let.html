<html>
<head><meta charset="utf-8"><title>Stable addresses and let · t-lang/wg-unsafe-code-guidelines · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/index.html">t-lang/wg-unsafe-code-guidelines</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable.20addresses.20and.20let.html">Stable addresses and let</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="276221489"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable%20addresses%20and%20let/near/276221489" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Alice Ryhl <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable.20addresses.20and.20let.html#276221489">(Mar 22 2022 at 17:03)</a>:</h4>
<p>I was recently pointed to this open issue: <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/15">https://github.com/rust-lang/unsafe-code-guidelines/issues/15</a></p>
<p>Do we really not guarantee that variables have stable addresses when you create references to them? If this also applies to the reference passed to destructors, then macros like <code>futures::pin_mut!</code> are incorrect since they assume that the <code>Pin&lt;&amp;mut T&gt;</code> reference that the macro creates has the same address as the reference passed to the destructor.</p>



<a name="276731717"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable%20addresses%20and%20let/near/276731717" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable.20addresses.20and.20let.html#276731717">(Mar 26 2022 at 15:42)</a>:</h4>
<p><span class="user-mention" data-user-id="218683">@Alice Ryhl</span> on the MIR level we guarantee that a local has a stable address from its <code>StorageLive</code> until its next <code>StorageDead</code></p>



<a name="276731728"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable%20addresses%20and%20let/near/276731728" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable.20addresses.20and.20let.html#276731728">(Mar 26 2022 at 15:42)</a>:</h4>
<p>but e.g. a <code>let</code> in a loop can have a new address in each loop iteration</p>



<a name="276731753"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable%20addresses%20and%20let/near/276731753" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable.20addresses.20and.20let.html#276731753">(Mar 26 2022 at 15:43)</a>:</h4>
<p>we have not really specified how surface Rust maps to MIR storage annotations, but I would generally expect that the address remains stable from the first write until move or drop. however I am less sure about re-initialized locals.</p>



<a name="276742928"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable%20addresses%20and%20let/near/276742928" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Alice Ryhl <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable.20addresses.20and.20let.html#276742928">(Mar 26 2022 at 19:58)</a>:</h4>
<p><span class="user-mention" data-user-id="120791">@RalfJ</span> according to the issue, it's an open question whether that's guaranteed even without a redefinition? If we do guarantee that, then we should probably close the issue or write that somewhere, or something.</p>



<a name="276746261"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable%20addresses%20and%20let/near/276746261" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable.20addresses.20and.20let.html#276746261">(Mar 26 2022 at 21:16)</a>:</h4>
<p>I think basically nothing is guaranteed on the surface level mostly since so far this is just not talked about explicitly anywhere</p>



<a name="276746268"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable%20addresses%20and%20let/near/276746268" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable.20addresses.20and.20let.html#276746268">(Mar 26 2022 at 21:16)</a>:</h4>
<p>but it seems impossible for us to break this</p>



<a name="276746282"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable%20addresses%20and%20let/near/276746282" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable.20addresses.20and.20let.html#276746282">(Mar 26 2022 at 21:17)</a>:</h4>
<p>I'm all for turning this into a proper guarantee, it just takes someone to push for it. This is a tricky subject to talk about precisely because it affects not only MIR semantics but Rust → MIR lowering.</p>



<a name="276749249"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable%20addresses%20and%20let/near/276749249" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable.20addresses.20and.20let.html#276749249">(Mar 26 2022 at 22:26)</a>:</h4>
<p>Given how many functions use temporary references, it feels like there might be a potential optimization loss if taking a reference to a value <em>ever</em> forces it to always live at that address for the rest of time.</p>



<a name="276750349"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable%20addresses%20and%20let/near/276750349" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Christopher Durham <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable.20addresses.20and.20let.html#276750349">(Mar 26 2022 at 22:52)</a>:</h4>
<p>I'd expect stable addresses to be bounded by the SB borrow stack. i.e. maximally stable would be until the binding is next <code>&amp;mut</code>ed or assigned to. It seems "morally" correct that while a valid tag is on the stack, it can be used to access the value.<br>
But yeah, that does seem to prevent some optimization of on-the-fly stack reorganization, so I'm not sure.</p>



<a name="276750454"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable%20addresses%20and%20let/near/276750454" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable.20addresses.20and.20let.html#276750454">(Mar 26 2022 at 22:55)</a>:</h4>
<p>SB can only help with actual memory accesses though</p>



<a name="276750456"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable%20addresses%20and%20let/near/276750456" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable.20addresses.20and.20let.html#276750456">(Mar 26 2022 at 22:55)</a>:</h4>
<p>if you use ptr comparison to check of a variable has a stable address, SB cannot affect that</p>



<a name="276750457"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable%20addresses%20and%20let/near/276750457" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable.20addresses.20and.20let.html#276750457">(Mar 26 2022 at 22:55)</a>:</h4>
<p>IOW, "address stability" and SB are wholly unrelated</p>



<a name="276750513"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable%20addresses%20and%20let/near/276750513" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Christopher Durham <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable.20addresses.20and.20let.html#276750513">(Mar 26 2022 at 22:56)</a>:</h4>
<p>Ah fair</p>



<a name="276750634"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable%20addresses%20and%20let/near/276750634" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Christopher Durham <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable.20addresses.20and.20let.html#276750634">(Mar 26 2022 at 22:59)</a>:</h4>
<p>(for a blessed instant I lived in a world where a) you can't compare pointers to different "objects", of which an empty borrow stack makes a new "object" and b) ptrtoint doesn't exist)<br>
(basically I forgot that addresses are observable beyond being used for accesses)</p>



<a name="276751056"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable%20addresses%20and%20let/near/276751056" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable.20addresses.20and.20let.html#276751056">(Mar 26 2022 at 23:07)</a>:</h4>
<p>yes such a world would make life a lot easier indeed :(</p>



<a name="276751065"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable%20addresses%20and%20let/near/276751065" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable.20addresses.20and.20let.html#276751065">(Mar 26 2022 at 23:07)</a>:</h4>
<p>but Rust made comparing <em>arbitrary, even dangling pointers</em> a <strong>safe operation</strong> so that's <em>very far</em> from the world we live in</p>



<a name="276751239"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable%20addresses%20and%20let/near/276751239" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable.20addresses.20and.20let.html#276751239">(Mar 26 2022 at 23:11)</a>:</h4>
<p>(Even hashing them, for extra "fun")</p>



<a name="276751865"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable%20addresses%20and%20let/near/276751865" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Gankra <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable.20addresses.20and.20let.html#276751865">(Mar 26 2022 at 23:26)</a>:</h4>
<p>i think banning inttoptr kills most of the "crimes" arbitrary pointer comparisons can introduce and mostly just leaves you with "code that gets stupid answers for asking stupid questions"</p>



<a name="276789416"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable%20addresses%20and%20let/near/276789416" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable.20addresses.20and.20let.html#276789416">(Mar 27 2022 at 13:51)</a>:</h4>
<p><span class="user-mention" data-user-id="137587">@Gankra</span> I dont see any connection between issues caused by ptr comparisons and inttoptr</p>



<a name="276790046"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable%20addresses%20and%20let/near/276790046" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Gankra <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable.20addresses.20and.20let.html#276790046">(Mar 27 2022 at 14:04)</a>:</h4>
<p><span class="user-mention" data-user-id="120791">@RalfJ</span> basically pointer-comparisons between two different allocations (by defining it as address-comparison) is only conceptually terrifying if you're allowed to actually take action on that comparison directly with things like inttoptr IMO</p>



<a name="276790260"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable%20addresses%20and%20let/near/276790260" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Gankra <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable.20addresses.20and.20let.html#276790260">(Mar 27 2022 at 14:08)</a>:</h4>
<p>i.e. this person was just asking me about it on twitter and really nervous about it (mostly just because C says these kinds of "blind" comparisons are UB) but they were in fact doing the responsible thing of going over to the canonical allocation and doing the reslices from there, just like cheri/strict-provenance wants you to: <a href="https://twitter.com/bitshiftmask/status/1507856233897893888">https://twitter.com/bitshiftmask/status/1507856233897893888</a></p>
<div class="inline-preview-twitter"><div class="twitter-tweet"><a href="https://twitter.com/bitshiftmask/status/1507856233897893888"><img class="twitter-avatar" src="https://uploads.zulipusercontent.net/b05fb1cdd1e43d0201532bd762bc1414c2888c99/68747470733a2f2f7062732e7477696d672e636f6d2f70726f66696c655f696d616765732f313436373235303534303831363038393039312f5849575a302d4c685f6e6f726d616c2e6a7067"></a><p><a href="https://twitter.com/Gankra_">@Gankra_</a> Every time I read about pointer provenance, I get more an more nervous about my library where I use pointers as integers to figure out if one slice "originates" from within another.

Which, works, but no one can figure out what kind of vibes it has.</p><span>- james.poll_on()?; (@bitshiftmask)</span></div></div>



<a name="276790358"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable%20addresses%20and%20let/near/276790358" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Gankra <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable.20addresses.20and.20let.html#276790358">(Mar 27 2022 at 14:11)</a>:</h4>
<p>(similarly i have a hacky toy compiler which represents spans as addresses into the original program text, but they are "resolved" not by intoptr but by doing a pointer comparison and using the result as an index into the original program text)</p>



<a name="276790575"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable%20addresses%20and%20let/near/276790575" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable.20addresses.20and.20let.html#276790575">(Mar 27 2022 at 14:16)</a>:</h4>
<p>hm, that seems orthogonal so the question here though which is whether the address that a <code>let</code>-bound variable is stored at can just silently change. the fact that pointer comparison gives a well-defined result at all already means a change in address can be observed and no amount of aliasing or provenance shenanigans can change this.</p>



<a name="276790596"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable%20addresses%20and%20let/near/276790596" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable.20addresses.20and.20let.html#276790596">(Mar 27 2022 at 14:17)</a>:</h4>
<p>if we didnt have ptr comparison OTOH, then getting "unique" access to an allocation would mean nobody else could even notice if we moved it somewhere else</p>



<a name="276790692"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable%20addresses%20and%20let/near/276790692" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable.20addresses.20and.20let.html#276790692">(Mar 27 2022 at 14:19)</a>:</h4>
<p>as in</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span><span class="w"></span>
<span class="c1">// stuff happens</span>
<span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">27</span><span class="p">;</span><span class="w"></span>
<span class="c1">// more stuff happens</span>
</code></pre></div>
<p>no pointer to <code>x</code> that was created in the first 'stuff' can still be used in the 2nd 'stuff' since we are claiming uniqueness by directly accessing the place. so can we move <code>x</code> to a different location at the reassignment? if pointers with 'invalid' provenance would be UB to compare (and ignoring ptr2int), then we could definitely move <code>x</code> to a different location since it would be impossible to even notice that this happened.</p>
<p>however, as things stand a pointer to <code>x</code> created in the first 'stuff' can still be <em>compared with</em> a pointer to <code>x</code> created in the second stuff, so whether or not <code>x</code> was moved to a different location is observable by the program and thus has to be prescribed by the spec.</p>



<a name="276794643"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable%20addresses%20and%20let/near/276794643" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Gankra <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable.20addresses.20and.20let.html#276794643">(Mar 27 2022 at 15:56)</a>:</h4>
<p>everything you're saying here is correct, i was just replying slightly tangentially, because I know a lot of people have Lingering Terror from pointer comparisons being able to be UB in C and also because e.g. the example in your article hinges on "accidental" address equality resulting in messed up conclusions.</p>



<a name="276794787"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable%20addresses%20and%20let/near/276794787" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable.20addresses.20and.20let.html#276794787">(Mar 27 2022 at 15:59)</a>:</h4>
<p>oh I see. if we never allow int2ptr to obtain an existing provenance then comparing pointers does <em>not</em> 'leak'/'expose' the pointer in the sense of the corresponding analysis done by the compiler -- even if we give away the result of a ptr comparison, that does not give away the (unique) provenance of our private allocation, and as long as we keep <em>that</em> to ourselves we can still optimize assuming nothing else reads from or writes to our location. That is a very neat consequence of killing general int2ptr that I had not even realized.</p>



<a name="276794921"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable%20addresses%20and%20let/near/276794921" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Gankra <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable.20addresses.20and.20let.html#276794921">(Mar 27 2022 at 16:01)</a>:</h4>
<p>yeah it's just another example of "you don't <em>actually</em> get to be 'lucky' with evil"</p>



<a name="276794966"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable%20addresses%20and%20let/near/276794966" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable.20addresses.20and.20let.html#276794966">(Mar 27 2022 at 16:02)</a>:</h4>
<p>well my examples aren't lucky, they are just evil ;)</p>



<a name="276794974"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable%20addresses%20and%20let/near/276794974" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable.20addresses.20and.20let.html#276794974">(Mar 27 2022 at 16:02)</a>:</h4>
<p>we already can handle "you dont get to be lucky" with things like <a href="https://www.ralfj.de/research/twinsem/twinsem.pdf">https://www.ralfj.de/research/twinsem/twinsem.pdf</a></p>



<a name="276795135"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable%20addresses%20and%20let/near/276795135" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Gankra <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable.20addresses.20and.20let.html#276795135">(Mar 27 2022 at 16:07)</a>:</h4>
<p><span class="user-mention" data-user-id="120791">@RalfJ</span> they "get lucky" in the sense of "we don't actually guarantee these stack vars are adjacent, but you congrats you noticed it"</p>



<a name="276795186"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable%20addresses%20and%20let/near/276795186" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Gankra <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable.20addresses.20and.20let.html#276795186">(Mar 27 2022 at 16:08)</a>:</h4>
<p>in much the same way you "get lucky" with a UAF into a reallocation</p>



<a name="276802621"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable%20addresses%20and%20let/near/276802621" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Gankra <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Stable.20addresses.20and.20let.html#276802621">(Mar 27 2022 at 19:04)</a>:</h4>
<p>To this effect I am adding this bullet to "Things it <em>is</em> still sound to do:"</p>
<blockquote>
<p>Compare arbitrary pointers by address. Addresses <em>are</em> just integers and so there is<br>
  always a coherent answer, even if the pointers are invalid or from different<br>
  address-spaces/provenances. Of course, comparing addresses from different address-spaces<br>
  is generally going to be <em>meaningless</em>, but so is comparing Kilograms to Meters, and Rust<br>
  doesn't prevent that either. Similarly, if you get "lucky" and notice that a pointer<br>
  one-past-the-end is the "same" address as the start of an unrelated allocation, anything<br>
  you do with that fact is <em>probably</em> going to be gibberish. The scope of that gibberish<br>
  is kept under control by the fact that the two pointers <em>still</em> aren't allowed to access<br>
  the other's allocation (bytes), because they still have different provenance.</p>
</blockquote>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>