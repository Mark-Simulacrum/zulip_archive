<html>
<head><meta charset="utf-8"><title>niches-and-interior-mutability · t-lang/wg-unsafe-code-guidelines · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/index.html">t-lang/wg-unsafe-code-guidelines</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html">niches-and-interior-mutability</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="260301831"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/260301831" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Boxy [she/her] <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#260301831">(Nov 04 2021 at 17:00)</a>:</h4>
<p><span class="user-mention" data-user-id="120791">@RalfJ</span>  in <a href="https://github.com/rust-lang/rust/issues/90383">#90383</a> you <a href="https://github.com/rust-lang/rust/pull/90383#discussion_r738817105">said</a> </p>
<blockquote>
<p>For example, for an Option&lt;Cell&lt;NonZeroI32&gt;&gt;, mutating the discriminant through a shared ref is almost certainly going to be allowed.</p>
</blockquote>
<p>If I'm understanding this right it would mean that:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span> <span class="nf">foo</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span>: <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">T</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">match</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">Some</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">(),</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p><code>a</code> could be set to <code>None</code> in the call <code>f(b)</code> if <code>T</code> is <code>Cell&lt;NonZeroI32&gt;</code></p>
<p>I think that would be a pretty bad thing to allow (it would basically make refinement types/enum-variant-type proposals impossible...) Is this discussed anywhere, I'm not sure where to look for prior convo about this ^^</p>



<a name="260308052"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/260308052" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#260308052">(Nov 04 2021 at 17:43)</a>:</h4>
<p>I think, logically, <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/84">https://github.com/rust-lang/unsafe-code-guidelines/issues/84</a>, and similar arguments therein for &amp;mut T would apply. IMO, it should be valid to treat the discriminant of an <code>Option</code> as <em>logically</em> distinct from the contained value, even if, after niche-optimization, it would physically overlap in memory. So thus if you're allowed to propagate niches through <code>Cell</code>, then logically, <code>&amp;Cell</code> (or probably generally <code>&amp;UnsafeCell</code>) should assert validity like it's suggested for <code>&amp;mut</code> in that issue.</p>



<a name="260887925"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/260887925" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#260887925">(Nov 10 2021 at 01:25)</a>:</h4>
<p>to be clear, when I said "allowed" I meant "it is not UB"</p>



<a name="260887948"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/260887948" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#260887948">(Nov 10 2021 at 01:25)</a>:</h4>
<p>so, the compiler has to cope with the fact that code might do this</p>



<a name="260888012"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/260888012" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#260888012">(Nov 10 2021 at 01:26)</a>:</h4>
<p>that is different from the standard that we apply to arbitrary safe code (UB-freedom vs soundness, basically)</p>



<a name="260888051"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/260888051" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#260888051">(Nov 10 2021 at 01:27)</a>:</h4>
<p>making code like this UB requires "logical discriminants" that are not stored in an actual real location in memory. I think the consequences of that are much worse than pessimising the compiler in these cases.</p>



<a name="260944703"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/260944703" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Teddy Katz <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#260944703">(Nov 10 2021 at 04:31)</a>:</h4>
<p>I think the concern that I have (and which I gather others have as well) is less about pessimizing the compiler and more about increasing cognitive burden on people who don't use <code>unsafe</code>. IMO, it's reasonable for users to assume that functions are not permitted to mutate the caller's local variables that aren't passed in as reference arguments. If we declare that these functions are actually allowed, we have a logically consistent abstract machine but a more confusing language, even for users who aren't writing unsafe code and who (ostensibly, to some extent) shouldn't be expected to care about things like niches and struct layout.</p>



<a name="260945167"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/260945167" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Teddy Katz <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#260945167">(Nov 10 2021 at 04:41)</a>:</h4>
<p>IIUC this line of thought was addressed in <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/84#issuecomment-711143389">this comment</a>, which distinguishes "failing to uphold the safety contract" from "causing UB". I interpret this to mean that a function like this is "not allowed" in some abstract sense, but if someone writes it anyway, the abstract machine and compiler do guarantee a specific behavior.</p>
<p>I guess that's workable, but it sort of creates a less compelling argument for library authors to uphold the safety contract. "Your code might produce nasal demons" (insta-UB) or "your code might produce nasal demons in a future version of the compiler" (relying on unspecified things, e.g. struct layout) or "your code might produce nasal demons if used the wrong way" (unsound APIs) all seem more convincing than "the rust team disapproves of your code but has committed to making it work anyway".</p>



<a name="260975834"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/260975834" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#260975834">(Nov 10 2021 at 11:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/260887948">said</a>:</p>
<blockquote>
<p>so, the compiler has to cope with the fact that code might do this</p>
</blockquote>
<p>Which of course means I need to write an IR spec that can cobe with the fact code might do this. That's going to be a headache and a half.</p>



<a name="260976693"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/260976693" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Boxy [she/her] <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#260976693">(Nov 10 2021 at 11:31)</a>:</h4>
<p>I would like to hear what the consequences of "logical discriminants" are</p>



<a name="260977734"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/260977734" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#260977734">(Nov 10 2021 at 11:41)</a>:</h4>
<p>Also, wouldn't requiring <code>&amp;impl !Freeze</code> to assert validity on the same conditions proposed in <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/84">unsafe-code-guidelines#84</a> for <code>&amp;mut T</code> solve this as well?</p>



<a name="261203431"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261203431" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261203431">(Nov 12 2021 at 01:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="326176">Boxy [she/her]</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/260976693">said</a>:</p>
<blockquote>
<p>I would like to hear what the consequences of "logical discriminants" are</p>
</blockquote>
<p>I'd like to see a proposal that can account for all the byte-level shenanigans Rust allows <em>and</em> supports "logical discriminants". for<br>
The LLVM and Rust memory model are extremely complicated already due to things like pointer provenance -- to the extend that most programmers work with simpler, wrong models. but for provenance at least we have several published papers, a thoroughly worked-out proposal for C, an implementation in an interpreter (Miri) -- we have a lot of the basics.<br>
Having extra logical data that does not even live at any particular address will just make this even worse, except that we currently have nothing in terms of precise sufficiently low-level proposals. We don't even know yet if all the problems ptr provenance cause can even be solved to satisfaction, so I am of the strong opinion that we should not accept any other kind of "weird extra state" into our semantics.</p>



<a name="261203507"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261203507" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261203507">(Nov 12 2021 at 01:42)</a>:</h4>
<p>once someone implements them in Miri, I'd be willing to discuss logical discriminants seriously -- but the burden here IMO is on those that want more crazy things to be added to our semantics, not on the ones that try to keep the semantics precisely defined. ;)</p>



<a name="261203742"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261203742" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261203742">(Nov 12 2021 at 01:47)</a>:</h4>
<p><span class="user-mention" data-user-id="392468">@Teddy Katz</span> </p>
<blockquote>
<p>I think the concern that I have (and which I gather others have as well) is less about pessimizing the compiler and more about increasing cognitive burden on people who don't use unsafe.</p>
</blockquote>
<p>what you are asking about is the contract between a safe function and its environment. this is not the same as "no UB", and making it precise requires a lot more machinery than a Miri-like interpreter -- it requires something like <a href="https://plv.mpi-sws.org/rustbelt/popl18/">RustBelt</a>. in that contract, I am all for saying that <code>&amp;Option&lt;T&gt;</code> remains in the same invariant no matter how this data happens to be encoded on the byte level.</p>
<blockquote>
<p>I interpret this to mean that a function like this is "not allowed" in some abstract sense, but if someone writes it anyway, the abstract machine and compiler do guarantee a specific behavior.</p>
</blockquote>
<p>exactly.</p>



<a name="261203878"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261203878" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261203878">(Nov 12 2021 at 01:50)</a>:</h4>
<blockquote>
<p>I guess that's workable, but it sort of creates a less compelling argument for library authors to uphold the safety contract. </p>
</blockquote>
<p>the only way to avoid this is to say that it is UB to violate the safety contract. that makes UB an undecidable property which can only be precisely expressed in the most advanced program logics that we have to day. Miri could not tell you if a particular program run has UB -- nobody could. I don't think anyone wants that.</p>



<a name="261204039"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261204039" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261204039">(Nov 12 2021 at 01:53)</a>:</h4>
<p>So, I don't see any way to avoid convincing library authors that safety matters. there <em>is</em> UB that could come from a function that mutates the enum discriminant in a wrong way, after all -- it just requires the caller to also use unsafe code. but we can always reduce it to nasal daemons. imagine some other library wrote</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span> <span class="nf">test_me</span><span class="p">(</span><span class="n">x</span>: <span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">f</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="n">x</span><span class="p">.</span><span class="n">is_some</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">unreachable_unchecked</span><span class="p">();</span><span class="w"> </span><span class="p">}}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>This function can only cause UB if there is some library that does this kind of discriminant manipulation. so we are squarely in "your code might produce nasal demons if used the wrong way" (unsound APIs), I would say, and I would hope that is convincing enough.<br>
In other words, we don't need UB from a complicated aliasing model to make such bad mutations cause UB when used the wrong way. a complicated aliasing model with logical discriminant would make UB already happen during the execution of <code>f</code> (if <code>f</code> was such a nasty function that tried to mutate a discriminant that happens to be located inside an UnsafeCell), but even with no aliasing model <code>test_me</code> would still lead to UB for such functions, and that should be sufficient to declare such an <code>f</code> buggy.</p>



<a name="261204247"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261204247" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261204247">(Nov 12 2021 at 01:57)</a>:</h4>
<p>also, note that (modulo some remaining bugs) we shouldnt even ever have niches that "leak into" an UnsafeCell; UnsafeCell blocks niche optimizations. see <a href="https://github.com/rust-lang/rust/issues/87341">https://github.com/rust-lang/rust/issues/87341</a> for more. so we don't even need "logical discriminants" for this, at least currently (once that bug is fixed).</p>



<a name="261204302"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261204302" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Boxy [she/her] <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261204302">(Nov 12 2021 at 01:58)</a>:</h4>
<p>(on that note I realised that what I need is not actually related to interior mutability after all)</p>



<a name="261204329"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261204329" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Boxy [she/her] <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261204329">(Nov 12 2021 at 01:58)</a>:</h4>
<p>(since what I actually want is that taking an <code>&amp;mut</code> to the inside of an <code>Option</code> cant mutate the discriminant)</p>



<a name="261204361"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261204361" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Boxy [she/her] <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261204361">(Nov 12 2021 at 01:59)</a>:</h4>
<p>I'm not completely clear on whether you think <code>test_me</code> is offering an unsound API here</p>



<a name="261204374"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261204374" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Boxy [she/her] <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261204374">(Nov 12 2021 at 01:59)</a>:</h4>
<p>(and whether that answer changes if you make it <code>f: fn(&amp;mut T)</code>)</p>



<a name="261204521"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261204521" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261204521">(Nov 12 2021 at 02:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/260977734">said</a>:</p>
<blockquote>
<p>Also, wouldn't requiring <code>&amp;impl !Freeze</code> to assert validity on the same conditions proposed in <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/84">unsafe-code-guidelines#84</a> for <code>&amp;mut T</code> solve this as well?</p>
</blockquote>
<p>note that that issue is mostly around "invalid values that are never used again at the type that would make them invalid".</p>
<p>thus Zulip discussion is related to <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/204">https://github.com/rust-lang/unsafe-code-guidelines/issues/204</a>, not <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/84">unsafe-code-guidelines#84</a>, as far as I can see.</p>



<a name="261204655"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261204655" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261204655">(Nov 12 2021 at 02:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="326176">Boxy [she/her]</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261204361">said</a>:</p>
<blockquote>
<p>I'm not completely clear on whether you think <code>test_me</code> is offering an unsound API here</p>
</blockquote>
<p>I think <code>test_me</code> is sound, i.e., cannot cause UB when called from safe code (and using other sound code). any way to cause UB will thus involve a bug in some unsafe code elsewhere.</p>



<a name="261204746"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261204746" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261204746">(Nov 12 2021 at 02:05)</a>:</h4>
<p>and I think the answer does not change when we make <code>f</code> take <code>&amp;mut T</code></p>



<a name="261204755"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261204755" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261204755">(Nov 12 2021 at 02:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261204521">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/260977734">said</a>:</p>
<blockquote>
<p>Also, wouldn't requiring <code>&amp;impl !Freeze</code> to assert validity on the same conditions proposed in <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/84">unsafe-code-guidelines#84</a> for <code>&amp;mut T</code> solve this as well?</p>
</blockquote>
<p>note that that issue is mostly around "invalid values that are never used again at the type that would make them invalid".</p>
<p>thus Zulip discussion is related to <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/204">https://github.com/rust-lang/unsafe-code-guidelines/issues/204</a>, not <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/84">unsafe-code-guidelines#84</a>, as far as I can see.</p>
</blockquote>
<p>Fair, though I brought up 84 because the same thing came up there with &amp;mut T.</p>



<a name="261204820"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261204820" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261204820">(Nov 12 2021 at 02:06)</a>:</h4>
<p><span class="user-mention" data-user-id="120791">@RalfJ</span> , just to be clear, although you are okay with calling <code>test_me</code> sound you don't think the compiler should be licensed to insert that final line in <code>test_me</code> (i.e. optimizing with the knowledge that enum discriminants can't be modified through a reference to the inner field)</p>



<a name="261204833"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261204833" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261204833">(Nov 12 2021 at 02:06)</a>:</h4>
<p>Although... Actually, it's not quite analagous, since the niche change can be observed via an &amp;UnsafeCell holding the exterior (whereas in the &amp;mut case, it's impossible to observe the changed niche if we validate the interior before the <code>&amp;mut T</code> is invalidated)</p>



<a name="261204839"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261204839" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Boxy [she/her] <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261204839">(Nov 12 2021 at 02:07)</a>:</h4>
<p><strong>RalfJ</strong> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261204746">said</a>:</p>
<blockquote>
<p>and I think the answer does not change when we make <code>f</code> take <code>&amp;mut T</code></p>
</blockquote>
<p>So I guess it would be right to say that mutating an enum discriminant through setting an <code>&amp;mut NonZeroI32</code> to <code>0</code>, is not language UB but just semantically wrong? (not sure what the fancy term for "semantically wrong" is, usually i'd say safety invariant but safety invariant of <em>what</em>)</p>



<a name="261204842"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261204842" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261204842">(Nov 12 2021 at 02:07)</a>:</h4>
<p><span class="user-mention" data-user-id="257758">@Connor Horman</span> yeah, it came up but <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/84">ucg#84</a> was not meant to be about enums -- the question it raises is independent of enums, it is just most easily demonstrated with enums (see the <code>bool</code> example in that issue). sadly the issue derailed from that quite a bit. :/<br>
EDIT: actually it doesnt even talk much about discriminants, I might misremember.</p>



<a name="261204846"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261204846" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261204846">(Nov 12 2021 at 02:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="271719">Mario Carneiro</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261204820">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> , just to be clear, although you are okay with calling <code>test_me</code> sound you don't think the compiler should be licensed to insert that final line in <code>test_me</code> (i.e. optimizing with the knowledge that enum discriminants can't be modified through a reference to the inner field)</p>
</blockquote>
<p>correct (in the presence of niche optimizations).</p>



<a name="261204931"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261204931" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261204931">(Nov 12 2021 at 02:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="326176">Boxy [she/her]</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261204839">said</a>:</p>
<blockquote>
<p><strong>RalfJ</strong> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261204746">said</a>:</p>
<blockquote>
<p>and I think the answer does not change when we make <code>f</code> take <code>&amp;mut T</code></p>
</blockquote>
<p>So I guess it would be right to say that mutating an enum discriminant through setting an <code>&amp;mut NonZeroI32</code> to <code>0</code>, is not language UB but just semantically wrong? (not sure what the fancy term for "semantically wrong" is, usually i'd say safety invariant but safety invariant of <em>what</em>)</p>
</blockquote>
<p>a function that writes 0 to a <code>&amp;mut NonZeroI32</code> is IMO <strong>unsound</strong>, even it it can do so without causing immediate UB like so:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span> <span class="nf">evil</span><span class="p">(</span><span class="n">x</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">NonZeroI32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">i32</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="o">*</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>UB can still arise when combined with other code that we IMO should deem correct.</p>



<a name="261204944"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261204944" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261204944">(Nov 12 2021 at 02:09)</a>:</h4>
<p>Oh wait, I just noticed that <code>test_me</code> is using shared references, not <code>&amp;mut</code> like in <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/84">ucg#84</a>. Shouldn't that always be okay, because any interior mutability hides niches?</p>



<a name="261204989"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261204989" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Boxy [she/her] <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261204989">(Nov 12 2021 at 02:10)</a>:</h4>
<p>it <em>should</em> hide niches but currently doesnt when unsafecell is newtyped</p>



<a name="261204992"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261204992" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Boxy [she/her] <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261204992">(Nov 12 2021 at 02:10)</a>:</h4>
<p>(additionally there's talk of allowing Cell to undo the niche hiding)</p>



<a name="261204997"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261204997" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261204997">(Nov 12 2021 at 02:10)</a>:</h4>
<p>also do we want to rely on it hiding niches? in some situations that could be okay</p>



<a name="261205011"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205011" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261205011">(Nov 12 2021 at 02:11)</a>:</h4>
<p>its not okay for Atomic types, but for Cell I dont know of a counterexample</p>



<a name="261205110"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205110" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Boxy [she/her] <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261205110">(Nov 12 2021 at 02:12)</a>:</h4>
<p>Ok I would sort of hope that one day <code>evil</code> will be immediate UB but I think its technically okay for it to not be for what I want to do... even if it will be sort of weird <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span> Perhaps one day ill muck around with miri but im not super far into what im trying to do so there would be no point right now.</p>



<a name="261205113"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205113" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261205113">(Nov 12 2021 at 02:12)</a>:</h4>
<p>what constitutes a counterexample here? This seems like unquestionably bad behavior, and the only tricky part is making it UB but still computationally feasible to determine that it is UB</p>



<a name="261205197"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205197" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261205197">(Nov 12 2021 at 02:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="271719">Mario Carneiro</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205113">said</a>:</p>
<blockquote>
<p>what constitutes a counterexample here? This seems like unquestionably bad behavior, and the only tricky part is making it UB but still computationally feasible to determine that it is UB</p>
</blockquote>
<p>a counterexample would be causing UB from safe code (and clearly sound unsafe libraries)</p>



<a name="261205201"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205201" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261205201">(Nov 12 2021 at 02:14)</a>:</h4>
<p>we have such examples for AtomicInt types when niches are not hidden (you can cause data races)</p>



<a name="261205204"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205204" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261205204">(Nov 12 2021 at 02:14)</a>:</h4>
<p>I dont know an example with Cell</p>



<a name="261205208"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205208" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261205208">(Nov 12 2021 at 02:14)</a>:</h4>
<p>if you have one, please share it :) (probably best on that issue)</p>



<a name="261205209"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205209" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261205209">(Nov 12 2021 at 02:14)</a>:</h4>
<p>but that should be impossible, because we've agreed that this is part of the <em>safety</em> contract</p>



<a name="261205218"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205218" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261205218">(Nov 12 2021 at 02:14)</a>:</h4>
<p>I dont follow?</p>



<a name="261205225"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205225" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261205225">(Nov 12 2021 at 02:15)</a>:</h4>
<p>so if you use sound libraries then they are already promising to not do these shenanigans</p>



<a name="261205226"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205226" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261205226">(Nov 12 2021 at 02:15)</a>:</h4>
<p>probably because I am hungry and should prepare dinner :D</p>



<a name="261205246"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205246" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261205246">(Nov 12 2021 at 02:15)</a>:</h4>
<p>oh you said impossible</p>



<a name="261205250"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205250" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261205250">(Nov 12 2021 at 02:15)</a>:</h4>
<p>I don't see how to cause a counterexample with atomic types either, because there is no <code>AtomicNonzeroU32</code> AFAIK</p>



<a name="261205295"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205295" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261205295">(Nov 12 2021 at 02:16)</a>:</h4>
<p>so the atomic types already have no niches</p>



<a name="261205297"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205297" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261205297">(Nov 12 2021 at 02:16)</a>:</h4>
<p>there was a counterxample, let me see if I can find it</p>



<a name="261205300"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205300" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261205300">(Nov 12 2021 at 02:16)</a>:</h4>
<p>maybe it wasnt the Artomic types</p>



<a name="261205304"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205304" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Boxy [she/her] <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261205304">(Nov 12 2021 at 02:16)</a>:</h4>
<p>AtomicBool has niches</p>



<a name="261205305"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205305" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Boxy [she/her] <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261205305">(Nov 12 2021 at 02:16)</a>:</h4>
<p>(presumably, nvm, its a newtyped u8! fun)</p>



<a name="261205306"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205306" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261205306">(Nov 12 2021 at 02:16)</a>:</h4>
<p><del>https://github.com/rust-lang/rust/issues/68303</del></p>



<a name="261205315"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205315" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261205315">(Nov 12 2021 at 02:17)</a>:</h4>
<p><a href="https://github.com/rust-lang/rust/issues/68206">https://github.com/rust-lang/rust/issues/68206</a></p>



<a name="261205318"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205318" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261205318">(Nov 12 2021 at 02:17)</a>:</h4>
<p>basically, you have an <code>Option&lt;Mutex&lt;bool&gt;&gt;</code></p>



<a name="261205360"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205360" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261205360">(Nov 12 2021 at 02:18)</a>:</h4>
<p>and you do <code>is_some</code> on the outer option in one thread while acquiring the lock and mutating the bool in another thread</p>



<a name="261205373"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205373" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261205373">(Nov 12 2021 at 02:18)</a>:</h4>
<p><em>logically</em> there is not even a race here (is_some will return true no matter which valid boolean the other thread writes), but for LLVM there certainly is a race here, and these days Miri should even be able to detect that.</p>



<a name="261205397"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205397" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261205397">(Nov 12 2021 at 02:19)</a>:</h4>
<p>but yeah having a version of AtomicBool that does have a niche would cause the same issue</p>



<a name="261205410"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205410" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261205410">(Nov 12 2021 at 02:19)</a>:</h4>
<p>The issue I have here, I believe I mentioned in either 84 or 77, but option gets represened something like this in lccc:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="cp">#[repr(Rust)]</span><span class="w"></span>
<span class="k">pub</span><span class="w"> </span><span class="k">union</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="p">[[</span><span class="n">niche_optimize_candidate</span><span class="p">]]</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">{</span><span class="w"> </span><span class="c1">// lcrust v0 abi, "repr(Rust) enum layout"</span>
<span class="w">     </span><span class="nb">Some</span>:  <span class="cp">#[repr(C)]</span><span class="w"> </span><span class="k">struct</span> <span class="p">{</span><span class="w"></span>
<span class="w">               </span><span class="cp">$discriminant</span>: <span class="kt">bool</span><span class="p">,</span><span class="w"></span>
<span class="w">               </span><span class="n">_0</span>: <span class="nc">T</span><span class="w"></span>
<span class="w">      </span><span class="p">},</span><span class="w"></span>
<span class="w">      </span><span class="p">[[</span><span class="n">niche_optimize_target</span><span class="p">]]</span><span class="w"> </span><span class="nb">None</span>:  <span class="cp">#[repr(C)]</span><span class="w"> </span><span class="k">struct</span><span class="p">{</span><span class="w"> </span><span class="cp">$discriminant</span>: <span class="kt">bool</span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>(See <a href="https://hackmd.io/@wSaA8OrrSQ2SlegMvA6e6A/SJ1TeE0y_#reprRust-enums">lcrust v0 abi, "repr(Rust) enum layout"</a>)<br>
I'm unsure how I can have a reference/pointer to <code>Some._0</code>, then set the whole enum to <code>None</code> via that pointer (and make sure this works nicely within the model I basically need or I can't correctly impl C++ consteval, which I'd very much like to not have to duplicate)</p>



<a name="261205470"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205470" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261205470">(Nov 12 2021 at 02:20)</a>:</h4>
<p>Also, related to counterexamples, <code>Option&lt;RefCell&lt;NicheT&gt;&gt;</code> has the same issue, single-threaded.<br>
You can have a mutable reference to the interior and observe it via the shared reference.</p>



<a name="261205485"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205485" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261205485">(Nov 12 2021 at 02:21)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205470">said</a>:</p>
<blockquote>
<p>Also, related to counterexamples, <code>Option&lt;RefCell&lt;NicheT&gt;&gt;</code> has the same issue, single-threaded.<br>
You can have a mutable reference to the interior and observe it via the shared reference.</p>
</blockquote>
<p>yes that was the <a href="https://github.com/rust-lang/rust/issues/68303">https://github.com/rust-lang/rust/issues/68303</a> that I linked first</p>



<a name="261205493"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205493" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261205493">(Nov 12 2021 at 02:21)</a>:</h4>
<p>but its only UB with stacked borrows, so less clear</p>



<a name="261205554"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205554" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261205554">(Nov 12 2021 at 02:22)</a>:</h4>
<p>(Interestingly, it may not be UB under lccc's model as long as it can't be used to write to the logical discriminant field. I'm pretty sure it's still UB under stacked borrows in that case, though)</p>



<a name="261205579"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205579" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261205579">(Nov 12 2021 at 02:23)</a>:</h4>
<blockquote>
<p>The issue I have here, I believe I mentioned in either 84 or 77, but option gets represened something like this in lccc</p>
</blockquote>
<p>Yeah, I understand you have some rather abstract model of memory that you want to fit this to. I dont know how to explain low-level memory shenanigans in such a high-level model. I am surprised that this would only come up with discrimiants though, I would expect more friction in other places that mix the high-level and byte-level view of memory.</p>



<a name="261205626"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205626" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261205626">(Nov 12 2021 at 02:24)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205554">said</a>:</p>
<blockquote>
<p>(Interestingly, it may not be UB under lccc's model as long as it can't be used to write to the logical discriminant field. I'm pretty sure it's still UB under stacked borrows in that case, though)</p>
</blockquote>
<p>does that mean that the Mutex&lt;bool&gt; example would not be UB in lccc since there is not even a data race?</p>



<a name="261205734"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205734" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261205734">(Nov 12 2021 at 02:26)</a>:</h4>
<p>It would still be because of overlapping memory locations. A non-addressible field which has non-zero size and is not empty (which is the <code>$discriminant</code> field in a niche-optimized case) shares the same memory location as the following field. However, in the current domain, talking about <code>unique</code> (&amp;mut) and <code>readonly</code> (&amp;), it cares about objects (mostly).</p>



<a name="261205766"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205766" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261205766">(Nov 12 2021 at 02:28)</a>:</h4>
<p>if it is possible to take into account overlapping memory locations for the purpose of data races, the same should be possible for aliasing -- so maybe this could be used to 'allow' (make it not immediate UB) the kind of code you were worried about earlier?</p>



<a name="261205808"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205808" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261205808">(Nov 12 2021 at 02:28)</a>:</h4>
<p><a href="https://github.com/rust-lang/rust/issues/68206">rust#68206</a> is interesting reading, and I understand the motivation for exposing niches in <code>Cell&lt;T&gt;</code> a bit better now. In that issue, they discuss a possible <code>UnsafeCellWithExposedNiches&lt;T&gt;</code> type, and actually I think that this might be enough to resolve the situation. The basic idea is that it is UB to write one of the niches of <code>T</code> via the <code>set</code> function of <code>&amp;UnsafeCellWithExposedNiches&lt;T&gt;</code></p>



<a name="261205826"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205826" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261205826">(Nov 12 2021 at 02:29)</a>:</h4>
<p>Yeah, the issue is how I specify that without increasing the number of ways that <code>unique</code> can overlap with <code>readonly</code> (which is currently only possible for mutable subobjects - how UnsafeCell is implemented).</p>



<a name="261205827"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205827" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261205827">(Nov 12 2021 at 02:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="271719">Mario Carneiro</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205808">said</a>:</p>
<blockquote>
<p><a href="https://github.com/rust-lang/rust/issues/68206">rust#68206</a> is interesting reading, and I understand the motivation for exposing niches in <code>Cell&lt;T&gt;</code> a bit better now. In that issue, they discuss a possible <code>UnsafeCellWithExposedNiches&lt;T&gt;</code> type, and actually I think that this might be enough to resolve the situation. The basic idea is that it is UB to write one of the niches of <code>T</code> via the <code>set</code> function of <code>&amp;UnsafeCellWithExposedNiches&lt;T&gt;</code></p>
</blockquote>
<p>I think making it UB would be rather difficult to achieve (and I am being very British here) -- but the API contract could certainly say that this is not allowed</p>



<a name="261205892"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205892" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261205892">(Nov 12 2021 at 02:30)</a>:</h4>
<p>Making it UB for that particular function should be easy, since the niches are known (for a given type <code>T</code>) and we're talking about a particular function here: this is basically just a miri-<code>assert!</code> at the entrance to the function</p>



<a name="261205894"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205894" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Boxy [she/her] <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261205894">(Nov 12 2021 at 02:30)</a>:</h4>
<p>I'm not convinced interior mutability is very relevent here. The rules for <code>&amp;UnsafeCellWithNiches&lt;T&gt;</code> should be the same as <code>&amp;mut T</code> if one of them doesnt conceptually contain the discriminant/be able to mutate it then neither should be able to</p>



<a name="261205903"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205903" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Boxy [she/her] <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261205903">(Nov 12 2021 at 02:31)</a>:</h4>
<p>(I know im the one who opened the thread and it talks about interior mutability but.. yeah)</p>



<a name="261205937"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205937" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261205937">(Nov 12 2021 at 02:32)</a>:</h4>
<p>the issue with <code>&amp;mut T</code> is that you can cast a <code>&amp;mut NonzeroU8</code> to a <code>*mut u8</code> and write 0 to it</p>



<a name="261205971"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205971" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261205971">(Nov 12 2021 at 02:32)</a>:</h4>
<p>the same issue presumably exists for <code>&amp;UnsafeCellWithNiches&lt;T&gt;</code></p>



<a name="261205978"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205978" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261205978">(Nov 12 2021 at 02:32)</a>:</h4>
<p><span class="user-mention silent" data-user-id="271719">Mario Carneiro</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205892">said</a>:</p>
<blockquote>
<p>Making it UB for that particular function should be easy, since the niches are known (for a given type <code>T</code>) and we're talking about a particular function here: this is basically just a miri-<code>assert!</code> at the entrance to the function</p>
</blockquote>
<p><code>UnsafeCell</code> doesnt have a <code>set</code> function though so this seems like an odd API? I cant find that in the issue either in a very quick glance</p>



<a name="261205986"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205986" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261205986">(Nov 12 2021 at 02:32)</a>:</h4>
<p>it doesn't? oops</p>



<a name="261205988"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205988" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261205988">(Nov 12 2021 at 02:32)</a>:</h4>
<p><span class="user-mention silent" data-user-id="271719">Mario Carneiro</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205937">said</a>:</p>
<blockquote>
<p>the issue with <code>&amp;mut T</code> is that you can cast a <code>&amp;mut NonzeroU8</code> to a <code>*mut u8</code> and write 0 to it</p>
</blockquote>
<p>Well, the question is whether you can.</p>



<a name="261205995"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205995" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Boxy [she/her] <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261205995">(Nov 12 2021 at 02:33)</a>:</h4>
<p>Mario Carneiro <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205971">said</a>:</p>
<blockquote>
<p>the same issue presumably exists for <code>&amp;UnsafeCellWithNiches&lt;T&gt;</code></p>
</blockquote>
<p>Yea, I just mean that this whole discussion can remove interior mutability imo</p>



<a name="261206012"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261206012" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261206012">(Nov 12 2021 at 02:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205988">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="271719">Mario Carneiro</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205937">said</a>:</p>
<blockquote>
<p>the issue with <code>&amp;mut T</code> is that you can cast a <code>&amp;mut NonzeroU8</code> to a <code>*mut u8</code> and write 0 to it</p>
</blockquote>
<p>Well, the question is whether you can.</p>
</blockquote>
<p>well, you can write that code. the question is what it does, i.e., whether it is immediate UB. (that is indeed <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/84">ucg#84</a>, and not directly about enums.)</p>



<a name="261206058"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261206058" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261206058">(Nov 12 2021 at 02:34)</a>:</h4>
<p>Well, if <code>&amp;UnsafeCellWithNiches&lt;T&gt;</code> is only there to implement <code>Cell&lt;T&gt;</code> then it could have a <code>set</code> method instead of <code>get_mut</code>. But it's probably beside the point</p>



<a name="261206071"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261206071" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261206071">(Nov 12 2021 at 02:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261206012">said</a>:</p>
<blockquote>
<p>well, you can write that code. the question is what it does, i.e., whether it is immediate UB. (that is indeed <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/84">ucg#84</a>, and not directly about enums.)</p>
</blockquote>
<p>Yes, I'm sort of presuming code is correct here when asking whether something can be done.</p>



<a name="261206099"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261206099" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261206099">(Nov 12 2021 at 02:35)</a>:</h4>
<p>(If it isn't correct code, then writing zero to that pointer can print potato to stdout for all I care)</p>



<a name="261206140"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261206140" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261206140">(Nov 12 2021 at 02:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="326176">Boxy [she/her]</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205995">said</a>:</p>
<blockquote>
<p>Mario Carneiro <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205971">said</a>:</p>
<blockquote>
<p>the same issue presumably exists for <code>&amp;UnsafeCellWithNiches&lt;T&gt;</code></p>
</blockquote>
<p>Yea, I just mean that this whole discussion can remove interior mutability imo</p>
</blockquote>
<p>I think I agree -- the question is about whether, when a pointer is in principle mutable without immediate UB, if that means that writing <em>arbitrary</em> values to it is fine (not immediate UB), or whether we can have pointers where writing some values is UB but writing other values is not.</p>



<a name="261206147"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261206147" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261206147">(Nov 12 2021 at 02:36)</a>:</h4>
<p>at least that's how I prefer to think about it since this avoids invoking 'shadow discriminants' ;)</p>



<a name="261206166"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261206166" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261206166">(Nov 12 2021 at 02:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="326176">Boxy [she/her]</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205995">said</a>:</p>
<blockquote>
<p>Mario Carneiro <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205971">said</a>:</p>
<blockquote>
<p>the same issue presumably exists for <code>&amp;UnsafeCellWithNiches&lt;T&gt;</code></p>
</blockquote>
<p>Yea, I just mean that this whole discussion can remove interior mutability imo</p>
</blockquote>
<p>Interior Mutability is kind of relevent, though. With <code>&amp;mut T</code>, you can defer the UB to later (such as before the function ends) as the problem can't be observed until after that later. With <code>&amp;UnsafeCellWithNiches&lt;T&gt;</code> the problem can be observed immediately.</p>



<a name="261206225"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261206225" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Boxy [she/her] <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261206225">(Nov 12 2021 at 02:38)</a>:</h4>
<p>ah well I guess "whether we can have pointes where writing some values is ub but other values is not" is exactly what i want <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span></p>



<a name="261206251"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261206251" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261206251">(Nov 12 2021 at 02:39)</a>:</h4>
<p>Using the "equivalence" of <code>&amp;UnsafeCellWithNiches&lt;T&gt;</code> and <code>&amp;mut T</code>, I think that means that my "write-back" proposal from <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/84">ucg#84</a> can't work at all. Those pointers have to stay good the whole time, not just at lifetime end</p>



<a name="261206323"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261206323" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261206323">(Nov 12 2021 at 02:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="271719">Mario Carneiro</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261206251">said</a>:</p>
<blockquote>
<p>Using the "equivalence" of <code>&amp;UnsafeCellWithNiches&lt;T&gt;</code> and <code>&amp;mut T</code>, I think that means that my "write-back" proposal from <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/84">ucg#84</a> can't work at all. Those pointers have to stay good the whole time, not just at lifetime end</p>
</blockquote>
<p>yeah, that's what <span class="user-mention" data-user-id="257758">@Connor Horman</span> pointed out -- if we unify both problems like that, the check has to happen on each write</p>



<a name="261206328"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261206328" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261206328">(Nov 12 2021 at 02:41)</a>:</h4>
<p>If we have:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="n">x</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">){</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u8</span><span class="p">).</span><span class="n">write</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">None</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="fm">panic!</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">miri</span>::<span class="n">validate_location</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="w"> </span><span class="c1">// Magicly inserted function that asks whether `x` points to a vlaid `bool`</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>Then that's fine to have that be well-defined to panic, but</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="n">x</span>: <span class="kp">&amp;</span><span class="nc">Cell</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="kp">&amp;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">Cell</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&gt;</span><span class="p">){</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u8</span><span class="p">).</span><span class="n">write</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">None</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="fm">panic!</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">miri</span>::<span class="n">validate_location</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="w"> </span><span class="c1">// Magicly inserted function that asks whether `x` points to a valid `bool`</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>the issue here is that the write to <code>x</code> could, in theory, affect the following if-let</p>



<a name="261206370"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261206370" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261206370">(Nov 12 2021 at 02:42)</a>:</h4>
<p>which might indicate maybe we shouldnt unify them, because for a <code>&amp;mut NonZeroU16</code> it seems it should be fine to temporarily make both bytes 0 as long as they are non-zero when the lifetime of the reference ends</p>



<a name="261206381"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261206381" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261206381">(Nov 12 2021 at 02:42)</a>:</h4>
<p>We can probably still unify them, but make <code>&amp;mut T</code>'s version "deferred", whatever that means.</p>



<a name="261206396"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261206396" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261206396">(Nov 12 2021 at 02:43)</a>:</h4>
<p>Haven't we worked our way to an actual counterexample of the safety of that? At least, if <code>&amp;UnsafeCellWithNiches&lt;T&gt;</code> exists and has a <code>get_mut</code></p>



<a name="261206399"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261206399" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261206399">(Nov 12 2021 at 02:43)</a>:</h4>
<p>that doesnt sound very unified to me any more, but I guess it depends on how the checking would work excatly</p>



<a name="261206415"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261206415" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Boxy [she/her] <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261206415">(Nov 12 2021 at 02:44)</a>:</h4>
<p>agh, your second example with the <code>&amp;Cell&lt;Bool&gt;</code> made me realise I actually cant do what I want to do at all without it being lang UB to write a 0 into an <code>&amp;mut NonZeroI32</code> or a 2 into a <code>bool</code> etc</p>



<a name="261206458"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261206458" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261206458">(Nov 12 2021 at 02:44)</a>:</h4>
<p>It seems to me the easiest base is to say that the rust memory model gives types to pointer values that come from references.</p>



<a name="261206461"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261206461" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Boxy [she/her] <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261206461">(Nov 12 2021 at 02:44)</a>:</h4>
<p>I guess it is just not possible to reason about what variant an enum has set (with the current set of UB)</p>



<a name="261206486"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261206486" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261206486">(Nov 12 2021 at 02:45)</a>:</h4>
<blockquote>
<p>the issue here is that the write to x could, in theory, affect the following if-let</p>
</blockquote>
<p>can it? so you are saying we could soundly have <code>x: &amp;Cell&lt;bool&gt;, y: &amp;Option&lt;Cell&lt;bool&gt;&gt;</code> that alias?</p>



<a name="261206489"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261206489" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261206489">(Nov 12 2021 at 02:45)</a>:</h4>
<p>We can safely have this rn.</p>



<a name="261206493"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261206493" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261206493">(Nov 12 2021 at 02:45)</a>:</h4>
<p>you mean we can create it in safe code?</p>



<a name="261206532"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261206532" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261206532">(Nov 12 2021 at 02:46)</a>:</h4>
<p>oh yeah we can... <code>as_ref().unwrap()</code></p>



<a name="261206538"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261206538" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261206538">(Nov 12 2021 at 02:46)</a>:</h4>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">Cell</span>::<span class="n">new</span><span class="p">(</span><span class="kc">true</span><span class="p">));</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">foo</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>



<a name="261206546"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261206546" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261206546">(Nov 12 2021 at 02:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261206458">said</a>:</p>
<blockquote>
<p>It seems to me the easiest base is to say that the rust memory model gives types to pointer values that come from references.</p>
</blockquote>
<p>I dont know what that means.^^</p>



<a name="261206579"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261206579" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261206579">(Nov 12 2021 at 02:47)</a>:</h4>
<p>So, x would have a "type" of <code>Cell&lt;bool&gt;</code> with validity invariant <code>[00|01]</code>, and that would infect pointers derived from it.</p>



<a name="261206633"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261206633" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261206633">(Nov 12 2021 at 02:48)</a>:</h4>
<p>(Although It may be easier to deal with it in terms of just the validity invariant, not the type - otherwise, what do you do if you go to another reference)</p>



<a name="261206660"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261206660" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261206660">(Nov 12 2021 at 02:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261206370">said</a>:</p>
<blockquote>
<p>which might indicate maybe we shouldnt unify them, because for a <code>&amp;mut NonZeroU16</code> it seems it should be fine to temporarily make both bytes 0 as long as they are non-zero when the lifetime of the reference ends</p>
</blockquote>
<p><span class="user-mention silent" data-user-id="271719">Mario Carneiro</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261206396">said</a>:</p>
<blockquote>
<p>Haven't we worked our way to an actual counterexample of the safety of that? At least, if <code>&amp;UnsafeCellWithNiches&lt;T&gt;</code> exists and has a <code>get_mut</code></p>
</blockquote>
<p>to be precise:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">UnsafeCellWithNiches</span>::<span class="n">new</span><span class="p">(</span><span class="n">NonZeroU16</span>::<span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">y</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">NonZeroU16</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">as_ref</span><span class="p">().</span><span class="n">unwrap</span><span class="p">().</span><span class="n">get_mut</span><span class="p">();</span><span class="w"></span>
<span class="o">*</span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">NonZeroU16</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u16</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// break the invariant</span>
<span class="fm">assert!</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">is_none</span><span class="p">());</span><span class="w"> </span><span class="c1">// oh noes</span>
<span class="o">*</span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">NonZeroU16</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u16</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// restore the invariant</span>
<span class="nb">drop</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="c1">// lifetime of `y` ends</span>
</code></pre></div>



<a name="261206672"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261206672" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261206672">(Nov 12 2021 at 02:49)</a>:</h4>
<p>You could then make it UB to write a value to the pointer that doesn't satisfy the reference's validity invariant.</p>



<a name="261206737"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261206737" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261206737">(Nov 12 2021 at 02:50)</a>:</h4>
<p>(Then to allow <code>&amp;mut T</code> to work, it can be defined behaviour to store an invalid value via pointers derive from a <code>&amp;mut T</code>, as long as the value is still valid immediately before the reference is invalidated)</p>



<a name="261206941"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261206941" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261206941">(Nov 12 2021 at 02:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261206672">said</a>:</p>
<blockquote>
<p>You could then make it UB to write a value to the pointer that doesn't satisfy the reference's validity invariant.</p>
</blockquote>
<p>so basically, like <span class="user-mention" data-user-id="271719">@Mario Carneiro</span>'s 'writeback' proposal, store the invariant in the provenance (or the borrow stack). but this has all the same problems, because memory accesses are bytewise but invariants can correlate many bytes. you start with a pointer to a 2-byte value that may not be all 0, then cast it to <code>*mut u8</code> and write a 0  -- is this allowed? now suddenly this depends on the state of some other bytes your access didnt even touch. if some other thread concurrently mutates the other byte, do we have a data race now because conceptually our first thread "read" that byte?</p>



<a name="261206949"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261206949" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261206949">(Nov 12 2021 at 02:55)</a>:</h4>
<p>so I dont buy your claim that this would be "easiest". the "easiest" approach is to not make this UB in the first place. :)</p>



<a name="261206994"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261206994" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261206994">(Nov 12 2021 at 02:56)</a>:</h4>
<p>Fair. It's the easiest I can think of, while still making this UB.</p>



<a name="261207091"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261207091" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261207091">(Nov 12 2021 at 02:58)</a>:</h4>
<p>that might be the case -- I havent seen any other proposal that would achieve this. (not counting 'non-addressable shadow data in memory' since I have yet to see a version of that proposal that would work with byte-wise shenanigans.)</p>



<a name="261207099"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261207099" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261207099">(Nov 12 2021 at 02:58)</a>:</h4>
<p>Hmm... Though. It works semi-well for <code>&amp;mut T</code>, since the validation of the memory occurs immediately before the invalidation of the reference (which means that nothing else can possibly observe/mutate it yet).</p>



<a name="261207103"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261207103" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261207103">(Nov 12 2021 at 02:58)</a>:</h4>
<p>and with that I should definitely start preparing diner, have a good evening/night/whatever everyone :)</p>



<a name="261207114"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261207114" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261207114">(Nov 12 2021 at 02:59)</a>:</h4>
<p>What if the invariants are always asserted from an omniscient perspective? So If you race with another thread to write the bytes then whether it is UB or not depends on what order the writes hit memory (but basically, that's a race and probably UB, although miri might not catch it because it's not good at concurrency exploration)</p>



<a name="261207134"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261207134" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261207134">(Nov 12 2021 at 02:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="271719">Mario Carneiro</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261207114">said</a>:</p>
<blockquote>
<p>What if the invariants are always asserted from an omniscient perspective? So If you race with another thread to write the bytes then whether it is UB or not depends on what order the writes hit memory (but basically, that's a race and probably UB, although miri might not catch it because it's not good at concurrency exploration)</p>
</blockquote>
<p>That interacts poorly if your memory location for data race purposes is &gt;1 byte</p>



<a name="261207269"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261207269" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261207269">(Nov 12 2021 at 03:00)</a>:</h4>
<p>(Although I guess in such a world, you're probably operating on an object model anyways, so you can go nuts with how the validation is applied)</p>



<a name="261207380"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261207380" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261207380">(Nov 12 2021 at 03:02)</a>:</h4>
<p>The issue with <code>Option&lt;UnsafeCellWithNiches&lt;NonZeroU16&gt;&gt;</code> seems really hairy, because you have unsynchronized reading of the discriminant while writing both bytes</p>



<a name="261207396"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261207396" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261207396">(Nov 12 2021 at 03:02)</a>:</h4>
<p>UnsafeCellWithNiches would basically be super-!Sync</p>



<a name="261207422"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261207422" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#261207422">(Nov 12 2021 at 03:03)</a>:</h4>
<p>It wouldn't be usable in a thread-safe interior mutability wrapper at all (at least, for a generic T or a concrete T with niches)</p>



<a name="262537894"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/262537894" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sebastian Malton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#262537894">(Nov 24 2021 at 01:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261206328">said</a>:</p>
<blockquote>
<p>If we have:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="n">x</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">){</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u8</span><span class="p">).</span><span class="n">write</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">None</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="fm">panic!</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">miri</span>::<span class="n">validate_location</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="w"> </span><span class="c1">// Magicly inserted function that asks whether `x` points to a vlaid `bool`</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>Then that's fine to have that be well-defined to panic, but</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="n">x</span>: <span class="kp">&amp;</span><span class="nc">Cell</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="kp">&amp;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">Cell</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&gt;</span><span class="p">){</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u8</span><span class="p">).</span><span class="n">write</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">None</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="fm">panic!</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">miri</span>::<span class="n">validate_location</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="w"> </span><span class="c1">// Magicly inserted function that asks whether `x` points to a valid `bool`</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>the issue here is that the write to <code>x</code> could, in theory, affect the following if-let</p>
</blockquote>
<p>I know that I am just jumping in, but I really don't understand why this first example is not UB (or why it doesn't use <code>unsafe</code>). You are writing the value of <code>2</code> to a <code>bool</code>.</p>



<a name="262548338"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/262548338" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#262548338">(Nov 24 2021 at 05:36)</a>:</h4>
<p><span class="user-mention" data-user-id="247082">@Sebastian Malton</span> It doesn't use <code>unsafe</code> mostly because it's annoying to write <code>unsafe</code> all the time when the topic is unsafe code... you can assume that all code blocks on this stream are wrapped in <code>unsafe { ... }</code> unless the application of unsafe blocks is itself the topic of discussion.</p>
<p>As for whether it is UB, while I and others would very much like it to be UB to write a <code>2</code> into a <code>&amp;mut bool</code>, the challenge is finding a way to detect that this is happening without using typed memory, because rust does not use typed memory. In the example we are not <em>syntactically</em> writing <code>2</code> to a <code>&amp;mut bool</code>, we are writing to a <code>*mut u8</code>, which is no problem at all. You could say that it is derived from a <code>&amp;mut bool</code>, but as long as a borrow is out on the value we can't look at it, and even then it's still open whether this ought to be immediate UB or only UB once the value is read at type <code>bool</code> (which could for example happen in subsequent safe code).</p>



<a name="262596603"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/262596603" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#262596603">(Nov 24 2021 at 14:37)</a>:</h4>
<p>indeed for these reasons I dont think it should be UB -- memory is not typed, and at no point does this program treat <code>2</code> as a value of type bool</p>



<a name="262598645"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/262598645" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sebastian Malton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#262598645">(Nov 24 2021 at 14:54)</a>:</h4>
<p>But if that function didn't do the <code>panic!()</code> and instead returned, it would be UB?</p>



<a name="262600672"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/262600672" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#262600672">(Nov 24 2021 at 15:10)</a>:</h4>
<p>Well, in the above examples, reaching the <code>miri::validate_location</code> call would be UB. The question of whether returning would be UB is open, but I'd personally like it very much, so I can assume that references to the interior of an Option don't modify the discriminant, even with potential niche-optimization.</p>



<a name="262657417"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/262657417" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sebastian Malton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#262657417">(Nov 25 2021 at 01:11)</a>:</h4>
<p>Yeah that makes the most sense to me. But I do see what <span class="user-mention" data-user-id="120791">@RalfJ</span> means about trying to track this in Miri for example.</p>



<a name="262816142"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/262816142" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#262816142">(Nov 26 2021 at 16:46)</a>:</h4>
<p>I think you cant even assume that references to a <code>&amp;mut bool</code> wont modify this to something non-bool (so enums and their discriminants are not the only example)</p>



<a name="262817525"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/262817525" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sebastian Malton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#262817525">(Nov 26 2021 at 17:00)</a>:</h4>
<p>Shouldn't you be able to assume that once the lifetime of the reference ends are are able to?</p>



<a name="262897968"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/262897968" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#262897968">(Nov 27 2021 at 23:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="247082">Sebastian Malton</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/262817525">said</a>:</p>
<blockquote>
<p>Shouldn't you be able to assume that once the lifetime of the reference ends are are able to?</p>
</blockquote>
<p>some people say yes, some people say no. I am in the latter camp, since I think it gives undue significance to the event of "a lifetime ends", which is an event that becomes very fuzzy and hard to define once you talk about unsafe code doing tricky pointer shenanigans.</p>



<a name="262960900"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/262960900" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sebastian Malton <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#262960900">(Nov 29 2021 at 02:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/262897968">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="247082">Sebastian Malton</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/262817525">said</a>:</p>
<blockquote>
<p>Shouldn't you be able to assume that once the lifetime of the reference ends are are able to?</p>
</blockquote>
<p>some people say yes, some people say no. I am in the latter camp, since I think it gives undue significance to the event of "a lifetime ends", which is an event that becomes very fuzzy and hard to define once you talk about unsafe code doing tricky pointer shenanigans.</p>
</blockquote>
<p>But that means that the compiler cannot assume a bool is strictly 1 or 0. </p>
<p>Furthermore, I don't see how that significance is not a reasonable extension of what an exclusive reference means. I guess the alternative could be that merely writing the 2 is instant UB.</p>



<a name="263031532"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/263031532" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#263031532">(Nov 29 2021 at 16:24)</a>:</h4>
<blockquote>
<p>But that means that the compiler cannot assume a bool is strictly 1 or 0. </p>
</blockquote>
<p>This is always a question of when and where the compiler can assume that. Whenever a <code>bool</code> "comes in" as an argument or return value of a function, the compiler <em>can</em> make this assumption -- any typed copy requires the validity invariant. But once a mutable reference to the bool has been given out, then the assumption might be violated until the next time that a typed copy is made.</p>
<p>This is not black and white, there are many possible trade-offs here that differ in terms of how many places the compiler can make this assumption, how complicated the unsafe code rules become, and so on.</p>



<a name="263031861"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/263031861" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/niches-and-interior-mutability.html#263031861">(Nov 29 2021 at 16:26)</a>:</h4>
<blockquote>
<p>Furthermore, I don't see how that significance is not a reasonable extension of what an exclusive reference means. I guess the alternative could be that merely writing the 2 is instant UB.</p>
</blockquote>
<p>It leads to an even more complicated model than Stacked Borrows, and some questions are unanswered. For example for <code>&amp;mut NonZeroU32</code>, there is no rule which says that the "lifetime of this reference" ends at the same time for all the 4 bytes involves -- the "lifetime ends" on a conflicting access, and that might be separate for each byte.<br>
FWIW this has all been discussed already in <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/84">https://github.com/rust-lang/unsafe-code-guidelines/issues/84</a>, I am just repeating myself here. ;)</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>