<html>
<head><meta charset="utf-8"><title>subobject provenance · t-lang/wg-unsafe-code-guidelines · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/index.html">t-lang/wg-unsafe-code-guidelines</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html">subobject provenance</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="277642838"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/277642838" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#277642838">(Apr 03 2022 at 15:36)</a>:</h4>
<p>there are plenty of requests to relax Stacked Borrows to <em>not</em> restrict the range of the reference to <code>T</code></p>



<a name="277642903"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/277642903" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#277642903">(Apr 03 2022 at 15:36)</a>:</h4>
<p>so, while SB as-is would let use use that annotation a lot, my impression is that that's a problem and I hope to fix it in a future aliasing model</p>



<a name="277650720"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/277650720" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ben Kimock (Saethlin) <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#277650720">(Apr 03 2022 at 17:21)</a>:</h4>
<p>That would be odd, in light of the safety requirements on unchecked slice indexing</p>



<a name="277653633"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/277653633" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#277653633">(Apr 03 2022 at 18:24)</a>:</h4>
<p>well, if we fix <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/134">https://github.com/rust-lang/unsafe-code-guidelines/issues/134</a> then OOB unchecked slice indexing will probably not be language UB any more (if the access is not conflicting with others, and still inbounds of the allocation)</p>



<a name="277653653"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/277653653" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#277653653">(Apr 03 2022 at 18:24)</a>:</h4>
<p>it can still be library UB</p>



<a name="277724093"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/277724093" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Christopher Durham <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#277724093">(Apr 04 2022 at 12:36)</a>:</h4>
<p>Similar to strict provenance being an experiment on library additions supporting going "all the way" on enforcing pointer validity, I wonder what that would look like for subobject slicing. Specifically, non-subobject access needs to be supported for <code>extern type</code> to work, so what would it take to make annotating use cases that want the looser semantics (e.g. with <code>extern type</code>) tractable.</p>



<a name="277724629"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/277724629" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Christopher Durham <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#277724629">(Apr 04 2022 at 12:40)</a>:</h4>
<p>For the examples in <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/134">#134</a>, <code>&amp;slice[0] as *const</code> is a C-ism which I think has mostly been conditioned away and people use the correct <code>.as_ptr()</code> now. Implementing <code>Rc::[into|from]_inner</code> is still easy to get wrong, but <code>&amp;raw mut</code> makes it as easy to write correctly as incorrectly.</p>



<a name="277724726"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/277724726" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Christopher Durham <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#277724726">(Apr 04 2022 at 12:41)</a>:</h4>
<p><a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/256">#256</a> <em>literally</em> wants an <code>extern type</code> tail on <code>&amp;Header</code>.</p>



<a name="277725523"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/277725523" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Christopher Durham <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#277725523">(Apr 04 2022 at 12:48)</a>:</h4>
<p>It's a simpler model for the developer if reference don't restrict their accessible range to <code>size_of_val(self)</code>, and likely simpler for SB as well (since you don't have to have two kinds of types, one which restricts, and one which doesn't), so my intuition says fixing <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/276">#276</a> and applying the same semantics to plain references to fix <a href="https://github.com/rust-lang/rust/issues/134">#134</a> is the better path</p>



<a name="277725576"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/277725576" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Christopher Durham <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#277725576">(Apr 04 2022 at 12:49)</a>:</h4>
<p>Leave subobject provenance slicing as something which is done on the allocator boundary</p>



<a name="277725808"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/277725808" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Christopher Durham <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#277725808">(Apr 04 2022 at 12:51)</a>:</h4>
<p>Additionally, while extern type models &amp;Header well, it doesn't really address container_of use cases... although CHERI addresses container_of by annotating the type, so maybe it's tractable? I don't know how much subobject slicing they do beyond the allocation layer, though.</p>



<a name="277729908"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/277729908" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#277729908">(Apr 04 2022 at 13:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="132829">Christopher Durham</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/subobject.20provenance/near/277725523">said</a>:</p>
<blockquote>
<p>It's a simpler model for the developer if reference don't restrict their accessible range to <code>size_of_val(self)</code></p>
</blockquote>
<p>I don't know about that. I don't know how <code>split_at_mut</code> makes any sense if the references have overlapping access</p>



<a name="277730032"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/277730032" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#277730032">(Apr 04 2022 at 13:24)</a>:</h4>
<p>Certainly in safe code references don't have any access outside the specified range, so I would consider that the default position</p>



<a name="277736537"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/277736537" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Christopher Durham <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#277736537">(Apr 04 2022 at 14:12)</a>:</h4>
<p>(why does the mobile app not have a quote option)</p>



<a name="277736623"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/277736623" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Christopher Durham <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#277736623">(Apr 04 2022 at 14:13)</a>:</h4>
<p><code>split_at_mut</code> still makes sense because <code>&amp;mut</code> still asserts uniqueness over <code>size_of_val(self)</code></p>



<a name="277736870"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/277736870" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Christopher Durham <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#277736870">(Apr 04 2022 at 14:15)</a>:</h4>
<p>I agree that references restricting provenance is ideologically correct, but the UCG repo documents a number of examples of people wanting it not to be true</p>



<a name="277737299"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/277737299" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Christopher Durham <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#277737299">(Apr 04 2022 at 14:18)</a>:</h4>
<p>I'd love a usable type-based solution for encoding when references do/don't subslice provenance, though. The practicality of such depends a lot on how extern type is handled both in the language and in SB, though.</p>



<a name="277747961"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/277747961" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Tavian Barnes <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#277747961">(Apr 04 2022 at 15:26)</a>:</h4>
<p>Another use case is <code>bitvec</code>'s use of a ZST slice reference to represent a slice of a packed bit vector: <a href="https://myrrlyn.net/blog/bitvec/addressing-bits">https://myrrlyn.net/blog/bitvec/addressing-bits</a></p>



<a name="277752414"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/277752414" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jacob Lifshay <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#277752414">(Apr 04 2022 at 15:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="132829">Christopher Durham</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/subobject.20provenance/near/277736537">said</a>:</p>
<blockquote>
<p>(why does the mobile app not have a quote option)</p>
</blockquote>
<p>you inspired me to finally get around to looking for the zulip issue: <a href="https://github.com/zulip/zulip-mobile/issues/1975">https://github.com/zulip/zulip-mobile/issues/1975</a></p>



<a name="277796317"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/277796317" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brooks Davis <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#277796317">(Apr 04 2022 at 21:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="132829">Christopher Durham</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/subobject.20provenance/near/277725808">said</a>:</p>
<blockquote>
<p>Additionally, while extern type models &amp;Header well, it doesn't really address container_of use cases... although CHERI addresses container_of by annotating the type, so maybe it's tractable? I don't know how much subobject slicing they do beyond the allocation layer, though.</p>
</blockquote>
<p>By default we don't do any subobject slicing. Even with the most conservative mode, you lose some C compatibility so it can't be on by default. We do enable it and use annotations on the CheriBSD kernel (FreeBSD derived), but haven't tried a really wide array of software.</p>



<a name="277800170"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/277800170" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#277800170">(Apr 04 2022 at 22:04)</a>:</h4>
<p>Yet, wearing my security hat, there are quite a few vulnerabilities that would be prevented on CHERI only in the presence of subobject slicing.</p>
<p>For that reason, my tentative opinion is that the Rust spec <em>should</em> restrict provenance ranges when you access subobjects.  Perhaps not when you just convert between pointers and references or whatnot; there's room to be less strict wrt <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/134">https://github.com/rust-lang/unsafe-code-guidelines/issues/134</a>.  But at least when it comes to struct fields – if you write <code>&amp;mut foo.bar</code>, you should not be able to convert that to a raw pointer and then walk to <code>foo.baz</code>, even if <code>foo.baz</code> is not otherwise borrowed.  The same should probably be true for array indexing.</p>
<p>And then there absolutely should be an opt-out on a per-struct or per-field level for when you want to use container_of.</p>



<a name="277800417"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/277800417" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#277800417">(Apr 04 2022 at 22:06)</a>:</h4>
<p>So, one thing I wanted to mention here: In some of the other conversations, people were indicating that they believed the optimization opportunities to be rather small. I'd like to point out that for subobject provenance, that is <em>decidedly</em> not the case. <code>foo(&amp;mut bar.field)</code> not interfering with SROA is a potentially <em>very</em> significant win, and it's not out of reach for rustc to exploit by any means, even in the near-ish future</p>



<a name="277800678"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/277800678" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#277800678">(Apr 04 2022 at 22:09)</a>:</h4>
<p>True.  In fact, having that not interfere with SROA is a fundamental enabler for some kinds of zero-cost abstractions.  If I group a bunch of variables together in a struct, but never expose a pointer to the whole struct, that should not be any slower than having a bunch of separate variables.</p>



<a name="277800799"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/277800799" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#277800799">(Apr 04 2022 at 22:10)</a>:</h4>
<p>I have a specific use case in mind involving an interpreter.</p>



<a name="277907010"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/277907010" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brooks Davis <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#277907010">(Apr 05 2022 at 16:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="198590">comex</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/subobject.20provenance/near/277800170">said</a>:</p>
<blockquote>
<p>Yet, wearing my security hat, there are quite a few vulnerabilities that would be prevented on CHERI only in the presence of subobject slicing.</p>
<p>For that reason, my tentative opinion is that the Rust spec <em>should</em> restrict provenance ranges when you access subobjects.  Perhaps not when you just convert between pointers and references or whatnot; there's room to be less strict wrt <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/134">https://github.com/rust-lang/unsafe-code-guidelines/issues/134</a>.  But at least when it comes to struct fields – if you write <code>&amp;mut foo.bar</code>, you should not be able to convert that to a raw pointer and then walk to <code>foo.baz</code>, even if <code>foo.baz</code> is not otherwise borrowed.  The same should probably be true for array indexing.</p>
<p>And then there absolutely should be an opt-out on a per-struct or per-field level for when you want to use container_of.</p>
</blockquote>
<p>That sounds like a good balance for Rust. One one likes bugs like <a href="https://googleprojectzero.blogspot.com/2021/12/this-shouldnt-have-happened.html">https://googleprojectzero.blogspot.com/2021/12/this-shouldnt-have-happened.html</a>. For CHERI C our current view is that subobject bounds violates guarantees in the C standard and requires too many changes by default, but we hope to find ways to use them more broadly in C.</p>



<a name="277907423"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/277907423" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bram Geron <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#277907423">(Apr 05 2022 at 16:37)</a>:</h4>
<p>Do you mean “more broadly than in C”?</p>



<a name="277908316"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/277908316" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brooks Davis <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#277908316">(Apr 05 2022 at 16:43)</a>:</h4>
<p>For languages like Rust where it appears bound can be set without breaking the language, I encourage people to do so. For C, I want to try using them more broadly and make it easier to do so because we do currently miss certain classes of bugs, but doing so means yet another language variant.</p>



<a name="277923288"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/277923288" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#277923288">(Apr 05 2022 at 18:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="271719">Mario Carneiro</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/subobject.20provenance/near/277729908">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="132829">Christopher Durham</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/subobject.20provenance/near/277725523">said</a>:</p>
<blockquote>
<p>It's a simpler model for the developer if reference don't restrict their accessible range to <code>size_of_val(self)</code></p>
</blockquote>
<p>I don't know about that. I don't know how <code>split_at_mut</code> makes any sense if the references have overlapping access</p>
</blockquote>
<p>if they would overlap you could still cause UB under the non-subslicing model by doing ABA accesses</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">something</span><span class="p">.</span><span class="n">split_at_mut</span><span class="p">(</span><span class="o">..</span><span class="p">.)</span>:
<span class="o">*</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>
<span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="p">;</span><span class="w"> </span><span class="c1">// let's say this aliases `a[0]`</span>
<span class="fm">assert!</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span><span class="w"></span>
</code></pre></div>



<a name="277923468"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/277923468" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#277923468">(Apr 05 2022 at 18:28)</a>:</h4>
<p>but crucially, it's the <em>accesses</em> that define the boundary, not the type</p>



<a name="277923523"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/277923523" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#277923523">(Apr 05 2022 at 18:28)</a>:</h4>
<p>this is, I think, what many people hoped Stacked Borrows would be. but I like types...</p>



<a name="277923971"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/277923971" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#277923971">(Apr 05 2022 at 18:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="198590">comex</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/subobject.20provenance/near/277800170">said</a>:</p>
<blockquote>
<p>Yet, wearing my security hat, there are quite a few vulnerabilities that would be prevented on CHERI only in the presence of subobject slicing.</p>
<p>For that reason, my tentative opinion is that the Rust spec <em>should</em> restrict provenance ranges when you access subobjects.  Perhaps not when you just convert between pointers and references or whatnot; there's room to be less strict wrt <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/134">https://github.com/rust-lang/unsafe-code-guidelines/issues/134</a>.  But at least when it comes to struct fields – if you write <code>&amp;mut foo.bar</code>, you should not be able to convert that to a raw pointer and then walk to <code>foo.baz</code>, even if <code>foo.baz</code> is not otherwise borrowed.  The same should probably be true for array indexing.</p>
<p>And then there absolutely should be an opt-out on a per-struct or per-field level for when you want to use container_of.</p>
</blockquote>
<p>I imagine being restrictive in some cases could be integrated into a model that is generally more permissive.</p>
<p>however, on a high level your argument seems to be "let's make more things UB to make things more secure" and... that's a bad argument for UB, I think. at best it is an argument for "we say this is definitely wrong and code shouldnt do it but we will also never do optimizations that would break code which does do it"</p>



<a name="277924259"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/277924259" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#277924259">(Apr 05 2022 at 18:32)</a>:</h4>
<p>I have seen arguments claiming integer overflow UB in C is a good thing because it means we can have checkers that check against integer overflow. I think that's a terrible argument, why do we need UB (and unexpected compilation results and all the fun associated with that) to have such checkers?!? we really don't. all we need is consensus that integer overflow is a bug.<br>
incidentally, in Rust we have checkers that check against integer overflow (we even do it by default in debug builds), while they are not UB. so this is constructive proof that the argument is wrong.</p>



<a name="277952407"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/277952407" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ben Kimock (Saethlin) <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#277952407">(Apr 05 2022 at 22:33)</a>:</h4>
<p><em>In addition</em> <code>clang</code> has <code>-fsanitize=unsigned-integer-overflow</code> which does what it says on the tin. So... yeah.</p>



<a name="278443059"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/278443059" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Christopher Durham <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#278443059">(Apr 10 2022 at 02:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310518">Jak{e,ob} Degen</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/subobject.20provenance/near/277800417">said</a>:</p>
<blockquote>
<p><code>foo(&amp;mut bar.field)</code> not interfering with SROA is a potentially <em>very</em> significant win, and it's not out of reach for rustc to exploit by any means, even in the near-ish future</p>
</blockquote>
<p><span class="user-mention silent" data-user-id="198590">comex</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/subobject.20provenance/near/277800678">said</a>:</p>
<blockquote>
<p>If I group a bunch of variables together in a struct, but never expose a pointer to the whole struct, that should not be any slower than having a bunch of separate variables.</p>
</blockquote>
<p>Personally, this convinces me that subobject slicing is the desirable default for reference retagging on field access. I wonder if doing subobject slicing when taking a reference to a field but not <code>&amp;raw</code> or just when normally retagging is a simple enough model that gets benefits of both worlds?</p>



<a name="278446273"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/278446273" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#278446273">(Apr 10 2022 at 03:53)</a>:</h4>
<p>I believe that is the status quo, and am hopeful that this is simple enough. Especially with improved ergonomics around <code>&amp;raw</code> and such things</p>



<a name="278446340"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/278446340" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Christopher Durham (CAD97) <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#278446340">(Apr 10 2022 at 03:55)</a>:</h4>
<p>I'm fairly sure (but not 100%) that retagging <code>&amp;Header</code> restricts it to just <code>size_of::&lt;Header&gt;()</code> bytes</p>



<a name="278446347"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/278446347" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#278446347">(Apr 10 2022 at 03:55)</a>:</h4>
<p>I also believe that is the case, so I must have misunderstood what you meant then</p>



<a name="278446396"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/278446396" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Christopher Durham (CAD97) <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#278446396">(Apr 10 2022 at 03:56)</a>:</h4>
<p>What I meant is that <code>&amp;object.field</code> would slice provenance, but <code>&amp;*&amp;raw const object.field</code> wouldn't</p>



<a name="278446410"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/278446410" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Christopher Durham (CAD97) <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#278446410">(Apr 10 2022 at 03:57)</a>:</h4>
<p>I have no idea how to spec such in SB tbh</p>



<a name="278446412"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/278446412" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Christopher Durham (CAD97) <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#278446412">(Apr 10 2022 at 03:57)</a>:</h4>
<p>Since both are "reference of place" operations</p>



<a name="278446454"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/278446454" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Christopher Durham (CAD97) <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#278446454">(Apr 10 2022 at 03:58)</a>:</h4>
<p>It's not necessarily a good idea, but just a wonder about whether subobject slicing could be restricted to just when taking a subfield reference but allowing <code>&amp;Header</code> to carry provenance for an erased VLA tail if carefully constructed</p>



<a name="278446464"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/278446464" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#278446464">(Apr 10 2022 at 03:59)</a>:</h4>
<p>Some attribute to opt-out of subobject provenance probably would be useful for those cases. I think CHERI has some opt-in stuff on the C side.</p>



<a name="278446473"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/278446473" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#278446473">(Apr 10 2022 at 03:59)</a>:</h4>
<p>Yeah, i don't know how such a thing could work either - <span class="user-mention" data-user-id="120791">@RalfJ</span> had mentioned one time that he had an idea for this, I don't know if he ever shared what it was though</p>



<a name="278446495"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/278446495" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Christopher Durham (CAD97) <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#278446495">(Apr 10 2022 at 04:00)</a>:</h4>
<p>The opt-out already has to exist for <code>extern type</code>, so for the tail it's "just" using an <code>extern type</code> tail</p>



<a name="278446553"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/278446553" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Christopher Durham (CAD97) <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#278446553">(Apr 10 2022 at 04:00)</a>:</h4>
<p>The interesting case is when you want a <code>container_of!</code> style operation to work</p>



<a name="278446572"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/278446572" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Christopher Durham (CAD97) <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#278446572">(Apr 10 2022 at 04:00)</a>:</h4>
<p>Access <code>ptr[-1]</code> or so</p>



<a name="278467538"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/278467538" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#278467538">(Apr 10 2022 at 13:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="132829">Christopher Durham (CAD97)</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/subobject.20provenance/near/278443059">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="310518">Jak{e,ob} Degen</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/subobject.20provenance/near/277800417">said</a>:</p>
<blockquote>
<p><code>foo(&amp;mut bar.field)</code> not interfering with SROA is a potentially <em>very</em> significant win, and it's not out of reach for rustc to exploit by any means, even in the near-ish future</p>
</blockquote>
<p><span class="user-mention silent" data-user-id="198590">comex</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/subobject.20provenance/near/277800678">said</a>:</p>
<blockquote>
<p>If I group a bunch of variables together in a struct, but never expose a pointer to the whole struct, that should not be any slower than having a bunch of separate variables.</p>
</blockquote>
<p>Personally, this convinces me that subobject slicing is the desirable default for reference retagging on field access. I wonder if doing subobject slicing when taking a reference to a field but not <code>&amp;raw</code> or just when normally retagging is a simple enough model that gets benefits of both worlds?</p>
</blockquote>
<p>how would that work with "access the header before the object" style code? that just seems like a fundamental conflict to me.</p>



<a name="278467587"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/278467587" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#278467587">(Apr 10 2022 at 13:12)</a>:</h4>
<p>also note that SROA when a pointer to a field has been taken is <em>really subtle</em> because no matter what we do with subobject provenance, this also affects the addresses things will be at.</p>



<a name="278467641"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/278467641" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#278467641">(Apr 10 2022 at 13:14)</a>:</h4>
<p>like, when I do</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">foo1</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">bar</span><span class="p">.</span><span class="n">field1</span><span class="p">);</span><span class="w"></span>
<span class="n">foo2</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">bar</span><span class="p">.</span><span class="n">field2</span><span class="p">);</span><span class="w"></span>
</code></pre></div>
<p>then the two functions could cooperate to calculate the offset between the two fields, and if this is <code>repr(C)</code> that is fully determined. doesn't that prevent SROA?<br>
even with <code>repr(Rust)</code> this must be consistent, e.g. if the code is executed mutliple times it must always be the same distance -- which is not generally true if <code>field1</code> and <code>field2</code> just become local variables.</p>



<a name="278467665"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/278467665" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#278467665">(Apr 10 2022 at 13:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="132829">Christopher Durham (CAD97)</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/subobject.20provenance/near/278446495">said</a>:</p>
<blockquote>
<p>The opt-out already has to exist for <code>extern type</code>, so for the tail it's "just" using an <code>extern type</code> tail</p>
</blockquote>
<p>I am also not quite sure how to do that while still having subobject provenance elsewhere</p>



<a name="278481207"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/278481207" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#278481207">(Apr 10 2022 at 17:56)</a>:</h4>
<p>since we are discussing <code>ptr::Unique</code>  in another topic, something that occurred to me -- I think what I am imagining for <code>&amp;mut</code> would basically make them equivalent to <code>Unique</code>, except that <code>&amp;mut</code> also does this "protector" stuff in SB (needed to ensure it remains dereferencable for the duration of the call). not sure if that is a good thing or a bad thing.</p>



<a name="278482495"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/278482495" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> rpjohnst <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#278482495">(Apr 10 2022 at 18:23)</a>:</h4>
<p>probably not super relevant here but it would be nice to have some kind of "&amp; but i don't care about the address" type- it would let this <code>foo1</code>/<code>foo2</code> example do SROA, it could represent small objects directly, etc...</p>



<a name="278483711"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/278483711" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Christopher Durham (CAD97) <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#278483711">(Apr 10 2022 at 18:52)</a>:</h4>
<p>I honestly don't know, and tbh most of this discussion is kind of moot until we have an actual model of the <code>extern type</code>-supporting SB, since it's mostly just conjecturing about hypotheticals</p>



<a name="278483745"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/278483745" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Christopher Durham (CAD97) <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#278483745">(Apr 10 2022 at 18:53)</a>:</h4>
<p>My very rough hypothetical for "subobject slicing except for <code>extern type</code>" is "retagging references does today's operations for types without an <code>extern type</code> tail and the nonslicing retag if the type has an <code>extern type</code> tail"</p>



<a name="278483796"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/278483796" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Christopher Durham (CAD97) <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#278483796">(Apr 10 2022 at 18:54)</a>:</h4>
<p>Which is basically a cop-out and doesn't make any sense if the rest of the world's state isn't identical between the two models</p>



<a name="278487762"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/278487762" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jessica Clarke <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#278487762">(Apr 10 2022 at 20:21)</a>:</h4>
<p><span class="user-mention silent" data-user-id="303115">Quy Nguyen</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/subobject.20provenance/near/278446464">said</a>:</p>
<blockquote>
<p>Some attribute to opt-out of subobject provenance probably would be useful for those cases. I think CHERI has some opt-in stuff on the C side.</p>
</blockquote>
<p>CHERI Clang has an opt-in compiler flag (with varying degrees of aggressiveness) and opt-out <code>__attribute__</code>s (and a <code>__builtin_addressof</code> variant that doesn't set bounds, though not sure if we ever actually make use of that)</p>



<a name="278488521"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/278488521" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#278488521">(Apr 10 2022 at 20:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/subobject.20provenance/near/278467641">said</a>:</p>
<blockquote>
<p>like, when I do</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">foo1</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">bar</span><span class="p">.</span><span class="n">field1</span><span class="p">);</span><span class="w"></span>
<span class="n">foo2</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">bar</span><span class="p">.</span><span class="n">field2</span><span class="p">);</span><span class="w"></span>
</code></pre></div>
<p>then the two functions could cooperate to calculate the offset between the two fields, and if this is <code>repr(C)</code> that is fully determined. doesn't that prevent SROA?<br>
even with <code>repr(Rust)</code> this must be consistent, e.g. if the code is executed mutliple times it must always be the same distance -- which is not generally true if <code>field1</code> and <code>field2</code> just become local variables.</p>
</blockquote>
<p>Yeah, I ended up realizing this, and it's actually even worse than that. We can't even SROA in this scenario:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">x</span>: <span class="p">(</span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">y</span>: <span class="kt">u8</span> <span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="n">foo</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">y</span><span class="p">);</span><span class="w"></span>
</code></pre></div>
<p>Because we need to ensure that <code>arg2.addr() - arg1.addr()</code> is at least 2. This particular case could be fixed by not guaranteeing address uniqueness, but of course my proposal for that doesn't work in a non-strict provenance world</p>



<a name="278489000"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/278489000" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#278489000">(Apr 10 2022 at 20:50)</a>:</h4>
<p>This is <em>really</em> sad, I wonder if there's a way to salvage it...</p>



<a name="278489123"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/278489123" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#278489123">(Apr 10 2022 at 20:53)</a>:</h4>
<p>I think this might be the same as <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/244">https://github.com/rust-lang/unsafe-code-guidelines/issues/244</a> ?</p>



<a name="278489196"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/278489196" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#278489196">(Apr 10 2022 at 20:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310518">Jak{e,ob} Degen</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/subobject.20provenance/near/278489000">said</a>:</p>
<blockquote>
<p>This is <em>really</em> sad, I wonder if there's a way to salvage it...</p>
</blockquote>
<p>at the very least, we'd have to have references whose 'address' is truly unobservable -- casting them to raw pointers would have to be unsafe. then we also need an operational model that actually justifies this...</p>



<a name="278489230"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/278489230" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#278489230">(Apr 10 2022 at 20:55)</a>:</h4>
<p>you can always just do the compiler thing and do an escape analysis on the address of the pointer, with no model changes</p>



<a name="278489327"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/278489327" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#278489327">(Apr 10 2022 at 20:57)</a>:</h4>
<p>Yeah, it sounds like this is something we'll need to do</p>



<a name="278489370"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/278489370" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#278489370">(Apr 10 2022 at 20:58)</a>:</h4>
<p>I don't think we have any inter-procedural analyses in rustc yet, so that'll be an interesting project</p>



<a name="278489402"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/278489402" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#278489402">(Apr 10 2022 at 20:59)</a>:</h4>
<p>you mean we should write a smart compiler rather than putting the burden on programmers? shocking!! ;)</p>



<a name="278489407"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/278489407" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#278489407">(Apr 10 2022 at 20:59)</a>:</h4>
<p>but yeah this discussion was about SROA when a reference to one field escapes, where escape analysis will just shrug its shoulders</p>



<a name="278489743"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/278489743" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#278489743">(Apr 10 2022 at 21:05)</a>:</h4>
<p>well, the "inter-procedural analysis" part is that we can go look in <code>foo</code> to find out if it <em>really</em> escapes instead of just assuming the worst</p>



<a name="278489755"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/278489755" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#278489755">(Apr 10 2022 at 21:05)</a>:</h4>
<p>sure, if we know <code>foo</code> the game changes</p>



<a name="278489761"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/278489761" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#278489761">(Apr 10 2022 at 21:05)</a>:</h4>
<p>since it is a reasonable estimate that most references do not have their addresses inspected</p>



<a name="278489804"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject%20provenance/near/278489804" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/subobject.20provenance.html#278489804">(Apr 10 2022 at 21:06)</a>:</h4>
<p>but it is unlikely that a local analysis can deduce this</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>