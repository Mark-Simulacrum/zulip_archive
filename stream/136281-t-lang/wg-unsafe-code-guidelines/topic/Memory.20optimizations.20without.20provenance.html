<html>
<head><meta charset="utf-8"><title>Memory optimizations without provenance · t-lang/wg-unsafe-code-guidelines · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/index.html">t-lang/wg-unsafe-code-guidelines</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html">Memory optimizations without provenance</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="277229678"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277229678" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277229678">(Mar 31 2022 at 03:41)</a>:</h4>
<p><span class="user-mention" data-user-id="119009">@eddyb</span> </p>
<blockquote>
<p>My understanding is that you have e.g. wasm then. Fully deterministic and fully unoptimizable memory-wise.</p>
</blockquote>
<p>No that's not true. You still have non-determinism to play with and that can be a <em>very</em> powerful hammer.<br>
Even wasm is not fully deterministic (in its float semantics); but that remark aside -- why would "no provenance" imply "fully deterministic"? It surely does not!</p>



<a name="277229828"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277229828" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277229828">(Mar 31 2022 at 03:44)</a>:</h4>
<p>in particular <a href="https://www.ralfj.de/research/twinsem/twinsem.pdf">https://www.ralfj.de/research/twinsem/twinsem.pdf</a> takes non-determinism based optimizations (in finite memory) to the next level, it's <em>almost</em> as good as (simple, C-style, non-restrict/SB) provenance.</p>



<a name="277230207"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277230207" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Thom Chiovoloni <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277230207">(Mar 31 2022 at 03:52)</a>:</h4>
<blockquote>
<p>(However, this does require accepting a fully non-deterministic allocator, which low-level people also find hard to stomach sometimes. In particular those that implement allocators. <span aria-label="joy" class="emoji emoji-1f602" role="img" title="joy">:joy:</span> )</p>
</blockquote>
<p>As someone who implements allocators (well, not at my current job), it is a little bit surprising the first time you realize you can't use malloc/free (err, <code>#[global_allocator]</code>/<code>__attribute__((malloc(...)))</code>/whatever allocator trait) to test your allocator. But it's not that bad honestly, you just use your allocators apis directly for testing.</p>
<p>I'm actually glad the compiler can sometimes optimize away allocations, and fine with it introducing whatever forms of nondeterminism wrt those apis being used that it needs to (despite being otherwise fairly conservative wrt the shenanigans I think compilers should get up to).</p>



<a name="277231157"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277231157" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277231157">(Mar 31 2022 at 04:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance/near/277229678">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="119009">eddyb</span> </p>
<blockquote>
<p>My understanding is that you have e.g. wasm then. Fully deterministic and fully unoptimizable memory-wise.</p>
</blockquote>
<p>No that's not true. You still have non-determinism to play with and that can be a <em>very</em> powerful hammer.<br>
Even wasm is not fully deterministic (in its float semantics); but that remark aside -- why would "no provenance" imply "fully deterministic"? It surely does not!</p>
</blockquote>
<p>my bad, I didn't mean to imply deterministic allocators were the only one way to have a flat memory, but rather that you lose <em>the right</em> to optimizations once you remove the concept of "allocations"</p>



<a name="277231223"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277231223" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277231223">(Mar 31 2022 at 04:10)</a>:</h4>
<p>wasm is just a good example of the extreme of "no memory optimizations here"</p>



<a name="277232267"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277232267" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277232267">(Mar 31 2022 at 04:32)</a>:</h4>
<p>(I'm editing the comment right now a bit, wow the wasm section is a mess)</p>



<a name="277232751"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277232751" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277232751">(Mar 31 2022 at 04:43)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance/near/277229828">said</a>:</p>
<blockquote>
<p>in particular <a href="https://www.ralfj.de/research/twinsem/twinsem.pdf">https://www.ralfj.de/research/twinsem/twinsem.pdf</a> takes non-determinism based optimizations (in finite memory) to the next level, it's <em>almost</em> as good as (simple, C-style, non-restrict/SB) provenance.</p>
</blockquote>
<p><a href="/user_uploads/4715/LhKkF8RsKpUTfT1K0Io_yS9y/image.png">image.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/4715/LhKkF8RsKpUTfT1K0Io_yS9y/image.png" title="image.png"><img src="/user_uploads/4715/LhKkF8RsKpUTfT1K0Io_yS9y/image.png"></a></div>



<a name="277232765"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277232765" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277232765">(Mar 31 2022 at 04:43)</a>:</h4>
<p>does that not say "provenance"? it just seems like a model with "optional provenance". that's <code>N + 1</code>, not <code>1 + 1</code> (i.e. <code>Option</code> is not <code>bool</code>)</p>



<a name="277232826"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277232826" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277232826">(Mar 31 2022 at 04:44)</a>:</h4>
<p>or is that not an example of what I thought it was?</p>



<a name="277232908"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277232908" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277232908">(Mar 31 2022 at 04:46)</a>:</h4>
<p>(again, the determinism connection was accidental, I was nerding out too much about wasm effectively having no memory UB)</p>



<a name="277238890"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277238890" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick12 <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277238890">(Mar 31 2022 at 06:38)</a>:</h4>
<p>For anyone else who read the first message and was a bit confused what it was quoting, it seems to be from <a href="https://github.com/rust-lang/rust/issues/95228#issuecomment-1084043484">https://github.com/rust-lang/rust/issues/95228#issuecomment-1084043484</a></p>



<a name="277271054"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277271054" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277271054">(Mar 31 2022 at 12:14)</a>:</h4>
<p>There are some optimizations that are really useful that depend on provneance.<br>
One that do today in lccc (source is in xir because binary ops aren't supported in the rust frontend, though I'll provide the logically equivalent rust)</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">function</span><span class="w"> </span><span class="n">inspect_stack_frames</span><span class="p">();</span><span class="w"></span>

<span class="n">function</span><span class="w"> </span><span class="n">lol</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">int</span><span class="p">(</span><span class="mi">32</span><span class="p">){</span><span class="w"></span>
<span class="w">    </span><span class="n">declare</span><span class="w"> </span><span class="n">_0</span>: <span class="nc">int</span><span class="p">(</span><span class="mi">32</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">declare</span><span class="w"> </span><span class="n">_1</span>: <span class="nc">int</span><span class="p">(</span><span class="mi">32</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">local</span><span class="w"> </span><span class="n">_1</span><span class="w"> </span><span class="c1">// [lvalue int(32)]</span>
<span class="w">    </span><span class="n">local</span><span class="w"> </span><span class="n">_0</span><span class="w"> </span><span class="c1">// [lvalue int(32),lvalue int(32)]</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">int</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">// [lvalue int(32),lvalue int (32),int(32)]</span>
<span class="w">    </span><span class="n">dup</span><span class="w"> </span><span class="c1">// [lvalue int(32),lvalue int(32),int(32),int(32)]</span>
<span class="w">    </span><span class="n">pivot</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">// [lvalue int(32),int(32),lvalue int(32), int(32)]</span>
<span class="w">    </span><span class="n">assign</span><span class="w"> </span><span class="c1">// [lvalue int(32),int(32)]</span>
<span class="w">    </span><span class="n">assign</span><span class="w"> </span><span class="c1">// []</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">global_address</span><span class="w"> </span><span class="n">inspect_stack_frames</span><span class="w"> </span><span class="c1">// [*function()-&gt;void()]</span>
<span class="w">    </span><span class="n">call</span><span class="w"> </span><span class="n">function</span><span class="p">()</span>-&gt;<span class="nc">void</span><span class="p">()</span><span class="w"> </span><span class="c1">// []</span>
<span class="w">    </span><span class="n">local</span><span class="w"> </span><span class="n">_0</span><span class="w"> </span><span class="c1">// [lvalue int(32)]</span>
<span class="w">    </span><span class="n">as_rvalue</span><span class="w"> </span><span class="c1">// [int(32)]</span>
<span class="w">    </span><span class="n">local</span><span class="w"> </span><span class="n">_1</span><span class="w"> </span><span class="c1">// [int(32),lvalue int(32)]</span>
<span class="w">    </span><span class="n">as_rvalue</span><span class="w"> </span><span class="c1">// [int(32),int(32)]</span>
<span class="w">    </span><span class="n">add</span><span class="w"> </span><span class="c1">// [int(32)]</span>
<span class="w">    </span><span class="n">exit</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>This is roughly equivalent to this code, that was used on the rust community discord to demonstraight the usefulness </p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">extern</span><span class="w"> </span><span class="s">"C"</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">inspect_stack_frame</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">foo</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="kt">i32</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">unsafe</span><span class="p">{</span><span class="n">inspect_stack_frame</span><span class="p">()}</span><span class="w"></span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>The machine code this generates is:</p>
<div class="codehilite" data-code-language="ActionScript"><pre><span></span><code><span class="mi">0000000000000000</span><span class="w"> </span><span class="o">&lt;</span><span class="nx">lol</span><span class="o">&gt;:</span><span class="w"></span>
<span class="w">   </span><span class="mi">0</span><span class="o">:</span><span class="w">   </span><span class="nx">e8</span><span class="w"> </span><span class="mi">00</span><span class="w"> </span><span class="mi">00</span><span class="w"> </span><span class="mi">00</span><span class="w"> </span><span class="mi">00</span><span class="w">          </span><span class="nx">call</span><span class="w">   </span><span class="mi">5</span><span class="w"> </span><span class="o">&lt;</span><span class="nx">lol</span><span class="o">+</span><span class="mh">0x5</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">                        </span><span class="mi">1</span><span class="o">:</span><span class="w"> </span><span class="nx">R_X86_64_PLT32</span><span class="w">       </span><span class="nx">inspect_stack_frames</span><span class="o">-</span><span class="mh">0x4</span><span class="w"></span>
<span class="w">   </span><span class="mi">5</span><span class="o">:</span><span class="w">   </span><span class="nx">b8</span><span class="w"> </span><span class="mi">02</span><span class="w"> </span><span class="mi">00</span><span class="w"> </span><span class="mi">00</span><span class="w"> </span><span class="mi">00</span><span class="w">          </span><span class="nx">mov</span><span class="w">    </span><span class="nx">$0x2</span><span class="o">,%</span><span class="nx">eax</span><span class="w"></span>
<span class="w">   </span><span class="nx">a</span><span class="o">:</span><span class="w">   </span><span class="nx">c3</span><span class="w">                      </span><span class="nx">ret</span><span class="w"></span>
</code></pre></div>



<a name="277272265"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277272265" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277272265">(Mar 31 2022 at 12:26)</a>:</h4>
<p>I'm fairly certain this optimization would be incorrect under a "no-provenance only non-deterministic allocations" world, since <code>inspect_stack_frame()</code> could do some magic to determine where <code>x</code> and <code>y</code> (or <code>_0</code>/<code>_1</code>) are and read them.</p>



<a name="277273075"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277273075" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277273075">(Mar 31 2022 at 12:33)</a>:</h4>
<p>If the non-determinstic allocations extens to the stackframe layout it would be impossible to determine where x and y are without crashing for some layouts which if I understand the twinsem paper correctly would be considered as UB even if the chosen layout makes it valid. This in effect prevents inspect_stack_frame() from reading or writing x and y unless a pointer is passed to it.</p>



<a name="277273348"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277273348" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277273348">(Mar 31 2022 at 12:36)</a>:</h4>
<p>That's "Unspecified if undefined" which, in C++, is indeed equivalent to just UB.<br>
I asked about it wrt. Rust in this stream, though, and the response wasn't necessarily encouraging.</p>



<a name="277273720"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277273720" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277273720">(Mar 31 2022 at 12:39)</a>:</h4>
<p>And, I mean, as much as I'd love to explode stuff  (though it probably won't crash, just read uninit mem), there's only so many layouts of <code>lol</code>s stack frame that don't use a bunch of memory for no reason.</p>



<a name="277279162"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277279162" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277279162">(Mar 31 2022 at 13:20)</a>:</h4>
<p>Twinsem allocates two pieces of memory on every memory allocation. Non-deterministically one is chosen as the memory to return and the other is marked as causing UB on access. You can do the same for the stack frame layout.</p>



<a name="277290012"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277290012" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277290012">(Mar 31 2022 at 14:29)</a>:</h4>
<p>the twinsem paper outright states their use of provenance for non-ptr2int memory allocations, doesn't it?</p>



<a name="277298910"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277298910" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277298910">(Mar 31 2022 at 15:30)</a>:</h4>
<p><span class="user-mention silent" data-user-id="119009">eddyb</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance/near/277232765">said</a>:</p>
<blockquote>
<p>does that not say "provenance"? it just seems like a model with "optional provenance". that's <code>N + 1</code>, not <code>1 + 1</code> (i.e. <code>Option</code> is not <code>bool</code>)</p>
</blockquote>
<p>yes that model <em>also</em> has provenance. but it also has quite good optimization power for "exposed" allocations where provenance does not help any more.</p>



<a name="277299064"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277299064" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277299064">(Mar 31 2022 at 15:31)</a>:</h4>
<p><span class="user-mention" data-user-id="257758">@Connor Horman</span> that optimization does <em>not</em> need provenance, if one assumes a fully non-det allocator</p>



<a name="277299109"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277299109" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277299109">(Mar 31 2022 at 15:31)</a>:</h4>
<p>you cant actually rely on <code>x</code> and <code>y</code> being "in the stack frame" or anything like that,m they might be literally anywhere in the address space</p>



<a name="277299225"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277299225" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277299225">(Mar 31 2022 at 15:32)</a>:</h4>
<p>True. Although fully non-deterministic allocator isn't really a practically applicable thing.</p>



<a name="277299304"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277299304" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277299304">(Mar 31 2022 at 15:32)</a>:</h4>
<p>not sure what you mean, it's a model thing</p>



<a name="277299328"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277299328" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277299328">(Mar 31 2022 at 15:32)</a>:</h4>
<p>the behavior of the actual allocator is entirely irrelevant for this argument</p>



<a name="277299688"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277299688" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277299688">(Mar 31 2022 at 15:35)</a>:</h4>
<p><span class="user-mention" data-user-id="119009">@eddyb</span> basically non-determinism is enough for things like</p>
<div class="codehilite" data-code-language="C"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span><span class="w"></span>
<span class="o">*</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>
<span class="n">some_function</span><span class="p">()</span><span class="o">:</span><span class="w"></span>
<span class="n">assert</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span><span class="w"></span>
</code></pre></div>
<p><code>some_function</code> cannot "guess" the address of <code>x</code>. if it just guesses an address and writes there, that is UB in case the guess is wrong, so the compiler is allowed to say "okay I choose UB and we are done".<br>
there is one wrinkle to this, which is that when the address space is finite there might be only a single place in memory where <code>x</code> could be put, and <code>some_function</code> then could rely on it being put there.  that's why twinsem needs "twin allocations", to exclude those pathological almost-OOM situations. compilers in practice already don't care about such situations so if we ignore them, just having a non-det allocator already lets you do many of the regular optimizations.</p>



<a name="277299886"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277299886" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277299886">(Mar 31 2022 at 15:36)</a>:</h4>
<p>that is, I think, where the entire concept of "provenance" comes from -- it was an <em>analysis</em> tool describing how compilers tracked whether information about a ptr address is flowing some place so that that place can guess the ptr value and access that memory.</p>



<a name="277299972"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277299972" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277299972">(Mar 31 2022 at 15:37)</a>:</h4>
<p>sadly many people seem confused by non-determinism so e.g. the C committee seems to refuse to accept optimizations based on a model like this (I had a <em>long</em> and frustrating discussion about this on the c-memory-model mailing list...)</p>



<a name="277300631"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277300631" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277300631">(Mar 31 2022 at 15:41)</a>:</h4>
<p>(the thread starts here: <a href="https://lists.cam.ac.uk/sympa/arc/cl-c-memory-object-model/2021-05/msg00236.html">https://lists.cam.ac.uk/sympa/arc/cl-c-memory-object-model/2021-05/msg00236.html</a> )</p>



<a name="277300983"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277300983" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277300983">(Mar 31 2022 at 15:44)</a>:</h4>
<p>My crazy perspective: "The compiler will perform X, Y, and Z optimizations and you get what you get" is already a semantics that could theoretically be formally specified, albeit one that's very difficult to check at runtime.  The goal is to convert that to operational semantics, for the sake of both understandability and runtime checking, without losing too many useful programs and without losing too many useful optimizations.  But whether that's even possible is an open research problem.  If we have an operational semantics that /almost/ satisfies that goal but fails to model the True Compiler Semantics in rare cases where the address space is completely full, that's still pretty useful.</p>



<a name="277301185"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277301185" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277301185">(Mar 31 2022 at 15:45)</a>:</h4>
<p>I was referring to twinsem, but I suppose you could say the same about strict_provenance, which is explicitly being positioned as an operational semantics that is a subset of some 'real' semantics...</p>



<a name="277303528"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277303528" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277303528">(Mar 31 2022 at 16:01)</a>:</h4>
<p>I don't understand how a model based solely in "non-determinism" as in "chaos" can be <em>sound</em>. if the compiler assumes something to be UB, then it's provenance that "reifies" non-guessability, and the chaos is no longer needed</p>



<a name="277303700"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277303700" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277303700">(Mar 31 2022 at 16:02)</a>:</h4>
<p>It can be sound because you can only verify a wrong guess by trying to access certain memory, and doing so is UB.</p>



<a name="277303702"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277303702" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277303702">(Mar 31 2022 at 16:02)</a>:</h4>
<p>"I choose UB because I see this address cannot leak" <em>is</em> provenance to me</p>



<a name="277303984"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277303984" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277303984">(Mar 31 2022 at 16:04)</a>:</h4>
<p>"this allocation is outside of the reach of accesses that do not refer to it statically" <em>is</em> provenance</p>



<a name="277304364"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277304364" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277304364">(Mar 31 2022 at 16:07)</a>:</h4>
<p>I think describing it in a deterministic model requires some kind of provenance.  But not if you accept the premise of nondeterminism, where "rolling the dice and committing UB if you have bad luck" is itself a form of UB.</p>



<a name="277304452"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277304452" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277304452">(Mar 31 2022 at 16:07)</a>:</h4>
<p>"This allocation is outside of the reach of accesses that do not refer to it statically" is translated into "the program cannot know for sure where the allocation is without referring to it statically, and cannot guess without committing UB if it has bad luck".</p>



<a name="277304608"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277304608" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277304608">(Mar 31 2022 at 16:08)</a>:</h4>
<p>okay so it's <em>not</em> "non-determinism" as in "chaos", "input side-effects" etc., it's "quantifying over many-worlds and <em>not</em> making a choice" (like in grammars)</p>



<a name="277304636"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277304636" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277304636">(Mar 31 2022 at 16:08)</a>:</h4>
<p>those two are... very different concepts that only unfortunately share a name</p>



<a name="277305023"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277305023" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277305023">(Mar 31 2022 at 16:10)</a>:</h4>
<p>the problem with the many-worlds quantification stuff is you have to actually explicitly place the quantifications</p>



<a name="277305475"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277305475" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> comex <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277305475">(Mar 31 2022 at 16:14)</a>:</h4>
<p>I believe that's accurate.</p>



<a name="277305789"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277305789" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277305789">(Mar 31 2022 at 16:16)</a>:</h4>
<p>so the example above becomes something more like</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">i32</span><span class="p">;</span><span class="w"></span>
<span class="n">x</span><span class="p">.</span><span class="n">non_det_map</span><span class="p">(</span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="o">*</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">some_function</span><span class="p">()</span>:
    <span class="nc">assert</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span><span class="w"></span>
<span class="p">}).</span><span class="n">ub_if_any_ub</span><span class="p">().</span><span class="n">choose</span><span class="p">();</span><span class="w"></span>
</code></pre></div>



<a name="277305998"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277305998" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277305998">(Mar 31 2022 at 16:18)</a>:</h4>
<p>so the only way to "get lucky uniformly across the multiverse" is to have access to the exact value of <code>x</code> every time</p>



<a name="277306336"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277306336" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277306336">(Mar 31 2022 at 16:21)</a>:</h4>
<p>it's a cute trick but a <code>NonDet&lt;usize&gt;</code> address is still... provenance. if you can soundly show that you cannot produce an equal <code>usize</code> without using the original... it's provenance</p>



<a name="277306453"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277306453" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277306453">(Mar 31 2022 at 16:22)</a>:</h4>
<p>it's just obfuscated by non-rigorous encodings</p>



<a name="277307290"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277307290" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277307290">(Mar 31 2022 at 16:28)</a>:</h4>
<p>it's probably easier to understand this as... parametericity I guess:<br>
we're saying that <code>forall y.( forall x.( x == y ) -&gt; ! )</code> is provable<br>
which allows us to infer <code>x != anything_not_derived_from_x</code></p>
<p>the result is "derived from <code>x</code>" becomes part of our reasoning and that's... provenance</p>



<a name="277314464"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277314464" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277314464">(Mar 31 2022 at 17:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="119009">eddyb</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance/near/277303984">said</a>:</p>
<blockquote>
<p>"this allocation is outside of the reach of accesses that do not refer to it statically" <em>is</em> provenance</p>
</blockquote>
<p>no it is not</p>



<a name="277314489"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277314489" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277314489">(Mar 31 2022 at 17:28)</a>:</h4>
<p>at least not in the sense of "pointers in the Abstract Machine are distinct from integers"</p>



<a name="277314544"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277314544" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277314544">(Mar 31 2022 at 17:29)</a>:</h4>
<p>true, all integers have what I'm calling provenance, in that kind of machine :P</p>



<a name="277314566"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277314566" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277314566">(Mar 31 2022 at 17:29)</a>:</h4>
<p>not quite sure which distinction you are making between different kinds of non-determinism, but this is <em>internal</em> non-determinism</p>



<a name="277314710"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277314710" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277314710">(Mar 31 2022 at 17:30)</a>:</h4>
<p>as in, <code>malloc</code> is just specified to return some integer (disjoint from existing allocations yada yada). this is non-deterministic because there might be many possible choices of integer.<br>
the compiler is allowed to reduce non-determinism during allocation, i.e., it is alllowed to make "choices". the programmer has to prove that no possible choice leads to UB.</p>



<a name="277314732"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277314732" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277314732">(Mar 31 2022 at 17:30)</a>:</h4>
<p><span class="user-mention silent" data-user-id="119009">eddyb</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance/near/277314544">said</a>:</p>
<blockquote>
<p>true, all integers have what I'm calling provenance, in that kind of machine :P</p>
</blockquote>
<p>yeah please dont call that provenance it confused everyone</p>



<a name="277314801"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277314801" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277314801">(Mar 31 2022 at 17:31)</a>:</h4>
<p>(I spent some time getting accustomed with grammars, specifically CFGs that are not DCFGs, and I believe NFA and DFA have a similar relationship - I still do not fully understand why that "many-worlds" stuff is called "non-deterministic", but it's very different from the other significant use of the word)</p>



<a name="277314919"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277314919" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277314919">(Mar 31 2022 at 17:32)</a>:</h4>
<p>In the past I mentioned "emergent" and "synthetic" provenance; the only kind this abstract machine has is "emergent". <em>all</em> specs have that, including assembly. or rather, <em>no</em> spec has it, because establishing the correctness of such an analysis is a <em>theorem</em>.<br>
when you ask "does X have provenance", in the context of our discussion here this question asks whether the concept of provenance is something that appears in the <em>specification</em> of X.</p>



<a name="277314992"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277314992" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277314992">(Mar 31 2022 at 17:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="119009">eddyb</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance/near/277314801">said</a>:</p>
<blockquote>
<p>(I spent some time getting accustomed with grammars, specifically CFGs that are not DCFGs, and I believe NFA and DFA have a similar relationship - I still do not fully understand why that "many-worlds" stuff is called "non-deterministic", but it's very different from the other significant use of the word)</p>
</blockquote>
<p>(it's not really very different, the question is just who gets to resolve the choices. but the underlying theoretic concept is the same. it's just a very general concept that you see used in different ways here.)</p>



<a name="277315196"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277315196" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277315196">(Mar 31 2022 at 17:34)</a>:</h4>
<p>so what I am saying is that we can have an Abstract Machine without provenance <em>in its specification</em> and still have a wide range of interesting pointer optimizations. of course nobody can stop you from defining an analysis on top of that that tracks data and control dependencies and whatnot (just like you can on assembly, which presumably "does not have provenance"), but that is not part of the spec / abstract machine so it's very different from "having provenance".</p>



<a name="277315657"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277315657" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277315657">(Mar 31 2022 at 17:39)</a>:</h4>
<p>I'm worried this leads into a philosophical argument where you can (almost?) always redefine an Abstract Machine so that it doesn't have a provenance concept anymore, explicitly, but remains equivalent</p>



<a name="277316273"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277316273" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277316273">(Mar 31 2022 at 17:44)</a>:</h4>
<p>one way to break the causal link to reach from a pointer to an integer (i.e. "provenance erasure"), would be require that integers remain invariant under all the address non-determinism</p>



<a name="277316336"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277316336" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277316336">(Mar 31 2022 at 17:45)</a>:</h4>
<p>in the binder equivalence, it's like putting an <code>exists</code> outside the non-det-like <code>forall</code> and requiring equality to it</p>



<a name="277316400"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277316400" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277316400">(Mar 31 2022 at 17:45)</a>:</h4>
<p>(it's really tempting to compare this to the double-slit experiment :P)</p>



<a name="277318090"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277318090" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277318090">(Mar 31 2022 at 17:58)</a>:</h4>
<p>Also this sort of nondeterministic maximally permissive provenance is basically the current C restrict wording, which is basically "if you change the input restrict pointer, and this new pointer expression changes, then it's valid to alias the original"</p>



<a name="277318335"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277318335" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277318335">(Mar 31 2022 at 18:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="119009">eddyb</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance/near/277315657">said</a>:</p>
<blockquote>
<p>I'm worried this leads into a philosophical argument where you can (almost?) always redefine an Abstract Machine so that it doesn't have a provenance concept anymore, explicitly, but remains equivalent</p>
</blockquote>
<p>no that's not the case. it's a hard technical distinction.<br>
you dont get <code>restrict</code> or <code>noalias</code> without explicit provenance in the abstract machine.</p>



<a name="277318408"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277318408" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277318408">(Mar 31 2022 at 18:01)</a>:</h4>
<p>ehm, didn't <span class="user-mention" data-user-id="143798">@Talchas</span> just say the opposite about <code>restrict</code>?</p>



<a name="277318508"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277318508" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277318508">(Mar 31 2022 at 18:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="119009">eddyb</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance/near/277316273">said</a>:</p>
<blockquote>
<p>one way to break the causal link to reach from a pointer to an integer (i.e. "provenance erasure"), would be require that integers remain invariant under all the address non-determinism</p>
</blockquote>
<p>I... don't think that's even well-formed.<br>
like, non-determinism in programming languages is a really well studied concept as completely standard. not sure why you want to somehow make it something mystic. but there's no way to even state what you just said in that context.</p>



<a name="277318607"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277318607" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277318607">(Mar 31 2022 at 18:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="119009">eddyb</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance/near/277318408">said</a>:</p>
<blockquote>
<p>ehm, didn't <span class="user-mention silent" data-user-id="143798">Talchas</span> just say the opposite about <code>restrict</code>?</p>
</blockquote>
<p>not sure what he said but the C restrict definition is so bogus and informal that it's not really worth discussing here IMO.^^</p>



<a name="277318615"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277318615" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277318615">(Mar 31 2022 at 18:03)</a>:</h4>
<p>Yeah, LLVM had to introduce the concept of optimizer only metadata to prevent <code>restrict</code> from being <code>consume</code> and standard optimizations just killing any uses of <code>restrict</code>.  This nebulous concept of <code>nondeterminism</code> also killed <code>PNVI-plain</code> from what I seen fwiw.</p>



<a name="277318625"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277318625" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277318625">(Mar 31 2022 at 18:03)</a>:</h4>
<p>any actual proposal for making <code>restrict</code> precise that I can even <em>imagine</em> needs provenance</p>



<a name="277318678"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277318678" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277318678">(Mar 31 2022 at 18:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="303115">Quy Nguyen</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance/near/277318615">said</a>:</p>
<blockquote>
<p>This nebulous concept of <code>nondeterminism</code> also killed <code>PNVI-plain</code> from what I seen fwiw.</p>
</blockquote>
<p>Yes it did. except there is nothing at all nebulous about it, it's an entirely standard concept and widely used.</p>



<a name="277318753"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277318753" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277318753">(Mar 31 2022 at 18:04)</a>:</h4>
<p>yeah, the C spec absolutely is a nondeterminism-based definition of restrict, but it's a moderately formal definition in english, not math, and who knows how well followed it is in implementations</p>



<a name="277318765"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277318765" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277318765">(Mar 31 2022 at 18:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="143798">Talchas</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance/near/277318753">said</a>:</p>
<blockquote>
<p>yeah, the C spec absolutely is a nondeterminism-based definition of restrict, but it's a moderately formal definition in english, not math, and who knows how well followed it is in implementations</p>
</blockquote>
<p>no its not at all</p>



<a name="277318786"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277318786" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277318786">(Mar 31 2022 at 18:04)</a>:</h4>
<p>it's an <em>information flow</em> based definition of restrict</p>



<a name="277318806"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277318806" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277318806">(Mar 31 2022 at 18:04)</a>:</h4>
<p>but (non-)determinism isnt even remotely related</p>



<a name="277319139"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277319139" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277319139">(Mar 31 2022 at 18:07)</a>:</h4>
<p>ehh, that's true but as far as non-formal descriptions go they're really really obviously equivalent? Formalizing them mathematically might be significantly different, but at the level of formality of the C spec it's at least close enough</p>



<a name="277319222"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277319222" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277319222">(Mar 31 2022 at 18:08)</a>:</h4>
<p>non-determinism in a language spec literally just means "this operation could do X or Y". like, the easiest primitive for this is a <code>nondet_bool() -&gt; bool</code> kind of operation that returns <code>true</code> or <code>false</code>. it's a bit like a random coin flip <em>but without the probabilities</em>, meaning that even if you call it many many times there is no "distribution" or anything like that that would make some observations "less likely" than others.</p>



<a name="277319239"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277319239" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277319239">(Mar 31 2022 at 18:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="143798">Talchas</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance/near/277319139">said</a>:</p>
<blockquote>
<p>ehh, that's true but as far as non-formal descriptions go they're really really obviously equivalent? Formalizing them mathematically might be significantly different, but at the level of formality of the C spec it's at least close enough</p>
</blockquote>
<p>I... honestly dont see how they are even <em>related</em>, let alone "equivalent"</p>



<a name="277319380"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277319380" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277319380">(Mar 31 2022 at 18:09)</a>:</h4>
<p>Because defining something based on change propagation is equivalent to something like <code>input = input ^ nondet()</code>?</p>



<a name="277319759"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277319759" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277319759">(Mar 31 2022 at 18:12)</a>:</h4>
<p>such a <code>nondet_bool</code> has the following properties:</p>
<ul>
<li>as a programmer, my code needs to be correct no matter which value it returns</li>
<li>the compiler (or any other part of the implementation) is allowed to <em>choose</em> a particular boolean independently for each call to this primitive. so, an optimization might look at <code>if nondet_bool() { ... } else { ... }</code> and look at the two branches, guess which one is 'cheaper', and then just replace <code>nondet_bool()</code> by <code>true</code> or <code>false</code> accordingly.</li>
</ul>
<p>non-determinism is also sometimes used to model the outside world. like, <code>nondet_bool</code> might read a line from stdin and somehow turn that into a bool. that is the aspect <span class="user-mention" data-user-id="119009">@eddyb</span> was confused about. for a programmer that is the same (you need to be correct no matter which value it returns). for a compiler this is very different though; the outside world is "external" non-determinism that the compiler doesnt get to mess with; I am talking about nondet that is <em>internal</em> to the abstract machine so the compiler gets to mess with it.</p>



<a name="277319842"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277319842" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277319842">(Mar 31 2022 at 18:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="143798">Talchas</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance/near/277319380">said</a>:</p>
<blockquote>
<p>Because defining something based on change propagation is equivalent to something like <code>input = input ^ nondet()</code>?</p>
</blockquote>
<p>eh, what? <code>input = input ^ nondet()</code> is equivalent to <code>input = nondet()</code> but, uh, what does that have to do with anything, let alone information flow?</p>



<a name="277320002"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277320002" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277320002">(Mar 31 2022 at 18:15)</a>:</h4>
<p>in particular, if the compiler sees <code>if nondet() { deref NULL ptr }</code> it is totally allowed to choose the <code>then</code> branch and therefore "choose UB". that is just an instance of what I said above, and it is the foundation for optimizations based on non-determinism.</p>



<a name="277320098"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277320098" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277320098">(Mar 31 2022 at 18:16)</a>:</h4>
<p>If there's a way to observe the <code>nondet()</code> return, you could make it do the right thing no matter what it does.</p>



<a name="277320149"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277320149" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277320149">(Mar 31 2022 at 18:16)</a>:</h4>
<div class="codehilite" data-code-language="C"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">array</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nondet</span><span class="p">();</span><span class="w"></span>
<span class="n">array</span><span class="p">[</span><span class="n">val</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="n">array</span><span class="p">[</span><span class="n">val</span><span class="p">]);</span><span class="w"></span>
</code></pre></div>



<a name="277320176"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277320176" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277320176">(Mar 31 2022 at 18:17)</a>:</h4>
<p>The compiler can't magically make that have UB.</p>



<a name="277320197"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277320197" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277320197">(Mar 31 2022 at 18:17)</a>:</h4>
<p>(yeah that's the thing that <span class="user-mention" data-user-id="120791">@RalfJ</span> doesn't want me to call "provenance", but which obeys parametric reasoning)</p>



<a name="277320560"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277320560" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277320560">(Mar 31 2022 at 18:20)</a>:</h4>
<p>(lol that example is annoying to rewrite into Rust)</p>



<a name="277320768"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277320768" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277320768">(Mar 31 2022 at 18:22)</a>:</h4>
<div class="codehilite" data-code-language="C++"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">array</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">zero</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nondet_fork</span><span class="p">([](</span><span class="kt">bool</span><span class="w"> </span><span class="n">which</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">array</span><span class="p">[</span><span class="n">which</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">array</span><span class="p">[</span><span class="n">which</span><span class="p">];</span><span class="w"></span>
<span class="p">});</span><span class="w"></span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="w"> </span><span class="n">zero</span><span class="p">);</span><span class="w"></span>
</code></pre></div>



<a name="277320816"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277320816" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277320816">(Mar 31 2022 at 18:22)</a>:</h4>
<p>Isn't the issue with UB <code>nondet()</code> that the compiler could choose <code>val = super_large_number</code>, see that that is larger than 2, and delete everything because it has UB?</p>



<a name="277320838"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277320838" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277320838">(Mar 31 2022 at 18:22)</a>:</h4>
<p>that should be a <code>bool</code></p>



<a name="277320978"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277320978" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Talchas <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277320978">(Mar 31 2022 at 18:24)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance/near/277319842">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="143798">Talchas</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance/near/277319380">said</a>:</p>
<blockquote>
<p>Because defining something based on change propagation is equivalent to something like <code>input = input ^ nondet()</code>?</p>
</blockquote>
<p>eh, what? <code>input = input ^ nondet()</code> is equivalent to <code>input = nondet()</code> but, uh, what does that have to do with anything, let alone information flow?</p>
</blockquote>
<p>Now the nondet worlds branch based on the flow of information from input, and the variables that depend on input`` is precisely the values that differ between worlrds. (Now this is probably a more generous model than anyone would like to use, but it is the one C wrote down for restrict)</p>



<a name="277321264"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277321264" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277321264">(Mar 31 2022 at 18:26)</a>:</h4>
<p>further iterating (though I am getting uncomfortably far from the Abstract Machine I would assume):</p>
<div class="codehilite" data-code-language="C++"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">array</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">zero</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nondet_merge</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="p">[]()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="p">},</span><span class="w"></span>
<span class="w">    </span><span class="p">[]()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">array</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="p">},</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="w"> </span><span class="n">zero</span><span class="p">);</span><span class="w"></span>
</code></pre></div>
<p>which an optimizer could gladly rewrite into:</p>
<div class="codehilite" data-code-language="C++"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">array</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span><span class="w"></span>
<span class="n">nondet_merge</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="p">[]()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">    </span><span class="p">[]()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
</code></pre></div>
<p>i.e.:</p>
<div class="codehilite" data-code-language="C++"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">array</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span><span class="w"></span>
<span class="n">array</span><span class="p">[</span><span class="n">nondet_bool</span><span class="p">()]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
</code></pre></div>
<p>the write to the <code>array</code>, and the <code>array</code> itself, are dead now</p>
<p>but you could imagine trying to read either specific slot: the result would be <code>NonDetSet {undef, 0}</code> and the compiler would gladly pick <code>undef</code> over <code>0</code></p>



<a name="277321778"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277321778" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277321778">(Mar 31 2022 at 18:30)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance/near/277320176">said</a>:</p>
<blockquote>
<p>The compiler can't magically make that have UB.</p>
</blockquote>
<p>absolutely. nothing I said disagrees with that statement, does it?</p>



<a name="277321823"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277321823" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277321823">(Mar 31 2022 at 18:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="119009">eddyb</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance/near/277320197">said</a>:</p>
<blockquote>
<p>(yeah that's the thing that <span class="user-mention silent" data-user-id="120791">RalfJ</span> doesn't want me to call "provenance", but which obeys parametric reasoning)</p>
</blockquote>
<p>I... what? I have no idea what you mean^^</p>



<a name="277321938"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277321938" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277321938">(Mar 31 2022 at 18:32)</a>:</h4>
<p><span class="user-mention silent" data-user-id="143798">Talchas</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance/near/277320978">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance/near/277319842">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="143798">Talchas</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance/near/277319380">said</a>:</p>
<blockquote>
<p>Because defining something based on change propagation is equivalent to something like <code>input = input ^ nondet()</code>?</p>
</blockquote>
<p>eh, what? <code>input = input ^ nondet()</code> is equivalent to <code>input = nondet()</code> but, uh, what does that have to do with anything, let alone information flow?</p>
</blockquote>
<p>Now the nondet worlds branch based on the flow of information from input, and the variables that depend on input`` is precisely the values that differ between worlrds. (Now this is probably a more generous model than anyone would like to use, but it is the one C wrote down for restrict)</p>
</blockquote>
<p>I mean... nondet values are values and hence you can look at their information flow.<br>
that's basically what you just said. but it doesn't mean the concepts of information flow and nondet are related, other than both existing inside a programming language.</p>



<a name="277321971"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277321971" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eddyb <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277321971">(Mar 31 2022 at 18:32)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance/near/277321823">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="119009">eddyb</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance/near/277320197">said</a>:</p>
<blockquote>
<p>(yeah that's the thing that <span class="user-mention silent" data-user-id="120791">RalfJ</span> doesn't want me to call "provenance", but which obeys parametric reasoning)</p>
</blockquote>
<p>I... what? I have no idea what you mean^^</p>
</blockquote>
<p>(as in, I would gladly say that <code>val</code> in that example has "non-det provenance" or something. though at this point I doubt I could convince anyone anyway lol)</p>



<a name="277322028"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277322028" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277322028">(Mar 31 2022 at 18:33)</a>:</h4>
<p><span class="user-mention" data-user-id="143798">@Talchas</span> in particular information flow as a concept makes sense without nondet. and so there is no reason whatsoever to bring up nondet when discussing the C 'spec' of <code>restrict</code></p>



<a name="277322339"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277322339" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277322339">(Mar 31 2022 at 18:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="119009">eddyb</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance/near/277321971">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance/near/277321823">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="119009">eddyb</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance/near/277320197">said</a>:</p>
<blockquote>
<p>(yeah that's the thing that <span class="user-mention silent" data-user-id="120791">RalfJ</span> doesn't want me to call "provenance", but which obeys parametric reasoning)</p>
</blockquote>
<p>I... what? I have no idea what you mean^^</p>
</blockquote>
<p>(as in, I would gladly say that <code>val</code> in that example has "non-det provenance" or something. though at this point I doubt I could convince anyone anyway lol)</p>
</blockquote>
<p>I mean I cant stop you from making up words and using them however you please. ;)<br>
but the thing you call provenance here is an <em>emergent analysis artifact</em>. it is not normative, and has no effect whatsoever on the Abstract Machine, Miri, the spec. it need not be mentioned in the docs and programmers never have to think of it. it is literally impossible for a program to have UB "because you forgot to account for provenance". all UB can be entirely explained by thinking of pointers as integers without any fluff. do we agree on that?<br>
that makes it <em>very different</em> from the kind of provenance that we have been discussing for the last week here. <em>that</em> provenance is normative, has an effect, exists in the abstract machine and miri. programmers need to be aware of it because it is needed to explain whether their code has UB or not.</p>



<a name="277408452"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277408452" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277408452">(Apr 01 2022 at 12:22)</a>:</h4>
<p>Although it's not really "provenance" in the usual sense, I think that this "nondet provenance" is something special in the machine, not because it's a new kind of value but because of <code>nondet_merge</code>. After reading that long C discussion you linked <span class="user-mention" data-user-id="120791">@RalfJ</span> I would say the same is true about the twinsem model. The relevant feature that acts like provenance here is that the AM is affected by other worlds (this is the "double slit" analogy I think <span class="user-mention" data-user-id="119009">@eddyb</span> was making): being UB on any world means that you are also UB in the current world (where "world" here means "global choice of all nondeterminism"). You say that this is bog-standard stuff but the alternative reading, where UB is only UB in that world, is also quite reasonable and is a lot less mystical. I dare say it's one of the things that makes C UB so hard to come to terms with.</p>



<a name="277409726"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277409726" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277409726">(Apr 01 2022 at 12:32)</a>:</h4>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nondet_bool</span><span class="p">();</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bool_from_stdin</span><span class="p">();</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">unreachable_unchecked</span><span class="p">()</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>This has got me thinking about nondeterminism as a two player game. The compiler's goal is to find UB and the environment's goal is to avoid UB. The compiler gets to delete your code if it has a winning strategy. I'm not really sure who wins this one...</p>



<a name="277419155"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277419155" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277419155">(Apr 01 2022 at 13:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="271719">Mario Carneiro</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance/near/277408452">said</a>:</p>
<blockquote>
<p>Although it's not really "provenance" in the usual sense, I think that this "nondet provenance" is something special in the machine, not because it's a new kind of value but because of <code>nondet_merge</code>. After reading that long C discussion you linked <span class="user-mention silent" data-user-id="120791">RalfJ</span> I would say the same is true about the twinsem model. The relevant feature that acts like provenance here is that the AM is affected by other worlds (this is the "double slit" analogy I think <span class="user-mention silent" data-user-id="119009">eddyb</span> was making): being UB on any world means that you are also UB in the current world (where "world" here means "global choice of all nondeterminism"). You say that this is bog-standard stuff but the alternative reading, where UB is only UB in that world, is also quite reasonable and is a lot less mystical. I dare say it's one of the things that makes C UB so hard to come to terms with.</p>
</blockquote>
<p>nonono, there is no "one world affecting the other" and no quantum double slit stuff going on</p>



<a name="277419275"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277419275" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277419275">(Apr 01 2022 at 13:40)</a>:</h4>
<p>literally the only thing that happens in by UB example is what I said above: the compiler is allowed to <em>refine</em> non-determinism by restricting the set of possible choices (including restricting it down to one)</p>



<a name="277419327"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277419327" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277419327">(Apr 01 2022 at 13:40)</a>:</h4>
<blockquote>
<p>The relevant feature that acts like provenance here is that the AM is affected by other worlds</p>
</blockquote>
<p>That's just not a thing</p>



<a name="277419349"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277419349" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277419349">(Apr 01 2022 at 13:41)</a>:</h4>
<p>if it helps, <code>nondet_bool()</code> is exactly the same as <code>freeze poison</code> on type <code>i1</code> in LLVM</p>



<a name="277419439"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277419439" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277419439">(Apr 01 2022 at 13:41)</a>:</h4>
<p>"UB is UB only in that world" is exactly what happens, but with nondet the compiler gets to 'steer' the program execution (to an extend) to pick a world that is favorable for it</p>



<a name="277419568"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277419568" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277419568">(Apr 01 2022 at 13:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="271719">Mario Carneiro</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance/near/277409726">said</a>:</p>
<blockquote>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nondet_bool</span><span class="p">();</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bool_from_stdin</span><span class="p">();</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">unreachable_unchecked</span><span class="p">()</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>This has got me thinking about nondeterminism as a two player game. The compiler's goal is to find UB and the environment's goal is to avoid UB. The compiler gets to delete your code if it has a winning strategy. I'm not really sure who wins this one...</p>
</blockquote>
<p>non-determinism 'commutes' so this is the same as first picking <code>y</code> and then picking <code>x</code>. the compiler thus gets to pick <code>x</code> to be equal to <code>y</code> and thus there is UB.</p>



<a name="277419638"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277419638" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277419638">(Apr 01 2022 at 13:43)</a>:</h4>
<p>I dont understand why so many smart people struggle so hard with (internal) non-determinism :(</p>



<a name="277419931"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277419931" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277419931">(Apr 01 2022 at 13:45)</a>:</h4>
<p>it's literally just: the allowable behaviors (set of traces) of <code>if nondet() { p1 } else { p2 }</code> is the <em>union</em> of the behaviors of <code>p1</code> and <code>p2</code>.<br>
UB is the set of <em>all</em> behaviors and hence if either <code>p1</code> or <code>p2</code> has UB, it directly follows that <code>if nondet() { p1 } else { p2 }</code> is UB (in the sense of being the set of all behaviors)</p>



<a name="277421730"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277421730" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277421730">(Apr 01 2022 at 13:56)</a>:</h4>
<p>So the part about that explanation that I don't understand is: if we consider the union of traces like you say, then in the case <code>x = false</code> there is a UB avoiding strategy <code>y = true</code> (a trace "user picks true" if you will) with no UB, and in the case <code>x = true</code> there is a UB avoiding strategy <code>y = false</code>, so the union of these is that there are two possible traces "user picks true" and "user picks false" and no UB to be found</p>



<a name="277428372"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277428372" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277428372">(Apr 01 2022 at 14:42)</a>:</h4>
<p>Input for determining an execution in C++ at least basically acts as though all input was provided before the program began executing. Thus the implementation could in <code>nondet_bool</code> lookahead to <code>bool_from_stdin</code>, read it, see that <code>y</code> will equal <code>false</code>, and pick <code>x=false</code>, or that <code>y</code> will equal <code>true</code>, and pick <code>x=true</code>.</p>



<a name="277428724"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277428724" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277428724">(Apr 01 2022 at 14:45)</a>:</h4>
<p>The way C++ does this is by this paragraph from <code>[intro.abstract]</code> (<a href="https://eel.is/c++draft/intro.abstract#5">https://eel.is/c++draft/intro.abstract#5</a>)</p>
<blockquote>
<p>A conforming implementation executing a well-formed program shall produce the same observable behavior as one of the possible executions of the corresponding instance of the abstract machine with the same program and the same input. However, if any such execution contains an undefined operation, this document places no requirement on the implementation executing that program with that input (not even with regard to operations preceding the first undefined operation).</p>
</blockquote>
<p>The "executions" here are <code>x = false</code> and <code>x = true</code>. And because for each possible input, at least one execution contains an undefined operation, clause 5 exempts the impl from the as-if rule in clause 1.</p>



<a name="277439586"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277439586" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277439586">(Apr 01 2022 at 15:58)</a>:</h4>
<p>Hm, that doesn't sound like it takes temporal dependencies into account. What if there is a <code>println!("{}", x);</code> before the <code>let y</code> line? In that case the user clearly has a UB-avoiding strategy, but it's not clear how you can even hold the input fixed and vary the nondeterminism since this leads to different IO calls.</p>



<a name="277445910"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277445910" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277445910">(Apr 01 2022 at 16:42)</a>:</h4>
<p>That is handled under clause 6 if both stdin and stdout are "interactive terminal devices".</p>



<a name="277530579"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277530579" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277530579">(Apr 02 2022 at 13:47)</a>:</h4>
<p><span class="user-mention silent" data-user-id="271719">Mario Carneiro</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance/near/277421730">said</a>:</p>
<blockquote>
<p>So the part about that explanation that I don't understand is: if we consider the union of traces like you say, then in the case <code>x = false</code> there is a UB avoiding strategy <code>y = true</code> (a trace "user picks true" if you will) with no UB, and in the case <code>x = true</code> there is a UB avoiding strategy <code>y = false</code>, so the union of these is that there are two possible traces "user picks true" and "user picks false" and no UB to be found</p>
</blockquote>
<p>that argument would work if you would print <code>x</code> to stdout before calling <code>bool_from_stdin</code>. but you didnt give the user any chance to observe <code>x</code> so the compiler may exploit that it is unobserved.</p>



<a name="277530750"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory%20optimizations%20without%20provenance/near/277530750" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/136281-t-lang/wg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance.html#277530750">(Apr 02 2022 at 13:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="271719">Mario Carneiro</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Memory.20optimizations.20without.20provenance/near/277439586">said</a>:</p>
<blockquote>
<p>Hm, that doesn't sound like it takes temporal dependencies into account.</p>
</blockquote>
<p>I like to think of not fixing all input before execution, but fixing <em>a strategy</em> that the 'outside world' uses. so, if the program does inputs and outputs, then the 'strategy' defines all possible reactions of the outside world, which may depend on prior program outputs.<br>
but in your original program, there is no UB-avoiding strategy for the outside world -- every strategy has UB for some possible non-deterministic choice. that's why the program still has UB for all strategies.<br>
(FWIW, if a program has UB for some strategy and is fine for other strategies, the compiler still has to ensure correct compilation for those strategies where the program is fine. but your program does not have any fine strategy.)</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>