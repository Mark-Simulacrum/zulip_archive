<html>
<head><meta charset="utf-8"><title>Is `unwind` any kind of abnormal exit? · project-ffi-unwind · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/210922-project-ffi-unwind/index.html">project-ffi-unwind</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/210922-project-ffi-unwind/topic/Is.20.60unwind.60.20any.20kind.20of.20abnormal.20exit.3F.html">Is `unwind` any kind of abnormal exit?</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="254832129"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/210922-project-ffi-unwind/topic/Is%20%60unwind%60%20any%20kind%20of%20abnormal%20exit%3F/near/254832129" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nagisa <a href="https://zulip-archive.rust-lang.org/stream/210922-project-ffi-unwind/topic/Is.20.60unwind.60.20any.20kind.20of.20abnormal.20exit.3F.html#254832129">(Sep 25 2021 at 11:32)</a>:</h4>
<p>For the purposes of this project and all of its outputs, are all kinds of abnormal exits (<code>unwind</code>, <code>longjmp</code>, "signal handler manually fiddles with program counter and stack pointer", "kernel manually fiddles with program counter and stack pointer" ...) considered an "unwind"? Most interesting to me is MSVC which implements longjmp as an unwind but GNU does not. Do we consider longjmp an unwind everywhere? nowhere? only on msvc?</p>



<a name="254832144"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/210922-project-ffi-unwind/topic/Is%20%60unwind%60%20any%20kind%20of%20abnormal%20exit%3F/near/254832144" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nagisa <a href="https://zulip-archive.rust-lang.org/stream/210922-project-ffi-unwind/topic/Is.20.60unwind.60.20any.20kind.20of.20abnormal.20exit.3F.html#254832144">(Sep 25 2021 at 11:33)</a>:</h4>
<p>cc <span class="user-mention" data-user-id="133224">@Nikita Popov</span></p>



<a name="254832535"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/210922-project-ffi-unwind/topic/Is%20%60unwind%60%20any%20kind%20of%20abnormal%20exit%3F/near/254832535" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/210922-project-ffi-unwind/topic/Is.20.60unwind.60.20any.20kind.20of.20abnormal.20exit.3F.html#254832535">(Sep 25 2021 at 11:39)</a>:</h4>
<p>setjmp/longjmp is declared UB in rust when jumping over frames with destructors according to the RFC. It doesn't matter if it is internally implemented as unwinding (windows) or register restore (unix).</p>



<a name="254832988"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/210922-project-ffi-unwind/topic/Is%20%60unwind%60%20any%20kind%20of%20abnormal%20exit%3F/near/254832988" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nagisa <a href="https://zulip-archive.rust-lang.org/stream/210922-project-ffi-unwind/topic/Is.20.60unwind.60.20any.20kind.20of.20abnormal.20exit.3F.html#254832988">(Sep 25 2021 at 11:46)</a>:</h4>
<p>In our case of interest are the abort-on-unwind drops. Do we think it is always UB to longjmp out of drop glue?</p>



<a name="254833028"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/210922-project-ffi-unwind/topic/Is%20%60unwind%60%20any%20kind%20of%20abnormal%20exit%3F/near/254833028" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nagisa <a href="https://zulip-archive.rust-lang.org/stream/210922-project-ffi-unwind/topic/Is.20.60unwind.60.20any.20kind.20of.20abnormal.20exit.3F.html#254833028">(Sep 25 2021 at 11:47)</a>:</h4>
<p>Relatedly, what about longjmping _into_ a frame with destructors, not over it?</p>



<a name="254833744"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/210922-project-ffi-unwind/topic/Is%20%60unwind%60%20any%20kind%20of%20abnormal%20exit%3F/near/254833744" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/210922-project-ffi-unwind/topic/Is.20.60unwind.60.20any.20kind.20of.20abnormal.20exit.3F.html#254833744">(Sep 25 2021 at 11:59)</a>:</h4>
<p>You can't longjmp into a function call. You can only go up to callees, not down to previously returned functions as the stack has been clobbered.</p>



<a name="254836514"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/210922-project-ffi-unwind/topic/Is%20%60unwind%60%20any%20kind%20of%20abnormal%20exit%3F/near/254836514" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nagisa <a href="https://zulip-archive.rust-lang.org/stream/210922-project-ffi-unwind/topic/Is.20.60unwind.60.20any.20kind.20of.20abnormal.20exit.3F.html#254836514">(Sep 25 2021 at 12:40)</a>:</h4>
<p>I don't think jumping into a function call is happening in what I'm asking about? More specifically I'm talking about a case like </p>
<div class="codehilite"><pre><span></span><code>struct LongJmp; impl Drop for LongJmp { fn drop(&amp;self) { longjmp() } }

fn has_destructors() {
     setjmp();
     drop(LongJmp); // jumps out of drop into a frame with destructors (but not over)
}
</code></pre></div>
<p>if that makes sense?</p>



<a name="254836521"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/210922-project-ffi-unwind/topic/Is%20%60unwind%60%20any%20kind%20of%20abnormal%20exit%3F/near/254836521" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nagisa <a href="https://zulip-archive.rust-lang.org/stream/210922-project-ffi-unwind/topic/Is.20.60unwind.60.20any.20kind.20of.20abnormal.20exit.3F.html#254836521">(Sep 25 2021 at 12:40)</a>:</h4>
<p>or whatever equivalents.</p>



<a name="254836940"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/210922-project-ffi-unwind/topic/Is%20%60unwind%60%20any%20kind%20of%20abnormal%20exit%3F/near/254836940" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/210922-project-ffi-unwind/topic/Is.20.60unwind.60.20any.20kind.20of.20abnormal.20exit.3F.html#254836940">(Sep 25 2021 at 12:47)</a>:</h4>
<p>I see. Not sure.</p>



<a name="254837405"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/210922-project-ffi-unwind/topic/Is%20%60unwind%60%20any%20kind%20of%20abnormal%20exit%3F/near/254837405" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/210922-project-ffi-unwind/topic/Is.20.60unwind.60.20any.20kind.20of.20abnormal.20exit.3F.html#254837405">(Sep 25 2021 at 12:54)</a>:</h4>
<p>In C++ that's not undefined behaviour, only jumping over. I'd assume the same for Rust, tbh.</p>



<a name="254837462"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/210922-project-ffi-unwind/topic/Is%20%60unwind%60%20any%20kind%20of%20abnormal%20exit%3F/near/254837462" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/210922-project-ffi-unwind/topic/Is.20.60unwind.60.20any.20kind.20of.20abnormal.20exit.3F.html#254837462">(Sep 25 2021 at 12:56)</a>:</h4>
<p>Although it would require rust exposing setjmp, since it's not a function and you can't grab it with FFI.</p>



<a name="254837702"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/210922-project-ffi-unwind/topic/Is%20%60unwind%60%20any%20kind%20of%20abnormal%20exit%3F/near/254837702" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/210922-project-ffi-unwind/topic/Is.20.60unwind.60.20any.20kind.20of.20abnormal.20exit.3F.html#254837702">(Sep 25 2021 at 12:59)</a>:</h4>
<p>(And if you tried to do a wrapper function, it would have to be of the form of a with_setjmp that takes a closure, since once you've returned from a function, it's UB to longjmp back into it)</p>



<a name="254839917"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/210922-project-ffi-unwind/topic/Is%20%60unwind%60%20any%20kind%20of%20abnormal%20exit%3F/near/254839917" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nagisa <a href="https://zulip-archive.rust-lang.org/stream/210922-project-ffi-unwind/topic/Is.20.60unwind.60.20any.20kind.20of.20abnormal.20exit.3F.html#254839917">(Sep 25 2021 at 13:30)</a>:</h4>
<p>Does C++ still allow unwinding from their destructors? Or are they nounwind?</p>



<a name="254839963"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/210922-project-ffi-unwind/topic/Is%20%60unwind%60%20any%20kind%20of%20abnormal%20exit%3F/near/254839963" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nagisa <a href="https://zulip-archive.rust-lang.org/stream/210922-project-ffi-unwind/topic/Is.20.60unwind.60.20any.20kind.20of.20abnormal.20exit.3F.html#254839963">(Sep 25 2021 at 13:31)</a>:</h4>
<p>And if it doesn't why does that work on msvc then?</p>



<a name="254840343"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/210922-project-ffi-unwind/topic/Is%20%60unwind%60%20any%20kind%20of%20abnormal%20exit%3F/near/254840343" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/210922-project-ffi-unwind/topic/Is.20.60unwind.60.20any.20kind.20of.20abnormal.20exit.3F.html#254840343">(Sep 25 2021 at 13:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="123586">nagisa</span> <a href="#narrow/stream/210922-project-ffi-unwind/topic/Is.20.60unwind.60.20any.20kind.20of.20abnormal.20exit.3F/near/254839917">said</a>:</p>
<blockquote>
<p>Does C++ still allow unwinding from their destructors? Or are they nounwind?</p>
</blockquote>
<p>C++ doesn't treat unwinds from longjmp the same as exceptions, but yes to both. However, most destructors are <code>noexcept</code> (which terminates if they exit via an exception), and exiting a destructor called as a result of stack unwinding via an exception also terminates.</p>



<a name="254840529"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/210922-project-ffi-unwind/topic/Is%20%60unwind%60%20any%20kind%20of%20abnormal%20exit%3F/near/254840529" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/210922-project-ffi-unwind/topic/Is.20.60unwind.60.20any.20kind.20of.20abnormal.20exit.3F.html#254840529">(Sep 25 2021 at 13:39)</a>:</h4>
<p><a href="http://eel.is/c++draft/csetjmp.syn#2">http://eel.is/c++draft/csetjmp.syn#2</a></p>
<blockquote>
<p>The function signature longjmp(jmp_­buf jbuf, int val) has more restricted behavior in this document. A setjmp/longjmp call pair has undefined behavior if replacing the setjmp and longjmp by catch and throw would invoke any non-trivial destructors for any objects with automatic storage duration. A call to setjmp or longjmp has undefined behavior if invoked in a suspension context of a coroutine ([expr.await]).</p>
</blockquote>



<a name="254840689"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/210922-project-ffi-unwind/topic/Is%20%60unwind%60%20any%20kind%20of%20abnormal%20exit%3F/near/254840689" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/210922-project-ffi-unwind/topic/Is.20.60unwind.60.20any.20kind.20of.20abnormal.20exit.3F.html#254840689">(Sep 25 2021 at 13:40)</a>:</h4>
<p>Nothing about <code>longjmp</code>ing out of destructors, so it falls back to the definition in C.</p>



<a name="254840987"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/210922-project-ffi-unwind/topic/Is%20%60unwind%60%20any%20kind%20of%20abnormal%20exit%3F/near/254840987" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nagisa <a href="https://zulip-archive.rust-lang.org/stream/210922-project-ffi-unwind/topic/Is.20.60unwind.60.20any.20kind.20of.20abnormal.20exit.3F.html#254840987">(Sep 25 2021 at 13:45)</a>:</h4>
<p>Hm, this still doesn't directly say if in C++ setjmp/longjmp are considered to be a form of unwinding (though if I had to hazard a guess, unwinding is an implementation detail in the eyes of the C++ standard and not something that needs to be specified? there's only two references to unwinding and neither a specification of what it is.</p>



<a name="254841263"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/210922-project-ffi-unwind/topic/Is%20%60unwind%60%20any%20kind%20of%20abnormal%20exit%3F/near/254841263" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nagisa <a href="https://zulip-archive.rust-lang.org/stream/210922-project-ffi-unwind/topic/Is.20.60unwind.60.20any.20kind.20of.20abnormal.20exit.3F.html#254841263">(Sep 25 2021 at 13:48)</a>:</h4>
<p>Here's another example</p>
<div class="codehilite"><pre><span></span><code>struct LongJmp; impl Drop for LongJmp { fn drop(&amp;self) { longjmp() } }
struct Boom; impl Drop for Boom { fn drop(&amp;self) { abort() } }

fn has_destructors() {
     setjmp();
     let boom = Boom;
     let guard = LongJmp;
     // cleanups here jumps out of drop into a frame with destructors (but not over)
}
</code></pre></div>
<p>As per C++ specification this is UB because replacing the jumps with throw/catch would invoke a destructor for <code>Boom</code>, I believe.</p>



<a name="254841413"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/210922-project-ffi-unwind/topic/Is%20%60unwind%60%20any%20kind%20of%20abnormal%20exit%3F/near/254841413" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nagisa <a href="https://zulip-archive.rust-lang.org/stream/210922-project-ffi-unwind/topic/Is.20.60unwind.60.20any.20kind.20of.20abnormal.20exit.3F.html#254841413">(Sep 25 2021 at 13:51)</a>:</h4>
<p>This is something our POF-based definition doesn't capture.</p>



<a name="254841573"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/210922-project-ffi-unwind/topic/Is%20%60unwind%60%20any%20kind%20of%20abnormal%20exit%3F/near/254841573" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nagisa <a href="https://zulip-archive.rust-lang.org/stream/210922-project-ffi-unwind/topic/Is.20.60unwind.60.20any.20kind.20of.20abnormal.20exit.3F.html#254841573">(Sep 25 2021 at 13:53)</a>:</h4>
<p>and for <code>-Zpanic-in-drop=abort</code> even the first example UB would be UB as per Rust definition AFAICT, for implementing abort-on-panic involves adding an equivalent of <code>catch_unwind</code>, making drop glue be a non-POF as per <a href="https://github.com/rust-lang/rfcs/blob/master/text/2945-c-unwind-abi.md#plain-old-frames">https://github.com/rust-lang/rfcs/blob/master/text/2945-c-unwind-abi.md#plain-old-frames</a></p>



<a name="254841703"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/210922-project-ffi-unwind/topic/Is%20%60unwind%60%20any%20kind%20of%20abnormal%20exit%3F/near/254841703" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nagisa <a href="https://zulip-archive.rust-lang.org/stream/210922-project-ffi-unwind/topic/Is.20.60unwind.60.20any.20kind.20of.20abnormal.20exit.3F.html#254841703">(Sep 25 2021 at 13:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/210922-project-ffi-unwind/topic/Is.20.60unwind.60.20any.20kind.20of.20abnormal.20exit.3F/near/254840343">said</a>:</p>
<blockquote>
<p>a destructor called as a result of stack unwinding via an exception also terminates.</p>
</blockquote>
<p>Isn't that like double-panic in Rust? This is reasonable and understandable behaviour.</p>



<a name="254841780"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/210922-project-ffi-unwind/topic/Is%20%60unwind%60%20any%20kind%20of%20abnormal%20exit%3F/near/254841780" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nagisa <a href="https://zulip-archive.rust-lang.org/stream/210922-project-ffi-unwind/topic/Is.20.60unwind.60.20any.20kind.20of.20abnormal.20exit.3F.html#254841780">(Sep 25 2021 at 13:56)</a>:</h4>
<p><code>-Zpanic-in-drop=abort</code> restricts that kind of behaviour to any panic in drop/destructor being an abort (or <code>std::terminate()</code> in C++ parlance), even if not currently unwinding</p>



<a name="254842264"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/210922-project-ffi-unwind/topic/Is%20%60unwind%60%20any%20kind%20of%20abnormal%20exit%3F/near/254842264" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nagisa <a href="https://zulip-archive.rust-lang.org/stream/210922-project-ffi-unwind/topic/Is.20.60unwind.60.20any.20kind.20of.20abnormal.20exit.3F.html#254842264">(Sep 25 2021 at 14:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="123586">nagisa</span> <a href="#narrow/stream/210922-project-ffi-unwind/topic/Is.20.60unwind.60.20any.20kind.20of.20abnormal.20exit.3F/near/254841413">said</a>:</p>
<blockquote>
<p>This is something our POF-based definition doesn't capture.</p>
</blockquote>
<p>And we cannot really use the C++-like definition either because of <code>-Cpanic=abort</code>…</p>



<a name="254860427"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/210922-project-ffi-unwind/topic/Is%20%60unwind%60%20any%20kind%20of%20abnormal%20exit%3F/near/254860427" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> BatmanAoD (Kyle Strand) <a href="https://zulip-archive.rust-lang.org/stream/210922-project-ffi-unwind/topic/Is.20.60unwind.60.20any.20kind.20of.20abnormal.20exit.3F.html#254860427">(Sep 25 2021 at 18:34)</a>:</h4>
<p>So that everyone has a bit of context, here's the blog post announcing that this project group would be exploring <code>longjmp</code>: <a href="https://blog.rust-lang.org/inside-rust/2021/01/26/ffi-unwind-longjmp.html">https://blog.rust-lang.org/inside-rust/2021/01/26/ffi-unwind-longjmp.html</a></p>
<p><span class="user-mention silent" data-user-id="123586">nagisa</span> <a href="#narrow/stream/210922-project-ffi-unwind/topic/Is.20.60unwind.60.20any.20kind.20of.20abnormal.20exit.3F/near/254832129">said</a>:</p>
<blockquote>
<p>For the purposes of this project and all of its outputs, are all kinds of abnormal exits... considered an "unwind"? ... Do we consider longjmp an unwind everywhere? nowhere? only on msvc?</p>
</blockquote>
<p>No, and nowhere. We did, however, <a href="https://github.com/rust-lang/project-ffi-unwind/pull/34">broaden our charter</a> to bring <code>longjmp</code> into our purview. Currently, all interactions between <code>longjmp</code> and Rust frames should be considered undefined, because they have not been specified in any way, but as <span class="user-mention" data-user-id="133247">@bjorn3</span> noted, RFC-2945 only makes <code>longjmp</code> over non-POF frames (which generally means frames with destructors) explicitly (and permanently) undefined.</p>
<p><span class="user-mention silent" data-user-id="123586">nagisa</span> <a href="#narrow/stream/210922-project-ffi-unwind/topic/Is.20.60unwind.60.20any.20kind.20of.20abnormal.20exit.3F/near/254832988">said</a>:</p>
<blockquote>
<p>In our case of interest are the abort-on-unwind drops. Do we think it is always UB to longjmp out of drop glue?</p>
</blockquote>
<p>I'm not sure what you mean here; <code>abort</code> will never call <code>drop</code>, abort-on-unwind should never trigger a <code>longjmp</code> even if you call <code>longjmp</code> in a <code>drop</code> function. But yes, I do expect that <code>longjmp</code> out of a <code>drop</code> function would be UB in the non-<code>abort</code> case.</p>
<p><span class="user-mention" data-user-id="257758">@Connor Horman</span> I'm not sure that <code>longjmp</code> inside a destructor would be well-defined in C++ either, actually. The fact that <code>throw</code>ing from a destructor causes the runtime to terminate doesn't seem to me to imply that the behavior of <code>longjmp</code> in the same context would "fall back to" that of the ISO C; I don't believe there's any such rule for interpreting the standard, since C++ has different semantics from C in quite a few places.</p>
<p>I've heard of several people in fact using <code>longjmp</code> in Rust; that's a large part of the motivation for exploring how to make that well-defined. I would assume that some kind of closure is indeed how <code>longjmp</code> is being invoked, but I haven't looked at actual code examples.</p>
<p><span class="user-mention silent" data-user-id="123586">nagisa</span> <a href="#narrow/stream/210922-project-ffi-unwind/topic/Is.20.60unwind.60.20any.20kind.20of.20abnormal.20exit.3F/near/254841413">said</a>:</p>
<blockquote>
<p>This is something our POF-based definition doesn't capture.</p>
</blockquote>
<p>Anything not captured by the POF definition should be treated with extreme caution. As I said above, even a simple <code>longjmp</code> over POFs is still technically UB in Rust simply because there's no specification for it yet. Additionally, per the above blogpost, we are leaning toward restricting <code>longjmp</code> further by introducing a new annotation required to make the behavior well defined.</p>



<a name="254861300"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/210922-project-ffi-unwind/topic/Is%20%60unwind%60%20any%20kind%20of%20abnormal%20exit%3F/near/254861300" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/210922-project-ffi-unwind/topic/Is.20.60unwind.60.20any.20kind.20of.20abnormal.20exit.3F.html#254861300">(Sep 25 2021 at 18:49)</a>:</h4>
<blockquote>
<p>The fact that throwing from a destructor causes the runtime to terminate doesn't seem to me to imply that the behavior of longjmp in the same context would "fall back to" that of the ISO C; I don't believe there's any such rule for interpreting the standard, since C++ has different semantics from C in quite a few places.</p>
</blockquote>
<p>Functions defined by the C standard have the behaviour specified by cross-reference to ISO 9899:2018 (for ISO 14882:2020 and latest draft of the C++ standard), so except where the behaviour is altered by the C++ standard, it has the behaviour specified in the normative cross-reference.</p>



<a name="254861508"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/210922-project-ffi-unwind/topic/Is%20%60unwind%60%20any%20kind%20of%20abnormal%20exit%3F/near/254861508" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/210922-project-ffi-unwind/topic/Is.20.60unwind.60.20any.20kind.20of.20abnormal.20exit.3F.html#254861508">(Sep 25 2021 at 18:52)</a>:</h4>
<p>Side note: it's not throwing from a destructor that causes termination - it's specifically throwing during stack unwinding. <br>
This code will throw an exception, for example, rather than terminate:</p>
<div class="codehilite" data-code-language="C++"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">(){</span><span class="w"></span>
<span class="w">     </span><span class="k">struct</span> <span class="nc">S</span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="o">~</span><span class="n">S</span><span class="p">()</span><span class="w"> </span><span class="k">noexcept</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span><span class="w"> </span><span class="c1">// required as C++ specifies that destructors without an exception specification use the same one as the implicitly-declared version</span>
<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="w">             </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="p">{</span><span class="s">"Destroyed S"</span><span class="p">};</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="n">S</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w">    </span><span class="c1">// Exception is thrown here and unwinds the stack if caught. No std::terminate call, no undefined behaviour</span>
</code></pre></div>
<p>Same as how rust let's you panic!() from a drop impl, but only panicking during another panic aborts (although that's earlier than C++ - since it happens immediately at the second panic, rather than when unwinding out of the destructor).</p>



<a name="254861742"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/210922-project-ffi-unwind/topic/Is%20%60unwind%60%20any%20kind%20of%20abnormal%20exit%3F/near/254861742" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> BatmanAoD (Kyle Strand) <a href="https://zulip-archive.rust-lang.org/stream/210922-project-ffi-unwind/topic/Is.20.60unwind.60.20any.20kind.20of.20abnormal.20exit.3F.html#254861742">(Sep 25 2021 at 18:55)</a>:</h4>
<p>But C has no rules about what happens "during unwinding", so this behavior isn't defined there either.</p>



<a name="254861810"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/210922-project-ffi-unwind/topic/Is%20%60unwind%60%20any%20kind%20of%20abnormal%20exit%3F/near/254861810" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> BatmanAoD (Kyle Strand) <a href="https://zulip-archive.rust-lang.org/stream/210922-project-ffi-unwind/topic/Is.20.60unwind.60.20any.20kind.20of.20abnormal.20exit.3F.html#254861810">(Sep 25 2021 at 18:56)</a>:</h4>
<p>It's not even clear to me what the expected behavior would be.</p>



<a name="254861831"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/210922-project-ffi-unwind/topic/Is%20%60unwind%60%20any%20kind%20of%20abnormal%20exit%3F/near/254861831" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> BatmanAoD (Kyle Strand) <a href="https://zulip-archive.rust-lang.org/stream/210922-project-ffi-unwind/topic/Is.20.60unwind.60.20any.20kind.20of.20abnormal.20exit.3F.html#254861831">(Sep 25 2021 at 18:57)</a>:</h4>
<p>E.g. would unwinding stop at the <code>setjmp</code> or continue up the stack?</p>



<a name="254867058"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/210922-project-ffi-unwind/topic/Is%20%60unwind%60%20any%20kind%20of%20abnormal%20exit%3F/near/254867058" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nagisa <a href="https://zulip-archive.rust-lang.org/stream/210922-project-ffi-unwind/topic/Is.20.60unwind.60.20any.20kind.20of.20abnormal.20exit.3F.html#254867058">(Sep 25 2021 at 20:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120076">BatmanAoD (Kyle Strand)</span> <a href="#narrow/stream/210922-project-ffi-unwind/topic/Is.20.60unwind.60.20any.20kind.20of.20abnormal.20exit.3F/near/254860427">said</a>:</p>
<blockquote>
<p>...<br>
I'm not sure what you mean here; <code>abort</code> will never call <code>drop</code>, abort-on-unwind should never trigger a <code>longjmp</code> even if you call <code>longjmp</code> in a <code>drop</code> function. But yes, I do expect that <code>longjmp</code> out of a <code>drop</code> function would be UB in the non-<code>abort</code> case.<br>
...</p>
</blockquote>
<p>I mean <code>-Zpanic-in-drop=abort</code> here, sorry if I wasn't clear. Basically the expected behaviour with that flag enabled is that unwinding from a drop gets converted to an abort, regardless of what the program-wide <code>-Cpanic</code> setting is. Was wondering what is the behaviour we'd like to prescribe here for <code>longjmp</code>, but since we want to <em>never</em> consider longjmp to be an unwind, that question is moot.</p>



<a name="254868751"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/210922-project-ffi-unwind/topic/Is%20%60unwind%60%20any%20kind%20of%20abnormal%20exit%3F/near/254868751" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> BatmanAoD (Kyle Strand) <a href="https://zulip-archive.rust-lang.org/stream/210922-project-ffi-unwind/topic/Is.20.60unwind.60.20any.20kind.20of.20abnormal.20exit.3F.html#254868751">(Sep 25 2021 at 20:40)</a>:</h4>
<p>Well, unfortunately, we can't really prescribe a behavior other than "undefined" in a lot of <code>longjmp</code> cases, since a <code>longjmp</code> can occur pretty much anywhere. That's one major reason for wanting an annotation to limit where well-defined <code>longjmp</code> can happen, and leaving it UB everywhere else.</p>



<a name="254869988"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/210922-project-ffi-unwind/topic/Is%20%60unwind%60%20any%20kind%20of%20abnormal%20exit%3F/near/254869988" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nagisa <a href="https://zulip-archive.rust-lang.org/stream/210922-project-ffi-unwind/topic/Is.20.60unwind.60.20any.20kind.20of.20abnormal.20exit.3F.html#254869988">(Sep 25 2021 at 20:59)</a>:</h4>
<p>Yeah, thats fine. I was more worried about us having some definition here ^^ No definition is actually easier to work with today ^^</p>



<a name="254879485"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/210922-project-ffi-unwind/topic/Is%20%60unwind%60%20any%20kind%20of%20abnormal%20exit%3F/near/254879485" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/210922-project-ffi-unwind/topic/Is.20.60unwind.60.20any.20kind.20of.20abnormal.20exit.3F.html#254879485">(Sep 25 2021 at 23:36)</a>:</h4>
<p>So as I understand this, even if <code>longjmp</code> was permitted to touch Rust, since it can't go anywhere too exciting and has to use a normal entry point, it would basically be semantically equivalent to emitting a <code>call</code> opcode, just with an arbitrary selection of actual opcodes?</p>



<a name="254974879"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/210922-project-ffi-unwind/topic/Is%20%60unwind%60%20any%20kind%20of%20abnormal%20exit%3F/near/254974879" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> BatmanAoD (Kyle Strand) <a href="https://zulip-archive.rust-lang.org/stream/210922-project-ffi-unwind/topic/Is.20.60unwind.60.20any.20kind.20of.20abnormal.20exit.3F.html#254974879">(Sep 27 2021 at 00:29)</a>:</h4>
<p>I'm not sure I understand the question, possibly because I know hardly anything about the LLVM language and opcodes. What do you mean by "a normal entry point"? If the question is whether <code>longjmp</code> can be thought of as unwinding without landing pads, that's probably entirely true on Windows (where <code>forced_unwind</code> actually does just skip landing pads), and I don't see any immediate problems with that mental model for other OSes.</p>



<a name="256485093"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/210922-project-ffi-unwind/topic/Is%20%60unwind%60%20any%20kind%20of%20abnormal%20exit%3F/near/256485093" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/210922-project-ffi-unwind/topic/Is.20.60unwind.60.20any.20kind.20of.20abnormal.20exit.3F.html#256485093">(Oct 06 2021 at 21:08)</a>:</h4>
<p>The sense of "entry point" I meant is that it has to go to a block that would have already been "semantically addressable" within Rust. Like the start of a function is the canonical place you can "address", but yes, also initiating an unwinding procedure via <code>panic!</code>, or other join-points in control flow that you can reach via loops and breaks... in other words it can't do "jump into a random point in Rust control flow and thus potentially skip over meaningful steps", it would have to go to one of the existing join-points.</p>



<a name="256489283"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/210922-project-ffi-unwind/topic/Is%20%60unwind%60%20any%20kind%20of%20abnormal%20exit%3F/near/256489283" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> BatmanAoD (Kyle Strand) <a href="https://zulip-archive.rust-lang.org/stream/210922-project-ffi-unwind/topic/Is.20.60unwind.60.20any.20kind.20of.20abnormal.20exit.3F.html#256489283">(Oct 06 2021 at 21:41)</a>:</h4>
<p>I feel like I'm treading into dangerous waters attempting to answer this, but yes, I would expect that to be a standard limitation on <code>longjmp</code> regardless of the caller's language. <code>setjmp</code> must be called first, and <code>longjmp</code> can only go back to where <code>setjmp</code> was called.</p>



<a name="256496267"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/210922-project-ffi-unwind/topic/Is%20%60unwind%60%20any%20kind%20of%20abnormal%20exit%3F/near/256496267" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/210922-project-ffi-unwind/topic/Is.20.60unwind.60.20any.20kind.20of.20abnormal.20exit.3F.html#256496267">(Oct 06 2021 at 22:44)</a>:</h4>
<p>Cool cool. I will not take your words as gospel but rather am just trying to begin to form an intuition.</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>