<html>
<head><meta charset="utf-8"><title>refined trait impls · t-lang · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/index.html">t-lang</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/refined.20trait.20impls.html">refined trait impls</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="275871279"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/refined%20trait%20impls/near/275871279" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/refined.20trait.20impls.html#275871279">(Mar 18 2022 at 22:42)</a>:</h4>
<p>I have an RFC draft on refining trait interfaces in implementations: <a href="https://rust-lang.github.io/async-fundamentals-initiative/RFC/refined_impls.html">https://rust-lang.github.io/async-fundamentals-initiative/RFC/refined_impls.html</a></p>



<a name="275871288"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/refined%20trait%20impls/near/275871288" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/refined.20trait.20impls.html#275871288">(Mar 18 2022 at 22:42)</a>:</h4>
<p>feedback is welcome</p>



<a name="275871321"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/refined%20trait%20impls/near/275871321" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/refined.20trait.20impls.html#275871321">(Mar 18 2022 at 22:42)</a>:</h4>
<p>(cross posted from <a href="#narrow/stream/187312-wg-async/topic/refined.20trait.20impls">this stream in #wg-async</a>)</p>



<a name="275873962"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/refined%20trait%20impls/near/275873962" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/refined.20trait.20impls.html#275873962">(Mar 18 2022 at 23:18)</a>:</h4>
<p>Has syntax like the following that allows users to not repeat function signatures on trait impls ever been discussed for Rust (obviously bikesheddable)?</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">impl</span><span class="w"> </span><span class="n">TraitA</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">TypeB</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="o">..</span><span class="p">.)</span><span class="w"> </span>-&gt; <span class="nc">_</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// ...</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>Note that this does not increase the amount of inference, because the actual function signature can still be known from the trait and function name.</p>
<p>If this is still something that is on the table, then I think the interaction of these features should be considered, to make sure they're compatible in whatever form we envision them</p>



<a name="275877821"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/refined%20trait%20impls/near/275877821" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/refined.20trait.20impls.html#275877821">(Mar 19 2022 at 00:20)</a>:</h4>
<p>Good point <span class="user-mention" data-user-id="310518">@Jake</span>, it's not clear how that would interact with this proposal. I'm thinking the answer has to be that the <code>_</code> resolves to the concrete type for that feature to be useful.</p>



<a name="275877919"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/refined%20trait%20impls/near/275877919" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/refined.20trait.20impls.html#275877919">(Mar 19 2022 at 00:22)</a>:</h4>
<p>I guess one alternative is to use <code>-&gt; _</code> inside of trait impls as a shortcut to mean "whatever the trait says" and not do any inference. But then I don't think it should be allowed outside of trait impls.</p>



<a name="275877931"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/refined%20trait%20impls/near/275877931" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/refined.20trait.20impls.html#275877931">(Mar 19 2022 at 00:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="116883">tmandry</span> <a href="#narrow/stream/213817-t-lang/topic/refined.20trait.20impls/near/275877919">said</a>:</p>
<blockquote>
<p>I guess one alternative is to use <code>-&gt; _</code> inside of trait impls as a shortcut to mean "whatever the trait says" and not do any inference. But then I don't think it should be allowed outside of trait impls.</p>
</blockquote>
<p>Sorry, I should have been more clear. Yes, this is exactly what I'm suggesting the feature could look like</p>



<a name="275878005"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/refined%20trait%20impls/near/275878005" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/refined.20trait.20impls.html#275878005">(Mar 19 2022 at 00:24)</a>:</h4>
<p>Ah, after rereading your question it was clear, I was just pattern matching against another proposal I've seen to let <code>_</code> mean "inferred return type" (like <code>impl Trait</code> but without the opaqueness)</p>



<a name="275878049"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/refined%20trait%20impls/near/275878049" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/refined.20trait.20impls.html#275878049">(Mar 19 2022 at 00:25)</a>:</h4>
<p>Ah, I see. Yeah, the only problem that this feature would solve is that "trait method signatures are inherently unnecessary and occasionally annoying to write"</p>



<a name="275878110"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/refined%20trait%20impls/near/275878110" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/refined.20trait.20impls.html#275878110">(Mar 19 2022 at 00:26)</a>:</h4>
<p>My concern is specifically about how the where clauses would be chosen for the <code>(..) -&gt; _</code> case once more than one possible set of where clauses is allowed</p>



<a name="275878183"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/refined%20trait%20impls/near/275878183" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/refined.20trait.20impls.html#275878183">(Mar 19 2022 at 00:28)</a>:</h4>
<p>For that specific issue I could imagine requiring the user to write <code>where ...</code> or something like that.</p>



<a name="275878229"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/refined%20trait%20impls/near/275878229" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/refined.20trait.20impls.html#275878229">(Mar 19 2022 at 00:28)</a>:</h4>
<p>That said, this feature feels a bit too hypothetical/underspecified to me to include in the RFC</p>



<a name="275878237"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/refined%20trait%20impls/near/275878237" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/refined.20trait.20impls.html#275878237">(Mar 19 2022 at 00:28)</a>:</h4>
<p>Yeah, I agree it shouldn't be in the RFC, I'd just like to check that we're not accidentally preventing ourselves from adding this feature in the future</p>



<a name="275879686"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/refined%20trait%20impls/near/275879686" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Boxy [she/her] <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/refined.20trait.20impls.html#275879686">(Mar 19 2022 at 00:56)</a>:</h4>
<p>It's not clear to me that it is okay to just remove any of the where clauses from the trait in the impl.<br>
i.e. a trait fn <code>fn foo&lt;T: Trait&lt;Assoc = u32&gt;&gt;(&amp;self) -&gt; &lt;T as Trait&gt;::Assoc</code><br>
implemented as <code>fn foo&lt;T: Trait&gt;(&amp;self) -&gt; &lt;T as Trait&gt;::Assoc</code> is not compatible with the trait definition</p>



<a name="275879687"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/refined%20trait%20impls/near/275879687" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/refined.20trait.20impls.html#275879687">(Mar 19 2022 at 00:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="116883">tmandry</span> I wonder if it'd be worth trying to determine some common cases where the wider bounds would not be desired.</p>
<p>For example, <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=8f5d2ab7562c499160576187fd5e6b6f">this compiles today</a>:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">struct</span> <span class="nc">Foo</span><span class="p">;</span><span class="w"></span>
<span class="k">impl</span><span class="w"> </span><span class="nb">Extend</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">extend</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">_</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="fm">unimplemented!</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>But it's not obvious to me that <code>Foo.extend("hello")</code> compiling with that <code>impl</code> is good.</p>



<a name="275881071"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/refined%20trait%20impls/near/275881071" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/refined.20trait.20impls.html#275881071">(Mar 19 2022 at 01:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="326176">Boxy [she/her]</span> <a href="#narrow/stream/213817-t-lang/topic/refined.20trait.20impls/near/275879686">said</a>:</p>
<blockquote>
<p>It's not clear to me that it is okay to just remove any of the where clauses from the trait in the impl.<br>
i.e. a trait fn <code>fn foo&lt;T: Trait&lt;Assoc = u32&gt;&gt;(&amp;self) -&gt; &lt;T as Trait&gt;::Assoc</code><br>
implemented as <code>fn foo&lt;T: Trait&gt;(&amp;self) -&gt; &lt;T as Trait&gt;::Assoc</code> is not compatible with the trait definition</p>
</blockquote>
<p>Interesting.. but I actually think it is compatible. Callers through the trait interface will have to prove the <code>&lt;T as Trait&gt;::Assoc = u32</code> bound, and the refined interface promises that <code>&lt;T as Trait&gt;::Assoc</code> will be returned, so we know the return type will be correct. Callers through the impl interface will be able to use and get back any type for <code>&lt;T as Trait&gt;::Assoc</code></p>



<a name="275881134"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/refined%20trait%20impls/near/275881134" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Boxy [she/her] <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/refined.20trait.20impls.html#275881134">(Mar 19 2022 at 01:24)</a>:</h4>
<p>oh right yes..its far too late for me to be thinking about type system stuff <span aria-label="rofl" class="emoji emoji-1f923" role="img" title="rofl">:rofl:</span></p>



<a name="275881140"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/refined%20trait%20impls/near/275881140" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/refined.20trait.20impls.html#275881140">(Mar 19 2022 at 01:25)</a>:</h4>
<p>A key point that seems to trip people up here is that where clauses are always proven by the caller. They don't exist to bind the function implementation</p>



<a name="275881231"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/refined%20trait%20impls/near/275881231" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/refined.20trait.20impls.html#275881231">(Mar 19 2022 at 01:26)</a>:</h4>
<p>(fwiw, I wasted several hours during the design phase of this RFC because I forgot that)</p>



<a name="275881347"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/refined%20trait%20impls/near/275881347" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/refined.20trait.20impls.html#275881347">(Mar 19 2022 at 01:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="125270">scottmcm</span> <a href="#narrow/stream/213817-t-lang/topic/refined.20trait.20impls/near/275879687">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="116883">tmandry</span> I wonder if it'd be worth trying to determine some common cases where the wider bounds would not be desired.</p>
</blockquote>
<p>This seems like a good idea. I haven't spent much time thinking about that. Part of me wants to defer to crawling <a href="http://crates.io">crates.io</a> and looking at actual examples</p>



<a name="275881488"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/refined%20trait%20impls/near/275881488" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/refined.20trait.20impls.html#275881488">(Mar 19 2022 at 01:32)</a>:</h4>
<p>That specific example is interesting but I'm not sure what to take away from it. Maybe functions that unconditionally panic should be given more scrutiny, because there may be no way to actually implement them... but it also seems unlikely that those functions would be <code>pub</code> in a published crate / something with semver constraints</p>



<a name="275883310"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/refined%20trait%20impls/near/275883310" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/refined.20trait.20impls.html#275883310">(Mar 19 2022 at 02:13)</a>:</h4>
<p>Yeah, any single-method trait is far less likely to do something like this, I agree.  But coming from Java-like languages it's very common to have interfaces that just <code>throw new NotSupportedException()</code> in shipped code, so while that's probably less common in Rust, it doesn't seem completely unlikely.</p>
<p>One piece of that example I do think is interesting is that the the trait's generic type ends up completely unused.  I don't know if that could be a heuristic -- for lifetimes it's common to not use them, but for a type parameter is seems potentially more unusual, especially when the argument <em>is</em> used in the trait definition.</p>
<p>Another thing that came to mind: how would provided implementations of things work with this?  Suppose I wrote </p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">impl</span><span class="w"> </span><span class="nb">Iterator</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="o">..</span><span class="p">.</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>Should the <code>nth</code> also be considered <code>const fn</code>?</p>



<a name="275929537"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/refined%20trait%20impls/near/275929537" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/refined.20trait.20impls.html#275929537">(Mar 19 2022 at 21:03)</a>:</h4>
<p>Related to refined trait impls, there is an intersection with <code>generic_associated_types</code> which seems quite important for that feature to be more user-friendly: the <code>type Assoc&lt;'a&gt; where Self : 'a</code> kind of associated types, could be filled with a refined implementation that does not care about the <code>Self : 'a</code> bound on <code>'a</code>, similar to the loosened bounds for methods.</p>



<a name="275929544"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/refined%20trait%20impls/near/275929544" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/refined.20trait.20impls.html#275929544">(Mar 19 2022 at 21:03)</a>:</h4>
<p>See <a href="#narrow/stream/122651-general/topic/When.20do.20GATs.20implementations.20need.20.60Self.3A.20'a.60.3F/near/273480813">https://rust-lang.zulipchat.com/#narrow/stream/122651-general/topic/When.20do.20GATs.20implementations.20need.20.60Self.3A.20'a.60.3F/near/273480813</a> for more info/context</p>



<a name="275951584"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/refined%20trait%20impls/near/275951584" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> matt1992 <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/refined.20trait.20impls.html#275951584">(Mar 20 2022 at 06:40)</a>:</h4>
<p>I find the use of "more specific" to refer to impling <code>fn method(impl Foo + Bar)</code> as <code>fn method(impl Foo)</code> mildly annoying. That's going more general, since the types that implement <code>Foo</code> are a superset of those that implement  <code>Foo + Bar</code>.</p>
<p>The use of "more specific" for return types makes sense though.</p>



<a name="276120532"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/refined%20trait%20impls/near/276120532" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/refined.20trait.20impls.html#276120532">(Mar 21 2022 at 22:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="125270">scottmcm</span> <a href="#narrow/stream/213817-t-lang/topic/refined.20trait.20impls/near/275883310">said</a>:</p>
<blockquote>
<p>Another thing that came to mind: how would provided implementations of things work with this?  Suppose I wrote </p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">impl</span><span class="w"> </span><span class="nb">Iterator</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="o">..</span><span class="p">.</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>Should the <code>nth</code> also be considered <code>const fn</code>?</p>
</blockquote>
<p>That is a good question and instance of a more general problem. I could imagine having some kind of annotation like <code>const(where const Self::next)</code> for this. You could also use that for methods of generic types. Related to the <code>~const</code> we have today (I always forget what that means)</p>



<a name="276220511"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/refined%20trait%20impls/near/276220511" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/refined.20trait.20impls.html#276220511">(Mar 22 2022 at 16:56)</a>:</h4>
<p>Opened the RFC PR: <a href="https://github.com/rust-lang/rfcs/issues/3245">rust-lang/rfcs#3245</a></p>



<a name="276338076"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/refined%20trait%20impls/near/276338076" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/refined.20trait.20impls.html#276338076">(Mar 23 2022 at 14:07)</a>:</h4>
<p>Hmm, I've just realized that where refined impls <em>w.r.t.</em> bounds are accepted today, making call sites suddenly start using the looser function signatures can lead to type inference errors:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">trait</span><span class="w"> </span><span class="n">Is</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">type</span> <span class="nc">EqTo</span><span class="w"> </span>: <span class="o">?</span><span class="nb">Sized</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="w"> </span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Is</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">type</span> <span class="nc">EqTo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">Self</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="k">trait</span><span class="w"> </span><span class="n">Example</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">assoc</span><span class="o">&lt;</span><span class="n">T</span><span class="w"> </span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="k">where</span><span class="w"></span>
<span class="w">        </span><span class="bp">Self</span><span class="w"> </span>: <span class="nc">Is</span><span class="o">&lt;</span><span class="n">EqTo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="c1">// refined impl</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="w"> </span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Example</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">assoc</span><span class="o">&lt;</span><span class="n">__</span><span class="w"> </span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">{}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">_check</span><span class="o">&lt;</span><span class="n">T</span><span class="w"> </span>: <span class="o">?</span><span class="nb">Sized</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Example</span><span class="o">&gt;</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="c1">// and what if we just had `T : ?Sized`?</span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>::<span class="n">assoc</span>::<span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>I know type inference errors are acceptable provided crater shows they're low impact, but since I haven't seen that mentioned in the RFC, at least not super-explicitly, I think it could deserve a mention in the Drawbacks section.</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>