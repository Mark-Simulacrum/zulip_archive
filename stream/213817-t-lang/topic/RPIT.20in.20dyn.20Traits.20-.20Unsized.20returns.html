<html>
<head><meta charset="utf-8"><title>RPIT in dyn Traits - Unsized returns · t-lang · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/index.html">t-lang</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/RPIT.20in.20dyn.20Traits.20-.20Unsized.20returns.html">RPIT in dyn Traits - Unsized returns</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="276396414"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/RPIT%20in%20dyn%20Traits%20-%20Unsized%20returns/near/276396414" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Olivier FAURE <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/RPIT.20in.20dyn.20Traits.20-.20Unsized.20returns.html#276396414">(Mar 23 2022 at 20:35)</a>:</h4>
<p>I'd like to make a separate thread to make my case for using <a href="https://github.com/rust-lang/rfcs/pull/2884">RFC #2884</a>, aka unsized returns, for RPIT-in-dyn-trait and by extension dyn async traits.</p>
<p>Niko's rationale for the current RPIT-in-dyn-trait design is to enable library writers to write:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">async</span><span class="w"> </span><span class="k">fn</span> <span class="nf">count</span><span class="p">(</span><span class="n">x</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="k">dyn</span><span class="w"> </span><span class="n">AsyncIterator</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">next</span><span class="p">().</span><span class="k">await</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">c</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">c</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>and have that code be used in no_std envs.</p>
<p>The big constraints are:</p>
<ul>
<li>Library writers must write their code "naturally"; they will write code as generic as possible, and not worry about implementation details.</li>
<li>Embedded developers must be able to use libraries without allocating anything. They may not even have an allocator.</li>
<li>These two constraints must be compatible. Eg embedded developers shouldn't have to ask library writers to add an allocator-less version.</li>
</ul>
<p>To satisfy those, the design adds a new "adapter" concept. Adapter are like magic HKTs that can take a trait <code>MyTrait</code>, and produce a wrapper type <code>MyTraitWrapper</code> that, for every RPIT method of <code>MyTrait</code>, implements a wrapper method with basically the RPIT's vtable, plus a custom destructor. The main use-case of that adapter concept is the <code>#[dyner::inline_adapter]</code> attribute, which, applied to <code>AsyncIterator</code>, gives us <code>InlineAsyncIterator</code>, which is an iterator that stores the return value of the <code>next()</code> call in a preallocated slot.</p>



<a name="276396538"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/RPIT%20in%20dyn%20Traits%20-%20Unsized%20returns/near/276396538" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Olivier FAURE <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/RPIT.20in.20dyn.20Traits.20-.20Unsized.20returns.html#276396538">(Mar 23 2022 at 20:36)</a>:</h4>
<hr>
<p>Josh's big objection to this is that this pattern is basically encouraging lots of hidden allocations that aren't clear when looking at either the call site or the callee code. Eg:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">impl</span><span class="w"> </span><span class="n">AsyncIterator</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">MyRange</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">i32</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">async</span><span class="w"> </span><span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">sleep</span><span class="p">(</span><span class="mi">30</span><span class="p">).</span><span class="k">await</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">range</span><span class="p">.</span><span class="n">next</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">async</span><span class="w"> </span><span class="k">fn</span> <span class="nf">do_thing</span><span class="p">(</span><span class="n">x</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="k">dyn</span><span class="w"> </span><span class="n">AsyncIterator</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">next</span><span class="p">().</span><span class="k">await</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">c</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">c</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">do_thing_with_my_range</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">do_thing</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">MyRange</span><span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="mi">10</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>Looking at the code of all three functions, there's no sign that any of the code allocates anywhere, even though it creates boxes for every call to <code>.next()</code>.</p>
<p>Even if we edited <code>do_thing_with_my_range</code> to add an explicit boxing adapter, <code>.next()</code> is the call that allocates, and yet there's no indication at either the call site or in <code>next()</code>'s implementation that memory is allocated.</p>
<p>Josh points out that this is bad, because allocator calls are non-trivial things, and developers may want strong guarantees that they can control where the allocator is called. Allocations can panic, can be expensive cache-wise, etc. Some people get <em>really</em> nervous when the compiler starts adding hidden allocations.</p>



<a name="276396692"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/RPIT%20in%20dyn%20Traits%20-%20Unsized%20returns/near/276396692" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Olivier FAURE <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/RPIT.20in.20dyn.20Traits.20-.20Unsized.20returns.html#276396692">(Mar 23 2022 at 20:37)</a>:</h4>
<hr>
<p>My own objection to the proposed design is that the whole "adapter" machinery seems very complex, and yet it only covers very specific use-cases.</p>
<p>The "inline adapter" only works for <code>&amp;mut self</code> methods that return a type with a borrow on self. This is the case for <code>AsyncIterator::next()</code>, but it may not be the case for other trait methods, eg:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">trait</span><span class="w"> </span><span class="n">MyTrait</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">get_printable</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">value</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">impl</span><span class="w"> </span><span class="n">Display</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">call_three_times</span><span class="p">(</span><span class="n">obj</span>: <span class="kp">&amp;</span><span class="nc">dyn</span><span class="w"> </span><span class="n">MyTrait</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">obj</span><span class="p">.</span><span class="n">get_printable</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">obj</span><span class="p">.</span><span class="n">get_printable</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">obj</span><span class="p">.</span><span class="n">get_printable</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">"{a} {b} {c}"</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>My understanding is that the implemented workaround is using a cell, and the second call to <code>get_printable</code> panics, but... let's be honest, this is a horrifying hack. If we're not fine with inserting silent allocations, I can't imagine we're fine with inserting random panics because the allocation strategy of your caller didn't like that you called the same <code>&amp;self</code> method twice.</p>



<a name="276396740"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/RPIT%20in%20dyn%20Traits%20-%20Unsized%20returns/near/276396740" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Olivier FAURE <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/RPIT.20in.20dyn.20Traits.20-.20Unsized.20returns.html#276396740">(Mar 23 2022 at 20:38)</a>:</h4>
<hr>
<p>Instead, I propose that we ask developers who want their async code to be maximally portable to write</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span> <span class="nf">count</span><span class="p">(</span><span class="n">x</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="k">impl</span><span class="w"> </span><span class="n">AsyncIterator</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>We can add <code>InlineAsyncIterator</code> as a special type, implemented with existing concepts (and some unsafe code), and skip most of the dynx / adapter machinery.</p>
<p>Embedded developers who want no allocation and to avoid generic bloat can then write:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span> <span class="nf">invoke_count</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">x</span>: <span class="nc">impl</span><span class="w"> </span><span class="n">AsyncIterator</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">count</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">InlineDynAsyncIterator</span>::<span class="n">new</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>For non-async RPIT methods, we can use the syntax in RFC 2884:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">trait</span><span class="w"> </span><span class="n">MyTrait</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">get_printable</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">value</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">impl</span><span class="w"> </span><span class="n">Display</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">call_three_times</span><span class="p">(</span><span class="n">obj</span>: <span class="kp">&amp;</span><span class="nc">dyn</span><span class="w"> </span><span class="n">MyTrait</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span>::<span class="n">new_with</span><span class="p">(</span><span class="o">||</span><span class="w"> </span><span class="n">obj</span><span class="p">.</span><span class="n">get_printable</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span>::<span class="n">new_with</span><span class="p">(</span><span class="o">||</span><span class="w"> </span><span class="n">obj</span><span class="p">.</span><span class="n">get_printable</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span>::<span class="n">new_with</span><span class="p">(</span><span class="o">||</span><span class="w"> </span><span class="n">obj</span><span class="p">.</span><span class="n">get_printable</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">"{a} {b} {c}"</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>Doing it that way, the main advantage is we can use different allocation strategies, and it's obvious which one we're using:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span> <span class="nf">call_three_times</span><span class="p">(</span><span class="n">obj</span>: <span class="kp">&amp;</span><span class="nc">dyn</span><span class="w"> </span><span class="n">MyTrait</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SmallBox</span>::<span class="n">new_with</span><span class="p">(</span><span class="o">||</span><span class="w"> </span><span class="n">obj</span><span class="p">.</span><span class="n">get_printable</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SmallBox</span>::<span class="n">new_with</span><span class="p">(</span><span class="o">||</span><span class="w"> </span><span class="n">obj</span><span class="p">.</span><span class="n">get_printable</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SmallBox</span>::<span class="n">new_with</span><span class="p">(</span><span class="o">||</span><span class="w"> </span><span class="n">obj</span><span class="p">.</span><span class="n">get_printable</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">"{a} {b} {c}"</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span> <span class="nf">call_three_times</span><span class="p">(</span><span class="n">obj</span>: <span class="kp">&amp;</span><span class="nc">dyn</span><span class="w"> </span><span class="n">MyTrait</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">arena</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MyGrowingArena</span>::<span class="n">new</span><span class="p">(</span><span class="n">SOME_VALUE</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arena</span><span class="p">.</span><span class="n">new_with</span><span class="p">(</span><span class="o">||</span><span class="w"> </span><span class="n">obj</span><span class="p">.</span><span class="n">get_printable</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arena</span><span class="p">.</span><span class="n">new_with</span><span class="p">(</span><span class="o">||</span><span class="w"> </span><span class="n">obj</span><span class="p">.</span><span class="n">get_printable</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arena</span><span class="p">.</span><span class="n">new_with</span><span class="p">(</span><span class="o">||</span><span class="w"> </span><span class="n">obj</span><span class="p">.</span><span class="n">get_printable</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">"{a} {b} {c}"</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>



<a name="276397306"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/RPIT%20in%20dyn%20Traits%20-%20Unsized%20returns/near/276397306" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/RPIT.20in.20dyn.20Traits.20-.20Unsized.20returns.html#276397306">(Mar 23 2022 at 20:42)</a>:</h4>
<p>Sounds good so far. Could you show what <code>call_three_times</code> looks like if you take <code>&amp;mut impl AsyncIterator</code> and want to be maximally general?</p>



<a name="276397331"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/RPIT%20in%20dyn%20Traits%20-%20Unsized%20returns/near/276397331" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Olivier FAURE <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/RPIT.20in.20dyn.20Traits.20-.20Unsized.20returns.html#276397331">(Mar 23 2022 at 20:42)</a>:</h4>
<p>The body is the same</p>



<a name="276397343"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/RPIT%20in%20dyn%20Traits%20-%20Unsized%20returns/near/276397343" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Olivier FAURE <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/RPIT.20in.20dyn.20Traits.20-.20Unsized.20returns.html#276397343">(Mar 23 2022 at 20:42)</a>:</h4>
<p>It's literally just changing a keyword</p>



<a name="276397355"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/RPIT%20in%20dyn%20Traits%20-%20Unsized%20returns/near/276397355" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/RPIT.20in.20dyn.20Traits.20-.20Unsized.20returns.html#276397355">(Mar 23 2022 at 20:43)</a>:</h4>
<p>Doesn't that mean that your maximally portable code is deciding for its caller whether to box or not?</p>



<a name="276397384"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/RPIT%20in%20dyn%20Traits%20-%20Unsized%20returns/near/276397384" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Olivier FAURE <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/RPIT.20in.20dyn.20Traits.20-.20Unsized.20returns.html#276397384">(Mar 23 2022 at 20:43)</a>:</h4>
<p>Wait, no, I thought you were talking about count</p>



<a name="276397451"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/RPIT%20in%20dyn%20Traits%20-%20Unsized%20returns/near/276397451" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/RPIT.20in.20dyn.20Traits.20-.20Unsized.20returns.html#276397451">(Mar 23 2022 at 20:43)</a>:</h4>
<p>Right, count is easier. What should call_three_times do to let its caller decide how to handle the return values?</p>



<a name="276397541"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/RPIT%20in%20dyn%20Traits%20-%20Unsized%20returns/near/276397541" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/RPIT.20in.20dyn.20Traits.20-.20Unsized.20returns.html#276397541">(Mar 23 2022 at 20:44)</a>:</h4>
<blockquote>
<p>Allocations can panic, can be expensive cache-wise, etc.</p>
</blockquote>
<p>Worse, some low-implementation-complexity allocators take locks on every allocation to be thread-safe, they don't have thread-local pools. I think older versions of musl do that for example. If this is called frequently that can be really bad for concurrent code... which you expect in the context of async.</p>



<a name="276397657"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/RPIT%20in%20dyn%20Traits%20-%20Unsized%20returns/near/276397657" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Olivier FAURE <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/RPIT.20in.20dyn.20Traits.20-.20Unsized.20returns.html#276397657">(Mar 23 2022 at 20:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="239881">Josh Triplett</span> <a href="#narrow/stream/213817-t-lang/topic/RPIT.20in.20dyn.20Traits.20-.20Unsized.20returns/near/276397451">said</a>:</p>
<blockquote>
<p>Right, count is easier. What should call_three_times do to let its caller decide how to handle the return values?</p>
</blockquote>
<p>It can do this:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span> <span class="nf">call_three_times</span><span class="p">(</span><span class="n">obj</span>: <span class="kp">&amp;</span><span class="nc">impl</span><span class="w"> </span><span class="n">MyTrait</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">obj</span><span class="p">.</span><span class="n">get_printable</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">obj</span><span class="p">.</span><span class="n">get_printable</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">obj</span><span class="p">.</span><span class="n">get_printable</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">"{a} {b} {c}"</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>



<a name="276397784"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/RPIT%20in%20dyn%20Traits%20-%20Unsized%20returns/near/276397784" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Olivier FAURE <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/RPIT.20in.20dyn.20Traits.20-.20Unsized.20returns.html#276397784">(Mar 23 2022 at 20:46)</a>:</h4>
<p>But then the given <code>impl MyTrait</code> must be non-dyn</p>



<a name="276397811"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/RPIT%20in%20dyn%20Traits%20-%20Unsized%20returns/near/276397811" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/RPIT.20in.20dyn.20Traits.20-.20Unsized.20returns.html#276397811">(Mar 23 2022 at 20:46)</a>:</h4>
<p>Is that a restriction we can place?</p>



<a name="276397862"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/RPIT%20in%20dyn%20Traits%20-%20Unsized%20returns/near/276397862" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Olivier FAURE <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/RPIT.20in.20dyn.20Traits.20-.20Unsized.20returns.html#276397862">(Mar 23 2022 at 20:47)</a>:</h4>
<p>Eeeh... kinda. Right now the language conflates "is dyn" with "is Sized".</p>



<a name="276397866"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/RPIT%20in%20dyn%20Traits%20-%20Unsized%20returns/near/276397866" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/RPIT.20in.20dyn.20Traits.20-.20Unsized.20returns.html#276397866">(Mar 23 2022 at 20:47)</a>:</h4>
<p>It does seem like it'd solve the problem, since then the caller can decide how to turn a <code>dyn</code> into an <code>impl</code> while handling the return values.</p>



<a name="276397910"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/RPIT%20in%20dyn%20Traits%20-%20Unsized%20returns/near/276397910" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/RPIT.20in.20dyn.20Traits.20-.20Unsized.20returns.html#276397910">(Mar 23 2022 at 20:47)</a>:</h4>
<p>(Though it doesn't give many options to the caller in doing so.)</p>



<a name="276398034"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/RPIT%20in%20dyn%20Traits%20-%20Unsized%20returns/near/276398034" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Olivier FAURE <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/RPIT.20in.20dyn.20Traits.20-.20Unsized.20returns.html#276398034">(Mar 23 2022 at 20:48)</a>:</h4>
<p>I mean... that makes sense? In non-async, non-RPIT code you usually don't worry about how the functions you're calling allocate memory for their internals.</p>



<a name="276398272"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/RPIT%20in%20dyn%20Traits%20-%20Unsized%20returns/near/276398272" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Olivier FAURE <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/RPIT.20in.20dyn.20Traits.20-.20Unsized.20returns.html#276398272">(Mar 23 2022 at 20:50)</a>:</h4>
<p>Like, if you're calling <code>find_path_with_astar(my_graph)</code>, you usually don't expect to control whether the A* implementation is using Vecs or VecDequeues.</p>



<a name="276398565"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/RPIT%20in%20dyn%20Traits%20-%20Unsized%20returns/near/276398565" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Olivier FAURE <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/RPIT.20in.20dyn.20Traits.20-.20Unsized.20returns.html#276398565">(Mar 23 2022 at 20:52)</a>:</h4>
<p>The broader point I'm making is that, given this trait declaration:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">trait</span><span class="w"> </span><span class="n">MyTrait</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">get_printable</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">value</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">impl</span><span class="w"> </span><span class="n">Display</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p><strong>there isn't any feasible way to pass <code>&amp;dyn MyTrait</code> to a function, and have that function use it, while guaranteeing that no dynamic allocation will ever be made.</strong></p>



<a name="276398734"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/RPIT%20in%20dyn%20Traits%20-%20Unsized%20returns/near/276398734" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Olivier FAURE <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/RPIT.20in.20dyn.20Traits.20-.20Unsized.20returns.html#276398734">(Mar 23 2022 at 20:53)</a>:</h4>
<p>You can make it so that there are <em>few</em> allocations, which is often good enough in embedded. You can use an arena. You can force the code that's making the allocation to use <code>Box::new_with</code> or whatever to make it clear that allocations are happening.</p>



<a name="276398935"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/RPIT%20in%20dyn%20Traits%20-%20Unsized%20returns/near/276398935" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Olivier FAURE <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/RPIT.20in.20dyn.20Traits.20-.20Unsized.20returns.html#276398935">(Mar 23 2022 at 20:55)</a>:</h4>
<p>But the <code>fn method() -&gt; impl Display;</code> API and the <code>fn call_three_times(obj: &amp;dyn MyTrait)</code> API, taken together, make it so that the program has no way to determine statically how much memory will be needed ahead of time.</p>



<a name="276400861"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/RPIT%20in%20dyn%20Traits%20-%20Unsized%20returns/near/276400861" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/RPIT.20in.20dyn.20Traits.20-.20Unsized.20returns.html#276400861">(Mar 23 2022 at 21:08)</a>:</h4>
<p>Whether sized or unsized return types are used for <code>dyn</code> has to be decided for each method on the trait. For async you would (pretty much always) want to use a sized return type with a dynx-like mechanism, whereas for other use cases you might want to use unsized returns. With that said I think the two approaches are compatible and can co-exist</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>