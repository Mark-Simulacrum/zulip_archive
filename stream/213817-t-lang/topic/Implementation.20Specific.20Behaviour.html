<html>
<head><meta charset="utf-8"><title>Implementation Specific Behaviour · t-lang · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/index.html">t-lang</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html">Implementation Specific Behaviour</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="271866373"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/271866373" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#271866373">(Feb 14 2022 at 18:16)</a>:</h4>
<p>I wanted to raise this question when I was reminded of this comment:</p>
<p><span class="user-mention silent" data-user-id="239881">Josh Triplett</span> <a href="#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270226146">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270225982">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="271719">Mario Carneiro</span> <a href="#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270225700">said</a>:</p>
<blockquote>
<p>Why is it called <code>asm!</code> instead of <code>llvm_asm!</code>? It's apparently still tied up with LLVM</p>
</blockquote>
<p>Or do what C++ does, which is just say its <em>conditionally-supported</em> with <em>implementation-defined</em> semantics.</p>
</blockquote>
<p>A world of <em>nope</em> to anything "implementation-defined" in Rust.</p>
</blockquote>
<p>I wanted to clarify <em>implementation-defined</em> behaviour (and related behaviours) as it applies to rust.<br>
C++ has 3 categories of implementation-specific behaviour, other than undefined behaviour:<br>
<em>implementation-defined behaviour</em> is classified as parameters of the abstract machine on which the standard operates. <a href="http://eel.is/c++draft/intro.abstract#2">http://eel.is/c++draft/intro.abstract#2</a>. It further requires that implementations document the choices for these parameters. Arguably, rust has limited implementation-defiend behaviour</p>
<ul>
<li>The set of target features available in cfg are implementation-defined </li>
<li>Whether or not overflowing default scalar operations panic or wrap is implementation-defined</li>
</ul>
<p><em>Unspecified behaviour</em> is classified as non-deterministic aspects of the parameterized abstract machine, of which the implementation choices made for each occurance in a program consistutes an "execution". Unspecified behaviour and implementation-defined behaviour differ only in that the standard does not require documentation for the latter. Rust does have several occurances of unspecified behaviour (characterized sometimes in documentation as unstable), such as:</p>
<ul>
<li>The layout of repr(Rust) types</li>
<li>The ABI of <code>extern "Rust"</code> functions</li>
<li>The pointer returned by <code>core::ptr::NonNull::dangling()</code></li>
<li>etc.</li>
</ul>
<p>There is also <em>conditionally-supported behaviour</em> which is similar to implementation-defined behaviour. An implementation is required to document all conditionally-supported behaviour it does not support (but not the ones it does). Rust has no occurances of this currently.</p>
<p>This set could be extended to include <em>target-specific behaviour</em> which I would ideally categorize as implementation-defined behaviour, but for a set of well-known targets, the behaviour could be fixed. There are arguments that this should be fixed exhaustively, however, this places the burden of new target support solely on t-lang, which may be unreasonable for some implementations, and may be unreasonable, especially when the choices may be obvious (for example, size of <code>usize</code> on a platform with 32-bit pointers and registers). </p>
<ul>
<li>The name of each of the cfg(target_*) components set</li>
<li>The complete set of target features</li>
<li>The size_of::&lt;usize&gt;() et. al</li>
<li>The underlying type of <code>std::ffi::c_int</code>, <code>std::ffi::c_long</code>, and <code>std::ffi::c_char</code></li>
<li>Which of the <code>core::arch</code> and <code>std::os</code> submodules are available, if any.</li>
</ul>
<p>(Note: I do not consider the options passed to the rustc invocation anything more than a detail of the implementation, and a way to control unspecified, implementation-defined, and target-specific behaviour. )</p>



<a name="271866503"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/271866503" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#271866503">(Feb 14 2022 at 18:17)</a>:</h4>
<p>Do these lists seem correct as described?</p>



<a name="271866996"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/271866996" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#271866996">(Feb 14 2022 at 18:21)</a>:</h4>
<p>Seems a stretch to call overflow behavior implementation-defined because that can be configured in cargo.toml. Would we expect some implementations to just ignore the user setting?</p>



<a name="271867139"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/271867139" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#271867139">(Feb 14 2022 at 18:22)</a>:</h4>
<p>Or perhaps it's a very unintuitive way to interpret implementation-defined when it applies to all implementations.</p>



<a name="271868445"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/271868445" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#271868445">(Feb 14 2022 at 18:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="330154">The 8472</span> <a href="#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/271866996">said</a>:</p>
<blockquote>
<p>Seems a stretch to call overflow behavior implementation-defined because that can be configured in cargo.toml. Would we expect some implementations to just ignore the user setting?</p>
</blockquote>
<p>See my note: the options passed to the rustc invocation aren't considered here as more than a detail of how the implementation makes a choice for implementation-defined behaviour.<br>
A non-rustc CLI is a perfectly valid implementation. It couldn't be used with cargo directly, but it's a valid implementation.</p>



<a name="271870385"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/271870385" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#271870385">(Feb 14 2022 at 18:49)</a>:</h4>
<p>Depends on whether the CLI is part of the spec so that other implementations have to be plug-in compatible or not.</p>



<a name="271874311"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/271874311" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#271874311">(Feb 14 2022 at 19:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="330154">The 8472</span> <a href="#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/271870385">said</a>:</p>
<blockquote>
<p>Depends on whether the CLI is part of the spec so that other implementations have to be plug-in compatible or not.</p>
</blockquote>
<p>Well, there are implementations without a rustc CLI already - gcc-rs being one of them and, strictly speaking, lccc's rust frontend. <br>
The entire frontend for the rust implementation is <code>xlangfrontend-rust.{so,dll}</code>, and that definately doesn't have  CLI. You could load that up with the necessary backend and intermediate transformers, agnostic of the driver (or even without any driver). The default driver is gcc-like, though there is a rustc driver planned, and also a "raw" driver that doesn't do fancy stuff like frontend detection (the invocation is something like <code>xlang --frontend=&lt;name or plugin path&gt; --backend=&lt;name or plugin path&gt; [--plugin &lt;name-or-path&gt;]... &lt;input&gt; &lt;output&gt;</code>). I'd argue these are still valid drivers for a rust implementation.</p>



<a name="271877341"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/271877341" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#271877341">(Feb 14 2022 at 19:35)</a>:</h4>
<p>yeah, ok, that argument was the wrong direction. What I mean is that some software might only be tested with overflow checks enabled. If we say implementation-defined without saying that it's an externally configurable input then always disabling overflow checks would be a valid implementation, no? Which could leave a security hole in such software.</p>



<a name="271877899"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/271877899" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#271877899">(Feb 14 2022 at 19:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="330154">The 8472</span> <a href="#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/271877341">said</a>:</p>
<blockquote>
<p>yeah, ok, that argument was the wrong direction. What I mean is that some software might only be tested with overflow checks enabled. If we say implementation-defined without saying that it's an externally configurable input then always disabling overflow checks would be a valid implementation, no? Which could leave a security hole in such software.</p>
</blockquote>
<p>Well, it's guaranteed that overflow checks occur when debug assertions are enabled (which would also be implementation-defined).<br>
If an implementation didn't support overflow checks via <code>-C overflow-checks</code>, it probably doesn't support cargo, in which case, the software likely won't build unless it's aware of this possibility (and would be aware of the alternative, and ways to check if the alternative is available, e.g. <code>-ftrapv</code>).</p>



<a name="271914257"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/271914257" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#271914257">(Feb 15 2022 at 01:23)</a>:</h4>
<p>First, implementation-defined behavior assumes that other implementations can make different definitions. I don't think that's necessarily the case; we'd need to make a deliberate decision to that effect about features that Rust implementations can vary on and features they can't.</p>



<a name="271914320"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/271914320" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#271914320">(Feb 15 2022 at 01:24)</a>:</h4>
<p>Second, I think we <em>do</em> fix the behavior of targets, when defining those targets; that behavior should be fixed for all implementations of the same target, and should only differ in a different target.</p>



<a name="271914330"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/271914330" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#271914330">(Feb 15 2022 at 01:24)</a>:</h4>
<p>(though that doesn't necessary make it lang)</p>



<a name="271914354"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/271914354" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#271914354">(Feb 15 2022 at 01:24)</a>:</h4>
<p>Third, I do think some aspects of the command line may need to be standardized, not varying; that again needs a deliberate decision.</p>



<a name="271914473"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/271914473" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#271914473">(Feb 15 2022 at 01:26)</a>:</h4>
<p><span class="user-mention" data-user-id="257758">@Connor Horman</span> </p>
<blockquote>
<p>Well, there are implementations without a rustc CLI already - gcc-rs being one of them and, strictly speaking, lccc's rust frontend. </p>
</blockquote>
<p>It remains to be seen if those become Rust implementations. Right now, I think they're implementations of some subset of Rust.</p>



<a name="271914525"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/271914525" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#271914525">(Feb 15 2022 at 01:27)</a>:</h4>
<p>Whether that subset becomes complete will depend both on the implementation (downstream) and on the definition of "complete" (upstream).</p>



<a name="271916362"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/271916362" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#271916362">(Feb 15 2022 at 01:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="239881">Josh Triplett</span> <a href="#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/271914473">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> </p>
<blockquote>
<p>Well, there are implementations without a rustc CLI already - gcc-rs being one of them and, strictly speaking, lccc's rust frontend. </p>
</blockquote>
<p>It remains to be seen if those become Rust implementations. Right now, I think they're implementations of some subset of Rust.</p>
</blockquote>
<p>Fair. Although mrustc is arguably an implementation of 1.54</p>
<p>In either case, I doubt it's a good idea to even stabilize the existance of a CLI from a language perspective, let alone it's form. I think that it may be a good optional feature set, and further constrains choices of implementation-defined behaviour, but it should be opt-in for the implementation. </p>
<p><span class="user-mention silent" data-user-id="239881">Josh Triplett</span> <a href="#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/271914257">said</a>:</p>
<blockquote>
<p>First, implementation-defined behavior assumes that other implementations can make different definitions. I don't think that's necessarily the case; we'd need to make a deliberate decision to that effect about features that Rust implementations can vary on and features they can't.</p>
</blockquote>
<p>IIRC, the numeric overflow RFC left it up to the implementation to decide, effectively. Keep in mind that it's not necessarily "different implementations can choose w/e" implementation-defined behaviour can be (and almost always is) constrained. </p>
<p><span class="user-mention silent" data-user-id="239881">Josh Triplett</span> <a href="#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/271914320">said</a>:</p>
<blockquote>
<p>Second, I think we <em>do</em> fix the behavior of targets, when defining those targets; that behavior should be fixed for all implementations of the same target, and should only differ in a different target.</p>
</blockquote>
<p>Right, but outside of the defined set of targets, implementations should be free to choose the behaviour. If I'm compiling for proprietaryinternalprocessor-pc-internal, I should be able to say what the choices are for the target-dependant behaviour, without necessarily consulting upstream, especially in the case where it's unlikely any other implementation would pick it up.</p>



<a name="271916393"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/271916393" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#271916393">(Feb 15 2022 at 01:54)</a>:</h4>
<p>To be clear, I'm not suggesting we should standardize the CLI, I'm just suggesting that we haven't made a decision on that front at all, and we should make a deliberate decision.</p>



<a name="271916422"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/271916422" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#271916422">(Feb 15 2022 at 01:55)</a>:</h4>
<p>I do think there's an advantage to having a standardized command line interface, even if we said that not all compilers need to have a command line interface; we could effectively say that if you have one, it needs to have certain options and syntax, which would help people invoke it in a standardized way. That actually seems helpful for other compilers, to give them a clear standard to support that will let them drop in.</p>



<a name="271916496"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/271916496" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#271916496">(Feb 15 2022 at 01:56)</a>:</h4>
<p>Regarding targets, the problem is that if some other implementation of rust or of a subset of rust ends up establishing a target by a given name, and then makes implementation decisions about that target, we could get stuck with some of those implementation decisions, or find ourselves having to consider breaking large numbers of existing users.</p>



<a name="271916506"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/271916506" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#271916506">(Feb 15 2022 at 01:56)</a>:</h4>
<p>That's part of why I'd come up with a candidate target policy, for proposing targets that aren't ready to even become tier 3 in rust itself.</p>



<a name="271916519"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/271916519" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#271916519">(Feb 15 2022 at 01:57)</a>:</h4>
<p>Part of the goal was to create a way to register a target and make the obvious decisions, without having to get that target upstream.</p>



<a name="271922740"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/271922740" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#271922740">(Feb 15 2022 at 03:40)</a>:</h4>
<p><span class="user-mention silent" data-user-id="239881">Josh Triplett</span> <a href="#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/271916496">said</a>:</p>
<blockquote>
<p>Regarding targets, the problem is that if some other implementation of rust or of a subset of rust ends up establishing a target by a given name, and then makes implementation decisions about that target, we could get stuck with some of those implementation decisions, or find ourselves having to consider breaking large numbers of existing users.</p>
</blockquote>
<p>Well, sure, but a lot of the decisions will either be obvious, fixed, or be decided outside of the context of rust (usually a combination of all three). I've mentioned it before, but it's not like T-lang can change the C ABI of a target, especially if it's already been in use for a while. <br>
I'm also thinking about internal proprietary targets that might never see an official implementation.</p>
<p>Also, speaking specifically of lccc, but may apply equally to gcc-rs. It seems unnecessarily restrictive that only the rust frontend for those implementations cannot support a target (and I'd personally not be a fan of making all of the targets supported period be a subset of those supported by rust). In lccc, the set of supported targets is dictated by <code>xlang_target</code>, which also describes common information for all targets.</p>
<p>I've got a target this easily applies to (a WIP 64-bit ISA <a href="https://github.com/Clever-ISA/Clever-ISA">https://github.com/Clever-ISA/Clever-ISA</a>&gt;). The default model would be pointers 64-bit, long 64-bit, int 32-bit. There would also likely be an ILP32 model. The target (arch) names are specified, the feature names are specified, assembly syntax is mostly given. <br>
I'm unsure there would be any decisions at all left for rust, in this case.</p>



<a name="271922838"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/271922838" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#271922838">(Feb 15 2022 at 03:41)</a>:</h4>
<p>That sounds like a target easily proposed as a candidate target then...</p>



<a name="271923077"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/271923077" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#271923077">(Feb 15 2022 at 03:45)</a>:</h4>
<p>Well, it's unlikely to see it's way into rustc specifically for a while. While most of the major ISA development is complete, toolchain development is lacking... and as it stands, I'm more likely to include it more quickly in lccc and it's related tooling than in the absolutely annoying gcc+binutils and llvm stacks.</p>



<a name="271925261"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/271925261" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#271925261">(Feb 15 2022 at 04:21)</a>:</h4>
<p>Sure. But there's no reason it couldn't be, hence coordinating about it.</p>



<a name="271925651"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/271925651" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#271925651">(Feb 15 2022 at 04:28)</a>:</h4>
<p>I can imagine a lot of targets are like this, with very little room to do much of anything other than say "Yes" or "No". In which case, is there a reason that decision shouldn't be left up to the implementors, assuming the target isn't so far out of left field that it violates basic assumptions? </p>
<p>I could also imagine that implementations like gcc-rs or lccc could easily use this to side step the "well, we should coordinate it". After all, both of them aren't just a rust implementation. If I want to add a target and lockdown all the details to w/e I want, I could add it to every other frontend (which is as theoretically as easy as adding somewhere between 13 and 40 lines of code to xlang_target, then adding backend support for the architecture if necessary), stabilize the C abi, then request it added to rust.  Seems like a lot of extra steps, and gives considerable advantage in that regard to multi-language implementations. </p>
<p>Not saying I would do that, but I'm sure you could see how that could easily be used by a hostile implementation to sidestep coordinating anything. Or just as a shortcut.</p>



<a name="271925858"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/271925858" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#271925858">(Feb 15 2022 at 04:32)</a>:</h4>
<p>The scenarios are:</p>
<ol>
<li>A rust implementation adds a new target nobody supports yet, unilaterally decides everything about the target, then later proposes it upstream with everything fixed, vs.</li>
<li>A C implementation adds a new target nobody supports yet, unilaterally decides everything about the target, then proposes it upstream to rust with everything fixed. Oh, and then trivially adds support to the rust frontend using the same architecture.</li>
</ol>
<p>The only difference I see here is that in the latter case,  the details of the target get decided without necessarily applying it to rust itself, and that the rust implementation needs to have a C frontend in the same tree.</p>



<a name="271925876"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/271925876" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#271925876">(Feb 15 2022 at 04:32)</a>:</h4>
<p>(Or not even just C, <em>any other language</em> but rust)</p>



<a name="271927914"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/271927914" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#271927914">(Feb 15 2022 at 05:07)</a>:</h4>
<p>C compilers sometimes coordinate new target definitions too, especially contemporary ones. The x86-64 target was coordinated, for example.</p>



<a name="271966438"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/271966438" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#271966438">(Feb 15 2022 at 12:29)</a>:</h4>
<p>Sure, they can, and sometimes do. But they aren't requried to.</p>



<a name="271967437"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/271967437" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#271967437">(Feb 15 2022 at 12:38)</a>:</h4>
<p>Also, I'd argue that the fact that they do without being required to is an argument that Rust implementations might do the same. I known that I'd be likely to coordinate with upstream any time that there are major decisions to be made.</p>



<a name="271968444"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/271968444" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#271968444">(Feb 15 2022 at 12:47)</a>:</h4>
<p>And it's basically artifically limiting the frontend in these cases. In lccc, if xlang_target supports the target, then all of the frontends support it by design. If the rust frontend is the only one that imposes a limitation, that wouldn't be a technical limitation.</p>



<a name="271986236"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/271986236" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#271986236">(Feb 15 2022 at 15:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="239881">Josh Triplett</span> <a href="#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/271914257">said</a>:</p>
<blockquote>
<p>First, implementation-defined behavior assumes that other implementations can make different definitions. I don't think that's necessarily the case; we'd need to make a deliberate decision to that effect about features that Rust implementations can vary on and features they can't.</p>
</blockquote>
<p>Also, this is already the case:<br>
<code>rustc -C overflow-checks=y</code> vs. <code>rustc -C overflow-checks=n</code> are different parameterized abstract machines in terms of rust - one panics on <code>i32::MAX+1</code>, the other one produces <code>i32::MIN</code> (or issues an deny-by-default lint). </p>
<p>From RFC 0560:</p>
<blockquote>
<h2>Summary</h2>
<p>[...]<br>
Implementations are permitted to check for overflow at any time (statically or dynamically). Implementations are required to at least check dynamically when debug_assert! assertions are enabled. [...]</p>
<h2>Arithmetic operations with error conditions</h2>
<p>[...]<br>
The result of an error condition depends upon the state of overflow checking, which can be either enabled or default (this RFC does not describe a way to disable overflow checking completely). If overflow checking is enabled, then an error condition always results in a panic.<br>
[...]</p>
<h2>Enabling Overflow Checking</h2>
<p>[...]<br>
Compilers should present a command-line option to enable overflow checking universally.</p>
</blockquote>
<p>These sections together, at least to me,  seem to imply three things<br>
(1) It is the implementation's choice to check overflow, except that it must when debug_assertions are enabled<br>
(2) The result of checking overflow is a panic, otherwise, it wraps (constraint on the behaviour when disabled). Note that the Summary section also permits the implementation to issue a diagnostic and make the program ill-formed if overflow can be detected (which rustc <em>does</em>)<br>
(3) Implementations are recommended - but not required - to provide (and likely to document) a command line switch to control.</p>
<p>This seems to me to be a declaration of <em>implementation-defined</em> behaviour - the only thing that is missing is a mandate that the implementation documented it's choice in (1) (which would be implied in documentation of (3)). It could also be interpreted as unspecified behaviour, and it's merely a choice of rustc, as recommended, to provide a documented command line flag (which is a valid part of an implementations documentation - choices for unspecified behaviour).</p>



<a name="272034034"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272034034" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272034034">(Feb 15 2022 at 20:34)</a>:</h4>
<p><span class="user-mention" data-user-id="257758">@Connor Horman</span> </p>
<blockquote>
<p>Fair. Although mrustc is arguably an implementation of 1.54</p>
</blockquote>
<p>I'd emphatically disagree, mrustc cannot count as a conformant implementation of Rust because it allows an arbitrary superset of the language, specifically the superset that includes "all programs that would be rejected by a borrow checker". Arguably conformant implementations might be able to define <em>subsets</em> of the language, but certainly not arbitrary <em>supersets</em>, at least not on a stable-esque channel, and at least not without specific license from the hypothetical specification (I'm assuming that it will not be a valid implementation-defined choice to not provide a borrow checker). Which isn't to denigrate how cool or useful mrustc is, of course</p>



<a name="272034188"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272034188" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272034188">(Feb 15 2022 at 20:35)</a>:</h4>
<p><span class="user-mention" data-user-id="256342">@bstrie</span> I'm honestly concerned both about subset-of-Rust implementations and superset-of-Rust implementations, for different reasons. I agree with you underlying point though.</p>



<a name="272034322"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272034322" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272034322">(Feb 15 2022 at 20:36)</a>:</h4>
<p>C and C++ both explicitly note that an implementation can translate an ill-formed program, and, while I'd expect rust to recommend implementations not translate additionall ill-formed programs, I wouldn't expect it to forbid it.<br>
subset-of-Rust isn't a valid implementation (notwithstanding lints that can be controlled), but I'd expected superset-of-Rust to be valid, though discouraged.</p>



<a name="272034351"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272034351" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272034351">(Feb 15 2022 at 20:37)</a>:</h4>
<p><span class="user-mention" data-user-id="256342">@bstrie</span> A subset-of-Rust implementation causes ecosystem issues if it pushes people to stick to that subset for compatibility. A superset-of-Rust implementation causes ecosystem issues if people use that superset and expect Rust to add that feature without breaking it (effectively, such an implementation bypasses the unstable-to-stable development cycle).</p>



<a name="272034477"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272034477" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272034477">(Feb 15 2022 at 20:38)</a>:</h4>
<p>(Especially wrt. something like mrustc, which is explicitly designed to be a simple implementation that sidesteps the huge implementation pain of the borrow checker, while being designed to operate on code known to be well-formed, namely rustc itself)</p>



<a name="272034517"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272034517" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272034517">(Feb 15 2022 at 20:38)</a>:</h4>
<p>indeed, I'm not <em>entirely</em> on board with allowing subsets in "conformant Rust implementations", although in practical terms it may be functionally impossible to <em>actually</em> implement 100% of Rust, so we'd need some sort of reasonable cut-off to say that an implementation is "close enough". If we were to produce a Rust specification today, for example, I highly doubt rustc would adhere to it 100%, when you take bugs into account...</p>



<a name="272034535"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272034535" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272034535">(Feb 15 2022 at 20:38)</a>:</h4>
<p><span class="user-mention" data-user-id="257758">@Connor Horman</span> I would be very happy to see Rust specifically say "if you have extensions to Rust, you're not a compliant Rust implementation", for precisely the reason of it creating expectations that such extensions will not change when becoming part of Rust. Or, possibly, to have some process for handling such extensions.</p>



<a name="272034568"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272034568" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272034568">(Feb 15 2022 at 20:39)</a>:</h4>
<p>(And arguably, unstable features themselves are a form of superset)</p>



<a name="272034635"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272034635" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272034635">(Feb 15 2022 at 20:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272034477">said</a>:</p>
<blockquote>
<p>(Especially wrt. something like mrustc, which is explicitly designed to be a simple implementation that sidesteps the huge implementation pain of the borrow checker, while being designed to operate on code known to be well-formed, namely rustc itself)</p>
</blockquote>
<p>I do think what mrustc does makes sense, and I think we <em>should</em> have a process for explicitly permitting mrustc to do that, which is not the same as saying that we should allow borrow-checker-less implementations in general.</p>



<a name="272034793"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272034793" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272034793">(Feb 15 2022 at 20:41)</a>:</h4>
<p>As an example, I think mrustc's approach of "this exists to compile already-known-working Rust code for bootstrapping purposes" is very different than a compiler that intentionally omits borrow checking so that people can write code that does mutable aliasing, or a compiler that provides a <code>#[borrow_checker(disable)]</code>.</p>



<a name="272034998"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272034998" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272034998">(Feb 15 2022 at 20:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="239881">Josh Triplett</span> <a href="#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272034535">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> I would be very happy to see Rust specifically say "if you have extensions to Rust, you're not a compliant Rust implementation", for precisely the reason of it creating expectations that such extensions will not change when becoming part of Rust. Or, possibly, to have some process for handling such extensions.</p>
</blockquote>
<p>You'd have to define what an "extension" is. Would an implementation happening to be well-behaved in the face of some undefined behaviour be considered an extension? What about if it then documents that choice. Or if it documents the specific layout of repr(Rust) structures on that implementation (which is something I already do). <br>
Definately, I think that unstable features are the right way to go for extensions (especially wrt. well-formedness), and implementations should be discouraged from going beyond that, but I'd still consider a line such as "An implementation may nonetheless translate an ill-formed program for which it produces a diagnostic" necessary for a specification.</p>



<a name="272035038"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272035038" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272035038">(Feb 15 2022 at 20:43)</a>:</h4>
<p>right, I don't think we need to censure or denounce mrustc, we should just be clear that it's not quite "an implementation of Rust" so much as it's a "Rust-compatible code generator" or something, if we implicitly allow "implementation" (or "compiler") to suggest a full suite of static analysis that strictly characterizes the language</p>



<a name="272035145"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272035145" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272035145">(Feb 15 2022 at 20:44)</a>:</h4>
<p>(An exception would be something like the <code>compile_error!</code> macro, in the same way that C explicitly forbids implementations from translating a program that contains an <code>#error</code> directive that isn't removed by the preprocessor)</p>



<a name="272035501"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272035501" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272035501">(Feb 15 2022 at 20:47)</a>:</h4>
<blockquote>
<p>You'd have to define what an "extension" is. Would an implementation happening to be well-behaved in the face of some undefined behaviour be considered an extension? What about if it then documents that choice. Or if it documents the specific layout of repr(Rust) structures on that implementation (which is something I already do). </p>
</blockquote>
<p>If users can rely on something like that then they'd end up writing code that only runs on that particular compiler and is UB on other rustc implementations. That's a pretty horrible outcome.</p>



<a name="272035591"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272035591" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272035591">(Feb 15 2022 at 20:48)</a>:</h4>
<p>An implementation may add something behind a feature gate, but be incapable of gating all parts of the feature (see <a href="https://internals.rust-lang.org/t/reserved-syntax-should-be-lexically-valid/15743">https://internals.rust-lang.org/t/reserved-syntax-should-be-lexically-valid/15743</a>, where I noted that gating it from the lexer is not an option).</p>



<a name="272035743"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272035743" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272035743">(Feb 15 2022 at 20:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="330154">The 8472</span> <a href="#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272035501">said</a>:</p>
<blockquote>
<blockquote>
<p>You'd have to define what an "extension" is. Would an implementation happening to be well-behaved in the face of some undefined behaviour be considered an extension? What about if it then documents that choice. Or if it documents the specific layout of repr(Rust) structures on that implementation (which is something I already do). </p>
</blockquote>
<p>If users can rely on something like that then they'd end up writing code that only runs on that particular compiler and is UB on other rustc implementations. That's a pretty horrible outcome.</p>
</blockquote>
<p>There are ways arround it (in my case, you have to either explicitly compile with a particular <code>-Z</code> option you can't set from cargo, or you can detect it and fallback when unavailable, which is still portable if the detection logic is correct)<br>
Also, you can already write non-portable code:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="cp">#![feature]</span><span class="w"></span>
</code></pre></div>



<a name="272035845"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272035845" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272035845">(Feb 15 2022 at 20:50)</a>:</h4>
<p><span class="user-mention" data-user-id="257758">@Connor Horman</span> Regarding that thread, one underlying reason for not doing that is precisely that that syntax is reserved <em>so that Rust can use it</em>, and allowing it to be parsed and interpreted by a macro would potentially break our ability to use such syntax ourselves.</p>



<a name="272035919"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272035919" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272035919">(Feb 15 2022 at 20:51)</a>:</h4>
<p>If a macro can say "ooh, shiny syntax, I'm going to parse <code>foo#thing</code> in my macro", that could break our ability to create a Rust feature that uses <code>foo#thing</code>.</p>



<a name="272035950"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272035950" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272035950">(Feb 15 2022 at 20:51)</a>:</h4>
<p>Which defeats part of the purpose of having reserved syntax.</p>



<a name="272035996"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272035996" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272035996">(Feb 15 2022 at 20:51)</a>:</h4>
<p>Yeah, I noted that. Although there are ways through, for example, by reserving a set of prefixes (say, <code>__&lt;XID_Continue&gt;+</code>) for implementations.</p>



<a name="272036022"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272036022" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272036022">(Feb 15 2022 at 20:52)</a>:</h4>
<p>We're talking about stable compilers. -Z / #[feature()] is nightly stuff. Aka this may blow up in your face at any time.</p>



<a name="272036124"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272036124" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272036124">(Feb 15 2022 at 20:52)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272035996">said</a>:</p>
<blockquote>
<p>Yeah, I noted that. Although there are ways through, for example, by reserving a set of prefixes (say, <code>__&lt;XID_Continue&gt;+</code>) for implementations.</p>
</blockquote>
<p>We could do that, which then raises the question of whether we want to have syntax space reserved for implementations, which then raises the question of whether we want implementation-specific extensions at all. :)</p>



<a name="272036135"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272036135" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272036135">(Feb 15 2022 at 20:52)</a>:</h4>
<p>Some implementations don't have that distinction.<br>
I think of all of the ones that exist or are being worked on now, rustc <em>is</em> the only one that has that explicit distinction.</p>



<a name="272036211"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272036211" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272036211">(Feb 15 2022 at 20:53)</a>:</h4>
<p><span class="user-mention" data-user-id="257758">@Connor Horman</span> But that aside, I do think it'd be reasonable to consider designating some specific part of syntax space (whether using <code>#</code> or something else) for macro use, so that macros can define "keywords" and know they won't conflict with identifiers, for instance.</p>



<a name="272036217"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272036217" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272036217">(Feb 15 2022 at 20:53)</a>:</h4>
<p>I think they can't be called compliant implementations then until they have a stable-compliant mode?</p>



<a name="272036402"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272036402" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272036402">(Feb 15 2022 at 20:54)</a>:</h4>
<p>This is perfectly fine for experimental/under development compilers , but they should advertise themselves similar to nightly.</p>



<a name="272036405"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272036405" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272036405">(Feb 15 2022 at 20:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272036135">said</a>:</p>
<blockquote>
<p>Some implementations don't have that distinction.<br>
I think of all of the ones that exist or are being worked on now, rustc <em>is</em> the only one that has that explicit distinction.</p>
</blockquote>
<p>That also has to do with rustc being "where Rust is developed", and while I acknowledge the potential problems with that equivocation, it's also an accurate description.</p>



<a name="272036414"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272036414" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272036414">(Feb 15 2022 at 20:54)</a>:</h4>
<p>(lccc might include a <code>--disable-unstable</code> option, but that comes with issues, like needing to use a previously built version of the compiler to build the stdlib, because I don't want the RUSTC_BOOTSTRAP issue)</p>



<a name="272036506"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272036506" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272036506">(Feb 15 2022 at 20:55)</a>:</h4>
<p>(rustc is also unique among the group that I'm aware of, in that it contemplates binary distribution as the primary form of release, which enables the nightly/beta/stable distinction)</p>



<a name="272036735"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272036735" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272036735">(Feb 15 2022 at 20:57)</a>:</h4>
<p>well, it also has the advantage that you can't link nightly-built libs to stable</p>



<a name="272036956"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272036956" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272036956">(Feb 15 2022 at 20:59)</a>:</h4>
<p>TBH, the most I'd want to see in the spec related to stable is that</p>
<blockquote>
<p>The <code>#[feature]</code> attribute may be applied to a crate, and takes one or more identifiers, separated by commas. Whether or not the <code>#[feature]</code> attribute is supported is <em>implementation-defined</em> and the identifiers accepted by the attribute and their effects are unspecified.</p>
</blockquote>



<a name="272037198"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272037198" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272037198">(Feb 15 2022 at 21:00)</a>:</h4>
<p>So, there are two separate aspects of that that might need to be treated independently.</p>



<a name="272037215"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272037215" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272037215">(Feb 15 2022 at 21:00)</a>:</h4>
<p>One is  "you can be a compliant implementation whether or not you implement nightly Rust", which I do think should be true.</p>



<a name="272037277"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272037277" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272037277">(Feb 15 2022 at 21:01)</a>:</h4>
<p>It is true in fact, stable rustc (w/o <code>RUSTC_BOOTSTRAP</code>) is considered an implementation of rust, after all.</p>



<a name="272037295"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272037295" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272037295">(Feb 15 2022 at 21:01)</a>:</h4>
<p>The other is "can other implementations define and implement arbitrary nightly features", which needs thought, and <em>if</em> we support that it'd need both namespacing and perhaps something more specific than "effects are unspecified".</p>



<a name="272037451"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272037451" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272037451">(Feb 15 2022 at 21:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272037277">said</a>:</p>
<blockquote>
<p>It is true in fact, stable rustc (w/o <code>RUSTC_BOOTSTRAP</code>) is considered an implementation of rust, after all.</p>
</blockquote>
<p>We don't yet have a definition of "an implementation of Rust", so "it is true" isn't yet established. But yes, I think that's a demonstration that it <em>should</em> be true if and when we have a definition.</p>



<a name="272037486"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272037486" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272037486">(Feb 15 2022 at 21:02)</a>:</h4>
<p>Certainly. I'd love to see namespaced features, currently I have an ugly <code>lccc_</code> prefix. But rustc already does define and implement arbitrary nightly features, and I definately already do and use them in the standard library.</p>



<a name="272037954"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272037954" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272037954">(Feb 15 2022 at 21:05)</a>:</h4>
<p>Also, I'd say "The effects are unspecified" perfectly describes the situtation as-is, and the situtation I'd ideally have.<br>
First, being unspecified doesn't prohibit documention, it merely doesn't mandate it.<br>
Second, unspecified can be constrained. It's not free-for-all. Well known features could be included in the spec, or separated out as a "If you use these features, you should match these results".</p>



<a name="272038311"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272038311" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272038311">(Feb 15 2022 at 21:08)</a>:</h4>
<p>I'm thinking about constraints like "features can't break the behavior of other mandatory aspects of the spec". e.g. "you can't have a feature to turn off the borrow checker".</p>



<a name="272038371"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272038371" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272038371">(Feb 15 2022 at 21:08)</a>:</h4>
<p>Not trying to be too specific here, just thinking in general that there might need to be constraints on "features can do anything".</p>



<a name="272038490"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272038490" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272038490">(Feb 15 2022 at 21:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272037486">said</a>:</p>
<blockquote>
<p>But rustc already does define and implement arbitrary nightly features, and I definately already do and use them in the standard library.</p>
</blockquote>
<p>I think it's important to distinguish the degree to which "rustc defines nightly features" and the degree to which "Rust defines nightly features". We have features that have been through an RFC or similar process, and we also have random internal features that haven't. The latter have been a regular source of problems.</p>



<a name="272038519"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272038519" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272038519">(Feb 15 2022 at 21:10)</a>:</h4>
<p>That would be a valid constraint on the unspecified behaviour, but seeing as it's already designed to alter the well-formedness of a program, that would be a very difficult constraint to define.</p>



<a name="272038621"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272038621" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272038621">(Feb 15 2022 at 21:10)</a>:</h4>
<p>Fully acknowledged. Specifications are not easy.</p>



<a name="272038648"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272038648" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272038648">(Feb 15 2022 at 21:10)</a>:</h4>
<p><span class="user-mention silent" data-user-id="239881">Josh Triplett</span> <a href="#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272038490">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272037486">said</a>:</p>
<blockquote>
<p>But rustc already does define and implement arbitrary nightly features, and I definately already do and use them in the standard library.</p>
</blockquote>
<p>I think it's important to distinguish the degree to which "rustc does" and the degree to which "Rust does". We have features that have been through an RFC or similar process, and we also have random internal features that haven't. The latter have been a regular source of problems.</p>
</blockquote>
<p>Yes. I will note that I mostly consistently use Rust to mean the language, and rustc to mean the implementation. If I'm saying rustc does x, I'm pointing specifically to the rustc implementation in fact.</p>



<a name="272038759"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272038759" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272038759">(Feb 15 2022 at 21:11)</a>:</h4>
<p>I've noticed that. :)<br>
I tend to also use "Rust" to encompass "the parts of rustc that I would vaguely imagine to be/define part of Rust", which is a fuzzy line.</p>



<a name="272038981"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272038981" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272038981">(Feb 15 2022 at 21:13)</a>:</h4>
<p>It's possible to debate the merits of "random internal features" for sure, but I'd argue they're necessary to provide much of what is specified. For example, <code>#[lang]</code> (and likewise <code>core::intrinsics</code>) is easily something I can point to as "this is necessarily a private detail of the implementation".</p>



<a name="272038984"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272038984" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272038984">(Feb 15 2022 at 21:13)</a>:</h4>
<p>In some ways, Rust is also its development process, not just the resulting language. So, for instance, the language team defines "Rust", and doesn't just define "rustc", even though we work on both.</p>



<a name="272039076"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272039076" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272039076">(Feb 15 2022 at 21:14)</a>:</h4>
<p>re: extensions, it wouldn't even be terrible if the specification forbade implementations from offering any extensions at all that weren't specifically covered under implementation-defined behavior, with a specific exception carved-out for rustc. Unfair to some degree, certainly, but I don't think splitting up that sort of experimentation across multiple implementations actually buys you anything, rustc's process for adding things already has plenty of community buy-in and bureaucratic process (and would presumably have much <em>more</em> process if there were  actually a professional specification)</p>



<a name="272039082"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272039082" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272039082">(Feb 15 2022 at 21:14)</a>:</h4>
<p><span class="user-mention" data-user-id="257758">@Connor Horman</span> That's something I'd like to fix. FWIW, I personally share your distaste for "lang items".</p>



<a name="272039161"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272039161" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272039161">(Feb 15 2022 at 21:14)</a>:</h4>
<p>And to the extent those are required, I <em>do</em> think we could make them stable. For instance, if the compiler <em>needs</em> to know how to desugar something that needs to reference a library thing, we should have a stable way of saying "this is the library thing in question".</p>



<a name="272039214"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272039214" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272039214">(Feb 15 2022 at 21:15)</a>:</h4>
<p>(e.g. <code>IntoIterator</code> or the internals of <code>try</code>.)</p>



<a name="272039291"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272039291" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272039291">(Feb 15 2022 at 21:15)</a>:</h4>
<p><span class="user-mention" data-user-id="256342">@bstrie</span> While I wouldn't <em>object</em> to special-casing rustc, I also think that would not go over well as a standards process. ;)</p>



<a name="272039486"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272039486" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272039486">(Feb 15 2022 at 21:17)</a>:</h4>
<p>Eh... I can point to several occurances where I've both added or removed lang items in lccc's standard library,<br>
My philosphy is, "If I can do it another way, it's not a lang item." UnsafeCell is a great example of where I've moved magic by 3 lines as it were (and <code>Box</code> is an even better example).</p>



<a name="272039548"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272039548" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272039548">(Feb 15 2022 at 21:17)</a>:</h4>
<p><span class="user-mention" data-user-id="256342">@bstrie</span> That's going to ultimately be a hazard we have to deal with. "Rust" is tied to "Rust development process" which is tied to "rustc development process" which is tied to "rustc" (among many other things Rust and rustc share). We don't want to have a "standard" in name only, but we <em>also</em> don't want to break the important parts of that link (e.g. "defining new features of Rust via the Rust process, not by random downstream extensions that get widely adopted and used to force us to not break them").</p>



<a name="272039616"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272039616" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272039616">(Feb 15 2022 at 21:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="239881">Josh Triplett</span> <a href="#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272039291">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="256342">bstrie</span> While I wouldn't <em>object</em> to special-casing rustc, I also think that would not go over well as a standards process. ;)</p>
</blockquote>
<p>Yes, I would object with all of the weight my opinion carries against special-casing any particular implementation, but least of all rustc.</p>



<a name="272039763"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272039763" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272039763">(Feb 15 2022 at 21:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="239881">Josh Triplett</span> <a href="#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272039548">said</a>:</p>
<blockquote>
<p>We don't want to have a "standard" in name only, but we <em>also</em> don't want to break the important parts of that link (e.g. "defining new features of Rust via the Rust process, not by random downstream extensions that get widely adopted and used to force us to not break them").</p>
</blockquote>
<p>In particular, I bring up the latter half of this fairly often because it's the portion that tends to come up often even <em>without</em> a standard, but I do care about the first half of this as well. If we're going to have a standard that says "whatever rustc does", that's not a standard, and we might as well not have one. Which is part of why sometimes I wonder if we <em>should</em> have one or not. :)</p>



<a name="272041177"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272041177" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272041177">(Feb 15 2022 at 21:31)</a>:</h4>
<p>I'll argue that the value in a standard is that the text of a standard can be assumed to be deliberate, whereas the code in a reference implementation like rustc can easily be assumed to be incidental. In that sense, I'd much rather read a normative specification than read the source of rustc as a way of determining what the "language" "should" be doing, and users of the language can benefit from this even if there's only one implementation. I think there may be benefits to having more than one implementation (and perhaps detriments, to be sure), and a specification can facilitate that, but I ultimately disagree that "having/facilitating multiple implementations" is the only impetus for having a normative specification. Which is why, if we do have more than one, I don't mind rustc being privileged/"first among equals". Competition can be achieved via the standards process itself, not via competition between the implementations, and then the purpose of rustc's nightly channel/feature flags is just the prototyping phase of the standards track.</p>



<a name="272041239"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272041239" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272041239">(Feb 15 2022 at 21:31)</a>:</h4>
<p>Maybe we could say that alternative rust compilers can be compliant even if they have extensions for as long as they don't allow those extensions on the "stable"/"preferred"/"suitable for production usage" release channel just like rustc.</p>



<a name="272041394"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272041394" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272041394">(Feb 15 2022 at 21:32)</a>:</h4>
<p><span class="user-mention" data-user-id="133247">@bjorn3</span> That assumes other implementations <em>have</em> a "stable"/"nightly" distinction, and don't succumb to pressure to not have one. (Such pressure being <em>higher</em> for other implementations out of temptation to have it be a differentiating factor from rustc.)</p>



<a name="272041455"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272041455" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272041455">(Feb 15 2022 at 21:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="256342">bstrie</span> <a href="#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272041177">said</a>:</p>
<blockquote>
<p>I'll argue that the value in a standard is that the text of a standard can be assumed to be deliberate, whereas the code in a reference implementation like rustc can easily be assumed to be incidental. In that sense, I'd much rather read a normative specification than read the source of rustc as a way of determining what the "language" "should" be doing, and users of the language can benefit from this even if there's only one implementation.</p>
</blockquote>
<p>I completely agree with this, but that's one major reason why I'm saying the standard shouldn't <em>defer</em> to rustc, rather than <em>deliberately documenting</em> rustc.</p>



<a name="272041590"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272041590" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272041590">(Feb 15 2022 at 21:34)</a>:</h4>
<p>I would prefer to have one layer of indirection here. For instance, the standard could reference and require the use of certain Rust development processes, and those Rust development processes may include trying things out in rustc, but the Rust development processes aren't defined <em>in</em> the standard, and "must do xyz in rustc" isn't directly <em>in</em> the standard.</p>



<a name="272041630"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272041630" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272041630">(Feb 15 2022 at 21:35)</a>:</h4>
<p>For example gccrs could disable extensions when merging into upstream gcc, leaving it enabled on the gccrs fork. I presume distros ate unlikely to package the gccrs fork rather than upstream gcc.</p>



<a name="272041647"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272041647" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272041647">(Feb 15 2022 at 21:35)</a>:</h4>
<p>(and to be clear, there are <em>some</em> things that can be improved via competition between implementations, like error messages, performance, etc. Just not anything semantically-visible/subject to backwards-compatibility)</p>



<a name="272041678"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272041678" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272041678">(Feb 15 2022 at 21:35)</a>:</h4>
<p>I've noted that none of the ones I'm aware of have that distinction. lccc really can't support stable/nightly distinction and I likewise can't see that gcc-rs is capable of the same, because the distribution method is source. I contemplate a "Stable Release" in lccc being <code>git tag release-1.x &amp;&amp; tar * | gzip &gt; lccc-1.x.tar.gz</code></p>



<a name="272041746"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272041746" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272041746">(Feb 15 2022 at 21:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="133247">bjorn3</span> <a href="#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272041630">said</a>:</p>
<blockquote>
<p>For example gccrs could disable extensions when merging into upstream gcc, leaving it enabled on the gccrs fork. I presume distros ate unlikely to package the gccrs fork rather than upstream gcc.</p>
</blockquote>
<p>How would you build the standard library using gccrs when merged, then?</p>



<a name="272041784"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272041784" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272041784">(Feb 15 2022 at 21:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272041746">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="133247">bjorn3</span> <a href="#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272041630">said</a>:</p>
<blockquote>
<p>For example gccrs could disable extensions when merging into upstream gcc, leaving it enabled on the gccrs fork. I presume distros ate unlikely to package the gccrs fork rather than upstream gcc.</p>
</blockquote>
<p>How would you build the standard library using gccrs when merged, then?</p>
</blockquote>
<p>Don't use unstable features in it. :)</p>



<a name="272041804"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272041804" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272041804">(Feb 15 2022 at 21:36)</a>:</h4>
<p>Yeah, that's happening.</p>



<a name="272041812"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272041812" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272041812">(Feb 15 2022 at 21:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272041678">said</a>:</p>
<blockquote>
<p>I've noted that none of the ones I'm aware of have that distinction. lccc really can't support stable/nightly distinction and I likewise can't see that gcc-rs is capable of the same, because the distribution method is source. I contemplate a "Stable Release" in lccc being <code>git tag release-1.x &amp;&amp; tar * | gzip &gt; lccc-1.x.tar.gz</code></p>
</blockquote>
<p>It's still possible to have such a distinction, if you make that change on a release branch before shipping a release.</p>



<a name="272041851"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272041851" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272041851">(Feb 15 2022 at 21:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272041804">said</a>:</p>
<blockquote>
<p>Yeah, that's happening.</p>
</blockquote>
<p>It actually is something that we're working to improve. <em>Currently</em>, not hypothetically.</p>



<a name="272041865"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272041865" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272041865">(Feb 15 2022 at 21:37)</a>:</h4>
<p>alternatively, split out all the lang-item-using parts of std into a new "liblang" that's below libcore :)</p>



<a name="272041894"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272041894" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272041894">(Feb 15 2022 at 21:37)</a>:</h4>
<p>RIght, but then you run into the same problem "How to build the standard library". At the very least, <code>libcore</code> necessarily has to interact with the compiler in compiler specific ways.</p>



<a name="272041911"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272041911" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272041911">(Feb 15 2022 at 21:37)</a>:</h4>
<blockquote>
<p>How would you build the standard library using gccrs when merged, then?</p>
</blockquote>
<p>The same way rustc does it (env var override) or as part of the build system by building an additional binary for building the standard library which is discarded.</p>



<a name="272041921"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272041921" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272041921">(Feb 15 2022 at 21:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="256342">bstrie</span> <a href="#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272041865">said</a>:</p>
<blockquote>
<p>alternatively, split out all the lang-item-using parts of std into a new "liblang" that's below libcore :)</p>
</blockquote>
<p>That just moves the goal</p>



<a name="272041925"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272041925" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272041925">(Feb 15 2022 at 21:38)</a>:</h4>
<p><span class="user-mention" data-user-id="256342">@bstrie</span> I think the lang-item bits could potentially be stabilized. But also, we could potentially make alloc and std shareable and non-nightly more easily than core, and that's an <em>improvement</em>.</p>



<a name="272042023"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272042023" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272042023">(Feb 15 2022 at 21:38)</a>:</h4>
<p>just give me a future where core/alloc/std is one crate configured via cargo features and I'll be happy :P</p>



<a name="272042061"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272042061" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272042061">(Feb 15 2022 at 21:39)</a>:</h4>
<p>How about a future where it's one or more crates <em>on crates.io</em>? :)</p>



<a name="272042105"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272042105" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272042105">(Feb 15 2022 at 21:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="239881">Josh Triplett</span> <a href="#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272041925">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="256342">bstrie</span> I think the lang-item bits could potentially be stabilized. But also, we could potentially make alloc and std shareable and non-nightly more easily than core, and that's an <em>improvement</em>.</p>
</blockquote>
<p>I've noted above why I don't think so: at that level, you need to interface directly with the compiler, and compilers will have different ways of doing that, by way of being different internally.</p>



<a name="272042108"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272042108" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272042108">(Feb 15 2022 at 21:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="239881">Josh Triplett</span> <a href="#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272042061">said</a>:</p>
<blockquote>
<p>How about a future where it's one or more crates <em>on crates.io</em>? :)</p>
</blockquote>
<p>(Not expecting that any time <em>soon</em>, but striving will get us some nice things.)</p>



<a name="272042111"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272042111" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272042111">(Feb 15 2022 at 21:39)</a>:</h4>
<p>but that implies that we'll stabilize scary things like auto traits...</p>



<a name="272042215"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272042215" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272042215">(Feb 15 2022 at 21:40)</a>:</h4>
<p><span class="user-mention" data-user-id="257758">@Connor Horman</span> We have a variety of uses of lang items, some of which make more sense than others.</p>



<a name="272042248"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272042248" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272042248">(Feb 15 2022 at 21:40)</a>:</h4>
<p>Having a lang item so that the compiler can find a specific type definition, because it's needed for desugaring, seems easy to stabilize.</p>



<a name="272042275"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272042275" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272042275">(Feb 15 2022 at 21:40)</a>:</h4>
<p>I think libstd/liballoc could reasonably be made unstable. libcore, or some liblang that provides that primitive interface... not so much, imo.</p>



<a name="272042280"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272042280" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272042280">(Feb 15 2022 at 21:41)</a>:</h4>
<p>And we should ideally make it so that we don't <em>need</em> lang items for the <code>impl</code> blocks on built-in types, for instance.</p>



<a name="272042346"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272042346" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272042346">(Feb 15 2022 at 21:41)</a>:</h4>
<p>e.g. we really shouldn't need <code>slice_u8_alloc</code> as a lang item.</p>



<a name="272042424"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272042424" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272042424">(Feb 15 2022 at 21:42)</a>:</h4>
<p>Do you mean stable <span class="user-mention" data-user-id="257758">@Connor Horman</span>?</p>



<a name="272042526"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272042526" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272042526">(Feb 15 2022 at 21:43)</a>:</h4>
<p>we might be getting off-topic for #t-lang, but one reason why not to lean into the existing core/alloc/std split is that I can think of a dozen different configurable "cargo features" for std and having an individual crate for each one would be a nightmare for coherence</p>



<a name="272042583"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272042583" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272042583">(Feb 15 2022 at 21:44)</a>:</h4>
<p>Also, some standard libraries may have reciprocal requirements. For example, in lccc, I specify that the 3 base standard library crates are named <code>std</code> in mangling, and that's definately something that will be relied upon internally. Like <code>#[global_allocator]</code> that defines a symbol that matches the mangled name of a stdlib symbol that's imported.</p>



<a name="272042588"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272042588" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272042588">(Feb 15 2022 at 21:44)</a>:</h4>
<p>The lang items for builtin type impls are necessary not just for coherence, but also for finding the list of implementations on specific types. For the former I tried introducing a coherence loophole attribute once. For the latter I think any replacement will lead to a perf regression.</p>



<a name="272042628"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272042628" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272042628">(Feb 15 2022 at 21:44)</a>:</h4>
<p><span class="user-mention" data-user-id="133247">@bjorn3</span> Can you clarify what you mean by "for finding the list of implementations on specific types"?</p>



<a name="272042641"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272042641" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272042641">(Feb 15 2022 at 21:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="133247">bjorn3</span> <a href="#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272042424">said</a>:</p>
<blockquote>
<p>Do you mean stable <span class="user-mention silent" data-user-id="257758">Connor Horman</span>?</p>
</blockquote>
<p>Yes.</p>



<a name="272042677"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272042677" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272042677">(Feb 15 2022 at 21:45)</a>:</h4>
<p>If I do <code>a.foo()</code> it needs to find all impls on the type of <code>a</code> to find one which contains the method <code>foo</code>.</p>



<a name="272042692"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272042692" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272042692">(Feb 15 2022 at 21:45)</a>:</h4>
<p><span class="user-mention" data-user-id="133247">@bjorn3</span> In particular, is it necessary to have a <em>different</em> lang item for <em>each</em> impl block, or would it suffice to have one lang item that could be applied to multiple such blocks, and collect them when compiling?</p>



<a name="272042696"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272042696" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272042696">(Feb 15 2022 at 21:45)</a>:</h4>
<p>I think the keyword to search for is "assemble".</p>



<a name="272042830"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272042830" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272042830">(Feb 15 2022 at 21:46)</a>:</h4>
<p>Each lang item is tied to a single def id. The code to search for builtin type impls looks at the lang item specific to the type it needs to have impls for.</p>



<a name="272042930"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272042930" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272042930">(Feb 15 2022 at 21:47)</a>:</h4>
<p>Having a different mechanism for these impls would be possible, but it would likely require searching in every crate of the crate graph which would be a perf regression.</p>



<a name="272043002"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272043002" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272043002">(Feb 15 2022 at 21:48)</a>:</h4>
<p>What makes built-in types different than non-built-in types in that way?</p>



<a name="272043033"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272043033" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272043033">(Feb 15 2022 at 21:48)</a>:</h4>
<p>To what degree does the same logic apply to making, say, Vec faster?</p>



<a name="272043061"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272043061" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272043061">(Feb 15 2022 at 21:48)</a>:</h4>
<p>builtin types are defined by the compiler, and can't be traced to a particular crate that defines them.</p>



<a name="272043076"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272043076" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272043076">(Feb 15 2022 at 21:49)</a>:</h4>
<p>Exactly!</p>



<a name="272043258"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272043258" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272043258">(Feb 15 2022 at 21:51)</a>:</h4>
<p>But yes, I don't think that stabilizing the surface of the raw "compiler-stdlib interface" is a good idea, though reducing the scope of that surface is, and constraining it to <code>libcore</code>. But you'll always have different interfaces by way of having different compilers.<br>
Also, <code>libproc_macro</code> is a whole other story, and basically has to be compiler-specific.</p>



<a name="272043266"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272043266" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272043266">(Feb 15 2022 at 21:51)</a>:</h4>
<p>That explains why we need <em>a</em> lang item. But what would happen if we just treated <code>#[lang = "u32"] type u32;</code> as the definition of the type <code>u32</code>, in the crate it appears in, and then <code>impl u32 {}</code> blocks as not special and just associated with that type definition?</p>



<a name="272043310"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272043310" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272043310">(Feb 15 2022 at 21:51)</a>:</h4>
<p>(I'm aware that we have some cases of coherence issues, where a type has impl blocks in both core and alloc. That aside, though?)</p>



<a name="272043367"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272043367" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272043367">(Feb 15 2022 at 21:52)</a>:</h4>
<p>I think that would be a valid and viable implementation.</p>



<a name="272043389"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272043389" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272043389">(Feb 15 2022 at 21:52)</a>:</h4>
<p>That could work I think.</p>



<a name="272043413"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272043413" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272043413">(Feb 15 2022 at 21:52)</a>:</h4>
<p>Thanks, that's what I was trying to figure out.</p>



<a name="272043434"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272043434" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272043434">(Feb 15 2022 at 21:52)</a>:</h4>
<p>That's the <em>kind</em> of change that seems like it'd be an improvement to the lang-libs interface.</p>



<a name="272043435"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272043435" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272043435">(Feb 15 2022 at 21:52)</a>:</h4>
<p>Although, the type still needs to be available unqualified in every namespace.</p>



<a name="272043481"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272043481" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272043481">(Feb 15 2022 at 21:53)</a>:</h4>
<p>(Prelude doesn't do it, you can still use builtin types w/ <code>#![no_implicit_prelude]</code>)</p>



<a name="272043527"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272043527" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272043527">(Feb 15 2022 at 21:53)</a>:</h4>
<p>In an ideal world, perhaps that could be just another kind of more primitive prelude, but I get why it likely needs a special case. That special case doesn't seem like an <em>issue</em> though, if we have the one lang item.</p>



<a name="272043624"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272043624" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272043624">(Feb 15 2022 at 21:54)</a>:</h4>
<p>This is the code I was refering to by the way: <a href="https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler/rustc_typeck/src/check/method/probe.rs#L653">https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler/rustc_typeck/src/check/method/probe.rs#L653</a></p>



<a name="272043692"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272043692" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272043692">(Feb 15 2022 at 21:55)</a>:</h4>
<p><span class="user-mention" data-user-id="133247">@bjorn3</span> Yeah, I just recently touched that code in a PR. Doesn't mean I understood <em>why</em> we needed that approach. :)</p>



<a name="272043761"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272043761" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272043761">(Feb 15 2022 at 21:55)</a>:</h4>
<p>In any case, I'd argue that this proves my point of different implementations having different raw interfaces: one implementation could choose what rustc currently does, and one implementation could choose the other approach, depending on which is more reasonable for it's structure.</p>



<a name="272044099"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272044099" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272044099">(Feb 15 2022 at 21:58)</a>:</h4>
<p>I think what I'm getting at is that it might not be unreasonable to attempt to standardize parts of that interface. Doesn't mean we're prepared to commit to that <em>entire</em> interface being stable, but things like <code>#[lang = "add"]</code> and <code>#[lang = "copy"]</code> seem feasible to stabilize.</p>



<a name="272044129"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272044129" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272044129">(Feb 15 2022 at 21:58)</a>:</h4>
<p>Or <code>#[lang = "bool"]</code>.</p>



<a name="272044138"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272044138" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272044138">(Feb 15 2022 at 21:58)</a>:</h4>
<p>And for certain desugarings: What's do say that implementations will desugar the same constructs the same way. They only have to operate <em>as-if</em> they were.</p>



<a name="272044391"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272044391" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272044391">(Feb 15 2022 at 22:00)</a>:</h4>
<p>If the types and traits in question are public, then that as-if is sufficiently constraining that the lang items are still necessary.</p>



<a name="272044427"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272044427" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272044427">(Feb 15 2022 at 22:01)</a>:</h4>
<p>(And if the types and traits <em>aren't</em> exposed then the lang items may not need to be stable.)</p>



<a name="272044713"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272044713" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272044713">(Feb 15 2022 at 22:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="239881">Josh Triplett</span> <a href="#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272044099">said</a>:</p>
<blockquote>
<p>I think what I'm getting at is that it might not be unreasonable to attempt to standardize parts of that interface. Doesn't mean we're prepared to commit to that <em>entire</em> interface being stable, but things like <code>#[lang = "add"]</code> and <code>#[lang = "copy"]</code> seem feasible to stabilize.</p>
</blockquote>
<p>I'd point to this: <a href="https://github.com/LightningCreations/lccc/blob/main/lcrust/libraries/libcore/src/intrinsics.rs">https://github.com/LightningCreations/lccc/blob/main/lcrust/libraries/libcore/src/intrinsics.rs</a>.<br>
In the case where I'm pulling in from the <code>__lccc::builtins::rust</code> namespace, I'm just desugaring <code>extern "rust-intrinsic"</code> manually. In other cases, I'm pulling in from the C builtin namespace which isn't normally available to rust code (but welcome to different implementations do different things, and lccc's fully-qualified intrinsic names).</p>



<a name="272044735"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272044735" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272044735">(Feb 15 2022 at 22:03)</a>:</h4>
<p>Is there an implied expectation there that different implementations would share the same <code>core</code>, <span class="user-mention" data-user-id="239881">@Josh Triplett</span>?  That doesn't seem obvious, to me.</p>



<a name="272044856"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272044856" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272044856">(Feb 15 2022 at 22:04)</a>:</h4>
<p>I don't think stabilizing simple lang items makes sense. Any rust program needs to have the panic related lang items defined. The only stable provider of them is libcore which defines all simple lang items too. Stabilizing the panic related lang items is something I hope won't happen in the conceivable future as they are still rather in flux and have some less nice properties like depnding on <code>core::fmt</code> (which is unsuitable for microcontrollers and other constrained environments)</p>



<a name="272045119"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272045119" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272045119">(Feb 15 2022 at 22:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="125270">scottmcm</span> <a href="#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272044735">said</a>:</p>
<blockquote>
<p>Is there an implied expectation there that different implementations would share the same <code>core</code>, <span class="user-mention silent" data-user-id="239881">Josh Triplett</span>?  That doesn't seem obvious, to me.</p>
</blockquote>
<p>More an expectation that they <em>could</em> if they don't have a specific reason to reimplement it.</p>



<a name="272045281"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272045281" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272045281">(Feb 15 2022 at 22:08)</a>:</h4>
<p>(Which goes slightly along with an expectation that they <em>should</em> if they don't have a really <em>good</em> reason to reimplement it. ;) )</p>



<a name="272045851"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272045851" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272045851">(Feb 15 2022 at 22:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="239881">Josh Triplett</span> <a href="#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272044391">said</a>:</p>
<blockquote>
<p>If the types and traits in question are public, then that as-if is sufficiently constraining that the lang items are still necessary.</p>
</blockquote>
<p>Not necessarily. While experimenting on loop desugaring I also tried a few approaches that didn't use IntoIterator and replaced IntoIterator::into_iter in the desugaring with separate function which eventually called IntoIterator::into_iter. The lang item currently requires it to be a trait method without body. Had to change the compiler to change the desugaring.</p>



<a name="272045983"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272045983" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272045983">(Feb 15 2022 at 22:15)</a>:</h4>
<p>And if we ever want to opportunistically desugar into try_fold instead, well, new lang item.</p>



<a name="272046476"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272046476" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272046476">(Feb 15 2022 at 22:19)</a>:</h4>
<p>I guess a specification could leave some wiggle room by allowing indirection and non-default implementations. I.e. if Iterator::next is the lang item then it could allow calling an Iterator::foo instead as long as its default implementation results in next() being called. A non-default lang implementation would be observable in overridden code, so the as-if rule wouldn't be sufficient.</p>



<a name="272046506"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272046506" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272046506">(Feb 15 2022 at 22:19)</a>:</h4>
<p>FYI For compiler generated function bodies we generally write the function as a function calling itself.</p>



<a name="272046557"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272046557" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272046557">(Feb 15 2022 at 22:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="239881">Josh Triplett</span> <a href="#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272045119">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="125270">scottmcm</span> <a href="#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272044735">said</a>:</p>
<blockquote>
<p>Is there an implied expectation there that different implementations would share the same <code>core</code>, <span class="user-mention silent" data-user-id="239881">Josh Triplett</span>?  That doesn't seem obvious, to me.</p>
</blockquote>
<p>More an expectation that they <em>could</em> if they don't have a specific reason to reimplement it.</p>
</blockquote>
<p>FTR, most currently do. Both mrustc and gcc-rs reuse rustc's stdlib. lccc is the odd one out here, because I decided I definately was not going to track nightly rustc.</p>



<a name="272046645"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272046645" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272046645">(Feb 15 2022 at 22:20)</a>:</h4>
<p>Also gave me opportunity to explore certain changes that aren't publicly observable, for example, fixing TypeId.</p>



<a name="272046764"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272046764" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272046764">(Feb 15 2022 at 22:21)</a>:</h4>
<p>gcc-rs is not yet at the point where reusing rustc's libcore would be possible at all. Currently it is limited to single crate usage as no crate metadata serialization has been implemented. It does use the same lang items for operator traits though.</p>



<a name="272046970"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272046970" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272046970">(Feb 15 2022 at 22:23)</a>:</h4>
<p>Fair, in the latter two cases, it's more accurate to say, that's the intention (in the case of gcc-rs, at least as of the last time I read the website)</p>



<a name="272047146"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272047146" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272047146">(Feb 15 2022 at 22:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="330154">The 8472</span> <a href="#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272046476">said</a>:</p>
<blockquote>
<p>I guess a specification could leave some wiggle room by allowing indirection and non-default implementations. I.e. if Iterator::next is the lang item then it could allow calling an Iterator::foo instead as long as its default implementation results in next() being called. A non-default lang implementation would be observable in overridden code, so the as-if rule wouldn't be sufficient.</p>
</blockquote>
<p>Well, if <code>Iterator::foo</code> is unstable, then it wouldn't be observable in terms of the rust spec.</p>



<a name="272047396"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272047396" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272047396">(Feb 15 2022 at 22:27)</a>:</h4>
<p>Doesn't help if we want it to be stable so that user code can implement a better alternative to repeatedly calling <code>next</code>. <code>foo</code> would likely be <code>try_fold</code> or something similar.</p>



<a name="272047527"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272047527" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272047527">(Feb 15 2022 at 22:28)</a>:</h4>
<p>I mean right now I'm going for unstable methods (get_unchecked) but switching between next() and try_fold() depending on whether the body contains control flow is another approach that has been discussed multiple times.</p>



<a name="272047580"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272047580" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272047580">(Feb 15 2022 at 22:29)</a>:</h4>
<p>Well, I guess if it's standardized then an extension would just have go through the standards process?</p>



<a name="272047677"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272047677" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272047677">(Feb 15 2022 at 22:30)</a>:</h4>
<p>One thing I think we should capture: "standards process" does not need to mean "thing that takes time measured in years".</p>



<a name="272047690"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272047690" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272047690">(Feb 15 2022 at 22:30)</a>:</h4>
<p>Just because some languages work that way does not mean we have to.</p>



<a name="272047751"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272047751" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272047751">(Feb 15 2022 at 22:31)</a>:</h4>
<p>Yeah. One thing I do like about rust is that features can be added quickly. Although, in some cases, far <em>too</em> quickly. And also, far <em>too</em> slowly.</p>



<a name="272047753"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272047753" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272047753">(Feb 15 2022 at 22:31)</a>:</h4>
<p>I think our response to people concerned that having something in the standard would slow down iteration should be for us to speed up the iteration time of the standard. :)</p>



<a name="272047784"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272047784" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272047784">(Feb 15 2022 at 22:31)</a>:</h4>
<p><em>cough</em> Never <em>cough</em></p>



<a name="272047868"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272047868" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272047868">(Feb 15 2022 at 22:32)</a>:</h4>
<p>I like the idea of having the rust specification just be an ever-evolving document, that is changed as features are stabilized, and then released on the same schedule that is already used.</p>



<a name="272047976"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272047976" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272047976">(Feb 15 2022 at 22:33)</a>:</h4>
<p><em>nod</em></p>



<a name="272047979"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272047979" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272047979">(Feb 15 2022 at 22:33)</a>:</h4>
<p>Yes please.</p>



<a name="272048049"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272048049" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272048049">(Feb 15 2022 at 22:34)</a>:</h4>
<p>I like the approach used by the HTML5 "living standard".</p>



<a name="272048056"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272048056" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272048056">(Feb 15 2022 at 22:34)</a>:</h4>
<p>I think one of the main things of targets is that it should be possible to say, add support for a target which requires propietary code to be linked, or other such things, and have that still Rust.</p>



<a name="272048066"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272048066" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272048066">(Feb 15 2022 at 22:34)</a>:</h4>
<p>Yeah... who wants to be the safari?</p>



<a name="272048091"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272048091" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272048091">(Feb 15 2022 at 22:34)</a>:</h4>
<p>&lt;opinionated&gt;(The real HTML5 standard by WHATWG, not the snapshot-of-other-people's-work by W3C.)&lt;/opinionated&gt;</p>



<a name="272048157"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272048157" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272048157">(Feb 15 2022 at 22:35)</a>:</h4>
<p>Oh, we already have <a href="http://caniuse.rs">caniuse.rs</a></p>



<a name="272048168"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272048168" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272048168">(Feb 15 2022 at 22:35)</a>:</h4>
<p>In fact, the way I'd personally implement having a rust specification, after completing the work of specifying rust as-is, would be to stabilize a feature, normative documentation needs to be added to the specification. That would be a prerequisite (or part of) the stabilization report.</p>



<a name="272048366"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272048366" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272048366">(Feb 15 2022 at 22:37)</a>:</h4>
<p>(I say part of because it seems like functionally, stabilizing a feature from a T-lang or T-libs-api perspective is adding it to the formal language/standard library (resp.), so it could be argued that what <em>should</em> be FCP'd is the actual specification of the feature, rather than the stabilization of a particular implementation)</p>



<a name="272048492"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272048492" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272048492">(Feb 15 2022 at 22:38)</a>:</h4>
<p>Yeah, I was thinking about how C# does their standardization process, and I think my ideal process would be a living standard owned by the Rust foundation, and then every x years we submit it to ISO/whatever as a kind of LTS Rust/edition/whatever.</p>



<a name="272048573"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272048573" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272048573">(Feb 15 2022 at 22:40)</a>:</h4>
<p>Nope to ISO. Ton of nopes to ISO. I don't need another ISO standard to implement, I already have upwards of $700 worth (and I'm avoiding buying those as well).</p>



<a name="272048676"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272048676" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272048676">(Feb 15 2022 at 22:41)</a>:</h4>
<p>TBH, I don't see a need for the spec to be anything other than the documentation provided by T-lang and T-libs-api jointly that says "This is what Rust is". I don't see a need for there to be a formal body backing that document other than Rust itself (and the Rust Foundation).</p>



<a name="272048698"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272048698" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Urgau <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272048698">(Feb 15 2022 at 22:41)</a>:</h4>
<p><a href="https://youtu.be/YZomx3Jt4Xs?t=1541">https://youtu.be/YZomx3Jt4Xs?t=1541</a></p>
<div class="youtube-video message_inline_image"><a data-id="YZomx3Jt4Xs" href="https://youtu.be/YZomx3Jt4Xs?t=1541"><img src="https://uploads.zulipusercontent.net/546c04ca1b755dc02a5d54374262e87ea59b65a4/68747470733a2f2f692e7974696d672e636f6d2f76692f595a6f6d78334a743458732f64656661756c742e6a7067"></a></div>



<a name="272049404"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272049404" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Quy Nguyen <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272049404">(Feb 15 2022 at 22:48)</a>:</h4>
<p>Yeah ISO was just an example, alongside ECMA as with what Dart is doing or w/e. I do think it's a fundamental debate with the Rust standard that of whether we want it more like C++ or Java. I'm still partial to the C++ way of doing things, but there are definitely people who think that the main production compilers will be forks/distributions of rustc (ala openjdk), or niche/research compilers.</p>



<a name="272049510"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272049510" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272049510">(Feb 15 2022 at 22:50)</a>:</h4>
<blockquote>
<p>there are definitely people who think that the main production compilers will be forks/distributions of rust</p>
</blockquote>
<p>I hope not <span aria-label="rofl" class="emoji emoji-1f923" role="img" title="rofl">:rofl:</span></p>



<a name="272049663"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272049663" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272049663">(Feb 15 2022 at 22:51)</a>:</h4>
<p>But as I say, I don't think there really needs to be any sort of entity or organization, other than Rust itself, backing the Rust specification.</p>



<a name="272049956"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272049956" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272049956">(Feb 15 2022 at 22:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="303115">Quy Nguyen</span> <a href="#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272049404">said</a>:</p>
<blockquote>
<p>I do think it's a fundamental debate with the Rust standard that of whether we want it more like C++ or Java.</p>
</blockquote>
<p>Is "no" an option? ;)</p>



<a name="272050013"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272050013" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272050013">(Feb 15 2022 at 22:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272049663">said</a>:</p>
<blockquote>
<p>But as I say, I don't think there really needs to be any sort of entity or organization, other than Rust itself, backing the Rust specification.</p>
</blockquote>
<p>I can imagine scenarios in which it makes sense to have an organization stamp the Rust specification, but not take over the Rust specification.</p>



<a name="272050037"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272050037" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272050037">(Feb 15 2022 at 22:55)</a>:</h4>
<p>Yeah.</p>



<a name="272050146"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272050146" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272050146">(Feb 15 2022 at 22:56)</a>:</h4>
<p>Something like ISO is <em>fun</em> though, because they like having exclusive publication rights to <em>the</em> standard.</p>



<a name="272050194"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272050194" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272050194">(Feb 15 2022 at 22:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="303115">Quy Nguyen</span> <a href="#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272048492">said</a>:</p>
<blockquote>
<p>Yeah, I was thinking about how C# does their standardization process, and I think my ideal process would be a living standard owned by the Rust foundation, and then every x years we submit it to ISO/whatever as a kind of LTS Rust/edition/whatever.</p>
</blockquote>
<p>I don't think we want an "LTS Rust" in that sense. If there's an org that will take and stamp a version every x <em>weeks</em> or at most <em>months</em>, that might work.</p>



<a name="272050213"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272050213" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272050213">(Feb 15 2022 at 22:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272050146">said</a>:</p>
<blockquote>
<p>Something like ISO is <em>fun</em> though, because they like having exclusive publication rights to <em>the</em> standard.</p>
</blockquote>
<p>Which makes them pretty much automatically a no-go. That's not adding value, that's taking away value.</p>



<a name="272050251"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272050251" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272050251">(Feb 15 2022 at 22:57)</a>:</h4>
<p>Yeah. C++ and C actually go arround this by publishing drafts on open-std.</p>



<a name="272050319"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272050319" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272050319">(Feb 15 2022 at 22:58)</a>:</h4>
<p>But if you want <em>the</em> standard? That's 250 CHF for C, and 200 for C++.</p>



<a name="272130504"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272130504" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272130504">(Feb 16 2022 at 15:28)</a>:</h4>
<p>I'm not aware of any downsides of standardizing through ECMA rather than ISO, it seems to work well for javascript and be strictly better</p>



<a name="272130676"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272130676" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272130676">(Feb 16 2022 at 15:29)</a>:</h4>
<p>it even seems appropriate since, as far as <em>organizational</em> genealogy is concerned, Rust is Javascript's nearest sibling :P</p>



<a name="272769812"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272769812" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272769812">(Feb 22 2022 at 07:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272034322">said</a>:</p>
<blockquote>
<p>C and C++ both explicitly note that an implementation can translate an ill-formed program, and, while I'd expect rust to recommend implementations not translate additionall ill-formed programs, I wouldn't expect it to forbid it.<br>
subset-of-Rust isn't a valid implementation (notwithstanding lints that can be controlled), but I'd expected superset-of-Rust to be valid, though discouraged.</p>
</blockquote>
<p>I actually do expect Rust to say ill-formed programs should not be translated to machine code.</p>



<a name="272769977"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272769977" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272769977">(Feb 22 2022 at 07:59)</a>:</h4>
<p>The purpose of a type system is to reject ill-formed programs.<br>
Rust is functionally defined by its ownership type system.<br>
Thus, a compiler that does not reject ill-formed programs is not implementing Rust's type system.<br>
Thus, a compiler that does not reject ill-formed programs is not implementing Rust.</p>



<a name="272770380"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272770380" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272770380">(Feb 22 2022 at 08:05)</a>:</h4>
<p>I would also expect the complete definition of that mandate to have a loophole you could drive a truck through because it might still e.g. allow dynamic interpretation for debugging purposes or partially lowering parts of the program to object fragments but refusing to actually fully emit and link the result.</p>



<a name="272791559"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272791559" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272791559">(Feb 22 2022 at 11:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="281757">Jubilee</span> <a href="#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272769977">said</a>:</p>
<blockquote>
<p>The purpose of a type system is to reject ill-formed programs.<br>
Rust is functionally defined by its ownership type system.<br>
Thus, a compiler that does not reject ill-formed programs is not implementing Rust's type system.<br>
Thus, a compiler that does not reject ill-formed programs is not implementing Rust.</p>
</blockquote>
<p>I understand that it's less useful, but I noted a few reasons that having it open is useful (namely pieces of extensions that cannot be detected after features are checked, and implementations like mrustc that are used for bootstrapping).</p>



<a name="272792027"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/272792027" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#272792027">(Feb 22 2022 at 11:50)</a>:</h4>
<p>It would also open the option of making fcw's treated as "Ill-formed" immediately, while still allowing them to just be warnings for backcompat.</p>



<a name="274016290"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Implementation%20Specific%20Behaviour/near/274016290" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour.html#274016290">(Mar 03 2022 at 18:24)</a>:</h4>
<p>I do not believe Mutabah has a finished implementation of rustc, either.</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>