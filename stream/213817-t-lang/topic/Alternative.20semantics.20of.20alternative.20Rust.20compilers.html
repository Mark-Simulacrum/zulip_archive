<html>
<head><meta charset="utf-8"><title>Alternative semantics of alternative Rust compilers · t-lang · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/index.html">t-lang</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html">Alternative semantics of alternative Rust compilers</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="253663773"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/253663773" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#253663773">(Sep 16 2021 at 22:59)</a>:</h4>
<p>This is a follow-up to <a href="https://github.com/Rust-GCC/gccrs/issues/653#issuecomment-913965979">https://github.com/Rust-GCC/gccrs/issues/653#issuecomment-913965979</a>, where <span class="user-mention" data-user-id="239881">@Josh Triplett</span> wrote</p>
<blockquote>
<p>Yes, -ffast-math changes the semantics, but not in a way that causes changes to the set of accepted programs, or similar compatibility issues; that combined with the fact that it isn't the default makes me not concerned about it. In general, I'd prefer if all Rust compilers stuck very precisely to the language semantics across the board. But in the interests of trying to make sure people and projects have room to experiment, I'd settle for all Rust compilers not changing language semantics in a way that causes some programs to work on some compilers and fail on others. That holds especially true when the change is a non-standard option, rather than the default behavior of that compiler. Another compiler choosing to expose a --give-slightly-wrong-answers flag won't cause problems in the Rust ecosystem, the way an --accept-incorrect-programs flag would.</p>
</blockquote>
<p>I am trying to understand why you think this would cause less trouble, because I think it causes <em>more</em> trouble. "This" being: two Rust compilers both accepting a program and giving distinct guaranteed semantics to it (i.e., I am not talking about non-determinism here). I think such a change in semantics has the potential to cause massive  problems in the Rust ecosystem: <code>--give-slightly-wrong-answers</code> will mean that Rust programs can suddenly misbehave but only in obscure situations that would not be discovered during testing. I think this is <em>worse</em> than an alternative compiler accepting more or less programs than rustc would; if compilation fails at least we know at compile time that something is wrong (this is basically just an experimental language extension, we have those all the time inside rustc). But I think it is crucial that <em>if</em> compilation succeeds, one can be sure of how the program will behave.<br>
With such a flag we can easily end up with some crates only working properly with default semantics, and some crates only working with <code>--give-slightly-wrong-answers</code> -- the same kind of ecosystem split we can have when alternative compilers accept more programs than rustc, but made worse by the fact that there is no way to tell if you accidentally ended up including a crate that requires the alternative compiler.</p>



<a name="253664076"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/253664076" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#253664076">(Sep 16 2021 at 23:01)</a>:</h4>
<p>I admit that with fast-math specifically, it seems unlikely that a crate would work <em>only</em> with fast-math and fail to work with regular rustc. fast-math is somewhat of a special case here. But you phrased your statement as being about deviations from the standard language semantics in general, and against that I want to strongly push back.</p>



<a name="253667392"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/253667392" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#253667392">(Sep 16 2021 at 23:39)</a>:</h4>
<p>Note that many compilers will expose different semantics and requirements via the command line by virtue of having different interfaces. ]<br>
I think the canonical example would be the borrow checker:<br>
mrustc is an example of a rust compiler that does not have a borrow checker at all. Not gated at invocation or build time, simply doesn't exist.<br>
Likewise, the default lccc rust frontend won't come with a borrow checker out of the box (as it would just use a runtime plugin to call out to polonius which the host may not be able to build), and will have both configure time and invocation time options to enable or disable it (the invocation time option is likely less necessary, but the configure time option is to ensure that polonius doesn't end up dictating the build requirements for the rust frontend, making bootstrapping difficult).</p>
<p>For runtime options, <code>-ffast-math</code> and similar does seem like a reasonable option: it cannot be set by crates, only users. This is true of any extension option that any alternative rust compiler provides, both in non-standard CLIs and rustc-like CLIs. <br>
I plan a number myself for lccc, one notable one is <code>-Z build-abi</code> which affects the version of a guaranteed abi provided by lccc - someone could rely on this abi in a crate, which would break on non-lccc compilers (and on any version that changes the default abi version, or when the user specifies an abi-affecting flag on the command-line), but I personally see this as a non-issue, as the crate itself cannot set the flag, only the user. <br>
A crate could, of course, detect the presense of the flag and use that to write optimized code relying on the abi, and fall back to a safe implementation (I do this myself within the standard library of lccc, I detect the abi version and whether randomized layout is enabled by generating a manifest file and reading it's <code>abi_version</code> field). If done correctly, however, this shouldn't cause issues as the test would fail on other compiles, so the fallback code would be selected. <br>
You could argue that a guaranteed abi is a guarantee an alternative rust compiler shouldn't make, however the abi is necessary within lccc (a primary use case was proc-macros, as the project was originally written in C++, though even while transition to rust the abi-safety is still a potential question, as the compiler may not be compiled by itself), and I refuse to ever make or rely on an undocumented internal guarantee - in my opinion that leads to Left-hand Right-hand bugs, or bugs when there are two sources of truth that disagree. With something like ABI that's a recipe for undefined behaviour.</p>



<a name="253667695"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/253667695" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#253667695">(Sep 16 2021 at 23:42)</a>:</h4>
<p>An argument against <code>-ffast-math</code> specifically would be that it does, in fact, introduce new undefined behaviour over the rust language. However, this is notably the case in other programming languages (it is notably non-compliant with both the C and C++ standards to enable the option), and it is well-documented as such. I would expect such documentation to be sufficient to cover it.</p>



<a name="253686141"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/253686141" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Thom Chiovoloni <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#253686141">(Sep 17 2021 at 04:01)</a>:</h4>
<p>yeah, i don't think just copying C++'s ffast-math behavior is a good model. I do think we need something to that effect (but honestly, IMO the finite-math-only flags are footguns, and probably should be either not part of it or a separate thing), but i'd rather it be integrated into the language more</p>



<a name="253686188"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/253686188" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Thom Chiovoloni <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#253686188">(Sep 17 2021 at 04:02)</a>:</h4>
<p>(and tbh i kind of think specifying this might help clear up some of the "situations" rust currently has around non-ieee-compliant floats...)</p>



<a name="253686363"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/253686363" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#253686363">(Sep 17 2021 at 04:04)</a>:</h4>
<p><span class="user-mention" data-user-id="120791">@RalfJ</span> To be clear, I'm not arguing that <code>-ffast-math</code> in particular is a great idea (it bundles together too many things), and also, I'd love to see some subsets of it added to rustc. But the case I was making is this:</p>



<a name="253686511"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/253686511" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#253686511">(Sep 17 2021 at 04:06)</a>:</h4>
<p>I really don't want to see compilers changing language semantics in a way that accepts more or less programs; that changes the language itself. But <code>-ffast-math</code> does two things: 1) make the program faster and 2) make the results less accurate. (1) isn't an issue, and (2) is a quality-of-implementation issue: either it won't be an issue or it'll make people not want to use the option. The <em>existence</em> of the option can't bifurcate the ecosystem.</p>



<a name="253686541"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/253686541" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#253686541">(Sep 17 2021 at 04:07)</a>:</h4>
<p>I'm contrasting that with something like <code>-fmake-borrow-checker-errors-into-warnings</code>, which would be extremely damaging, because it would accept a different language that isn't quite Rust, and lead to crates that only work on one compiler but not another.</p>



<a name="253686628"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/253686628" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#253686628">(Sep 17 2021 at 04:08)</a>:</h4>
<p>An option like <code>--give-slightly-wrong-answers</code> could make people want to use the compiler if there's a good reason for it, or could make people not want to use the option if it causes problems, but as long as it isn't the default I don't see how it does harm.</p>



<a name="253686680"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/253686680" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#253686680">(Sep 17 2021 at 04:09)</a>:</h4>
<p>Now, if there were a <code>--give-slightly-more-right-answers</code> option, that could be a problem; people might depend on that, and it could cause a similar rift in the ecosystem. That's the kind of thing that ought to get coordinated, and if the semantics of it seem like something people would want or need, we could add it to the language.</p>



<a name="253689387"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/253689387" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> isHavvy <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#253689387">(Sep 17 2021 at 04:49)</a>:</h4>
<p>Note that mrustc gets a pass because it's not trying to be a compiler for all Rust code, but rather a compiler for rustc specifically.</p>



<a name="253725956"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/253725956" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#253725956">(Sep 17 2021 at 11:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="239881">Josh Triplett</span> <a href="#narrow/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers/near/253686541">said</a>:</p>
<blockquote>
<p>I'm contrasting that with something like <code>-fmake-borrow-checker-errors-into-warnings</code>, which would be extremely damaging, because it would accept a different language that isn't quite Rust, and lead to crates that only work on one compiler but not another.</p>
</blockquote>
<p>I mentioned basically this specifically, though an <code>-fno-borrowck</code> (invocation-time) or a <code>--disable-borrowck</code> (configure-time), rather than a demotion to warnings. The borrow checker is, imo, the most complicated and the least well-documented part of the rust language. Every implementation that I know of that plans to implement one at all plans to shell out to polonius to implement it. <br>
In lccc, the option to disable the borrow checker is present at the configuration level (enabled by default if the requirements for polonius are detected, disabled otherwise). Like many other configure time options, it has a invocation-time counterpart, when enabled at configuration-time.</p>



<a name="253726415"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/253726415" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#253726415">(Sep 17 2021 at 11:19)</a>:</h4>
<p>(The reason for the option is simple, lccc, like every other alternative rust compiler I'm aware of that has one, implements the borrowchecker via polonius, but the requirements for polonius may not be satisfied by the host system when the requirements for the rest of the frontend and project are. Thus it switches based on feature detection and can be explicitly toggled by the person running configure)</p>



<a name="253727227"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/253727227" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#253727227">(Sep 17 2021 at 11:26)</a>:</h4>
<p>It is reasonable to expect that such an option (from both sides) <em>could</em> lead to crates depending on it to compile, however, I don't expect it to be often as the default state is enabled and crates can't enable the flag themselves.</p>



<a name="253727510"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/253727510" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#253727510">(Sep 17 2021 at 11:29)</a>:</h4>
<p>(Well, via cargo they can't. A project using rust-autotools or some other alternative build system could do so, but at that point, they could also detect the precense of lccc, gcc-rs, mrustc, or w/e, or could set some even more interesting options to then proceed to rely on)</p>



<a name="254085642"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254085642" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254085642">(Sep 20 2021 at 17:21)</a>:</h4>
<blockquote>
<p>But -ffast-math does two things: 1) make the program faster and 2) make the results less accurate. (1) isn't an issue, and (2) is a quality-of-implementation issue: either it won't be an issue or it'll make people not want to use the option. The existence of the option can't bifurcate the ecosystem.</p>
</blockquote>
<p>One person's "less accurate" is another person's "wrong". There is not really a clear line dividing this. And having a compiler that gives wrong answers can easily bifurcate the ecosystem in silent and hard to detect ways, once there are crates relying on the wrong answer.</p>



<a name="254085729"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254085729" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254085729">(Sep 20 2021 at 17:21)</a>:</h4>
<p>Wouldn't it be the same as cpus that give wrong answers?</p>



<a name="254085824"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254085824" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254085824">(Sep 20 2021 at 17:22)</a>:</h4>
<p>You can rely on wrong hardware semantics just as much as compiler optimizations.</p>



<a name="254085867"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254085867" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254085867">(Sep 20 2021 at 17:22)</a>:</h4>
<p>sure</p>



<a name="254086800"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254086800" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254086800">(Sep 20 2021 at 17:29)</a>:</h4>
<p>To be honest, with -ffast-math specifically, a lot of things affect the result of floating-point operations, especially where both contracted floating-point operations, and extended intermediate operands (FLT_EVAL_MODE in C). I'd find it hard to rely on the flag accidentally.</p>



<a name="254086880"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254086880" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254086880">(Sep 20 2021 at 17:29)</a>:</h4>
<p>And it's always possible to deliberately rely on compiler differences. Just ask the compiler what it's version is.</p>



<a name="254087116"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254087116" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254087116">(Sep 20 2021 at 17:31)</a>:</h4>
<p>(Unless you'd argue that compilers must avoid reporting the actual program name and copyright information with --version)</p>



<a name="254087258"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254087258" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254087258">(Sep 20 2021 at 17:32)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers/near/254085642">said</a>:</p>
<blockquote>
<blockquote>
<p>But -ffast-math does two things: 1) make the program faster and 2) make the results less accurate. (1) isn't an issue, and (2) is a quality-of-implementation issue: either it won't be an issue or it'll make people not want to use the option. The existence of the option can't bifurcate the ecosystem.</p>
</blockquote>
<p>One person's "less accurate" is another person's "wrong". There is not really a clear line dividing this. And having a compiler that gives wrong answers can easily bifurcate the ecosystem in silent and hard to detect ways, once there are crates relying on the wrong answer.</p>
</blockquote>
<p>I'm not arguing that "less accurate" isn't wrong; it absolutely is. I'm just suggesting that it'd be extremely unlikely for code to somehow rely specifically on that wrong answer, especially given that <code>-ffast-math</code> isn't the default.</p>



<a name="254087911"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254087911" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254087911">(Sep 20 2021 at 17:36)</a>:</h4>
<p>Someone would have to use a different compiler, use a non-standard option for that compiler, and then somehow rely specifically on an exact floating-point result produced by that combination of compiler and options. That seems extremely unlikely.</p>



<a name="254088018"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254088018" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254088018">(Sep 20 2021 at 17:37)</a>:</h4>
<p>Indeed, and, as I mentioned, even more difficult to rely on accidentally.</p>



<a name="254088197"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254088197" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254088197">(Sep 20 2021 at 17:38)</a>:</h4>
<blockquote>
<p>Someone would have to use a different compiler, use a non-standard option for that compiler,</p>
</blockquote>
<p>true... but the same argument would then apply to non-default compiler flags that make the compiler accept more programs</p>



<a name="254088207"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254088207" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254088207">(Sep 20 2021 at 17:38)</a>:</h4>
<p>Right. You'd really have to go out of your way, or you'd have to have a very specialized algorithm that may or may not stabilize with slightly different floating-point results. Which is absolutely possible, but why would you compile such an algorithm with <code>-ffast-math</code> <em>and</em> rely on it <em>and</em> not test with rustc or without <code>-ffast-math</code>.</p>



<a name="254088265"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254088265" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254088265">(Sep 20 2021 at 17:38)</a>:</h4>
<p>With -ffast-math the compiler is allowed to just ignore it. It relaxes a guarantee the compiler normally gives. It doesn't strengthen it.</p>



<a name="254088284"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254088284" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254088284">(Sep 20 2021 at 17:38)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers/near/254088197">said</a>:</p>
<blockquote>
<blockquote>
<p>Someone would have to use a different compiler, use a non-standard option for that compiler,</p>
</blockquote>
<p>true... but the same argument would then apply to non-default compiler flags that make the compiler accept more programs</p>
</blockquote>
<p>But non-defalut compiler flag that make the compiler accept more programs are something people may seek out and <em>seek</em> to rely on.</p>



<a name="254088378"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254088378" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254088378">(Sep 20 2021 at 17:39)</a>:</h4>
<p>Versus something like <code>-ffast-math</code> which isn't designed to be a thing people rely on the semantics of. It's designed to be a thing you <em>can't</em> rely on the semantics of. :)</p>



<a name="254088438"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254088438" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254088438">(Sep 20 2021 at 17:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="133247">bjorn3</span> <a href="#narrow/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers/near/254088265">said</a>:</p>
<blockquote>
<p>With -ffast-math the compiler is allowed to just ignore it. It relaxes a guarantee the compiler normally gives. It doesn't strengthen it.</p>
</blockquote>
<p>With -fno-borrowchecker the compiler is not allowed to ignore it as it guarantees that code not passing the borrowchecker will compile.</p>



<a name="254088463"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254088463" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254088463">(Sep 20 2021 at 17:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="239881">Josh Triplett</span> <a href="#narrow/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers/near/254088207">said</a>:</p>
<blockquote>
<p>Right. You'd really have to go out of your way, or you'd have to have a very specialized algorithm that may or may not stabilize with slightly different floating-point results. Which is absolutely possible, but why would you compile such an algorithm with <code>-ffast-math</code> <em>and</em> rely on it <em>and</em> not test with rustc or without <code>-ffast-math</code>.</p>
</blockquote>
<p>Or a <code>-ffast-math</code> option on a different compiler that may do different things. Or a different version of the same compiler.</p>



<a name="254088619"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254088619" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254088619">(Sep 20 2021 at 17:40)</a>:</h4>
<p><span class="user-mention silent" data-user-id="133247">bjorn3</span> <a href="#narrow/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers/near/254088438">said</a>:</p>
<blockquote>
<p>With -fno-borrowchecker the compiler is not allowed to ignore it as it guarantees that code not passing the borrowchecker will compile.</p>
</blockquote>
<p>Well, the compiler can reject the option.</p>



<a name="254088635"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254088635" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254088635">(Sep 20 2021 at 17:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="239881">Josh Triplett</span> <a href="#narrow/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers/near/254088378">said</a>:</p>
<blockquote>
<p>Versus something like <code>-ffast-math</code> which isn't designed to be a thing people rely on the semantics of. It's designed to be a thing you <em>can't</em> rely on the semantics of. :)</p>
</blockquote>
<p>okay that is a distinction I can find myself agreeing with much more. it seems only tangentially related to whether it changes the set of accepted programs or not.</p>



<a name="254088642"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254088642" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254088642">(Sep 20 2021 at 17:41)</a>:</h4>
<p><span class="user-mention" data-user-id="133247">@bjorn3</span> Exactly. And someone might seek that out because they're struggling with the borrow-checker and still in the mindset of "I know what I'm doing, the compiler should just let me do it", and then find an option that does just that...</p>



<a name="254088743"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254088743" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254088743">(Sep 20 2021 at 17:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers/near/254088635">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="239881">Josh Triplett</span> <a href="#narrow/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers/near/254088378">said</a>:</p>
<blockquote>
<p>Versus something like <code>-ffast-math</code> which isn't designed to be a thing people rely on the semantics of. It's designed to be a thing you <em>can't</em> rely on the semantics of. :)</p>
</blockquote>
<p>okay that is a distinction I can find myself agreeing with much more. it seems only tangentially related to whether it changes the set of accepted programs or not.</p>
</blockquote>
<p>I think it's closely related. A thing that changes the set of accepted programs is much more likely to be relied on.</p>



<a name="254089075"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254089075" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254089075">(Sep 20 2021 at 17:43)</a>:</h4>
<p>-ffast-math shrinks the set of programs that compile without UB. -fno-borrowchecker expands it. You can't rely on -ffast-math being used, because if your program was well behaved with it for all possible compilers, it will still be well behaved without it. You can rely on -fno-borrowchecker being used, because some programs will no longer work without it.</p>



<a name="254089166"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254089166" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254089166">(Sep 20 2021 at 17:44)</a>:</h4>
<p><span class="user-mention" data-user-id="239881">@Josh Triplett</span>  do you consider UB-removing flags to be "changing the set of accepted programs"?</p>



<a name="254089228"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254089228" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254089228">(Sep 20 2021 at 17:44)</a>:</h4>
<p>(as in, is "accepting" a static notion or does it include UB-freedom)</p>



<a name="254089260"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254089260" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254089260">(Sep 20 2021 at 17:45)</a>:</h4>
<p><span class="user-mention" data-user-id="120791">@RalfJ</span> As in, something that changes UB to defined behavior, such that you can write a program using that behavior without invoking UB?</p>



<a name="254089284"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254089284" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254089284">(Sep 20 2021 at 17:45)</a>:</h4>
<p>IMO "accepting" includes UB-freedom.</p>



<a name="254089324"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254089324" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254089324">(Sep 20 2021 at 17:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="133247">bjorn3</span> <a href="#narrow/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers/near/254089075">said</a>:</p>
<blockquote>
<p>-ffast-math shrinks the set of programs that compile without UB. -fno-borrowchecker expands it. You can't rely on -ffast-math being used, because if your program was well behaved with it for all possible compilers, it will still be well behaved without it. You can rely on -fno-borrowchecker being used, because some programs will no longer work without it.</p>
</blockquote>
<p>You could also rely on mrustc, or a version of some compiler compiled without a borrow checker at all (which is what lccc provides: <code>--disable-borrowck</code> doesn't build or include the borrow checker at all)</p>



<a name="254089477"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254089477" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254089477">(Sep 20 2021 at 17:46)</a>:</h4>
<p><span class="user-mention" data-user-id="120791">@RalfJ</span> Yes, I would absolutely consider that to be "changing the set of accepting programs".</p>



<a name="254089551"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254089551" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254089551">(Sep 20 2021 at 17:46)</a>:</h4>
<p>As much as there are things that are currently UB that I'd love to define <em>in Rust</em>, to the extent we haven't defined those things yet, a non-standard compiler option to enable them would have that same risk of bifurcating the ecosystem.</p>



<a name="254089615"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254089615" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254089615">(Sep 20 2021 at 17:47)</a>:</h4>
<p><span class="user-mention silent" data-user-id="239881">Josh Triplett</span> <a href="#narrow/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers/near/254089260">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> As in, something that changes UB to defined behavior, such that you can write a program using that behavior without invoking UB?</p>
</blockquote>
<p>Note that I'd argue this is a fundamental freedom of having undefined behaviour =&gt; Undefined Behaviour leaves the behaviour of the program undefined, up to the implementation. A natural collary is that it allows the implementation to ascribe a particular guaranteed behaviour to that result.</p>



<a name="254089676"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254089676" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254089676">(Sep 20 2021 at 17:47)</a>:</h4>
<p>okay. well then I have a hard time coming up with other realistic examples for semantics-changing flags... I dont necessarily agree that those are inherently less likely to be relied upon, its more than we only have one real example and that has a bunch of facts making less of an issue^^</p>



<a name="254089699"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254089699" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254089699">(Sep 20 2021 at 17:47)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers/near/254089615">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="239881">Josh Triplett</span> <a href="#narrow/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers/near/254089260">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> As in, something that changes UB to defined behavior, such that you can write a program using that behavior without invoking UB?</p>
</blockquote>
<p>Note that I'd argue this is a fundamental freedom of having undefined behaviour =&gt; Undefined Behaviour leaves the behaviour of the program undefined, up to the implementation. A natural collary is that it allows the implementation to ascribe a particular guaranteed behaviour to that result.</p>
</blockquote>
<p>That's not the same thing. An implementation is free to do something different, because it's not defined. But if an implementation tries to <em>define</em> it and make that a <em>guarantee</em>, that's a semantic change to the language.</p>



<a name="254089792"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254089792" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254089792">(Sep 20 2021 at 17:48)</a>:</h4>
<p>Well, it depends on why it defines it.</p>



<a name="254089906"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254089906" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254089906">(Sep 20 2021 at 17:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers/near/254089676">said</a>:</p>
<blockquote>
<p>okay. well then I have a hard time coming up with other realistic examples for semantics-changing flags... I dont necessarily agree that those are inherently less likely to be relied upon, its more than we only have one real example and that has a bunch of facts making less of an issue^^</p>
</blockquote>
<p>I can think of a few. For instance, consider an option that always initializes variables to 0, and lets you write something like:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">x</span>: <span class="kt">u32</span><span class="p">;</span><span class="w"></span>
<span class="n">f</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w"></span>
</code></pre></div>



<a name="254090057"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254090057" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254090057">(Sep 20 2021 at 17:50)</a>:</h4>
<p>that changes the set of accepted programs</p>



<a name="254090163"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254090163" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254090163">(Sep 20 2021 at 17:51)</a>:</h4>
<p><code>-fno-mutable-aliasing</code></p>



<a name="254090198"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254090198" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254090198">(Sep 20 2021 at 17:51)</a>:</h4>
<p>likewise (removes UB)</p>



<a name="254090244"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254090244" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254090244">(Sep 20 2021 at 17:51)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers/near/254090198">said</a>:</p>
<blockquote>
<p>likewise (removes UB)</p>
</blockquote>
<p><code>-Z mutable-noalias=no</code></p>



<a name="254090477"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254090477" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254090477">(Sep 20 2021 at 17:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers/near/254089792">said</a>:</p>
<blockquote>
<p>Well, it depends on why it defines it.</p>
</blockquote>
<p>no -- changing the set of UB is always a language change. there is a hierarchy here, where a compiler that is correct for "Rust with less UB" is also always a correct compiler for "real Rust". but that does not change the fact that these are 2 distinct languages.</p>



<a name="254090501"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254090501" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254090501">(Sep 20 2021 at 17:53)</a>:</h4>
<p><span class="user-mention" data-user-id="120791">@RalfJ</span> I think by definition anything that turns UB into defined behavior changes the set of "valid" programs. Are you looking specifically for things that would not change the set of "accepted" programs, insofar as rustc "accepts" the program but the resulting compiled code invokes UB?</p>



<a name="254090732"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254090732" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254090732">(Sep 20 2021 at 17:54)</a>:</h4>
<p>well I was looking for something that would fall in the category of fast-math. you claim that that category in general is less likely to be relied upon, but I cant even come up with another realistic example.^^</p>



<a name="254090794"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254090794" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254090794">(Sep 20 2021 at 17:55)</a>:</h4>
<p>Ah, I see! You're looking for options that <em>don't</em> do any harm.</p>



<a name="254090804"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254090804" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254090804">(Sep 20 2021 at 17:55)</a>:</h4>
<p>I can think of a lot of those.</p>



<a name="254090811"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254090811" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254090811">(Sep 20 2021 at 17:55)</a>:</h4>
<p>One moment...</p>



<a name="254091058"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254091058" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254091058">(Sep 20 2021 at 17:56)</a>:</h4>
<p>I'd argue that any compiler option or change in behaviour that can be observed at all can be relied upon.</p>



<a name="254091135"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254091135" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254091135">(Sep 20 2021 at 17:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers/near/254091058">said</a>:</p>
<blockquote>
<p>I'd argue that any compiler option or change in behaviour that can be observed at all can be relied upon.</p>
</blockquote>
<p>Potentially, yes, but not everything that could be observed and <em>theoretically</em> relied upon is likely to cause issues.</p>



<a name="254091194"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254091194" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254091194">(Sep 20 2021 at 17:57)</a>:</h4>
<p>You can 100% observe the difference in code using <code>-C opt-level=0</code> vs.<code>-C opt-level=3</code> could be relied upon to an extent that breaks if one is used rather than the other.</p>



<a name="254091195"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254091195" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254091195">(Sep 20 2021 at 17:57)</a>:</h4>
<p>"disable the borrow checker" or "allow mutable aliasing" or "allow use of uninitialized variables" or similar change semantics in a way that would absolutely lead programs to rely on them if used.</p>



<a name="254091755"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254091755" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254091755">(Sep 20 2021 at 18:00)</a>:</h4>
<p>I'd also ask what the difference would be between an option of a non-standard CLI, or of a <code>-Z</code> or <code>-Z</code> enabled option is, vs. say <code>#[feature]</code>, which can basically do the same thing. I could just as easily write <code>#![feature(disable_borrow_rules)]</code> and provide that in a compiler, instead of just a <code>-Z borrowck=no</code> option.</p>



<a name="254092183"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254092183" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254092183">(Sep 20 2021 at 18:03)</a>:</h4>
<p>Both are compiler-specific, both are obviously unstable (except maybe the non-standard CLI version), and only the latter can be imposed at the crate level when using standard cargo.</p>



<a name="254093118"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254093118" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254093118">(Sep 20 2021 at 18:10)</a>:</h4>
<p>Well, one difference is that we're not likely to add a <code>-Z borrowck=no</code> option, and we're even less likely to stabilize it. :)</p>



<a name="254093226"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254093226" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254093226">(Sep 20 2021 at 18:11)</a>:</h4>
<p>But in any case, <code>-Z</code> options and similar nightly-only features are the actual process by which we evolve Rust semantics, and they're intentionally presented as unstable and can break at any time, and thus we discourage people from relying on their semantics.</p>



<a name="254093255"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254093255" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254093255">(Sep 20 2021 at 18:11)</a>:</h4>
<p>Well, compilers can (and rustc already does, distinct from the language features) add their own unstable features. <code>#[feature(stability_attributes)]</code> comes to mind</p>



<a name="254093297"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254093297" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254093297">(Sep 20 2021 at 18:11)</a>:</h4>
<p>And despite that, people <em>do</em> already write code to rely on nightly features, and that code only builds on nightly Rust.</p>



<a name="254093402"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254093402" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254093402">(Sep 20 2021 at 18:12)</a>:</h4>
<p>Well yes, and specifically nightly rustc.</p>



<a name="254093487"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254093487" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254093487">(Sep 20 2021 at 18:12)</a>:</h4>
<p>Imo, unstable options and unstable features both represent an opt-in to non-portability, not just instability.</p>



<a name="254093496"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254093496" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254093496">(Sep 20 2021 at 18:12)</a>:</h4>
<p>(I'm still intentionally using those terms synonymously, yes.)</p>



<a name="254093603"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254093603" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254093603">(Sep 20 2021 at 18:13)</a>:</h4>
<p>Yes, and on top of that, Rust's mechanism for ensuring that you can't use nightly options on a stable compiler makes it even less likely that people will rely on them.</p>



<a name="254093948"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254093948" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254093948">(Sep 20 2021 at 18:15)</a>:</h4>
<p>There are, by design, programs that rely on nightly, because they need that support. The authors of those programs are the same people who help push for those options to be stabilized.</p>



<a name="254094221"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254094221" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254094221">(Sep 20 2021 at 18:17)</a>:</h4>
<p>So then my argument is that a user setting the <code>-Z borrowck=no</code> option would implicitly accept the burden of portability, or lack thereof, just like one using a <code>#![feature(disable_borrow_rules)]</code> would (keeping the <code>-fno-borrowck</code> version out of this, because the gcc CLI is inherently non-portable, so imo, the behaviour of <code>-Z</code> options would extend to them)</p>



<a name="254094224"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254094224" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254094224">(Sep 20 2021 at 18:17)</a>:</h4>
<p>And even taking all that into account, it would still be hazardous for us to introduce an option that we're <em>never</em> likely to stabilize, if people are going to start relying on it.</p>



<a name="254094398"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254094398" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254094398">(Sep 20 2021 at 18:18)</a>:</h4>
<p><span class="user-mention" data-user-id="257758">@Connor Horman</span> GCC doesn't have any similar mechanism for distinguishing nightly versus stable, though. If an option exists for experimentation purposes, it'll get released as part of the next GCC release, and people can start relying on its semantics.</p>



<a name="254094454"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254094454" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254094454">(Sep 20 2021 at 18:19)</a>:</h4>
<p>If such options only existed when you build a GCC nightly snapshot, that'd be much less likely for people to start relying on, rather than just testing as part of the development and evolution process.</p>



<a name="254094580"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254094580" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254094580">(Sep 20 2021 at 18:20)</a>:</h4>
<p>(That's one of a few possible approaches that could potentially help mitigate the chances of people relying on non-standard options and the corresponding semantics.)</p>



<a name="254094870"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254094870" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254094870">(Sep 20 2021 at 18:21)</a>:</h4>
<p><span class="user-mention" data-user-id="120791">@RalfJ</span> Another potentially interesting option that I can imagine a compiler providing would be one that guarantees tail-call optimization. Programs could easily rely on that, by writing recursive algorithms that would otherwise run out of stack. So that has the same kind of problem.</p>



<a name="254095363"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254095363" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254095363">(Sep 20 2021 at 18:25)</a>:</h4>
<p>Another option in the vein of <code>-ffast-math</code> where people <em>could</em> rely on it but probably won't: <code>-falign-functions</code>.</p>



<a name="254095469"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254095469" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254095469">(Sep 20 2021 at 18:25)</a>:</h4>
<p>You could, for instance, align all functions to 32-byte boundaries, and then write code that relies on that, by using the lower 5 bits of function pointers.</p>



<a name="254095713"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254095713" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254095713">(Sep 20 2021 at 18:27)</a>:</h4>
<p>A crate using gcc's gcc CLI wouldn't work with conventional tooling anyways, directly.<br>
Of course, adaptors are being worked on (cargo-gccrs is one, I'm writing one for a couple of projects, though they wouldn't be directly used with pure-cargo projects), which may run into the same point.</p>



<a name="254095924"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254095924" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254095924">(Sep 20 2021 at 18:28)</a>:</h4>
<p>I'd expect that <code>cargo-gccrs</code> wrapper to get used (and be a primary way people invoke gccrs), and it's more-or-less running cargo with a wrapper that behaves like rustc.</p>



<a name="254096254"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254096254" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254096254">(Sep 20 2021 at 18:30)</a>:</h4>
<p>As for the stable vs. nightly, it would also impact <code>#[feature]</code>s in the same way (stable/beta rustc doesn't accept those either, but nightly/dev does), so this is more of a fundamental issue with compilers that don't make this distinction (of course, I'd argue it should be unnecessary to do so). </p>
<p>I likewise don't distinguish between the two modes in lccc's rust frontend.<br>
In theory, binary versions of either could be built in a stable-only configuration, but as both are primarily intended for from-source builds rather than binary distribution (though I would expect gcc-rs to be distributed by distro package amangers), that option would have to be up to the person building the program to set, and it would, of course, require an opt-out for stdlib building purposes. <br>
My intention is not to provide this option as a matter of lack of necessity; I am unaware of any consideration on this matter from gcc-rs.</p>



<a name="254096554"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254096554" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254096554">(Sep 20 2021 at 18:32)</a>:</h4>
<p>I'm not arguing that it's a necessity. I'm just observing that it <em>contributes</em> to the likelihood of an option creating an issue and leading people to rely on it.</p>



<a name="254096613"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254096613" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254096613">(Sep 20 2021 at 18:33)</a>:</h4>
<p><span class="user-mention" data-user-id="120791">@RalfJ</span> Despite <code>-falign-functions</code> potentially affecting semantics in a way people can rely on, I don't think such an option is likely to cause any serious issue, for a few different reasons.</p>



<a name="254097495"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254097495" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254097495">(Sep 20 2021 at 18:39)</a>:</h4>
<p>It's very much in the vein of "optional hack", and it's so very simple to <em>not</em> rely on it; the delta it represents is so small that making a non-specialized program that inherently relies on it seems exceedingly unlikely.</p>



<a name="254290023"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254290023" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254290023">(Sep 21 2021 at 22:50)</a>:</h4>
<p>I see, makes sense</p>



<a name="254293939"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254293939" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254293939">(Sep 21 2021 at 23:34)</a>:</h4>
<p>I actually had a question reguarding this.<br>
So an option like -Z borrowck=no wouldn't be a good idea as demonstrated above, but what about --disable-borrowck (configure option removing borrowck support altogether, so basically mrustc). I noted previously that lccc has this option (and some logic to enable/disable it by default, depending on rustc version) to avoid elevating build requirements, particularly when bootstrapping (lccc is ideally buildable with mrustc or one step away).</p>



<a name="254298245"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254298245" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254298245">(Sep 22 2021 at 00:27)</a>:</h4>
<p>I think if there was some bootstrapping reason why it was important, such as building without it to then use that compiler to build polonius for a stage 2 build, that would make sense. But shipping that as a Rust compiler would cause problems.</p>



<a name="254299530"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254299530" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254299530">(Sep 22 2021 at 00:45)</a>:</h4>
<p>(Note that in lccc, the default build is not a bootstrap build as with gcc or rustc, rather the default build is a single stage like llvm is - this behaviour is controlled by the <code>--enable-boostrap</code> (which is disabled by default)  flag, or else can be performed manually. Bootstrapping here refers to building the compiler from a chain starting with a language other than rust)</p>
<p><span class="user-mention silent" data-user-id="239881">Josh Triplett</span> <a href="#narrow/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers/near/254298245">said</a>:</p>
<blockquote>
<p>I think if there was some bootstrapping reason why it was important, such as building without it to then use that compiler to build polonius for a stage 2 build, that would make sense. But shipping that as a Rust compiler would cause problems.</p>
</blockquote>
<p>This sort of depends what is meant by "shipping". As I noted previously, lccc is intended for source distributation rather than binary distribution, so in theory, the rust frontend is "shipped" with both options, and you'd choose this at the site. By default, of course, it will build the borrow checker if it detects that the host rust compiler (<code>$RUSTC</code> or <code>$RUSTC_FOR_BUILD</code>) is sufficiently capable of building polonius (if it's unsure, it will emit an error asking for one option or the other, though it will disable it for known bad <code>$RUSTC</code>s).</p>



<a name="254412675"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254412675" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254412675">(Sep 22 2021 at 18:13)</a>:</h4>
<p>Is the <code>-ffast-math</code> under discussion here one that makes basic math on floating-point be potentially UB?  Or to produce garbage results?  Or is it just doing things like FMA and replacing division with reciprocals?</p>
<p>Because I feel like they're very different conversations.</p>



<a name="254413283"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254413283" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254413283">(Sep 22 2021 at 18:17)</a>:</h4>
<p>I believe that in gcc/clang, -ffast-math makes certain operations Undefined Behaviour (specifically, it turns on -ffinite-math-only which makes it UB for an operation to produce an infinite or NaN result)</p>



<a name="254413503"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254413503" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254413503">(Sep 22 2021 at 18:19)</a>:</h4>
<p>(Which, in rust, would imply the flag is unsound. The idea is that code that cares wouldn't have issues with it)</p>



<a name="254421634"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/254421634" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#254421634">(Sep 22 2021 at 19:10)</a>:</h4>
<p>seems like, fitting into the larger Rust language, that's something that should go on functions/modules, not the entire compilation</p>



<a name="257402442"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/257402442" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#257402442">(Oct 13 2021 at 17:10)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers/near/254413503">said</a>:</p>
<blockquote>
<p>(Which, in rust, would imply the flag is unsound. The idea is that code that cares wouldn't have issues with it)</p>
</blockquote>
<p>This is what scares me, yeah.  Anything that allows UB from safe code -- even if opted into from a compiler flag -- isn't something that would make me happy.  And <code>f32: Add</code>, so we can't really even say "well the <code>+</code> becomes <code>unsafe</code> for floats".</p>



<a name="257410091"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/257410091" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#257410091">(Oct 13 2021 at 18:00)</a>:</h4>
<p>Isn't there precedent for compiler flags being unsafe (such as -C target-feature)?</p>



<a name="257447995"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/257447995" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#257447995">(Oct 13 2021 at 22:19)</a>:</h4>
<p>not really. in the case of target feature the entire program is still safe, you just need a higher minimum CPU. However, all programs always have implied minimum CPU requirements you're expected to meet before you even begin to discuss soundness.</p>



<a name="257448230"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/257448230" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#257448230">(Oct 13 2021 at 22:21)</a>:</h4>
<p>If you build a program for x86 and try to run it on an ARM device... when things go wrong that's not because of an unsound part of the program, that's a simple user error.</p>



<a name="257452277"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/257452277" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#257452277">(Oct 13 2021 at 23:00)</a>:</h4>
<p>Well, <code>-C target-cpu</code> can cause ABI mismatches with floating-point types on i686, even if we don't call entering code with a particular target-feature enabled UB if it is not actually present (which is what I would argue is the semantics).</p>



<a name="257469283"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/257469283" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#257469283">(Oct 14 2021 at 02:19)</a>:</h4>
<p>I <em>would</em> call it UB to enter code compiled for a feature level that the CPU doesn't support, but I still would not call the flag itself unsafe just because the binary could potentially be misused after the compilation completes.</p>
<p>In the case of the floating point stuff on i686, yeah I guess that's essentially a linking error being caused by the flag, so I suppose the flag should count as unsafe, or at least "dangerous" (if we want to reserve unsafe for specifically Rust code related concerns).</p>



<a name="257497507"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/257497507" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#257497507">(Oct 14 2021 at 08:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="224471">Lokathor</span> <a href="#narrow/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers/near/257469283">said</a>:</p>
<blockquote>
<p>In the case of the floating point stuff on i686, yeah I guess that's essentially a linking error being caused by the flag, so I suppose the flag should count as unsafe, or at least "dangerous" (if we want to reserve unsafe for specifically Rust code related concerns).</p>
</blockquote>
<p>It's not even a linker error. <a href="https://godbolt.org/z/eKzzajPzE">https://godbolt.org/z/eKzzajPzE</a></p>



<a name="257539914"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Alternative%20semantics%20of%20alternative%20Rust%20compilers/near/257539914" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers.html#257539914">(Oct 14 2021 at 14:00)</a>:</h4>
<p>I am aware it's not a literal error code produced by the linker. however, a symbol was declared to be available using a particular signature and then the linker was provided an object file that contains the symbol but under some other signature. So I would say that it's an issue in the linking stage of the compilation. If a correct object file were provided to the linker instead then there would have been no problem.</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>