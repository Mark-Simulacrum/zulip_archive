<html>
<head><meta charset="utf-8"><title>type ascription *in patterns* · t-lang · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/index.html">t-lang</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/type.20ascription.20*in.20patterns*.html">type ascription *in patterns*</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="213985025"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/type%20ascription%20%2Ain%20patterns%2A/near/213985025" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/type.20ascription.20*in.20patterns*.html#213985025">(Oct 20 2020 at 22:00)</a>:</h4>
<p>It seems like most of the worries about type ascription in the other thread are about its use in expressions.</p>
<p>How might people feel about it on non-top-level bindings in <em>patterns</em>?</p>
<p>Something like this seems rather nice, to me:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">match</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">parse</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">y</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">..</span><span class="p">.</span><span class="w"></span>
<span class="w">    </span><span class="nb">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">..</span><span class="p">.</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>For now I'm explicitly talking about putting this only on bindings, not on arbitrary sub-patterns, though that of course could be done too.</p>
<p>(boats also made a comment in this direction in the other thread, that probably helped raise this in my head.)</p>



<a name="213991474"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/type%20ascription%20%2Ain%20patterns%2A/near/213991474" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/type.20ascription.20*in.20patterns*.html#213991474">(Oct 20 2020 at 23:23)</a>:</h4>
<p>Ascriptions in patterns feel like a natural thing to have. On top of the added readability (c.f. IDEs) I talked about in the other thread, it would also make <code>let</code> bindings be less special <span aria-label="+1" class="emoji emoji-1f44d" role="img" title="+1">:+1:</span></p>



<a name="213998130"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/type%20ascription%20%2Ain%20patterns%2A/near/213998130" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/type.20ascription.20*in.20patterns*.html#213998130">(Oct 21 2020 at 01:07)</a>:</h4>
<p>For back-compat I think let still needs to be more than just <code>let $pat</code>, since </p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">Wrapping</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>: <span class="nc">Wrapping</span><span class="o">&lt;</span><span class="kt">u64</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Wrapping</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span><span class="w"></span>
</code></pre></div>

<p>works today.  Getting to "let is just a pattern" needs the full &lt;<a href="https://github.com/Centril/rfcs/blob/rfc/generalized-type-ascription/text/0000-generalized-type-ascription.md#type-ascription-in-patterns">https://github.com/Centril/rfcs/blob/rfc/generalized-type-ascription/text/0000-generalized-type-ascription.md#type-ascription-in-patterns</a>&gt;.  (Or I suppose removing the <code>$pat: $type</code> in an edition, which arguably could make things easier to parse without accidentally allowing <code>let x:u64:u64 = 4;</code>.)</p>



<a name="214004068"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/type%20ascription%20%2Ain%20patterns%2A/near/214004068" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/type.20ascription.20*in.20patterns*.html#214004068">(Oct 21 2020 at 03:09)</a>:</h4>
<p>What? I thought this was already stable</p>



<a name="214004123"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/type%20ascription%20%2Ain%20patterns%2A/near/214004123" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/type.20ascription.20*in.20patterns*.html#214004123">(Oct 21 2020 at 03:10)</a>:</h4>
<p>I don't think <code>let x:u64:u64 = 4;</code> should be prevented either, if it is a natural consequence of the grammar</p>



<a name="214004438"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/type%20ascription%20%2Ain%20patterns%2A/near/214004438" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/type.20ascription.20*in.20patterns*.html#214004438">(Oct 21 2020 at 03:18)</a>:</h4>
<p>oops, I see you are only talking about ascriptions on binders, not patterns. I want type ascriptions everywhere they can reasonably be placed, notwithstanding issues in expression syntax (in particular because this is not something where alternate syntax to do the same thing exists). There are named args objections to type ascriptions in a struct or enum pattern, but this could be solved by preferring named args over type ascription, and requiring parentheses to get the latter. What are thoughts on using parentheses like this:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">struct</span> <span class="nc">Foo</span><span class="w"> </span><span class="p">{</span><span class="n">x</span>: <span class="kt">u32</span><span class="p">}</span><span class="w"></span>
<span class="k">fn</span> <span class="nf">bla</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{(</span><span class="n">x</span>: <span class="kt">u32</span><span class="p">)}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span><span class="n">x</span>: <span class="mi">0</span><span class="p">};</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>



<a name="214078306"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/type%20ascription%20%2Ain%20patterns%2A/near/214078306" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nikomatsakis <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/type.20ascription.20*in.20patterns*.html#214078306">(Oct 21 2020 at 16:39)</a>:</h4>
<p><span class="user-mention" data-user-id="125270">@scottmcm</span> I think I favor it in bindings. The precedence there is indeed quite strong.</p>



<a name="261184714"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/type%20ascription%20%2Ain%20patterns%2A/near/261184714" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Wrenn <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/type.20ascription.20*in.20patterns*.html#261184714">(Nov 11 2021 at 21:08)</a>:</h4>
<p>I observed a somewhat-new Rust programmer encounter a situation where this feature would be nice. This snippet (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=5f48d6b8fd01431c98e77bdd2e2e73d0">playground</a>) produces a type inferencing error:<br>
<a href="/user_uploads/4715/EHS608N6wMeLyKAk-OP2Ub7H/Screen-Shot-2021-11-11-at-3.52.28-PM.png">Screen-Shot-2021-11-11-at-3.52.28-PM.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/4715/EHS608N6wMeLyKAk-OP2Ub7H/Screen-Shot-2021-11-11-at-3.52.28-PM.png" title="Screen-Shot-2021-11-11-at-3.52.28-PM.png"><img src="/user_uploads/4715/EHS608N6wMeLyKAk-OP2Ub7H/Screen-Shot-2021-11-11-at-3.52.28-PM.png"></a></div><p>Although rustc is unable to infer the type of the closure's parameters, rust-analyzer <em>is</em> able to do so, and displays its inferred type hints like this:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">reticulate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">buf</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">invert</span>: <span class="kt">bool</span><span class="p">)</span><span class="o">|</span><span class="w"> </span><span class="n">reticulate_splines</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">buf</span><span class="p">[</span><span class="o">..</span><span class="p">],</span><span class="w"> </span><span class="n">invert</span><span class="p">);</span><span class="w"></span>
</code></pre></div>
<p>The discrepancy between the error (types are unknown) and what's displayed in the editor (inferred types) is jarring enough, but if the user then tries to add rust-analyzer's type hints to their source code, they get a syntax error. The above snippet is invalid rust; the types need to go outside the tuple:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">reticulate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">buf</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">invert</span>: <span class="kt">bool</span><span class="p">)</span><span class="o">|</span><span class="w"> </span><span class="n">reticulate_splines</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">buf</span><span class="p">[</span><span class="o">..</span><span class="p">],</span><span class="w"> </span><span class="n">invert</span><span class="p">);</span><span class="w"></span>
</code></pre></div>
<p><strong>I think rust-analyzer is broadly doing the Right thing in trying to display types as close to the identifiers as possible.</strong> It'd just be nice if the natural place for these hints was also valid Rust. Type ascription in patterns would permit this.</p>



<a name="261267388"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/type%20ascription%20%2Ain%20patterns%2A/near/261267388" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Wrenn <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/type.20ascription.20*in.20patterns*.html#261267388">(Nov 12 2021 at 15:22)</a>:</h4>
<p><span class="user-mention" data-user-id="125270">@scottmcm</span> what's the back compat issue?</p>



<a name="261287485"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/type%20ascription%20%2Ain%20patterns%2A/near/261287485" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/type.20ascription.20*in.20patterns*.html#261287485">(Nov 12 2021 at 17:52)</a>:</h4>
<p><span class="user-mention silent" data-user-id="219211">Jack Wrenn</span> <a href="#narrow/stream/213817-t-lang/topic/type.20ascription.20*in.20patterns*/near/261267388">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="125270">scottmcm</span> what's the back compat issue?</p>
</blockquote>
<p>I think they were hinting at the following scenario:</p>
<ul>
<li><code>let</code> bindings would just be <code>let &lt;pat&gt; = &lt;expr&gt;</code> (note the lack of <code>ty</code> annotation),</li>
<li><code>&lt;pat&gt;</code>terns would allow for a type ascription at the binder level:</li>
</ul>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="kd">let</span><span class="w">  </span><span class="n">x</span>: <span class="kt">i32</span>  <span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">y</span>: <span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="n">z</span>: <span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">27</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span><span class="p">);</span><span class="w"></span>
</code></pre></div>
<p>Such a change would break code such as the <code>Wrapping</code> example they used, as well as the more common <code>let (y, z): (u8: bool)</code>.</p>
<p>So the first bullet would have to be dropped, at least for the current editions, and in that case, if <code>let</code> were allowed to <code>let &lt;pat&gt; : &lt;ty&gt;</code>, then <code>let x:u64: u64</code> would be valid Rust syntax, which looks a bit weird and thus seems to be deemed undesirable.</p>
<ul>
<li>Note that we can currently write <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=b96673f5933177fa34def07e958414ef"><code>matches!(Some { 0: () }, None::&lt;_&gt; { .. })</code></a> (which evaluates to <code>false</code> ofc.), so we already have weird stuff the grammar allows us to write. I kind of agree with <span class="user-mention" data-user-id="271719">@Mario Carneiro</span> on that front, thus.</li>
</ul>
<hr>
<p>My personal take on this —and I may be talking with a macro author bias (whereby neither <code>:pat</code> nor <code>:pat_param</code> can be followed by <code>:</code> in case they were to bundle a type ascription in the future)— is that we embrace the <code>:pat</code> / <code>:pat_param </code> distinction that already exists: to have a top-level pattern grammar type (similar to the current <a href="https://doc.rust-lang.org/1.56.1/reference/patterns.html"><code>PatternNoTopAlt</code></a> but not quite the same), which on top of not allowing <code>or_patterns</code> as it currently does, it wouldn't allow any form of outer type ascription either (thus allowing macro authors to finally write <code>$arg:pat_param : $Arg:ty</code>). The <code>let</code> binding grammar would then be <code>let &lt;pat_param&gt; $(: &lt;ty&gt;)? = &lt;expr&gt;;</code></p>
<p>Thus, on top of the macro improvement (I repeat this because it can be extremely frustrating to have subpar support for closures and function defs in <code>macro_rules!</code> macros just because of this), it would deny things such as <code>let x: u64: u64</code> (it would allow <code>let (x: u64): u64</code>, but that one seems way more reasonable already).</p>
<hr>
<p>Now the only remaining question would be the case of <code>ref mut out @ None</code> (a pattern I, and other people, may have written so as to ensure <code>*out = Some(…);</code> is a set and not a replace operation) <em>w.r.t.</em> these ascriptions? Which should it be:</p>
<ul>
<li>
<p><code>ref mut out: Option&lt;T&gt; @ None</code></p>
</li>
<li>
<p><code>ref mut out @ None: Option&lt;T&gt;</code></p>
</li>
<li>
<p>Neither: the type-ascripted binder would not be compatible with <code>@</code> currently. In that case, would smth like <code>(ref mut out: Option&lt;T&gt;) @ None</code> be allowed? That is, should the <code>Identifier</code> pattern be changed to take a <code>Binder</code> pattern before the <code>@</code>, and that <code>Binder</code> pattern would then be <code>ref? mut? &lt;ident&gt; (: &lt;ty&gt;)?</code></p>
</li>
</ul>
<p>I haven't looked into the details of these grammar changes I'm suggesting (the <code>PatParam</code> <em>vs.</em> <code>NestedPat</code> distinction may yield a slightly cumbersome grammar definition), but it looks doable in a retro-compatible fashion.</p>



<a name="261291399"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/type%20ascription%20%2Ain%20patterns%2A/near/261291399" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Wrenn <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/type.20ascription.20*in.20patterns*.html#261291399">(Nov 12 2021 at 18:20)</a>:</h4>
<p>Oh, gotcha! My point of confusion was the <em>at the binder level</em> restriction, I think. I was actually imagining that:</p>
<ul>
<li><code>let</code> bindings would just be <code>let &lt;pat&gt; = &lt;expr&gt;</code></li>
<li><code>&lt;pat&gt;</code>terns would allow for type ascription at almost any level</li>
</ul>
<p>In such a scenario, all of these would be equally acceptable:</p>
<ul>
<li><code>let Wrapping(x) = ...</code></li>
<li><code>let Wrapping(x): Wrapping&lt;u8&gt; = ...</code></li>
<li><code>let Wrapping(x: u8) = ...</code></li>
<li><code>let Wrapping(x: u8): Wrapping&lt;_&gt; = ...</code></li>
</ul>
<p>...but <em>not</em>:</p>
<ul>
<li><code>let Wrapping(x): Wrapping&lt;_&gt;: Wrapping&lt;_&gt;  = ...</code></li>
</ul>



<a name="261292560"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/type%20ascription%20%2Ain%20patterns%2A/near/261292560" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Wrenn <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/type.20ascription.20*in.20patterns*.html#261292560">(Nov 12 2021 at 18:29)</a>:</h4>
<p>(to be clear, while I think it's a nice bonus that <code>let u8:u8:u8 = 42</code> wouldn't be valid Rust in this scenario, it wouldn't bother me all that much if it were valid. the fact that silly things like <code>let c@r@v@n = 42;</code> are possible hasn't caused any actual crisis in rust readability.)</p>



<a name="261293173"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/type%20ascription%20%2Ain%20patterns%2A/near/261293173" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Wrenn <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/type.20ascription.20*in.20patterns*.html#261293173">(Nov 12 2021 at 18:34)</a>:</h4>
<p><span class="user-mention" data-user-id="232018">@Daniel Henry-Mantilla</span> can you say a little more about the <code>ref mut out @ None</code> pattern? Or point me to some discussion where the issue was raised?  A code snippet where the pattern is used would be helpful!</p>



<a name="261293379"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/type%20ascription%20%2Ain%20patterns%2A/near/261293379" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/type.20ascription.20*in.20patterns*.html#261293379">(Nov 12 2021 at 18:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="232018">Daniel Henry-Mantilla</span> <a href="#narrow/stream/213817-t-lang/topic/type.20ascription.20*in.20patterns*/near/261287485">said</a>:</p>
<blockquote>
<p>whereby neither <code>:pat</code> nor <code>:pat_param</code> can be followed by <code>:</code> in case they were to bundle a type ascription in the future</p>
</blockquote>
<p>Oh, that was actually restricted properly?  Then there might not even exist the issue that I was thinking of -- you were right that I was worried about things like <code>$p:pat : $t:ty</code> in macros.</p>
<p>Incorporating the type annotation difference into the existing pat/pat_param split is really clever <span aria-label="+1" class="emoji emoji-1f44d" role="img" title="+1">:+1:</span></p>



<a name="261293979"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/type%20ascription%20%2Ain%20patterns%2A/near/261293979" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/type.20ascription.20*in.20patterns*.html#261293979">(Nov 12 2021 at 18:40)</a>:</h4>
<p><span class="user-mention silent" data-user-id="219211">Jack Wrenn</span> <a href="#narrow/stream/213817-t-lang/topic/type.20ascription.20*in.20patterns*/near/261293173">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="232018">Daniel Henry-Mantilla</span> can you say a little more about the <code>ref mut out @ None</code> pattern? Or point me to some discussion where the issue was raised?  A code snippet where the pattern is used would be helpful!</p>
</blockquote>
<p>There is no real issue there, I was just wondering of <em>where</em> to put the ascription should it only go on the binder (most of the syntaxes don't look super great, hence my asking, but maybe I'm just imagining a non-issue). Regarding an example of usage of such pattern, <a href="https://github.com/danielhenrymantilla/fix_hidden_lifetime_bug.rs/blob/v0.2.4/src/proc_macros/collect_lifetime_params.rs#L85-L112">here is one</a></p>



<a name="261294040"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/type%20ascription%20%2Ain%20patterns%2A/near/261294040" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/type.20ascription.20*in.20patterns*.html#261294040">(Nov 12 2021 at 18:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="232018">Daniel Henry-Mantilla</span> <a href="#narrow/stream/213817-t-lang/topic/type.20ascription.20*in.20patterns*/near/261287485">said</a>:</p>
<blockquote>
<p>Now the only remaining question would be the case of <code>ref mut out @ None</code></p>
</blockquote>
<p>I've been thinking of this as "in bindings" rather than generally "in patterns".  So to me I'd expect the <code>out: Option&lt;T&gt; @ None</code> order, since the annotation is only allowed after a binding ident.  (Not in fully general locations -- at least for now, maybe never -- like <code>([a, b]: Ty, [c, d]: Ty)</code>.)</p>
<p>I think the locality of that is better too, now that <code>foo @ (a, b, c, d, e)</code> works, and <code>foo @ (a, b, c, d, e) : &amp;Blah</code> seems like the wrong place -- <code>foo : &amp;Blah @ (a, b, c, d, e)</code> reads better to me.</p>



<a name="261296874"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/type%20ascription%20%2Ain%20patterns%2A/near/261296874" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Wrenn <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/type.20ascription.20*in.20patterns*.html#261296874">(Nov 12 2021 at 19:05)</a>:</h4>
<blockquote>
<p>Not in fully general locations -- at least for now, maybe never -- like <code>([a, b]: Ty, [c, d]: Ty)</code>.</p>
</blockquote>
<p>Hm, I'm pretty sure I've had times where I've really wanted to write virtually exactly that; e.g.:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">distance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="p">([</span><span class="n">x_0</span><span class="p">,</span><span class="w"> </span><span class="n">y_0</span><span class="p">)]</span>: <span class="nc">Point2D</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">x_1</span><span class="p">,</span><span class="w"> </span><span class="n">y_1</span><span class="p">]</span>: <span class="nc">Point2D</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="p">)</span><span class="o">|</span><span class="w"> </span><span class="fm">unimplemented!</span><span class="p">();</span><span class="w"></span>
</code></pre></div>
<p>(where <code>pub type Point2D&lt;T&gt; = [T; 2];</code>) </p>
<p>Why might you not want to allow that?</p>



<a name="261298465"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/type%20ascription%20%2Ain%20patterns%2A/near/261298465" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nikomatsakis <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/type.20ascription.20*in.20patterns*.html#261298465">(Nov 12 2021 at 19:19)</a>:</h4>
<p>There was an RFC about this at some point</p>



<a name="261298515"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/type%20ascription%20%2Ain%20patterns%2A/near/261298515" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nikomatsakis <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/type.20ascription.20*in.20patterns*.html#261298515">(Nov 12 2021 at 19:20)</a>:</h4>
<p>I often want this</p>



<a name="261298655"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/type%20ascription%20%2Ain%20patterns%2A/near/261298655" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Wrenn <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/type.20ascription.20*in.20patterns*.html#261298655">(Nov 12 2021 at 19:20)</a>:</h4>
<p>Are you thinking of the <a href="https://github.com/rust-lang/rfcs/pull/2522">Generalized Type Ascription</a> RFC?</p>



<a name="261307196"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/type%20ascription%20%2Ain%20patterns%2A/near/261307196" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Wrenn <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/type.20ascription.20*in.20patterns*.html#261307196">(Nov 12 2021 at 20:33)</a>:</h4>
<p>I haven't yet wrapped my head around all of the semantic issues noted in the discussion of that RFC, but I wonder if any that pertain to type-ascription-in-patterns can be avoided by first <em>just</em> supporting type ascription in patterns that are already accompanied by types:</p>
<ul>
<li><code>let PAT: TYPE = ...;</code></li>
<li><code>|PAT: TYPE| ...</code></li>
<li><code>fn foo(PAT: TYPE) { ... }</code></li>
</ul>
<p>...because in these cases, any types that appear in the <code>PAT</code> can be rewritten to occurring in <code>TYPE</code>; e.g.,</p>
<ul>
<li><code>let (a: u8, b) = ...</code> is equivalent to:<br>
<code>let (a, b): (u8, _) = ...</code></li>
</ul>
<p>There's still the <a href="https://github.com/rust-lang/rfcs/pull/2522#issuecomment-454508792">question</a> of "What if the type annotations disagree?"; e.g.,</p>
<ul>
<li><code>let (a: &amp;'a u8, b): (&amp;'static u8, _) = ...</code></li>
</ul>
<p>...but that can be resolved conservatively by requiring that all annotations can be unified into a single annotation without subtyping or coercion.</p>



<a name="261308924"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/type%20ascription%20%2Ain%20patterns%2A/near/261308924" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/type.20ascription.20*in.20patterns*.html#261308924">(Nov 12 2021 at 20:51)</a>:</h4>
<p>I don't think that works in function patterns, because there <code>TYPE</code> is required; is the type supposed to be reconstructed from the pattern?</p>



<a name="261310772"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/type%20ascription%20%2Ain%20patterns%2A/near/261310772" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Wrenn <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/type.20ascription.20*in.20patterns*.html#261310772">(Nov 12 2021 at 21:06)</a>:</h4>
<p>All of these cases require modifying the relevant points of the grammar from <code>Pattern : Type</code> to <code>Pattern</code>. The grammar change in this case would be roughly from this:</p>
<blockquote>
<p>FunctionParamPattern: PatternNoTopAlt <code>:</code> Type</p>
</blockquote>
<p>...to this:</p>
<blockquote>
<p>FunctionParamPattern: PatternNoTopAlt</p>
</blockquote>
<p>(but a lil more complicated because of variadic functions allowing for <code>...</code>)</p>
<p>I, personally, wouldn't mind being able to write:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span> <span class="nf">distance</span><span class="p">(</span><span class="n">metric</span>: <span class="nc">DistanceMetric</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">x0</span>: <span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="n">y0</span>: <span class="kt">u8</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="n">x1</span>: <span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="n">y1</span>: <span class="kt">u8</span><span class="p">))</span><span class="w"> </span>-&gt; <span class="kt">u8</span> <span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="fm">unimplemented!</span><span class="p">()</span><span class="w"></span>
</code></pre></div>
<p>...but in the discussion on that RFC, at least one person mentioned not wanting to further encourage the use of patterns in parameter lists, iirc.</p>
<p>At any rate: If we <em>did</em> allow this, there'd be an extra well-formedness check to make sure that the reconstructed top-level type didn't have any placeholders.</p>



<a name="261319832"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/type%20ascription%20%2Ain%20patterns%2A/near/261319832" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/type.20ascription.20*in.20patterns*.html#261319832">(Nov 12 2021 at 22:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="219211">Jack Wrenn</span> <a href="#narrow/stream/213817-t-lang/topic/type.20ascription.20*in.20patterns*/near/261310772">said</a>:</p>
<blockquote>
<p>I, personally, wouldn't mind being able to write:</p>
<p><div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span> <span class="nf">distance</span><span class="p">(</span><span class="n">metric</span>: <span class="nc">DistanceMetric</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">x0</span>: <span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="n">y0</span>: <span class="kt">u8</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="n">x1</span>: <span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="n">y1</span>: <span class="kt">u8</span><span class="p">))</span><span class="w"> </span>-&gt; <span class="kt">u8</span>
</code></pre></div><br>
</p>
</blockquote>
<p>I originally agreed, but the further discussion about it convinced me that having parameters always have the unambiguous <code>$pat : $ty</code> is right.  It might be ok for tuples, but I don't think it's worth doing it for just them, and the discussion convinced me that </p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span> <span class="nf">distance</span><span class="p">(</span><span class="n">metric</span>: <span class="nc">DistanceMetric</span><span class="p">,</span><span class="w"> </span><span class="n">Wrapping</span><span class="p">(</span><span class="n">x</span>: <span class="kt">u8</span><span class="p">))</span><span class="w"></span>
</code></pre></div>
<p>is undesirable (even though it's fully-specified).</p>



<a name="261320119"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/type%20ascription%20%2Ain%20patterns%2A/near/261320119" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Boxy [she/her] <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/type.20ascription.20*in.20patterns*.html#261320119">(Nov 12 2021 at 22:35)</a>:</h4>
<p>oh wow i'd love to be able to write <code>fn distance(Wrapping(x: u8))</code></p>



<a name="261320719"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/type%20ascription%20%2Ain%20patterns%2A/near/261320719" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/type.20ascription.20*in.20patterns*.html#261320719">(Nov 12 2021 at 22:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="219211">Jack Wrenn</span> <a href="#narrow/stream/213817-t-lang/topic/type.20ascription.20*in.20patterns*/near/261296874">said</a>:</p>
<blockquote>
<p>Why might you not want to allow that?</p>
</blockquote>
<p>Binding modes make it a little funky, and I'm not convinced it's ever better to annotate the pattern instead of the binding.  I like that if it's on a binding, we can say that that's definitely the type of the binding, the same way it is on a normal <code>let x: Ty</code>.  Whereas <code>Foo(x): &amp;mut Foo</code> feels weird to me as a sub-pattern.  (But I guess it's already a bit weird to annotate like that at the top level, so maybe that ship has sailed.  Not that I ever see people write code that looks like that.)</p>
<p>The only time you can't annotate the binding is for something which there's a phantom type parameter, but all the places I've ever wanted this haven't been phantom.</p>
<p>Notably your example doesn't actually annotate anything meaningful -- or, at least, it wouldn't if &lt;<a href="https://github.com/rust-lang/rust/issues/76342">https://github.com/rust-lang/rust/issues/76342</a>&gt; were fixed.  And I think <code>([x_0: i32, y_0], [x_1: i32, y_0])</code> is a fine way to annotate arrays.</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>