<html>
<head><meta charset="utf-8"><title>Explicit closure lifetimes · t-lang · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/index.html">t-lang</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Explicit.20closure.20lifetimes.html">Explicit closure lifetimes</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="266401264"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Explicit%20closure%20lifetimes/near/266401264" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Explicit.20closure.20lifetimes.html#266401264">(Dec 30 2021 at 04:20)</a>:</h4>
<p>TL; DR - I'd like to propose allowing <code>for&lt;'a&gt; |closure_arg: &amp;'a str|</code> to explicitly indicate a higher-ranked closure. Regardless of what we decide to do about the closure region inference issues described below, I think this will help to improve the clarity of certain tricky code.</p>
<p>I've been revisiting some of the open issues around closure lifetimes (<a href="https://github.com/rust-lang/rust/issues/91966">https://github.com/rust-lang/rust/issues/91966</a> and <a href="https://github.com/rust-lang/rust/issues/41078">https://github.com/rust-lang/rust/issues/41078</a>). From what I can tell, there are essentially two problems that can happen:</p>
<ol>
<li>We infer a higher-ranked region (<code>for&lt;'a&gt; fn(&amp;'a u8)</code>) when we really want some specific (local) region. This occurs in the following code:</li>
</ol>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span> <span class="nf">main</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">fields</span>: <span class="nb">Vec</span><span class="o">&lt;&amp;</span><span class="kt">str</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">pusher</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="n">a</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="o">|</span><span class="w"> </span><span class="n">fields</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">a</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>which gives the error:</p>
<div class="codehilite"><pre><span></span><code>error[E0521]: borrowed data escapes outside of closure
 --&gt; src/main.rs:3:28
  |
2 |     let mut fields: Vec&lt;&amp;str&gt; = Vec::new();
  |         ---------- `fields` declared here, outside of the closure body
3 |     let pusher = |a: &amp;str| fields.push(a);
  |                   -        ^^^^^^^^^^^^^^ `a` escapes the closure body here
  |                   |
  |                   `a` is a reference that is only valid in the closure body
</code></pre></div>
<p>The issue is that <code>Vec&lt;&amp;str&gt;</code> is not higher-ranked, so we can only push an <code>&amp;'0 str</code> for some specific lifetime <code>'0</code>. The <code>pusher</code> closure signature requires that it accept <em>any</em> lifetime, which leads to a compiler error.</p>
<ol start="2">
<li>We infer some specific region when we really want a higher-ranked region. This occurs in the following code:</li>
</ol>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">cell</span>::<span class="n">Cell</span><span class="p">;</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">static_cell</span>: <span class="nc">Cell</span><span class="o">&lt;&amp;'</span><span class="nb">static</span><span class="w"> </span><span class="kt">u8</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Cell</span>::<span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">25</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">closure</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="n">s</span><span class="o">|</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>
<span class="w">    </span><span class="n">closure</span><span class="p">(</span><span class="n">static_cell</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">30</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">short_cell</span>: <span class="nc">Cell</span><span class="o">&lt;&amp;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Cell</span>::<span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">val</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">closure</span><span class="p">(</span><span class="n">short_cell</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>I'm using <code>Cell</code> to force invariance, since otherwise, region subtyping will make this example work even without a higher-ranked region. The above code produces the following error:</p>
<div class="codehilite"><pre><span></span><code>error[E0597]: `val` does not live long enough
  --&gt; src/main.rs:8:43
   |
4  |     let static_cell: Cell&lt;&amp;&#39;static u8&gt; = Cell::new(&amp;25);
   |                      ----------------- type annotation requires that `val` is borrowed for `&#39;static`
...
8  |     let short_cell: Cell&lt;&amp;u8&gt; = Cell::new(&amp;val);
   |                                           ^^^^ borrowed value does not live long enough
9  |     closure(short_cell);
10 | }
   | - `val` dropped here while still borrowed
</code></pre></div>
<p>Here, the closure gets inferred to <code>|s: Cell&lt;&amp;'static u8&gt;|</code>, so it cannot accept a <code>Cell&lt;&amp;'0 u8&gt;</code> for some shorter lifetime <code>&amp;'0</code>. What we really want is <code>for&lt;'a&gt; |s: Cell&lt;&amp;'a u8&gt;|</code>, so that the closure can accept both <code>Cell</code>s.</p>
<p>As far as I know, this is the only place in the compiler where type inference needs to pick between a higher-ranked region or a specific region in a <em>signature</em>. In all other cases, (functions, traits, <code>impl Trait</code>, etc), the signature is not inferred from a function body, so we never need to decide whether or not to 'convert' some specific region into a higher-ranked region.</p>
<p>It might be possible to improve the closure lifetime inference logic to always pick the 'correct' lifetime. However, even if this is possible, I think this will be one of the most complex things inferred by the compiler. In particular, I'm concerned that the leak-check changes could actually cause this to influence runtime behavior. As described in <a href="https://github.com/rust-lang/rust/pull/72493#issue-623623350">https://github.com/rust-lang/rust/pull/72493#issue-623623350</a>, the following impls do <strong>not</strong> overlap:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="c1">// impl A</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="k">fn</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="c1">// impl B</span>
</code></pre></div>
<p>This means that a higher-ranked closure <code>for&lt;'a&gt; |arg: &amp;'a str|</code> will coerce to a function pointer that uses impl A, while the non-higher-ranked closure <code>|arg: &amp;'0 str|</code> will coerce to a function pointer that uses impl B. I haven't yet been able to come up with an actual example where this happens automatically (I think an automatic closure to fn ptr coercion only happens when a function pointer type is explicitly written, not when we just have an impl for an fn ptr). However, I think this case is complex enough to be concerning, especially considering that it's not easy to tell whether or not a closure is higher-ranked.</p>
<p>Because of this complexity, I think it would be useful to allow explicitly specifying that a closure should be higher-ranked. Using <code>for&lt;'a&gt; |val: &amp;'a str|</code> seems like a natural extension of how lifetimes are explicitly indicated for functions (this syntax is currently banned for closures, so we don't need to worry about affecting existing code). This will provide a way of making a closure 'obviously' higher-ranked - even if the inference algorithm is improved, I think this will still be useful when improving a closure. For example, we might later decided to infer <code>|val: &amp;str|</code> to be non-higher-ranked in some cases, but <code>for&lt;'a&gt; |val: &amp;'str|</code> will always mean a higher-ranked closure.</p>
<p>Of course, this still leaves users without a way of explicitly indicating that a closure should <em>not</em> be higher-ranked (<code>|val: &amp;str|</code> currently gets inferred as a higher-ranked closure in all cases, I think). I considered <code>|val: &amp;'_ str|</code>, but that currently compiles and means the same thing as <code>|val: &amp;str|</code>. I think we could separately address non-higher-ranked lifetime annotations (if at all). Allowing <code>for&lt;'a&gt; |val: &amp;'a str|</code> will make closures more consistent with functions, and would make sense even if we never allow any other kind of explicit lifetime annotations.</p>



<a name="266401343"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Explicit%20closure%20lifetimes/near/266401343" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Explicit.20closure.20lifetimes.html#266401343">(Dec 30 2021 at 04:22)</a>:</h4>
<p>For reference, <code>for&lt;'a&gt; |_val: &amp;'a str| {}</code> current errors with:</p>
<div class="codehilite"><pre><span></span><code>error: cannot introduce explicit parameters for a closure
 --&gt; src/main.rs:2:5
  |
2 |     for&lt;&#39;a&gt; |_val: &amp;&#39;a str| {};
  |     ^^^^^^^ ------------------ the parameters are attached to this closure
  |     |
  |     help: remove the parameters
</code></pre></div>



<a name="266411485"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Explicit%20closure%20lifetimes/near/266411485" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Explicit.20closure.20lifetimes.html#266411485">(Dec 30 2021 at 08:24)</a>:</h4>
<p>I agree. <span class="user-mention" data-user-id="125294">@Aaron Hill</span> you could also mention all the cases where a <code>funnel</code> function is used to nudge the closure into getting the right signature (such instances can be foind in a bunch of the aforentioned issues, or abundantly on URLO).</p>
<p>Also, regarding the objective of a non-higher-order <code>|s : &amp;str|</code> closure, <span class="user-mention" data-user-id="125294">@Aaron Hill</span> , I believe that <code>for&lt;&gt;</code> syntax could achieve that: that is, the <code>for</code> syntax could be required to be exhaustive. That being said, a <code>|s| { let _: &amp;str = s; ... }</code> is another way to type annotate in a non-higher-order fashion a closure aprameter</p>



<a name="266442476"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Explicit%20closure%20lifetimes/near/266442476" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Explicit.20closure.20lifetimes.html#266442476">(Dec 30 2021 at 17:02)</a>:</h4>
<p>Is the idea that <code>for&lt;'a&gt; |first: &amp;'a str, second: &amp;bool|</code> would have a higher-ranked <code>str</code> reference but a non-higher-ranked <code>bool</code> reference?</p>



<a name="266442616"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Explicit%20closure%20lifetimes/near/266442616" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Explicit.20closure.20lifetimes.html#266442616">(Dec 30 2021 at 17:04)</a>:</h4>
<p>If so, I think that could work - however, I think it could be confusing that adding a explicit lifetime (by adding a <code>for&lt;&gt;</code>) can change the interpretation of a different</p>



<a name="266442656"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Explicit%20closure%20lifetimes/near/266442656" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Explicit.20closure.20lifetimes.html#266442656">(Dec 30 2021 at 17:05)</a>:</h4>
<p>We could start out by banning lifetime elision when <code>for&lt;&gt;</code> is used, so you can only use it to write entirely higher-ranked closures</p>



<a name="266442676"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Explicit%20closure%20lifetimes/near/266442676" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Explicit.20closure.20lifetimes.html#266442676">(Dec 30 2021 at 17:05)</a>:</h4>
<p>and then later decide what the behavior should be with a mixture of explicit and elided lifetimes inside <code>for&lt;&gt;</code></p>



<a name="266442955"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Explicit%20closure%20lifetimes/near/266442955" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Explicit.20closure.20lifetimes.html#266442955">(Dec 30 2021 at 17:10)</a>:</h4>
<p>If the overall idea sounds reasonable to everyone, I'll write up an RFC</p>



<a name="266447713"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Explicit%20closure%20lifetimes/near/266447713" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Explicit.20closure.20lifetimes.html#266447713">(Dec 30 2021 at 18:25)</a>:</h4>
<p>It looks like the possibility of accepting <code>for&lt;'a&gt; |param: &amp;'a str|</code> was previously mentioned in <a href="https://github.com/rust-lang/rust/pull/70209">https://github.com/rust-lang/rust/pull/70209</a></p>



<a name="266532377"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Explicit%20closure%20lifetimes/near/266532377" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Explicit.20closure.20lifetimes.html#266532377">(Jan 01 2022 at 01:01)</a>:</h4>
<p>Pre-RFC is up: <a href="https://internals.rust-lang.org/t/pre-rfc-allow-for-a-syntax-with-closures-for-explicit-higher-ranked-lifetimes/15888">https://internals.rust-lang.org/t/pre-rfc-allow-for-a-syntax-with-closures-for-explicit-higher-ranked-lifetimes/15888</a></p>



<a name="267117380"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Explicit%20closure%20lifetimes/near/267117380" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Explicit.20closure.20lifetimes.html#267117380">(Jan 06 2022 at 21:29)</a>:</h4>
<p>RFC is up: <a href="https://github.com/rust-lang/rfcs/pull/3216">https://github.com/rust-lang/rfcs/pull/3216</a></p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>