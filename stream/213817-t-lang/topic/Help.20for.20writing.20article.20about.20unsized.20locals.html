<html>
<head><meta charset="utf-8"><title>Help for writing article about unsized locals · t-lang · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/index.html">t-lang</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Help.20for.20writing.20article.20about.20unsized.20locals.html">Help for writing article about unsized locals</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="272802758"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Help%20for%20writing%20article%20about%20unsized%20locals/near/272802758" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Olivier FAURE <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Help.20for.20writing.20article.20about.20unsized.20locals.html#272802758">(Feb 22 2022 at 13:35)</a>:</h4>
<p>Hello rust-lang! I'm currently working on an article summarizing the current state of unsized locals in Rust (eg RFC 1909 and RFC 2884). Would anybody who has done compiler work related to these features be willing to read my draft and check there aren't any gross mistakes?</p>



<a name="272802775"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Help%20for%20writing%20article%20about%20unsized%20locals/near/272802775" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Olivier FAURE <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Help.20for.20writing.20article.20about.20unsized.20locals.html#272802775">(Feb 22 2022 at 13:35)</a>:</h4>
<p>Thanks in advance :)</p>



<a name="272803028"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Help%20for%20writing%20article%20about%20unsized%20locals/near/272803028" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Olivier FAURE <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Help.20for.20writing.20article.20about.20unsized.20locals.html#272803028">(Feb 22 2022 at 13:37)</a>:</h4>
<p>The current draft is here: <a href="https://github.com/PoignardAzur/poignardazur.github.io/blob/898fe4fdd13aca5ab9a9e04ac69461d49261a3c6/drafts/rust-design-unsized-vars-returns.md">https://github.com/PoignardAzur/poignardazur.github.io/blob/898fe4fdd13aca5ab9a9e04ac69461d49261a3c6/drafts/rust-design-unsized-vars-returns.md</a></p>



<a name="272803652"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Help%20for%20writing%20article%20about%20unsized%20locals/near/272803652" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Help.20for.20writing.20article.20about.20unsized.20locals.html#272803652">(Feb 22 2022 at 13:42)</a>:</h4>
<blockquote>
<p>Unsized locals have one major use case: passing unsized values to functions and returning unsized values, including trait objects. </p>
</blockquote>
<p>Passing unsized valued as arguments has been split into a separate feature. Unsized locals require alloca support from the codegen backend (which eg cranelift doesn't have), but unsized arguments don't as for them a pointer is passed without allocating anything on the stack.</p>



<a name="272806235"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Help%20for%20writing%20article%20about%20unsized%20locals/near/272806235" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Olivier FAURE <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Help.20for.20writing.20article.20about.20unsized.20locals.html#272806235">(Feb 22 2022 at 14:01)</a>:</h4>
<p>Oh, right, I forgot about that.</p>



<a name="272806381"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Help%20for%20writing%20article%20about%20unsized%20locals/near/272806381" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Olivier FAURE <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Help.20for.20writing.20article.20about.20unsized.20locals.html#272806381">(Feb 22 2022 at 14:02)</a>:</h4>
<p>But that feature is still under the tracking issue for RFC 1909, right?</p>



<a name="272810683"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Help%20for%20writing%20article%20about%20unsized%20locals/near/272810683" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Help.20for.20writing.20article.20about.20unsized.20locals.html#272810683">(Feb 22 2022 at 14:34)</a>:</h4>
<h3><em>Quid</em> of <code>&amp;own</code> references</h3>
<p><code>unsized_locals</code> still seems quite magical to me; while <code>alloca</code> does indeed require backend magic, there is a significant amount of <code>unsized_locals</code>, such as <code>unsized_fn_params</code> already, which can be tackled without it. Without <code>alloca</code>, the key abstraction for the mentioned features are <strong><code>&amp;own</code> references</strong>.</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span> <span class="nf">call</span><span class="w"> </span><span class="p">(</span><span class="n">f</span>: <span class="kp">&amp;</span><span class="nc">own</span><span class="w"> </span><span class="k">dyn</span><span class="w"> </span><span class="nb">FnOnce</span><span class="p">())</span><span class="w"></span>
</code></pre></div>
<div class="spoiler-block"><div class="spoiler-header">
<p>Incidentally &amp;own references also allow their own nifty things</p>
</div><div class="spoiler-content" aria-hidden="true">
<p>Such as a <code>ManualDrop</code> trait.</p>
<p>For starters, let's consider such a design but without <code>&amp;own</code>:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="cp">#[derive(ManualDropFields)]</span><span class="w"> </span><span class="c1">// type Fields = (F, );</span>
<span class="k">struct</span> <span class="nc">ScopeGuard</span><span class="o">&lt;</span><span class="n">F</span><span class="w"> </span>: <span class="nb">FnOnce</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">f</span>: <span class="nc">F</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">F</span><span class="w"> </span>: <span class="nb">FnOnce</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ManualDrop</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Foo</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">manual_drop</span><span class="p">((</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="p">)</span>: <span class="nc">Foo</span>::<span class="n">Fields</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">f</span><span class="p">();</span><span class="w"> </span><span class="c1">// Neither `unsafe`, nor an unnecessary `Option` discriminant!</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cm">/* Magic: dropping a `Foo` converts it into its raw fields, and calls `manual_drop` */</span><span class="w"></span>
</code></pre></div>
<p>But this has the problem of involving extra moving (<em>e.g.</em>, what happens if a field is not <code>Sized</code>? Or if <code>Pin</code>ning is involved?). And at that point we need <strong>owning indirection</strong>, but <strong>not necessarily heap-allocated</strong> —on the contrary!— Enter <code>&amp;own</code> references:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="c1">// type Fields&lt;'drop&gt; = (&amp;'drop own F, );</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">F</span><span class="w"> </span>: <span class="nb">FnOnce</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ManualDrop</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Foo</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">manual_drop</span><span class="p">((</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="p">)</span>: <span class="p">(</span><span class="o">&amp;'</span><span class="nb">_</span><span class="w"> </span><span class="n">own</span><span class="w"> </span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">f</span><span class="p">();</span><span class="w"> </span><span class="c1">// Neither `unsafe`, nor an unnecessary `Option` discriminant!</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cm">/* Magic: dropping a `Foo` generates `&amp;own` handles to each of its fields —in place!— and then calls `manual_drop` */</span><span class="w"></span>
</code></pre></div>
</div></div>
<p>With them, taking <code>unsized_fn_params</code> is as simple as taking <code>&amp;'_ own</code> parameters to them.</p>
<p>That's it.</p>
<p>That simple.</p>
<p>No magic ABI dance, no complex stack explanation with diagrams, compatibility with FFI and any <code>extern "ABI"</code> thanks to it being API-based.</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span> <span class="nf">call_me_maybe</span><span class="p">(</span><span class="n">f</span>: <span class="kp">&amp;</span><span class="nc">own</span><span class="w"> </span><span class="k">dyn</span><span class="w"> </span><span class="nb">FnOnce</span><span class="p">(),</span><span class="w"> </span><span class="n">maybe</span>: <span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">maybe</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">f</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="c1">// else `drop(f)`</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>Also, no wondering / pondering about the semantics of <code>let g = f;</code> : by virtue of being a reference, the "move the pointer" semantics would be clear (especially meaningful then the <code>!Sized</code> type would be a <code>[u8]</code> with a huge instance behind it), which thus obviously allows to write "middleware" / middle-layer functions very easily:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span> <span class="nf">middlelayer</span><span class="p">(</span><span class="n">f</span>: <span class="kp">&amp;</span><span class="nc">own</span><span class="w"> </span><span class="k">dyn</span><span class="w"> </span><span class="nb">FnOnce</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">foo</span><span class="p">(</span><span class="n">f</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>Regarding <code>dyn</code>-safety, we <em>could</em> then have the language magically support <code>self: Self</code> receivers by implicitly writing a <code>&amp;own self</code>-based shim, and having the <code>dyn Trait</code>s use that. But until then, users could write it themselves, or with a proc-macro. That's the beauty of a non magic core, to begin with.</p>
<p>This would be a more Rusty / less LLVM-y way of describing things (API-based implementation, rather than ABI-based), and something that would therefore generalize to giving more fine-grained control to callers and so on:</p>
<div class="spoiler-block"><div class="spoiler-header">
<p>The ABI under the API control even for existentials</p>
</div><div class="spoiler-content" aria-hidden="true">
<ul>
<li>Helper notation: since <code>impl</code>'s quantification (existential <em>vs.</em> universal) is position dependent, and the following will explore designs that require existentials in argument position, I'll be using the alternative syntax that the <code>impl Trait</code> RFCs suggested: <code>any Trait</code> for an universal one, and <code>some Trait</code> for an existential one.</li>
</ul>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span> <span class="nf">foo</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">some</span><span class="w"> </span><span class="nb">FnMut</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">env</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="cm">/* potentially huge */</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">move</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">_captured</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">env</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="c1">// …</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">goo</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">some</span><span class="w"> </span><span class="nb">FnMut</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo</span><span class="p">();</span><span class="w"> </span><span class="c1">// is the *potentially huge* `foo()` value unnecessarily memcpy-ed here?</span>
<span class="w">    </span><span class="n">f</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">f</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>could become:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="w">                                               </span><span class="c1">// or `dyn`</span>
<span class="w">                                               </span><span class="c1">// vvvv</span>
<span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="n">storage</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="nb">_</span> <span class="nc">mut</span><span class="w"> </span><span class="p">(</span><span class="n">some</span><span class="w"> </span><span class="nb">Sized</span><span class="p">))</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="o">'</span><span class="nb">_</span> <span class="nc">own</span><span class="w"> </span><span class="p">(</span><span class="n">some</span><span class="w"> </span><span class="nb">FnMut</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">storage</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="nb">_</span> <span class="nc">mut</span><span class="w"> </span><span class="n">Slot</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">storage</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">env</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="cm">/* … */</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">storage</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">_captured</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">env</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="c1">// …</span>
<span class="w">    </span><span class="p">})</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="w">                                               </span><span class="c1">// or `dyn`</span>
<span class="w">                                               </span><span class="c1">// vvvv</span>
<span class="k">fn</span> <span class="nf">goo</span><span class="p">(</span><span class="n">storage</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="nb">_</span> <span class="nc">mut</span><span class="w"> </span><span class="p">(</span><span class="n">some</span><span class="w"> </span><span class="nb">Sized</span><span class="p">))</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="o">'</span><span class="nb">_</span> <span class="nc">own</span><span class="w"> </span><span class="p">(</span><span class="n">some</span><span class="w"> </span><span class="nb">FnMut</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">storage</span><span class="p">);</span><span class="w"> </span><span class="c1">// move the small pointer</span>
<span class="w">    </span><span class="n">f</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">f</span><span class="w"> </span><span class="c1">// move the small pointer.</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
</div></div>
<p>It's easy to see from here how we could even start dealing with some cases of <code>-&gt; dyn</code> in return position, by relying on an <code>&amp;'_ mut (some Storage)</code> existential parameter, with which a <code>-&gt; &amp;_ own dyn</code> would "connect".</p>
<ul>
<li>(Related to this, <code>with</code> contexts could even alleviate the notation of this parameter).</li>
</ul>
<hr>
<p>Finally, in order to handle <code>dyn</code> safety in this case, and/or re-connect with allocators, a <code>&amp;'frame own T</code>, even for <code>T : ?Sized</code>, could be moved into an allocation by virtue of using <code>Layout::for_value</code> and a manual bitwise move (granted, a technically unnecessary one with full placement new, but I'm confident we'd be able to incrementally improve that aspect afterwards).</p>
<hr>
<p>FWIW, most of these things can be implemented in third-party code, and <a href="https://docs.rs/stackbox">have been</a>, but the issue there is that the lifetime of temporaries is a huge hurdle to the ergonomics. With a tiny bit of <code>lang</code> magic, that aspect could easily be soothed, leading to all these powerful abstractions at a very meager implementation cost in the compiler (smaller than special-casing non-<code>Sized</code> values in all the situations that require it).</p>



<a name="272810887"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Help%20for%20writing%20article%20about%20unsized%20locals/near/272810887" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Help.20for.20writing.20article.20about.20unsized.20locals.html#272810887">(Feb 22 2022 at 14:35)</a>:</h4>
<p>Note that I'm not against the <code>unsized_locals</code> sugar, or the power of non-<code>unsafe</code> <code>alloca</code> (tbh, I've heard in several occasions that <code>alloca</code> is evil / dangerous, so I'm not explicitly for it either; but since I don't know the actual pitfalls of <code>alloca</code> myself, I can't be against it either).<br>
It's just that the less magic the language features are, the better, so I do strongly believe the core of this functionality ought to be built atop <code>&amp;own</code> references, and only feature the sugar after that's done / from there.</p>
<p>All that to say, that if you are writing a blog post about the features, it would be very nice if the tangential topic of <code>&amp;own</code> references could be mentioned as well, <span class="user-mention" data-user-id="263609">@Olivier FAURE</span>, to make more people aware of that pattern <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="272812878"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Help%20for%20writing%20article%20about%20unsized%20locals/near/272812878" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Help.20for.20writing.20article.20about.20unsized.20locals.html#272812878">(Feb 22 2022 at 14:50)</a>:</h4>
<p>I am against <code>alloca</code>.<br>
<code>alloca</code> is a horrible mess that needs to be yeeted off the tallest cliff one can find. <br>
(Kinda sidetracked from writing the article, though)</p>



<a name="272815722"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Help%20for%20writing%20article%20about%20unsized%20locals/near/272815722" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Help.20for.20writing.20article.20about.20unsized.20locals.html#272815722">(Feb 22 2022 at 15:10)</a>:</h4>
<p>I'm not a fan of alloca in C, due to various potential hazards, but I'm hopeful that Rust can address those and produce something nicely usable and safe.</p>



<a name="272818921"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Help%20for%20writing%20article%20about%20unsized%20locals/near/272818921" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Help.20for.20writing.20article.20about.20unsized.20locals.html#272818921">(Feb 22 2022 at 15:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="239881">Josh Triplett</span> <a href="#narrow/stream/213817-t-lang/topic/Help.20for.20writing.20article.20about.20unsized.20locals/near/272815722">said</a>:</p>
<blockquote>
<p>I'm not a fan of alloca in C, due to various potential hazards, but I'm hopeful that Rust can address those and produce something nicely usable and safe.</p>
</blockquote>
<p>Heh.</p>



<a name="272820892"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Help%20for%20writing%20article%20about%20unsized%20locals/near/272820892" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Help.20for.20writing.20article.20about.20unsized.20locals.html#272820892">(Feb 22 2022 at 15:44)</a>:</h4>
<p><code>&amp;own</code> references and <code>unsized_fn_params</code> are effectively equivalent. Any value in the rust abi not passed in registers gets turned into what is effectively an <code>&amp;own</code> reference.</p>



<a name="272824957"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Help%20for%20writing%20article%20about%20unsized%20locals/near/272824957" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Olivier FAURE <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Help.20for.20writing.20article.20about.20unsized.20locals.html#272824957">(Feb 22 2022 at 16:08)</a>:</h4>
<p><span class="user-mention" data-user-id="133247">@bjorn3</span> Has there been recent progress (recent being "in the last 12 months or so") on <code>unsized_fn_params</code> ? Looking at the code, it sounds like the feature hasn't been modified since it was added.</p>



<a name="272825541"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Help%20for%20writing%20article%20about%20unsized%20locals/near/272825541" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Olivier FAURE <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Help.20for.20writing.20article.20about.20unsized.20locals.html#272825541">(Feb 22 2022 at 16:12)</a>:</h4>
<p><span class="user-mention" data-user-id="232018">@Daniel Henry-Mantilla</span> That's interesting, but right now I'm trying to summarize existing work, not write a whole new RFC. I don't really want to get into a debate of whether move references would be possible and/or a substitute for unsized fn parameters. (and it would be a pretty long debate, really)</p>



<a name="272827334"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Help%20for%20writing%20article%20about%20unsized%20locals/near/272827334" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Help.20for.20writing.20article.20about.20unsized.20locals.html#272827334">(Feb 22 2022 at 16:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="263609">Olivier FAURE</span> <a href="#narrow/stream/213817-t-lang/topic/Help.20for.20writing.20article.20about.20unsized.20locals/near/272824957">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="133247">bjorn3</span> Has there been recent progress (recent being "in the last 12 months or so") on <code>unsized_fn_params</code> ? Looking at the code, it sounds like the feature hasn't been modified since it was added.</p>
</blockquote>
<p>Not that I am aware of. I don't think it has any bugs. I think it is mostly blocked on a decision if it should be stabilized.</p>



<a name="272828583"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Help%20for%20writing%20article%20about%20unsized%20locals/near/272828583" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Olivier FAURE <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Help.20for.20writing.20article.20about.20unsized.20locals.html#272828583">(Feb 22 2022 at 16:30)</a>:</h4>
<p>Makes sense</p>



<a name="272843507"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Help%20for%20writing%20article%20about%20unsized%20locals/near/272843507" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Help.20for.20writing.20article.20about.20unsized.20locals.html#272843507">(Feb 22 2022 at 18:08)</a>:</h4>
<p>FWIW, I had been pondering things like <code>&amp;own</code> as a possible way around things like <a href="https://github.com/rust-lang/rust/issues/91521">https://github.com/rust-lang/rust/issues/91521</a> -- I don't know if it's worth adding them overall, but I think there are some interesting avoiding-copying things that they could help, especially if they could be signature-invisible.</p>



<a name="272843894"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Help%20for%20writing%20article%20about%20unsized%20locals/near/272843894" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Olivier FAURE <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Help.20for.20writing.20article.20about.20unsized.20locals.html#272843894">(Feb 22 2022 at 18:11)</a>:</h4>
<p><em>sigh</em> I guess I should add a section about those, then.</p>



<a name="272844946"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Help%20for%20writing%20article%20about%20unsized%20locals/near/272844946" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Help.20for.20writing.20article.20about.20unsized.20locals.html#272844946">(Feb 22 2022 at 18:18)</a>:</h4>
<p>That one could be fixed using a less naive handling of temporaries for calls. Currently the call turns into <code>_2 = move _1; _0 = bar(move _2) -&gt; bb1;</code>, however as <code>_0</code> and <code>_1</code> don't alias (at least if we say that the return place and argument places of a call must never alias as is currently true), it could instead be lowered directly as <code>_0 = bar(move _1) -&gt; bb1</code> which would turn into a <code>jmp bar</code> without anything other instructions at assembly level with even basic optimizations. This is really a problem of how calls are lowered in MIR, not an intrinsic problem needing a new language feature to solve.</p>



<a name="272943347"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Help%20for%20writing%20article%20about%20unsized%20locals/near/272943347" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Olivier FAURE <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Help.20for.20writing.20article.20about.20unsized.20locals.html#272943347">(Feb 23 2022 at 12:48)</a>:</h4>
<p>Well, article is up: <a href="https://poignardazur.github.io/2022/02/23/rust-unsized-vars-analysis/">https://poignardazur.github.io/2022/02/23/rust-unsized-vars-analysis/</a></p>



<a name="273005955"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Help%20for%20writing%20article%20about%20unsized%20locals/near/273005955" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Help.20for.20writing.20article.20about.20unsized.20locals.html#273005955">(Feb 23 2022 at 20:19)</a>:</h4>
<p>So while they are very much not the same thing, I kind of would like to see a "bounded alloca" that essentially allows returning <code>[T; M] where M &lt; N</code> <span class="user-mention" data-user-id="124288">@oli</span></p>



<a name="273006074"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Help%20for%20writing%20article%20about%20unsized%20locals/near/273006074" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Help.20for.20writing.20article.20about.20unsized.20locals.html#273006074">(Feb 23 2022 at 20:20)</a>:</h4>
<p>Where N is statically known but M may be decided at runtime.</p>



<a name="273006415"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Help%20for%20writing%20article%20about%20unsized%20locals/near/273006415" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Help.20for.20writing.20article.20about.20unsized.20locals.html#273006415">(Feb 23 2022 at 20:23)</a>:</h4>
<p>is there anything beyond a nice API that we gain from that over <code>ArrayVec</code>?</p>



<a name="273006947"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Help%20for%20writing%20article%20about%20unsized%20locals/near/273006947" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Help.20for.20writing.20article.20about.20unsized.20locals.html#273006947">(Feb 23 2022 at 20:27)</a>:</h4>
<p>The problem arises when N is potentially very high, I think, and so you are trying to make it better than "always expand the stack by 16KiB."</p>



<a name="273010059"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Help%20for%20writing%20article%20about%20unsized%20locals/near/273010059" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Thom Chiovoloni <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Help.20for.20writing.20article.20about.20unsized.20locals.html#273010059">(Feb 23 2022 at 20:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="124288">oli</span> <a href="#narrow/stream/213817-t-lang/topic/Help.20for.20writing.20article.20about.20unsized.20locals/near/273006415">said</a>:</p>
<blockquote>
<p>is there anything beyond a nice API that we gain from that over <code>ArrayVec</code>?</p>
</blockquote>
<p>Some performance. In practice I've saw some benefits from <a href="https://crates.io/crates/alloca">https://crates.io/crates/alloca</a> over a big ArrayVec, which includes the cost of a dynamic call.</p>
<p>I don't know if I think it's worth it though -- it will be very confusing for new users if the direct form of [T] is the one that they almost should never use (and instead they should use <code>&amp;[T]</code>, <code>&amp;mut [T]</code>, <code>Box&lt;[T]&gt;</code>, or <code>Vec&lt;T&gt;</code>).</p>



<a name="273010360"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Help%20for%20writing%20article%20about%20unsized%20locals/near/273010360" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Help.20for.20writing.20article.20about.20unsized.20locals.html#273010360">(Feb 23 2022 at 20:57)</a>:</h4>
<p>Yeah I don't have a firm claim on whether this is ultimately "worth it" per se, just expressing what nice to haves might look like. And syntactically I think it would have to look more like <code>[T; dyn N]</code>, yes.</p>



<a name="273011102"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Help%20for%20writing%20article%20about%20unsized%20locals/near/273011102" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Help.20for.20writing.20article.20about.20unsized.20locals.html#273011102">(Feb 23 2022 at 21:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="281757">Jubilee</span> <a href="#narrow/stream/213817-t-lang/topic/Help.20for.20writing.20article.20about.20unsized.20locals/near/273006947">said</a>:</p>
<blockquote>
<p>The problem arises when N is potentially very high, I think, and so you are trying to make it better than "always expand the stack by 16KiB."</p>
</blockquote>
<p>Does it do that for uninit arrays too?</p>



<a name="273011376"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Help%20for%20writing%20article%20about%20unsized%20locals/near/273011376" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Help.20for.20writing.20article.20about.20unsized.20locals.html#273011376">(Feb 23 2022 at 21:05)</a>:</h4>
<p>It should as the array may be initialized later in which case the stack space must be allocated.</p>



<a name="273098017"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Help%20for%20writing%20article%20about%20unsized%20locals/near/273098017" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Olivier FAURE <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Help.20for.20writing.20article.20about.20unsized.20locals.html#273098017">(Feb 24 2022 at 14:44)</a>:</h4>
<p>Expanding the stack isn't too bad performance-wise, I think, as long as you're not initializing anything.</p>



<a name="273098047"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Help%20for%20writing%20article%20about%20unsized%20locals/near/273098047" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Olivier FAURE <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Help.20for.20writing.20article.20about.20unsized.20locals.html#273098047">(Feb 24 2022 at 14:44)</a>:</h4>
<p>Until you get stack overflow</p>



<a name="273122982"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Help%20for%20writing%20article%20about%20unsized%20locals/near/273122982" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Help.20for.20writing.20article.20about.20unsized.20locals.html#273122982">(Feb 24 2022 at 17:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="263609">Olivier FAURE</span> <a href="#narrow/stream/213817-t-lang/topic/Help.20for.20writing.20article.20about.20unsized.20locals/near/273098047">said</a>:</p>
<blockquote>
<p>Until you get stack overflow</p>
</blockquote>
<p>as long as you're not initializing <strong>anything</strong>, yes.<br>
I am talking about situations where you wind up partially initializing some fragment of 64KiB.</p>



<a name="273123139"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Help%20for%20writing%20article%20about%20unsized%20locals/near/273123139" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Help.20for.20writing.20article.20about.20unsized.20locals.html#273123139">(Feb 24 2022 at 17:36)</a>:</h4>
<p>"why did that number jump?" because I named the actual limit for the datatype in question I am thinking of.</p>



<a name="273401409"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Help%20for%20writing%20article%20about%20unsized%20locals/near/273401409" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Olivier FAURE <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Help.20for.20writing.20article.20about.20unsized.20locals.html#273401409">(Feb 27 2022 at 12:36)</a>:</h4>
<blockquote>
<p>I am talking about situations where you wind up partially initializing some fragment of 64KiB.</p>
</blockquote>
<p>I might be missing something, but I'd expect that partially initializing, say, 10 bytes of a 64KiB array isn't particularly expensive? AFAIK, allocating lots of unused stack space doesn't cost anything (except for increased risks of stack overflow). It's not like uninitialized stack memory takes up CPU cache space.</p>



<a name="273582090"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Help%20for%20writing%20article%20about%20unsized%20locals/near/273582090" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Help.20for.20writing.20article.20about.20unsized.20locals.html#273582090">(Mar 01 2022 at 02:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="263609">Olivier FAURE</span> <a href="#narrow/stream/213817-t-lang/topic/Help.20for.20writing.20article.20about.20unsized.20locals/near/273401409">said</a>:</p>
<blockquote>
<blockquote>
<p>I am talking about situations where you wind up partially initializing some fragment of 64KiB.</p>
</blockquote>
<p>I might be missing something, but I'd expect that partially initializing, say, 10 bytes of a 64KiB array isn't particularly expensive? AFAIK, allocating lots of unused stack space doesn't cost anything (except for increased risks of stack overflow). It's not like uninitialized stack memory takes up CPU cache space.</p>
</blockquote>
<p>sure?<br>
until you move it. Then you either have to know its size via dynamic constraints orrrr you have to move 64KiB around.</p>



<a name="273583203"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/Help%20for%20writing%20article%20about%20unsized%20locals/near/273583203" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/Help.20for.20writing.20article.20about.20unsized.20locals.html#273583203">(Mar 01 2022 at 02:27)</a>:</h4>
<p>Specifically I am thinking of a case where the maximum value is so extremely high like that, and also you want to handle <strong>multiple</strong> of them at the same time. :D</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>