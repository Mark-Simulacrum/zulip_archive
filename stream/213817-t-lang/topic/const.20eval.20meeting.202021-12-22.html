<html>
<head><meta charset="utf-8"><title>const eval meeting 2021-12-22 · t-lang · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/index.html">t-lang</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html">const eval meeting 2021-12-22</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="265549828"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265549828" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265549828">(Dec 20 2021 at 11:17)</a>:</h4>
<p>I'm writing the ahead-of-meeting notes for this Wednesday's design meeting in <a href="https://hackmd.io/JdKPGA2eQ_qSX13pQeKoNg">https://hackmd.io/JdKPGA2eQ_qSX13pQeKoNg</a></p>



<a name="265564156"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265564156" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> fee1-dead <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265564156">(Dec 20 2021 at 13:45)</a>:</h4>
<p>I am not entirely sure what you meant by "many open questions around trait objects and fn ptrs" for option three. Are you talking about the same problems for const trait impls? i.e. how to specify a const fn ptr with the <code>const_heap</code> "effect", how to specify traits with methods that use the <code>const_heap</code> "effect" etc? This point should be clarified more IMO.</p>



<a name="265566331"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265566331" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265566331">(Dec 20 2021 at 14:00)</a>:</h4>
<p>you're right, that was very negatively formulated, I now wrote</p>
<blockquote>
<p>open question (like with const fn calls in general): how do we handle  trait objects method calls and fn ptr calls with this?</p>
</blockquote>



<a name="265716649"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265716649" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nikomatsakis <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265716649">(Dec 21 2021 at 18:06)</a>:</h4>
<p><span class="user-mention" data-user-id="124288">@oli</span> will you be able to attend, in that case?</p>



<a name="265717129"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265717129" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265717129">(Dec 21 2021 at 18:10)</a>:</h4>
<p>I will be there, yes.</p>



<a name="265717207"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265717207" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265717207">(Dec 21 2021 at 18:11)</a>:</h4>
<p>The doc is just so we have a written overview. We can dig into details in questions</p>



<a name="265717284"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265717284" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nikomatsakis <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265717284">(Dec 21 2021 at 18:12)</a>:</h4>
<p>seems good, we were thinking the framing is more "overview of where const eval is at"</p>



<a name="265717298"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265717298" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nikomatsakis <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265717298">(Dec 21 2021 at 18:12)</a>:</h4>
<p>I'll make a calendar invite</p>



<a name="265717316"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265717316" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nikomatsakis <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265717316">(Dec 21 2021 at 18:12)</a>:</h4>
<p><span class="user-mention" data-user-id="361356">@fee1-dead</span> (are you available too?)</p>



<a name="265717385"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265717385" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265717385">(Dec 21 2021 at 18:13)</a>:</h4>
<p>Yea, but we also have two things we'd like to explain so you can FCP it xD</p>



<a name="265719491"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265719491" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nikomatsakis <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265719491">(Dec 21 2021 at 18:34)</a>:</h4>
<p>Filed <a href="https://github.com/rust-lang/lang-team/issues/131">https://github.com/rust-lang/lang-team/issues/131</a> and created a calendar invite</p>



<a name="265728923"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265728923" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dylan MacKenzie (ecstatic-morse) <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265728923">(Dec 21 2021 at 20:09)</a>:</h4>
<p>I'll be in attendance as well, since I was involved in <a href="#narrow/stream/146212-t-compiler.2Fconst-eval/topic/.60ConstSafe.60.20and.20bitwise.20copies/near/179959089">some of the initial discussions</a>. Many thanks to <span class="user-mention silent" data-user-id="361356">fee1-dead</span> for writing the MCP, as well as all the const trait impl work they've done. Due to their work, we're quite close to being able to do some really interesting stuff at compile-time in an ergonomic way (no serialization from a build script). <code>impl const Iterator for Range&lt;usize&gt;</code> is going to be a huge boon.</p>
<p>One point I'd like to make about heap allocation is that the "effect" to allow it should go the other way (<code>#[const_no_heap]</code>). The issue here is functions that return a <strong>value</strong> that is known to always be bitwise copyable of a <strong>type</strong> that is not. However, this case is actually pretty rare—basically only for default/sentinel values—so most functions would require <em>both</em> <code>const</code> and <code>#[const_heap]</code>. <code>#[const_heap]</code> is easier to make backwards compatible, but we should be able to do <code>#[const_no_heap]</code> across an edition boundary if we're careful here.</p>
<p>I haven't thought too much about the special const allocator. That seems promising as well, although I'm not sure how fun it is to use custom allocators at the moment.</p>
<p>Another issue is mutable references in the final value of a constant. This should not be allowed. It can cause UB in safe code because constants are bitwise copied whenever they are used (this is the same underlying issue as for things with heap allocations btw, we are bitwise copying things that aren't copy). We're fine for now, since mutable reference (or shared references to types with interior mutability) are forbidden in a const context (except on nightly), but this restriction is <em>really</em> annoying and lifting it is likely a prerequisite for transient heap allocations to be useful. I think we'll need to use the "value-based analysis" from const qualification for this, since we already allow stuff like <code>const X: Option&lt;&amp;mut u32&gt; = None;</code>.</p>



<a name="265730615"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265730615" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dylan MacKenzie (ecstatic-morse) <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265730615">(Dec 21 2021 at 20:27)</a>:</h4>
<p>Also, I agree with Ralf that "effect" isn't really the right term. <code>#[const_no_heap]</code> is just about guaranteeing that the return value of a function is bitwise copyable. We know that's the case because no heap allocations took place during the function call (although there's other ways for non-<code>Copy</code> types to cause problems when copied, I don't think anything besides <code>&amp;mut</code> is an issue in a const-context).</p>



<a name="265730866"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265730866" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dylan MacKenzie (ecstatic-morse) <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265730866">(Dec 21 2021 at 20:30)</a>:</h4>
<p>You could also imagine an <code>#[unsafe_return_value_bitwise_copyable]</code>, which doesn't do any additional checks, that gets added to <code>Vec::new()</code> and friends. I think that's not a good idea because we want users to be able to define const default constructors for their containers, and we don't have precedent for publicly exposed attributes allowing unsafety as far as I know.</p>



<a name="265731227"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265731227" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dylan MacKenzie (ecstatic-morse) <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265731227">(Dec 21 2021 at 20:33)</a>:</h4>
<p>Oh, and one more question re: the allocator proposal. If we have <code>const X: Vec&lt;i32&gt; = vec![2];</code> where we've used a custom allocator that never deallocates, what happens when we do <code>X.push()</code>at runtime? Presumably we would clone <code>X</code> onto the heap, but that seems difficult within the current allocator framework (though maybe not with <code>const_eval_select</code>?). I think I prefer just emulating the default allocator when in a const context and forcing people to <code>leak</code> containers with interesting results instead of returning  the container itself by value.</p>



<a name="265731598"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265731598" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265731598">(Dec 21 2021 at 20:37)</a>:</h4>
<p>We don't want to allow <code>const X: Vec&lt;i32&gt;</code> to be built from a heap allocation at all. We'd allow <code>const X: Vec&lt;i32, ConstAlloc&gt;</code>, which never deallocates, so bit copying those vecs is fine.</p>



<a name="265731787"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265731787" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265731787">(Dec 21 2021 at 20:39)</a>:</h4>
<p>If we allow <code>Vec&lt;T, GlobalAlloc&gt;</code> beyond <code>Vec::new</code>, then we need the const_heap attribute or some variant of it</p>



<a name="265731928"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265731928" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265731928">(Dec 21 2021 at 20:41)</a>:</h4>
<p>I left that attribute as the last part of the meeting, as it requires the most discussion and I want to give the overview and two other topics some time</p>



<a name="265731952"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265731952" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265731952">(Dec 21 2021 at 20:41)</a>:</h4>
<p>Its details are in the MCP linked at the top of the doc</p>



<a name="265733072"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265733072" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265733072">(Dec 21 2021 at 20:55)</a>:</h4>
<p>I just read <a href="https://tmandry.gitlab.io/blog/posts/2021-12-21-context-capabilities/">https://tmandry.gitlab.io/blog/posts/2021-12-21-context-capabilities/</a> and am wondering if that could give us the very thing we want. Libraries don't have to change their allocator or become generic, but users can inject the const allocator</p>



<a name="265734390"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265734390" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dylan MacKenzie (ecstatic-morse) <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265734390">(Dec 21 2021 at 21:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="124288">oli</span> <a href="#narrow/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22/near/265731598">said</a>:</p>
<blockquote>
<p>We don't want to allow <code>const X: Vec&lt;i32&gt;</code> to be built from a heap allocation at all. We'd allow <code>const X: Vec&lt;i32, ConstAlloc&gt;</code>, which never deallocates, so bit copying those vecs is fine.</p>
</blockquote>
<p>I omitted the extra parameter in my example, but that's what my question about <code>push</code> was referring to. What happens when we call <code>X.push()</code> at runtime for the <code>ConstAlloc</code> parameterized one?</p>



<a name="265734939"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265734939" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dylan MacKenzie (ecstatic-morse) <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265734939">(Dec 21 2021 at 21:14)</a>:</h4>
<p>Also, what happens if we do the following (once again, assume <code>X</code> is parameterized with <code>ConstAlloc</code>)?</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">X</span><span class="p">.</span><span class="n">get_mut</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">X</span><span class="p">.</span><span class="n">get_mut</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="o">*</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">b</span><span class="p">;</span><span class="w"></span>
</code></pre></div>



<a name="265735058"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265735058" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dylan MacKenzie (ecstatic-morse) <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265735058">(Dec 21 2021 at 21:15)</a>:</h4>
<p><span class="user-mention" data-user-id="124288">@oli</span> ^ (I don't have notifications for this channel, so ping me if you respond)</p>



<a name="265735205"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265735205" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265735205">(Dec 21 2021 at 21:17)</a>:</h4>
<p>The push will reallocate, so yea, you get a clone and add to that. The const allocator never frees, it just allocates, so you will waste a lot of memory at runtime that way</p>



<a name="265735232"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265735232" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265735232">(Dec 21 2021 at 21:17)</a>:</h4>
<p>Oof. Good point on the owned mutation</p>



<a name="265735344"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265735344" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dylan MacKenzie (ecstatic-morse) <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265735344">(Dec 21 2021 at 21:18)</a>:</h4>
<p>Yeah, <code>Box</code> and <code>Vec</code> are similar to <code>&amp;mut</code> in the respect that they allow safe code to create a  mutable reference into memory that is <em>not</em> copied when the const is read.</p>



<a name="265735406"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265735406" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265735406">(Dec 21 2021 at 21:19)</a>:</h4>
<p>I guess we do need to treat Vec as we do &amp;mut... yea that...</p>



<a name="265735437"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265735437" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265735437">(Dec 21 2021 at 21:20)</a>:</h4>
<p>Damn and here I thought ConstAlloc was straightforward</p>



<a name="265735523"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265735523" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265735523">(Dec 21 2021 at 21:20)</a>:</h4>
<p>I guess even for that we need ConstSafe and ConstRefSafe</p>



<a name="265735682"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265735682" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dylan MacKenzie (ecstatic-morse) <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265735682">(Dec 21 2021 at 21:22)</a>:</h4>
<p>I'm also a little confused about <code>ConstRefSafe</code>. Is it ever any different from <code>Freeze</code>? It seems like it only matters for things with interior mutability.</p>



<a name="265735804"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265735804" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dylan MacKenzie (ecstatic-morse) <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265735804">(Dec 21 2021 at 21:23)</a>:</h4>
<p>I guess if you include raw pointers in the list of things that aren't <code>ConstRefSafe</code>, but I've given up trying to enforce this stuff in the presence of unsafe code.</p>



<a name="265735843"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265735843" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265735843">(Dec 21 2021 at 21:23)</a>:</h4>
<p>Hmm... I need to read up before tomorrow's meeting. I don't remember the details xD</p>



<a name="265735931"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265735931" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265735931">(Dec 21 2021 at 21:24)</a>:</h4>
<p>But maybe this capabilities stuff can really safe our hide here. If we only allow scoped allocators, you can't really leak the value. That should give us transient heap</p>



<a name="265735948"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265735948" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dylan MacKenzie (ecstatic-morse) <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265735948">(Dec 21 2021 at 21:25)</a>:</h4>
<p>I think it's enough to say that attempting to mutate that was allocated during const-eval is UB, and to ensure that it can't happen in purely safe code.</p>



<a name="265735974"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265735974" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265735974">(Dec 21 2021 at 21:25)</a>:</h4>
<p>Right</p>



<a name="265735975"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265735975" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dylan MacKenzie (ecstatic-morse) <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265735975">(Dec 21 2021 at 21:25)</a>:</h4>
<p>I'll read tmandry's post.</p>



<a name="265736168"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265736168" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265736168">(Dec 21 2021 at 21:27)</a>:</h4>
<p>But users may have written safe abstractions containing raw pointers, and I don't want to just push new kinds of UB that aren't that outside of const contexts. People should safely be able to slap const on a function and if it wasn't UB before, it shouldn't be now</p>



<a name="265736231"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265736231" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265736231">(Dec 21 2021 at 21:28)</a>:</h4>
<p>That's why I worry about raw pointers in people's abstractions</p>



<a name="265736304"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265736304" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265736304">(Dec 21 2021 at 21:28)</a>:</h4>
<p>We can vet libstd, but if we create a new source of UB footguns, then that's bad</p>



<a name="265736910"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265736910" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dylan MacKenzie (ecstatic-morse) <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265736910">(Dec 21 2021 at 21:34)</a>:</h4>
<p>It doesn't seem that bad to me. Everything will still work at compile-time (assuming the existing validity invariants are upheld). The only issue is calling that function at runtime while passing it a pointer to something that was created at compile-time. All we would be saying is that such pointers can't be written to. In other words, if you have a function that writes through a raw pointer, it requires that that raw pointer is valid for writes. Pointers into <code>.rodata</code> aren't valid for writes.</p>



<a name="265737497"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265737497" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dylan MacKenzie (ecstatic-morse) <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265737497">(Dec 21 2021 at 21:37)</a>:</h4>
<p>But the only alternative I've been considering is escape analysis. Perhaps there's something different? I dunno.</p>



<a name="265737581"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265737581" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265737581">(Dec 21 2021 at 21:38)</a>:</h4>
<p>The c&amp;c proposal could also give us an easy way to check non-transient heap allocations. We could allow the trailing expression of const contexts (other than const fn) to be a <code>with</code> block that registers a ConstAlloc as the global allocator, and then run fee1-dead's analysis assuming all calls heap allocate. Pessimistic, but you can always convert a box into a reference and a vec into a slice and everything is peachy</p>



<a name="265737673"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265737673" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265737673">(Dec 21 2021 at 21:39)</a>:</h4>
<p>That requires no attribute, is backcompat and doesn't have issues with mutation</p>



<a name="265737756"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265737756" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265737756">(Dec 21 2021 at 21:40)</a>:</h4>
<p>Only hacky thing would be the <code>ConstAlloc</code> not being mentionable elsewhere</p>



<a name="265737774"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265737774" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dylan MacKenzie (ecstatic-morse) <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265737774">(Dec 21 2021 at 21:40)</a>:</h4>
<p>I was just about to ask about mutation. How would what you're thinking about handle the <code>get_mut</code> example above?</p>



<a name="265737832"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265737832" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265737832">(Dec 21 2021 at 21:41)</a>:</h4>
<p>Which one? for transient or non-transient?</p>



<a name="265737849"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265737849" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dylan MacKenzie (ecstatic-morse) <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265737849">(Dec 21 2021 at 21:42)</a>:</h4>
<p>non-transient (I think?)</p>



<a name="265737992"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265737992" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265737992">(Dec 21 2021 at 21:43)</a>:</h4>
<p>Right. The mcp suggests an analysis run on const contexts other than functions that ensures all owned values are behind references and freeze or are created via functions that aren't annotated with the effect attribute</p>



<a name="265738175"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265738175" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265738175">(Dec 21 2021 at 21:45)</a>:</h4>
<p>Thus any <code>&amp;mut X</code> or equivalent at runtime would result in a <code>&amp;mut &amp;Vec&lt;T&gt;</code> or similar</p>



<a name="265738319"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265738319" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dylan MacKenzie (ecstatic-morse) <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265738319">(Dec 21 2021 at 21:46)</a>:</h4>
<p>Oh, interesting, so we would implicitly add a reference? Or are you just saying that we forbid <code>const X: Vec&lt;u32&gt;</code> unless the initializer is not <code>#[const_heap]</code>?</p>



<a name="265738350"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265738350" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265738350">(Dec 21 2021 at 21:47)</a>:</h4>
<p>Yes, that is what the mcp suggests</p>



<a name="265738376"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265738376" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dylan MacKenzie (ecstatic-morse) <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265738376">(Dec 21 2021 at 21:47)</a>:</h4>
<p>I assumed the second one, but then I don't quite understand where c&amp;c fits it. Probably good to talk it out tomorrow.</p>



<a name="265738385"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265738385" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265738385">(Dec 21 2021 at 21:47)</a>:</h4>
<p>And my c&amp;c idea would do the same, but without an attribute</p>



<a name="265738886"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265738886" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dylan MacKenzie (ecstatic-morse) <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265738886">(Dec 21 2021 at 21:52)</a>:</h4>
<p>One more thing, does reversing the polarity of <code>#[const_heap]</code> appeal to you? Unfortunately we're at a bad time to plan an edition-gated change. The idea would be to make <code>#[const_heap]</code> the (implicit) default in edition 2024 and apply<code>#[const_no_heap]</code>to a subset of existing const fn during migration.</p>



<a name="265738916"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265738916" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dylan MacKenzie (ecstatic-morse) <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265738916">(Dec 21 2021 at 21:53)</a>:</h4>
<p>Obviously that assumes that we end up using an attribute, which is not decided.</p>



<a name="265739190"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265739190" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dylan MacKenzie (ecstatic-morse) <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265739190">(Dec 21 2021 at 21:56)</a>:</h4>
<p>The subset being const fn that return types which are <code>!Copy</code> (or maybe <code>!NeedsDrop</code>?).</p>



<a name="265740482"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265740482" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265740482">(Dec 21 2021 at 22:09)</a>:</h4>
<p>(cc <span class="user-mention" data-user-id="118594">@Dylan MacKenzie (ecstatic-morse)</span>)<br>
FWIW, since this is all about bit-copy-ing (<em>e.g.</em>, <code>&amp;mut</code> suffers from these issues as well (and while a <code>&amp;mut</code> to a non-zero span of memory can only be obtained, in safe code, through heap allocs (+ leaking), the <code>&amp;mut</code> itself final result is a type that has become allocator agnostic; hence why it's not really about "a const allocator")).</p>
<p>I suggested a copy-focused approach in <a href="#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Heap.20allocations.20in.20constants.20lang-team.23129/near/263299173">https://rust-lang.zulipchat.com/#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Heap.20allocations.20in.20constants.20lang-team.23129/near/263299173</a>, with basically a provideable <code>unsafe impl</code> with which one could say whether <strong>a specific instance</strong> of the implementing type was safely bit-copyable:</p>
<ul>
<li>all instances of all <code>Copy</code> types are;</li>
<li><code>String</code>, <code>Vec</code>, <em>etc.</em>, are, if and only if they have a null capacity;</li>
<li>a <code>.leak()</code>ed version of the above, which ends up as a <code>&amp;'static str</code> or a <code>&amp;'static [T]</code>, would involve <code>Copy</code> types (shared references) and thus be <code>const</code>-safe as well.</li>
</ul>
<p>I find that approach to be quite good at covering all corner cases, and so, kind of elegant. It does involve a form of "runtime code checking" of the actual instance that ends up emitted by a <code>const</code> block, so it may boil down to the "post-monomorphization errors" unsatisfactory category? It would, however, be more satisfactory than <code>#[unsafe_return_value_bitwise_copyable]</code>, imho.</p>
<p>Also, there seems to be a <code>Send</code> requirement as well, since the <code>Copy</code> can occur in any thread: <code>&amp;'static Cell&lt;…&gt;</code> should not be <code>const</code>-safe either</p>



<a name="265741686"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265741686" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dylan MacKenzie (ecstatic-morse) <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265741686">(Dec 21 2021 at 22:22)</a>:</h4>
<p>The benefit of <code>#[const_{no_,}heap]</code> (or <del>the allocator</del> Oli's c&amp;c approach) as opposed to your traits or <code>#[unsafe_return_value_is_const_safe]</code> is that we <em>know for sure</em> that there are no heap allocations in the final value of the constant. There's no unsafe like with your traits. As you point out, <code>&amp;Cell&lt;T&gt;</code> is <code>Copy</code> and also should not be allowed in the final value of a <code>const</code>, so we would couple this with a value-based analysis for references that allow mutation (<code>&amp;mut T</code>, <code>&amp;Cell&lt;T&gt;</code>, etc.) which will cover all safe code. You could still leak a <code>Box</code>, convert the <code>&amp;'static mut</code> to a raw pointer, and dereference it at runtime, but that requires <code>unsafe</code> code</p>



<a name="265741877"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265741877" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dylan MacKenzie (ecstatic-morse) <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265741877">(Dec 21 2021 at 22:25)</a>:</h4>
<p>Your proposal seems quite close to the checks we could implement in Miri to make sure that the final value of a const does not contain any pointers that would allow mutation, but done explicitly through the trait system, which is cool.</p>



<a name="265765949"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265765949" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> fee1-dead <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265765949">(Dec 22 2021 at 04:47)</a>:</h4>
<p><span class="user-mention silent" data-user-id="116009">nikomatsakis</span> <a href="#narrow/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22/near/265717316">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="361356">fee1-dead</span> (are you available too?)</p>
</blockquote>
<p>I would probably only be available for the first half of the meeting.</p>



<a name="265777901"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265777901" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265777901">(Dec 22 2021 at 08:33)</a>:</h4>
<p>OK, I'll rewrite the doc so we can start with heap</p>



<a name="265789616"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265789616" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Charles Lew <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265789616">(Dec 22 2021 at 10:41)</a>:</h4>
<p>My idea is wildly different, but I'm curious whether it is feasible to "materialize" const rvalue to ordinary rvalues, by converting the graph topology structure and relationships into allocation and memory write "instructions" :)</p>



<a name="265824963"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265824963" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265824963">(Dec 22 2021 at 16:39)</a>:</h4>
<p>Hackmd is not very mobile friendly. I wasn't able to do larger refactorings. We'll go through the doc as it is and then just start with the const heap topic. <span class="user-mention" data-user-id="361356">@fee1-dead</span> feel free to edit the doc to reflect your MCP better. I don't think I did that properly</p>



<a name="265833878"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265833878" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nikomatsakis <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265833878">(Dec 22 2021 at 18:01)</a>:</h4>
<p><span class="user-group-mention" data-user-group-id="1977">@T-lang</span> design meeting</p>



<a name="265833899"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265833899" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nikomatsakis <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265833899">(Dec 22 2021 at 18:01)</a>:</h4>
<p><a href="https://hackmd.io/JdKPGA2eQ_qSX13pQeKoNg">hackmd document</a></p>



<a name="265833947"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265833947" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nikomatsakis <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265833947">(Dec 22 2021 at 18:01)</a>:</h4>
<p>anyone who wants zoom link and doesn't have it (it's on the cal invite) ping me</p>



<a name="265840336"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265840336" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265840336">(Dec 22 2021 at 19:01)</a>:</h4>
<p>Some follow-ups from the meeting:</p>



<a name="265840451"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265840451" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265840451">(Dec 22 2021 at 19:02)</a>:</h4>
<p>Where is discussion about <code>~const</code> syntax happening, so that that can get addressed concurrently and not let the syntax become a blocker on future stabilization of that mechanism?</p>



<a name="265840470"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265840470" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265840470">(Dec 22 2021 at 19:02)</a>:</h4>
<p>I was about to open a thread here XD</p>



<a name="265840538"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265840538" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265840538">(Dec 22 2021 at 19:03)</a>:</h4>
<p>Also, I agree with <span class="user-mention" data-user-id="127859">@Taylor Cramer</span>'s point in the meeting that it'd be potentially awkward to require <em>every</em> struct to be generic over allocators (e.g. <code>struct S { v: Vec&lt;u32&gt; }</code>). I'm wondering what the right mechanism would be to simplify that.</p>



<a name="265840619"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265840619" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265840619">(Dec 22 2021 at 19:04)</a>:</h4>
<p>Or, alternatively, perhaps we can make the default type parameter for <code>Vec</code> and similar be something that works in const context, as long as we have a way to handle that being the same type used at runtime?</p>



<a name="265840721"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265840721" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265840721">(Dec 22 2021 at 19:05)</a>:</h4>
<p>I'm wondering if we need a convenient way to spell <code>if const context { StaticAlloc } else { GlobalAlloc }</code>.</p>



<a name="265840889"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265840889" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265840889">(Dec 22 2021 at 19:07)</a>:</h4>
<p>the problem is not as much in making a "runtime" (guaranteed optimized out) decision, but how we could ever make such a decision in the type system itself</p>



<a name="265841100"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265841100" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265841100">(Dec 22 2021 at 19:10)</a>:</h4>
<p>we do already have <code>const_eval_select</code> and could create convenient syntax for that, but that's an expression, you can't make a type decision on that</p>



<a name="265841255"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265841255" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265841255">(Dec 22 2021 at 19:11)</a>:</h4>
<p>there is the safe transmute project that we could use to transmute from something with a <code>StaticAlloc</code> to <code>GlobalAlloc</code> if it is behind a reference</p>



<a name="265841328"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265841328" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265841328">(Dec 22 2021 at 19:12)</a>:</h4>
<p>I had thought there was a <code>.clone_in</code> method, but I can't seem to <em>find</em> it.</p>



<a name="265841330"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265841330" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265841330">(Dec 22 2021 at 19:12)</a>:</h4>
<p>but all of these schemes rely on users not creating types that erase allocators</p>



<a name="265841358"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265841358" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265841358">(Dec 22 2021 at 19:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="239881">Josh Triplett</span> <a href="#narrow/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22/near/265841328">said</a>:</p>
<blockquote>
<p>I had thought there was a <code>.clone_in</code> method, but I can't seem to <em>find</em> it.</p>
</blockquote>
<p>even if there were, it's not recursive/deep, so it would still be fairly annoying to use</p>



<a name="265841534"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265841534" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265841534">(Dec 22 2021 at 19:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="124288">oli</span> <a href="#narrow/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22/near/265841330">said</a>:</p>
<blockquote>
<p>but all of these schemes rely on users not creating types that erase allocators</p>
</blockquote>
<p>imagine a <code>struct GlobalBox&lt;i32&gt;(*mut i32);</code> that a user wrote that always gets initialized with <code>Box::into_raw(Box::&lt;i32, GlobalAlloc&gt;::new(42))</code>, that seems a totally reasonable type to me, but I don't see how we could ever make that work out without introducing a new kind of UB or sth.</p>



<a name="265841734"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265841734" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265841734">(Dec 22 2021 at 19:16)</a>:</h4>
<p><span class="user-mention" data-user-id="124288">@oli</span> The heap handling in miri could handle checking for that UB, right?</p>



<a name="265841785"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265841785" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265841785">(Dec 22 2021 at 19:17)</a>:</h4>
<p>sure, but for associated constants being used in generic functions, that would cause post monomorphization errors</p>



<a name="265841816"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265841816" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265841816">(Dec 22 2021 at 19:17)</a>:</h4>
<p>To what extent do all the problems with <code>ConstAlloc</code>/<code>StaticAlloc</code> apply equally to any <em>other</em> allocator someone might want to use?</p>



<a name="265841857"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265841857" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265841857">(Dec 22 2021 at 19:17)</a>:</h4>
<p>other allocators either are arenas, so fine, or call FFI, so don't work anyway</p>



<a name="265841873"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265841873" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265841873">(Dec 22 2021 at 19:17)</a>:</h4>
<p>Sorry, clarification:</p>



<a name="265841929"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265841929" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265841929">(Dec 22 2021 at 19:18)</a>:</h4>
<p>oooh</p>



<a name="265841946"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265841946" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265841946">(Dec 22 2021 at 19:18)</a>:</h4>
<p>yea, that's true</p>



<a name="265841949"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265841949" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nikomatsakis <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265841949">(Dec 22 2021 at 19:18)</a>:</h4>
<p><a href="https://github.com/rust-lang/lang-team/blob/master/design-meeting-minutes/2021-12-22-Const-eval-update.md">https://github.com/rust-lang/lang-team/blob/master/design-meeting-minutes/2021-12-22-Const-eval-update.md</a></p>



<a name="265841953"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265841953" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265841953">(Dec 22 2021 at 19:18)</a>:</h4>
<p>I don't mean in a const context. I mean, ignoring const for a moment, wouldn't we have all the same problems about non-<code>GlobalAlloc</code> allocators being painful to use with any <code>DifferentAlloc</code> at runtime?</p>



<a name="265841984"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265841984" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265841984">(Dec 22 2021 at 19:18)</a>:</h4>
<p>So why don't we talk about how to make that less painful in general, and then const benefits from that?</p>



<a name="265841999"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265841999" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265841999">(Dec 22 2021 at 19:18)</a>:</h4>
<p>we are basically trying to solve both the allocator pains and const pains at the same time, but should be talking about them independently</p>



<a name="265842337"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265842337" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265842337">(Dec 22 2021 at 19:22)</a>:</h4>
<p><a href="#narrow/stream/213817-t-lang/topic/Making.20allocators.20less.20painful.20to.20use">https://rust-lang.zulipchat.com/#narrow/stream/213817-t-lang/topic/Making.20allocators.20less.20painful.20to.20use</a></p>



<a name="265844858"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265844858" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265844858">(Dec 22 2021 at 19:49)</a>:</h4>
<p>Something else we didn't get to in the meeting: what exactly does the proposed <code>#[const_alloc]</code> mean in that particular approach?</p>



<a name="265884946"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/265884946" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> fee1-dead <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#265884946">(Dec 23 2021 at 05:26)</a>:</h4>
<p>That idea was a bit complicated. Instead of using a custom allocator, the <code>#[const_alloc]</code> approach makes <code>GlobalAlloc</code> work in const contexts.<br>
We then created marker traits to limit what types are allowed for the final values of constants because we want to avoid having <code>const FOO: Vec&lt;i32&gt; = vec![42];</code>. </p>
<p>The only problem would be that only looking at the types would disallow some current real-world code e.g. <code>const A: Vec&lt;i32&gt; = Vec::new()</code> which is legal on stable. The solution for that is to look at what functions actually do (i.e. do they make allocations or not?) by marking functions that allocate and return owned pointers of allocations with <code>#[const_alloc]</code>. Then when we check constants we need to ask these questions: 1. Did you create an allocation? (are there any calls to <code>#[const_alloc]</code> functions?), 2. If so then the following types are forbidden: <code>Box&lt;T&gt;, Vec&lt;T&gt;, etc.</code> The same rules apply to functions, of course. We require functions to be marked with <code>#[const_alloc]</code> if there are any calls to other <code>#[const_alloc]</code> functions and the return type might point to an allocation.</p>



<a name="266826783"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/266826783" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Olivier FAURE <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#266826783">(Jan 04 2022 at 16:11)</a>:</h4>
<blockquote>
<p>cramertj: right, you could use droppable things as intermediaries…but the actual const I would think would just return a reference, and now there is no “drop” that will get called</p>
<p>cramertj: you’d also have to require Freeze, but we have a lot of requirements on these things anyway, it seems like we’re generally on the same page that we don’t want types with random drop impls getting inserted</p>
</blockquote>
<p>I think that avenue has been under-discussed.</p>
<p>If you say "only give me owned values if they don't have a drop impl or interior mutability" then there is no possible way static values get deallocated. You don't need to rewrite the entire serde crate to allow a new allocator, and you don't need to introduce potential post-monomorphization errors by filtering types based on their computed values.</p>



<a name="266826865"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/266826865" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Olivier FAURE <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#266826865">(Jan 04 2022 at 16:12)</a>:</h4>
<p>The biggest obstacle mentioned is that it would be a breaking change. This code currently compiles on stable:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">struct</span> <span class="nc">Foo</span><span class="p">;</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="nb">Drop</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">"dropped"</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">const</span><span class="w"> </span><span class="n">FOO</span>: <span class="nc">Foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Foo</span><span class="p">;</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">FOO</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">FOO</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>and would break with the new rules.</p>



<a name="266826933"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/266826933" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Olivier FAURE <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#266826933">(Jan 04 2022 at 16:12)</a>:</h4>
<p>But I think there could be workarounds.</p>



<a name="266827933"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/266827933" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Olivier FAURE <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#266827933">(Jan 04 2022 at 16:17)</a>:</h4>
<p>What I have in mind would be "We allow constants to have a type with a drop impl; but we don't allow these constants to be used by value in non-const contexts, only by shared ref".</p>
<p>eg:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">const</span><span class="w"> </span><span class="n">MY_VEC</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">42</span><span class="p">];</span><span class="w"> </span><span class="c1">// ok</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MY_VEC</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w"> </span><span class="c1">// ok</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MY_VEC</span><span class="p">.</span><span class="n">len</span><span class="p">();</span><span class="w">   </span><span class="c1">// ok</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MY_VEC</span><span class="p">;</span><span class="w">         </span><span class="c1">// ERROR</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>That's still a breaking change, so.</p>



<a name="266828422"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/266828422" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Olivier FAURE <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#266828422">(Jan 04 2022 at 16:19)</a>:</h4>
<p>If existing code uses constants with a drop impl by value, we implicitly clone the value. (although that's also a breaking change in itself; the non-breaking version would be to actually create one static per instantiation of the const value, I guess) We lint against this behavior and remove it in a future edition.</p>



<a name="266828807"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/266828807" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Olivier FAURE <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#266828807">(Jan 04 2022 at 16:21)</a>:</h4>
<p>The bottom line is, that way you can have Vec in consts without rewriting all serde code to be generic over allocator type, or having complex analysis that checks if a constant has allocated pointers or not.</p>



<a name="266829521"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/266829521" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> fee1-dead <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#266829521">(Jan 04 2022 at 16:24)</a>:</h4>
<p><span class="user-mention silent" data-user-id="263609">Olivier FAURE</span> <a href="#narrow/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22/near/266827933">said</a>:</p>
<blockquote>
<p>What I have in mind would be "We allow constants to have a type with a drop impl; but we don't allow these constants to be used by value in non-const contexts, only by shared ref".</p>
<p>eg:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">const</span><span class="w"> </span><span class="n">MY_VEC</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">42</span><span class="p">];</span><span class="w"> </span><span class="c1">// ok</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MY_VEC</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w"> </span><span class="c1">// ok</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MY_VEC</span><span class="p">.</span><span class="n">len</span><span class="p">();</span><span class="w">   </span><span class="c1">// ok</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MY_VEC</span><span class="p">;</span><span class="w">         </span><span class="c1">// ERROR</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>That's still a breaking change, so.</p>
</blockquote>
<p>It wouldn't be an actual breaking change if we could detect whether a type contains an allocation in its final value. We'd just disallow it to be the final value of a <code>const</code>. It is allowed to exist behind a reference or inside a <code>static</code>.</p>



<a name="266829676"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/266829676" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> fee1-dead <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#266829676">(Jan 04 2022 at 16:25)</a>:</h4>
<p>I wonder if we could <em>just</em> make it work by restricting <code>const_heap</code> to only statics.</p>



<a name="266830367"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/266830367" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Olivier FAURE <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#266830367">(Jan 04 2022 at 16:28)</a>:</h4>
<p>Yeah, but the point is to avoid making correctness depend on values.</p>



<a name="266833056"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/266833056" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> fee1-dead <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#266833056">(Jan 04 2022 at 16:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="263609">Olivier FAURE</span> <a href="#narrow/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22/near/266830367">said</a>:</p>
<blockquote>
<p>Yeah, but the point is to avoid making correctness depend on values.</p>
</blockquote>
<p>Have you read <a href="https://github.com/rust-lang/lang-team/issues/129">https://github.com/rust-lang/lang-team/issues/129</a>? It proposes a system of marker traits and detection of heap allocations based on callees.</p>



<a name="266835541"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/266835541" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Olivier FAURE <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#266835541">(Jan 04 2022 at 17:06)</a>:</h4>
<p>Oh, I misread it. I thought it was value-based.</p>



<a name="266837073"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/213817-t-lang/topic/const%20eval%20meeting%202021-12-22/near/266837073" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Olivier FAURE <a href="https://zulip-archive.rust-lang.org/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22.html#266837073">(Jan 04 2022 at 17:19)</a>:</h4>
<p>My biggest objection is that whether or not a function allocates ought to be an implementation detail. Adding a new effect means you need to keep track of whether the functions you call have the effect, whether you're using a vec or a static array, etc, even though most of the time you don't care about it.</p>
<p>I think an elegant design would be one where using Box, String or Vec isn't any harder in const functions than in regular functions. But there's no obvious way to implement an elegant design, because right now consts with Drop impls are allowed, and the drop glue of those consts can even be called in regular code.</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>