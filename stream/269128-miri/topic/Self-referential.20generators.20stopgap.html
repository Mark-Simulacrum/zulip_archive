<html>
<head><meta charset="utf-8"><title>Self-referential generators stopgap · miri · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/index.html">miri</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Self-referential.20generators.20stopgap.html">Self-referential generators stopgap</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="265914899"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Self-referential%20generators%20stopgap/near/265914899" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Self-referential.20generators.20stopgap.html#265914899">(Dec 23 2021 at 13:10)</a>:</h4>
<p>This is mostly a note to myself... I wonder if we could at least preliminarily make miri compatible with self-referential generators by treating <code>&amp;mut T</code> for <code>T: !Unpin</code> as not actually being a unique pointer. AFAIK codegen already does something like that wrt how it adds <code>noalias</code>? My main concern is that there might be too many <code>!Unpin</code> types so this could make detection of other aliasing issues less effective. I am not sure how common <code>!Unpin</code> types are in practice.</p>



<a name="265920992"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Self-referential%20generators%20stopgap/near/265920992" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Self-referential.20generators.20stopgap.html#265920992">(Dec 23 2021 at 14:25)</a>:</h4>
<p>yeah, noalias for mutable references is tied to <code>Unpin</code>:<br>
<a href="https://github.com/rust-lang/rust/blob/b81553267437627af63c79c1a20c73af865a842a/compiler/rustc_middle/src/ty/layout.rs#L2482">https://github.com/rust-lang/rust/blob/b81553267437627af63c79c1a20c73af865a842a/compiler/rustc_middle/src/ty/layout.rs#L2482</a></p>



<a name="266568173"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Self-referential%20generators%20stopgap/near/266568173" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Self-referential.20generators.20stopgap.html#266568173">(Jan 01 2022 at 18:06)</a>:</h4>
<p><a href="https://github.com/rust-lang/miri/pull/1952">https://github.com/rust-lang/miri/pull/1952</a> implements this and seems to have the desired effect. I wonder what people think about this.</p>



<a name="266571339"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Self-referential%20generators%20stopgap/near/266571339" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Thom Chiovoloni <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Self-referential.20generators.20stopgap.html#266571339">(Jan 01 2022 at 19:26)</a>:</h4>
<p>personally not a huge fan given that pin and such were designed to be a library solution not a language thign, but i guess this accurately models how rustc actually compiles things, so...</p>



<a name="269172090"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Self-referential%20generators%20stopgap/near/269172090" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Self-referential.20generators.20stopgap.html#269172090">(Jan 24 2022 at 21:00)</a>:</h4>
<p>Wait, does that mean it's now legal to opt out of <code>Unique</code> access levels w.r.t. <code>&amp;mut T</code> for any <code>T: ?Sized</code>? <span aria-label="stuck out tongue" class="emoji emoji-1f61b" role="img" title="stuck out tongue">:stuck_out_tongue:</span>  <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=c729de03da938f74f58f7dc70aef37e4">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=c729de03da938f74f58f7dc70aef37e4</a></p>



<a name="269304768"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Self-referential%20generators%20stopgap/near/269304768" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Self-referential.20generators.20stopgap.html#269304768">(Jan 25 2022 at 18:51)</a>:</h4>
<p>no, it doesnt mean its legal. it just means Miri no longer complains.</p>



<a name="269304939"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Self-referential%20generators%20stopgap/near/269304939" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Self-referential.20generators.20stopgap.html#269304939">(Jan 25 2022 at 18:52)</a>:</h4>
<p>this is an attempt to make miri more useful for programs/libraries that involve self-referential generators -- overall I think this can help catch more bugs, even if it means some uniqueness violations are missed</p>



<a name="269304984"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Self-referential%20generators%20stopgap/near/269304984" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Self-referential.20generators.20stopgap.html#269304984">(Jan 25 2022 at 18:52)</a>:</h4>
<p>but we are unfortunately not yet at the stage where "it passes miri" implies "it is legal" (in the sense of not being UB)</p>



<a name="269314610"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Self-referential%20generators%20stopgap/near/269314610" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Self-referential.20generators.20stopgap.html#269314610">(Jan 25 2022 at 19:55)</a>:</h4>
<p>Thanks :) In that case I'll refrain from using such trickery :D</p>



<a name="269314813"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Self-referential%20generators%20stopgap/near/269314813" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake Goulding <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Self-referential.20generators.20stopgap.html#269314813">(Jan 25 2022 at 19:56)</a>:</h4>
<blockquote>
<p>"it passes miri" implies "it is legal" </p>
</blockquote>
<p>Someday... someday... <span aria-label="fingers crossed" class="emoji emoji-1f91e" role="img" title="fingers crossed">:fingers_crossed:</span></p>



<a name="270631620"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Self-referential%20generators%20stopgap/near/270631620" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Thom Chiovoloni <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Self-referential.20generators.20stopgap.html#270631620">(Feb 03 2022 at 23:00)</a>:</h4>
<p>At first I disliked this because this seemed extremely ad-hoc and I couldn't think of a reason this would be the case, but there's a sense in which this kinda works.</p>
<p>My very loose reasoning is: <code>!Unpin</code> indicates that some pointers into the value exist that will be invalidated by the move. Which means some pointers into the value exist. Which means it can't be noalias.</p>
<p>That said this description <em>for sure</em> plays it fast and loose with the difference between values and types. And if things have been pinned or not. (TBH, it's bordering on deliberately handwavey, but attempts to unwave the hands only made it more confusing)</p>



<a name="270631905"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Self-referential%20generators%20stopgap/near/270631905" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Thom Chiovoloni <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Self-referential.20generators.20stopgap.html#270631905">(Feb 03 2022 at 23:02)</a>:</h4>
<p>I've come to understand that my mental model for what pin means is very different than how it was formalized (and thats about all I've come to understand about pins formalization), so I suspect this doesn't play nicely with that at all.</p>



<a name="270712602"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Self-referential%20generators%20stopgap/near/270712602" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Self-referential.20generators.20stopgap.html#270712602">(Feb 04 2022 at 13:15)</a>:</h4>
<p>I agree with that intuition, <span class="user-mention" data-user-id="209168">@Thom Chiovoloni</span>. Moreover, I'm pretty sure I recall <span class="user-mention" data-user-id="120791">@RalfJ</span> mentioning something along the lines of: when an <code>!Unpin</code> instance is pointed to by a <code>Pin</code>-wrapped pointer (when it is "pinned"), then, conceptually, the instance is kind of "owned by its memory location".<br>
So, in that regard, it surely can't be deemed unaliased anymore.</p>



<a name="270729221"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Self-referential%20generators%20stopgap/near/270729221" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Self-referential.20generators.20stopgap.html#270729221">(Feb 04 2022 at 15:24)</a>:</h4>
<p>If a <code>Pin&lt;&amp;mut T&gt;</code> (where <code>T: !Unpin</code>) would end up being aliasable, it would probably be better internally represented as an <code>&amp;UnsafeCell&lt;T&gt;</code> without compiler or SB modifications, something like this:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="cp">#![feature(specialization)]</span><span class="w"></span>

<span class="k">use</span><span class="w"> </span><span class="n">core</span>::<span class="n">marker</span>::<span class="n">PhantomData</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">core</span>::<span class="n">cell</span>::<span class="n">UnsafeCell</span><span class="p">;</span><span class="w"></span>

<span class="k">mod</span> <span class="nn">private</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">Sealed</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="w">    </span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Sealed</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="n">T</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="w">    </span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Sealed</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">Reference</span>: <span class="nc">private</span>::<span class="n">Sealed</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="sd">/// The type that the reference points to.</span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Target</span>: <span class="o">?</span><span class="nb">Sized</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="sd">/// How the reference is stored internally in `Pin`.</span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Pointer</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;'</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Reference</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;'</span><span class="na">a</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Pointer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;'</span><span class="na">a</span><span class="w"> </span><span class="n">T</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;'</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Reference</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;'</span><span class="na">a</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">T</span>: <span class="nb">Unpin</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Pointer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;'</span><span class="na">a</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">T</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">default</span><span class="w"> </span><span class="k">impl</span><span class="o">&lt;'</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Reference</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;'</span><span class="na">a</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Pointer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;'</span><span class="na">a</span><span class="w"> </span><span class="n">UnsafeCell</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Pin</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Reference</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">_phantom</span>: <span class="nc">PhantomData</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">pointer</span>: <span class="nc">T</span>::<span class="n">Pointer</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;'</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;&amp;'</span><span class="na">a</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Pin</span><span class="o">&lt;&amp;'</span><span class="na">a</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">pointer</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">a</span> <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">_phantom</span>: <span class="nc">PhantomData</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">pointer</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// This impl currently breaks the Rust compiler:</span>
<span class="c1">// error[E0275]: overflow evaluating the requirement `Pin&lt;&amp;mut _&gt;: From&lt;&amp;mut _&gt;`</span>
<span class="n">default</span><span class="w"> </span><span class="k">impl</span><span class="o">&lt;'</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;&amp;'</span><span class="na">a</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Pin</span><span class="o">&lt;&amp;'</span><span class="na">a</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">pointer</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">a</span> <span class="nc">mut</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">_phantom</span>: <span class="nc">PhantomData</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="c1">// SAFETY: casting `&amp;mut T` to &amp;UnsafeCell&lt;T&gt;` is sound</span>
<span class="w">            </span><span class="n">pointer</span>: <span class="nc">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">&amp;*</span><span class="p">(</span><span class="n">pointer</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;'</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;&amp;'</span><span class="na">a</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Pin</span><span class="o">&lt;&amp;'</span><span class="na">a</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">T</span>: <span class="nb">Unpin</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">pointer</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">a</span> <span class="nc">mut</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">_phantom</span>: <span class="nc">PhantomData</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">pointer</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>(This <a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=2bdaa697419cce8e95ece9c82f91ccc1">doesn't actually compile</a> today, even with the incomplete <code>specialization</code> feature :P)</p>



<a name="270730115"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Self-referential%20generators%20stopgap/near/270730115" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Self-referential.20generators.20stopgap.html#270730115">(Feb 04 2022 at 15:30)</a>:</h4>
<p>Interestingly enough, that error is not caused by the unstable <code>specialization</code> feature (<a href="https://github.com/rust-lang/rust/issues/37748">#37748</a>).</p>



<a name="270749294"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Self-referential%20generators%20stopgap/near/270749294" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Thom Chiovoloni <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Self-referential.20generators.20stopgap.html#270749294">(Feb 04 2022 at 17:52)</a>:</h4>
<p>i think the trait projection here would break covariance in stuff like <code>Pin&lt;&amp;'a T&gt;</code> and <code>Pin&lt;Box&lt;T&gt;&gt;</code></p>



<a name="270749364"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Self-referential%20generators%20stopgap/near/270749364" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Thom Chiovoloni <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Self-referential.20generators.20stopgap.html#270749364">(Feb 04 2022 at 17:53)</a>:</h4>
<p>but even if that worked, idrk that i really agree that this is a good way of modeling it</p>



<a name="270749751"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Self-referential%20generators%20stopgap/near/270749751" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Thom Chiovoloni <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Self-referential.20generators.20stopgap.html#270749751">(Feb 04 2022 at 17:56)</a>:</h4>
<p>istm that an unfortunate problem here is that even when the value is not held in a Pin, it still might be pinned, since you can get a <code>&amp;mut T</code> out of a <code>Pin&lt;&amp;mut T&gt;</code>, which shouldn't invalidate the aliasing pointers into the internals unless you move it out, which the unsafe makes you you promise not to do</p>



<a name="270750269"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Self-referential%20generators%20stopgap/near/270750269" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Thom Chiovoloni <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Self-referential.20generators.20stopgap.html#270750269">(Feb 04 2022 at 18:01)</a>:</h4>
<p>which means that any <code>&amp;mut impl !Unpin</code> potentially can be aliased, unless you know for sure it has not been pinned. at least from the compilers perspective and such -- what rust code can assume is different (as safe code can move out of a <code>&amp;mut impl !Unpin</code> with reckless abandon)</p>



<a name="270750317"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Self-referential%20generators%20stopgap/near/270750317" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Thom Chiovoloni <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Self-referential.20generators.20stopgap.html#270750317">(Feb 04 2022 at 18:01)</a>:</h4>
<p>(i believe this also all applies to <code>&amp;impl !Unpin</code> too, ofc, although its somewhat of a less interesting case)</p>



<a name="270750493"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Self-referential%20generators%20stopgap/near/270750493" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Thom Chiovoloni <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Self-referential.20generators.20stopgap.html#270750493">(Feb 04 2022 at 18:03)</a>:</h4>
<p>this all means i dont think unsafecell is an appropriate way to model it</p>



<a name="270750746"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Self-referential%20generators%20stopgap/near/270750746" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Thom Chiovoloni <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Self-referential.20generators.20stopgap.html#270750746">(Feb 04 2022 at 18:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="400735">Pointerbender</span> <a href="#narrow/stream/269128-miri/topic/Self-referential.20generators.20stopgap/near/270729221">said</a>:</p>
<blockquote>
<p>If a <code>Pin&lt;&amp;mut T&gt;</code> (where <code>T: !Unpin</code>) would end up being aliasable...</p>
</blockquote>
<p>e.g. i think the problem is that it has to still be aliasable so long as its pinned, even if youve pulled the <code>&amp;mut T</code> out of the pin. so thats not quite sufficient.</p>



<a name="270827567"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Self-referential%20generators%20stopgap/near/270827567" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Self-referential.20generators.20stopgap.html#270827567">(Feb 05 2022 at 13:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="209168">Thom Chiovoloni</span> <a href="#narrow/stream/269128-miri/topic/Self-referential.20generators.20stopgap/near/270749294">said</a>:</p>
<blockquote>
<p>i think the trait projection here would break covariance in stuff like <code>Pin&lt;&amp;'a T&gt;</code> and <code>Pin&lt;Box&lt;T&gt;&gt;</code></p>
<p>...</p>
<p>this all means i dont think unsafecell is an appropriate way to model it</p>
</blockquote>
<p>Oh yeah this is a really good point :) I fully agree with you there.</p>



<a name="270828203"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Self-referential%20generators%20stopgap/near/270828203" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Self-referential.20generators.20stopgap.html#270828203">(Feb 05 2022 at 13:54)</a>:</h4>
<p>Would <code>NonNull&lt;T&gt;</code> be a viable alternative to <code>&amp;UnsafeCell&lt;T&gt;</code> to store a <code>Pin&lt;T: !Unpin&gt;</code> internally? It would solve the problems with the variance and since any <code>&amp;mut T</code> derived from it would be a reborrow, this would be allowed under Stacked Borrows (with the assumption that only the internals of <code>Pin</code> and generators can promise this kind of behavior, as a kind of safe encapsulation - so not as a hard promise to the "outside world" that <code>Pin&lt;T: !Unpin&gt;</code> is allowed to alias anywhere). I guess <code>NonNull&lt;T&gt;</code> is less optimizable because it doesn't have alignment or write-provenance guarantees semantically (nor having tagged the <code>restrict</code> llvm keyword , for that matter) and these can all lead to missed compiler optimizations where the compiler can't infer these by itself.</p>



<a name="270833714"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Self-referential%20generators%20stopgap/near/270833714" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Self-referential.20generators.20stopgap.html#270833714">(Feb 05 2022 at 15:50)</a>:</h4>
<p>An example of what that might look like (this time it also compiles :P <a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=9dd5dbfa8b595f2b29cd6c7031046d33">playground</a>):</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="cp">#![feature(specialization)]</span><span class="w"></span>

<span class="k">use</span><span class="w"> </span><span class="n">core</span>::<span class="n">marker</span>::<span class="n">PhantomData</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">core</span>::<span class="n">ops</span>::<span class="p">{</span><span class="n">Deref</span><span class="p">,</span><span class="w"> </span><span class="n">DerefMut</span><span class="p">};</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">core</span>::<span class="n">ptr</span>::<span class="n">NonNull</span><span class="p">;</span><span class="w"></span>

<span class="k">mod</span> <span class="nn">private</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">Sealed</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="w">    </span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">core</span>::<span class="n">ops</span>::<span class="n">Deref</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Sealed</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">PinPointer</span>: <span class="nc">Deref</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">private</span>::<span class="n">Sealed</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Pointer</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">deref</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pointer</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">a</span> <span class="nc">Self</span>::<span class="n">Pointer</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="o">'</span><span class="na">a</span> <span class="o">&lt;</span><span class="bp">Self</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">Deref</span><span class="o">&gt;</span>::<span class="n">Target</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">default</span><span class="w"> </span><span class="k">impl</span><span class="o">&lt;</span><span class="n">P</span>: <span class="nc">Deref</span><span class="o">&gt;</span><span class="w"> </span><span class="n">PinPointer</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">P</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Pointer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NonNull</span><span class="o">&lt;&lt;</span><span class="n">P</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">Deref</span><span class="o">&gt;</span>::<span class="n">Target</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">deref</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pointer</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">a</span> <span class="nc">Self</span>::<span class="n">Pointer</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="o">'</span><span class="na">a</span> <span class="o">&lt;</span><span class="bp">Self</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">Deref</span><span class="o">&gt;</span>::<span class="n">Target</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// SAFETY: `self.pointer` is an aligned `NonNull` pointer.</span>
<span class="w">        </span><span class="c1">// SAFETY: `&amp;self.pointer` can be soundly represented as `*const *const P::Target`</span>
<span class="w">        </span><span class="c1">// SAFETY: and can safely be dereferenced twice.</span>
<span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">&amp;**</span><span class="p">(</span><span class="n">pointer</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">P</span>: <span class="nc">Deref</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Unpin</span><span class="o">&gt;</span><span class="w"> </span><span class="n">PinPointer</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">P</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Pointer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">P</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">deref</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pointer</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">a</span> <span class="nc">Self</span>::<span class="n">Pointer</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="o">'</span><span class="na">a</span> <span class="o">&lt;</span><span class="bp">Self</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">Deref</span><span class="o">&gt;</span>::<span class="n">Target</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">Pointer</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">Deref</span><span class="o">&gt;</span>::<span class="n">deref</span><span class="p">(</span><span class="n">pointer</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cp">#[derive(Copy, Clone)]</span><span class="w"></span>
<span class="cp">#[repr(transparent)]</span><span class="w"></span>
<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Pin</span><span class="o">&lt;</span><span class="n">P</span>: <span class="nc">PinPointer</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">_phantom</span>: <span class="nc">PhantomData</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">pointer</span>: <span class="nc">P</span>::<span class="n">Pointer</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">unsafe</span><span class="w"> </span><span class="k">impl</span><span class="o">&lt;</span><span class="n">P</span>: <span class="nc">PinPointer</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Pin</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">P</span>: <span class="nb">Send</span> <span class="p">{}</span><span class="w"></span>
<span class="k">unsafe</span><span class="w"> </span><span class="k">impl</span><span class="o">&lt;</span><span class="n">P</span>: <span class="nc">PinPointer</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Sync</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Pin</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">P</span>: <span class="nb">Sync</span> <span class="p">{}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">P</span>: <span class="nc">PinPointer</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Deref</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Pin</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="n">P</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">Deref</span><span class="o">&gt;</span>::<span class="n">Target</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">deref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Self</span>::<span class="n">Target</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="o">&lt;</span><span class="n">P</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">PinPointer</span><span class="o">&gt;</span>::<span class="n">deref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">pointer</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">P</span>: <span class="nc">PinPointer</span><span class="o">&lt;</span><span class="n">Pointer</span><span class="o">=</span><span class="n">P</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">DerefMut</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Pin</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">where</span><span class="w"></span>
<span class="w">    </span><span class="o">&lt;</span><span class="n">P</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">Deref</span><span class="o">&gt;</span>::<span class="n">Target</span>: <span class="nb">Unpin</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">P</span>: <span class="nc">DerefMut</span><span class="p">,</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">deref_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="bp">Self</span>::<span class="n">Target</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">pointer</span><span class="p">.</span><span class="n">deref_mut</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Pin</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">where</span><span class="w"></span>
<span class="w">    </span><span class="n">P</span>: <span class="nc">PinPointer</span><span class="o">&lt;</span><span class="n">Pointer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">P</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="o">&lt;</span><span class="n">P</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">Deref</span><span class="o">&gt;</span>::<span class="n">Target</span>: <span class="nb">Unpin</span><span class="p">,</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">pointer</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">_phantom</span>: <span class="nc">PhantomData</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">pointer</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Pin</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">where</span><span class="w"></span>
<span class="w">    </span><span class="n">P</span>: <span class="nb">Copy</span> <span class="o">+</span><span class="w"> </span><span class="n">PinPointer</span><span class="o">&lt;</span><span class="n">Pointer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NonNull</span><span class="o">&lt;&lt;</span><span class="n">P</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">Deref</span><span class="o">&gt;</span>::<span class="n">Target</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new_unchecked</span><span class="p">(</span><span class="n">pointer</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">_phantom</span>: <span class="nc">PhantomData</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">pointer</span>: <span class="nc">NonNull</span>::<span class="n">from</span><span class="p">(</span><span class="n">pointer</span><span class="p">.</span><span class="n">deref</span><span class="p">()),</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;'</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Pin</span><span class="o">&lt;&amp;'</span><span class="na">a</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">where</span><span class="w"></span>
<span class="w">    </span><span class="o">&amp;'</span><span class="na">a</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">T</span>: <span class="nc">PinPointer</span><span class="o">&lt;</span><span class="n">Pointer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NonNull</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new_unchecked_mut</span><span class="p">(</span><span class="n">pointer</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">a</span> <span class="nc">mut</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">_phantom</span>: <span class="nc">PhantomData</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">pointer</span>: <span class="nc">NonNull</span>::<span class="n">from</span><span class="p">(</span><span class="n">pointer</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">pin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Pin</span>::<span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">a</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="o">*</span><span class="n">pin</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">pin</span><span class="p">.</span><span class="n">deref_mut</span><span class="p">(),</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>



<a name="270840567"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Self-referential%20generators%20stopgap/near/270840567" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Thom Chiovoloni <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Self-referential.20generators.20stopgap.html#270840567">(Feb 05 2022 at 18:02)</a>:</h4>
<p>The issue is that the value is still pinned even after it is no longer wrapped in the pin. E.g. extracting the <code>&amp;mut T</code> from the Pin needs to be allowed, and should not invalidate the pointers (unless you use the <code>&amp;mut</code> to violate pinning guarantees ofc, which you promise via <code>unsafe</code> that you wont) -- this must be the case, because in practice you need to get a <code>&amp;mut T</code> out of the pin to use it in many cases.</p>
<p>Unfortunately, means that I don't think there's anything you can do to the internals of Pin to solve this, including NonNull. That is (AFAICT), once a value of an <code>!Unpin</code> type ever becomes pinned[^1], it behaves a bit like the value has a magic invisible UnsafeCell (or UnsafeAlias? IDK), wrapped around it or something. This cannot be modeled statically, without significant breaking changes</p>
<p>Sadly, the fact that it isn't a wrapper and instead is trait-based is not really obviously sensible, and seems fragile. For example, it seems like a problem when references are taken to fields of the <code>&amp;mut Unpin</code>.</p>
<p>These would get noalias on them (as they are <code>Unpin</code>), even though they may have pointers to them. This is not directly possible with <code>async {}</code> (it might be indirectly possible when the value is polled, but may take some contrived case for something to go wrong...). </p>
<p>Either way, it seems like a problem whether or not <code>async {}</code> hits it,  and more broadly, it was kinda part of why I've argued a few times that us needing to disable noalias on <code>!Unpin</code> is a bad sign, and feels like we may probably shouldn't be applying it as aggressively as we do. That said, that's an unpopular opinion, and maybe I'm too pessimistic.</p>
<p>[^1]: Something like this anyway -- miri and rustc don't noalias any !unpin, even ones that have never been pinned. I think this is just because rustc has no way of knowing if the value has been pinned in most cases, and miri follows rustcs lead here, but it may be that the rules are more complex than I can tell.</p>



<a name="270896642"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Self-referential%20generators%20stopgap/near/270896642" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Self-referential.20generators.20stopgap.html#270896642">(Feb 06 2022 at 15:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="209168">Thom Chiovoloni</span> <a href="#narrow/stream/269128-miri/topic/Self-referential.20generators.20stopgap/near/270840567">said</a>:</p>
<blockquote>
<p>Either way, it seems like a problem whether or not <code>async {}</code> hits it,  and more broadly, it was kinda part of why I've argued a few times that us needing to disable noalias on <code>!Unpin</code> is a bad sign, and feels like we may probably shouldn't be applying it as aggressively as we do. That said, that's an unpopular opinion, and maybe I'm too pessimistic.</p>
</blockquote>
<p>I'd say you make good arguments for it :) I'm not a pinning expert, but am still curious to see how they'd solve that! Thank you for all the feedback :)</p>



<a name="270993814"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Self-referential%20generators%20stopgap/near/270993814" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Self-referential.20generators.20stopgap.html#270993814">(Feb 07 2022 at 15:23)</a>:</h4>
<p><span class="user-mention" data-user-id="209168">@Thom Chiovoloni</span> </p>
<blockquote>
<p>Sadly, the fact that it isn't a wrapper and instead is trait-based is not really obviously sensible, and seems fragile. For example, it seems like a problem when references are taken to fields of the &amp;mut Unpin.</p>
<p>These would get noalias on them (as they are Unpin), even though they may have pointers to them. This is not directly possible with async {} (it might be indirectly possible when the value is polled, but may take some contrived case for something to go wrong...). </p>
</blockquote>
<p>do you have an example of when this would be a problem?</p>



<a name="270993990"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Self-referential%20generators%20stopgap/near/270993990" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Thom Chiovoloni <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Self-referential.20generators.20stopgap.html#270993990">(Feb 07 2022 at 15:24)</a>:</h4>
<p>Hmm, with <code>async{}</code>? No, it's possible I'm wrong and it wouldn't?</p>



<a name="270994033"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Self-referential%20generators%20stopgap/near/270994033" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Thom Chiovoloni <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Self-referential.20generators.20stopgap.html#270994033">(Feb 07 2022 at 15:25)</a>:</h4>
<p>I can come up with what i mean for a manually self-referential type</p>



<a name="270994038"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Self-referential%20generators%20stopgap/near/270994038" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Thom Chiovoloni <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Self-referential.20generators.20stopgap.html#270994038">(Feb 07 2022 at 15:25)</a>:</h4>
<p>if thats not clear</p>



<a name="270994072"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Self-referential%20generators%20stopgap/near/270994072" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Self-referential.20generators.20stopgap.html#270994072">(Feb 07 2022 at 15:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="232018">Daniel Henry-Mantilla</span> <a href="#narrow/stream/269128-miri/topic/Self-referential.20generators.20stopgap/near/270712602">said</a>:</p>
<blockquote>
<p>I agree with that intuition, <span class="user-mention silent" data-user-id="209168">Thom Chiovoloni</span>. Moreover, I'm pretty sure I recall <span class="user-mention silent" data-user-id="120791">RalfJ</span> mentioning something along the lines of: when an <code>!Unpin</code> instance is pointed to by a <code>Pin</code>-wrapped pointer (when it is "pinned"), then, conceptually, the instance is kind of "owned by its memory location".<br>
So, in that regard, it surely can't be deemed unaliased anymore.</p>
</blockquote>
<p>I dont know what you mean by "owned by its memory location"... but very roughly my definition of pinning says that ownership of that memory is then subject to library-specific rules, i.e., it is managed by the type itself. that is very different from the regular owned / mutably borrowed case where we know that ownership of the memory lies with the owner of that type.</p>



<a name="270994192"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Self-referential%20generators%20stopgap/near/270994192" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Self-referential.20generators.20stopgap.html#270994192">(Feb 07 2022 at 15:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="209168">Thom Chiovoloni</span> <a href="#narrow/stream/269128-miri/topic/Self-referential.20generators.20stopgap/near/270994033">said</a>:</p>
<blockquote>
<p>I can come up with what i mean for a manually self-referential type</p>
</blockquote>
<p>yeah that's what I mean -- a reasonably realistic example where this would happen in practice</p>



<a name="270994504"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Self-referential%20generators%20stopgap/near/270994504" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Self-referential.20generators.20stopgap.html#270994504">(Feb 07 2022 at 15:28)</a>:</h4>
<p>FWIW I think the best idea in <a href="https://github.com/rust-lang/rust/issues/63818">https://github.com/rust-lang/rust/issues/63818</a> so far was to have something like UnsafeAliasable or so, which acts similar to UnsafeCell but opts-out of uniqueness (rather than opting out of immutability)</p>



<a name="270994569"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Self-referential%20generators%20stopgap/near/270994569" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Thom Chiovoloni <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Self-referential.20generators.20stopgap.html#270994569">(Feb 07 2022 at 15:28)</a>:</h4>
<p>Yeah, i broadly like the idea of that too, but don't see how it could be compatible with pin/unpin</p>



<a name="270995086"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Self-referential%20generators%20stopgap/near/270995086" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Thom Chiovoloni <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Self-referential.20generators.20stopgap.html#270995086">(Feb 07 2022 at 15:32)</a>:</h4>
<p>that said, i do feel some degree of wrapper fatigue. but maybe i just need to embrace <code>UnsafeAlias&lt;UnsafeCell&lt;MaybeUninit&lt;T&gt;&gt;&gt;</code> as peak rust</p>



<a name="270995230"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Self-referential%20generators%20stopgap/near/270995230" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Thom Chiovoloni <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Self-referential.20generators.20stopgap.html#270995230">(Feb 07 2022 at 15:32)</a>:</h4>
<p>i think the problem with UnsafeAlias is that it seems tricky to use, since in practice you need a &amp;T or &amp;mut T to do most things with a type, and as soon as you get something out of UnsafeAlias the jig is up</p>



<a name="270995354"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Self-referential%20generators%20stopgap/near/270995354" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Thom Chiovoloni <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Self-referential.20generators.20stopgap.html#270995354">(Feb 07 2022 at 15:33)</a>:</h4>
<p>The !Unpin workaround avoids that issue but... feels like it has others. I could be wrong though.</p>



<a name="270996489"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Self-referential%20generators%20stopgap/near/270996489" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Thom Chiovoloni <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Self-referential.20generators.20stopgap.html#270996489">(Feb 07 2022 at 15:41)</a>:</h4>
<p>That said, the degree to which "the jig is up" is more substantial in current SB than it feels like it needs to be, since (i believe) extracting the <code>&amp;mut T</code> will invalidate the other pointers into the UnsafeAlias permanently. If it only did so during the span of time that the reference was around, it would be more usable, perhaps.</p>



<a name="271006753"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Self-referential%20generators%20stopgap/near/271006753" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Self-referential.20generators.20stopgap.html#271006753">(Feb 07 2022 at 16:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="209168">Thom Chiovoloni</span> <a href="#narrow/stream/269128-miri/topic/Self-referential.20generators.20stopgap/near/270995086">said</a>:</p>
<blockquote>
<p>that said, i do feel some degree of wrapper fatigue. but maybe i just need to embrace <code>UnsafeAlias&lt;UnsafeCell&lt;MaybeUninit&lt;T&gt;&gt;&gt;</code> as peak rust</p>
</blockquote>
<p>yeah... type wrappers are great to let the type system help us express various things, but they dont compose terribly well</p>



<a name="271006851"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Self-referential%20generators%20stopgap/near/271006851" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Self-referential.20generators.20stopgap.html#271006851">(Feb 07 2022 at 16:47)</a>:</h4>
<p><span class="user-mention silent" data-user-id="209168">Thom Chiovoloni</span> <a href="#narrow/stream/269128-miri/topic/Self-referential.20generators.20stopgap/near/270995230">said</a>:</p>
<blockquote>
<p>i think the problem with UnsafeAlias is that it seems tricky to use, since in practice you need a &amp;T or &amp;mut T to do most things with a type, and as soon as you get a &amp;mut out of UnsafeAlias the jig is up</p>
</blockquote>
<p>well it'd have to be like UnsafeCell -- you would have <code>&amp;mut UnsafeAlias&lt;T&gt;</code></p>



<a name="271006970"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Self-referential%20generators%20stopgap/near/271006970" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Self-referential.20generators.20stopgap.html#271006970">(Feb 07 2022 at 16:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="209168">Thom Chiovoloni</span> <a href="#narrow/stream/269128-miri/topic/Self-referential.20generators.20stopgap/near/270996489">said</a>:</p>
<blockquote>
<p>That said, the degree to which "the jig is up" is more substantial in current SB than it feels like it needs to be, since (i believe) extracting the <code>&amp;mut T</code> will invalidate the other pointers into the UnsafeAlias permanently. If it only did so during the span of time that the reference was around, it would be more usable, perhaps.</p>
</blockquote>
<p>that depends on where the reference is derived from -- if all those aliasing pointers form a single "equivalence class" for aliasing (as they should), then deriving an &amp;mut from one of them will not invalidate the others. but using any of the others will invalidate the &amp;mut, of course.</p>



<a name="271188668"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Self-referential%20generators%20stopgap/near/271188668" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Alice Ryhl <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Self-referential.20generators.20stopgap.html#271188668">(Feb 08 2022 at 20:48)</a>:</h4>
<p>Hey. I was pointed to this thread from &lt;<a href="https://github.com/tokio-rs/tokio/issues/3101">https://github.com/tokio-rs/tokio/issues/3101</a>&gt;</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>