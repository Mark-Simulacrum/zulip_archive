<html>
<head><meta charset="utf-8"><title>Pointer caching · miri · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/index.html">miri</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html">Pointer caching</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="271288183"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271288183" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dragoș Tiselice <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271288183">(Feb 09 2022 at 14:45)</a>:</h4>
<p>Hi!</p>
<p>I wrote an abstraction that caches a buffer split into many mutable sub slices. The use case is for a framebuffer where we want to be able to split it according to some layout for writing, and then we want to use the same reference to read from the same buffer which means giving up on all the computed splits. In order not to lose all that computation, I'm caching them in a type that uses unsafe and only grants access to the splits if it's provided with the same exact reference as the one they were created from.</p>
<p>However, I see that miri considers this UB and I'm having a bit of a hard time understanding why.</p>



<a name="271288664"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271288664" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dragoș Tiselice <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271288664">(Feb 09 2022 at 14:48)</a>:</h4>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=01a3d38c1915c266faa2d7137bff5239">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=01a3d38c1915c266faa2d7137bff5239</a></p>



<a name="271289194"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271289194" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dragoș Tiselice <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271289194">(Feb 09 2022 at 14:52)</a>:</h4>
<p>The issue seems to be around storing the cached splits between accesses since the first access seems to pass fine, which means that storing it in the cache and then transmuting it seems to be the main issue.</p>



<a name="271291177"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271291177" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dragoș Tiselice <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271291177">(Feb 09 2022 at 15:05)</a>:</h4>
<p>My end goal here was to have a cache where I can store non-overlapping mutable sub-slices of a buffer and only have access to the when I have mutable access to the buffer itself.</p>



<a name="271311403"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271311403" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dragoș Tiselice <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271311403">(Feb 09 2022 at 17:06)</a>:</h4>
<p>Here is a simplified version that still fails: <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=9363bbc4c9a5c240f34fd5c77fc8c4e6">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=9363bbc4c9a5c240f34fd5c77fc8c4e6</a></p>



<a name="271313416"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271313416" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271313416">(Feb 09 2022 at 17:19)</a>:</h4>
<p>the <code>&amp;mut buffer</code> in line 37 invalidates the pointers created in the <code>new</code> call in line 35. It doesn't matter that the pointers are equal, the first pointers are now invalid</p>



<a name="271313951"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271313951" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dragoș Tiselice <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271313951">(Feb 09 2022 at 17:22)</a>:</h4>
<p>Does the same happen here: <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=0895607f812aaa0e5030d64056c05d20">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=0895607f812aaa0e5030d64056c05d20</a><br>
?</p>



<a name="271313973"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271313973" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dragoș Tiselice <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271313973">(Feb 09 2022 at 17:22)</a>:</h4>
<p>miri seems to pass this one.</p>



<a name="271314234"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271314234" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dragoș Tiselice <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271314234">(Feb 09 2022 at 17:24)</a>:</h4>
<p>Also, why would <code>&amp;mut buffer</code> invalidate the pointers? Isn't this what <code>RefCell</code> does?</p>



<a name="271314356"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271314356" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ben Kimock (Saethlin) <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271314356">(Feb 09 2022 at 17:24)</a>:</h4>
<p>Miri passes with the default flags. It does not pass if you enable all of Stacked Borrows with <code>MIRIFLAGS=-Zmiri-tag-raw-pointers</code>.</p>



<a name="271315053"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271315053" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ben Kimock (Saethlin) <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271315053">(Feb 09 2022 at 17:28)</a>:</h4>
<p>Stacked Borrows is an absolute minefield for implementing code like this. In general, under Stacked Borrows, you need to avoid creating unique references. The code it makes you write can seem a bit convoluted as a result.</p>



<a name="271315237"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271315237" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271315237">(Feb 09 2022 at 17:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="351014">Dragoș Tiselice</span> <a href="#narrow/stream/269128-miri/topic/Pointer.20caching/near/271314234">said</a>:</p>
<blockquote>
<p>Also, why would <code>&amp;mut buffer</code> invalidate the pointers? Isn't this what <code>RefCell</code> does?</p>
</blockquote>
<p><code>&amp;mut</code> stands for <em>unique</em> / <em>exclusive</em> / unaliased pointer; <code>RefCell</code> and other like abstractions are based on <em>shared</em> pointers. Usually the trick is, when receiving  a <code>&amp;mut …</code>, to use something semantically akin to <a href="https://doc.rust-lang.org/stable/std/cell/struct.Cell.html#method.from_mut">https://doc.rust-lang.org/stable/std/cell/struct.Cell.html#method.from_mut</a> to loosen the "exclusive &amp; mutable" invariant down to "shared &amp; mutable". then you can freely interleave these <code>&amp;</code> accesses, provided you be careful when temporarily upgrading them back to <code>&amp;mut</code>, to only do so when the lifetimes in the API, or runtime tools, somehow guarantee that temporary exclusivity</p>



<a name="271315570"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271315570" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dragoș Tiselice <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271315570">(Feb 09 2022 at 17:31)</a>:</h4>
<p><code>Cell::from_mut</code> is similar in spirit to what I'm trying to achieve here.</p>



<a name="271315750"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271315750" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dragoș Tiselice <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271315750">(Feb 09 2022 at 17:32)</a>:</h4>
<p>I guess the main issue in my example is the provenience of the pointer used to create the unique reference?</p>



<a name="271317400"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271317400" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ben Kimock (Saethlin) <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271317400">(Feb 09 2022 at 17:40)</a>:</h4>
<p>The current problems you're running into are aliasing, not necessarily provenance. I think you can get around the problems with Stacked Borrows invalidation based on creation of &amp;mut by not creating &amp;mut. Just pay attention to calling methods that have a &amp;mut receiver.</p>



<a name="271317725"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271317725" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dragoș Tiselice <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271317725">(Feb 09 2022 at 17:42)</a>:</h4>
<p>That makes sense, but I'm having issues seeing where I'm creating &amp;mut's. Lemme try to digest it further.</p>



<a name="271319117"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271319117" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dragoș Tiselice <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271319117">(Feb 09 2022 at 17:49)</a>:</h4>
<p>I guess this is caused by the fact that <code>slice</code> will be aliased by the sub-slices that I'm returning in <code>fn access</code>. But without passing <code>slice</code> as a <code>&amp;mut</code> I won't be able to grab its lifetime.</p>



<a name="271321472"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271321472" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dragoș Tiselice <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271321472">(Feb 09 2022 at 18:02)</a>:</h4>
<p>Maybe a better question to ask would be: for such saved raw slices (ptr + len), is there any way you can produce unique <code>&amp;mut</code> slices from them that would be accepted by Stacked Borrows?</p>



<a name="271336822"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271336822" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271336822">(Feb 09 2022 at 19:47)</a>:</h4>
<p>In these cases I like to use <code>&amp;UnsafeCell&lt;[T]&gt;</code> instead of <code>&amp;mut [T]</code> everywhere. Then, using raw pointer arithmetic, I can create disjoint subslices (also passed around as <code>&amp;UnsafeCell&lt;[T]&gt;</code> or <code>&amp;UnsafeCell&lt;T&gt;</code>) and either write directly through the raw pointer or temporarily upgrade it to a <code>&amp;mut T</code> where needed, without invalidating the pointer(s) that it was reborrowed from.</p>



<a name="271337017"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271337017" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271337017">(Feb 09 2022 at 19:48)</a>:</h4>
<p>Caveat: this will make <code>T</code> invariant, so it won't work so well when <code>T</code> has any lifetimes attached, unless you apply more tricks to work-around that on a case-by-case basis.</p>



<a name="271337138"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271337138" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271337138">(Feb 09 2022 at 19:49)</a>:</h4>
<p>but for stuff like <code>&amp;UnsafeCell&lt;[u8]&gt;</code> this approach works great.</p>



<a name="271337277"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271337277" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271337277">(Feb 09 2022 at 19:50)</a>:</h4>
<p>If you are concerned about preserving variance, then raw pointers and/or <code>NonNull</code> are your next best bet.</p>



<a name="271337392"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271337392" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271337392">(Feb 09 2022 at 19:51)</a>:</h4>
<p>Actually, <code>NonNull</code> is better, <code>*mut T</code> is also invariant in <code>T</code> :)</p>



<a name="271338154"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271338154" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dragoș Tiselice <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271338154">(Feb 09 2022 at 19:56)</a>:</h4>
<p><code>T</code> being invariant works fine. The issue with this approach is that I really wanted to have an API that lets end-users use this without having to write unsafe code.</p>



<a name="271338214"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271338214" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271338214">(Feb 09 2022 at 19:56)</a>:</h4>
<p><code>NonNull&lt;[T]&gt;</code> and <code>&amp;UnsafeCell&lt;[T]&gt;</code> both promise the pointer won't be null, but differ in a couple of ways: the latter encodes the promise that the pointee is properly aligned and properly initialized and <code>NonNull</code> does not, which matters for some compiler optimizations.</p>



<a name="271338237"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271338237" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dragoș Tiselice <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271338237">(Feb 09 2022 at 19:56)</a>:</h4>
<p>Another issue is that I don't have ownership of the array.</p>



<a name="271338394"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271338394" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271338394">(Feb 09 2022 at 19:58)</a>:</h4>
<p><code>&amp;UnsafeCell&lt;[T]&gt;</code> is safe to pass around, as long as the end-users don't access the pointee. Alternatively, you can exchange <code>&amp;Cell&lt;[T]&gt;</code> or <code>Cell&lt;T&gt;</code> with your end-users as a safe encapsulation for accessing the inner <code>&amp;UnsafeCell</code>.</p>



<a name="271338684"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271338684" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271338684">(Feb 09 2022 at 19:59)</a>:</h4>
<p>(it's also sound to cast <code>&amp;mut T</code> to a <code>&amp;UnsafeCell&lt;T&gt;</code> in case you don't have ownership to the array, a mutable borrow would suffice in this case)</p>



<a name="271338860"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271338860" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271338860">(Feb 09 2022 at 20:00)</a>:</h4>
<p><code>Cell::from_mut</code> has a safe API for this, for <code>&amp;UnsafeCell</code> you have to resort to unsafe (but sound) pointer casts to obtain it from a <code>&amp;mut T</code>.</p>



<a name="271338916"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271338916" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dragoș Tiselice <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271338916">(Feb 09 2022 at 20:00)</a>:</h4>
<p><code>Cell::from_mut</code> could be promising. But I'm not completely sure whether it'll work.</p>



<a name="271338948"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271338948" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dragoș Tiselice <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271338948">(Feb 09 2022 at 20:00)</a>:</h4>
<p>Exactly.</p>



<a name="271339386"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271339386" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271339386">(Feb 09 2022 at 20:03)</a>:</h4>
<p>Another suggestion (just shooting ideas here :P) is to change the API to not give out mutable references, but rather accept an immutable reference from the caller, which your API will then internally write to the correct memory location (I guess giving a <code>&amp;mut T</code> or a <code>&amp;Cell&lt;T&gt;</code> to the end-user is more desirable if you're concerned about stuff like minimal copying etc.).</p>



<a name="271339816"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271339816" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dragoș Tiselice <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271339816">(Feb 09 2022 at 20:06)</a>:</h4>
<p>It's just not very clear to me whether <code>Cell::from_mut</code> could let me cache splits.</p>



<a name="271340344"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271340344" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271340344">(Feb 09 2022 at 20:10)</a>:</h4>
<p>Ah, how I intended that is if you have a <code>&amp;UnsafeCell&lt;T&gt;</code> for which you know it's safe to let a end-user to write to that location (e.g. no <code>Sync</code> accesses from multiple threads), then you can  hand-out a reference <code>r</code> where <code>let r: &amp;Cell&lt;T&gt; = Cell::from_mut(unsafe { &amp;mut *unsafe_cell.get() });</code></p>



<a name="271340497"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271340497" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271340497">(Feb 09 2022 at 20:11)</a>:</h4>
<p>To the caller <code>Cell&lt;T&gt;</code> is a safe interface, but internally within the API you'd have to resort to a bit of unsafe to obtain the right pointer to build the temporary <code>&amp;mut T</code>.</p>



<a name="271340717"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271340717" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dragoș Tiselice <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271340717">(Feb 09 2022 at 20:13)</a>:</h4>
<p>The issue is that I actually need a long-living object that will repeatedly obtain the <code>&amp;mut [T]</code>. Since the pointer is expected to be the same, I'm trying to cache the sub-slices.</p>



<a name="271340804"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271340804" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dragoș Tiselice <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271340804">(Feb 09 2022 at 20:14)</a>:</h4>
<p>The exact use case is rendering once per frame to a framebuffer.</p>



<a name="271340834"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271340834" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dragoș Tiselice <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271340834">(Feb 09 2022 at 20:14)</a>:</h4>
<p>Which comes in the form of a <code>&amp;mut [u8]</code>.</p>



<a name="271340965"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271340965" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dragoș Tiselice <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271340965">(Feb 09 2022 at 20:15)</a>:</h4>
<p>I'm also trying to write to the framebuffer from multiple threads, so <code>Cell</code> won't work.</p>



<a name="271341779"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271341779" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271341779">(Feb 09 2022 at 20:22)</a>:</h4>
<p>are the subslices that the multiple threads are writing to disjoint in this case?</p>



<a name="271341811"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271341811" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dragoș Tiselice <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271341811">(Feb 09 2022 at 20:22)</a>:</h4>
<p>Yes.</p>



<a name="271341876"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271341876" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dragoș Tiselice <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271341876">(Feb 09 2022 at 20:23)</a>:</h4>
<p>That's why I liked the first design: it forces you to come up with splits from an original slice, so they are guaranteed to be disjoint.</p>



<a name="271342055"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271342055" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271342055">(Feb 09 2022 at 20:24)</a>:</h4>
<p>I see, but now the problem becomes the recombination of those slices under Stacked Borrows. Hmm, I think the only way to work-around that I think is to keep one main slice around, and only hand-out disjoint subslices to different threads. Then recover the original "main slice" at the end when all the threads finish the work.</p>



<a name="271342103"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271342103" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271342103">(Feb 09 2022 at 20:25)</a>:</h4>
<p>A while back I published a crate that may help with drawing inspiration how to do this: <a href="https://crates.io/crates/deferred-reference">https://crates.io/crates/deferred-reference</a></p>



<a name="271342169"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271342169" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dragoș Tiselice <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271342169">(Feb 09 2022 at 20:25)</a>:</h4>
<p>Do you need to recover it?</p>



<a name="271342171"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271342171" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271342171">(Feb 09 2022 at 20:25)</a>:</h4>
<p>Mandatory heads-up: it currently has some soundness issues which I have not gotten around to fixing yet :)</p>



<a name="271342336"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271342336" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271342336">(Feb 09 2022 at 20:26)</a>:</h4>
<p>I guess you only need to recover the original whole slice if you want to pass it to the next consumer. If there is no next consumer, then recovering it is optional.</p>



<a name="271342712"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271342712" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271342712">(Feb 09 2022 at 20:29)</a>:</h4>
<p>The way the concept of "Deferred References" works, is that you can start out with a full slice, and obtain reference to subslices without taking a reference to the entire original slice (and in this way you can avoid invalidating any <code>&amp;mut</code> references that were already given out to other subslices.</p>



<a name="271342860"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271342860" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271342860">(Feb 09 2022 at 20:30)</a>:</h4>
<p>e.g. this example from the docs: <a href="https://docs.rs/deferred-reference/0.1.2/deferred_reference/struct.Deferred.html#method.get_mut">https://docs.rs/deferred-reference/0.1.2/deferred_reference/struct.Deferred.html#method.get_mut</a></p>



<a name="271343492"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271343492" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dragoș Tiselice <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271343492">(Feb 09 2022 at 20:35)</a>:</h4>
<p>This looks very impressive, but since it still keeps a reference from the original slice, it doesn't help with my use case. :')</p>



<a name="271344452"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271344452" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271344452">(Feb 09 2022 at 20:43)</a>:</h4>
<p>Hmm, what about using the <code>slice</code> passed to <code>.access(slice)</code> and re-execute the closure to split it into identical slices, instead of re-using the inner <code>splits_raw</code> pointer?</p>



<a name="271344706"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271344706" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dragoș Tiselice <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271344706">(Feb 09 2022 at 20:45)</a>:</h4>
<p>That improved the situation, but re-executing the closure is exactly what I'm trying to avoid. Imagine a 4K framebuffer where this can be expensive to execute each frame.</p>



<a name="271345078"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271345078" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271345078">(Feb 09 2022 at 20:48)</a>:</h4>
<p>I understand, in that case I'm afraid using something like <code>&amp;UnsafeCell&lt;[T]&gt;</code> is the only option. It might still be possible to do safely though, let me see if I can alter the example to see if I can get it to work, one moment :)</p>



<a name="271345240"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271345240" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dragoș Tiselice <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271345240">(Feb 09 2022 at 20:49)</a>:</h4>
<p>How do you produce the <code>&amp;UnsafeCell&lt;[T]&gt;</code>? I guess transmuting the <code>&amp;mut [T]</code> is the only way.</p>



<a name="271345869"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271345869" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271345869">(Feb 09 2022 at 20:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="351014">Dragoș Tiselice</span> <a href="#narrow/stream/269128-miri/topic/Pointer.20caching/near/271345240">said</a>:<br>
Try to avoid <code>transmute</code>s on <code>repr(Rust)</code> data types such as pointers or references to <code>!Sized</code> types (wide pointers). Instead, in this instance, a pointer cast would be less dangerous:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span> <span class="nf">from_mut</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">slice</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="nb">_</span> <span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="n">T</span><span class="p">])</span><span class="w"></span>
<span class="w">  </span>-&gt; <span class="kp">&amp;</span><span class="o">'</span><span class="nb">_</span> <span class="nc">UnsafeCell</span><span class="o">&lt;</span><span class="p">[</span><span class="n">T</span><span class="p">]</span><span class="o">&gt;</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="o">&amp;*</span><span class="p">(</span><span class="n">slice</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="p">[</span><span class="n">T</span><span class="p">]</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">UnsafeCell</span><span class="o">&lt;</span><span class="p">[</span><span class="n">T</span><span class="p">]</span><span class="o">&gt;</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>



<a name="271345882"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271345882" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271345882">(Feb 09 2022 at 20:55)</a>:</h4>
<p>Like so: <a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=dce42d18d1ed589e19df860bb9c92fe2">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=dce42d18d1ed589e19df860bb9c92fe2</a></p>



<a name="271345941"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271345941" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271345941">(Feb 09 2022 at 20:55)</a>:</h4>
<p>(without transmute or pointer cast :) )</p>



<a name="271345984"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271345984" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271345984">(Feb 09 2022 at 20:55)</a>:</h4>
<p>(from the end-user's perspective)</p>



<a name="271346113"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271346113" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271346113">(Feb 09 2022 at 20:56)</a>:</h4>
<p>It does require a nightly feature though</p>



<a name="271346140"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271346140" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271346140">(Feb 09 2022 at 20:56)</a>:</h4>
<p>otherwise we can't take the slice pointer length without creating a reference to it</p>



<a name="271346425"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271346425" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271346425">(Feb 09 2022 at 20:59)</a>:</h4>
<p>I've been trying to nudge it along into getting stabilized (at least for <code>NonNull::len</code>), but the <a href="https://github.com/rust-lang/rust/issues/71146">tracking issue</a> is not so active atm, I'll give it another nudge one of these days. It's a really useful API, I'm using it in a couple of places myself, too :)</p>



<a name="271346624"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271346624" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271346624">(Feb 09 2022 at 21:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="400735">Pointerbender</span> <a href="#narrow/stream/269128-miri/topic/Pointer.20caching/near/271346140">said</a>:</p>
<blockquote>
<p>otherwise we can't take the slice pointer length without creating a reference to it</p>
</blockquote>
<p>AFAIK, in cases such as this one it can be polyfilled as <code>(&amp;*(raw_slice as *const [()])).len()</code></p>



<a name="271346764"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271346764" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271346764">(Feb 09 2022 at 21:01)</a>:</h4>
<p>Omg, that's clever, this opens up so many possibilities! <span aria-label="smiley" class="emoji emoji-1f603" role="img" title="smiley">:smiley:</span></p>



<a name="271346885"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271346885" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271346885">(Feb 09 2022 at 21:02)</a>:</h4>
<p>That even works for slice lengths above <code>isize::MAX</code> too!</p>



<a name="271346964"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271346964" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271346964">(Feb 09 2022 at 21:03)</a>:</h4>
<p>(not likely to encounter those in practice, but apparently it's possible to encounter them on 32-bit systems with Physical Address Extension enabled :P )</p>



<a name="271347130"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271347130" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271347130">(Feb 09 2022 at 21:04)</a>:</h4>
<p>Thanks for sharing that little nugget, that made my day :)</p>



<a name="271348547"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271348547" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dragoș Tiselice <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271348547">(Feb 09 2022 at 21:15)</a>:</h4>
<p>Thank you so much for the help! :) Does passing <code>UnsafeCell</code> make it work with miri?</p>



<a name="271348778"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271348778" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271348778">(Feb 09 2022 at 21:17)</a>:</h4>
<p>Yes, on the playground it does, I think that has the <code>MIRIFLAGS="-Zmiri-track-raw-pointers"</code> flag turned on by default, but I'm not 100% sure.</p>



<a name="271348809"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271348809" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271348809">(Feb 09 2022 at 21:18)</a>:</h4>
<p>Let me run it locally real quick to make sure, one sec.</p>



<a name="271349396"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271349396" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271349396">(Feb 09 2022 at 21:23)</a>:</h4>
<p>Yep, it passes with <code>MIRIFLAGS="-Zmiri-track-raw-pointers"</code>, too. Note that end-users might be tempted to create their own references into the <code>UnsafeCell</code> wrapper since it exposes an API to get the raw pointer. This would require <code>unsafe</code> on the end-user side, so therefore I think still counts as "sound", because it would require <code>unsafe</code> to trigger UB. But, if you want to take away this footgun you could wrap the <code>UnsafeCell</code> in a <code>#[repr(transparent)]</code> <code>FrameBuffer</code> wrapper struct so that end-users can't obtain a raw pointer.</p>



<a name="271349682"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271349682" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271349682">(Feb 09 2022 at 21:25)</a>:</h4>
<p>Something like:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="cp">#[repr(transparent)]</span><span class="w"></span>
<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">FrameBuffer</span><span class="o">&lt;</span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span><span class="w"> </span><span class="n">buffer</span>: <span class="nc">UnsafeCell</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">FrameBuffer</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">pub</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">buffer</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">buffer</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>



<a name="271349764"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271349764" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dragoș Tiselice <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271349764">(Feb 09 2022 at 21:26)</a>:</h4>
<p>A wrapper makes sense, but I think I can probably change the API a bit in order to hide this part. Thank you so much for the help! :) I hope, if anything, that this might prove to be a useful test case.</p>



<a name="271349814"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271349814" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271349814">(Feb 09 2022 at 21:26)</a>:</h4>
<p>My pleasure, thanks for the fun puzzle :D</p>



<a name="271411811"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271411811" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271411811">(Feb 10 2022 at 10:26)</a>:</h4>
<p><span class="user-mention" data-user-id="351014">@Dragoș Tiselice</span> I had an after-thought about this :) Since <code>SplitsCache</code> implements <code>Sync</code>, but <code>UnsafeCell</code> is not <code>Sync</code>, there is a soundness hole in the approach I suggested: it's possible to create multiple <code>SplitsCache</code> instances backed by the same memory slice and an end-user can safely (but unsoundly) share these between threads, this could in theory allow data races to the backing memory which is undefined behavior. In order to make this sound, you may need to globally keep track of slices that are being held by a <code>SplitsCache</code>, and not let a end-user create a second <code>SplitsCache</code> to a slice which is already wrapped in a <code>SplitsCache</code> somewhere else.</p>



<a name="271427109"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271427109" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dragoș Tiselice <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271427109">(Feb 10 2022 at 13:01)</a>:</h4>
<p>I think I finally understood the issue and, unfortunately, the solution with <code>UnsafeCell</code>doesn't work. The issue with this is that I want to be able to provide different <code>&amp;mut</code>s to <code>access</code>.</p>
<p>E.g. there's a code that I don't own that serves <code>&amp;mut</code> every frame. If I simply covert those to <code>&amp;UnsafeCell&lt;[T]&gt;</code>, I'm just moving the problem to a different place, but the issue is still there since the pointer that ultimately ends up sent to <code>access</code> comes from a different <code>&amp;mut</code>.</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span> <span class="nf">feed_framebuffer</span><span class="p">(</span><span class="n">framebuffer</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// This fails here because for every iteration of the loop below, you produce another &amp;mut.</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">uc</span>: <span class="kp">&amp;</span><span class="nc">UnsafeCell</span><span class="o">&lt;</span><span class="p">[</span><span class="kt">u8</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">&amp;*</span><span class="p">(</span><span class="n">framebuffer</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">]</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">UnsafeCell</span><span class="o">&lt;</span><span class="p">[</span><span class="kt">u8</span><span class="p">]</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="n">cache</span><span class="p">.</span><span class="n">access</span><span class="p">(</span><span class="n">uc</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">framebuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="k">u8</span><span class="p">;</span><span class="w"> </span><span class="mi">1920</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1080</span><span class="p">];</span><span class="w"></span>

<span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">feed_framebuffer</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">framebuffer</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>Ofc, this would work if the <code>framebuffer</code> was stored as an <code>UnsafeCell&lt;[u8]&gt;</code>, but this is not code that I have control of. Is this use case something Stacked Borrows could accommodate? If not, I will have to provide my own types for the slices, but that's annoying I will be simply duplicating slice code.</p>



<a name="271427259"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271427259" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dragoș Tiselice <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271427259">(Feb 10 2022 at 13:02)</a>:</h4>
<p>And, yes, I've noticed that too (<code>Sync</code> unsoundness), but I was more concerned about the general solution because of the issue above.</p>



<a name="271428446"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271428446" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271428446">(Feb 10 2022 at 13:13)</a>:</h4>
<p>Ah I see. The way Stacked Borrows works is that when you take out a "fresh" <code>&amp;mut</code> (i.e. not a reborrow) it invalidates all other pointers and references to the pointee. The <code>&amp;mut</code> then becomes the only exclusive reference to it.</p>



<a name="271428572"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271428572" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dragoș Tiselice <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271428572">(Feb 10 2022 at 13:14)</a>:</h4>
<p>Makes sense. I was under the impression that this is not the case. But I see the reasoning behind this. This does mean that the current design won't work, though. :(</p>



<a name="271428711"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271428711" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271428711">(Feb 10 2022 at 13:15)</a>:</h4>
<blockquote>
<p>E.g. there's a code that I don't own that serves &amp;mut every frame. If I simply covert those to &amp;UnsafeCell&lt;[T]&gt;, I'm just moving the problem to a different place, but the issue is still there since the pointer that ultimately ends up sent to access comes from a different &amp;mut.</p>
</blockquote>
<p>If there is a way to do all the work inside the loop, then this could still work. However, when the next <code>&amp;mut</code> comes around from the code you don't control, this means all prior pointers/references are now invalidated.</p>



<a name="271428807"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271428807" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dragoș Tiselice <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271428807">(Feb 10 2022 at 13:16)</a>:</h4>
<p>Exactly. And it will. There can be either Rust or C code that owns the framebuffer.</p>



<a name="271429074"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271429074" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271429074">(Feb 10 2022 at 13:18)</a>:</h4>
<p>If you find a way to make it work, I'd be curious to hear how you did it :)</p>



<a name="271429833"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271429833" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dragoș Tiselice <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271429833">(Feb 10 2022 at 13:24)</a>:</h4>
<p>I made a small example for the sake of completion: <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=211cb6c9f156f392f0a1c0a917357837">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=211cb6c9f156f392f0a1c0a917357837</a></p>



<a name="271430530"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271430530" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271430530">(Feb 10 2022 at 13:30)</a>:</h4>
<p>Ah yes, the only way to satisfy Stacked Borrows there is to not cache the pointer, unfortunately :) I recall this being a problem because of the size of the frame buffers that might be passed. How about storing the slice indices internally instead of raw pointers? Then you can recreate the slices from the cached indices without re-executing the closure.</p>



<a name="271430689"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271430689" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dragoș Tiselice <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271430689">(Feb 10 2022 at 13:31)</a>:</h4>
<p>I had tried this in the past and the performance difference was noticeable. Mostly because some algorithms using this split the buffer into quite a lot of sub-slices.</p>



<a name="271430774"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271430774" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dragoș Tiselice <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271430774">(Feb 10 2022 at 13:32)</a>:</h4>
<p>It could be worth re-doing the experiment.</p>



<a name="271430992"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271430992" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271430992">(Feb 10 2022 at 13:34)</a>:</h4>
<p>Was it doing slice index bounds checks in that earlier version? I'm not sure how much difference that would make, but it could alleviate the overhead by just a bit if it performs unchecked accesses to the slice.</p>



<a name="271431046"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271431046" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271431046">(Feb 10 2022 at 13:34)</a>:</h4>
<p>(if the slice has the same length, then it would be sound to unchecked slice accesses, because those were calculated by the closure before that)</p>



<a name="271431095"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271431095" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dragoș Tiselice <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271431095">(Feb 10 2022 at 13:35)</a>:</h4>
<p>I think the issue is simply that it performance <em>some</em> work on the sub-slices which is enough to make the difference. Lemme try to see what <a href="http://godbolt.org">godbolt.org</a> thinks.</p>



<a name="271431204"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271431204" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dragoș Tiselice <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271431204">(Feb 10 2022 at 13:35)</a>:</h4>
<p>That won't work since it will have to definitely offset the pointer. :')</p>



<a name="271431277"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271431277" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dragoș Tiselice <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271431277">(Feb 10 2022 at 13:36)</a>:</h4>
<p>So it's still O(sub-slices) work.</p>



<a name="271431350"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271431350" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271431350">(Feb 10 2022 at 13:37)</a>:</h4>
<p>Ah yes that won't be constant-time :)</p>



<a name="271431427"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271431427" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dragoș Tiselice <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271431427">(Feb 10 2022 at 13:37)</a>:</h4>
<p>For a 4K framebuffer, this is around ~500K additions, which is definitely noticeable.</p>



<a name="271431525"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271431525" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dragoș Tiselice <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271431525">(Feb 10 2022 at 13:38)</a>:</h4>
<p>This would probably be fine if it could somehow be delayed, but that won't work since you can only have one root <code>&amp;mut</code>.</p>



<a name="271431659"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271431659" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271431659">(Feb 10 2022 at 13:39)</a>:</h4>
<p>Another wild out-of-the-box idea: I'm guessing that the code you're not in charge of would not accept a PR that adds an option to work with <code>*mut</code> instead of <code>&amp;mut</code> in order to avoid pointer invalidations? :P</p>



<a name="271431822"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271431822" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dragoș Tiselice <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271431822">(Feb 10 2022 at 13:40)</a>:</h4>
<p>For all the current clients, that might be an option, but long-term it would be ideal to be flexible, I guess.</p>



<a name="271443627"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271443627" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dragoș Tiselice <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271443627">(Feb 10 2022 at 15:06)</a>:</h4>
<p>I have to say that I'm quite unhappy with trying to come up with a slice-like API for a <code>Slice&lt;'a&gt;</code> type. Any ideas how to make this more user-friendly?</p>



<a name="271443791"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271443791" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271443791">(Feb 10 2022 at 15:06)</a>:</h4>
<p>What API features should it have and how is it used?</p>



<a name="271446149"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271446149" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dragoș Tiselice <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271446149">(Feb 10 2022 at 15:21)</a>:</h4>
<p>Well, I would imagine users wanting to write with random access, iterate mutably, maybe even split more.</p>



<a name="271446203"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271446203" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dragoș Tiselice <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271446203">(Feb 10 2022 at 15:21)</a>:</h4>
<p><code>slice[x] = foo;</code> will never work, though.</p>



<a name="271447741"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271447741" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271447741">(Feb 10 2022 at 15:32)</a>:</h4>
<p>Would the users have a <code>&amp;mut Slice&lt;'a&gt;</code> at some point?</p>



<a name="271447871"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271447871" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271447871">(Feb 10 2022 at 15:33)</a>:</h4>
<p>(this would run into the same problems under Stacked Borrows if it's used in the same manner as from the previous examples, I believe. That's why I'm asking to learn more about how it's used :) )</p>



<a name="271449262"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271449262" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271449262">(Feb 10 2022 at 15:42)</a>:</h4>
<p>Could you share the struct definition for <code>Slice&lt;'a&gt;</code>?</p>



<a name="271454915"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271454915" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271454915">(Feb 10 2022 at 16:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="400735">Pointerbender</span> <a href="#narrow/stream/269128-miri/topic/Pointer.20caching/near/271348778">said</a>:</p>
<blockquote>
<p>Yes, on the playground it does, I think that has the <code>MIRIFLAGS="-Zmiri-track-raw-pointers"</code> flag turned on by default, but I'm not 100% sure.</p>
</blockquote>
<p>AFAIK it does not; and sadly the flag cannot be user-controlled either</p>



<a name="271455103"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271455103" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271455103">(Feb 10 2022 at 16:20)</a>:</h4>
<p>if someone wants to tackle <a href="https://github.com/integer32llc/rust-playground/issues/446">https://github.com/integer32llc/rust-playground/issues/446</a> that would be great :D</p>



<a name="271458540"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271458540" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dragoș Tiselice <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271458540">(Feb 10 2022 at 16:44)</a>:</h4>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">struct</span> <span class="nc">Slice</span><span class="o">&lt;'</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ptr</span>: <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">len</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">_phantom</span>: <span class="nc">PhantomData</span><span class="o">&lt;&amp;'</span><span class="na">a</span><span class="w"> </span><span class="p">()</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>This is what I've been thinking about. I'm also thinking about making it a write-only API since it'll have to deviate from slices too much anyway.</p>



<a name="271471717"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271471717" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271471717">(Feb 10 2022 at 18:14)</a>:</h4>
<p>You can use <code>ptr::NonNull&lt;T&gt;</code> for the <code>ptr</code> to get nice "packed" <code>Option&lt;Slice&gt;</code>s, but then make sure to be using <code>PhantomData&lt;&amp;'a mut [T]&gt;</code> as the <code>_phantom</code> field, since that's what your type represents, and otherwise you could fall into accidentally being covariant</p>



<a name="271548883"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271548883" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271548883">(Feb 11 2022 at 09:21)</a>:</h4>
<p><span class="user-mention" data-user-id="351014">@Dragoș Tiselice</span> I got something you might like :) <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=5fb76c27d514e82807df48c0cc40ed6a">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=5fb76c27d514e82807df48c0cc40ed6a</a></p>



<a name="271549256"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271549256" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271549256">(Feb 11 2022 at 09:24)</a>:</h4>
<p>There are a couple of tricks going on there.</p>
<p>1) The struct definition of <code>Slice</code> is:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Slice</span><span class="o">&lt;'</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">slice</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">a</span> <span class="nc">UnsafeCell</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>meaning that under Stacked Borrows, we can safely take out a <code>&amp;mut Slice&lt;T&gt;</code>, because asserting exclusive access to the <code>Slice</code> is not transitive to the pointee. In other words, a <code>&amp;mut Slice&lt;T&gt;</code> we can freely modify the <code>Slice</code> struct itself, but not  the memory location pointed to by the <code>slice</code> field. This ensures that the contents of the <code>UnsafeCell</code> retain their SharedReadWrite access, even when taking out a <code>&amp;mut Slice&lt;T&gt;</code>.</p>



<a name="271549416"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271549416" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271549416">(Feb 11 2022 at 09:26)</a>:</h4>
<p>In essence, <code>&amp;mut Slice&lt;T&gt;</code> is a "pointer to a pointer" (this indirection is vital to making this work under stacked borrows).</p>



<a name="271549690"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271549690" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271549690">(Feb 11 2022 at 09:28)</a>:</h4>
<p>2) I added a lifetime to the <code>CachedIncr</code>struct. Initially, this lifetime is unbounded, but it binds to the lifetime of <code>Slice&lt;'a, T&gt;</code> the first time the <code>incr</code> method is called.  This ensures that whenever a new <code>&amp;mut T</code> is given, it won't be possible to pass it to the same instance of <code>CachedIncr</code>, avoiding UB there (at this point, the end-user will just have to create a new <code>CachedIncr</code>).</p>



<a name="271549970"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271549970" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271549970">(Feb 11 2022 at 09:30)</a>:</h4>
<p>3) At the same time, the end-user can retain access to the original <code>&amp;mut T</code>, hopefully this will save you from having to write custom slice APIs. Once the end-user uses the <code>&amp;'a mut T</code> again, this will invalidate the <code>Slice&lt;'a, T&gt;</code> due to compiler lifetime rules.</p>



<a name="271550272"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271550272" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271550272">(Feb 11 2022 at 09:32)</a>:</h4>
<p>4) Since this is much closer to your original API and doesn't rely on the end-user passing around <code>&amp;UnsafeCell&lt;T&gt;</code> manually, this should also be sound w.r.t. <code>Sync</code> :)</p>



<a name="271551706"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271551706" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271551706">(Feb 11 2022 at 09:45)</a>:</h4>
<p>(all this does mean that the end-user needs a new <code>CachedIncr</code> instance on every iteration of "the loop", because the new <code>&amp;mut T</code> has a different lifetime, but this is what Stacked Borrows "demands" anyway, so on paper this matches what's needed, I just hope that's also good enough for your use case :) )</p>



<a name="271553040"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271553040" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pointerbender <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271553040">(Feb 11 2022 at 09:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/269128-miri/topic/Pointer.20caching/near/271454915">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="400735">Pointerbender</span> <a href="#narrow/stream/269128-miri/topic/Pointer.20caching/near/271348778">said</a>:</p>
<blockquote>
<p>Yes, on the playground it does, I think that has the <code>MIRIFLAGS="-Zmiri-track-raw-pointers"</code> flag turned on by default, but I'm not 100% sure.</p>
</blockquote>
<p>AFAIK it does not; and sadly the flag cannot be user-controlled either</p>
</blockquote>
<p>Thanks for that insight Ralf :) I'm starting a sabbatical in April, if nobody got around to it yet by then I might take a stab at adding it :D</p>



<a name="271584774"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271584774" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dragoș Tiselice <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271584774">(Feb 11 2022 at 14:33)</a>:</h4>
<p>Thanks a lot for the idea! I actually came up with something that seems to work quite well while working with different references and keeping the slice type: <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=8b61b653d3771101197b5c6837ad7838">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=8b61b653d3771101197b5c6837ad7838</a></p>



<a name="271585748"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/269128-miri/topic/Pointer%20caching/near/271585748" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dragoș Tiselice <a href="https://zulip-archive.rust-lang.org/stream/269128-miri/topic/Pointer.20caching.html#271585748">(Feb 11 2022 at 14:40)</a>:</h4>
<p>Ah, still seems to complain when run with <code>miri-tag-raw-pointers</code>.</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>