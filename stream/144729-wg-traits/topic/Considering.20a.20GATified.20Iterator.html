<html>
<head><meta charset="utf-8"><title>Considering a GATified Iterator · wg-traits · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/index.html">wg-traits</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/Considering.20a.20GATified.20Iterator.html">Considering a GATified Iterator</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="268342550"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/Considering%20a%20GATified%20Iterator/near/268342550" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/Considering.20a.20GATified.20Iterator.html#268342550">(Jan 18 2022 at 04:36)</a>:</h4>
<p>So, GATs get closer and clsoer to stabilization, I've started to think hard about how std will look like with GATs (see <a href="#narrow/stream/219381-t-libs/topic/APIs.20with.20GATs">https://rust-lang.zulipchat.com/#narrow/stream/219381-t-libs/topic/APIs.20with.20GATs</a>).</p>
<p>In particular, I'm interested in thinking about <code>Iterator</code>/<code>LendingIterator</code>. Essentially, I've been thinking: What is the most ergonomic way to integrate GATs into iterator-based APIs. A few examples: <code>for</code> loops, <code>FromIterator</code>, iterator adapters. One way that would be "easiest" would be to making a separate <code>LendingIterator</code> trait and a <code>impl&lt;I: Iterator&gt; LendingIterator for I {}</code>. But, the essentially splits the ecosystem around adapters and <code>FromIterator</code> (for loops could maybe change their desugaring). So a separate question: <em>Could we GATify <code>Iterator</code> somehow?</em> This has been brought up <a href="https://internals.rust-lang.org/t/pre-rfc-backward-compatible-gatification/15141/4">before</a>, but the conclusion was basically that wouldn't work.</p>
<p>Well, I want to get creative. Rather than say "this wouldn't work", I want to reframe this as "what would it take to make this work?" Particularly, is there any extension or modification to the current design of GATs that would allow it to work? What about other orthogonal language features? What if we <em>somehow</em> could prove lifetime bounds in some different way. Could this, in theory, be done in a backwards-compatible way (pre or post-GAT stabilization); if not, could it be done in an edition? What about trait objects? Currently, they're disallowed for GATs, so how does that factor in?</p>
<p>I don't think this is an easy problem to solve. But, like I said, I'd like to see some creative solutions. Really, "solving" this problem for <code>Iterator</code> means we could conceivably solve this for other traits, like <code>Deref</code>.</p>



<a name="268342584"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/Considering%20a%20GATified%20Iterator/near/268342584" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/Considering.20a.20GATified.20Iterator.html#268342584">(Jan 18 2022 at 04:37)</a>:</h4>
<p>To start, I'll elaborate some of my thoughts.</p>



<a name="268343439"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/Considering%20a%20GATified%20Iterator/near/268343439" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/Considering.20a.20GATified.20Iterator.html#268343439">(Jan 18 2022 at 04:55)</a>:</h4>
<p>So, let's start by imagining that <code>Iterator::Item</code> has a lifetime <code>'a</code>. What would this mean for some existing APIs? (Just a forewarning that I haven't thought these completely through)</p>



<a name="268347665"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/Considering%20a%20GATified%20Iterator/near/268347665" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/Considering.20a.20GATified.20Iterator.html#268347665">(Jan 18 2022 at 06:15)</a>:</h4>
<p>Let look at the <code>Iterator</code> trait</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">trait</span><span class="w"> </span><span class="nb">Iterator</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Item</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>vs <code>LendingIterator</code></p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">trait</span><span class="w"> </span><span class="n">LendingIterator</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Item</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="bp">Self</span>: <span class="o">'</span><span class="na">a</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">Item</span><span class="o">&lt;'</span><span class="nb">_</span><span class="o">&gt;&gt;</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>To be able "change" the former into the latter, we'll need some way to indicate that the lifetime on <code>Item</code> is unused, and therefore doesn't hold a borrow to <code>Self</code>. So, maybe the signature of <code>next</code> should be</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span> <span class="nf">next</span><span class="o">&lt;'</span><span class="na">out</span><span class="p">,</span><span class="w"> </span><span class="o">'</span><span class="na">in</span>: <span class="o">'</span><span class="na">out</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;'</span><span class="na">in</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">Item</span><span class="o">&lt;'</span><span class="na">out</span><span class="o">&gt;&gt;</span><span class="p">;</span><span class="w"></span>
</code></pre></div>
<p>But this isn't really what we want: the caller specifies the lifetimes here.<br>
To make things concrete, let's look at a specific impl:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">impl</span><span class="o">&lt;'</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">LendingIterator</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">std</span>::<span class="n">slice</span>::<span class="n">Iter</span><span class="o">&lt;'</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Item</span><span class="o">&lt;'</span><span class="na">x</span><span class="o">&gt;</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="bp">Self</span>: <span class="o">'</span><span class="na">x</span> <span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="bp">Self</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">Iterator</span><span class="o">&gt;</span>::<span class="n">Item</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">Item</span><span class="o">&lt;'</span><span class="nb">_</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nb">Iterator</span>::<span class="n">next</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>This works today, but the return type borrows from <code>Self</code>, so calling <code>LendingIterator::next(x)</code> is not the same <code>Iterator::next(x)</code>. This is normally what we want. But we need for a way for an impl to "opt-out" of this behavior.<br>
Let's also include a function that uses <code>Iterator</code> today</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span> <span class="nf">iterate</span><span class="o">&lt;'</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span>: <span class="o">'</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">I</span>: <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;'</span><span class="na">a</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">_i</span>: <span class="nc">I</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
</code></pre></div>
<p>We essentially need a way to say that "for any lifetime passed to <code>Item</code>, <code>I:Item</code> does not use it". How would you express this?<br>
<code>I: for&lt;'x&gt; Iterator&lt;Item&lt;'x&gt; = &amp;'a T&gt;</code> sort of works, because we see that <code>'x</code> isn't in the type. But that's a little weird - what if we <em>want</em> the normal <code>LendingIterator</code> behavior of a mutable borrow of <code>Self</code>? Is there ever a case would want that behavior? This only really works because we know that <code>T</code> can't name <code>'x</code>. For example if we had</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span> <span class="nf">iterate</span><span class="o">&lt;'</span><span class="na">x</span><span class="p">,</span><span class="w"> </span><span class="o">'</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span>: <span class="o">'</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">I</span>: <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&lt;'</span><span class="na">x</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;'</span><span class="na">a</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">_i</span>: <span class="nc">I</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
</code></pre></div>
<p>then this same behavior can't hold: <code>'x</code> might be in <code>T</code>.<br>
To my suprise (or maybe not, idk), this actually works right now:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span> <span class="nf">iter</span><span class="o">&lt;'</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span>: <span class="nc">core</span>::<span class="n">fmt</span>::<span class="n">Debug</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">'</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">I</span>: <span class="nc">for</span><span class="o">&lt;'</span><span class="na">x</span><span class="o">&gt;</span><span class="w"> </span><span class="n">LendingIterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&lt;'</span><span class="na">x</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;'</span><span class="na">a</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">_i</span>: <span class="nc">I</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_i</span><span class="p">.</span><span class="n">next</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_i</span><span class="p">.</span><span class="n">next</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="fm">dbg!</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="nb">drop</span><span class="p">(</span><span class="n">a</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="nb">drop</span><span class="p">(</span><span class="n">b</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>So, at least in the respect, if a lifetime param was added to <code>Iterator::Item</code>, we would only have to desugar <code>I: Iterator&lt;Item = T&gt;</code> to <code>I: for&lt;'x&gt; Iterator&lt;Item&lt;'x&gt; = T&gt;</code>.</p>
<p>But, next problem: <code>Iterator::collect</code>. The current signature looks like</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span> <span class="nf">collect</span><span class="o">&lt;</span><span class="n">B</span>: <span class="nc">FromIterator</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">Item</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">B</span><span class="w"></span>
<span class="k">where</span><span class="w"></span>
<span class="w">    </span><span class="bp">Self</span>: <span class="nb">Sized</span><span class="p">,</span><span class="w"></span>
</code></pre></div>
<p>So, I made a test trait, with the same "desugaring"</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">FromLendingIterator</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span>: <span class="nb">Sized</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">from_iter</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">for</span><span class="o">&lt;'</span><span class="na">x</span><span class="o">&gt;</span><span class="w"> </span><span class="n">LendingIterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&lt;'</span><span class="na">x</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">iter</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>and a GATified collect:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span> <span class="nf">collect</span><span class="o">&lt;</span><span class="n">B</span>: <span class="nc">for</span><span class="o">&lt;'</span><span class="na">x</span><span class="o">&gt;</span><span class="w"> </span><span class="n">FromLendingIterator</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">Item</span><span class="o">&lt;'</span><span class="na">x</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">B</span><span class="w"></span>
<span class="w">    </span><span class="k">where</span><span class="w"></span>
<span class="w">    </span><span class="bp">Self</span>: <span class="nb">Sized</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">FromLendingIterator</span>::<span class="n">from_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>This, unfortunately, errors:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">error</span><span class="p">[</span><span class="n">E0308</span><span class="p">]</span>: <span class="nc">mismatched</span><span class="w"> </span><span class="n">types</span><span class="w"></span>
<span class="w">  </span><span class="o">-</span>-&gt; <span class="nc">src</span><span class="o">/</span><span class="n">main</span><span class="p">.</span><span class="n">rs</span>:<span class="mi">14</span>:<span class="mi">9</span><span class="w"></span>
<span class="w">   </span><span class="o">|</span><span class="w"></span>
<span class="mi">14</span><span class="w"> </span><span class="o">|</span><span class="w">         </span><span class="n">FromLendingIterator</span>::<span class="n">from_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="o">|</span><span class="w">         </span><span class="o">^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><span class="w"> </span><span class="n">lifetime</span><span class="w"> </span><span class="n">mismatch</span><span class="w"></span>
<span class="w">   </span><span class="o">|</span><span class="w"></span>
<span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">note</span>: <span class="nc">expected</span><span class="w"> </span><span class="n">associated</span><span class="w"> </span><span class="k">type</span> <span class="err">`</span><span class="o">&lt;</span><span class="bp">Self</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">LendingIterator</span><span class="o">&gt;</span>::<span class="n">Item</span><span class="o">&lt;'</span><span class="na">x</span><span class="o">&gt;</span><span class="err">`</span><span class="w"></span>
<span class="w">                         </span><span class="n">found</span><span class="w"> </span><span class="k">type</span> <span class="err">`</span><span class="o">&lt;</span><span class="bp">Self</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">LendingIterator</span><span class="o">&gt;</span>::<span class="n">Item</span><span class="o">&lt;'</span><span class="nb">_</span><span class="o">&gt;</span><span class="err">`</span><span class="w"></span>
</code></pre></div>
<p>But that might be fixable bug.</p>



<a name="269112215"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/Considering%20a%20GATified%20Iterator/near/269112215" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nikomatsakis <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/Considering.20a.20GATified.20Iterator.html#269112215">(Jan 24 2022 at 14:22)</a>:</h4>
<p>So, a few thoughts:</p>
<ul>
<li>The prime challenge is that iterators and lending iterators aren't equivalent from the user's point-of-view.</li>
<li>Given a lending iterator, values can't cross for loop iterations, in short, unless you already know their type.</li>
</ul>
<p>So I think the first question is what kinds of code we would like people to be able to write...</p>
<p>...I think <em>probably</em> the ideal is that "if the data crosses for loop iterations, you get some kind of error if that doesn't work"</p>



<a name="269137918"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/Considering%20a%20GATified%20Iterator/near/269137918" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/Considering.20a.20GATified.20Iterator.html#269137918">(Jan 24 2022 at 17:13)</a>:</h4>
<p>Okay, for those following along: the next step here is probably to come up with some "user stories" for how we might expect people to use LendingIterator or a GATified Iterator (<a href="https://github.com/rust-lang/generic-associated-types-initiative/issues/1">https://github.com/rust-lang/generic-associated-types-initiative/issues/1</a>). We need to update the repo to have a place for them, but if you have some thoughts, please feel free to file an issue there, and I'll make sure it gets included. (Also welcome examples of other traits too, like Deref)</p>



<a name="271716809"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/Considering%20a%20GATified%20Iterator/near/271716809" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/Considering.20a.20GATified.20Iterator.html#271716809">(Feb 13 2022 at 00:01)</a>:</h4>
<p>So, I was trying to play with what a <code>FromIterator</code> would look like with a GATified <code>Iterator</code>:  <a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=2387f62342b52c091dc7e756c4a23359">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=2387f62342b52c091dc7e756c4a23359</a></p>



<a name="271716879"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/Considering%20a%20GATified%20Iterator/near/271716879" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/Considering.20a.20GATified.20Iterator.html#271716879">(Feb 13 2022 at 00:03)</a>:</h4>
<p>Here, I'm just imagining that <code>for&lt;'x&gt; LendingIterator&lt;Item&lt;'x&gt; = A&gt;</code> would be "generated" if the user wrote <code>LendingIterator&lt;Item = A&gt;</code></p>



<a name="271716931"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/Considering%20a%20GATified%20Iterator/near/271716931" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/Considering.20a.20GATified.20Iterator.html#271716931">(Feb 13 2022 at 00:04)</a>:</h4>
<p>This doesn't compile as-is right now</p>



<a name="271716936"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/Considering%20a%20GATified%20Iterator/near/271716936" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/Considering.20a.20GATified.20Iterator.html#271716936">(Feb 13 2022 at 00:04)</a>:</h4>
<p>For seemingly two separate reasons</p>



<a name="271716976"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/Considering%20a%20GATified%20Iterator/near/271716976" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/Considering.20a.20GATified.20Iterator.html#271716976">(Feb 13 2022 at 00:05)</a>:</h4>
<p>First, when we compare the impl against the trait, we have to check that, knowing the bounds from the trait method, we can prove that the bounds on the impl method hold</p>



<a name="271716982"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/Considering%20a%20GATified%20Iterator/near/271716982" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/Considering.20a.20GATified.20Iterator.html#271716982">(Feb 13 2022 at 00:05)</a>:</h4>
<p>namely <code>I: for&lt;'x&gt; LendingIterator&lt;Item&lt;'x&gt; = A&gt;</code></p>



<a name="271717052"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/Considering%20a%20GATified%20Iterator/near/271717052" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/Considering.20a.20GATified.20Iterator.html#271717052">(Feb 13 2022 at 00:07)</a>:</h4>
<p>However, long story short, when proving this, we normalize <code>for&lt;'x&gt; &lt;I as LendingIterator&gt;::Item&lt;'x&gt;</code>, which requires that <code>I: 'x</code>, for some <code>'x</code> as a placeholder</p>



<a name="271717207"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/Considering%20a%20GATified%20Iterator/near/271717207" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/Considering.20a.20GATified.20Iterator.html#271717207">(Feb 13 2022 at 00:11)</a>:</h4>
<p>There's an open issue (I think) for GATs somewhere that covers this scenario. Basically, we need to be better about knowing that the normalization <em>here</em>, we don't really care about <code>'x</code>, because we know that when we use this method, we require that <code>I: 'x</code> for the lifetime we pick for <code>'x</code></p>



<a name="271717370"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/Considering%20a%20GATified%20Iterator/near/271717370" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/Considering.20a.20GATified.20Iterator.html#271717370">(Feb 13 2022 at 00:15)</a>:</h4>
<p>I guess <a href="https://github.com/rust-lang/rust/issues/90573">#90573</a> is the issue I'm thinking of</p>



<a name="271717426"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/Considering%20a%20GATified%20Iterator/near/271717426" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/Considering.20a.20GATified.20Iterator.html#271717426">(Feb 13 2022 at 00:16)</a>:</h4>
<p>In particular, <a href="https://users.rust-lang.org/t/gats-and-hrtb-confusion/66830/4">this comment</a> does a great job of explaining it</p>



<a name="271717433"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/Considering%20a%20GATified%20Iterator/near/271717433" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/Considering.20a.20GATified.20Iterator.html#271717433">(Feb 13 2022 at 00:16)</a>:</h4>
<p>(I realize I think I wrote the wrong explanation on the issue)</p>



<a name="271717500"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/Considering%20a%20GATified%20Iterator/near/271717500" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/Considering.20a.20GATified.20Iterator.html#271717500">(Feb 13 2022 at 00:18)</a>:</h4>
<p>The second issue with this example is</p>
<div class="codehilite"><pre><span></span><code>note: expected associated type `&lt;Self as LendingIterator&gt;::Item&lt;&#39;x&gt;`
              found associated type `&lt;Self as LendingIterator&gt;::Item&lt;&#39;_&gt;`
</code></pre></div>
<p>which seems very similar to other associated type bugs that I've seen - but I  haven't investigated that</p>



<a name="271894801"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/Considering%20a%20GATified%20Iterator/near/271894801" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nikomatsakis <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/Considering.20a.20GATified.20Iterator.html#271894801">(Feb 14 2022 at 21:54)</a>:</h4>
<p><a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=6b4637cc023c8107560e2aadd44da0ae">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=6b4637cc023c8107560e2aadd44da0ae</a> &lt;-- so, the first problem you can do with <code>'static</code>, the second is that we don't have required where clause to say that "no matter what lifetime produced by Item, we get same result"</p>



<a name="272011755"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/Considering%20a%20GATified%20Iterator/near/272011755" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/Considering.20a.20GATified.20Iterator.html#272011755">(Feb 15 2022 at 17:49)</a>:</h4>
<p>So, to expand on what we found yesterday a bit: the first issue can be solved with a <code>'static</code> bound on <code>LendingIterator</code> (<a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=06771e6c633fb44eecf4bc4cf697f577">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=06771e6c633fb44eecf4bc4cf697f577</a>). The second issue (with collect) can be changed with a bit of modification to the function signature (in Niko's playground link)</p>



<a name="272029117"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/Considering%20a%20GATified%20Iterator/near/272029117" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nikomatsakis <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/Considering.20a.20GATified.20Iterator.html#272029117">(Feb 15 2022 at 19:54)</a>:</h4>
<p>Not strictly related, but <a href="https://github.com/rust-lang/rust/issues/93203#issuecomment-1040720703">this deep dive into scoped threads</a> turned up an interesting conclusion.</p>



<a name="272029145"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/Considering%20a%20GATified%20Iterator/near/272029145" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nikomatsakis <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/Considering.20a.20GATified.20Iterator.html#272029145">(Feb 15 2022 at 19:55)</a>:</h4>
<p>In short, the ability to have a more ergonomic API turns out to be gated on richer HRTB (e.g., implication goals)</p>



<a name="272029311"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/Considering%20a%20GATified%20Iterator/near/272029311" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/Considering.20a.20GATified.20Iterator.html#272029311">(Feb 15 2022 at 19:56)</a>:</h4>
<blockquote>
<p>If you insist, but remember that you asked for it.</p>
</blockquote>
<p>These are the best</p>



<a name="272029478"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/Considering%20a%20GATified%20Iterator/near/272029478" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/Considering.20a.20GATified.20Iterator.html#272029478">(Feb 15 2022 at 19:57)</a>:</h4>
<p>I was thinking a bit too. The issue here isn't just lifetimes: if we had <code>I: for&lt;X&gt; Foo&lt;Item&lt;X&gt; = A&gt;</code>, and there was some like <code>where X: Iterator</code> bound on <code>Item</code>, then we would get an error about <code>X: Iterator</code> not being provable</p>



<a name="272029593"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/Considering%20a%20GATified%20Iterator/near/272029593" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/Considering.20a.20GATified.20Iterator.html#272029593">(Feb 15 2022 at 19:58)</a>:</h4>
<p>We would either need to <em>imply</em> that <code>X: Iterator</code> hold here or have some way to write <code>for&lt;X: Iterator&gt;</code></p>



<a name="272030140"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/Considering%20a%20GATified%20Iterator/near/272030140" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/Considering.20a.20GATified.20Iterator.html#272030140">(Feb 15 2022 at 20:01)</a>:</h4>
<p><span class="user-mention silent" data-user-id="116009">nikomatsakis</span> <a href="#narrow/stream/144729-wg-traits/topic/Considering.20a.20GATified.20Iterator/near/272029145">said</a>:</p>
<blockquote>
<p>In short, the ability to have a more ergonomic API turns out to be gated on richer HRTB (e.g., implication goals)</p>
</blockquote>
<p>maybe because I've only skimmed this, but I don't necessarily see the relation?</p>



<a name="272134734"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/Considering%20a%20GATified%20Iterator/near/272134734" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/Considering.20a.20GATified.20Iterator.html#272134734">(Feb 16 2022 at 15:57)</a>:</h4>
<p>This is the non-lifetime case: <a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=129c544fe99596c4388c3429df1124e5">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=129c544fe99596c4388c3429df1124e5</a></p>



<a name="272134857"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/Considering%20a%20GATified%20Iterator/near/272134857" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/Considering.20a.20GATified.20Iterator.html#272134857">(Feb 16 2022 at 15:58)</a>:</h4>
<p>And an example of why using that kind of scheme (lifetime on the function instead of <code>for&lt;'x&gt;</code> doesn't work: <a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=552f9f34e4823b647c503203537a1fbc">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=552f9f34e4823b647c503203537a1fbc</a></p>



<a name="272149901"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/Considering%20a%20GATified%20Iterator/near/272149901" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/Considering.20a.20GATified.20Iterator.html#272149901">(Feb 16 2022 at 17:36)</a>:</h4>
<p>I think we need implied binds that essentially amounts to <code>fn from_iter&lt;T: for&lt;'x where WF(LendingIterator&lt;Item&lt;'x&gt; = A&gt;)&gt; LendingIterator&lt;Item&lt;'x&gt; = A&gt;&gt;(mut iter: I) -&gt; Self;</code></p>



<a name="272150030"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/Considering%20a%20GATified%20Iterator/near/272150030" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/Considering.20a.20GATified.20Iterator.html#272150030">(Feb 16 2022 at 17:37)</a>:</h4>
<p>Because I don't think we can necessarily treat <code>LendingIterator&lt;Item&lt;'x&gt; = A&gt;</code> as WF always</p>



<a name="272150125"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/Considering%20a%20GATified%20Iterator/near/272150125" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/Considering.20a.20GATified.20Iterator.html#272150125">(Feb 16 2022 at 17:37)</a>:</h4>
<p>because maybe there's a <code>where &lt;Self as LendingIterator&gt;::Item: Foo</code> bound; we would then have to check that <code>A: Foo</code>, not just treat it as WF</p>



<a name="272150400"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/Considering%20a%20GATified%20Iterator/near/272150400" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/Considering.20a.20GATified.20Iterator.html#272150400">(Feb 16 2022 at 17:39)</a>:</h4>
<p>but what if there was something like <code>trait Trait&lt;U&gt; { type Assoc&lt;T&gt; where Option&lt;(T, U)&gt;: Foo; }</code></p>



<a name="272150633"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/Considering%20a%20GATified%20Iterator/near/272150633" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/Considering.20a.20GATified.20Iterator.html#272150633">(Feb 16 2022 at 17:41)</a>:</h4>
<p>If we then had <code>T: for&lt;X, Y&gt; Trait&lt;X, Assoc&lt;Y&gt; = ()&gt;</code>, what are the implied bounds on <code>X</code> and <code>Y</code>?</p>



<a name="272150961"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/Considering%20a%20GATified%20Iterator/near/272150961" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/Considering.20a.20GATified.20Iterator.html#272150961">(Feb 16 2022 at 17:43)</a>:</h4>
<p>or, better example <code>&lt;X, T: for&lt;Y&gt; Trait&lt;X, Assoc&lt;Y&gt; = ()&gt;&gt;</code></p>



<a name="272151099"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/Considering%20a%20GATified%20Iterator/near/272151099" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/Considering.20a.20GATified.20Iterator.html#272151099">(Feb 16 2022 at 17:44)</a>:</h4>
<p>do we need a where clause on the function: <code>where for&lt;Y&gt; Option&lt;(X, Y)&gt;: Foo</code>?</p>



<a name="272151185"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/Considering%20a%20GATified%20Iterator/near/272151185" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/Considering.20a.20GATified.20Iterator.html#272151185">(Feb 16 2022 at 17:44)</a>:</h4>
<p>And in both cases it's implied that it's <code>for&lt;Y where Option&lt;(X, Y)&gt;: Foo&gt;</code></p>



<a name="272530571"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/Considering%20a%20GATified%20Iterator/near/272530571" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/Considering.20a.20GATified.20Iterator.html#272530571">(Feb 19 2022 at 17:22)</a>:</h4>
<p>This is what I mean: <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=fc8e420591a297e757b2853987d59b44">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=fc8e420591a297e757b2853987d59b44</a></p>



<a name="272530646"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/Considering%20a%20GATified%20Iterator/near/272530646" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/Considering.20a.20GATified.20Iterator.html#272530646">(Feb 19 2022 at 17:24)</a>:</h4>
<p>Also seeing <a href="https://github.com/rust-lang/chalk/blob/662706f0e27722386f77d694fe8602b16be010f9/chalk-solve/src/wf.rs#L209">this</a> and thinking about what it would mean for <em>everything</em> to be "lazy"</p>



<a name="273574510"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/Considering%20a%20GATified%20Iterator/near/273574510" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nikomatsakis <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/Considering.20a.20GATified.20Iterator.html#273574510">(Mar 01 2022 at 00:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="232957">Jack Huey</span> <a href="#narrow/stream/144729-wg-traits/topic/Considering.20a.20GATified.20Iterator/near/272029593">said</a>:</p>
<blockquote>
<p>We would either need to <em>imply</em> that <code>X: Iterator</code> hold here or have some way to write <code>for&lt;X: Iterator&gt;</code></p>
</blockquote>
<p>this seems right. I'd be inclined to do the implication---</p>



<a name="273576872"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/Considering%20a%20GATified%20Iterator/near/273576872" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/Considering.20a.20GATified.20Iterator.html#273576872">(Mar 01 2022 at 00:52)</a>:</h4>
<p>For this, probably</p>



<a name="274311195"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/Considering%20a%20GATified%20Iterator/near/274311195" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> marmeladema <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/Considering.20a.20GATified.20Iterator.html#274311195">(Mar 06 2022 at 15:20)</a>:</h4>
<p>Would GAT-ified iterator requires extension to GAT that could be backward incompatible with current GAT design and therefore postpone stabilization of GAT?</p>



<a name="274312196"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/Considering%20a%20GATified%20Iterator/near/274312196" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/Considering.20a.20GATified.20Iterator.html#274312196">(Mar 06 2022 at 15:42)</a>:</h4>
<p>Working on that. I think the answer is no, but still have to work through some things.</p>



<a name="275063804"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/Considering%20a%20GATified%20Iterator/near/275063804" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/Considering.20a.20GATified.20Iterator.html#275063804">(Mar 11 2022 at 23:53)</a>:</h4>
<p>I made a <code>generic_associated_types_extended</code> feature, which (currently) ignores obligations generated in <code>poly_project_and_unify_type</code> that reference new placeholders (with the <em>idea</em> being that they get checked later with a concrete lifetime) <a href="https://github.com/rust-lang/rust/issues/94869">#94869</a></p>



<a name="275063808"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/Considering%20a%20GATified%20Iterator/near/275063808" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/Considering.20a.20GATified.20Iterator.html#275063808">(Mar 11 2022 at 23:53)</a>:</h4>
<p><span class="user-mention" data-user-id="116009">@nikomatsakis</span></p>



<a name="275063816"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/Considering%20a%20GATified%20Iterator/near/275063816" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/Considering.20a.20GATified.20Iterator.html#275063816">(Mar 11 2022 at 23:53)</a>:</h4>
<p><span class="user-mention" data-user-id="426609">@Michael Goulet (compiler-errors)</span></p>



<a name="275063880"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/Considering%20a%20GATified%20Iterator/near/275063880" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/Considering.20a.20GATified.20Iterator.html#275063880">(Mar 11 2022 at 23:54)</a>:</h4>
<p>This alone is enough to make the <code>LendingIterator</code> <code>FromIterator</code> example work</p>



<a name="275162220"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/Considering%20a%20GATified%20Iterator/near/275162220" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/Considering.20a.20GATified.20Iterator.html#275162220">(Mar 13 2022 at 16:15)</a>:</h4>
<p>"Object-safe" GATs under <code>generic_associated_type_extended</code> feature: <a href="https://github.com/rust-lang/rust/issues/94911">#94911</a></p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>