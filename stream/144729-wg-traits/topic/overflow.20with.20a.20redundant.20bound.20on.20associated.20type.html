<html>
<head><meta charset="utf-8"><title>overflow with a redundant bound on associated type · wg-traits · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/index.html">wg-traits</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/overflow.20with.20a.20redundant.20bound.20on.20associated.20type.html">overflow with a redundant bound on associated type</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="272829241"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/overflow%20with%20a%20redundant%20bound%20on%20associated%20type/near/272829241" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake Goulding <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/overflow.20with.20a.20redundant.20bound.20on.20associated.20type.html#272829241">(Feb 22 2022 at 16:34)</a>:</h4>
<p>Working on answering <a href="https://stackoverflow.com/q/71210295/155423">Why does a trait bound of an associated type cause an evaluation overflow when the bound is guaranteed to always hold?</a>.</p>
<p>If you uncomment the <code>S::Expr: Clone</code> bound, you get an overflow error.</p>
<p>My reasoning for that is that the trait system isn't smart enough to see that <code>S: Schema</code> implies <code>S::Expr: Clone</code> when checking <code>Clone</code> for <code>ParserSchema::Expr</code>. Instead, it gets stuck in a loop </p>
<p>When it's computing <code>impl&lt;S&gt; Clone for Expr&lt;S&gt;</code> without the bound on the associated type, no loop is needed as it can terminate and say "so long as <code>S</code> implements <code>Schema</code>". Proving that can be a separate check later, not part of a cycle.</p>
<p>Am I missing any key points?</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">Schema</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Expr</span>: <span class="nb">Clone</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Wrapper</span><span class="o">&lt;</span><span class="n">S</span>: <span class="nc">Schema</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">f</span>: <span class="nb">Box</span><span class="o">&lt;</span><span class="n">S</span>::<span class="n">Expr</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Clone</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Wrapper</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">where</span><span class="w"></span>
<span class="w">    </span><span class="n">S</span>: <span class="nc">Schema</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="c1">// S::Expr: Clone, // overflow evaluating the requirement `Wrapper&lt;ParserSchema&gt;: Clone`</span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">f</span>: <span class="nc">self</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">clone</span><span class="p">()</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cp">#[derive(Clone)]</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">ParserSchema</span><span class="p">;</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">Schema</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">ParserSchema</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Expr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Wrapper</span><span class="o">&lt;</span><span class="n">ParserSchema</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>



<a name="272833309"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/overflow%20with%20a%20redundant%20bound%20on%20associated%20type/near/272833309" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/overflow.20with.20a.20redundant.20bound.20on.20associated.20type.html#272833309">(Feb 22 2022 at 16:59)</a>:</h4>
<p><code>Wrapper&lt;ParserSchema&gt;: Clone</code> requires that <code>&lt;ParserSchema as Schema&gt;::Expr: Clone</code>, which is just <code>Wrapper&lt;ParserSchema&gt;: Clone</code></p>



<a name="272833440"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/overflow%20with%20a%20redundant%20bound%20on%20associated%20type/near/272833440" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/overflow.20with.20a.20redundant.20bound.20on.20associated.20type.html#272833440">(Feb 22 2022 at 17:00)</a>:</h4>
<p>There's no coinduction here</p>



<a name="272833460"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/overflow%20with%20a%20redundant%20bound%20on%20associated%20type/near/272833460" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/overflow.20with.20a.20redundant.20bound.20on.20associated.20type.html#272833460">(Feb 22 2022 at 17:00)</a>:</h4>
<p>So it's just a cycle</p>



<a name="272834096"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/overflow%20with%20a%20redundant%20bound%20on%20associated%20type/near/272834096" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/overflow.20with.20a.20redundant.20bound.20on.20associated.20type.html#272834096">(Feb 22 2022 at 17:04)</a>:</h4>
<p>notably, this isn't a <em>generic</em> check</p>



<a name="272834136"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/overflow%20with%20a%20redundant%20bound%20on%20associated%20type/near/272834136" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/overflow.20with.20a.20redundant.20bound.20on.20associated.20type.html#272834136">(Feb 22 2022 at 17:04)</a>:</h4>
<blockquote>
<p>Proving that can be a separate check later, not part of a cycle.</p>
</blockquote>
<p>That is in fact what we're doing</p>



<a name="272834192"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/overflow%20with%20a%20redundant%20bound%20on%20associated%20type/near/272834192" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/overflow.20with.20a.20redundant.20bound.20on.20associated.20type.html#272834192">(Feb 22 2022 at 17:04)</a>:</h4>
<p>we're checking that <code>Wrapper&lt;ParserSchema&gt;</code> fulfills the bounds on <code>Schema::Expr</code></p>



<a name="272842885"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/overflow%20with%20a%20redundant%20bound%20on%20associated%20type/near/272842885" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake Goulding <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/overflow.20with.20a.20redundant.20bound.20on.20associated.20type.html#272842885">(Feb 22 2022 at 18:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="232957">Jack Huey</span> <a href="#narrow/stream/144729-wg-traits/topic/overflow.20with.20a.20redundant.20bound.20on.20associated.20type/near/272833440">said</a>:</p>
<blockquote>
<p>There's no coinduction here</p>
</blockquote>
<p>I'm not clear; did something I state indicate that there was? I don't even know what "coinduction" means, so I don't think I intended to mean that.</p>
<p><span class="user-mention silent" data-user-id="232957">Jack Huey</span> <a href="#narrow/stream/144729-wg-traits/topic/overflow.20with.20a.20redundant.20bound.20on.20associated.20type/near/272834136">said</a>:</p>
<blockquote>
<p>That is in fact what we're doing</p>
</blockquote>
<p>I'm not following; are you agreeing with me or correcting me?</p>



<a name="272843643"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/overflow%20with%20a%20redundant%20bound%20on%20associated%20type/near/272843643" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Michael Goulet (compiler-errors) <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/overflow.20with.20a.20redundant.20bound.20on.20associated.20type.html#272843643">(Feb 22 2022 at 18:09)</a>:</h4>
<p>(I think, in context) "coinduction" means that the trait bound is allowed to be self-proving. There's a cycle here, because when we need to prove that <code>Wrapper&lt;ParserSchema&gt;: Clone</code> by proving <code>Wrapper&lt;ParserSchema&gt;: Clone</code>, we can't.</p>



<a name="272843743"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/overflow%20with%20a%20redundant%20bound%20on%20associated%20type/near/272843743" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Michael Goulet (compiler-errors) <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/overflow.20with.20a.20redundant.20bound.20on.20associated.20type.html#272843743">(Feb 22 2022 at 18:10)</a>:</h4>
<p>This is in comparison to other traits, like <code>Send</code>, that can circularly depend on themselves being <code>Send</code> for the bound to be satisfied (at least afaik).</p>



<a name="272843801"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/overflow%20with%20a%20redundant%20bound%20on%20associated%20type/near/272843801" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake Goulding <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/overflow.20with.20a.20redundant.20bound.20on.20associated.20type.html#272843801">(Feb 22 2022 at 18:10)</a>:</h4>
<p>Let me try to start from the top...</p>
<p>When the compiler sees <code>impl Schema for ParserSchema</code>, it makes sure that <code>&lt;Schema as ParserSchema&gt;::Expr: Clone</code>. </p>
<p>When we have</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Clone</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Wrapper</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">where</span><span class="w"></span>
<span class="w">    </span><span class="n">S</span>: <span class="nc">Schema</span><span class="p">,</span><span class="w"></span>
</code></pre></div>
<p>then the check can stop and say "yes, so long as <code>S: Schema</code>". It doesn't need to re-check that <code>&lt;S as Schema&gt;::Expr: Clone</code>.</p>
<p>However, with </p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Clone</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Wrapper</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">where</span><span class="w"></span>
<span class="w">    </span><span class="n">S</span>: <span class="nc">Schema</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">S</span>::<span class="n">Expr</span>: <span class="nb">Clone</span><span class="p">,</span><span class="w"></span>
</code></pre></div>
<p>it <strong>does</strong> re-check <code>&lt;S as Schema&gt;::Expr: Clone</code>, which is what leads to the loop.</p>
<p>A Sufficiently Advanced Compiler could see that <code>Schema</code> already enforces that and the two pieces of code could have the same behavior.</p>



<a name="272843966"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/overflow%20with%20a%20redundant%20bound%20on%20associated%20type/near/272843966" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake Goulding <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/overflow.20with.20a.20redundant.20bound.20on.20associated.20type.html#272843966">(Feb 22 2022 at 18:12)</a>:</h4>
<p>Like, I get that with the bound on the associated type we get a loop and even a bit why.</p>



<a name="272844108"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/overflow%20with%20a%20redundant%20bound%20on%20associated%20type/near/272844108" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake Goulding <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/overflow.20with.20a.20redundant.20bound.20on.20associated.20type.html#272844108">(Feb 22 2022 at 18:13)</a>:</h4>
<p>but based on the definition of <code>Schema</code>, <code>S: Schema</code> implies <code>S::Expr: Clone</code>, so from the outside it seems odd that one form is allowed and the other isn't.</p>



<a name="272844142"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/overflow%20with%20a%20redundant%20bound%20on%20associated%20type/near/272844142" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake Goulding <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/overflow.20with.20a.20redundant.20bound.20on.20associated.20type.html#272844142">(Feb 22 2022 at 18:13)</a>:</h4>
<p>I'm assuming that the difference boils down to an implementation trade-off.</p>



<a name="272844639"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/overflow%20with%20a%20redundant%20bound%20on%20associated%20type/near/272844639" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Michael Goulet (compiler-errors) <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/overflow.20with.20a.20redundant.20bound.20on.20associated.20type.html#272844639">(Feb 22 2022 at 18:16)</a>:</h4>
<p>So the cycle begins when we start to check <code>impl Schema for ParserSchema</code>. We need to enforce that <code>&lt;ParserSchema as Schema&gt;::Expr</code> is <code>Clone</code> for that <code>impl</code> to be happy. But we know what the exact concrete type for <code>&lt;ParserSchema as Schema&gt;::Expr</code> is, so we _actually_ check if <code>Wrapper&lt;ParserSchema&gt;: Clone</code>. When we _exclude_ that commented-out bound on <code>impl Clone for Wrapper&lt;S&gt;</code>, then the only nested bound we need to check is <code>S: Schema</code>. That's fine, because we know that <code>ParserSchema: Schema</code> with no extra requirements to check. However, when we have that <code>&lt;S as  Schema&gt;::Expr: Clone</code> bound, we substitute <code>S = ParserSchema</code> and then normalize the type, getting <code>Wrapper&lt;ParserSchema&gt;: Clone</code>. That's a cycle.</p>



<a name="272844859"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/overflow%20with%20a%20redundant%20bound%20on%20associated%20type/near/272844859" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake Goulding <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/overflow.20with.20a.20redundant.20bound.20on.20associated.20type.html#272844859">(Feb 22 2022 at 18:18)</a>:</h4>
<p>Yes</p>



<a name="272844919"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/overflow%20with%20a%20redundant%20bound%20on%20associated%20type/near/272844919" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Michael Goulet (compiler-errors) <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/overflow.20with.20a.20redundant.20bound.20on.20associated.20type.html#272844919">(Feb 22 2022 at 18:18)</a>:</h4>
<p>The fact that we substitute the <code>&lt;S as Schema&gt;::Expr</code> when <code>S = ParserSchema</code> and then compute the real type of the assoc is what makes us have a cycle, I think, because once we turn that cyclical bound from <code>&lt;ParserSchema as Schema&gt;::Expr: Clone</code> into <code>Wrapper&lt;ParserSchema&gt;: Clone</code>, then we can no longer (easily) apply the fact that we know that any <code>&lt;_ as Schema&gt;::Expr</code> is <code>Clone</code>.</p>



<a name="272844958"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/overflow%20with%20a%20redundant%20bound%20on%20associated%20type/near/272844958" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Michael Goulet (compiler-errors) <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/overflow.20with.20a.20redundant.20bound.20on.20associated.20type.html#272844958">(Feb 22 2022 at 18:18)</a>:</h4>
<p>(since applying that known fact requires the LHS of the trait bound to be an associated type)</p>



<a name="272845083"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/overflow%20with%20a%20redundant%20bound%20on%20associated%20type/near/272845083" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake Goulding <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/overflow.20with.20a.20redundant.20bound.20on.20associated.20type.html#272845083">(Feb 22 2022 at 18:19)</a>:</h4>
<p>But that  Sufficiently Advanced Compiler could see that we don't <em>need</em> to check <code>S::Expr: Clone</code> /  substitute <code>S = ParserSchema</code> because it's implied by the definition of <code>Schema</code>.</p>



<a name="272845229"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/overflow%20with%20a%20redundant%20bound%20on%20associated%20type/near/272845229" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake Goulding <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/overflow.20with.20a.20redundant.20bound.20on.20associated.20type.html#272845229">(Feb 22 2022 at 18:20)</a>:</h4>
<p>(note that I'm not claiming that a SAC is easy to implement, by any means <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span>)</p>



<a name="272845384"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/overflow%20with%20a%20redundant%20bound%20on%20associated%20type/near/272845384" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Michael Goulet (compiler-errors) <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/overflow.20with.20a.20redundant.20bound.20on.20associated.20type.html#272845384">(Feb 22 2022 at 18:21)</a>:</h4>
<p>Sure, I could see it might be able to filter out implied impl bounds that are possible to prove before doing any substitutions, and then only substitute and check the bounds that are remaining.</p>



<a name="272845439"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/overflow%20with%20a%20redundant%20bound%20on%20associated%20type/near/272845439" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Michael Goulet (compiler-errors) <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/overflow.20with.20a.20redundant.20bound.20on.20associated.20type.html#272845439">(Feb 22 2022 at 18:22)</a>:</h4>
<p>(thus filtering that commented out bound in the example)</p>



<a name="272845607"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/overflow%20with%20a%20redundant%20bound%20on%20associated%20type/near/272845607" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Michael Goulet (compiler-errors) <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/overflow.20with.20a.20redundant.20bound.20on.20associated.20type.html#272845607">(Feb 22 2022 at 18:23)</a>:</h4>
<p>would perhaps also be solved if we had lazy projection normalization :^)</p>



<a name="272848100"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/overflow%20with%20a%20redundant%20bound%20on%20associated%20type/near/272848100" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake Goulding <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/overflow.20with.20a.20redundant.20bound.20on.20associated.20type.html#272848100">(Feb 22 2022 at 18:40)</a>:</h4>
<p>Isn't everything solved by that?</p>



<a name="272848172"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/overflow%20with%20a%20redundant%20bound%20on%20associated%20type/near/272848172" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Michael Goulet (compiler-errors) <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/overflow.20with.20a.20redundant.20bound.20on.20associated.20type.html#272848172">(Feb 22 2022 at 18:41)</a>:</h4>
<p>that's what I tell myself constantly</p>



<a name="272848201"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/overflow%20with%20a%20redundant%20bound%20on%20associated%20type/near/272848201" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Michael Goulet (compiler-errors) <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/overflow.20with.20a.20redundant.20bound.20on.20associated.20type.html#272848201">(Feb 22 2022 at 18:41)</a>:</h4>
<p>i've heard lazy normalization writes your code for you /s</p>



<a name="272848606"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/overflow%20with%20a%20redundant%20bound%20on%20associated%20type/near/272848606" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/overflow.20with.20a.20redundant.20bound.20on.20associated.20type.html#272848606">(Feb 22 2022 at 18:44)</a>:</h4>
<p>It looks like the associated type stuff is a red herring. This code also causes an overflow:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Wrapper</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">f</span>: <span class="nb">Box</span><span class="o">&lt;</span><span class="n">Wrapper</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="nb">Clone</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Wrapper</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">Wrapper</span>: <span class="nb">Clone</span> <span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">fn</span> <span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">       </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">f</span>: <span class="nc">self</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">clone</span><span class="p">()</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>



<a name="272849087"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/overflow%20with%20a%20redundant%20bound%20on%20associated%20type/near/272849087" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/overflow.20with.20a.20redundant.20bound.20on.20associated.20type.html#272849087">(Feb 22 2022 at 18:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="116155">Jake Goulding</span> <a href="#narrow/stream/144729-wg-traits/topic/overflow.20with.20a.20redundant.20bound.20on.20associated.20type/near/272845083">said</a>:</p>
<blockquote>
<p>But that  Sufficiently Advanced Compiler could see that we don't <em>need</em> to check <code>S::Expr: Clone</code> /  substitute <code>S = ParserSchema</code> because it's implied by the definition of <code>Schema</code>.</p>
</blockquote>
<p>I don't think this is correct (logically). <code>S::Expr: Clone</code> is exactly the bound we are trying to check. So it's not really <em>implied</em>. But, it can be conductive "it's Clone as long as it's Clone". A subtle distinction, but kind of important logically. (You could imagine that there might be type variables thrown in here in a more complicated case)</p>



<a name="272849142"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/overflow%20with%20a%20redundant%20bound%20on%20associated%20type/near/272849142" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/overflow.20with.20a.20redundant.20bound.20on.20associated.20type.html#272849142">(Feb 22 2022 at 18:48)</a>:</h4>
<p>I don't think <code>Clone</code> can be coinductive though</p>



<a name="272849155"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/overflow%20with%20a%20redundant%20bound%20on%20associated%20type/near/272849155" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/overflow.20with.20a.20redundant.20bound.20on.20associated.20type.html#272849155">(Feb 22 2022 at 18:49)</a>:</h4>
<p>Now, I think the desire <em>is</em> to make all traits conductive at some point</p>



<a name="272849191"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/overflow%20with%20a%20redundant%20bound%20on%20associated%20type/near/272849191" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/overflow.20with.20a.20redundant.20bound.20on.20associated.20type.html#272849191">(Feb 22 2022 at 18:49)</a>:</h4>
<p>trait implementations usually can't be, since you have to call some code at the end of the day</p>



<a name="272849253"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/overflow%20with%20a%20redundant%20bound%20on%20associated%20type/near/272849253" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/overflow.20with.20a.20redundant.20bound.20on.20associated.20type.html#272849253">(Feb 22 2022 at 18:49)</a>:</h4>
<p><code>Send</code> is more about ensuring certain bad things don't happen, so coinductive makes sense there</p>



<a name="272849323"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/overflow%20with%20a%20redundant%20bound%20on%20associated%20type/near/272849323" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/overflow.20with.20a.20redundant.20bound.20on.20associated.20type.html#272849323">(Feb 22 2022 at 18:50)</a>:</h4>
<p>Well, there's an impl. Sort of one of the requirements</p>



<a name="272849423"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/overflow%20with%20a%20redundant%20bound%20on%20associated%20type/near/272849423" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/overflow.20with.20a.20redundant.20bound.20on.20associated.20type.html#272849423">(Feb 22 2022 at 18:51)</a>:</h4>
<p>Making it coinductive doesn't remove that requirement</p>



<a name="272849638"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/overflow%20with%20a%20redundant%20bound%20on%20associated%20type/near/272849638" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/overflow.20with.20a.20redundant.20bound.20on.20associated.20type.html#272849638">(Feb 22 2022 at 18:53)</a>:</h4>
<p>hm, I see what you mean. This is weird, but I guess it's fine since termination was never on the agenda</p>



<a name="272850013"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/overflow%20with%20a%20redundant%20bound%20on%20associated%20type/near/272850013" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/overflow.20with.20a.20redundant.20bound.20on.20associated.20type.html#272850013">(Feb 22 2022 at 18:55)</a>:</h4>
<p>Strangely, adding a type variable to <code>Wrapper</code> makes the overflow go away (although since the <code>Clone</code> bound is inductive ATM it doesn't end up implementing <code>Clone</code> in the end)</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Wrapper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">t</span>: <span class="nc">std</span>::<span class="n">marker</span>::<span class="n">PhantomData</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">   </span><span class="n">f</span>: <span class="nb">Box</span><span class="o">&lt;</span><span class="n">Wrapper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Clone</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Wrapper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">Wrapper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>: <span class="nb">Clone</span> <span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">fn</span> <span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">       </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">t</span>: <span class="nc">self</span><span class="p">.</span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">self</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">clone</span><span class="p">()</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">foo</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">w</span>: <span class="nc">Wrapper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Wrapper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">w</span><span class="p">.</span><span class="n">clone</span><span class="p">()</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="c1">// fail</span>
</code></pre></div>



<a name="272850514"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/overflow%20with%20a%20redundant%20bound%20on%20associated%20type/near/272850514" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/overflow.20with.20a.20redundant.20bound.20on.20associated.20type.html#272850514">(Feb 22 2022 at 18:59)</a>:</h4>
<p>Aha, <code>Sized</code> definitely can't be coinductive, if we assume that the witness to <code>Sized</code> comes with an answer to <code>size_of::&lt;T&gt;()</code></p>



<a name="272851123"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/overflow%20with%20a%20redundant%20bound%20on%20associated%20type/near/272851123" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/overflow.20with.20a.20redundant.20bound.20on.20associated.20type.html#272851123">(Feb 22 2022 at 19:02)</a>:</h4>
<p>Sized is definitely harder :)</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>