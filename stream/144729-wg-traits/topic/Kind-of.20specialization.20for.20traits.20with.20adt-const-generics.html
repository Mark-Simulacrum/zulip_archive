<html>
<head><meta charset="utf-8"><title>Kind-of specialization for traits with adt-const-generics · wg-traits · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/index.html">wg-traits</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/Kind-of.20specialization.20for.20traits.20with.20adt-const-generics.html">Kind-of specialization for traits with adt-const-generics</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="252541920"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/Kind-of%20specialization%20for%20traits%20with%20adt-const-generics/near/252541920" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Alex Vlasov <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/Kind-of.20specialization.20for.20traits.20with.20adt-const-generics.html#252541920">(Sep 08 2021 at 22:14)</a>:</h4>
<p>I was trying to find a cleaner and fastest to stabilize way to implement Default for all array sized including the exotic case for <code>[T; 0]</code> where <code>T</code> doesn't implement <code>Default</code>.</p>
<p>So, long story short the following code doesn't compile with an error </p>
<div class="codehilite"><pre><span></span><code>the const parameter `TY` is not constrained by the impl trait, self type, or predicates
  --&gt; &lt;source&gt;:29:31
   |
29 | impl&lt;T, const N: usize, const TY: ArrayType&gt; DefaultLike for [T; N]
   |                                                      ^^ unconstrained const parameter
   |
   = note: expressions using a const parameter must map each value to a distinct output value
   = note: proving the result of expressions other than the parameter are unique is not supported
</code></pre></div>
<div class="codehilite"><pre><span></span><code>#![allow(incomplete_features)]
#![feature(adt_const_params)]

#[derive(PartialEq, Eq)]
enum ArrayType {
    ZeroLength,
    Normal
}

trait ArrayDefault&lt;const TY: ArrayType&gt; {
    fn hack() -&gt; Self;
}

impl&lt;T&gt; ArrayDefault&lt;{ArrayType::ZeroLength}&gt; for [T; 0] {
    fn hack() -&gt; Self {
        []
    }
}
impl&lt;T: Default, const N: usize&gt; ArrayDefault&lt;{ArrayType::Normal}&gt; for [T; N] {
    fn hack() -&gt; Self {
        [(); N].map(|_| T::default())
    }
}

trait DefaultLike {
    fn tester() -&gt; Self;
}

impl&lt;T, const N: usize, const TY: ArrayType&gt; DefaultLike for [T; N]
    where
        [T; N]: ArrayDefault&lt;TY&gt;,
{
    fn tester() -&gt; Self {
        &lt;[T; N] as ArrayDefault&lt;TY&gt;&gt;::hack()
    }
}
</code></pre></div>
<p>Same would happen without any features and using just <code>const B: bool</code> in trait parameters.</p>
<p>I'd expect that an ability to separate in a specialization-like manner some default-like implementation and "more specialized" ones would be handy even if a type of const generic parameter in the implementation would be quite constrained (may require enum/bool only, ordering on the enum, etc).</p>
<p>Is it something that would be desired or this is just over the roof and may be solved easier or "for free" by any other features being worked on. If it's desired I'd like to help with how to implement it if I get some guidance</p>



<a name="252542240"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/Kind-of%20specialization%20for%20traits%20with%20adt-const-generics/near/252542240" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Alex Vlasov <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/Kind-of.20specialization.20for.20traits.20with.20adt-const-generics.html#252542240">(Sep 08 2021 at 22:17)</a>:</h4>
<p>My though is largely based on a fact that it's much easier to pick one implementation to use from the already ordered priority set for the same type(!) then e.g. between more generic <code>T: Debug</code> and concrete <code>String</code></p>



<a name="252546777"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/Kind-of%20specialization%20for%20traits%20with%20adt-const-generics/near/252546777" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Boxy [she/her] <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/Kind-of.20specialization.20for.20traits.20with.20adt-const-generics.html#252546777">(Sep 08 2021 at 22:59)</a>:</h4>
<p>needing to constrain generic params still has to be done with const generics.<br>
what would this print out if we allowed it? :</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">impl</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">N</span>: <span class="kt">usize</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">fn</span> <span class="nf">foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">Foo</span>::<span class="n">foo</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>



<a name="252551792"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/Kind-of%20specialization%20for%20traits%20with%20adt-const-generics/near/252551792" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Alex Vlasov <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/Kind-of.20specialization.20for.20traits.20with.20adt-const-generics.html#252551792">(Sep 08 2021 at 23:59)</a>:</h4>
<p>My message is not about a particular error, but a potential feature that may be useful. One can change a syntax to make it more like higher rank trait bound with a meaning that “for all TY …”, but the idea is to simulate some kind of specialization or implementation priority resolution using ordering of some generic constant. It may be indeed good to require a completely different syntax there (to express a different meaning), but my question is about fundamental use</p>



<a name="252593277"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/Kind-of%20specialization%20for%20traits%20with%20adt-const-generics/near/252593277" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Giacomo Stevanato <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/Kind-of.20specialization.20for.20traits.20with.20adt-const-generics.html#252593277">(Sep 09 2021 at 09:02)</a>:</h4>
<p>So what you're proposing is to add a new type of generic which selects the smallest value that satistfy the other bounds? I feel like this would just have all the soundness problems that specialization has, but with an even weirder user interface.</p>



<a name="252601384"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/Kind-of%20specialization%20for%20traits%20with%20adt-const-generics/near/252601384" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Alex Vlasov <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/Kind-of.20specialization.20for.20traits.20with.20adt-const-generics.html#252601384">(Sep 09 2021 at 10:12)</a>:</h4>
<p>What I propose is roughly another kind of HRTB that will have a semantics of something like a marker or a priority ordering: so the same type that potentially implements a trait for different values of much generic a method dispatch and trait resolution will always pick the implementation with the “smallest” (from the point of Ord) value of such marker. It should not have the problems that specialization does: specialization has to choose between implementations for a different types and you have to “order” the types that is more difficult then to order the values of the same type, and the latter has a unique solution</p>



<a name="252625600"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/144729-wg-traits/topic/Kind-of%20specialization%20for%20traits%20with%20adt-const-generics/near/252625600" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Giacomo Stevanato <a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/Kind-of.20specialization.20for.20traits.20with.20adt-const-generics.html#252625600">(Sep 09 2021 at 13:30)</a>:</h4>
<p>The problem with specialization is not choosing the implementation but that rather that it allows unsound code.</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>