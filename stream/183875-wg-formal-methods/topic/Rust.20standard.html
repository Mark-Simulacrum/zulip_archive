<html>
<head><meta charset="utf-8"><title>Rust standard · wg-formal-methods · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/index.html">wg-formal-methods</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html">Rust standard</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="256855938"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/256855938" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bas Spitters <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#256855938">(Oct 09 2021 at 09:32)</a>:</h4>
<p>Let me repeat a question from the hacspec zulip here. I understand that is no rust analogue of the C-standard. The hacspec semantics is "obviously correct", but how to evaluate this statement?<br>
To put it very crudely, what prevents the compiler team from evaluating 2+2 to 5 ? <span class="user-mention" data-user-id="116009">@nikomatsakis</span> <span class="user-mention" data-user-id="228996">@Sabree Blackmon</span> might want to chime in.<br>
I'm aware of Ferrocene, but the latest blog post seems to be from February <a href="https://ferrous-systems.com/blog/ferrocene-update-three-the-road/">https://ferrous-systems.com/blog/ferrocene-update-three-the-road/</a></p>



<a name="257054701"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/257054701" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bas Spitters <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#257054701">(Oct 11 2021 at 12:10)</a>:</h4>
<p><span class="user-mention" data-user-id="120791">@RalfJ</span> Any insights?</p>



<a name="257055658"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/257055658" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Florian Diebold <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#257055658">(Oct 11 2021 at 12:19)</a>:</h4>
<blockquote>
<p>To put it very crudely, what prevents the compiler team from evaluating 2+2 to 5 ?</p>
</blockquote>
<p>(what prevents the authors of the C standard from defining 2+2 = 5 in the next version of the standard?)</p>



<a name="257058290"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/257058290" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bas Spitters <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#257058290">(Oct 11 2021 at 12:41)</a>:</h4>
<p>Good question. I believe this is the reason Ferrocene wants to have clear versioning. With a version of a specifcation of the language corresponding to each release of the language.<br>
WASM does the same. See the Change history in v1.1 of their <a href="https://webassembly.github.io/spec/core/_download/WebAssembly.pdf">specification</a></p>
<p>Oxide makes good progress on specifying a substantial part of the language, and extensively tests their work to the rust test suite. They don't have an interpreter yet, but it would be interesting to test that with the interpreter of hacspec.<br>
<a href="https://github.com/aatxe/oxide">https://github.com/aatxe/oxide</a></p>



<a name="257101076"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/257101076" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bas Spitters <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#257101076">(Oct 11 2021 at 18:31)</a>:</h4>
<p><span class="user-mention" data-user-id="129457">@Florian Diebold</span> I hope I phrased it more clearly here<br>
<a href="https://github.com/rust-lang/lang-team/issues/123">https://github.com/rust-lang/lang-team/issues/123</a></p>



<a name="257124890"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/257124890" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nikomatsakis <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#257124890">(Oct 11 2021 at 22:40)</a>:</h4>
<p><span class="user-mention" data-user-id="382207">@Bas Spitters</span> There is currently no Rust standard, that is correct. I am personally quite interested in seeing the development of an official "type system + operational semantics" for MIR</p>



<a name="257124934"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/257124934" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nikomatsakis <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#257124934">(Oct 11 2021 at 22:40)</a>:</h4>
<p>I think that is a useful and practical step</p>



<a name="257124956"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/257124956" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nikomatsakis <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#257124956">(Oct 11 2021 at 22:40)</a>:</h4>
<p>I don't think that trying to create a specification along the lines of the C standard for Rust is the best investment of time</p>



<a name="257125018"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/257125018" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nikomatsakis <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#257125018">(Oct 11 2021 at 22:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="116009">nikomatsakis</span> <a href="#narrow/stream/183875-wg-formal-methods/topic/Rust.20standard/near/257124890">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="382207">Bas Spitters</span> There is currently no Rust standard, that is correct. I am personally quite interested in seeing the development of an official "type system + operational semantics" for MIR</p>
</blockquote>
<p>I have been considering helping to drive this over the next year or so as a "next focus" for myself -- if so, I would expect to be working quite a lot with the folks on this stream in getting feedback on that!</p>



<a name="257137559"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/257137559" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#257137559">(Oct 12 2021 at 01:38)</a>:</h4>
<p>Should there be a working group for this? The initial steps of taking something like Oxide or RustBelt and expanding the type system to include everything in <code>Ty&lt;'ctx&gt;</code> seem clear enough</p>



<a name="257162208"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/257162208" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bas Spitters <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#257162208">(Oct 12 2021 at 07:45)</a>:</h4>
<p><span class="user-mention" data-user-id="271719">@Mario Carneiro</span> That's one reason we restarted <a href="https://rust-formal-methods.github.io/">https://rust-formal-methods.github.io/</a> . One can have a smaller subgroup just focusing on  "type system + operational semantics" for MIR, of course.</p>



<a name="257163030"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/257163030" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#257163030">(Oct 12 2021 at 07:53)</a>:</h4>
<p>I think it is worth actually starting a draft of something with the aspirations of eventually being part of a rust spec. As far as I know, there is nothing currently in this category except the rust reference and, to some extent, the UCG document. Assuming that we are working outward from the MIR core language, the draft need not be a formal document in the sense of being executable Coq code or something, and to some extent I think that will slow the progress by gatekeeping folks who don't have a strong formal methods background. Rather, I see the role of formal methods experts as auditing and shaping the progression of a precise prose spec so that it remains obviously formalizable, possibly by working out a formal document on the side. I see the WASM spec as a great example of this kind of work.</p>



<a name="257163619"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/257163619" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#257163619">(Oct 12 2021 at 07:59)</a>:</h4>
<p>The rust-formal-methods web page is basically empty at the moment, which is understandable since it has just started, but the name of the WG makes it sound like it will be focused on tools for doing formal methods on rust code, which is only tangentially related to the existence of a formal spec, so I would guess that if one starts building a formal spec there then it would be somewhat off topic</p>



<a name="257164370"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/257164370" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bas Spitters <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#257164370">(Oct 12 2021 at 08:05)</a>:</h4>
<p>I agree the wasm spec is great.<br>
Without a spec all FM is build on quicksand. I also have in mind a similar informal text/formal code collaboration you mention.</p>
<p>Yes, the page is a start to bringing people together. PRs are welcome :-)</p>



<a name="257172329"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/257172329" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#257172329">(Oct 12 2021 at 09:15)</a>:</h4>
<blockquote>
<p>I don't think that trying to create a specification along the lines of the C standard for Rust is the best investment of time</p>
</blockquote>
<p>If there is specification work that happens I actually <em>do</em> think it should start with something like the C spec, hopefully better informed from the start to avoid some of the complexities of that document.  I don't think trying to come up with a list of formal semantics judgements is helpful until then. </p>
<p><span class="user-mention silent" data-user-id="271719">Mario Carneiro</span> <a href="#narrow/stream/183875-wg-formal-methods/topic/Rust.20standard/near/257137559">said</a>:</p>
<blockquote>
<p>Should there be a working group for this? The initial steps of taking something like Oxide or RustBelt and expanding the type system to include everything in <code>Ty&lt;'ctx&gt;</code> seem clear enough</p>
</blockquote>
<p>A big issue is that both of these tools are models. Of the two, RustBelt is the only finished one, I don't know what state Oxide is in currently, I heard there was a revised paper in submission... RustBelt's lambda-rust is different from MIR in (many) key ways, bringing it inline would probably mean effectively starting over, but even more: there are whole areas of the type system that are still big question marks ie: trait objects. </p>
<p>And if we want to specify the type system of rust the situation is trickier: I'm not sure anyone has written down the rules of trait resolution in Rust, and type checking and borrow checking are tangled together, thus defining typing for source rust means discussing its translation to MIR.</p>
<p>If this is going to be a thing, it will be a huge amount of work and I think would <em>clearly</em> merit an official WG and wide community involvement. It's going to need people who are experts on each part of the language to share their understanding of how things work (and how they should). Long term, this also means changing the RFC process so that RFCs ensure the specification is updated appropriately (but that means we've gotten a spec)</p>



<a name="257187614"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/257187614" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#257187614">(Oct 12 2021 at 11:35)</a>:</h4>
<blockquote>
<p>If this is going to be a thing, it will be a huge amount of work and I think would clearly merit an official WG and wide community involvement. </p>
</blockquote>
<p>Agree 100%. This is a large project, but a journey of a thousand miles begins with a single step, and that step is setting up a WG with this in its charter.</p>
<blockquote>
<p>A big issue is that both of these tools are models. Of the two, RustBelt is the only finished one, I don't know what state Oxide is in currently, I heard there was a revised paper in submission... RustBelt's lambda-rust is different from MIR in (many) key ways, bringing it inline would probably mean effectively starting over, but even more: there are whole areas of the type system that are still big question marks ie: trait objects. </p>
</blockquote>
<p>I think the best way to crystallize this problem is to actually write a naive-ish extension of RustBelt to all of Rust, put <code>???</code> in the appropriate places, and open issues to track resolution. So far there isn't even really a venue to discuss the problem.</p>



<a name="257189206"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/257189206" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Vytautas Astrauskas [he/him] <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#257189206">(Oct 12 2021 at 11:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="116009">nikomatsakis</span> <a href="#narrow/stream/183875-wg-formal-methods/topic/Rust.20standard/near/257124890">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="382207">Bas Spitters</span> There is currently no Rust standard, that is correct. I am personally quite interested in seeing the development of an official "type system + operational semantics" for MIR</p>
</blockquote>
<p><span class="user-mention" data-user-id="116009">@nikomatsakis</span> Which MIR do you have in mind? <code>optimized_mir</code>? I think that we can define the operational semantics without lifetimes (for example, by using something like Stacked Borrows). However, if we want to bridge that with the type system, which fundamentally depends on lifetimes, we probably need to have MIR with sufficient lifetime information available in it and, as far as I know, <code>optimized_mir</code> does not have it.</p>



<a name="257189466"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/257189466" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#257189466">(Oct 12 2021 at 11:50)</a>:</h4>
<p>Although the operational semantics does not have lifetimes, the type system should determine the preconditions of the function, with lifetimes mapping to relations on the borrow stacks</p>



<a name="257191930"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/257191930" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#257191930">(Oct 12 2021 at 12:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="271719">Mario Carneiro</span> <a href="#narrow/stream/183875-wg-formal-methods/topic/Rust.20standard/near/257187614">said</a>:</p>
<blockquote>
<p>I think the best way to crystallize this problem is to actually write a naive-ish extension of RustBelt to all of Rust, put <code>???</code> in the appropriate places, and open issues to track resolution. So far there isn't even really a venue to discuss the problem.</p>
</blockquote>
<p>I guess what I meant is that we're better off forgetting about Coq for the moment (and the next bunch of moments). A mechanization of all of Rust will follow a paper description.</p>



<a name="257241282"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/257241282" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#257241282">(Oct 12 2021 at 17:31)</a>:</h4>
<p>The operational semantics must not depend on lifetimes even if they are available. Unsafe code is allowed to temporarily lie about lifetimes and for example use 'static everywhere.</p>



<a name="257241558"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/257241558" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#257241558">(Oct 12 2021 at 17:33)</a>:</h4>
<p>Lifetimed only matter for borrowck. The typechecker can also check lifetime constraints, but also needs to work with lifetimes erased. In fact MIR borrowck erases most lifetimes and then uses MIR typeck to get the lifetime constraints on fresh lifetimes I believe.</p>



<a name="257248094"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/257248094" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Vytautas Astrauskas [he/him] <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#257248094">(Oct 12 2021 at 18:16)</a>:</h4>
<p><span class="user-mention silent" data-user-id="133247">bjorn3</span> <a href="#narrow/stream/183875-wg-formal-methods/topic/Rust.20standard/near/257241558">said</a>:</p>
<blockquote>
<p>Lifetimed only matter for borrowck. The typechecker can also check lifetime constraints, but also needs to work with lifetimes erased. In fact MIR borrowck erases most lifetimes and then uses MIR typeck to get the lifetime constraints on fresh lifetimes I believe.</p>
</blockquote>
<p>Let me try to rephrase what I wanted to say in a hopefully clearer way: there are multiple MIRs and I think we need to decide which one of them we are going to use for defining semantics. One option would be to use <code>optimized_mir</code>, which is <a href="https://doc.rust-lang.org/nightly/nightly-rustc/src/rustc_middle/ty/mod.rs.html#1874-1875">used by Miri</a> (via <a href="https://doc.rust-lang.org/nightly/nightly-rustc/src/rustc_const_eval/interpret/machine.rs.html#146"><code>load_mir</code></a>) and, therefore, feels for me like a natural target for defining operational semantics. However, the MIR type checker runs on a different MIR and if we want to relate type-checking with operational semantics, we need to resolve this somehow.</p>



<a name="257302092"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/257302092" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#257302092">(Oct 13 2021 at 02:47)</a>:</h4>
<p><span class="user-mention silent" data-user-id="382207">Bas Spitters</span> <a href="#narrow/stream/183875-wg-formal-methods/topic/Rust.20standard/near/257054701">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> Any insights?</p>
</blockquote>
<p>certainly lots of thoughts^^ if only I could just make a copy of the stuff in my brain and share it with y'all... but sadly the bandwidth from my brain to the outside world is limited and that connection is highly congested with other things like being on various PCs and applying for faculty jobs and moving to Boston and being pinged on too many Rust issues and whatnot. :/  Some day I will have a week or at least a few days I can devote to bringing my thoughts on a spec for MIR operational semantics into markdown format and then I will be eager for everyone's feedback. A few months ago I told some people "some time this year", but I also thoroughly underestimated how much this move would disrupt me.</p>



<a name="257320162"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/257320162" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#257320162">(Oct 13 2021 at 07:02)</a>:</h4>
<p><span class="user-mention" data-user-id="116109">@Vytautas Astrauskas [he/him]</span> I think that’s orthogonal to the question of the semantics. The semantics of MIR will be independent of whatever form rust programs take. However, for the purposes of defining type checking it might be expedient to add a few ghost instructions to MIR which relate to lifetimes/regions. However their semantics would be nop.</p>



<a name="257320342"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/257320342" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#257320342">(Oct 13 2021 at 07:04)</a>:</h4>
<p>The questions (to me) seem to revolve around things like concurrency, trait objects, etc..</p>



<a name="257334881"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/257334881" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bas Spitters <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#257334881">(Oct 13 2021 at 09:18)</a>:</h4>
<p><span class="user-mention" data-user-id="120791">@RalfJ</span> Good luck on the move.<br>
<span class="user-mention" data-user-id="116109">@Vytautas Astrauskas [he/him]</span> Agreeing on which MIR to specify would already be progress. <span class="user-mention" data-user-id="116009">@nikomatsakis</span> What would be your preference? Also, what's the status of oxide?</p>



<a name="257337710"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/257337710" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#257337710">(Oct 13 2021 at 09:41)</a>:</h4>
<p>If one takes the name seriously, it's a bit dicey to be using "optimized MIR" to define semantics, because then the "optimizations" are ungrounded. But lifetime erased MIR seems like a reasonable substitute, since that's the relevant difference here</p>



<a name="257338254"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/257338254" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#257338254">(Oct 13 2021 at 09:46)</a>:</h4>
<p>It should also be possible to pull this back to an operational semantics on lifetime annotated MIR, defined by just ignoring any lifetimes during execution. So that should be enough to provide a basis for the whole set of mir-opt passes.</p>



<a name="257338445"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/257338445" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#257338445">(Oct 13 2021 at 09:48)</a>:</h4>
<p>Pushing the op.sem even farther back, to post type annotated HIR or so, would be even better, again defined by pullback so that MIR build is correct by construction. In order to keep the number of productions small though I believe it suffices to specify how HIR is turned into MIR and only present an actual op.sem on MIR. (My impression is that this is why <span class="user-mention silent" data-user-id="120791">RalfJ</span> was interested in starting the specification at the MIR level, because it is simpler than the languages it derives from.)</p>



<a name="257387994"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/257387994" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#257387994">(Oct 13 2021 at 15:44)</a>:</h4>
<p>there are multiple MIR dialects, but they are actually not <em>that</em> different -- I think drop elaboration is the only major shift, other than that the op.sem should be the same everywhere I think. Also see <a href="https://github.com/rust-lang/rust/issues/86299">https://github.com/rust-lang/rust/issues/86299</a>.</p>



<a name="257388153"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/257388153" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#257388153">(Oct 13 2021 at 15:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="271719">Mario Carneiro</span> <a href="#narrow/stream/183875-wg-formal-methods/topic/Rust.20standard/near/257337710">said</a>:</p>
<blockquote>
<p>If one takes the name seriously, it's a bit dicey to be using "optimized MIR" to define semantics, because then the "optimizations" are ungrounded. But lifetime erased MIR seems like a reasonable substitute, since that's the relevant difference here</p>
</blockquote>
<p>isnt the question more that we need to define the semantics of optimized MIR (rather than using optimized MIR to define the semantics of anything)?<br>
also, lifetime erasure should not change the semantics.</p>



<a name="257393615"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/257393615" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#257393615">(Oct 13 2021 at 16:17)</a>:</h4>
<blockquote>
<p>isnt the question more that we need to define the semantics of optimized MIR (rather than using optimized MIR to define the semantics of anything)?</p>
</blockquote>
<p>Well, we need to do both. We need to pick some core language <code>M</code>, such that <code>M</code> has a direct operational semantics on it, and every higher level language <code>H</code> earlier in the pipeline than <code>M</code> has its translation to <code>M</code> specified by some function <code>f : H -&gt; M</code>. The meaning of a program <code>x</code> in <code>H</code> is defined to be the meaning of <code>f(x)</code>, which is in turn defined via the op.sem on <code>M</code>.</p>
<p>If we take <code>M</code> to be optimized MIR, then that means that pre-optimized MIR would play the role of <code>H</code> here, which means we have to specify the optimizations and I think we don't want to do that. We can take <code>M</code> to be any/all of the MIR dialects however, which gives independent operational semantics to the before and after for mir-opt, meaning that correctness of the optimization becomes a theorem rather than a definition (which is a good thing).</p>
<blockquote>
<p>also, lifetime erasure should not change the semantics.</p>
</blockquote>
<p>How would you explain the role of the type system and lifetimes in the specification of the abstract machine? Does the machine use a type system at all, or perhaps a weak type system with layouts but no lifetimes?</p>



<a name="258406704"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/258406704" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#258406704">(Oct 20 2021 at 17:16)</a>:</h4>
<blockquote>
<p>If we take M to be optimized MIR</p>
</blockquote>
<p>Definitely not. As you said, that would make the optimizations part of the spec!</p>



<a name="258406860"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/258406860" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#258406860">(Oct 20 2021 at 17:17)</a>:</h4>
<blockquote>
<p>Does the machine use a type system at all, or perhaps a weak type system with layouts but no lifetimes?</p>
</blockquote>
<p>Yeah, that -- the machine cares about types for data layout and validity invariants, but no more than that.</p>



<a name="258450730"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/258450730" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#258450730">(Oct 20 2021 at 21:56)</a>:</h4>
<p>Is it possible to describe this type system ab initio, rather than "<code>Ty</code> but without lifetimes"? Is there anything more than lifetime erasure that happens to turn <code>Ty</code> into the R-AM type system?</p>



<a name="258450766"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/258450766" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#258450766">(Oct 20 2021 at 21:56)</a>:</h4>
<p>Because that type system seems like a good place to start</p>



<a name="258450950"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/258450950" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#258450950">(Oct 20 2021 at 21:58)</a>:</h4>
<p>(Perhaps "classification of validity invariants" is more accurate than "type system" here, since it barely qualifies as a type system)</p>



<a name="258452392"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/258452392" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#258452392">(Oct 20 2021 at 22:10)</a>:</h4>
<p>Here are some other things that make the MIR type system different from just type erasure:</p>
<ul>
<li>Pointers are untyped, i.e. all (sized) <code>*const T</code> and <code>*mut T</code> collapse to a single type</li>
<li>References are also untyped (aka shallow), but I think are a different type from pointers since they are nonnull</li>
<li>Most major type categories in <code>Ty</code> retain their distinctions, including in particular structs and enums as well as "internal" types like generators, trait objects and closures</li>
</ul>
<p>That's already making some claims that might go beyond what UCG has established. For example this implies that <code>&amp;!</code> and <code>*const !</code> are valid to inhabit as long as you don't dereference them, and <code>*const dyn Trait</code> must have a valid vtable pointer. Obviously it requires some tweaking and discussion (hopefully of bounded length), but a description roughly along these lines will answer a lot of open questions about MIR.</p>



<a name="258495343"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/258495343" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#258495343">(Oct 21 2021 at 06:43)</a>:</h4>
<p>I think it's important to distinguish the MIR type system from the abstract machine's 'type system'</p>



<a name="258495365"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/258495365" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#258495365">(Oct 21 2021 at 06:43)</a>:</h4>
<p>the mir type system <em>does</em> care about borrows, we want to be able to write the rules of the borrow checker on it</p>



<a name="258495425"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/258495425" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#258495425">(Oct 21 2021 at 06:44)</a>:</h4>
<p>on the other hand the machine only cares about things like type sizes: we just need to know how many bytes are in <code>_1</code> when we do <code>*_blah</code></p>



<a name="258495601"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/258495601" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#258495601">(Oct 21 2021 at 06:46)</a>:</h4>
<p>I <em>think</em> we can't easily get around needing the size of types but maybe we can even define it in a fully type agnostic way</p>



<a name="258495638"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/258495638" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#258495638">(Oct 21 2021 at 06:47)</a>:</h4>
<p>and then we want to (be able to) show that a well-typed MIR program never blocks in the machine (type soundness)</p>



<a name="258501436"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/258501436" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#258501436">(Oct 21 2021 at 07:46)</a>:</h4>
<p>The part that is confusing me is: in what sense is the MIR type system actually a part of the specification then? Proving type soundness is all well and good, but it's somewhat unrelated to what Rust actually does, since unsafe code can go outside the constraints of the type system (not just temporarily, literally "breaking the rules" like storing a <code>&amp;'a str</code> to a local variable in a <code>&amp;'static str</code> field) and we still call such programs well defined. Even "semantic soundness" in the sense used by RustBelt (which can be used to validate unsafe functions with a safe contract) is not a requirement for valid rust code.</p>
<p>Somehow, this is operating at another level, which could be called the "best practices" for putting <code>unsafe</code> on things. But you can completely lie about the unsafety of everything and the program does not become UB as a result, so this suggests that <code>unsafe</code> is "just a lint". That's basically another way of saying that the R-AM does not use safety invariants.</p>
<p>But Rust certainly does have a type system; users get type inference and lifetime elision and calling a function with the wrong lifetimes is caught by the borrow checker. All of this has to be part of the specification, and maybe MIR is the right level to do it. This is fundamentally a static analysis of the code, so it can't literally be specified in terms of potential executions even though we would like to think of it that way. In particular, I don't know whether we should try to specify exactly NLL / Polonius as implemented, or try to be vague and say that they implement some correct static approximation of dynamic correctness (i.e. not using a value after it is dropped, generalized over all possible executions of the code).</p>



<a name="258547686"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/258547686" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#258547686">(Oct 21 2021 at 13:45)</a>:</h4>
<p>I think there are two different issues at play here: the first is specifying the semantics of MIR given a specific program syntax what result do we get</p>



<a name="258547779"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/258547779" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#258547779">(Oct 21 2021 at 13:46)</a>:</h4>
<p>the second is specifying what syntaxes are valid and what we want to guarantee about them (no ub for safe code)</p>



<a name="258547938"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/258547938" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#258547938">(Oct 21 2021 at 13:47)</a>:</h4>
<p>the <em>semantics</em> of mir should be (imo) type independent beyond the layout of types, the purpose is just to define the result of any given mir program and that can potentially include 'stuck / ub'</p>



<a name="258548133"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/258548133" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#258548133">(Oct 21 2021 at 13:48)</a>:</h4>
<p>then using that we can define the type system of MIR which I think we should definitely do, MIR is the defacto public interface of rust for tools / backends</p>



<a name="258548446"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/258548446" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#258548446">(Oct 21 2021 at 13:50)</a>:</h4>
<p>Validity invariants like nonnull references have to be in the R-AM semantics too because they are given to LLVM. It's not just layout</p>



<a name="258548533"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/258548533" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#258548533">(Oct 21 2021 at 13:50)</a>:</h4>
<p>sure, I think you get the point, the machine only cares about... machine things</p>



<a name="258548548"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/258548548" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#258548548">(Oct 21 2021 at 13:50)</a>:</h4>
<p>sure</p>



<a name="258548575"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/258548575" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#258548575">(Oct 21 2021 at 13:51)</a>:</h4>
<p>but then using that we can define properties that all rust programs must satisfy</p>



<a name="258548608"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/258548608" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#258548608">(Oct 21 2021 at 13:51)</a>:</h4>
<p>I think we agree here. I would really like to see what a semantic definition of types looks like though</p>



<a name="258548641"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/258548641" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#258548641">(Oct 21 2021 at 13:51)</a>:</h4>
<p>like: forall programs P (safe and unsafe) the machine must never reach a UB state</p>



<a name="258548796"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/258548796" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#258548796">(Oct 21 2021 at 13:52)</a>:</h4>
<p>how we define type soundness will be interesting as well</p>



<a name="258548855"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/258548855" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#258548855">(Oct 21 2021 at 13:52)</a>:</h4>
<p>would types be defined so as to make type soundness a tautology?</p>



<a name="258548881"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/258548881" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#258548881">(Oct 21 2021 at 13:52)</a>:</h4>
<p>not sure I follow</p>



<a name="258548893"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/258548893" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#258548893">(Oct 21 2021 at 13:52)</a>:</h4>
<p>as you've remarked RustBelt uses a rather advanced technique of semantic typing which captures the notion of unsafe abstraction</p>



<a name="258549021"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/258549021" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#258549021">(Oct 21 2021 at 13:53)</a>:</h4>
<p>we can definitely design the syntactic typing rules for MIR, but that still leaves the question of unsafe code</p>



<a name="258549099"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/258549099" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#258549099">(Oct 21 2021 at 13:54)</a>:</h4>
<p>and without a clean answer to that we can't hope to state a useful type soundness theorem for mir</p>



<a name="258549169"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/258549169" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#258549169">(Oct 21 2021 at 13:54)</a>:</h4>
<p>idk, what the answer here is, I haven't really thought about this problem in depth</p>



<a name="258549443"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/258549443" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#258549443">(Oct 21 2021 at 13:56)</a>:</h4>
<p>If the types are semantic types, then it's possible that type soundness is true by definition (i.e. we say that a function has type T -&gt; U if it doesn't cause UB and produces a U from a T). In that case the meat of the type soundness theorem is transferred to showing that the syntactic constructs are well typed</p>



<a name="258549600"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/258549600" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#258549600">(Oct 21 2021 at 13:57)</a>:</h4>
<p>I think this roughly accords with the RustBelt approach</p>



<a name="258549737"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/258549737" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#258549737">(Oct 21 2021 at 13:58)</a>:</h4>
<p>Anyway, I didn't mean to rant too much on this thread. I just want us to get the ball rolling</p>



<a name="258550251"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/258550251" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#258550251">(Oct 21 2021 at 14:01)</a>:</h4>
<p>Yes but I don't know if that's how we want to define the <em>official</em> typesystem of MIR as that effectively means that only POPL attendees will understand it</p>



<a name="258550385"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/258550385" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#258550385">(Oct 21 2021 at 14:02)</a>:</h4>
<p>we want a simple, powerful, easy to explain, flexible, sound and concise type-system should be easy right?</p>



<a name="258550813"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/258550813" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#258550813">(Oct 21 2021 at 14:04)</a>:</h4>
<blockquote>
<p>that effectively means that only POPL attendees will understand it</p>
</blockquote>
<p>Honestly, avoiding this situation is not a high priority IMO. Getting it right should come first, making it easy to understand can be done after the fact. The borrow checker has followed roughly this trajectory, so I don't think it's a misguided approach.</p>



<a name="258550987"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/258550987" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#258550987">(Oct 21 2021 at 14:05)</a>:</h4>
<p>Also, the C++ standard is not particularly easy to understand either. Maybe that's a poor comparison, but Rust is likely to be about as complicated (in very different directions, of course)</p>



<a name="258551616"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/258551616" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#258551616">(Oct 21 2021 at 14:08)</a>:</h4>
<p>There is another issue with the syntax/semantics definition of types: What if Rust is unsound? This is true at the moment and likely to be true for the forseeable future, but it puts the spec in an uncomfortable position because it probably wants to set things up in such a way as to make soundness a theorem, so there is going to be some part of rustc that differs from the spec</p>



<a name="258551756"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/258551756" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#258551756">(Oct 21 2021 at 14:09)</a>:</h4>
<p>well its one thing if rustc deviates from the spec and causes unsoundness</p>



<a name="258551768"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/258551768" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#258551768">(Oct 21 2021 at 14:09)</a>:</h4>
<p>its another thing if the <em>spec</em> is unsound</p>



<a name="258551923"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/258551923" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#258551923">(Oct 21 2021 at 14:10)</a>:</h4>
<p>i know it's naive of me but I would like it if the rust language, on paper has actual metatheoretical properties</p>



<a name="258551960"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/258551960" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#258551960">(Oct 21 2021 at 14:10)</a>:</h4>
<p>I think there are at least a few issues which venture into "the spec is unsound" territory. One of the oldest I-unsound issues is about hash collisions, I don't see how to make that sound</p>



<a name="258552499"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20standard/near/258552499" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20standard.html#258552499">(Oct 21 2021 at 14:14)</a>:</h4>
<p><a href="https://github.com/rust-lang/rust/issues/10389">https://github.com/rust-lang/rust/issues/10389</a> ?</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>