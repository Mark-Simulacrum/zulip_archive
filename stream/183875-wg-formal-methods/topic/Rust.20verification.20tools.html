<html>
<head><meta charset="utf-8"><title>Rust verification tools · wg-formal-methods · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/index.html">wg-formal-methods</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20verification.20tools.html">Rust verification tools</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="208996911"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20verification%20tools/near/208996911" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Alastair Reid <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20verification.20tools.html#208996911">(Sep 03 2020 at 16:47)</a>:</h4>
<p>My team in Google Research has been thinking about what we want in Rust verification.<br>
We want to narrow the gap between testing and verification. e.g., by making it easy to switch back and forth between testing and verification.</p>
<p>So we have been reimplementing the proptest library so that you can use the same test harness for testing/fuzzing with proptest and for formal verification using automatic verification tools like KLEE.</p>
<p>It's early days yet but we have something that works and we would love feedback on whether this is a direction that the community should go in or not.</p>
<p>Code: <a href="https://github.com/project-oak/rust-verification-tools">https://github.com/project-oak/rust-verification-tools</a><br>
Blog post: <a href="https://alastairreid.github.io/why-not-both/">https://alastairreid.github.io/why-not-both/</a><br>
Tweet: <a href="https://twitter.com/alastair_d_reid/status/1301543693233655810">https://twitter.com/alastair_d_reid/status/1301543693233655810</a></p>
<div class="inline-preview-twitter"><div class="twitter-tweet"><a href="https://twitter.com/alastair_d_reid/status/1301543693233655810"><img class="twitter-avatar" src="https://pbs.twimg.com/profile_images/731458319433519104/q1EULfSQ_normal.jpg"></a><p>Verifying vs testing?  Why not both?
New blog post about our work on Rust verification based on reimplementing the proptest library for formal verification tools so you can use the same test harness with both proptest and with “propverify”.
<a href="https://twitter.com/rustlang">@rustlang</a> #KLEE
<a href="https://t.co/rAzAvW6MCI">https://alastairreid.github.io/why-not-both/</a></p><span>- Alastair Reid (@alastair_d_reid)</span></div></div>



<a name="208997420"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20verification%20tools/near/208997420" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20verification.20tools.html#208997420">(Sep 03 2020 at 16:51)</a>:</h4>
<p>It shows a double scroll bar on code blocks in Firefox on Linux:</p>
<p><a href="/user_uploads/4715/phAyFXyFpAP8CF4N0wx2lPLo/image.png">image.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/4715/phAyFXyFpAP8CF4N0wx2lPLo/image.png" title="image.png"><img src="/user_uploads/4715/phAyFXyFpAP8CF4N0wx2lPLo/image.png"></a></div><p>This is likely caused by the <code>overflow: scroll</code> instead of <code>overflow: auto</code>.</p>



<a name="209000233"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20verification%20tools/near/209000233" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Alastair Reid <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20verification.20tools.html#209000233">(Sep 03 2020 at 17:12)</a>:</h4>
<p>Ugh! That is horrible. I guess I have to go futz with my website a bit. Thanks for the diagnosis!</p>



<a name="209071705"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20verification%20tools/near/209071705" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20verification.20tools.html#209071705">(Sep 04 2020 at 09:22)</a>:</h4>
<p>I fully agree with the point of this post. :) Testing and verification can complement each other very well.</p>
<p><span class="user-mention" data-user-id="336739">@Alastair Reid</span> some of this would also be very interesting to the secure code WG (<a class="stream" data-stream-id="146229" href="/#narrow/stream/146229-wg-secure-code">#wg-secure-code</a>), just in case you are not yet familiar with their work.</p>



<a name="252154258"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20verification%20tools/near/252154258" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Alastair Reid <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20verification.20tools.html#252154258">(Sep 06 2021 at 10:10)</a>:</h4>
<p>A few days ago, we announced the end of our Rust verification project at Google.<br>
I'm sad to see it end – but I am hoping that others will adapt some of the ideas and solutions to the problems we ran into when tackling "large" codebases.<br>
This post summarizes what I thought was important about the project <a href="https://project-oak.github.io/rust-verification-tools/2021/09/01/retrospective.html">https://project-oak.github.io/rust-verification-tools/2021/09/01/retrospective.html</a></p>



<a name="252451158"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20verification%20tools/near/252451158" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bas Spitters <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20verification.20tools.html#252451158">(Sep 08 2021 at 12:31)</a>:</h4>
<p><span class="user-mention" data-user-id="336739">@Alastair Reid</span> Some links in your blog post: <a href="https://alastairreid.github.io/why-not-both/">https://alastairreid.github.io/why-not-both/</a><br>
You say you use some format from <a href="https://alastairreid.github.io/verification-competitions/">https://alastairreid.github.io/verification-competitions/</a>, but I don't see which one. Could you say more?</p>



<a name="252612796"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20verification%20tools/near/252612796" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Alastair Reid <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20verification.20tools.html#252612796">(Sep 09 2021 at 12:00)</a>:</h4>
<p><span class="user-mention" data-user-id="382207">@Bas Spitters</span> I was specifically thinking of SV-COMP and the interface defined in the rules <a href="https://sv-comp.sosy-lab.org/2021/rules.php">https://sv-comp.sosy-lab.org/2021/rules.php</a><br>
which defines operations such as "X __VERIFIER_nondet_X()" where X is a builtin type.</p>
<p>Expressing the same in Rust, there are at least three possible trait-based approaches (based on what we found in MIRAI, KLEE, SMACK and Crux-MIR). <a href="https://github.com/project-oak/rust-verification-tools/blob/main/verification-annotations/src/traits.rs">https://github.com/project-oak/rust-verification-tools/blob/main/verification-annotations/src/traits.rs</a></p>
<p>The methods in the three traits are</p>
<ul>
<li>fn verifier_nondet(self) -&gt; Self;</li>
<li>fn abstract_value() -&gt; Self;</li>
<li>fn symbolic(desc: &amp;'static str) -&gt; Self;</li>
</ul>
<p>Where the self argument to verifier_nondet is a value that can be used when testing.<br>
And the string argument to symbolic is a name to use in error reports, etc.</p>



<a name="252613302"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20verification%20tools/near/252613302" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Alastair Reid <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20verification.20tools.html#252613302">(Sep 09 2021 at 12:05)</a>:</h4>
<p>On top of that, you need some ways to add assumptions, etc. <a href="https://github.com/project-oak/rust-verification-tools/blob/main/verification-annotations/src/verifier/seahorn.rs">https://github.com/project-oak/rust-verification-tools/blob/main/verification-annotations/src/verifier/seahorn.rs</a></p>
<p>And individual tools might extend this. For example, our KLEE bindings have a bunch of operations not found in SeaHorn to let you control path merging and to generate a single concrete instance of a symbolic value <a href="https://github.com/project-oak/rust-verification-tools/blob/main/verification-annotations/src/verifier/klee.rs">https://github.com/project-oak/rust-verification-tools/blob/main/verification-annotations/src/verifier/klee.rs</a></p>



<a name="252626354"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20verification%20tools/near/252626354" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Alastair Reid <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20verification.20tools.html#252626354">(Sep 09 2021 at 13:35)</a>:</h4>
<p>In addition to creating symbolic values, the following functions are useful.</p>
<p>/// Assume that condition <code>cond</code> is true<br>
pub fn assume(cond: bool)</p>
<p>/// Reject the current execution with a verification failure.<br>
pub fn abort() -&gt; !</p>
<p>/// Reject the current execution with a verification failure<br>
/// and an error message.<br>
pub fn report_error(message: &amp;str) -&gt; !</p>
<p>/// Reject the current execution path with a verification success.<br>
/// This is equivalent to <code>assume(false)</code> except for the never return type<br>
pub fn reject() -&gt; !</p>



<a name="252627212"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20verification%20tools/near/252627212" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Alastair Reid <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20verification.20tools.html#252627212">(Sep 09 2021 at 13:40)</a>:</h4>
<p>And, if your verification tool can generate failing inputs, it is nice to be able to print those inputs using Rust code (so that they are formatted nicely). For this, it is useful to be able to test whether you are rerunning the verification harness with concrete values or you are verifying the code with symbolic values.</p>
<p>/// Detect whether the program is being run symbolically in KLEE<br>
/// or being replayed using the kleeRuntest runtime.<br>
///<br>
/// This is used to decide whether to display the values of<br>
/// variables that may be either symbolic or concrete.<br>
pub fn is_replay() -&gt; bool</p>
<p>Typical usage:</p>
<p>let x = abstract_value();<br>
let y = abstract_value();<br>
if is_replay() {<br>
    println!("Test inputs x={} y={}")<br>
}<br>
assert!(x + y == y + x);</p>



<a name="252628233"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20verification%20tools/near/252628233" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Alastair Reid <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20verification.20tools.html#252628233">(Sep 09 2021 at 13:46)</a>:</h4>
<p>Finally, if you want to be able to implement something like  the   #[should_panic] attribute, it is useful to have a way for the verification harness to report the expected behaviour of the system. Something like the following</p>
<p>/// Declare that failure is the expected behaviour<br>
pub fn expect(msg: Option&lt;&amp;str&gt;) {<br>
    match msg {<br>
        None =&gt; eprintln!("VERIFIER_EXPECT: should_panic"),<br>
        Some(msg) =&gt; eprintln!("VERIFIER_EXPECT: should_panic(expected = \"{}\")", msg),<br>
    }<br>
}</p>
<p>I think the functions listed above provide important functionality that we would probably want in many different kinds of tool. Of course, the exact names and types could easily change - especially since I was learning Rust and Rust conventions as I was designing this.</p>



<a name="252630319"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/183875-wg-formal-methods/topic/Rust%20verification%20tools/near/252630319" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Alastair Reid <a href="https://zulip-archive.rust-lang.org/stream/183875-wg-formal-methods/topic/Rust.20verification.20tools.html#252630319">(Sep 09 2021 at 13:59)</a>:</h4>
<p>Another reason why having a standard API is a good idea (beyond being able to run competitions) is that it lets us build higher-level libraries on top. eg we reimplemented the API of PropTest (a property-based testing crate) to work on top of the above API.</p>
<p>One of the key things that PropTest gives you (and that PropVerify copied) is an EDSL for defining values to test with.<br>
eg you can write "x in 1..1000u32" to generate a value in a range or "prop::collection::vec(0..10u32, 5)" to generate a vector of length up to 5 where each value is in the range 0..10.</p>
<p>The nice thing about doing this is to be able to use a range of techniques from fuzzing (PropTest) through to formal using a variety of different backends (using PropVerify).<br>
(Caveat: at the time we wrote this, KLEE was the only tool on the formal end of things that could cope with enough of the Rust language that it actually worked with PropVerify. Hopefully this has changed.)</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>