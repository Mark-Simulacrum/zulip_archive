<html>
<head><meta charset="utf-8"><title>Behavior of dangling pointer arithmetic operations · t-libs · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/index.html">t-libs</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html">Behavior of dangling pointer arithmetic operations</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="272863626"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/272863626" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Celina V. <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#272863626">(Feb 22 2022 at 20:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="125270">scottmcm</span> <a href="#narrow/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations/near/272861975">said</a>:</p>
<blockquote>
<p>Hmm, seems like we need more words here then, since the topic mentions <code>Unique::dangling</code>, so that's how I was interpreting it.</p>
<p>So are you saying that <code>.add(0)</code> after moving out side an allocated object would be UB?  Like <code>.wrapping_offset(100).add(0)</code>?  That would make sense to me.</p>
</blockquote>
<p>I renamed the topic name since this has shifted a bit. Hopefully it makes more sense now.</p>
<p>The main question now is under which conditions the pointer <code>add()</code> operation has UB when dealing with dangling pointers. I can also move this discussion to  <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines">#t-lang/wg-unsafe-code-guidelines</a> if it's a better channel for that.</p>
<p>Thanks again for all the answers.</p>



<a name="272865011"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/272865011" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#272865011">(Feb 22 2022 at 20:54)</a>:</h4>
<p>I guess, from the perspective of validation, you could think of <code>dangling()</code> as being</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">empty</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="nb">static</span> <span class="p">[</span><span class="n">T</span><span class="p">;</span><span class="w"> </span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[];</span><span class="w"></span>
<span class="w">    </span><span class="n">empty</span><span class="p">.</span><span class="n">as_ptr</span><span class="p">()</span><span class="w"></span>
</code></pre></div>
<p>where it returns a pointer to an allocated object, so the <code>add(0)</code> on that is valid, but if you move it off that allocated object at all (like <code>.wrapping_offset(1)</code>) then then <code>.add(0)</code> is no longer valid any more.</p>
<p>(That particular implementation doesn't compile today, though, since it -- possibly erroneously? -- requires <code>T: 'static</code>.)</p>



<a name="272886348"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/272886348" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Celina V. <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#272886348">(Feb 23 2022 at 00:25)</a>:</h4>
<p>I was reading about this issue a bit more and I found <a href="https://doc.rust-lang.org/nomicon/vec/vec-alloc.html">this Rustonomicon document on vector allocation</a>. In this document, they do allocate even for <code>0</code> capacity vector to ensure safe alias analysis.</p>



<a name="272960828"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/272960828" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#272960828">(Feb 23 2022 at 15:06)</a>:</h4>
<p>Oh, interesting implementation idea. The following, by the way, does compile on stable Rust:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">const</span><span class="w"> </span><span class="k">fn</span> <span class="nf">dangling</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">trait</span><span class="w"> </span><span class="n">Generic</span><span class="o">&lt;'</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span>: <span class="o">'</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">EMPTY_SLICE</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">a</span> <span class="p">[</span><span class="n">T</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">impl</span><span class="o">&lt;'</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span>: <span class="o">'</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Generic</span><span class="o">&lt;'</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">EMPTY_SLICE</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">a</span> <span class="p">[</span><span class="n">T</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[];</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="o">&lt;</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">Generic</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span>::<span class="n">EMPTY_SLICE</span><span class="p">.</span><span class="n">as_ptr</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>



<a name="272980242"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/272980242" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#272980242">(Feb 23 2022 at 17:17)</a>:</h4>
<p>I think that's equivalent to <code>[].as_ptr()</code>, since it's a <code>const</code> not a <code>static</code>, and that also compiles -- but returns (AFAICT) a pointer to the ZST local.</p>
<p>Perhaps that's another case of the "it pointed to an object that's definitely no longer around" and thus is UB despite being a properly-aligned ZST?</p>



<a name="272980519"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/272980519" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#272980519">(Feb 23 2022 at 17:19)</a>:</h4>
<p>No, that gets static promotion. <br>
Although it gives zero guarantees of returning the same pointer each time</p>



<a name="274455315"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/274455315" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Celina V. <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#274455315">(Mar 07 2022 at 20:51)</a>:</h4>
<p>Going back to the initial issue that triggered this topic, I don't think the current iterator implementation for empty vector is safe. The usage of <code>add</code> and underlying <code>getelementptr inbounds</code> in the code bellow when <code>ptr</code> is a dangling pointer violates the safety condition that the base pointer has an in bounds address of an <strong>allocated object</strong>.</p>
<div class="codehilite"><pre><span></span><code>            let end = if mem::size_of::&lt;T&gt;() == 0 {
                (ptr as *const u8).wrapping_add(slice.len()) as *const T
            } else {
                ptr.add(slice.len())
            };
</code></pre></div>
<p>ref: <a href="https://github.com/rust-lang/rust/blob/ecb867ec3cefa97a5807453a68758392730e3ed9/library/core/src/slice/iter.rs#L93">https://github.com/rust-lang/rust/blob/ecb867ec3cefa97a5807453a68758392730e3ed9/library/core/src/slice/iter.rs#L93</a></p>
<p>I don't think the ZST exception applies here, since the code is explicitly checking that <code>T</code> is not ZST. There is no exception as far as I can tell if the offset value is 0.</p>
<p>In practice, LLVM may mark <code>end</code> as carrying poison value, which allows the compiler to optimize its value and replace by any value of its type.</p>



<a name="274472168"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/274472168" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#274472168">(Mar 07 2022 at 23:06)</a>:</h4>
<p>as in, <code>dangling + 0 = poison</code> ?</p>



<a name="274472842"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/274472842" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#274472842">(Mar 07 2022 at 23:13)</a>:</h4>
<p>I believe the distinction here is that wrapping_add can go out of bounds as long as you don't use it until it's back in bounds</p>



<a name="274476726"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/274476726" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#274476726">(Mar 07 2022 at 23:59)</a>:</h4>
<p>sure, but I think <span class="user-mention" data-user-id="442621">@Celina V.</span> is saying that even <code>ptr.add(0)</code> is poisoned if <code>ptr</code> is not an allocated object</p>



<a name="274479314"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/274479314" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> erikdesjardins <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#274479314">(Mar 08 2022 at 00:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="138448">cuviper</span> <a href="#narrow/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations/near/274472168">said</a>:</p>
<blockquote>
<p>as in, <code>dangling + 0 = poison</code> ?</p>
</blockquote>
<p>where <code>+</code> = <code>getelementptr inbounds</code>, yes<br>
gepi (and <code>pointer::add</code>) require the base pointer to be inbounds of an allocated object<br>
the index being 0 doesn't matter<br>
<a href="https://llvm.org/docs/LangRef.html#id234">https://llvm.org/docs/LangRef.html#id234</a></p>



<a name="274479379"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/274479379" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> erikdesjardins <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#274479379">(Mar 08 2022 at 00:27)</a>:</h4>
<p>(unfortunately) i can't easily demonstrate this with dangling pointers because alive doesn't support inttoptr (and llvm seems to not exploit this currently)<br>
you can see it when going oob of a normal allocation <a href="https://alive2.llvm.org/ce/z/xynnkM">https://alive2.llvm.org/ce/z/xynnkM</a></p>



<a name="274481100"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/274481100" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> erikdesjardins <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#274481100">(Mar 08 2022 at 00:48)</a>:</h4>
<p>i guess it depends on the semantics of <code>inttoptr</code> (which the langref is very light on...), which we use to create the dangling pointer<br>
because stuff like this should work i think</p>
<div class="codehilite" data-code-language="LLVM"><pre><span></span><code><span class="c">; address of some memory-mapped device</span>
<span class="nv">%regs</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">inttoptr</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">123456</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="kt">i8</span><span class="p">*</span><span class="w"></span>
<span class="nv">%enable</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">getelementptr</span><span class="w"> </span><span class="k">inbounds</span><span class="w"> </span><span class="kt">i8</span><span class="p">,</span><span class="w"> </span><span class="kt">i8</span><span class="p">*</span><span class="w"> </span><span class="nv">%regs</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">42</span><span class="w"></span>
<span class="k">store</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="kt">i8</span><span class="p">*</span><span class="w"> </span><span class="nv">%enable</span><span class="w"></span>
</code></pre></div>
<p>and that's basically the same</p>



<a name="274482891"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/274482891" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> erikdesjardins <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#274482891">(Mar 08 2022 at 01:11)</a>:</h4>
<hr>
<p>okay, i'm no longer convinced either way <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span></p>
<p>from the perspective of llvm ir:</p>
<p>if the pointer is dangling because it points to, e.g. a local variable that's out of scope, then <code>dangling + 0 = poison</code> (<a href="https://alive2.llvm.org/ce/z/tUpYpG">https://alive2.llvm.org/ce/z/tUpYpG</a>)<br>
if the pointer is dangling because we created it out of thin air with <code>inttoptr</code>, it may or may not be poison, i don't know</p>
<p>from the perspective of "<a href="https://doc.rust-lang.org/std/primitive.pointer.html#method.add">https://doc.rust-lang.org/std/primitive.pointer.html#method.add</a> safety comments":</p>
<p>it's probably UB, because it says</p>
<blockquote>
<p>Both the starting and resulting pointer must be either in bounds or one byte past the end of the same allocated object.</p>
</blockquote>
<p>although "allocated object" is not rigorously defined</p>



<a name="274485989"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/274485989" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#274485989">(Mar 08 2022 at 01:56)</a>:</h4>
<p>For the purpose of ZSTs, we generally seem to consider there to be an "allocated object" at every correctly-aligned non-null address.</p>
<p>I think basically the problem is that a bunch of these things no longer make much sense without the C rule of "every object (that's not a sub-object, in C++) has a distinct address".</p>



<a name="274503000"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/274503000" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> erikdesjardins <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#274503000">(Mar 08 2022 at 06:51)</a>:</h4>
<p>llvm ir doesn't seem to have those semantics: <a href="https://alive2.llvm.org/ce/z/ejchHX">https://alive2.llvm.org/ce/z/ejchHX</a><br>
at least when the pointer is derived from an existing allocation (can't use <code>inttoptr</code> in alive)</p>



<a name="274503006"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/274503006" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> erikdesjardins <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#274503006">(Mar 08 2022 at 06:51)</a>:</h4>
<blockquote>
<p>For the purpose of ZSTs, we generally seem to consider there to be an "allocated object" at every correctly-aligned non-null address.</p>
</blockquote>
<p>this seems equivalent to "every nonnull pointer is inbounds"<br>
since by that reasoning there's a <code>()</code> at every nonnull address</p>
<p>this would mean that <code>.add(0)</code> would be defined for any nonnull pointer</p>
<p>(i have no comment on whether this is desirable)</p>



<a name="274503009"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/274503009" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> erikdesjardins <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#274503009">(Mar 08 2022 at 06:51)</a>:</h4>
<blockquote>
<p>I think basically the problem is that a bunch of these things no longer make much sense without the C rule of "every object (that's not a sub-object, in C++) has a distinct address".</p>
</blockquote>
<p>yeah</p>
<p>llvm ir does have zsts though, and still has these rules<br>
but i don't know if its semantics around this are actually consistent</p>



<a name="274585899"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/274585899" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#274585899">(Mar 08 2022 at 18:40)</a>:</h4>
<p>I suppose one option here is just for us to define that <code>offset</code> on a pointer-to-ZST is always defined as identity, and do that by not emitting anything to LLVM for those cases, so thus we're not impacted by their semantics for it.</p>



<a name="274588930"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/274588930" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Celina V. <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#274588930">(Mar 08 2022 at 19:00)</a>:</h4>
<p>The exception already exists for  ZST: <a href="https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts">https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts</a>.</p>
<blockquote>
<p>pointer offsets are no-ops</p>
</blockquote>
<p>However, this is a pointer to a sized type:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">mem</span>::<span class="n">size_of</span>::<span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="c1">// This should be a no-op.</span>
<span class="w">                </span><span class="p">(</span><span class="n">ptr</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="kt">u8</span><span class="p">).</span><span class="n">wrapping_add</span><span class="p">(</span><span class="n">slice</span><span class="p">.</span><span class="n">len</span><span class="p">())</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="c1">// ------ This is the branch with UB.</span>
<span class="w">                </span><span class="n">ptr</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">slice</span><span class="p">.</span><span class="n">len</span><span class="p">())</span><span class="w"></span>
<span class="w">            </span><span class="p">};</span><span class="w"></span>
</code></pre></div>
<p>That said, I'm not sure why the ZST branch is doing a wrapping_add since it should be a no-op. <span aria-label="shrug" class="emoji emoji-1f937" role="img" title="shrug">:shrug:</span></p>



<a name="274589990"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/274589990" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#274589990">(Mar 08 2022 at 19:06)</a>:</h4>
<p>the ZST side is adding as <code>*const u8</code>, so that's not a no-op for non-zero length</p>



<a name="274590009"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/274590009" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#274590009">(Mar 08 2022 at 19:06)</a>:</h4>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Iter</span><span class="o">&lt;'</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span>: <span class="o">'</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ptr</span>: <span class="nc">NonNull</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">end</span>: <span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="c1">// If T is a ZST, this is actually ptr+len.  This encoding is picked so that</span>
<span class="w">    </span><span class="c1">// ptr == end is a quick test for the Iterator being empty, that works</span>
<span class="w">    </span><span class="c1">// for both ZST and non-ZST.</span>
<span class="w">    </span><span class="n">_marker</span>: <span class="nc">PhantomData</span><span class="o">&lt;&amp;'</span><span class="na">a</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>



<a name="274590127"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/274590127" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#274590127">(Mar 08 2022 at 19:07)</a>:</h4>
<p>where <code>ptr+len</code> in that comment is raw numeric addition, ignoring the size of T</p>



<a name="274593133"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/274593133" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Celina V. <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#274593133">(Mar 08 2022 at 19:26)</a>:</h4>
<p>Indeed. You are correct! It makes me wonder why, but I don't' want to diverge this thread.</p>
<p>edit: I guess this is trying to get an iterator that has the correct number of iterations and ignoring the pointer value.</p>



<a name="274600544"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/274600544" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#274600544">(Mar 08 2022 at 20:18)</a>:</h4>
<p>That's right.  For ZSTs it always returns the begin pointer, and uses the end pointer to track the length.  That's why the end isn't <em>also</em> a <code>NonNull&lt;T&gt;</code>.</p>
<p>(It might be clearer to have end be a pointer-or-usize union, and just treat <code>end</code> as <code>len</code> directly for ZSTs.  Probably not worth changing, though.)</p>



<a name="274629201"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/274629201" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> erikdesjardins <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#274629201">(Mar 09 2022 at 00:43)</a>:</h4>
<p>ah, see <a href="https://github.com/rust-lang/rust/pull/77844">https://github.com/rust-lang/rust/pull/77844</a> and the linked email thread (particularly here forward: <a href="https://lists.llvm.org/pipermail/llvm-dev/2019-March/131048.html">https://lists.llvm.org/pipermail/llvm-dev/2019-March/131048.html</a>)</p>
<blockquote>
<p>The conclusion for me at least was that <code>getelementptr inbounds</code> with offset 0 is _not_ the identity function, but can sometimes return <code>poison</code> even when the input is a regular pointer -- specifically, it returns <code>poison</code> when this pointer points into something that LLVM "knows has been deallocated", i.e., a former LLVM-managed allocation. It is however the identity function on pointers obtained by casting integers.</p>
</blockquote>
<p>(this is consistent with observed behavior--my ub examples above always use pointers derived from allocations that are definitely out of scope, or pointers moved out of bounds, since i couldn't use <code>inttoptr</code>)</p>
<p>so, because the vec iter code in question here creates the dangling pointer via <code>inttoptr</code>, it doesn't have ub<br>
at least with our current knowledge of llvm semantics</p>



<a name="274630446"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/274630446" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Celina V. <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#274630446">(Mar 09 2022 at 00:59)</a>:</h4>
<p>I understood the opposite from the <a href="https://lists.llvm.org/pipermail/llvm-dev/2019-March/131366.html">last email</a> of the thread you just posted:</p>
<blockquote>
<p>That last part is given by the lang-ref (imo):<br>
  "If the inbounds keyword is present, the result value of the<br>
   getelementptr is a poison value if the base pointer is not an in<br>
   bounds address of an allocated object"</p>
<p>I read this as: If you have a GEPi, you get poison if the base pointer<br>
is not an allocated object. That is a dangling pointer (b) causes the<br>
GEPi to be poison and a pointer from **integer (a) may, if the address<br>
denoted by the integer is not inside, or one past, an allocated object.**<br>
Now any offset except 0 will add more possible ways to generate a poison<br>
value.</p>
</blockquote>



<a name="274631838"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/274631838" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#274631838">(Mar 09 2022 at 01:16)</a>:</h4>
<p>I think this comes into the problem of "allocated object" being unclear.  I might interpret all this using the "<em>based</em> on" rules in <a href="https://llvm.org/docs/LangRef.html#pointeraliasing">https://llvm.org/docs/LangRef.html#pointeraliasing</a></p>
<p>If it's based on an <code>alloca</code> or a thing marked a an allocator (<code>__rust_alloc</code>), then it can become no longer an allocated object despite being a ZST.  But if it's not <em>based on</em> anything (just an int2ptr from a literal) then the options are "that's never allowed for anything" or "we have to assume it's a legal object on the target", and the former is impractical for certain real uses, so I think it always does the latter.</p>
<p>But we could resolve the issue by making one ZST that's max-aligned and always returning that address from <code>dangling</code>, if desired.  Then it'd be based on that one static, and always a valid allocated object.</p>



<a name="274646874"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/274646874" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> erikdesjardins <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#274646874">(Mar 09 2022 at 06:01)</a>:</h4>
<p>I think the author of that email gets confused by that point in the thread. "The address denoted by the integer is not inside, or one past, an allocated object" is not something knowable by LLVM, because pointers created from integer constants can refer to memory allocated outside LLVM. So we can just say "there's a {ZST/memory mapped io/etc.} at that address" and it can't assume otherwise.</p>
<p>This is definitely unsatisfying. There doesn't seem to be a clear answer--LLVM IR semantics are <a href="https://github.com/rust-lang/rust/pull/77844#discussion_r524992199">quicksand</a>, the best we can do is try not to <del>sink completely</del> cause miscompiles in practice</p>



<a name="274646878"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/274646878" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> erikdesjardins <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#274646878">(Mar 09 2022 at 06:01)</a>:</h4>
<blockquote>
<p>But we could resolve the issue by making one ZST that's max-aligned and always returning that address from dangling, if desired. Then it'd be based on that one static, and always a valid allocated object.</p>
</blockquote>
<p>We could do that, and Alive agrees that using a global ZST with gepi offset 0 is well defined: <a href="https://alive2.llvm.org/ce/z/LKPkVG">https://alive2.llvm.org/ce/z/LKPkVG</a>.<br>
Or something like the empty slice implementation from upthread</p>



<a name="275310687"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/275310687" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Celina V. <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#275310687">(Mar 14 2022 at 23:14)</a>:</h4>
<p>This might be a dumb question, but Is the <code>inbounds</code> version of <code>gep</code> required for this case?</p>



<a name="275331900"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/275331900" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> erikdesjardins <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#275331900">(Mar 15 2022 at 05:41)</a>:</h4>
<p><em>Technically</em> it's never required: it would be legal for an LLVM pass to drop <code>inbounds</code> from all gep instructions.</p>
<p>But not having it inhibits optimizations, e.g. in this quickly-thrown-together example, removing <code>inbounds</code> (from everywhere) prevents vectorization, probably because LLVM can no longer tell that pointers computed from <code>x</code> and <code>y</code> can't alias: <a href="https://godbolt.org/z/o6WsG96oq">https://godbolt.org/z/o6WsG96oq</a>.</p>
<p>And since the slice iter code in question is often used in hot loops, removing <code>inbounds</code> in this case would probably cause perf regressions for the same reason.</p>



<a name="275434625"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/275434625" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Celina V. <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#275434625">(Mar 15 2022 at 21:01)</a>:</h4>
<p>I'm only talking about the specific dangling pointer case, which only happens when capacity is 0.</p>



<a name="275441754"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/275441754" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> erikdesjardins <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#275441754">(Mar 15 2022 at 22:00)</a>:</h4>
<p>I don't quite understand what you're getting at. <code>inttoptr</code> does inhibit alias analysis, but that doesn't seem 100% relevant here--my last godbolt example doesn't include <code>intttoptr</code>, and <code>x</code> is an argument that could be dangling or not at runtime, yet optimizations are still affected by the presence/absense of <code>inbounds</code>.</p>
<p>If you mean changing the code to not execute the gep for 0:</p>
<div class="codehilite"><pre><span></span><code>if slice.len() &gt; 0 {
    ptr.add(slice.len())
} else {
    ptr
}
</code></pre></div>
<p>...that is also likely to cause perf regressions, since it introduces a branch in hot code.</p>



<a name="276108232"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/276108232" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Celina V. <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#276108232">(Mar 21 2022 at 20:22)</a>:</h4>
<p>I understand that it would inflict some performance issue, but there's a question of how much that would be and whether it is worth it. If using <code>gepi</code> here can lead to incorrect behavior, it might be worth considering a different implementation, even if it causes some performance deterioration.</p>



<a name="276108313"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/276108313" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Celina V. <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#276108313">(Mar 21 2022 at 20:22)</a>:</h4>
<p>BTW, I bumped into this paper today that is quite interesting: <a href="https://dl.acm.org/doi/10.1145/3276495">https://dl.acm.org/doi/10.1145/3276495</a></p>



<a name="276140399"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/276140399" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#276140399">(Mar 22 2022 at 03:39)</a>:</h4>
<p>relevant to this thread:</p>
<p><span class="user-mention silent" data-user-id="137587">Gankra</span> <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/strict.20provenance.20std.20compat.20notes/near/276138165">said</a>:</p>
<blockquote>
<p>llvm underspecifies it, i got the llvm maintainers to agree it's a reasonable interpretation that there are allocations of size 0 everywhere</p>
</blockquote>



<a name="277040012"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/277040012" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Celina V. <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#277040012">(Mar 29 2022 at 17:32)</a>:</h4>
<p>Just to make sure I understand, we are saying that dangling pointer arithmetic operations are well defined because the dangling pointer was created by casting an integer. If that's the case, any chance we can update the safety rules for pointer arithmetic operations such as <code>add</code>? Maybe something like:</p>
<blockquote>
<p>Both the starting and resulting pointer must be either in bounds or one byte past the end of the same allocated object, or the starting pointer was created by casting any non-zero integer.</p>
</blockquote>



<a name="277050410"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/277050410" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#277050410">(Mar 29 2022 at 18:58)</a>:</h4>
<p>I think what I quoted only makes the no-op <code>add(0)</code> ok</p>



<a name="277178119"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/277178119" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Celina V. <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#277178119">(Mar 30 2022 at 17:17)</a>:</h4>
<p>So what about something like:</p>
<blockquote>
<p>Both the starting and resulting pointer must be either in bounds or one byte past the end of the same allocated object. This does not apply if the requested offset is 0, in which case the operation is a no-op.</p>
</blockquote>



<a name="277190065"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/277190065" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#277190065">(Mar 30 2022 at 18:49)</a>:</h4>
<p>i don't think there are non-zero sized allocations everywhere though</p>



<a name="277190105"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/277190105" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#277190105">(Mar 30 2022 at 18:49)</a>:</h4>
<p>in fact i know there aren't</p>



<a name="277190943"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/277190943" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#277190943">(Mar 30 2022 at 18:55)</a>:</h4>
<p>Yeah, I think that the <code>dangling().add(0)</code> is ok, but <code>dangling().wrapping_offset(10).add(0)</code> <strong>isn't</strong>, because the <code>wrapping_offset</code> moved off of the zero-sized allocation, and thus the <code>.add(0)</code> is invalid despite the <code>0</code>.</p>



<a name="277215970"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/277215970" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Celina V. <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#277215970">(Mar 30 2022 at 23:35)</a>:</h4>
<p>Any suggestion on how to capture the conditions necessary for this to be safe and not an UB?</p>



<a name="277223311"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/277223311" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#277223311">(Mar 31 2022 at 01:37)</a>:</h4>
<p>I think as long as LLVM doesn't fully specify it, Rust can't either. What Rust can offer is a subset of what LLVM can perform.</p>



<a name="277345113"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/277345113" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Celina V. <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#277345113">(Mar 31 2022 at 21:55)</a>:</h4>
<p>I totally agree with that. But to me that is basically the definition of UB. If we cannot guarantee LLVM behavior, the safe thing to do is for Rust to assume this is UB.</p>



<a name="277347460"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/277347460" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#277347460">(Mar 31 2022 at 22:17)</a>:</h4>
<p>The middle ground is that we accept the soft promise of LLVM's behavior for our implementation in std, but we don't make any external promises about this ourselves in docs/reference/etc.</p>



<a name="277354788"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/277354788" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Waffle Lapkin <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#277354788">(Mar 31 2022 at 23:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations/near/272980519">said</a>:</p>
<blockquote>
<p>Although it gives zero guarantees of returning the same pointer each time</p>
</blockquote>
<p>It's a zero argument <code>const</code> function, it's guaranteed to always return the same value.</p>



<a name="277354993"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/277354993" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#277354993">(Mar 31 2022 at 23:52)</a>:</h4>
<p>Heh, want to bet?</p>



<a name="277465566"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/277465566" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nikomatsakis <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#277465566">(Apr 01 2022 at 19:08)</a>:</h4>
<p>So I've skimmed this thread and I wanted to share a few thoughts:</p>
<p>My take is that it is perfectly reasonable for the stdlib to depend on specific behavior of LLVM (i.e., "this is theoretically UB but not in reality"). The premise is: if LLVM were to change their behavior, we could adapt the stdlib to do something different, and everybody's code would be fixed. This works because nobody gets to choose not to upgrade libstd when they upgrade Rust (and hence get the new LLVM). </p>
<p>In contrast, I think that people putting code in <a href="http://crates.io">crates.io</a> wouldn't want to rely on these assumptions.</p>
<p>Effectively, relying on LLVM's behavior here is the equivalent of relying on any other <em>unstable feature of rustc</em> -- it works in a certain way right now, but it might change in the future, and that's ok because libstd can change to match.</p>
<p>What I am <strong>not</strong> super happy about that is that this reliance is very implicit. I wonder if it woudl make sense to add an internal intrinsic or other function that clearly documents the guarantee in question and call that instead. Internally, it would just be the same as pointer-add, but then <span class="user-mention" data-user-id="442621">@Celina V.</span>'s tool could detect that we are using it and ignore that code as "not UB" (the compiler documented it was ok!), while still detecting code in the <a href="http://crates.io">crates.io</a> ecosystem that makes a similar assumption.</p>
<p>Moreover, we would have that assumption more clearly documented for ourselves.</p>
<p>Thoughts?</p>



<a name="277467550"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/277467550" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jak{e,ob} Degen <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#277467550">(Apr 01 2022 at 19:28)</a>:</h4>
<p>Those seem like good steps; how does this interact with compatibility across LLVM versions? Is there a potential hazard here where we accidentally make some rustc versions and some LLVM versions incompatible in a way that we don't want to?</p>



<a name="277474415"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/277474415" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#277474415">(Apr 01 2022 at 20:34)</a>:</h4>
<p>that is certainly a <em>potential</em> hazard, yes.</p>



<a name="277700918"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/277700918" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#277700918">(Apr 04 2022 at 08:54)</a>:</h4>
<p>"The premise is: if LLVM were to change their behavior, we could adapt the stdlib to do something different, and everybody's code would be fixed. This works because nobody gets to choose not to upgrade libstd when they upgrade Rust (and hence get the new LLVM)." - I would not like to rely on this property too much. Although it is a long way off and a big change, I think that if we could make std more like a regular crate, it would have a lot of advantages around versioning, etc.</p>



<a name="277729631"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/277729631" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#277729631">(Apr 04 2022 at 13:21)</a>:</h4>
<p>I would like to make std more like a regular crate, but I'm not sure I like the idea of allowing you to select std's version. I'm thinking <code>[dependencies] std = { default-features = false, features = ["core", "alloc"] }</code>, with presumably it being an error to use a version field there. Maybe it would be fine, but I need to think about the consequences</p>



<a name="277729915"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/277729915" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#277729915">(Apr 04 2022 at 13:23)</a>:</h4>
<p>How do you use this w/o cargo?</p>



<a name="277730002"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/277730002" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#277730002">(Apr 04 2022 at 13:24)</a>:</h4>
<p>however Cargo passes the -Zbuild-std information to rustc today</p>



<a name="277730084"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/277730084" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#277730084">(Apr 04 2022 at 13:25)</a>:</h4>
<p>Which is build the stdlib crate using cargo.</p>



<a name="277730135"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/277730135" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#277730135">(Apr 04 2022 at 13:25)</a>:</h4>
<p>where "using Cargo" ultimately just means using rustc</p>



<a name="277730265"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/277730265" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#277730265">(Apr 04 2022 at 13:26)</a>:</h4>
<p>The important part is that it builds a matching std shipped with rustc.</p>



<a name="277732920"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/277732920" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#277732920">(Apr 04 2022 at 13:47)</a>:</h4>
<p><span class="user-mention silent" data-user-id="256342">bstrie</span> <a href="#narrow/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations/near/277730135">said</a>:</p>
<blockquote>
<p>where "using Cargo" ultimately just means using rustc</p>
</blockquote>
<p>Well... resolving dependencies, determining rustc args, then invoking rustc a dozen or so times.</p>



<a name="277733011"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/277733011" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#277733011">(Apr 04 2022 at 13:47)</a>:</h4>
<p>sure, just like building dependencies generally, so I'm not sure what the objection is</p>



<a name="277733067"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/277733067" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#277733067">(Apr 04 2022 at 13:48)</a>:</h4>
<p>(Oh, and since vendoring doesn't work with stdlib deps IIRC, good luck if you need to build w/o an internet connection)</p>



<a name="277744253"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/277744253" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#277744253">(Apr 04 2022 at 15:03)</a>:</h4>
<p>That is a limitation of the way the standard library source is distributed. IMO it should be distributed with vendored dependencies just like the full rust source tarball.</p>



<a name="277744524"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/277744524" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#277744524">(Apr 04 2022 at 15:05)</a>:</h4>
<p>without getting too much into the weeds here, I would prefer to avoid design choices which limit our options with ways in which std can be built, if possible. Whether we should change the way std is built is a question which might change over time</p>



<a name="278065069"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/278065069" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Celina V. <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#278065069">(Apr 06 2022 at 18:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="138448">cuviper</span> <a href="#narrow/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations/near/277347460">said</a>:</p>
<blockquote>
<p>The middle ground is that we accept the soft promise of LLVM's behavior for our implementation in std, but we don't make any external promises about this ourselves in docs/reference/etc.</p>
</blockquote>
<p>I think that makes sense. What do you think about adding an internal function that would be used by <code>std</code>, like suggested by <span class="user-mention" data-user-id="116009">@nikomatsakis</span>? That way we can document the exact behavior of each function and explicitly call out the assumption we are making inside <code>std</code>.</p>



<a name="278073153"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/278073153" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#278073153">(Apr 06 2022 at 19:21)</a>:</h4>
<p>I think the strict provenance stuff might be leading somewhere close to that.  Like we could potentially say "if you used <code>ptr::invalid</code>, then it's UB even to <code>.offset(0)</code>", and have a different thing (maybe <code>conjure_zst_ref</code> like I posited in <a href="https://github.com/rust-lang/rust/pull/95385#issuecomment-1086472902">https://github.com/rust-lang/rust/pull/95385#issuecomment-1086472902</a> ) for getting a fresh "zero size allocation", on which <code>.offset(0)</code> <em>would</em> be completely legal -- even if they both happen to just do an <code>as</code> cast today.</p>



<a name="278543763"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/278543763" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#278543763">(Apr 11 2022 at 12:11)</a>:</h4>
<p>Oh I had entirely missed this thread, and yet it seems very relevant to the stuff I think about. ;)</p>



<a name="278543877"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/278543877" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#278543877">(Apr 11 2022 at 12:12)</a>:</h4>
<p>FWIW I think the following is a nice symmetry principle that Miri implements and that I use as guide when figuring out inbounds ptr arithmetic rules: <code>ptr.add(n)</code> is allowed if and only if doing an <code>n*size</code>-byte load starting at <code>ptr</code> would be considered allowed as far as bounds checks goes (i.e., ignoring aliasing restrictions).</p>



<a name="278544015"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/278544015" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#278544015">(Apr 11 2022 at 12:14)</a>:</h4>
<p>also see <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/299">https://github.com/rust-lang/unsafe-code-guidelines/issues/299</a> and <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/93">https://github.com/rust-lang/unsafe-code-guidelines/issues/93</a> for the specific case of <code>.add(0)</code></p>



<a name="278544188"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/278544188" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#278544188">(Apr 11 2022 at 12:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="125270">scottmcm</span> <a href="#narrow/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations/near/277190943">said</a>:</p>
<blockquote>
<p>Yeah, I think that the <code>dangling().add(0)</code> is ok, but <code>dangling().wrapping_offset(10).add(0)</code> <strong>isn't</strong>, because the <code>wrapping_offset</code> moved off of the zero-sized allocation, and thus the <code>.add(0)</code> is invalid despite the <code>0</code>.</p>
</blockquote>
<p>hm, my symmetry principle doesn't really answer this one. what Miri currently implements is: if <code>dangling</code> here is <code>ptr::invalid(n)</code> with n ≠ 0, then both of these are allowed. <code>invalid</code> does not have provenance, so <code>invalid(10)</code> and <code>invalid(5).wrapping_offset(5)</code> produce fully identical results.</p>



<a name="278544387"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/278544387" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#278544387">(Apr 11 2022 at 12:17)</a>:</h4>
<p>I don't see any good reason to make <code>invalid(5).wrapping_offset(5).add(0)</code> be UB, other than "LLVM makes it UB" -- and whether it does that, I do not know.</p>



<a name="278582163"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/278582163" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#278582163">(Apr 11 2022 at 16:45)</a>:</h4>
<p>Maybe we should just ask LLVM (again) about their stance on this, and get them to commit <em>something</em> to the LangRef? I've been meaning to bring up this question in their forum for a while now...</p>



<a name="278589812"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/278589812" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#278589812">(Apr 11 2022 at 17:39)</a>:</h4>
<p>Definitely getting <em>something</em> in the LangRef would be nice.  I don't know if <a href="#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/strict.20provenance.20std.20compat.20notes/near/276138165">https://rust-lang.zulipchat.com/#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/strict.20provenance.20std.20compat.20notes/near/276138165</a> got in, for example.</p>



<a name="278590137"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/278590137" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#278590137">(Apr 11 2022 at 17:40)</a>:</h4>
<p>it didnt :/</p>



<a name="278590169"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/278590169" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#278590169">(Apr 11 2022 at 17:40)</a>:</h4>
<p>and I dont know of any public record of that discussion either</p>



<a name="278591183"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/278591183" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#278591183">(Apr 11 2022 at 17:47)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations/near/278544387">said</a>:</p>
<blockquote>
<p>and whether it does that, I do not know.</p>
</blockquote>
<p>I don't either, but it seems to me like the "there are zero-size allocations" everywhere model means that it'd be UB because it moved outside the allocation, then did an <code>inbounds</code>.</p>



<a name="278592937"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/278592937" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nikomatsakis <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#278592937">(Apr 11 2022 at 17:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="256841">Nick Cameron</span> <a href="#narrow/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations/near/277744524">said</a>:</p>
<blockquote>
<p>without getting too much into the weeds here, I would prefer to avoid design choices which limit our options with ways in which std can be built, if possible. Whether we should change the way std is built is a question which might change over time</p>
</blockquote>
<p>I don't believe that this decision moves us any further-or-closer to that goal in particular. I'm generally on board with std being less reliant on nightly features; but in this case, it's a relatively minor deal to remove later, albeit at some performance penalty.</p>



<a name="278594020"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/278594020" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#278594020">(Apr 11 2022 at 18:06)</a>:</h4>
<p><span class="user-mention silent" data-user-id="125270">scottmcm</span> <a href="#narrow/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations/near/278591183">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations/near/278544387">said</a>:</p>
<blockquote>
<p>and whether it does that, I do not know.</p>
</blockquote>
<p>I don't either, but it seems to me like the "there are zero-size allocations" everywhere model means that it'd be UB because it moved outside the allocation, then did an <code>inbounds</code>.</p>
</blockquote>
<p>yeah... but I dont want to generate a unique provenance for each of these zero-sized allocations in Miri :/</p>



<a name="278594056"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/278594056" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#278594056">(Apr 11 2022 at 18:07)</a>:</h4>
<p>and I dont think LLVM actually <em>gains</em> anything by making that UB. so it feels rather silly.</p>



<a name="278594350"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/278594350" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#278594350">(Apr 11 2022 at 18:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="256841">Nick Cameron</span> <a href="#narrow/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations/near/277700918">said</a>:</p>
<blockquote>
<p>"The premise is: if LLVM were to change their behavior, we could adapt the stdlib to do something different, and everybody's code would be fixed. This works because nobody gets to choose not to upgrade libstd when they upgrade Rust (and hence get the new LLVM)." - I would not like to rely on this property too much. Although it is a long way off and a big change, I think that if we could make std more like a regular crate, it would have a lot of advantages around versioning, etc.</p>
</blockquote>
<p>FWIW, there are quite a few things in std that rely on being able to break rustc's abstraction boundary (i.e., rely on unspecified implementation details). <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/90">https://github.com/rust-lang/unsafe-code-guidelines/issues/90</a> is a very incomplete list of such situations.</p>



<a name="278596709"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/278596709" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#278596709">(Apr 11 2022 at 18:27)</a>:</h4>
<p>Hmm, <code>if d != 0 { x.add(d) } else { x }</code> optimizes to a <strong>non</strong>-<code>inbounds</code> GEP (<a href="https://rust.godbolt.org/z/vrdK8bMGs">https://rust.godbolt.org/z/vrdK8bMGs</a>), which suggests that at least right now they don't believe <code>.add(0)</code> is always ok.</p>
<p>EDIT: oh, that's just because the pointer is nullable, per alive2</p>



<a name="278598757"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Behavior%20of%20dangling%20pointer%20arithmetic%20operations/near/278598757" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations.html#278598757">(Apr 11 2022 at 18:39)</a>:</h4>
<p>Hmm, no matter how hard I try I can't convince alive that <code>.add(0)</code> is a nop: <a href="https://alive2.llvm.org/ce/z/WuQ7Kr">https://alive2.llvm.org/ce/z/WuQ7Kr</a></p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>