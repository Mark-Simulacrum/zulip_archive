<html>
<head><meta charset="utf-8"><title>`core::arch::x86_64::cmpxchg16b` stability? · t-libs · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/index.html">t-libs</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/.60core.3A.3Aarch.3A.3Ax86_64.3A.3Acmpxchg16b.60.20stability.3F.html">`core::arch::x86_64::cmpxchg16b` stability?</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="264394588"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/%60core%3A%3Aarch%3A%3Ax86_64%3A%3Acmpxchg16b%60%20stability%3F/near/264394588" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Thom Chiovoloni <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/.60core.3A.3Aarch.3A.3Ax86_64.3A.3Acmpxchg16b.60.20stability.3F.html#264394588">(Dec 10 2021 at 02:01)</a>:</h4>
<p>So, <code>cmpxchg16b</code> has been unstable for a while: <a href="https://doc.rust-lang.org/nightly/core/arch/x86_64/fn.cmpxchg16b.html">https://doc.rust-lang.org/nightly/core/arch/x86_64/fn.cmpxchg16b.html</a></p>
<p>I always assumed it was a decision about not wanting the only access to 128 bit atomics be through a platform intrinsic, but <a href="https://github.com/rust-lang/stdarch/issues/827">https://github.com/rust-lang/stdarch/issues/827</a> indicates that perhaps it was actually just forgotten (or is this deliberate, and decision just happened elsewhere?)</p>
<p>Either way, with <code>asm!</code> perhaps stabilizing soon, it seems a little silly for this to remain unstable as well, given that inline assembly provides access to this functionality anyway, but in a more annoying to use form (substantially so — u128 is not exactly easily used in <code>asm!</code>).</p>
<p>Do people feel warmly towards stabilizing this? If so, what would the path be towards that?</p>



<a name="264403146"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/%60core%3A%3Aarch%3A%3Ax86_64%3A%3Acmpxchg16b%60%20stability%3F/near/264403146" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/.60core.3A.3Aarch.3A.3Ax86_64.3A.3Acmpxchg16b.60.20stability.3F.html#264403146">(Dec 10 2021 at 04:54)</a>:</h4>
<p>I think it'd be appropriate to stabilize this. If someone posted a stabilization PR, I'd be happy to FCP it.</p>



<a name="266615111"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/%60core%3A%3Aarch%3A%3Ax86_64%3A%3Acmpxchg16b%60%20stability%3F/near/266615111" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Thom Chiovoloni <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/.60core.3A.3Aarch.3A.3Ax86_64.3A.3Acmpxchg16b.60.20stability.3F.html#266615111">(Jan 02 2022 at 13:50)</a>:</h4>
<p>So that PR would be against... rust-lang/stdarch (since that's where the definition lives)?</p>



<a name="266615131"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/%60core%3A%3Aarch%3A%3Ax86_64%3A%3Acmpxchg16b%60%20stability%3F/near/266615131" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Thom Chiovoloni <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/.60core.3A.3Aarch.3A.3Ax86_64.3A.3Acmpxchg16b.60.20stability.3F.html#266615131">(Jan 02 2022 at 13:50)</a>:</h4>
<p>(This (and vacation) has been most of why I've not filed one yet)</p>



<a name="266619178"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/%60core%3A%3Aarch%3A%3Ax86_64%3A%3Acmpxchg16b%60%20stability%3F/near/266619178" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/.60core.3A.3Aarch.3A.3Ax86_64.3A.3Acmpxchg16b.60.20stability.3F.html#266619178">(Jan 02 2022 at 15:35)</a>:</h4>
<p>RE. stabilizing <code>Atomic{U,I}128</code>, wouldn't that bear a problem of not being an architecturally available atomic (since it depends on a target feature)? So it still wouldn't be available on x86_64, unless rustc (or others) adds support for the SysV architecture levels for x86_64 (x86_64v2 does require the cmpxchg16b feature by default), and then only on those targets. <br>
This is, at least, the reasoning I used in lccc, which doesn't indicate 16-byte lock-free atomic support for x86_64 (See &lt;<a href="https://github.com/LightningCreations/lccc/blob/1c39bb370a1df223fa9d3c88f4610abdb31c6667/xlang/xlang_targets/src/properties/x86.rs#L151">https://github.com/LightningCreations/lccc/blob/1c39bb370a1df223fa9d3c88f4610abdb31c6667/xlang/xlang_targets/src/properties/x86.rs#L151</a>&gt;).</p>



<a name="266624871"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/%60core%3A%3Aarch%3A%3Ax86_64%3A%3Acmpxchg16b%60%20stability%3F/near/266624871" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/.60core.3A.3Aarch.3A.3Ax86_64.3A.3Acmpxchg16b.60.20stability.3F.html#266624871">(Jan 02 2022 at 17:44)</a>:</h4>
<blockquote>
<p>unless rustc (or others) adds support for the SysV architecture levels for x86_64</p>
</blockquote>
<p>That's already supported. <code>-Ctarget-cpu=x86-64-v2</code></p>



<a name="266624988"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/%60core%3A%3Aarch%3A%3Ax86_64%3A%3Acmpxchg16b%60%20stability%3F/near/266624988" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/.60core.3A.3Aarch.3A.3Ax86_64.3A.3Acmpxchg16b.60.20stability.3F.html#266624988">(Jan 02 2022 at 17:47)</a>:</h4>
<p>but that leaves the problem that <code>cmpxchg16b</code> is a relatively poor way to do 128bit atomics when you don't have 128bit loads and stores.</p>



<a name="266625047"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/%60core%3A%3Aarch%3A%3Ax86_64%3A%3Acmpxchg16b%60%20stability%3F/near/266625047" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/.60core.3A.3Aarch.3A.3Ax86_64.3A.3Acmpxchg16b.60.20stability.3F.html#266625047">(Jan 02 2022 at 17:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="330154">The 8472</span> <a href="#narrow/stream/219381-t-libs/topic/.60core.3A.3Aarch.3A.3Ax86_64.3A.3Acmpxchg16b.60.20stability.3F/near/266624871">said</a>:</p>
<blockquote>
<blockquote>
<p>unless rustc (or others) adds support for the SysV architecture levels for x86_64</p>
</blockquote>
<p>That's already supported. <code>-Ctarget-cpu=x86-64-v2</code></p>
</blockquote>
<p>That wouldn't use it architecturally, though, only the CPU features mandated by the ABI.</p>



<a name="266625210"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/%60core%3A%3Aarch%3A%3Ax86_64%3A%3Acmpxchg16b%60%20stability%3F/near/266625210" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/.60core.3A.3Aarch.3A.3Ax86_64.3A.3Acmpxchg16b.60.20stability.3F.html#266625210">(Jan 02 2022 at 17:52)</a>:</h4>
<p>By architecturally you mean llvm being able to turn the 128bit atomic ops into cmpxchg16b?</p>



<a name="266627109"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/%60core%3A%3Aarch%3A%3Ax86_64%3A%3Acmpxchg16b%60%20stability%3F/near/266627109" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/.60core.3A.3Aarch.3A.3Ax86_64.3A.3Acmpxchg16b.60.20stability.3F.html#266627109">(Jan 02 2022 at 18:39)</a>:</h4>
<p><code>AtomicU128</code> and <code>AtomicI128</code> can only exist if the target spec said that 128bit atomics are supported while compiling libcore.</p>



<a name="266629907"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/%60core%3A%3Aarch%3A%3Ax86_64%3A%3Acmpxchg16b%60%20stability%3F/near/266629907" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Thom Chiovoloni <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/.60core.3A.3Aarch.3A.3Ax86_64.3A.3Acmpxchg16b.60.20stability.3F.html#266629907">(Jan 02 2022 at 19:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="209168">Thom Chiovoloni</span> <a href="#narrow/stream/219381-t-libs/topic/.60core.3A.3Aarch.3A.3Ax86_64.3A.3Acmpxchg16b.60.20stability.3F/near/266615111">said</a>:</p>
<blockquote>
<p>So that PR would be against... rust-lang/stdarch (since that's where the definition lives)?</p>
</blockquote>
<p>Erm, sorry, to be clear: this is a question. I thought stabilization PRs were supposed to be against rust-lang/rust, but the code that stabilizes this doesn't live there. Is that okay?</p>



<a name="266631744"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/%60core%3A%3Aarch%3A%3Ax86_64%3A%3Acmpxchg16b%60%20stability%3F/near/266631744" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/.60core.3A.3Aarch.3A.3Ax86_64.3A.3Acmpxchg16b.60.20stability.3F.html#266631744">(Jan 02 2022 at 20:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="133247">bjorn3</span> <a href="#narrow/stream/219381-t-libs/topic/.60core.3A.3Aarch.3A.3Ax86_64.3A.3Acmpxchg16b.60.20stability.3F/near/266627109">said</a>:</p>
<blockquote>
<p><code>AtomicU128</code> and <code>AtomicI128</code> can only exist if the target spec said that 128bit atomics are supported while compiling libcore.</p>
</blockquote>
<p>That's what I thought of rustc. That's currently true of lccc as well, as my plan was only to query the lock-free atomic mask in the target properties when setting <code>target_has_atomic</code>.</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>