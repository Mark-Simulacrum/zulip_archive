<html>
<head><meta charset="utf-8"><title>Possible variation of RFC 2930 (ReadBuf) · t-libs · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/index.html">t-libs</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Possible.20variation.20of.20RFC.202930.20(ReadBuf).html">Possible variation of RFC 2930 (ReadBuf)</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="264166330"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Possible%20variation%20of%20RFC%202930%20%28ReadBuf%29/near/264166330" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Possible.20variation.20of.20RFC.202930.20(ReadBuf).html#264166330">(Dec 08 2021 at 14:58)</a>:</h4>
<p>I'm sure this has been considered, but I couldn't find discussion after a casual dig through the mountain of discussion around reading into uninit memory. Could we introduce a new trait, call it Read2 as a total strawman, that has <code>read</code> with the <code>ReadBuf</code> argument, rather than adding a new method to the existing Read trait?</p>
<p>We could add a default impl: <code>impl&lt;T: Read&gt; Read2 for T</code> which wraps the u8 slice in a ReadBuf, so all existing impls of Read have baseline compatiblity, then change all uses of Read to Read2. The downside is back compat where you have a Read2 object and something expects a Read argument, in which case you hit a slow path and have to zero memory, but this seems no worse than using the default impl of read_buf in the current proposal.</p>



<a name="264170144"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Possible%20variation%20of%20RFC%202930%20%28ReadBuf%29/near/264170144" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Waffle Lapkin <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Possible.20variation.20of.20RFC.202930.20(ReadBuf).html#264170144">(Dec 08 2021 at 15:22)</a>:</h4>
<p>If there is <code>impl&lt;T: Read&gt; Read2 for T</code>, then types can't both</p>
<ul>
<li>implement <code>Read</code> (needed for compatability) and</li>
<li>implement <code>Read2</code> efficiently (ie without going through initialization and <code>Read</code>)</li>
</ul>



<a name="264170767"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Possible%20variation%20of%20RFC%202930%20%28ReadBuf%29/near/264170767" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Waffle Lapkin <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Possible.20variation.20of.20RFC.202930.20(ReadBuf).html#264170767">(Dec 08 2021 at 15:25)</a>:</h4>
<p>I think this can be solved by providing compatability adapter like <code>struct ReadCompat&lt;R: Read2&gt;(R); impl Read for ReadCompat...</code>.<br>
This would make calling old code from new code more verbose, but it's a solution.</p>



<a name="264171202"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Possible%20variation%20of%20RFC%202930%20%28ReadBuf%29/near/264171202" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Waffle Lapkin <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Possible.20variation.20of.20RFC.202930.20(ReadBuf).html#264171202">(Dec 08 2021 at 15:28)</a>:</h4>
<p>Another way is to invert everything:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Read2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Read</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">ReadCompat</span><span class="o">&lt;</span><span class="n">R</span>: <span class="nc">Read</span><span class="o">&gt;</span><span class="p">(</span><span class="n">R</span><span class="p">);</span><span class="w"></span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">R</span>: <span class="nc">Read</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Read2</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">ReadCompat</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
</code></pre></div>
<p>This way calling new code from old code is more verbose.</p>



<a name="264172896"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Possible%20variation%20of%20RFC%202930%20%28ReadBuf%29/near/264172896" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Possible.20variation.20of.20RFC.202930.20(ReadBuf).html#264172896">(Dec 08 2021 at 15:37)</a>:</h4>
<p>I would expect types could just impl Read2, and when migrating, stop impl'ing Read (since the blanket impl exists, it is not needed for compat, though I guess crates would need to cfg based on Rust version if they wanted to support Rust versions from before the blanket impl is added to std)</p>



<a name="264173847"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Possible%20variation%20of%20RFC%202930%20%28ReadBuf%29/near/264173847" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Waffle Lapkin <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Possible.20variation.20of.20RFC.202930.20(ReadBuf).html#264173847">(Dec 08 2021 at 15:43)</a>:</h4>
<p>Compat can still be needed if both the <code>impl Read</code> and <code>f(_: impl Read)</code> are coming from immutable dependencies</p>



<a name="264174433"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Possible%20variation%20of%20RFC%202930%20%28ReadBuf%29/near/264174433" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Possible.20variation.20of.20RFC.202930.20(ReadBuf).html#264174433">(Dec 08 2021 at 15:47)</a>:</h4>
<p>Could you flesh out that example a bit please, I don’t understand</p>



<a name="264175930"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Possible%20variation%20of%20RFC%202930%20%28ReadBuf%29/near/264175930" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Waffle Lapkin <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Possible.20variation.20of.20RFC.202930.20(ReadBuf).html#264175930">(Dec 08 2021 at 15:56)</a>:</h4>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="c1">// std</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Read2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Read</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* ... */</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</code></pre></div>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="c1">// coolread (old crate)</span>
<span class="k">impl</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">Read</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">ReadImpl</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* ... */</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</code></pre></div>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="c1">// coolwrite (new crate)</span>
<span class="k">fn</span> <span class="nf">write_to_file</span><span class="p">(</span><span class="n">path</span>: <span class="nc">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Path</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">data</span>: <span class="nc">impl</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">Read2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* ... */</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</code></pre></div>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="c1">// your crate</span>
<span class="k">use</span><span class="w"> </span><span class="n">coolread</span>::<span class="n">ReadImpl</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">coolwrite</span>::<span class="n">write_to_file</span><span class="p">;</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">read</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ReadImpl</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>
<span class="n">write_to_file</span><span class="p">(</span><span class="s">"./a"</span><span class="p">,</span><span class="w"> </span><span class="n">read</span><span class="p">);</span><span class="w"> </span><span class="c1">// compilation error</span>
</code></pre></div>



<a name="264180414"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Possible%20variation%20of%20RFC%202930%20%28ReadBuf%29/near/264180414" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Possible.20variation.20of.20RFC.202930.20(ReadBuf).html#264180414">(Dec 08 2021 at 16:26)</a>:</h4>
<p>Ah so, in your original example, the arg to f should be Read2?</p>



<a name="264180538"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Possible%20variation%20of%20RFC%202930%20%28ReadBuf%29/near/264180538" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Possible.20variation.20of.20RFC.202930.20(ReadBuf).html#264180538">(Dec 08 2021 at 16:27)</a>:</h4>
<p>My suggestion is for the blanket impl to be the other way around, so in this case it should compile, I think?</p>



<a name="264212021"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Possible%20variation%20of%20RFC%202930%20%28ReadBuf%29/near/264212021" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Waffle Lapkin <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Possible.20variation.20of.20RFC.202930.20(ReadBuf).html#264212021">(Dec 08 2021 at 20:01)</a>:</h4>
<p><span class="user-mention silent" data-user-id="256841">Nick Cameron</span> <a href="#narrow/stream/219381-t-libs/topic/Possible.20variation.20of.20RFC.202930.20.28ReadBuf.29/near/264180414">said</a>:</p>
<blockquote>
<p>Ah so, in your original example, the arg to f should be Read2?</p>
</blockquote>
<p>Yes, it should have been <code>Read2</code>.</p>
<p><span class="user-mention silent" data-user-id="256841">Nick Cameron</span> <a href="#narrow/stream/219381-t-libs/topic/Possible.20variation.20of.20RFC.202930.20.28ReadBuf.29/near/264180538">said</a>:</p>
<blockquote>
<p>My suggestion is for the blanket impl to be the other way around, so in this case it should compile, I think?</p>
</blockquote>
<p>Yes, <em>this</em> example with your original suggestion works. But there is an example which works the other way around too:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="c1">// std</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Read</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Read2</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* ... */</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</code></pre></div>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="c1">// coolread (new crate this time)</span>
<span class="k">impl</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">Read2</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">ReadImpl</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* ... */</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</code></pre></div>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="c1">// coolwrite (old crate this time)</span>
<span class="k">fn</span> <span class="nf">write_to_file</span><span class="p">(</span><span class="n">path</span>: <span class="nc">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Path</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">data</span>: <span class="nc">impl</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">Read</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* ... */</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</code></pre></div>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="c1">// your crate</span>
<span class="k">use</span><span class="w"> </span><span class="n">coolread</span>::<span class="n">ReadImpl</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">coolwrite</span>::<span class="n">write_to_file</span><span class="p">;</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">read</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ReadImpl</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>
<span class="n">write_to_file</span><span class="p">(</span><span class="s">"./a"</span><span class="p">,</span><span class="w"> </span><span class="n">read</span><span class="p">);</span><span class="w"> </span><span class="c1">// compilation error</span>
</code></pre></div>



<a name="264215148"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Possible%20variation%20of%20RFC%202930%20%28ReadBuf%29/near/264215148" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Possible.20variation.20of.20RFC.202930.20(ReadBuf).html#264215148">(Dec 08 2021 at 20:26)</a>:</h4>
<p>right yeah, this kind of situation would suck. I think it would be relatively easy to provide a compat utility struct, but aiui there isn't a very efficient implementation possible because you have to zero out the uninit memory in the buffer provided to Read2::read</p>



<a name="264215442"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Possible%20variation%20of%20RFC%202930%20%28ReadBuf%29/near/264215442" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Possible.20variation.20of.20RFC.202930.20(ReadBuf).html#264215442">(Dec 08 2021 at 20:28)</a>:</h4>
<p>although, doesn't this happen silently with 2930? As in you don't need any compat shim, but you silently hit slowdown because you have to use the default impl for read?</p>



<a name="264422191"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Possible%20variation%20of%20RFC%202930%20%28ReadBuf%29/near/264422191" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Possible.20variation.20of.20RFC.202930.20(ReadBuf).html#264422191">(Dec 10 2021 at 09:37)</a>:</h4>
<p>cc <span class="user-mention" data-user-id="239881">@Josh Triplett</span> <span class="user-mention" data-user-id="243558">@Steven Fackler</span> any thoughts?</p>



<a name="264433635"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Possible%20variation%20of%20RFC%202930%20%28ReadBuf%29/near/264433635" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Possible.20variation.20of.20RFC.202930.20(ReadBuf).html#264433635">(Dec 10 2021 at 11:29)</a>:</h4>
<p><span class="user-mention" data-user-id="256841">@Nick Cameron</span> I love the <em>idea</em> of a legacy-free trait that only uses <code>ReadBuf</code>, but I don't love the need for compat wrappers.</p>



<a name="264439463"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Possible%20variation%20of%20RFC%202930%20%28ReadBuf%29/near/264439463" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Possible.20variation.20of.20RFC.202930.20(ReadBuf).html#264439463">(Dec 10 2021 at 12:26)</a>:</h4>
<p>I think the RFC discusses the option a bit - my primary concern there was that I wanted libraries consuming an arbitrary <code>Read</code> to be able to take advantage of readbuf without a breaking API change.</p>



<a name="264439653"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Possible%20variation%20of%20RFC%202930%20%28ReadBuf%29/near/264439653" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Possible.20variation.20of.20RFC.202930.20(ReadBuf).html#264439653">(Dec 10 2021 at 12:28)</a>:</h4>
<p>And you could make it decently ergonomic with a little bit of compiler work to support e.g. a lint for "override exactly 1 of read and read_buf"</p>



<a name="264441056"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Possible%20variation%20of%20RFC%202930%20%28ReadBuf%29/near/264441056" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Possible.20variation.20of.20RFC.202930.20(ReadBuf).html#264441056">(Dec 10 2021 at 12:41)</a>:</h4>
<p>I'd <em>love</em> to see compiler support for "here's what sets of methods of a trait you should implement".</p>



<a name="264441097"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Possible%20variation%20of%20RFC%202930%20%28ReadBuf%29/near/264441097" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Possible.20variation.20of.20RFC.202930.20(ReadBuf).html#264441097">(Dec 10 2021 at 12:42)</a>:</h4>
<p>(Minimum and maximum. That would also help for traits that have mutually recursive defaults.)</p>



<a name="264443813"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Possible%20variation%20of%20RFC%202930%20%28ReadBuf%29/near/264443813" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Possible.20variation.20of.20RFC.202930.20(ReadBuf).html#264443813">(Dec 10 2021 at 13:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243558">Steven Fackler</span> <a href="#narrow/stream/219381-t-libs/topic/Possible.20variation.20of.20RFC.202930.20.28ReadBuf.29/near/264439463">said</a>:</p>
<blockquote>
<p>I think the RFC discusses the option a bit - my primary concern there was that I wanted libraries consuming an arbitrary <code>Read</code> to be able to take advantage of readbuf without a breaking API change.</p>
</blockquote>
<p>Do you mean that you want libs to be able to use a <code>Read</code> impl where there is only an implementation of read_buf, and use the default impl of read? Or that you want such libraries to be able to get the perf benefits of using a ReadBuf? (I don't understand how the latter is posible)</p>



<a name="264444220"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Possible%20variation%20of%20RFC%202930%20%28ReadBuf%29/near/264444220" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Possible.20variation.20of.20RFC.202930.20(ReadBuf).html#264444220">(Dec 10 2021 at 13:10)</a>:</h4>
<p>For the lint, I worry that there is a lot to express and at least one of n, or even a min/max is only an approximation. E.g., you might want to force the implementor to impl one of <code>read</code> and <code>read_buf</code> and one of <code>read_vectored</code> and <code>read_buf_vectored</code> (I know we don't actually want this for Read)</p>



<a name="264444311"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Possible%20variation%20of%20RFC%202930%20%28ReadBuf%29/near/264444311" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Possible.20variation.20of.20RFC.202930.20(ReadBuf).html#264444311">(Dec 10 2021 at 13:11)</a>:</h4>
<p>(I wonder if default methods are also too crude a mechanism, but that is a different story, I think)</p>



<a name="264451590"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Possible%20variation%20of%20RFC%202930%20%28ReadBuf%29/near/264451590" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Possible.20variation.20of.20RFC.202930.20(ReadBuf).html#264451590">(Dec 10 2021 at 14:06)</a>:</h4>
<p>To summarize, here are the different approaches</p>
<div class="spoiler-block"><div class="spoiler-header">
<p>Read and read_buf situation summary</p>
</div><div class="spoiler-content" aria-hidden="true">
<h3>1. Add a new <code>Read</code> trait, say <code>ReadIntoReadBuf</code>, with no <code>&amp;'_ mut [u8]</code> API, but a <code>ReadBuf&lt;'_&gt;</code> API.</h3>
<p>Objective: if one of those two traits is implemented, then it should still be possible to interact with APIs requiring the other trait.</p>
<p>The gap can be filled with a blanket impl in one direction, and a <code>.compat()</code> adapter in the other. To consider these approaches, let's assume a <code>::user</code>, <code>::provides_read</code>, and <code>::uses_read</code> crates, with <code>::user</code> depending on these other two crates.</p>
<h4>1.1. <code>impl&lt;R : ?Sized + ReadIntoReadBuf&gt; Read for R {}</code> + <code>.compat()</code> adapter for <code>impl Read -&gt; impl ReadIntoReadBuf</code>.</h4>
<p>Pros:</p>
<ul>
<li>
<p>all the impls are optimal, except for the code of the <code>Compat&lt;…&gt;</code> adapter (this is good: it's nice to have the noisy one feature the suboptimal impl).</p>
</li>
<li>
<p><strong><code>::provides_read</code> can improve its implementation of <code>Read</code> by replacing it with on of <code>ReadIntoReadBuf</code> instead, without breaking semver</strong> / within a minor bump. If <code>::user</code>, itself, where to have an <code>impl ReadIntoReadBuf</code> requirement, then they're all happy.</p>
</li>
</ul>
<p>Cons:</p>
<ul>
<li><strong><code>::uses_read</code> can't improve its logic to take advantage of the new <code>ReadIntoReadBuf</code>, at least not for the already existing APIs</strong>. It will need to either add new APIs itself (<code>stuff</code> -&gt; <code>stuff_read_buf</code>), or to perform a major breaking change. If the major change path is taken, and <code>::user</code> wants to use it, while waiting for <code>::provides_read</code> to catch up, they'll have to temporarily append those <code>.compat()</code> adapters.</li>
</ul>
<h4>1.2. <code>impl&lt;R : ?Sized + Read&gt; ReadIntoReadBuf for R {}</code> + <code>.compat()</code> adapter for <code>impl ReadIntoReadBuf -&gt; impl Read</code>.</h4>
<p>Pros/Cons are swapped <em>w.r.t.</em> the previous situation:</p>
<ul>
<li>
<p><code>::uses_read</code> can now say that its APIs expects an <code>impl ReadIntoReadBuf</code>, and not require a major version bump. But if <code>::provides_read</code> now wants to provide a smarter <code>ReadIntoReadBuf</code> implementation for its type, it will have to let go of the original <code>Read</code> impl because of coherence, and thus so doing would require a major version bump. And, again, <code>::user</code> were to use an updated <code>::provides_read</code>, while waiting for <code>::uses_read</code> to catch up, they'd still need to use <code>.compat()</code> adapters.</p>
</li>
<li>
<p>The blanket impl provides a <em>silent</em> suboptimal implementation of <code>ReadIntoReadBuf</code>, whereas the noisy <code>.compat()</code> would just be featuring a true no-op compatibility layer for a suboptimal consumer.</p>
</li>
</ul>
<hr>
<p>Among these two declinations, I think I personally would lean towards <code>1.1</code></p>
<p>General takeway of <code>1.</code>: requires a new trait (and thus a new name!), and would lead to sometimes requiring major version bumps and/or <code>.compat()</code> wrappers. On top of a deprecated trait lying around.</p>
<h3>2. Add a new <code>read_buf()</code> method to <code>Read</code>, with a default dummy impl</h3>
<ul>
<li>The default "dummy" (zero-filling) impl is needed for retro-compat / to be able to make the method be a default one;</li>
<li>This is the approach suggested by the RFC</li>
</ul>
<p>Pros:</p>
<ul>
<li>No new trait</li>
<li>Everybody is compatible with everybody, any of <code>::uses_read</code> or <code>::provides_read</code> can improve their stuff on their own end, without breaking the other side (it will just lead to a situation where the improved implementation won't be used, as it happened with <code>.compat()</code> which made that explicit, but at the cost of requiring it / of otherwise breaking code). Once both ends provide their improved implementations, <code>::user</code> suddenly benefits from a performance boost, and all happening within "transparent" minor bumps.</li>
</ul>
<p>Cons:</p>
<ul>
<li>People explicitly overriding <code>read_buf</code> (on top of potentially forgetting to do so!) would still be required to provide an explicit body for <code>fn read()</code>, since it's a mandatory method. Not that big of a deal, but it does leave an after-taste of not-totally-polished design that doesn't suit stdlib-quality APIs.</li>
</ul>
<p>I personally have to admit that this doesn't look as bad as <code>1.</code>'s transitioning phase, even if long-term it would be worse <strong>if no palliative measures were applied</strong>. Good news is, we could always provide such measures in the interim to still have a nice mid-to-long-term situation <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span> </p>
<h3>2.1. Palliative measures (potentially requiring new features and/or new lints) for the <code>fn read(…)…; fn read_buf(…) … { … }</code></h3>
<p>Key idea: <strong>make <code>fn read (…) { … }</code> default as well by delegating to <code>read_buf</code>. But</strong> since <code>read_buf()</code>'s default impl already delegates to <code>read(…)</code>, <strong>people could "miswrite" an <code>impl Read</code> and "forget" to write any methods, <em>with the compiler not saying anything</em>, and leading to infinite recursions at runtime</strong></p>
<p>Solution: make the compiler "say a thing" when that happens. A basic implementation would be to make <code>Read</code> be a <code>#[lang]</code> item, and hardcode / special-case that impl.</p>
<p>A nicer way would be to provide a more general tool for this pattern, which technically applies to other traits as well (<em>e.g.</em>, <code>PartialEq::{eq, ne}</code>):</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">trait</span><span class="w"> </span><span class="n">Read</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">read</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="cp">#![requires(fn read_buf)]</span><span class="w"></span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">read_buf</span><span class="p">(</span><span class="n">ReadBuf</span>::<span class="n">new</span><span class="p">(</span><span class="n">buf</span><span class="p">)).</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="p">()</span><span class="o">|</span><span class="w"> </span><span class="n">buf</span><span class="p">.</span><span class="n">filled</span><span class="p">().</span><span class="n">len</span><span class="p">())</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">read_buf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span>: <span class="nc">ReadBuf</span><span class="o">&lt;'</span><span class="nb">_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="cp">#![requires(fn read)]</span><span class="w"></span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">buf</span><span class="p">.</span><span class="n">initialize_unfilled</span><span class="p">()).</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">n</span><span class="o">|</span><span class="w"> </span><span class="n">buf</span><span class="p">.</span><span class="n">add_filled</span><span class="p">(</span><span class="n">n</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>so that</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">impl</span><span class="w"> </span><span class="n">Read</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">MyThing</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
</code></pre></div>
<p>would cause:</p>
<div class="codehilite" data-code-language="Bash Session"><pre><span></span><code><span class="go">Error: cycle detected when resolving the default implementations requirements.</span>
<span class="go">info = `fn read_buf` requires `fn read`, which requires `fn read_buf`, completing the cycle.</span>
<span class="go">note = you may need to provide an explicit implementation of one of these methods</span>
</code></pre></div>
<p>A hacky way would be to make the <code>infinite_recursion</code> smart enough to detect this problem and lint against it; although the error message wouldn't look great</p>
</div></div>



<a name="264457788"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Possible%20variation%20of%20RFC%202930%20%28ReadBuf%29/near/264457788" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Thom Chiovoloni <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Possible.20variation.20of.20RFC.202930.20(ReadBuf).html#264457788">(Dec 10 2021 at 14:54)</a>:</h4>
<p>(off topic but how did you do this zulip magic?)</p>



<a name="264464646"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Possible%20variation%20of%20RFC%202930%20%28ReadBuf%29/near/264464646" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ibraheem Ahmed <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Possible.20variation.20of.20RFC.202930.20(ReadBuf).html#264464646">(Dec 10 2021 at 15:41)</a>:</h4>
<p>(<a href="https://zulip.com/help/format-your-message-using-markdown#spoilers">https://zulip.com/help/format-your-message-using-markdown#spoilers</a>)</p>



<a name="264500296"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Possible%20variation%20of%20RFC%202930%20%28ReadBuf%29/near/264500296" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Possible.20variation.20of.20RFC.202930.20(ReadBuf).html#264500296">(Dec 10 2021 at 20:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243558">Steven Fackler</span> <a href="#narrow/stream/219381-t-libs/topic/Possible.20variation.20of.20RFC.202930.20.28ReadBuf.29/near/264439653">said</a>:</p>
<blockquote>
<p>And you could make it decently ergonomic with a little bit of compiler work to support e.g. a lint for "override exactly 1 of read and read_buf"</p>
</blockquote>
<p>There are <em>so</em> many places where this would be handy.  Here's a relevant old IRLO thread: <a href="https://internals.rust-lang.org/t/brainstorming-allowing-implementing-just-try-fold-and-getting-next-free/9417?u=scottmcm">https://internals.rust-lang.org/t/brainstorming-allowing-implementing-just-try-fold-and-getting-next-free/9417?u=scottmcm</a></p>



<a name="264513431"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Possible%20variation%20of%20RFC%202930%20%28ReadBuf%29/near/264513431" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Possible.20variation.20of.20RFC.202930.20(ReadBuf).html#264513431">(Dec 10 2021 at 21:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="256841">Nick Cameron</span> <a href="#narrow/stream/219381-t-libs/topic/Possible.20variation.20of.20RFC.202930.20.28ReadBuf.29/near/264443813">said</a>:</p>
<blockquote>
<p>Do you mean that you want libs to be able to use a <code>Read</code> impl where there is only an implementation of read_buf, and use the default impl of read? Or that you want such libraries to be able to get the perf benefits of using a ReadBuf? (I don't understand how the latter is posible)</p>
</blockquote>
<p>I want a library that has a function that looks like <code>pub fn do_a_thing&lt;R&gt;(reader: &amp;mut R) where R: Read</code> to be able to start using the read_buf interface internally without changing the function signature.</p>



<a name="264586691"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Possible%20variation%20of%20RFC%202930%20%28ReadBuf%29/near/264586691" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Waffle Lapkin <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Possible.20variation.20of.20RFC.202930.20(ReadBuf).html#264586691">(Dec 11 2021 at 21:47)</a>:</h4>
<p><span class="user-mention silent" data-user-id="125270">scottmcm</span> <a href="#narrow/stream/219381-t-libs/topic/Possible.20variation.20of.20RFC.202930.20.28ReadBuf.29/near/264500296">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="243558">Steven Fackler</span> <a href="#narrow/stream/219381-t-libs/topic/Possible.20variation.20of.20RFC.202930.20.28ReadBuf.29/near/264439653">said</a>:</p>
<blockquote>
<p>And you could make it decently ergonomic with a little bit of compiler work to support e.g. a lint for "override exactly 1 of read and read_buf"</p>
</blockquote>
<p>There are <em>so</em> many places where this would be handy.  Here's a relevant old IRLO thread: <a href="https://internals.rust-lang.org/t/brainstorming-allowing-implementing-just-try-fold-and-getting-next-free/9417?u=scottmcm">https://internals.rust-lang.org/t/brainstorming-allowing-implementing-just-try-fold-and-getting-next-free/9417?u=scottmcm</a></p>
</blockquote>
<p>Are there any ideas how hard could it be? Since this feature is wanted anyway, maybe we can "just" implement it? :D</p>



<a name="264592100"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Possible%20variation%20of%20RFC%202930%20%28ReadBuf%29/near/264592100" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Possible.20variation.20of.20RFC.202930.20(ReadBuf).html#264592100">(Dec 11 2021 at 23:43)</a>:</h4>
<p>I think the hardest part is deciding how to expose it.</p>
<p>If you wanted to start with a <code>#[rustc_must_implement_one_of(read, read_buf)]</code> attribute on the trait and worry about how to expose it publicly later, it might not be that bad.  Track that on the trait metadata, then update the part that checks whether you implemented all the required trait to look at that too?  But I've never done a change like that before, so you'd probably want to check with <a class="stream" data-stream-id="182449" href="/#narrow/stream/182449-t-compiler.2Fhelp">#t-compiler/help</a> for whether there's something obvious I'm missing there.</p>
<p>And it'd still be useful even if it's only usable in the standard library for a while, since outside the standard library one can make a major version bump if needed.</p>



<a name="268362562"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Possible%20variation%20of%20RFC%202930%20%28ReadBuf%29/near/268362562" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Waffle Lapkin <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Possible.20variation.20of.20RFC.202930.20(ReadBuf).html#268362562">(Jan 18 2022 at 09:13)</a>:</h4>
<p>Hey! My PR with <code>#[rustc_must_implement_one_of]</code> is finally <a href="https://github.com/rust-lang/rust/pull/92164#event-5907607104">merged</a>!</p>
<p>There is a lot to be desired for the general feature of overriding minimal complete definition, but it's the start =)</p>



<a name="268426997"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Possible%20variation%20of%20RFC%202930%20%28ReadBuf%29/near/268426997" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Possible.20variation.20of.20RFC.202930.20(ReadBuf).html#268426997">(Jan 18 2022 at 17:27)</a>:</h4>
<p>Nice job!  I flipped through the tests and it's already looking great.</p>



<a name="268429084"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Possible%20variation%20of%20RFC%202930%20%28ReadBuf%29/near/268429084" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Possible.20variation.20of.20RFC.202930.20(ReadBuf).html#268429084">(Jan 18 2022 at 17:41)</a>:</h4>
<p>Hrm, we'll probably need a way to do this unstably, no? E.g. if we wanted to change the <code>Iterator</code> interface to require either <code>next()</code> or <code>try_fold()</code> as someone suggested then offering the option to only implement the latter shouldn't be insta-stable.</p>



<a name="268429241"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Possible%20variation%20of%20RFC%202930%20%28ReadBuf%29/near/268429241" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Possible.20variation.20of.20RFC.202930.20(ReadBuf).html#268429241">(Jan 18 2022 at 17:42)</a>:</h4>
<p>It works for <code>read_buf</code> because that itself is unstable.</p>



<a name="268445080"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Possible%20variation%20of%20RFC%202930%20%28ReadBuf%29/near/268445080" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Possible.20variation.20of.20RFC.202930.20(ReadBuf).html#268445080">(Jan 18 2022 at 19:43)</a>:</h4>
<p>Yeah, figuring out a road to experimentation makes sense as a next step.  Using it with anything stable will probably need rustdoc and such to handle it too.</p>
<p>That said, new trait <code>impl</code>s get directly FCP'd to stable today.  So it's not impossible that this could just be directly FCP'd on stable traits too.  (Though obviously having the opportunity to gate something is always nicer.)</p>



<a name="268446370"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Possible%20variation%20of%20RFC%202930%20%28ReadBuf%29/near/268446370" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Possible.20variation.20of.20RFC.202930.20(ReadBuf).html#268446370">(Jan 18 2022 at 19:53)</a>:</h4>
<p>For a simple A or B choice that might be ok, but if it gets more complex where you have multiple default implementations depending on which methods are available then imo it becomes too unwieldy to insta-stabilize</p>



<a name="268447436"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Possible%20variation%20of%20RFC%202930%20%28ReadBuf%29/near/268447436" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Waffle Lapkin <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Possible.20variation.20of.20RFC.202930.20(ReadBuf).html#268447436">(Jan 18 2022 at 20:01)</a>:</h4>
<p>Maybe we can have a <code>#[rustc_unstable_default_impl]</code> attribute that marks default body of functions as unstable?</p>



<a name="268469926"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Possible%20variation%20of%20RFC%202930%20%28ReadBuf%29/near/268469926" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Waffle Lapkin <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Possible.20variation.20of.20RFC.202930.20(ReadBuf).html#268469926">(Jan 18 2022 at 23:12)</a>:</h4>
<p>Actually, I think this should be pretty easy to implement <span aria-label="thinking" class="emoji emoji-1f914" role="img" title="thinking">:thinking:</span></p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>