<html>
<head><meta charset="utf-8"><title>Read + uninit memory · t-libs · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/index.html">t-libs</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html">Read + uninit memory</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="185173844"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185173844" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185173844">(Jan 09 2020 at 00:46)</a>:</h4>
<p>I have a prototype of a more robust approach towards use of uninitialized buffers in the Read trait, if people are interested: <a href="https://paper.dropbox.com/doc/IO-Buffer-Initialization--AneImNfaJpZ0LCvEngs0_eFTAg-MvytTgjIOTNpJAS6Mvw38" target="_blank" title="https://paper.dropbox.com/doc/IO-Buffer-Initialization--AneImNfaJpZ0LCvEngs0_eFTAg-MvytTgjIOTNpJAS6Mvw38">https://paper.dropbox.com/doc/IO-Buffer-Initialization--AneImNfaJpZ0LCvEngs0_eFTAg-MvytTgjIOTNpJAS6Mvw38</a> for background, and <a href="https://github.com/sfackler/read-buf" target="_blank" title="https://github.com/sfackler/read-buf">https://github.com/sfackler/read-buf</a> for the code</p>



<a name="185173853"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185173853" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185173853">(Jan 09 2020 at 00:46)</a>:</h4>
<p>I'm going to start writing an RFC for it all this week</p>



<a name="185197173"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185197173" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amanieu <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185197173">(Jan 09 2020 at 09:51)</a>:</h4>
<p>I've been looking into some of this stuff for non-libstd work.</p>



<a name="185197183"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185197183" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amanieu <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185197183">(Jan 09 2020 at 09:51)</a>:</h4>
<p>One thing that I find very useful is for <code>read</code> to return an initialized slice rather than a <code>usize</code>.</p>



<a name="185197185"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185197185" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amanieu <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185197185">(Jan 09 2020 at 09:51)</a>:</h4>
<p>Basically it returns the part of the buffer that has been filled.</p>



<a name="185197263"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185197263" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amanieu <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185197263">(Jan 09 2020 at 09:52)</a>:</h4>
<p>You can easily get the <code>usize</code> back by calling <code>.len()</code>.</p>



<a name="185197775"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185197775" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amanieu <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185197775">(Jan 09 2020 at 10:01)</a>:</h4>
<p>Regarding the buffer argument, what I had in mind what a <code>ReadBuf</code> trait which is implemented by both <code>&amp;mut [u8]</code> and <code>&amp;mut [MaybeUninit&lt;u8&gt;]</code>. The read method would then become <code>fn read(buf: impl ReadBuf) -&gt; &amp;[u8]</code>.</p>



<a name="185197790"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185197790" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amanieu <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185197790">(Jan 09 2020 at 10:01)</a>:</h4>
<p>However this is no longer object-safe since it uses generics.</p>



<a name="185212421"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185212421" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185212421">(Jan 09 2020 at 13:42)</a>:</h4>
<p>Taking an impl ReadBuf makes it not object safe which we need.</p>



<a name="185212491"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185212491" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185212491">(Jan 09 2020 at 13:43)</a>:</h4>
<p>The returning a slice approach ends up being pretty awkward - there are no guarantees as to where that slice actually points, which you need if you're trying to have an interface that converts <code>[MaybeUninit&lt;u8&gt;]</code> into <code>[u8]</code>.</p>



<a name="185212770"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185212770" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amanieu <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185212770">(Jan 09 2020 at 13:46)</a>:</h4>
<p>I don't understand the problem with returning a slice. The slice points to the buffer that was provided by the caller. Specifically the part of the buffer that was filled by the read operation (the rest of the buffer still being uninitialized).</p>



<a name="185214201"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185214201" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185214201">(Jan 09 2020 at 14:06)</a>:</h4>
<p>Read is not an unsafe trait, so all a caller knows is that the returned buffer points to some slice of initialized bytes. It is hopefully a slice from the head of the input buffer, but it could be a slice from the middle of it, or a slice into static memory, or something else</p>



<a name="185214242"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185214242" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185214242">(Jan 09 2020 at 14:06)</a>:</h4>
<p>code doing something like e.g. read_exact needs to know that the head of the input buffer is the bit being initialized if it's going to be able to return the entire buffer as initialized memory at the end</p>



<a name="185240082"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185240082" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185240082">(Jan 09 2020 at 18:20)</a>:</h4>
<p>you can always check the pointer address if you care that much about the exact location.</p>



<a name="185391011"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185391011" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nikomatsakis <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185391011">(Jan 11 2020 at 14:03)</a>:</h4>
<p><span class="user-mention" data-user-id="243558">@Steven Fackler</span> thinking a bit more about this, I'm wondering if the right way to think about the RFC is that we are adding a type to the std library for working with partially initialized buffers -- and then using that in the Read trait? (In other words, this is a general abstraction that may have use elsewhere, presumably..?)</p>



<a name="185397751"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185397751" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185397751">(Jan 11 2020 at 17:18)</a>:</h4>
<p>that could make sense, though I'm not totally sure what other use cases would come up. Minimally we could parameterize it instead of being locked down to u8</p>



<a name="185397853"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185397853" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185397853">(Jan 11 2020 at 17:21)</a>:</h4>
<p>the version for vectored IO is going to have to be locked down to being read specific since we need to match up with readv's ABI</p>



<a name="185403815"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185403815" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185403815">(Jan 11 2020 at 20:22)</a>:</h4>
<blockquote>
<p>code doing something like e.g. read_exact needs to know that the head of the input buffer is the bit being initialized if it's going to be able to return the entire buffer as initialized memory at the end</p>
</blockquote>
<p>Actually, this is interesting. As I read it again I realize that maybe I don't understand the imagined usage pattern. Can you give an example?</p>
<p>I've not yet seen code that makes an uninit buffer, fills it a part at a time, and then returns that whole thing to some outer scope for some reason.</p>



<a name="185404113"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185404113" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185404113">(Jan 11 2020 at 20:30)</a>:</h4>
<p><code>fn read_exact2(&amp;mut self, buf: &amp;mut [MaybeUninit&lt;u8&gt;]) -&gt; io::Result&lt;&amp;[u8]&gt;</code></p>



<a name="185404556"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185404556" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185404556">(Jan 11 2020 at 20:44)</a>:</h4>
<p>right, so you get some buffer of initialized bytes back, that seems like a totally fine API</p>



<a name="185404591"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185404591" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185404591">(Jan 11 2020 at 20:45)</a>:</h4>
<p>when you're done with that pass, you just go again with the full MaybeUninit slice from last pass</p>



<a name="185404593"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185404593" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> simulacrum <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185404593">(Jan 11 2020 at 20:46)</a>:</h4>
<p>read_exact needs to do multiple reads, but if the returned buffers aren't consecutive (i.e., may not be from the head) then you can't return a consecutive buffer</p>



<a name="185404637"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185404637" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185404637">(Jan 11 2020 at 20:46)</a>:</h4>
<p>oh you mean for the default read_exact method?</p>



<a name="185404639"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185404639" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> simulacrum <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185404639">(Jan 11 2020 at 20:46)</a>:</h4>
<p>well, it too, but yes</p>



<a name="185404656"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185404656" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185404656">(Jan 11 2020 at 20:47)</a>:</h4>
<p>well if you're not using a default read_exact method, then whatever internals did the first read clearly can continue to do the second read  until the read_exact is complete</p>



<a name="185404709"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185404709" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185404709">(Jan 11 2020 at 20:49)</a>:</h4>
<p>I want you to write the default implementation of that read_exact2 method</p>



<a name="185404717"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185404717" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> simulacrum <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185404717">(Jan 11 2020 at 20:49)</a>:</h4>
<p>Maybe? But the default is not possible to write I think is the point</p>



<a name="185404768"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185404768" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185404768">(Jan 11 2020 at 20:50)</a>:</h4>
<p>If you have a new <code>read_exact</code>, you have a new <code>read</code> also, naturally, wouldn't you say?</p>



<a name="185404769"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185404769" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185404769">(Jan 11 2020 at 20:50)</a>:</h4>
<p>so you'd have read2 and then read_exact2, right?</p>



<a name="185404770"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185404770" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185404770">(Jan 11 2020 at 20:50)</a>:</h4>
<p>yes</p>



<a name="185404771"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185404771" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185404771">(Jan 11 2020 at 20:50)</a>:</h4>
<p>Write the implementation of read_exact2 that uses read2</p>



<a name="185404778"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185404778" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185404778">(Jan 11 2020 at 20:51)</a>:</h4>
<p>i am on my phone, so please understand this will take a moment, but sure</p>



<a name="185405147"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185405147" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185405147">(Jan 11 2020 at 21:03)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="sd">/// you should init from the front of the buffer</span>
<span class="k">fn</span> <span class="nf">read2</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="n">MaybrUninit</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nc">io</span>::<span class="n">result</span><span class="o">&lt;&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">]</span><span class="o">&gt;</span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// assumed</span>
<span class="p">}</span><span class="w"></span>

<span class="sd">/// the default impl fails if your read2 doesn&#39;t fill from the front of the buffer</span>
<span class="k">fn</span> <span class="nf">read_exact2</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">start</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="n">MaybrUninit</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nc">io</span>::<span class="n">result</span><span class="o">&lt;&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">]</span><span class="o">&gt;</span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="o">*</span><span class="n">start</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="n">buf</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">in_addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buf</span><span class="p">.</span><span class="n">as_ptr</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">out</span><span class="p">.</span><span class="n">as_ptr</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">in_addr</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// didn&#39;t fill from the fromt</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">they</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// this much is init now  chop away and continue</span>
<span class="w">      </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">head</span><span class="p">,</span><span class="w"> </span><span class="n">tail</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buf</span><span class="p">.</span><span class="n">split_at_mut</span><span class="p">(</span><span class="n">out</span><span class="p">.</span><span class="n">len</span><span class="p">());</span><span class="w"></span>
<span class="w">      </span><span class="n">buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tail</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="c1">// all of it is init now</span>
<span class="w">  </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">transmute_slice_however</span><span class="p">(</span><span class="n">start</span><span class="p">)</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>



<a name="185405269"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185405269" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185405269">(Jan 11 2020 at 21:06)</a>:</h4>
<p>Right, and so everyone else that wants to incrementally fill a buffer like read_exact2 does has to compare raw pointers, which is not a great experience</p>



<a name="185405283"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185405283" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185405283">(Jan 11 2020 at 21:07)</a>:</h4>
<p>..what did you expect from MaybeUninit?</p>



<a name="185405285"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185405285" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185405285">(Jan 11 2020 at 21:07)</a>:</h4>
<p>MaybeUninit isn't a great experience in the first place.</p>



<a name="185405329"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185405329" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> simulacrum <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185405329">(Jan 11 2020 at 21:08)</a>:</h4>
<p>I seem to recall something to the effect of it not being sound to stitch together buffers like this even if you compare pointers</p>



<a name="185405332"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185405332" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185405332">(Jan 11 2020 at 21:08)</a>:</h4>
<p>as i also said, If you override the read_exact2 your own version of read_exact2 can skip the pointer comparison step because you know what your own internal read2 method does</p>



<a name="185405333"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185405333" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185405333">(Jan 11 2020 at 21:08)</a>:</h4>
<p>in this case it's not stitching, it's making sure they're the same thing all along so that should be fine</p>



<a name="185405340"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185405340" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185405340">(Jan 11 2020 at 21:09)</a>:</h4>
<p>I don't agree that we should accept a bad user experience because some part of the API has a non-ideal user experience</p>



<a name="185405346"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185405346" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185405346">(Jan 11 2020 at 21:09)</a>:</h4>
<p>there's no stitching! please note the part where we have <code>start</code>, then reborrow it, and edit along the reborrowed one, and then <em>release that reborrow</em> and transmute <code>start</code> once at the end</p>



<a name="185405358"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185405358" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> simulacrum <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185405358">(Jan 11 2020 at 21:10)</a>:</h4>
<p>I guess yeah, it seems plausibly fine to do this "stitching" (yes, not really, but at a high level)</p>



<a name="185405408"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185405408" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185405408">(Jan 11 2020 at 21:10)</a>:</h4>
<p><span class="user-mention" data-user-id="243558">@Steven Fackler</span> Users are always free to override a default method</p>



<a name="185405409"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185405409" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185405409">(Jan 11 2020 at 21:10)</a>:</h4>
<p>rather, people implementing the trait i should say</p>



<a name="185405413"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185405413" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185405413">(Jan 11 2020 at 21:10)</a>:</h4>
<p>I don't understand how that's relevant to the claim that this read2 API forces awkward pointer double-checking</p>



<a name="185405424"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185405424" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185405424">(Jan 11 2020 at 21:11)</a>:</h4>
<p>because if you overwrite read_exact2 with your own version you don't need to pointer check at all</p>



<a name="185405482"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185405482" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185405482">(Jan 11 2020 at 21:13)</a>:</h4>
<p>someone implementing the Read trait doesn't need to do any checking of any kind in read_exact2 because they don't need to write it in the first place!</p>



<a name="185405529"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185405529" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185405529">(Jan 11 2020 at 21:14)</a>:</h4>
<p>I am talking about other code in other places that wants to do a similar thing of incrementally initializing a buffer</p>



<a name="185405532"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185405532" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185405532">(Jan 11 2020 at 21:14)</a>:</h4>
<p>that's what i asked for an example for that you never really gave a usage of :P</p>



<a name="185405552"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185405552" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185405552">(Jan 11 2020 at 21:15)</a>:</h4>
<p>read_exact is an example. Unless you're claiming that that is the <em>only code</em> that ever incrementally initializes a buffer, then there are other instances of that thing</p>



<a name="185405554"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185405554" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185405554">(Jan 11 2020 at 21:15)</a>:</h4>
<p>for example read_to_end</p>



<a name="185405596"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185405596" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185405596">(Jan 11 2020 at 21:16)</a>:</h4>
<p>but in any case, the other major problem with that version of read2 is that the default implementation of read2 itself that needs to delegate to read can't be implemented sufficiently efficiently</p>



<a name="185405610"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185405610" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185405610">(Jan 11 2020 at 21:17)</a>:</h4>
<p>there are also APIs like parsers that take in a slice of bytes and either process them or say "no, I need more stuff"</p>



<a name="185405620"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185405620" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185405620">(Jan 11 2020 at 21:17)</a>:</h4>
<p>which then needs to incrementally fill a buffer</p>



<a name="185405628"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185405628" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185405628">(Jan 11 2020 at 21:17)</a>:</h4>
<p>So the usual desired usage of MaybeUninit for a buffer that I see is something like</p>
<div class="codehilite"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="n">cap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5000</span><span class="p">;</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">with_capacity</span><span class="p">(</span><span class="n">cap</span><span class="p">);</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">slice</span>::<span class="n">from_raw_parts</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">as_mut_ptr</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">cap</span><span class="p">)</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="k">while</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="n">bytes_this_pass</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">source</span><span class="p">.</span><span class="n">read_to_unit_buffer</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">buf</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">do_work</span><span class="p">(</span><span class="n">bytes_this_pass</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>and people usually do not desire to actually _keep_ the bytes from pass to pass of the loop</p>



<a name="185405677"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185405677" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185405677">(Jan 11 2020 at 21:18)</a>:</h4>
<p>what happens when do_work says "bytes_this_pass is too small for me to do anything with"?</p>



<a name="185405684"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185405684" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185405684">(Jan 11 2020 at 21:18)</a>:</h4>
<p>then you return Err :P</p>
<p>there's always the possibilty of problems</p>



<a name="185405690"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185405690" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185405690">(Jan 11 2020 at 21:19)</a>:</h4>
<p>but it's not an error condition</p>



<a name="185405693"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185405693" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185405693">(Jan 11 2020 at 21:19)</a>:</h4>
<p>or you can use read_uninit_exact if you <em>must</em> have some quantity</p>



<a name="185405697"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185405697" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185405697">(Jan 11 2020 at 21:19)</a>:</h4>
<p>you don't always know the exact quantity</p>



<a name="185405701"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185405701" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185405701">(Jan 11 2020 at 21:19)</a>:</h4>
<p>e.g. you are trying to parse a single json object</p>



<a name="185405754"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185405754" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185405754">(Jan 11 2020 at 21:20)</a>:</h4>
<p>if you're steaming in json then be prepared to handle part of a json; that's a problem you might have both with and without an uninit buffer. a normal read might also cut out partway through an object, you just plain need to be able to handle that somehow</p>



<a name="185405764"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185405764" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185405764">(Jan 11 2020 at 21:21)</a>:</h4>
<p>you handle it by reading the rest of the object</p>



<a name="185405812"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185405812" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185405812">(Jan 11 2020 at 21:22)</a>:</h4>
<p>so if your buffer is 10 (to pick a number), and you read 10, and then you're partway through an object.. you gotta do something with that 10 before you can read another 10 bytes, so you already have to be able to handle partial objects</p>



<a name="185405816"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185405816" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185405816">(Jan 11 2020 at 21:22)</a>:</h4>
<p>also, before I forget: I absolutely wouldn't suggest putting an uninit based read onto the existing Read trait as ant sort of "default method" on top of <code>read</code>, that would be crazy.</p>



<a name="185405825"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185405825" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185405825">(Jan 11 2020 at 21:23)</a>:</h4>
<p>read2 would be like, a totally different method on a new trait for types that are able to handle having MaybeUninit buffers safely</p>



<a name="185405826"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185405826" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185405826">(Jan 11 2020 at 21:23)</a>:</h4>
<p>why would that be crazy</p>



<a name="185405886"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185405886" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185405886">(Jan 11 2020 at 21:24)</a>:</h4>
<p>i mean what would the read2 default impl even be?</p>



<a name="185405897"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185405897" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185405897">(Jan 11 2020 at 21:25)</a>:</h4>
<p>the problem with that proposal is that it doesn't have a good default impl</p>



<a name="185405902"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185405902" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185405902">(Jan 11 2020 at 21:25)</a>:</h4>
<p>it is important to not bifurcate the read trait</p>



<a name="185405908"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185405908" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185405908">(Jan 11 2020 at 21:25)</a>:</h4>
<p>code should be able to take advantage of readers that can work with uninit memory when possible, without needing to just forbid other readers in the type signature</p>



<a name="185405955"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185405955" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185405955">(Jan 11 2020 at 21:26)</a>:</h4>
<p>there are other proposals that do have a good default impl, and don't force a second trait</p>



<a name="185405971"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185405971" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185405971">(Jan 11 2020 at 21:27)</a>:</h4>
<p>Well, returning the slice of what you wrote is mostly just better for a lot of uses, for both <code>&amp;[u8]</code> or <code>&amp;[MaybeUninit&lt;u8&gt;]</code></p>



<a name="185405976"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185405976" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185405976">(Jan 11 2020 at 21:27)</a>:</h4>
<p>better than what?</p>



<a name="185405980"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185405980" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185405980">(Jan 11 2020 at 21:28)</a>:</h4>
<p>so, in the sense that, people who want Result&lt;usize&gt; are somehow already best served by getting Result&lt;usize&gt;, yes that trait should continue to use Result&lt;usize&gt; even for the uninit buffer version</p>



<a name="185406019"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185406019" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185406019">(Jan 11 2020 at 21:28)</a>:</h4>
<p>i mean better than Result&lt;usize&gt;</p>



<a name="185406938"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185406938" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amanieu <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185406938">(Jan 11 2020 at 22:00)</a>:</h4>
<p><code>read2</code> could just guarantee that the returned slice starts at the beginning of the buffer.</p>



<a name="185407002"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185407002" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185407002">(Jan 11 2020 at 22:03)</a>:</h4>
<p>Since the trait overall is safe, the writer of the trait is technically within their rights to just not do that though, and <code>unsafe</code> code can't simply rely  on it correctly being start of buffer, so they'd have to do the pointer value check.</p>



<a name="185407049"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185407049" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185407049">(Jan 11 2020 at 22:04)</a>:</h4>
<p>I think that would only end up happening with a deliberately hostile impl, but it could still happen at all.</p>



<a name="185407060"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185407060" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amanieu <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185407060">(Jan 11 2020 at 22:05)</a>:</h4>
<p>Anyways, I kinda like the <code>ReadBuf</code> proposal.</p>



<a name="185407099"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185407099" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> simulacrum <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185407099">(Jan 11 2020 at 22:06)</a>:</h4>
<p>And I believe we've pretty much agreed that we don't want to make Read (or an equivalent, but new) trait <code>unsafe</code>, even if we ignore backwards compat concerns? i.e., it's too common to write to force people to think about the unsafety aspects?</p>



<a name="185407101"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185407101" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amanieu <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185407101">(Jan 11 2020 at 22:06)</a>:</h4>
<p>However I would make one small change: have <code>read2</code> update the <code>ReadBuf</code> in-place to set the number of bytes read, and give <code>ReadBuf</code> a way to safely extract the initialized portion of the buffer.</p>



<a name="185407102"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185407102" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amanieu <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185407102">(Jan 11 2020 at 22:07)</a>:</h4>
<p>This would works for <code>ReadBufs</code> too.</p>



<a name="185407152"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185407152" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amanieu <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185407152">(Jan 11 2020 at 22:08)</a>:</h4>
<p>Basically I want to be able to, with only safe code, create a [MaybeUninit&lt;u8&gt;], pass it to <code>read2</code> and get a <code>[u8]</code> back.</p>



<a name="185407154"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185407154" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amanieu <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185407154">(Jan 11 2020 at 22:08)</a>:</h4>
<p>All the unsafe code should be in the <code>read2</code> implementation.</p>



<a name="185407163"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185407163" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amanieu <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185407163">(Jan 11 2020 at 22:09)</a>:</h4>
<p>(or in <code>ReadBuf</code> if the <code>read2</code> implementation doesn't use unsafe code)</p>



<a name="185407392"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185407392" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185407392">(Jan 11 2020 at 22:16)</a>:</h4>
<p>how does one make <code>[MaybeUninit&lt;u8&gt;]</code> in safe code again?<br>
is there like a nightly box api for that or something?</p>



<a name="185407398"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185407398" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amanieu <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185407398">(Jan 11 2020 at 22:17)</a>:</h4>
<p>MaybeUninit::uninit() is safe</p>



<a name="185407400"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185407400" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amanieu <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185407400">(Jan 11 2020 at 22:17)</a>:</h4>
<p>You can create an uninitialized value just note read inside it.</p>



<a name="185407452"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185407452" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amanieu <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185407452">(Jan 11 2020 at 22:19)</a>:</h4>
<p><span class="user-mention" data-user-id="243558">@Steven Fackler</span> After having a chance to fully review your proposal, I really like the ReadBuf abstraction. The only change I would recommend is for <code>read2</code> to return <code>Result&lt;()&gt;</code> and instead always update the length of the ReadBuf in-place. This makes it more ergonomic to obtain the result of a read.</p>



<a name="185407505"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185407505" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185407505">(Jan 11 2020 at 22:20)</a>:</h4>
<p>oh so you mean like, <code>[MaybeUninit::&lt;u8&gt;::unint(); 1024]</code>, okay i get it</p>



<a name="185407691"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185407691" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amanieu <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185407691">(Jan 11 2020 at 22:27)</a>:</h4>
<p>Then again I'm having second thoughts on how well that would work with ReadBufs...</p>



<a name="185409643"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185409643" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185409643">(Jan 11 2020 at 23:31)</a>:</h4>
<p><code>ReadBuf</code>doesn't track the length of "read" data internally, it tracks the amount of initialized memory. It's important that that's monotonically increasing so that you don't end up repeatedly re-zeroing bits of the buffer</p>



<a name="185409674"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/185409674" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amanieu <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#185409674">(Jan 11 2020 at 23:32)</a>:</h4>
<p>Ah fair enough. In that case I have no objections.</p>



<a name="197867428"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/197867428" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#197867428">(May 17 2020 at 20:29)</a>:</h4>
<p>I finally got around to writing the RFC for this, if anyone wants to take a look before I open it up: <a href="https://github.com/sfackler/rfcs/blob/read-buf/text/0000-read-buf.md">https://github.com/sfackler/rfcs/blob/read-buf/text/0000-read-buf.md</a></p>



<a name="197870464"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/197870464" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#197870464">(May 17 2020 at 21:45)</a>:</h4>
<p>might be worth saying that <code>let mut buf: [u8; 1024] = unsafe { MaybeUninit::uninit().assume_init() };</code> is also UB already even with a known reader according to the current rules (but those rules are under discussion)</p>



<a name="197870484"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/197870484" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#197870484">(May 17 2020 at 21:45)</a>:</h4>
<p>(it doesn't affect the discussion much I think, but just to make sure that people don't read that code and think it is officially blessed.)</p>



<a name="197870537"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/197870537" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#197870537">(May 17 2020 at 21:46)</a>:</h4>
<p>shameless plug: if you want a citation for "uninitialized memory does not just have an arbitrary value", you could link to my blog post: <a href="https://www.ralfj.de/blog/2019/07/14/uninit.html">https://www.ralfj.de/blog/2019/07/14/uninit.html</a></p>



<a name="197870553"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/197870553" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#197870553">(May 17 2020 at 21:47)</a>:</h4>
<p>though you already have a pretty convincing example in there :)</p>



<a name="197870615"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/197870615" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#197870615">(May 17 2020 at 21:48)</a>:</h4>
<blockquote>
<p>Sometimes, working with uninitialized buffers can be more complex than working with regular initialized buffers!</p>
</blockquote>
<p>I'd add "however", as in: "Sometimes, however, working with ..."</p>



<a name="197870763"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/197870763" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#197870763">(May 17 2020 at 21:52)</a>:</h4>
<p>what about <code>assert_initialized</code> -&gt; <code>assume_init</code>, to match  <code>MaybeUninit</code>?</p>



<a name="197870785"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/197870785" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#197870785">(May 17 2020 at 21:53)</a>:</h4>
<p>so <code>ReadBuf</code> has an invariant <code>initialized &gt;= written</code>? might be worth stating explicitly.</p>



<a name="197870919"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/197870919" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#197870919">(May 17 2020 at 21:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory/near/197870763">said</a>:</p>
<blockquote>
<p>what about <code>assert_initialized</code> -&gt; <code>assume_init</code>, to match  <code>MaybeUninit</code>?</p>
</blockquote>
<p>oh it already is <code>assume</code> later, just not in the example code</p>



<a name="197870932"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/197870932" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#197870932">(May 17 2020 at 21:57)</a>:</h4>
<p><code>initialize_unwriten_to</code> is an odd name, to me that sounds like a function that sets all uninit memory <em>to</em> some value <code>n</code></p>



<a name="197871324"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/197871324" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#197871324">(May 17 2020 at 22:05)</a>:</h4>
<p>But overall, big <span aria-label="+1" class="emoji emoji-1f44d" role="img" title="+1">:+1:</span> :-)</p>



<a name="197874867"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/197874867" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#197874867">(May 17 2020 at 23:24)</a>:</h4>
<p>Thanks! Yeah I'm not sure about the naming of some of the methods on ReadBuf</p>



<a name="197874871"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/197874871" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#197874871">(May 17 2020 at 23:24)</a>:</h4>
<p>in particular initialize_unwritten/initialize_unwritten_to</p>



<a name="197875665"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/197875665" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> BurntSushi <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#197875665">(May 17 2020 at 23:51)</a>:</h4>
<p><span class="user-mention" data-user-id="243558">@Steven Fackler</span> love it! great RFC. i very much like the <code>ReadBuf</code> type. the way it works feels very transparent and makes a lot of sense. i always agree with your decision on <code>io::Result&lt;()&gt;</code> vs <code>io::Result&lt;usize&gt;</code>. having all of that encapsulated in <code>ReadBuf</code> feels like the right way to go. (i say this as someone who hasn't really tracked progress on this issue.)</p>
<p>i think my "biggest" criticism is definitely that trivial <code>Read</code> impls become possible. it's kind of a bummer. a lint would definitely help with that. the other aspect of this that stinks though is the docs. today, it's clear that there is one single required method to implement, and i'd guess that <code>read</code> is what most folks will continue using even with <code>read_buf</code>. in the new world, there will be no required methods listed in the place one expects, which seems like kind of  a bummer.</p>
<p>how much has the case of not making <code>read</code> have a default impl been considered? it would create some guaranteed boiler plate for some subset of impls which stinks, but maybe it's not _that_ terrible?</p>



<a name="197878068"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/197878068" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#197878068">(May 18 2020 at 00:45)</a>:</h4>
<p>I'd hope that people would actually start implementing read_buf by default rather than read as time goes on. We can provide APIs like <code>ReadBuf::append</code> to avoid making people mess with unsafe while still avoiding initialization.</p>
<p>I'll add leaving <code>read</code> required as an alternative.</p>



<a name="197929265"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/197929265" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> simulacrum <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#197929265">(May 18 2020 at 12:51)</a>:</h4>
<p>I imagine that if we wanted to it wouldn't be <em>too</em> hard to add a compiler lint/error that required you to implement one of read or read_buf, fwiw -- it'd be a perma-unstable attribute pair or something like that</p>



<a name="197929395"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/197929395" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> simulacrum <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#197929395">(May 18 2020 at 12:52)</a>:</h4>
<p>one downside of the current approach of mutually recursive defaults it that e.g. rust-analyzer's "add required methods" assist stops working etc, since there's no required methods</p>



<a name="197929473"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/197929473" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> simulacrum <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#197929473">(May 18 2020 at 12:53)</a>:</h4>
<p>in the ideal world we'd e.g. make 2021 edition code have read_buf be required and prior editions get read defaulted</p>



<a name="197929509"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/197929509" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> simulacrum <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#197929509">(May 18 2020 at 12:53)</a>:</h4>
<p>which in theory isn't impossible</p>



<a name="197939130"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/197939130" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#197939130">(May 18 2020 at 14:06)</a>:</h4>
<p>Yeah I think the lint check would be pretty easy to add, and we could probably even just upgrade it to some rustc-only annotation to make it a hard error</p>



<a name="197939143"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/197939143" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#197939143">(May 18 2020 at 14:06)</a>:</h4>
<p>which rust-analyzer could pick up on as well</p>



<a name="197939336"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/197939336" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> simulacrum <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#197939336">(May 18 2020 at 14:07)</a>:</h4>
<p>yeah -- I wouldn't mind a hard error personally -- one downside of the mutually default approach is due to LLVM treating recursion without side effects as UB it would make it pretty easy to accidentally trigger that (whereas today it's sort of hard(er) to accidentally hit that)</p>



<a name="197963598"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/197963598" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#197963598">(May 18 2020 at 16:52)</a>:</h4>
<p>I would love to see attributes for what the minimum required implementation is.</p>



<a name="197997291"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/197997291" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#197997291">(May 18 2020 at 21:23)</a>:</h4>
<p><a href="https://github.com/rust-lang/rfcs/pull/2930">https://github.com/rust-lang/rfcs/pull/2930</a></p>



<a name="197997506"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/197997506" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> simulacrum <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#197997506">(May 18 2020 at 21:25)</a>:</h4>
<p><span class="user-mention" data-user-id="243558">@Steven Fackler</span> hm, I think I don't see anything about the possibility of an custom attribute to force either read or read_buf to get implemented? do you just consider that out of scope?</p>



<a name="197997526"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/197997526" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> simulacrum <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#197997526">(May 18 2020 at 21:26)</a>:</h4>
<p>IMO, it well may be -- tying the two together could just lead to unnecessary noise</p>



<a name="197997548"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/197997548" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#197997548">(May 18 2020 at 21:26)</a>:</h4>
<p>There's a note about a lint</p>



<a name="197997596"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/197997596" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#197997596">(May 18 2020 at 21:26)</a>:</h4>
<blockquote>
<p>We would ideally create a lint that exactly one of the two methods is implemented, but that is not a hard requirement.</p>
</blockquote>



<a name="197997721"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/197997721" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> simulacrum <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#197997721">(May 18 2020 at 21:27)</a>:</h4>
<p>ah okay, thanks! I had skimmed and mostly paid attention to unresolved questions / future work section</p>



<a name="197999542"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/197999542" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#197999542">(May 18 2020 at 21:46)</a>:</h4>
<p>I don't think it'll be very hard to implement that check, so I'm not too worried about it</p>



<a name="198002476"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/198002476" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> simulacrum <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#198002476">(May 18 2020 at 22:19)</a>:</h4>
<p>sure, yeah</p>



<a name="198002494"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/198002494" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> simulacrum <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#198002494">(May 18 2020 at 22:19)</a>:</h4>
<p>I agree it seems separate and not something that really needs to be RFCd (though probably deserves check boxes or whatever)</p>



<a name="203039979"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/203039979" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#203039979">(Jul 06 2020 at 20:59)</a>:</h4>
<p>Discussion on the RFC has trailed off - might be time to FCP it? I think people are generally aligned on the current text.</p>



<a name="203268932"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/203268932" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amanieu <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#203268932">(Jul 08 2020 at 13:47)</a>:</h4>
<p><span class="user-mention" data-user-id="243558">@Steven Fackler</span> Did you address the point about making ReadBuf generic over <code>T</code> instead of only supporting <code>u8</code>?</p>



<a name="203269863"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/203269863" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#203269863">(Jul 08 2020 at 13:55)</a>:</h4>
<p>Oh yeah, I'll add a bit about that to the text</p>



<a name="203838067"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/203838067" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pickfire <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#203838067">(Jul 14 2020 at 14:15)</a>:</h4>
<p>If there is reading into uninitialized buffer, is there writing into uninitialized buffer?</p>



<a name="203870287"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/203870287" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Peter Rabbit <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#203870287">(Jul 14 2020 at 18:35)</a>:</h4>
<p>Is there a difference between reading <em>into</em> and writing <em>into</em>?</p>



<a name="203950531"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/203950531" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#203950531">(Jul 15 2020 at 12:50)</a>:</h4>
<p>What do you mean by that? Generally speaking, one "side" of each of Read and Write interact with a byte buffer, but they differ in which side it is</p>



<a name="204078978"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/204078978" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pickfire <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#204078978">(Jul 16 2020 at 12:59)</a>:</h4>
<p>I mean as in writing directly to uninitialized buffer like what this proposal does.</p>



<a name="204084330"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/204084330" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#204084330">(Jul 16 2020 at 13:38)</a>:</h4>
<p>The Write trait doesn't involve any mutable buffers.</p>



<a name="205667902"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/205667902" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#205667902">(Aug 01 2020 at 06:27)</a>:</h4>
<p>I'm way late to this thread, but +1 to wishing we had a way to allow different "required" sets on traits -- it came up for <code>Iterator</code> a while ago too, since either <code>next</code> or <code>try_fold</code> are enough to do everything else.</p>



<a name="207096132"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/207096132" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#207096132">(Aug 16 2020 at 23:59)</a>:</h4>
<p>I finally updated the RFC text. There is also a PR open on Tokio updating their async read/write traits to use ReadBuf (currently vendored into the library) as a reference: <a href="https://github.com/tokio-rs/tokio/pull/2758">https://github.com/tokio-rs/tokio/pull/2758</a></p>



<a name="207097540"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/207097540" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amanieu <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#207097540">(Aug 17 2020 at 00:41)</a>:</h4>
<p>The Tokio PR doesn't have the proposed <code>ReadBufs</code> for vectored I/O, is that intentional?</p>



<a name="207097584"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/207097584" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amanieu <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#207097584">(Aug 17 2020 at 00:42)</a>:</h4>
<p>BTW I'm very excited about this change since it will allow me to significantly reduce the amount of unsafe code in my I/O logic :)</p>



<a name="207097969"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/207097969" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#207097969">(Aug 17 2020 at 00:54)</a>:</h4>
<p>Not sure about readbufs and the tokio PR - I imagine sean's just working incrementally</p>



<a name="207163091"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/207163091" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amanieu <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#207163091">(Aug 17 2020 at 16:11)</a>:</h4>
<p><span class="user-mention" data-user-id="243558">@Steven Fackler</span> Do you feel that RFC is ready for FCP or are there still unresolved questions?</p>



<a name="207163112"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/207163112" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#207163112">(Aug 17 2020 at 16:11)</a>:</h4>
<p>I think it's ready</p>



<a name="209321630"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/209321630" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#209321630">(Sep 07 2020 at 19:07)</a>:</h4>
<p>While preparing the PR to add ReadBuf to std, I came across a potential problem in the API: <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=af920f318b4918c39788957414ae2ee4">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=af920f318b4918c39788957414ae2ee4</a></p>



<a name="209321706"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/209321706" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#209321706">(Sep 07 2020 at 19:08)</a>:</h4>
<p>specifically, a malicious Read implementation can <em>replace</em> the ReadBuf passed into read_buf with another (I think the only way to do this without unsafe is to leak the buffer). This can invalidate assumptions callers make about the relation of the initialization information to the buffer they're working with</p>



<a name="209321736"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/209321736" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#209321736">(Sep 07 2020 at 19:09)</a>:</h4>
<p>A potential solution is to have a <code>ReadBufRef</code> type (or something like that) which is passed to read_buf by value to prevent replacement of the buffer reference, but that's an unfortunate layer of complication :(</p>



<a name="209323967"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/209323967" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amanieu <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#209323967">(Sep 07 2020 at 19:48)</a>:</h4>
<p>Can we <code>Pin</code> it?</p>



<a name="209324906"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/209324906" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#209324906">(Sep 07 2020 at 20:09)</a>:</h4>
<p>That could work, though it'd be a bit of an "abuse" of Pin, since ReadBuf morally should be Unpin</p>



<a name="209325750"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/209325750" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amanieu <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#209325750">(Sep 07 2020 at 20:28)</a>:</h4>
<p>Otherwise we could redesign the API to have <code>ReadBuf</code> passed by value instead of by reference.</p>



<a name="209329584"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/209329584" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#209329584">(Sep 07 2020 at 21:52)</a>:</h4>
<p>Yeah, that's the ReadBufRef idea, but it's a bit unfortunate since there'll be 2 types with very similar APIs :(</p>



<a name="209755608"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/209755608" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#209755608">(Sep 11 2020 at 08:58)</a>:</h4>
<p><span class="user-mention" data-user-id="243558">@Steven Fackler</span>  so turning <code>ReadBuf</code> itself into a reference type (and thus only having 1 type) wouldn't work well?</p>



<a name="209766916"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/209766916" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#209766916">(Sep 11 2020 at 11:07)</a>:</h4>
<p>I don't think we easily can, since it needs to store the initialized filled counts in addition to the slice</p>



<a name="209768326"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/209768326" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#209768326">(Sep 11 2020 at 11:24)</a>:</h4>
<p>that could be a private inner type that it points to though?</p>



<a name="209769036"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/209769036" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> HeroicKatora <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#209769036">(Sep 11 2020 at 11:33)</a>:</h4>
<p>A type that references these fields should work. Then you still have a single lifetime. And overwriting the struct with a different buffer is benign. Then grab the result from the original fields. So</p>
<div class="codehilite"><pre><span></span><code>struct ReadBuf&lt;&#39;buf&gt; {
    inner: &amp;&#39;buf mut [MaybeUninit&lt;u8&gt;],
    filled: &amp;&#39;buf mut usize,
    initialized: &amp;&#39;buf mut usize,
};
</code></pre></div>



<a name="209777514"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/209777514" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#209777514">(Sep 11 2020 at 13:03)</a>:</h4>
<p>That's what one of the types would look like, but where are those filled and initialized pointers pointing without a second type?</p>



<a name="209777970"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/209777970" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> HeroicKatora <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#209777970">(Sep 11 2020 at 13:07)</a>:</h4>
<p>Somewhere in the caller's stack, potentially. For the purpose of a  wrapper that provides safe access and can constructed from a <code>[MaybeUnint&lt;u8&gt;]</code>, yes, you would need a second struct. The main difference is that this second struct is never exposed to the callee.</p>



<a name="209779558"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/209779558" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#209779558">(Sep 11 2020 at 13:21)</a>:</h4>
<p>Oh yeah that's what the proposal would look like. The reference type is passed by value into <code>read_buf</code>.</p>



<a name="209780097"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/209780097" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> HeroicKatora <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#209780097">(Sep 11 2020 at 13:26)</a>:</h4>
<p>Any naming considerations? I would keep <code>ReadBuf</code> for the argument type honestly. And rather introduce a new name for the second typically hidden type, something like <code>ReadVec</code>—paralleling io_vec and clarifying that it temporarily owns something.. Just my 2¢</p>



<a name="209786063"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/209786063" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#209786063">(Sep 11 2020 at 14:18)</a>:</h4>
<p><span class="user-mention" data-user-id="243558">@Steven Fackler</span> I was thinking more of <code>struct ReadBuf&lt;'buf&gt;(&amp;'buf mut ReadBufInner)</code>, with <code>ReadBufInner</code> being a private type defined like the RFC's <code>ReadBuf</code></p>



<a name="209786146"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/209786146" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#209786146">(Sep 11 2020 at 14:18)</a>:</h4>
<p>but maybe it cannot be private</p>



<a name="209786170"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/209786170" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#209786170">(Sep 11 2020 at 14:19)</a>:</h4>
<p>Yeah, since you need to be able to stick a ReadBufInner on the stack of the caller</p>



<a name="209786222"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/209786222" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#209786222">(Sep 11 2020 at 14:19)</a>:</h4>
<p>We could maybe use one type with an enum type for the filled and initialized counts to allow them to be either by value or by reference?</p>



<a name="209786361"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/209786361" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#209786361">(Sep 11 2020 at 14:20)</a>:</h4>
<p><code>enum MaybeRef&lt;'a, T&gt; { Value(T), Ref(&amp;'a mut T), } struct ReadBuf&lt;'a&gt; { buf: &amp;'a mut [MaybeUninit&lt;u8&gt;], filled: MaybeRef&lt;'a, usize&gt;, initialized: MaybeRef&lt;'a, usize&gt; }</code>?</p>



<a name="209786526"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/209786526" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> HeroicKatora <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#209786526">(Sep 11 2020 at 14:21)</a>:</h4>
<p>You can't move <code>initialized</code> to the callee. How would you ensure that you get the value back afterwards?</p>



<a name="209786919"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/209786919" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> HeroicKatora <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#209786919">(Sep 11 2020 at 14:24)</a>:</h4>
<p>Doesn't <code>ReadBuf&lt;'buf&gt;(&amp;'buf mut Inner)</code> have the problem that <code>Inner</code> stores a <code>&amp;mut [MaybeUninit&lt;u8&gt;]</code> and thus has as second lifetime?  Well, coercion would probably shorten it behind the reference. Yeah, that might be better.</p>



<a name="209788103"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/209788103" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#209788103">(Sep 11 2020 at 14:32)</a>:</h4>
<p>It wouldn't move into the callee - you'd construct a readbuf that stores a reference for the filled and initialized fields that refer to the root readbuf</p>



<a name="209788661"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/209788661" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> HeroicKatora <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#209788661">(Sep 11 2020 at 14:37)</a>:</h4>
<p>I see, you want to use the same type for both representations and sides of the function call. That's clever.</p>



<a name="209800412"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/209800412" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pickfire <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#209800412">(Sep 11 2020 at 16:05)</a>:</h4>
<p>Shouldn't <code>filled</code> and <code>initialized</code> have the same type for <code>MaybeRef</code>? Would it be useful for one to be <code>Value</code> and the other one to be <code>Ref</code>?</p>



<a name="209800997"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/209800997" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#209800997">(Sep 11 2020 at 16:09)</a>:</h4>
<p>sure they could be in a single enum</p>



<a name="209801208"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/209801208" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pickfire <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#209801208">(Sep 11 2020 at 16:11)</a>:</h4>
<p>Doesn't <code>MaybeRef</code> sounds like <code>Cow</code>? Or the difference is only the <code>&amp;'mut T</code>?</p>



<a name="209801391"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/209801391" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> HeroicKatora <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#209801391">(Sep 11 2020 at 16:12)</a>:</h4>
<p>If anything, a <code>Cow&lt;'_, Cell&lt;_&gt;&gt;</code> could be possible in this case but that's hardly optimal.</p>



<a name="209801478"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/209801478" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pickfire <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#209801478">(Sep 11 2020 at 16:13)</a>:</h4>
<p>Or maybe we could have a new type, <code>CowMut&lt;'a, B&gt;</code>? Difference being <code>Borrowed(&amp;'a mut B)</code> rather than <code>Borrowed(&amp;'a B)</code>. Not sure if it's useful.</p>



<a name="209802027"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/209802027" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> HeroicKatora <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#209802027">(Sep 11 2020 at 16:17)</a>:</h4>
<p>It doesn't need to be exposed, it could stay an implementation detail. The exposed interface would be</p>
<blockquote>
<p><code>fn as_mut(&amp;mut self) -&gt; ReadBuf&lt;'_&gt;</code> </p>
</blockquote>
<p>or something along those lines. Doing the matching and borrowing internally.</p>



<a name="209802281"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/209802281" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> HeroicKatora <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#209802281">(Sep 11 2020 at 16:19)</a>:</h4>
<p>Cute, that would make it reasonably easy to forward toan inner reader and do some post-processing on the initialized portion.</p>



<a name="209803166"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/209803166" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amanieu <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#209803166">(Sep 11 2020 at 16:26)</a>:</h4>
<p>At this point I'm tempted to just go with "unsafe code should check that the <code>ReadBuf</code> still points to the same buffer" in the docs.</p>



<a name="209803294"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/209803294" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amanieu <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#209803294">(Sep 11 2020 at 16:27)</a>:</h4>
<p>Safe code doesn't need to worry about this since it safely accesses the read data via methods on the <code>ReadBuf</code> and never touches the original buffer.</p>



<a name="209819135"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/209819135" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#209819135">(Sep 11 2020 at 18:40)</a>:</h4>
<p>I'm a bit worried too much unsafe code will forget to do that. It's an easy thing to miss during review.</p>



<a name="209820273"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/209820273" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#209820273">(Sep 11 2020 at 18:50)</a>:</h4>
<p>That's my worry as well. I didn't notice it for quite a while myself!</p>



<a name="209820574"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Read%20%2B%20uninit%20memory/near/209820574" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> HeroicKatora <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory.html#209820574">(Sep 11 2020 at 18:53)</a>:</h4>
<p>The methods to turn it into an initialized buffer could take an 'expected buffer' argument as well to avoid this mistake.<br>
But that feels less ergonomic? However it only affects buffers so it may be fine</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>