<html>
<head><meta charset="utf-8"><title>Parker/Unparker · t-libs · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/index.html">t-libs</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Parker.2FUnparker.html">Parker/Unparker</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="272409784"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Parker/Unparker/near/272409784" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Yoshua Wuyts [he/they] <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Parker.2FUnparker.html#272409784">(Feb 18 2022 at 14:44)</a>:</h4>
<p>Heya, I was wondering if we have an equivalent of <a href="https://docs.rs/crossbeam/latest/crossbeam/sync/struct.Parker.html"><code>crossbeam::Parker</code></a> internally in the stdlib. I know about the windows Parker type, but I'm not entirely sure if it's the same thing.</p>
<p>Related to that: if we don't, is there a good place to add it internally? Or would this even be something we should consider adding as a public API? (I've wanted this a few times, though I'd like be keen to hear libs team member's perspective on this first.)</p>
<p>cc/ <span class="user-mention" data-user-id="310399">@Mara</span> probably?</p>



<a name="272410592"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Parker/Unparker/near/272410592" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> simulacrum <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Parker.2FUnparker.html#272410592">(Feb 18 2022 at 14:51)</a>:</h4>
<p>std::thread::park/unpark is almost this, just per-thread rather than on an ad-hoc struct</p>



<a name="272414302"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Parker/Unparker/near/272414302" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Yoshua Wuyts [he/they] <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Parker.2FUnparker.html#272414302">(Feb 18 2022 at 15:20)</a>:</h4>
<p>Yeah that's right. Though in this instance we definitely want to enable waking up the thread we created <code>Parker</code> on from (potentially) any other thread, which I don't believe we can do without a <code>Parker</code>-like abstraction.</p>



<a name="272414347"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Parker/Unparker/near/272414347" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amanieu <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Parker.2FUnparker.html#272414347">(Feb 18 2022 at 15:20)</a>:</h4>
<p>C++20 has a futex-like API on atomic types: <a href="https://en.cppreference.com/w/cpp/atomic/atomic/wait">https://en.cppreference.com/w/cpp/atomic/atomic/wait</a></p>



<a name="272414438"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Parker/Unparker/near/272414438" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amanieu <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Parker.2FUnparker.html#272414438">(Feb 18 2022 at 15:21)</a>:</h4>
<p>Basically you can <code>wait</code> on an atomic or wake up a thread that is waiting on an atomic.</p>



<a name="272415088"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Parker/Unparker/near/272415088" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Yoshua Wuyts [he/they] <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Parker.2FUnparker.html#272415088">(Feb 18 2022 at 15:26)</a>:</h4>
<p>oh that sounds neat!?</p>



<a name="272415140"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Parker/Unparker/near/272415140" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Yoshua Wuyts [he/they] <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Parker.2FUnparker.html#272415140">(Feb 18 2022 at 15:27)</a>:</h4>
<p>Fwiw here's roughly how I plan to use <code>Parker</code>: <a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=f111c32329892c9b7e8f281b9c3c16a0">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=f111c32329892c9b7e8f281b9c3c16a0</a></p>



<a name="272417055"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Parker/Unparker/near/272417055" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Yoshua Wuyts [he/they] <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Parker.2FUnparker.html#272417055">(Feb 18 2022 at 15:43)</a>:</h4>
<p><span class="user-mention silent" data-user-id="143274">Amanieu</span> <a href="#narrow/stream/219381-t-libs/topic/Parker.2FUnparker/near/272414438">said</a>:</p>
<blockquote>
<p>Basically you can <code>wait</code> on an atomic or wake up a thread that is waiting on an atomic.</p>
</blockquote>
<p>That almost feels like the better API, right? -- though I believe the counterpart to C++'s <code>std::atomic&lt;T&gt;</code> would be something like <code>crossbeam::atomic::AtomicCell</code>? -- would it make sense to add it to the individual atomic types if we don't also have an <code>AtomicCell</code> type?</p>



<a name="272422183"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Parker/Unparker/near/272422183" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Parker.2FUnparker.html#272422183">(Feb 18 2022 at 16:21)</a>:</h4>
<p>I don't  know who  thought <code>std::atomic::wait</code> was a good idea, since it's required in freestanding.<br>
I think it would be fairly difficult to implement something like it without OS support.</p>



<a name="272424662"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Parker/Unparker/near/272424662" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Thom Chiovoloni <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Parker.2FUnparker.html#272424662">(Feb 18 2022 at 16:42)</a>:</h4>
<p>i had the start of an RFC for it at one point. I still think it's worth having, but I think it would be better to focus on after the other near-term std::sync changes.</p>



<a name="272424913"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Parker/Unparker/near/272424913" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amanieu <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Parker.2FUnparker.html#272424913">(Feb 18 2022 at 16:44)</a>:</h4>
<p>Yea that's the issue with the <code>wait</code> API, we can't have it in <code>core</code> because it requires OS support. Maybe an extension trait in <code>std</code>? But then it could just as well be an extension trait in an external crate.</p>



<a name="272425002"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Parker/Unparker/near/272425002" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amanieu <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Parker.2FUnparker.html#272425002">(Feb 18 2022 at 16:45)</a>:</h4>
<p>For the actual implementation it's basically the same as <code>parking_lot</code>: wait queues in a hash table keyed on an address.</p>



<a name="272426768"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Parker/Unparker/near/272426768" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Thom Chiovoloni <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Parker.2FUnparker.html#272426768">(Feb 18 2022 at 16:57)</a>:</h4>
<p>i definitely think it would live in std on an extension trait. i was even considering just making it be <code>fn wait(&amp;AtomicU32, u32)</code> and <code>fn wake(&amp;AtomicU32)</code>. but in practice it probably needs to support other atomic types. (the downside being that this means the parking_lot approach must be taken, even on platforms with a native futex API, unless that native API supports many sizes of futex word, like windows does)</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>