<html>
<head><meta charset="utf-8"><title>Any reason for no AtomicFlag · t-libs · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/index.html">t-libs</a></h2>
<h3>Topic: <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html">Any reason for no AtomicFlag</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://rust-lang.github.io/zulip_archive/style.css" rel="stylesheet"></head>

<a name="223791034"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/223791034" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#223791034">(Jan 24 2021 at 02:29)</a>:</h4>
<p>In <code>core::sync::atomic</code>, there are a number of atomic types which are guaranteed to be lock free, but are not guaranteed to exist.  This makes it difficult to write portable code that needs atomics. <br>
One type that is notably absent from the module is an <code>AtomicFlag</code> type. This would be an analog of <code>atomic_flag</code> from C11, and <code>std::atomic_flag</code> from C++11 (both which are guaranteed to be lock free by the standard, and are the minimum necessary to write basic concurrency primitives like spin locks). <br>
While I would not pretend this is entirely portable, it's would be the most portable, even more so than <code>Atomic{U,I}size</code>.</p>
<p>Is there a reason, that AtomicFlag was not added, or is it simply an omission?</p>



<a name="223805766"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/223805766" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Gwaihir Thorondorsen <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#223805766">(Jan 24 2021 at 09:48)</a>:</h4>
<p>The reason it's not been added is that it's very much not clear what are the differences with <code>AtomicBool</code>. I'll try to explicit those, please tell me what I missed or got wrong.</p>
<p><code>AtomicBool</code> is guaranteed to have the same memory layout as <code>bool</code>, as witnessed by the <code>get_mut</code> and (unstable) <code>from_mut</code> methods, and thus needs the platform to support atomic operations on a single byte, which may not be available even though the platform supports atomic operations of a larger width.</p>
<p>On the other hand, <code>AtomicFlag</code> would not have any layout guarantees (neither size nor alignment) so it could be supported on all platforms having atomic instructions of some width but would only expose a restricted set of atomic boolean operations.</p>



<a name="223810885"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/223810885" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#223810885">(Jan 24 2021 at 12:07)</a>:</h4>
<p>Maybe one could have <code>AtomciBool</code> without <code>get/from_mut</code> on those platforms?<br>
However, people might be unsafely transmuting things as well...</p>



<a name="223815217"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/223815217" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#223815217">(Jan 24 2021 at 13:58)</a>:</h4>
<blockquote>
<p>On the other hand, <code>AtomicFlag</code> would not have any layout guarantees (neither size nor alignment) so it could be supported on all platforms having atomic instructions of some width but would only expose a restricted set of atomic boolean operations.</p>
</blockquote>
<p>Yeah that is what I was thinking. Specifically, AtomicFlag only needs <code>.test_and_set</code> and <code>.clear</code>. </p>
<blockquote>
<p>Maybe one could have <code>AtomciBool</code> without <code>get/from_mut</code> on those platforms?<br>
However, people might be unsafely transmuting things as well...</p>
</blockquote>
<p>Yeah, changing the layout guarantees of AtomicBool is probably not a good idea.</p>



<a name="223815240"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/223815240" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amanieu <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#223815240">(Jan 24 2021 at 13:59)</a>:</h4>
<p><code>AtomicBool</code> is somewhat problematic on RISC-V since it is 1 byte but RISC-V doesn't have single-byte ops.</p>



<a name="223815320"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/223815320" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amanieu <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#223815320">(Jan 24 2021 at 14:00)</a>:</h4>
<p>Note that byte atomics can always be emulated using larger atomic operations (LLVM does this for us), but it is less efficient.</p>



<a name="223818136"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/223818136" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#223818136">(Jan 24 2021 at 15:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="143274">Amanieu</span> <a href="#narrow/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag/near/223815320">said</a>:</p>
<blockquote>
<p>Note that byte atomics can always be emulated using larger atomic operations (LLVM does this for us), but it is less efficient.</p>
</blockquote>
<p>on the hardware level, that is -- if you did this emulation in Rust or LLVM IR you'd be introducing data races</p>



<a name="223822345"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/223822345" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#223822345">(Jan 24 2021 at 16:39)</a>:</h4>
<p>Could you explain more about that one Ralf? I don't follow why there'd potentially be a data race</p>



<a name="223825775"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/223825775" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mara <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#223825775">(Jan 24 2021 at 17:48)</a>:</h4>
<blockquote>
<p>Maybe one could have AtomciBool without get/from_mut on those platforms?</p>
</blockquote>
<p><code>from_mut</code> is already conditional on the layout of <code>bool</code> and <code>AtomicBool</code> being the same (and is unstable anyway). But <code>get_mut</code> is not. We do hard-code a alignment of 1 for <code>AtomicBool</code> right now, but t hat's not necessarily a promise we can't break.</p>



<a name="223826983"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/223826983" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#223826983">(Jan 24 2021 at 18:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="224471">Lokathor</span> <a href="#narrow/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag/near/223822345">said</a>:</p>
<blockquote>
<p>Could you explain more about that one Ralf? I don't follow why there'd potentially be a data race</p>
</blockquote>
<p>any such emulation would at least read from the neighboring bytes, right? that would introduce a read-write race if there is other code using non-atomic writes on those neighboring bytes. Am I misunderstanding how the emulation works?</p>



<a name="223902757"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/223902757" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Konrad Borowski <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#223902757">(Jan 25 2021 at 14:20)</a>:</h4>
<p>I don't think existence of <code>get_mut</code> method necessitates <code>AtomicBool</code> to have the same layout as <code>bool</code> - assuming for instance atomic value is represented with 32-bit integer we can create a pointer to part of that integer, however <code>from_mut</code> very much does do so</p>



<a name="223903048"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/223903048" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Konrad Borowski <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#223903048">(Jan 25 2021 at 14:22)</a>:</h4>
<p>in fact, we already hide <code>from_mut</code> on platforms that have different layout for atomics</p>



<a name="223903305"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/223903305" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Konrad Borowski <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#223903305">(Jan 25 2021 at 14:24)</a>:</h4>
<p>if you check the documentation for atomic non-8-bit integer types, they all say the following:</p>
<blockquote>
<p><strong>Note:</strong> This function is only available on targets where uX has an alignment of Y bytes.</p>
</blockquote>



<a name="223906159"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/223906159" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mara <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#223906159">(Jan 25 2021 at 14:45)</a>:</h4>
<p>Yes exactly, that is what i was saying. The only thing is that I didn't put that sentence you just quoted in the documentation for AtomicU8::from_mut and AtomicBool::from_mut, because I figured that version would always exist. (That note is only there for u16/i16 and up.) However, the availability is gated on <code>cfg(target_has_atomic_equal_alignment = "8")</code> just like the others, so that shouldn't be a problem other than a small docs update.</p>



<a name="223932652"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/223932652" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#223932652">(Jan 25 2021 at 17:35)</a>:</h4>
<p>So let me see if i follow: on platforms with atomics for say, <em>only</em> 32-bit operations, then rust's atomic types smaller than that get a size increase until they're the right size?</p>



<a name="223938321"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/223938321" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#223938321">(Jan 25 2021 at 18:18)</a>:</h4>
<p>looks like <code>macro_rules! atomic_int</code> explicitly sets the alignment, so it could be over-aligned (and sized) that way</p>



<a name="223938390"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/223938390" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#223938390">(Jan 25 2021 at 18:18)</a>:</h4>
<p>but AFAICT they're all defined with their "natural" alignment right now</p>



<a name="223939028"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/223939028" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#223939028">(Jan 25 2021 at 18:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="138448">cuviper</span> <a href="#narrow/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag/near/223938321">said</a>:</p>
<blockquote>
<p>looks like <code>macro_rules! atomic_int</code> explicitly sets the alignment, so it could be over-aligned (and sized) that way</p>
</blockquote>
<p>this is because LLVM atomic ops requires alignment equal to the size of the atomic (even when e.g. <code>i64</code> otherwise has lower alignment on [some] 32bit systems)</p>



<a name="223940162"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/223940162" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#223940162">(Jan 25 2021 at 18:31)</a>:</h4>
<p><span class="user-mention" data-user-id="120791">@RalfJ</span> requires <em>exactly</em> equal? wouldn't greater alignment be fine?</p>



<a name="223940668"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/223940668" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mara <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#223940668">(Jan 25 2021 at 18:35)</a>:</h4>
<p>i guess you're just supposed to use the larger atomic ops, if you want a greater alignment/size.</p>



<a name="223940975"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/223940975" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mara <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#223940975">(Jan 25 2021 at 18:37)</a>:</h4>
<p>std::atomic docs say:</p>
<blockquote>
<p>Atomic operations may be implemented at the instruction layer with larger-size atomics. For example some platforms use 4-byte atomic instructions to implement AtomicI8. Note that this emulation should not have an impact on correctness of code, it's just something to be aware of.</p>
</blockquote>
<p>AtomicBool docs say:</p>
<blockquote>
<p>This type has the same in-memory representation as a bool.</p>
</blockquote>
<p>I suppose this last promise is about the representation of the values (e.g 0=false, 1=true), not about alignment. Not sure about size. I guess this would imply that they'd have to be the same size too.</p>



<a name="223941059"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/223941059" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#223941059">(Jan 25 2021 at 18:38)</a>:</h4>
<p>remember that size is an upper bound on alignment too (as stride)</p>



<a name="223941128"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/223941128" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#223941128">(Jan 25 2021 at 18:39)</a>:</h4>
<p>so if that is promising the same size as <code>bool</code>, we can't align it any higher</p>



<a name="223941149"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/223941149" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mara <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#223941149">(Jan 25 2021 at 18:39)</a>:</h4>
<p>yeah</p>



<a name="223941327"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/223941327" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mara <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#223941327">(Jan 25 2021 at 18:41)</a>:</h4>
<p>so if AtomicBool is always 1 byte, the question is if we want a AtomicFlag / AtomicSmallest / AtomicAnything / AtomicOneBitOrMoreIDontCare type for the smallest available atomic type.</p>



<a name="223941718"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/223941718" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mara <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#223941718">(Jan 25 2021 at 18:44)</a>:</h4>
<p>I'm wondering how often that'd be used. I can imagine that a lot of places using atomics are already doing platform-specific things depending on which are available, or are doing things with more than one bit. I suppose we could always guarantee at least eight bits? It's tricky to find the balance between minimal guarantees such that it can exist on as many platforms as possible, and enough guarantees that it'll be useful.</p>



<a name="223941721"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/223941721" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#223941721">(Jan 25 2021 at 18:44)</a>:</h4>
<p>(flashbacks of <code>stdint.h</code>and its <code>int_leastN_t</code>, <code>int_fastN_t</code>, <code>intmax_t</code>...)</p>



<a name="223941740"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/223941740" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mara <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#223941740">(Jan 25 2021 at 18:44)</a>:</h4>
<p>haha, yeah</p>



<a name="223941847"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/223941847" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#223941847">(Jan 25 2021 at 18:45)</a>:</h4>
<p>could such types have niches? it looks like we don't set any niche attributes on <code>AtomicBool</code>.</p>



<a name="223941998"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/223941998" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#223941998">(Jan 25 2021 at 18:46)</a>:</h4>
<p>I don't know if that was an oversight, or a real limitation of atomics</p>



<a name="223943382"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/223943382" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mara <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#223943382">(Jan 25 2021 at 18:58)</a>:</h4>
<p>That's done on purpose for UnsafeCell.</p>



<a name="223944503"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/223944503" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#223944503">(Jan 25 2021 at 19:05)</a>:</h4>
<p>Yeah, niches on a !Freeze+Sync type can cause data races, since you can access an Outer Option concurrently to an atomic write, and atomic write+non-atomic read is not synchronized, so you get a data race and UB.</p>



<a name="223944884"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/223944884" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#223944884">(Jan 25 2021 at 19:08)</a>:</h4>
<p>ah, right</p>



<a name="223947270"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/223947270" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#223947270">(Jan 25 2021 at 19:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="138448">cuviper</span> <a href="#narrow/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag/near/223940162">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> requires <em>exactly</em> equal? wouldn't greater alignment be fine?</p>
</blockquote>
<p>yeah... what I meant is, the alignment requirement is equal to the size. of course, like all alignment requirements, this is a lower bound.</p>



<a name="223958440"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/223958440" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amanieu <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#223958440">(Jan 25 2021 at 20:54)</a>:</h4>
<p><span class="user-mention" data-user-id="224471">@Lokathor</span> No, just <code>AtomicBool</code>. For other types we should guarantee exact layout.</p>



<a name="223958680"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/223958680" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amanieu <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#223958680">(Jan 25 2021 at 20:56)</a>:</h4>
<p>To be fair, I was the one who originally suggested that <code>AtomicBool</code> should have the same layout as <code>bool</code>. I wasn't expecting any new architectures (RISC-V) to not support byte-sized atomics.</p>



<a name="245767594"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/245767594" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#245767594">(Jul 13 2021 at 00:46)</a>:</h4>
<p>I found another potential use for a restricted <code>AtomicFlag</code> specifically: the w65 architecture (which I desire to have supported by rust in the future). <br>
In attempting to determine how to best implement lock-free atomics, I discovered two things about the w65 architecture:</p>
<ol>
<li>atomic_test_and_set is trivial to implement: it's a single instruction (tsb: "Test and Set Bits"), plus setup</li>
<li>It may not be possible to implement a lock-free version of atomic_compare_exchange, even for 8 or 16-bit atomics (which are otherwise possible to implement lock-free). I've attempted a fairly complicated implementation, but lacking any kind of hardware level exchange or compare-exchange makes doing it without having a potential race condition (which, at best, is capable of producing out-of-thin-air values in code running in an interrupt handler, and at worst, breaks compare_exchange entirely)</li>
</ol>



<a name="245787049"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/245787049" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#245787049">(Jul 13 2021 at 07:21)</a>:</h4>
<p><code>compare_exchange</code> can be implemented with a loop and <code>compare_and_set</code> entirely inside Rust, can't it? Why should that not work as well on w65?</p>



<a name="245787322"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/245787322" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#245787322">(Jul 13 2021 at 07:25)</a>:</h4>
<p>actually it doesnt even require a loop</p>



<a name="245787329"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/245787329" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#245787329">(Jul 13 2021 at 07:25)</a>:</h4>
<p>I guess I dont know how test_and_set differs from compare_and_set</p>



<a name="245803769"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/245803769" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#245803769">(Jul 13 2021 at 10:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120791">RalfJ</span> <a href="#narrow/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag/near/245787049">said</a>:</p>
<blockquote>
<p><code>compare_exchange</code> can be implemented with a loop and <code>compare_and_set</code> entirely inside Rust, can't it? Why should that not work as well on w65?</p>
</blockquote>
<p>I'm not sure how you would implement <code>compare_exchange</code> with a loop, avoiding a race condition between checking the value and performing the exchange (and, if a race condition occurs, the race condition between the first set and repairing the value), without some primitive operation for that? <code>compare_and_set</code> could be implemented with <code>compare_exchange</code>. <code>test_and_set</code> works because I don't need to extract the actual value of the atomic, I just need to know whether the test suceeded, while simultaneously setting the bit in the atomic (which tsb does, it performs a bitwise and between memory and the accumulator, then <code>or</code>s the accumulator into the memory location and sets flags based on the former result).</p>



<a name="245804900"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/245804900" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#245804900">(Jul 13 2021 at 10:29)</a>:</h4>
<p>faking atomics by disabling interrupts and using multiple instructions isn't an option? (i'm assuming it's a uniprocessor system)</p>



<a name="245805297"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/245805297" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#245805297">(Jul 13 2021 at 10:33)</a>:</h4>
<p>That's my "non-lock-free" approach, but it doesn't work with the non-maskable interrupt which may have to be disabled a different way (on the snes, clear bit 8 of the counter enable register), or may not have a way to be disabled at all.</p>



<a name="245805572"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/245805572" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#245805572">(Jul 13 2021 at 10:36)</a>:</h4>
<p>(C requires that asynchronous signal handlers, what interrupts are treated as here, be capable of accessing lock-free atomics)</p>



<a name="245807445"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/245807445" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#245807445">(Jul 13 2021 at 10:56)</a>:</h4>
<p>One of the microprocessor frameworks for rust emulates atomics by checking for the location where atomic operation code is at the start of an interupt handler and either rewinding or finalizing the steps done to do the atomic instruction before running the rest of the interrupt handler.</p>



<a name="245808510"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/245808510" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amanieu <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#245808510">(Jul 13 2021 at 11:07)</a>:</h4>
<p>Fundamentally this is a similar situation to ARMv5 which only has a <code>swp</code> instruction for atomic exchange: you can't support arbitrary CAS operations on such a platform without either locking or OS support (restarting the atomic sequence in interrupt handlers).</p>



<a name="245815331"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/245815331" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#245815331">(Jul 13 2021 at 12:18)</a>:</h4>
<p>Could be doable, though it costs from 6 to 22 cycles in the prelude of each interrupt handler (the upper bound for when it interrupts a 16-bit atomic operation, and has to undo it).</p>



<a name="245819897"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/245819897" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#245819897">(Jul 13 2021 at 12:55)</a>:</h4>
<p>hm, something like this should work, no?</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">atomic_compare_exchange</span><span class="p">(</span><span class="n">ptr</span>: <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">old</span>: <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">new</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">cur</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">atomic_load</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">cur</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">old</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">atomic_compare_and_set</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">old</span><span class="p">,</span><span class="w"> </span><span class="n">new</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="n">new</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="c1">// If nobody else writes to this location concurrently, CAS will definitely succeed.</span>
<span class="w">    </span><span class="c1">// If CAS failed, nothing was changed, so we can just try again.</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>



<a name="245820432"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/245820432" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#245820432">(Jul 13 2021 at 12:59)</a>:</h4>
<p>I think I'll note this as a verification exercise I can give to a student one day :)</p>



<a name="245822664"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/245822664" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#245822664">(Jul 13 2021 at 13:15)</a>:</h4>
<p>I guess that would, but then you need <code>compare_and_set</code>, and likewise, I'm unsure how to implement that without first having <code>compare_exchange</code></p>



<a name="245828945"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/245828945" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#245828945">(Jul 13 2021 at 14:02)</a>:</h4>
<blockquote>
<p>which tsb does, it performs a bitwise and between memory and the accumulator, then ors the accumulator into the memory location and sets flags based on the former result</p>
</blockquote>
<p>If I understood this correctly it can only ever set additional bits to true, never clear them. So that is insufficient to derive the other RMW primitives from that.</p>



<a name="245829063"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/245829063" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#245829063">(Jul 13 2021 at 14:03)</a>:</h4>
<p>Indeed. There is trb, which clears bits, but that becomes two operations that can be interrupted at the intermediate stage</p>



<a name="245829245"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/245829245" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#245829245">(Jul 13 2021 at 14:04)</a>:</h4>
<p>It also isn't a compare_exchange. The latter op happens reguardless of the bitwise and</p>



<a name="245829433"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/245829433" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#245829433">(Jul 13 2021 at 14:06)</a>:</h4>
<p>Makes it good for atomic_test_and_set because the only thing I'm testing is whether the bit is set, to determine the return value.</p>



<a name="245829918"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/245829918" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#245829918">(Jul 13 2021 at 14:10)</a>:</h4>
<p>There are separate feature flags for <code>target_has_atomic</code> and <code>target_has_atomic_load_store</code>. So you should be able to implement basic atomics that only have load/store and then add an extension trait that supports those instructions?</p>
<p>Actually, isn't that <code>fetch_or</code>?</p>



<a name="245830021"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/245830021" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#245830021">(Jul 13 2021 at 14:10)</a>:</h4>
<p>Not really, since it doesn't load the value</p>



<a name="245830186"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/245830186" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#245830186">(Jul 13 2021 at 14:11)</a>:</h4>
<p>yeah, but you can load it and then do the test to make sure that it's still loaded, no? or does it only take one immediate?</p>



<a name="245830335"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/245830335" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#245830335">(Jul 13 2021 at 14:12)</a>:</h4>
<p>I think I haven't understood your description of the instruction properly.</p>



<a name="245830638"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/245830638" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#245830638">(Jul 13 2021 at 14:14)</a>:</h4>
<p>It takes a single (absolute or direct) memory reference, and performs the operation on that memory address and the accumulator. <br>
The description from &lt;<a href="http://6502.org/tutorials/65c816opcodes.html#6.1.2.3">http://6502.org/tutorials/65c816opcodes.html#6.1.2.3</a>&gt; is:</p>
<blockquote>
<p>TRB and TSB test the bits of the data with the bits of the accumulator (using a bitwise And, like BIT), then reset (i.e. clear) or set (respectively) the bits of the data that are ones in the accumulator.</p>
</blockquote>



<a name="245830761"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/245830761" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#245830761">(Jul 13 2021 at 14:15)</a>:</h4>
<p>(As far as I can tell, it's primary use case would be implementing atomic flags and binary semaphores)</p>



<a name="245832263"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/245832263" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#245832263">(Jul 13 2021 at 14:25)</a>:</h4>
<p>Ah, so you can unconditionally either set or clear some bits and get information whether they were set before? That seems fairly niche.</p>



<a name="245832388"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/245832388" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#245832388">(Jul 13 2021 at 14:25)</a>:</h4>
<p>Yup. As I say, atomic flags and binary semaphores (8-16 in one memory location, in fact)</p>



<a name="245857762"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/245857762" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RalfJ <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#245857762">(Jul 13 2021 at 17:21)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag/near/245822664">said</a>:</p>
<blockquote>
<p>I guess that would, but then you need <code>compare_and_set</code>, and likewise, I'm unsure how to implement that without first having <code>compare_exchange</code></p>
</blockquote>
<p>you said you have test_and_set, which I thought might be similar, but I guess it's not then</p>



<a name="245865394"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/245865394" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Thom Chiovoloni <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#245865394">(Jul 13 2021 at 18:14)</a>:</h4>
<p><code>test_and_set</code> is like <code>swap(true)</code>, iirc.</p>



<a name="245867795"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/245867795" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#245867795">(Jul 13 2021 at 18:32)</a>:</h4>
<p><span class="user-mention silent" data-user-id="209168">Thom Chiovoloni</span> <a href="#narrow/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag/near/245865394">said</a>:</p>
<blockquote>
<p><code>test_and_set</code> is like <code>swap(true)</code>, iirc.</p>
</blockquote>
<p>It could be implemented like that, but <code>tsb</code> would not work for swap in general (just the special case of <code>test_and_set</code>.</p>



<a name="245867992"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/245867992" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#245867992">(Jul 13 2021 at 18:34)</a>:</h4>
<p>I'd call it a special case of <code>swap</code>.</p>



<a name="245870696"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/245870696" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Thom Chiovoloni <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#245870696">(Jul 13 2021 at 18:55)</a>:</h4>
<p>right, yeah. i was attempting to explain that it wasn't a variant of compare_and_swap, but equivalent to swap with a specific constant arg</p>



<a name="245871800"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Any%20reason%20for%20no%20AtomicFlag/near/245871800" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/Any.20reason.20for.20no.20AtomicFlag.html#245871800">(Jul 13 2021 at 19:03)</a>:</h4>
<p>For <code>AtomicBool</code> maybe you could implement it as <code>if (newVal == true) { TSB(...) }  else { TRB(...) }</code>, but that doesn't work for the wider types.</p>



<hr><p>Last updated: Aug 07 2021 at 22:04 UTC</p>
</html>