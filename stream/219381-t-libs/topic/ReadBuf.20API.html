<html>
<head><meta charset="utf-8"><title>ReadBuf API · t-libs · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/index.html">t-libs</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html">ReadBuf API</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="273947636"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/273947636" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#273947636">(Mar 03 2022 at 09:47)</a>:</h4>
<p>cc <span class="user-mention" data-user-id="243558">@Steven Fackler</span> <span class="user-mention" data-user-id="362726">@DrMeepster</span></p>



<a name="273947722"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/273947722" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#273947722">(Mar 03 2022 at 09:48)</a>:</h4>
<p>Hi, I would like to discuss the ReadBuf API a bit as part of the path to stabilising RFC2930</p>



<a name="273947868"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/273947868" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#273947868">(Mar 03 2022 at 09:49)</a>:</h4>
<p>First off, I'm not aware of any users, I've tweeted this a couple of times, but got nothing. There are some issues linking to the tracking issue but not any PRs, afaict</p>



<a name="273947907"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/273947907" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#273947907">(Mar 03 2022 at 09:49)</a>:</h4>
<p>So if anyone knows of users I'd be very glad to get a real experience report</p>



<a name="273948153"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/273948153" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#273948153">(Mar 03 2022 at 09:51)</a>:</h4>
<p>Anyway, I have two angles here: if we keep the current abstraction, then I think we can improve the API (as it is it seems fine, but a little big and confusing). I'd also like to float a slightly different abstraction (I know there was a lot of discussion pre-RFC, but I can't find it now. There didn't seem to be much discussion of this in the RFC itself, apologies if I'm retreading well-trodden ground)</p>



<a name="273948539"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/273948539" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#273948539">(Mar 03 2022 at 09:54)</a>:</h4>
<p>The larger change: it strikes me that when using a byte slice, we don't keep track of filled vs unfilled, just the whole slice, returning the number of read bytes from read. Whereas with ReadBuf we track filled/unfilled/uninit. So I wonder instead if ReadBuf should just track init vs uninit internally and read should return the number of bytes read (and it must ensure that that number is all initialised, obvs). That would make ReadBuf much simpler (and using it closer to using a byte slice) at the expense of requiring some external state. Thoughts?</p>



<a name="273950303"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/273950303" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#273950303">(Mar 03 2022 at 10:08)</a>:</h4>
<p>If we keep the three-way split, I propose the following changes:</p>
<h2>Construction</h2>
<ul>
<li>remove <code>new</code> (it should create an empty <code>ReadBuf</code>, but that is useless, I think)</li>
<li>Should implement <code>From&lt;&amp;'a [u8]&gt; for ReadBuf&lt;'a&gt;</code> to create a ReadBuf from a byte slice (rather than <code>new</code>)</li>
<li>Should implement <code>From&lt;&amp;'a [MaybeUninit&lt;u8&gt;]&gt; for ReadBuf&lt;'a&gt;</code> to create a ReadBuf from a byte slice (rather than <code>uninit</code>)</li>
</ul>
<h2>Length functions</h2>
<ul>
<li>Keep <code>capacity</code></li>
<li><code>filled_len</code> -&gt; <code>len</code> to match <code>Vec</code> etc. (in fact, we don't even need it with the <code>Deref</code> impl, see below)</li>
<li>remove <code>remaining</code> (can use <code>capacity() - len()</code> or <code>unfilled().len()</code>)</li>
<li>remove <code>initialized_len</code> (can use <code>initialized().len()</code>)</li>
</ul>
<h2>Slicing functions</h2>
<ul>
<li>Keep <code>initialized</code>, <code>unfilled</code>, <code>uninitialized</code>, and mut variants</li>
<li>Remove <code>filled</code> and <code>filled_mut</code>, replace by implementing <code>Deref&lt;Target = [u8]&gt;</code> and <code>DerefMut</code></li>
</ul>
<h2>Initializing data</h2>
<ul>
<li>Remove <code>initialize_unfilled</code> and <code>initialize_unfilled_to</code>, unless these are super useful<ul>
<li>rationale, getting unfilled slice is easy, initialising is easy, so it seems the only benefit is tracking this</li>
</ul>
</li>
<li>keep <code>assume_init</code></li>
</ul>
<h2>Misc</h2>
<ul>
<li>Keep <code>clear</code> and <code>append</code></li>
<li>Remove <code>add_filled</code></li>
<li>Rename <code>set_filled</code> to <code>assume_filled</code> (to match <code>assume_init</code>)</li>
</ul>



<a name="273950584"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/273950584" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#273950584">(Mar 03 2022 at 10:10)</a>:</h4>
<p>For reference, current API is <a href="https://doc.rust-lang.org/nightly/std/io/struct.ReadBuf.html">https://doc.rust-lang.org/nightly/std/io/struct.ReadBuf.html</a></p>



<a name="273964188"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/273964188" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#273964188">(Mar 03 2022 at 12:23)</a>:</h4>
<p>The second half of this section of the RFC talks about returning the read count separately: <a href="https://github.com/rust-lang/rfcs/blob/master/text/2930-read-buf.md#rationale-and-alternatives">https://github.com/rust-lang/rfcs/blob/master/text/2930-read-buf.md#rationale-and-alternatives</a>. IMO it puts too much of the burden on consumers to remember all of the subtle checks required when working with <code>impl Read</code> + unsafe</p>



<a name="273964280"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/273964280" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#273964280">(Mar 03 2022 at 12:24)</a>:</h4>
<p>You could look at tokio stuff for usage - they have a copy of ReadBuf in their API: <a href="https://docs.rs/tokio/1.17.0/tokio/io/trait.AsyncRead.html">https://docs.rs/tokio/1.17.0/tokio/io/trait.AsyncRead.html</a></p>



<a name="273965148"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/273965148" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#273965148">(Mar 03 2022 at 12:31)</a>:</h4>
<p>This is the most pressing issue blocking stabilization IMO: <a href="https://github.com/rust-lang/rfcs/pull/2930#issuecomment-688933597">https://github.com/rust-lang/rfcs/pull/2930#issuecomment-688933597</a></p>



<a name="273966985"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/273966985" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#273966985">(Mar 03 2022 at 12:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243558">Steven Fackler</span> <a href="#narrow/stream/219381-t-libs/topic/ReadBuf.20API/near/273964188">said</a>:</p>
<blockquote>
<p>The second half of this section of the RFC talks about returning the read count separately: <a href="https://github.com/rust-lang/rfcs/blob/master/text/2930-read-buf.md#rationale-and-alternatives">https://github.com/rust-lang/rfcs/blob/master/text/2930-read-buf.md#rationale-and-alternatives</a>. IMO it puts too much of the burden on consumers to remember all of the subtle checks required when working with <code>impl Read</code> + unsafe</p>
</blockquote>
<p>I read that in the context of having the read count returned and having the filled len in ReadBuf, in which case I agree totally with the conclusion. But as an alternative where ReadBuf is simpler, I think it is more attractive - IMO, the difficult checks here are around the difference between init  but unfilled and uninit, which ReadBuf would still maintain. The number of bytes read (i.e., the filled len) is pretty simple, after all it corresponds exactly to reading using a byte buffer</p>



<a name="273978552"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/273978552" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Giacomo Stevanato <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#273978552">(Mar 03 2022 at 14:16)</a>:</h4>
<p><span class="user-mention silent" data-user-id="256841">Nick Cameron</span> <a href="#narrow/stream/219381-t-libs/topic/ReadBuf.20API/near/273950303">said</a>:</p>
<blockquote>
<ul>
<li>Should implement <code>From&lt;&amp;'a [u8]&gt; for ReadBuf&lt;'a&gt;</code> to create a ReadBuf from a byte slice (rather than <code>new</code>)</li>
<li>Should implement <code>From&lt;&amp;'a [MaybeUninit&lt;u8&gt;]&gt; for ReadBuf&lt;'a&gt;</code> to create a ReadBuf from a byte slice (rather than <code>uninit</code>)</li>
</ul>
</blockquote>
<p>Those should probably be <code>&amp;'a mut [u8]</code> and <code>&amp;'a mut [MaybeUninit&lt;u8&gt;]</code></p>



<a name="273979116"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/273979116" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#273979116">(Mar 03 2022 at 14:20)</a>:</h4>
<p>yes, indeed!</p>



<a name="274028776"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/274028776" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#274028776">(Mar 03 2022 at 19:48)</a>:</h4>
<p>I think "corresponds exactly to reading using a byte buffer" is not a feature in cases where using a byte buffer is easy to get wrong.</p>



<a name="274028872"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/274028872" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#274028872">(Mar 03 2022 at 19:49)</a>:</h4>
<p>Remembering to slice the byte buffer by the returned value is something the compiler gives no help with.</p>



<a name="274028905"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/274028905" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#274028905">(Mar 03 2022 at 19:49)</a>:</h4>
<p>It feels very much like c programming.</p>



<a name="274029147"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/274029147" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#274029147">(Mar 03 2022 at 19:50)</a>:</h4>
<p>If tracking the number of bytes read in ReadBuf means I can just ask the ReadBuf for the slice of bytes I just got, without having to <code>[..bytes_read]</code>, that seems like a great <em>improvement</em> over byte buffers.</p>



<a name="274097885"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/274097885" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#274097885">(Mar 04 2022 at 08:53)</a>:</h4>
<p>That makes a lot of sense, thanks!</p>



<a name="274097982"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/274097982" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#274097982">(Mar 04 2022 at 08:54)</a>:</h4>
<p>So, lets scratch that idea completely and just look at the smaller changes I suggested (which I acknowledge is still quite a significant overhaul).</p>



<a name="274098157"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/274098157" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#274098157">(Mar 04 2022 at 08:56)</a>:</h4>
<p>The bits I'm most unsure about are using deref to get to the filled buffer. This seems like a little bit of an abuse of deref and a bit magic, however, I do think it will make code read nicely. Alternatives are to stick to using a <code>filled</code> method or to impl <code>Into&lt;&amp;mut [u8]&gt;</code> to get the filled buffer.</p>



<a name="274098545"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/274098545" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#274098545">(Mar 04 2022 at 08:59)</a>:</h4>
<p>The other bit I'm unsure about is removing the initialize_unfilled methods, I see that these are useful when you want to get all the unfilled space for a task which expects a byte slice rather than a ReadBuf, but it also seems pretty easy to do yourself and not super common to do.</p>



<a name="274098934"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/274098934" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#274098934">(Mar 04 2022 at 09:01)</a>:</h4>
<p>An alternative, would be to rename to just <code>initialize</code>, I think adding the <code>unfilled</code> suffix does not really help understanding - I think the point is to make clear that the already initialized part of the buffer will not be reset, but as a casual reader, I would still need to look that up in the docs, so I don't think it adds a huge amount.</p>



<a name="274099089"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/274099089" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#274099089">(Mar 04 2022 at 09:03)</a>:</h4>
<p>I would also not return a slice, but return void (but see next thought) because I can imagine times when you would want a slice of the whole buffer, not just the unfilled part, and it seems that the current API is not very atomic.</p>



<a name="274099356"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/274099356" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#274099356">(Mar 04 2022 at 09:05)</a>:</h4>
<p>Next thought: I wonder if the various state-changing methods (assume_init, initialize_unfilled, etc.) should return <code>&amp;mut Self</code> rather than void to permit a more fluent, builder-style use of the API?</p>



<a name="274100639"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/274100639" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#274100639">(Mar 04 2022 at 09:17)</a>:</h4>
<p>Meta: should I copy these thoughts to the tracking issue or create a draft PR or something? I hoped to get some initial discussion going here, but I'm not clear what the usual/best way is to have this kind of discussion</p>



<a name="274103780"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/274103780" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#274103780">(Mar 04 2022 at 09:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="256841">Nick Cameron</span> <a href="#narrow/stream/219381-t-libs/topic/ReadBuf.20API/near/274099356">said</a>:</p>
<blockquote>
<p>Next thought: I wonder if the various state-changing methods (assume_init, initialize_unfilled, etc.) should return <code>&amp;mut Self</code> rather than void to permit a more fluent, builder-style use of the API?</p>
</blockquote>
<p>Would you expect typical usage to need to call several of those one after another?</p>



<a name="274104814"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/274104814" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#274104814">(Mar 04 2022 at 09:51)</a>:</h4>
<p>I would expect it is common usage to want to use a buffer after calling assume_init. Something like, let slice = bytes.assume_init(n).inititialized();</p>



<a name="274106181"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/274106181" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#274106181">(Mar 04 2022 at 10:00)</a>:</h4>
<p>Fair. I think a PR to make those chainable, along with a doc example showing that usage, would suffice.</p>



<a name="274106225"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/274106225" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#274106225">(Mar 04 2022 at 10:01)</a>:</h4>
<p>Do you have thoughts on the other suggested changes?</p>



<a name="274106490"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/274106490" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#274106490">(Mar 04 2022 at 10:03)</a>:</h4>
<p>Still processing them.</p>



<a name="274106660"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/274106660" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#274106660">(Mar 04 2022 at 10:05)</a>:</h4>
<p>As an aside, I suspect in practice I'm <em>often</em> going to wish <code>ReadBuf</code> had the option of owning its data, and failing that, I'm going to wish for self-referential structures.</p>



<a name="274106752"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/274106752" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#274106752">(Mar 04 2022 at 10:06)</a>:</h4>
<p>I have use cases today in which I store a <code>Vec&lt;u8&gt;</code> or a <code>[u8; 4096]</code> in a data structure as a buffer in progress. I'd like to be able to replace those with <code>ReadBuf</code> and avoid the unnecessary initialization. But I can't do that with <code>ReadBuf</code>.</p>



<a name="274107772"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/274107772" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#274107772">(Mar 04 2022 at 10:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="256841">Nick Cameron</span> <a href="#narrow/stream/219381-t-libs/topic/ReadBuf.20API/near/274098157">said</a>:</p>
<blockquote>
<p>The bits I'm most unsure about are using deref to get to the filled buffer. This seems like a little bit of an abuse of deref and a bit magic, however, I do think it will make code read nicely. Alternatives are to stick to using a <code>filled</code> method or to impl <code>Into&lt;&amp;mut [u8]&gt;</code> to get the filled buffer.</p>
</blockquote>
<p>I agree that using <code>Deref</code> seems a little questionable, since there are actually two possible buffers you might want, <code>filled</code> or <code>initialized</code>. The caller wants <code>filled</code>, while the callee might want <code>initialized</code>.</p>



<a name="274107839"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/274107839" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#274107839">(Mar 04 2022 at 10:15)</a>:</h4>
<p>In practice making things more ergonomic for the caller seems like the right tradeoff (many many more callers of read_buf than implementers of read_buf), but I do find Deref eyebrow-raising at least.</p>



<a name="274107859"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/274107859" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#274107859">(Mar 04 2022 at 10:15)</a>:</h4>
<p>It's worth further consideration, at the least.</p>



<a name="274108288"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/274108288" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#274108288">(Mar 04 2022 at 10:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="256841">Nick Cameron</span> <a href="#narrow/stream/219381-t-libs/topic/ReadBuf.20API/near/274098934">said</a>:</p>
<blockquote>
<p>An alternative, would be to rename to just <code>initialize</code>, I think adding the <code>unfilled</code> suffix does not really help understanding - I think the point is to make clear that the already initialized part of the buffer will not be reset, but as a casual reader, I would still need to look that up in the docs, so I don't think it adds a huge amount.</p>
</blockquote>
<p><span class="user-mention silent" data-user-id="256841">Nick Cameron</span> <a href="#narrow/stream/219381-t-libs/topic/ReadBuf.20API/near/274099089">said</a>:</p>
<blockquote>
<p>I would also not return a slice, but return void (but see next thought) because I can imagine times when you would want a slice of the whole buffer, not just the unfilled part, and it seems that the current API is not very atomic.</p>
</blockquote>
<p>I think these two thoughts are tied together. If the methods return a slice, I think they need to have <code>unfilled</code> in the name, because the important detail is that the slice they return is of the unfilled portion. Along the same lines, <code>initialize_unfilled_to</code> counts <code>n</code> bytes of unfilled data, not <code>n</code> bytes from the beginning.</p>



<a name="274108377"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/274108377" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#274108377">(Mar 04 2022 at 10:20)</a>:</h4>
<p>I do think that in general we don't need to make it <em>that</em> ergonomic to use <code>ReadBuf</code> as a thing you initialize and then write to; that kinda defeats the purpose.</p>



<a name="274108412"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/274108412" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#274108412">(Mar 04 2022 at 10:21)</a>:</h4>
<p>I think if those methods don't return a slice then they don't have reason to exist.</p>



<a name="274193932"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/274193932" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dirkjan Ochtman <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#274193932">(Mar 04 2022 at 21:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="239881">Josh Triplett</span> <a href="#narrow/stream/219381-t-libs/topic/ReadBuf.20API/near/274106752">said</a>:</p>
<blockquote>
<p>I have use cases today in which I store a <code>Vec&lt;u8&gt;</code> or a <code>[u8; 4096]</code> in a data structure as a buffer in progress. I'd like to be able to replace those with <code>ReadBuf</code> and avoid the unnecessary initialization. But I can't do that with <code>ReadBuf</code>.</p>
</blockquote>
<p>I've been thinking we'd want a <code>Vec::read_buf()</code> method that creates a <code>VecReadBuf</code> which can do the <code>Vec::set_len()</code> on <code>Drop</code>. The <code>VecReadBuf</code> would expose the inner <code>ReadBuf</code> somehow (maybe through <code>DerefMut</code>?).</p>



<a name="274567912"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/274567912" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Alice Ryhl <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#274567912">(Mar 08 2022 at 16:43)</a>:</h4>
<p>My experience from using the ReadBuf API in Tokio is that you really have to fix the footgun if you want to stabilize this. You will see _lots_ of unsound code if you don't.</p>



<a name="274568955"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/274568955" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#274568955">(Mar 08 2022 at 16:50)</a>:</h4>
<p>I filed issue <a href="https://github.com/rust-lang/rust/issues/94741">https://github.com/rust-lang/rust/issues/94741</a> to continue discussion. (I'm in the process of making one about the footgun, see also <a href="#narrow/stream/219381-t-libs/topic/Read.3A.3Abuf_read.20signature">https://rust-lang.zulipchat.com/#narrow/stream/219381-t-libs/topic/Read.3A.3Abuf_read.20signature</a>)</p>



<a name="274582018"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/274582018" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Conrad Ludgate <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#274582018">(Mar 08 2022 at 18:16)</a>:</h4>
<p>Reading some of this makes we wish we had a storage API in the language. ReadBuf seems a lot like <a href="https://docs.rs/cl-generic-vec/0.3.4/cl_generic_vec/type.SliceVec.html">https://docs.rs/cl-generic-vec/0.3.4/cl_generic_vec/type.SliceVec.html</a>, and the owned variety that <span class="user-mention" data-user-id="239881">@Josh Triplett</span> requested is just a normal or stack vec</p>



<a name="274583358"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/274583358" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Conrad Ludgate <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#274583358">(Mar 08 2022 at 18:26)</a>:</h4>
<p>I'm <a href="https://github.com/rust-lang/rust/pull/94421">already experimenting</a> with moving the vec impl to be inline with the HeapVec type you see in that crate, which should make any potential adoption of that design to be more streamlined</p>



<a name="274661036"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/274661036" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Conrad Ludgate <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#274661036">(Mar 09 2022 at 09:21)</a>:</h4>
<p>Here's a quick PoC crate combining lots of the proposed ideas <a href="https://docs.rs/cl-generic-read-buf/0.1.0/cl_generic_read_buf/">https://docs.rs/cl-generic-read-buf/0.1.0/cl_generic_read_buf/</a></p>



<a name="274697551"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/274697551" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Kestrer <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#274697551">(Mar 09 2022 at 14:47)</a>:</h4>
<p>That makes <code>Read</code> not object safe, right? I think that should be avoided.</p>



<a name="274699073"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/274699073" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Kestrer <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#274699073">(Mar 09 2022 at 14:57)</a>:</h4>
<p>Just musing about this, one mildy cursed option would be to make <code>ReadBuf</code> an "ultra-wide" pointer:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">ReadBuf</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">buf</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">a</span> <span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">],</span><span class="w"></span>
<span class="w">    </span><span class="n">filled</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">a</span> <span class="nc">mut</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">initialized</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">a</span> <span class="nc">mut</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="k">impl</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ReadBuf</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">buf</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">a</span> <span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">],</span><span class="w"> </span><span class="n">filled</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">a</span> <span class="nc">mut</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">initialized</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">a</span> <span class="nc">mut</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span><span class="w">  </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* ... */</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">reborrow</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">ReadBuf</span><span class="o">&lt;'</span><span class="nb">_</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* ... */</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>This approach would make replacing the <code>ReadBuf</code> impossible, as well as offering an extremely generic API. <code>Vec</code> can provide a function like this:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">impl</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">as_read_buf</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;'</span><span class="na">a</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">filled</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">a</span> <span class="nc">mut</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">ReadBuf</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* ... */</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>The only disadvantage is forcing every <code>read</code> call to accept a whole _four_ pointers, which isn't an insignificant nunber of bytes.</p>



<a name="274705814"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/274705814" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Conrad Ludgate <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#274705814">(Mar 09 2022 at 15:43)</a>:</h4>
<p><span class="user-mention silent" data-user-id="360486">Kestrer</span> <a href="#narrow/stream/219381-t-libs/topic/ReadBuf.20API/near/274697551">said</a>:</p>
<blockquote>
<p>That makes <code>Read</code> not object safe, right? I think that should be avoided.</p>
</blockquote>
<p>That is correct, good point. I think I can figure a way around that though</p>



<a name="274794898"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/274794898" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> DrMeepster <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#274794898">(Mar 10 2022 at 06:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="360486">Kestrer</span> <a href="#narrow/stream/219381-t-libs/topic/ReadBuf.20API/near/274699073">said</a>:</p>
<blockquote>
<p>Just musing about this, one mildy cursed option would be to make <code>ReadBuf</code> an "ultra-wide" pointer:</p>
</blockquote>
<p>that is incredibly cursed but also brilliant and I love it</p>



<a name="278296448"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/278296448" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#278296448">(Apr 08 2022 at 12:29)</a>:</h4>
<p>I have been pondering the ReadBuf API again, and I have a suggestion. But first I want to recap what I see as the problems:</p>



<a name="278296471"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/278296471" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#278296471">(Apr 08 2022 at 12:29)</a>:</h4>
<ol>
<li>The unsoundness footgun</li>
</ol>



<a name="278296876"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/278296876" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#278296876">(Apr 08 2022 at 12:32)</a>:</h4>
<ol start="2">
<li>It's a confusing API: there are three slices in play but they are named in terms of two sets of two views and the middle slice (unfilled and initialised) does not have a name. In addition the methods are not uniform in terms of which slice is used as the base, e.g., (without looking at the docs) is n in  assume_init(n) relative to the start of the buffer of the start of the unfilled part of the buffer?</li>
</ol>



<a name="278296992"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/278296992" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#278296992">(Apr 08 2022 at 12:33)</a>:</h4>
<ol start="3">
<li>Readers can mutate the filled part of the buffer. This has some use cases (compression), but means there is no way to get the number of bytes read from buffer and leads to some surprising edge cases like the size of the filled part being smaller after a read than before, or larger but not by the number of bytes read</li>
</ol>



<a name="278297159"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/278297159" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#278297159">(Apr 08 2022 at 12:35)</a>:</h4>
<p>I propose a solution which addresses all of these issues, but which requires an extra data structure (though note that all the viable proposals to solving the footgun issue (which is considered a blocker) also introduce another data structure, albeit usually a simple one).</p>



<a name="278297431"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/278297431" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#278297431">(Apr 08 2022 at 12:37)</a>:</h4>
<p>Basically we split ReadBuf into two, I call these ReadBuf and ReadCursor (strawman naming, I'm sure these can be improved). ReadBuf makes the distinction between filled and unfilled parts of the buffer and is created like today from initialised or uninitialised bytes. Getting the filled part gets bytes, getting the unfilled parts gets a ReadCursor by value: ReadBuf&lt;'a&gt;::unfilled(&amp;'b mut self) -&gt; ReadCursor&lt;'a, 'b&gt;</p>



<a name="278297868"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/278297868" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#278297868">(Apr 08 2022 at 12:41)</a>:</h4>
<p>Read::read_buf takes a ReadCursor by value, so it can not be accessed by the caller after the read call. ReadCursor provides access to the init and unint (but not the filled) part of the buffer. As the cursor is filled, it no longer has access to the filled data. Modifying the cursor (either filling or initialising) updates the buffer. After the read, the caller can update its backing data based on the lengths from the ReadBuf, and there is no way this could be switched out (i.e., the footgun is gone). The number of bytes read is guaranteed to be the difference between the length of the filled part before and after the read and the filled part can only grow during the read. Since each data structure only presents two slices, there is no ambiguity about the base index for each method.</p>



<a name="278298014"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/278298014" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#278298014">(Apr 08 2022 at 12:42)</a>:</h4>
<p>Of course we lose the ability for readers to compress their read data along with existing data, but IMO that is a good thing!</p>



<a name="278298364"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/278298364" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#278298364">(Apr 08 2022 at 12:44)</a>:</h4>
<p>(It's actually not quite as simple as this, the user has to be able to get and set the length of the initialised data on the ReadBuf so that they can setup the buffer and update their backing buffer from it, so there is some distinction between init and uninit in the ReadBuf API, but there is no direct access to the bytes)</p>



<a name="278298560"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/278298560" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#278298560">(Apr 08 2022 at 12:46)</a>:</h4>
<p>Draft code: <a href="https://gist.github.com/nrc/0b2db7a0bcb6fd9317e8218f31fd5719">https://gist.github.com/nrc/0b2db7a0bcb6fd9317e8218f31fd5719</a> (this is very unpolished and mostly just a copy and paste job from the existing API, I think we could improve the API a lot)</p>



<a name="278298704"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/278298704" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#278298704">(Apr 08 2022 at 12:48)</a>:</h4>
<p>Two questions: can we remove the 'b lifetime from ReadCursor? It is annoying. I don't think it can be merged with 'a, I wonder if we could make ReadCursor unsized and refer to it as &amp;mut ReadCursor&lt;'a&gt;, but then its not moved to Read::read_buf, so we have the footgun back :-(</p>



<a name="278298918"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/278298918" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#278298918">(Apr 08 2022 at 12:50)</a>:</h4>
<p>And would it be worth duplicating the length in ReadCursor so they are only updated 'locally' as the cursor is written to, then have an explicit <code>flush</code> method? I don't think this would work because the data and metadata would get out of sync and we'd need to rely on drop to keep things in sync, which is unsound.</p>



<a name="278298936"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/278298936" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#278298936">(Apr 08 2022 at 12:50)</a>:</h4>
<p>Anyway, thoughts?</p>



<a name="278376522"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/278376522" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#278376522">(Apr 09 2022 at 00:13)</a>:</h4>
<p><span class="user-mention" data-user-id="256841">@Nick Cameron</span> I'm not seeing an obvious reason why the ReadCursor couldn't give access to the data already filled via <em>that</em> ReadCursor, while preventing access to data filled via a <em>prior</em> ReadCursor.</p>



<a name="278376574"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/278376574" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#278376574">(Apr 09 2022 at 00:14)</a>:</h4>
<p>Take a ReadBuf, fill the first kilobyte, then get a new cursor, it points to the next kilobyte, you pass it to a read_buf call, it can write and re-write that second kilobyte, but can't touch the first kilobyte.</p>



<a name="278376675"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/278376675" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#278376675">(Apr 09 2022 at 00:16)</a>:</h4>
<p>(Also, unrelated, I'm starting to wonder if we should just call this <code>Buf</code> rather than <code>ReadBuf</code>; I wonder if we'll end up adding APIs to it that make it generally useful as both an input and output buffer.)</p>



<a name="278376794"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/278376794" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#278376794">(Apr 09 2022 at 00:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="256841">Nick Cameron</span> <a href="#narrow/stream/219381-t-libs/topic/ReadBuf.20API/near/278298704">said</a>:</p>
<blockquote>
<p>Two questions: can we remove the 'b lifetime from ReadCursor? It is annoying. I don't think it can be merged with 'a, I wonder if we could make ReadCursor unsized and refer to it as &amp;mut ReadCursor&lt;'a&gt;, but then its not moved to Read::read_buf, so we have the footgun back :-(</p>
</blockquote>
<p>I don't think that'd be a footgun, because the read_buf call couldn't use a <code>&amp;mut ReadCursor</code> to modify the ReadBuf in unexpected ways (such as replacing it completely).</p>



<a name="278376857"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/278376857" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#278376857">(Apr 09 2022 at 00:20)</a>:</h4>
<p>Unless you think people will reuse the ReadCursor rather than getting a fresh one for each read_buf call?</p>



<a name="278526503"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/278526503" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#278526503">(Apr 11 2022 at 09:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="239881">Josh Triplett</span> <a href="#narrow/stream/219381-t-libs/topic/ReadBuf.20API/near/278376522">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="256841">Nick Cameron</span> I'm not seeing an obvious reason why the ReadCursor couldn't give access to the data already filled via <em>that</em> ReadCursor, while preventing access to data filled via a <em>prior</em> ReadCursor.</p>
</blockquote>
<p>So, this is possible, just not explicitly supported by the API. I.e, the reader takes a view of the unfilled data as a slice and can then write to the slice <br>
however it likes, it can read back, re-write, whatever. Its only when the reader commits its writes by using <code>advance</code> that the data is 'moved' from the unfilled to the filled segment and the reader loses access. So when I say it doesn't have access to any filled data, I strictly mean any data which is filled from the perspective of the buffer, not from the perspective of the reader writing into it.</p>



<a name="278526573"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/278526573" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#278526573">(Apr 11 2022 at 09:13)</a>:</h4>
<p>I think that should be  OK for most use cases. Giving access to filled and committed data would mean tracking another length (and kind of segment from the user's perspective) which would make the API even more complicated</p>



<a name="278526667"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/278526667" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#278526667">(Apr 11 2022 at 09:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="239881">Josh Triplett</span> <a href="#narrow/stream/219381-t-libs/topic/ReadBuf.20API/near/278376675">said</a>:</p>
<blockquote>
<p>(Also, unrelated, I'm starting to wonder if we should just call this <code>Buf</code> rather than <code>ReadBuf</code>; I wonder if we'll end up adding APIs to it that make it generally useful as both an input and output buffer.)</p>
</blockquote>
<p>Yeah, I have been thinking the same thing, but maybe BorrowedBuf or SliceBuf, since I think we might also want an OwnedBuf for io_uring style interfaces</p>



<a name="278526754"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/278526754" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#278526754">(Apr 11 2022 at 09:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="256841">Nick Cameron</span> <a href="#narrow/stream/219381-t-libs/topic/ReadBuf.20API/near/278526503">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="239881">Josh Triplett</span> <a href="#narrow/stream/219381-t-libs/topic/ReadBuf.20API/near/278376522">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="256841">Nick Cameron</span> I'm not seeing an obvious reason why the ReadCursor couldn't give access to the data already filled via <em>that</em> ReadCursor, while preventing access to data filled via a <em>prior</em> ReadCursor.</p>
</blockquote>
<p>So, this is possible, just not explicitly supported by the API. I.e, the reader takes a view of the unfilled data as a slice and can then write to the slice <br>
however it likes, it can read back, re-write, whatever. Its only when the reader commits its writes by using <code>advance</code> that the data is 'moved' from the unfilled to the filled segment and the reader loses access. So when I say it doesn't have access to any filled data, I strictly mean any data which is filled from the perspective of the buffer, not from the perspective of the reader writing into it.</p>
</blockquote>
<p>That means you have to keep working with a slice of MaybeUninit though, even once you know which parts you've filled.</p>



<a name="278526999"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/278526999" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#278526999">(Apr 11 2022 at 09:16)</a>:</h4>
<p><span class="user-mention silent" data-user-id="239881">Josh Triplett</span> <a href="#narrow/stream/219381-t-libs/topic/ReadBuf.20API/near/278376857">said</a>:</p>
<blockquote>
<p>Unless you think people will reuse the ReadCursor rather than getting a fresh one for each read_buf call?</p>
</blockquote>
<p>I don't think they would reuse the cursor, though they could (would that count as a footgun? It seems technically as possible as the current situation, although the incentives change a bit), but they might get the uninit length from the cursor rather than the buffer which would be unsound (well unsound if they don't check the address, i.e., the same footgun) and I think that would be just as feasible as currently?</p>



<a name="278527078"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/278527078" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#278527078">(Apr 11 2022 at 09:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="239881">Josh Triplett</span> <a href="#narrow/stream/219381-t-libs/topic/ReadBuf.20API/near/278526754">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="256841">Nick Cameron</span> <a href="#narrow/stream/219381-t-libs/topic/ReadBuf.20API/near/278526503">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="239881">Josh Triplett</span> <a href="#narrow/stream/219381-t-libs/topic/ReadBuf.20API/near/278376522">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="256841">Nick Cameron</span> I'm not seeing an obvious reason why the ReadCursor couldn't give access to the data already filled via <em>that</em> ReadCursor, while preventing access to data filled via a <em>prior</em> ReadCursor.</p>
</blockquote>
<p>So, this is possible, just not explicitly supported by the API. I.e, the reader takes a view of the unfilled data as a slice and can then write to the slice <br>
however it likes, it can read back, re-write, whatever. Its only when the reader commits its writes by using <code>advance</code> that the data is 'moved' from the unfilled to the filled segment and the reader loses access. So when I say it doesn't have access to any filled data, I strictly mean any data which is filled from the perspective of the buffer, not from the perspective of the reader writing into it.</p>
</blockquote>
<p>That means you have to keep working with a slice of MaybeUninit though, even once you know which parts you've filled.</p>
</blockquote>
<p>They could call <code>slice_assume_init_ref</code> or use <code>initialize_to</code> to get an initialized slice.</p>



<a name="278527144"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/278527144" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#278527144">(Apr 11 2022 at 09:18)</a>:</h4>
<p>That'd lose the efficiency of using <code>read_buf</code>.</p>



<a name="278527168"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/ReadBuf%20API/near/278527168" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/ReadBuf.20API.html#278527168">(Apr 11 2022 at 09:18)</a>:</h4>
<p>Oh, wait, <code>assume_init</code>, yes, that would work.</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>