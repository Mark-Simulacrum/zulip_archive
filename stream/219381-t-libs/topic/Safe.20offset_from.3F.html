<html>
<head><meta charset="utf-8"><title>Safe offset_from? · t-libs · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/index.html">t-libs</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Safe.20offset_from.3F.html">Safe offset_from?</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="246055839"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Safe%20offset_from%3F/near/246055839" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Simon Sapin <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Safe.20offset_from.3F.html#246055839">(Jul 15 2021 at 06:16)</a>:</h4>
<p><a href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html#method.offset_from">https://doc.rust-lang.org/nightly/std/primitive.pointer.html#method.offset_from</a> has pretty steep safety requirements. Is it possible to build a safe API like it that works on slices and is fallible? (returns <code>None</code> if the parameter is not a sub-slice)</p>



<a name="246055947"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Safe%20offset_from%3F/near/246055947" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Simon Sapin <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Safe.20offset_from.3F.html#246055947">(Jul 15 2021 at 06:19)</a>:</h4>
<p>In particular: how to check whether pointers are from the same allocated object, without the check itself invoking provenance daemons?</p>



<a name="246056753"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Safe%20offset_from%3F/near/246056753" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Safe.20offset_from.3F.html#246056753">(Jul 15 2021 at 06:35)</a>:</h4>
<p>You can't. It is a compiler concept, not something physically represented after compilation.</p>



<a name="246059532"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Safe%20offset_from%3F/near/246059532" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Simon Sapin <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Safe.20offset_from.3F.html#246059532">(Jul 15 2021 at 07:18)</a>:</h4>
<p>I ended up doing <code>usize</code> arithmetic without using <code>ptr::offset_from</code>. Does this look correct?</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="w">        </span><span class="k">fn</span> <span class="nf">address_range</span><span class="p">(</span><span class="n">slice</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nc">std</span>::<span class="n">ops</span>::<span class="n">RangeInclusive</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slice</span><span class="p">.</span><span class="n">as_ptr</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">slice</span><span class="p">.</span><span class="n">len</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="n">start</span><span class="o">..=</span><span class="n">end</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">slice_addresses</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address_range</span><span class="p">(</span><span class="n">slice</span><span class="p">.</span><span class="n">as_bytes</span><span class="p">());</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">on_disk_addresses</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address_range</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">dirstate_map</span><span class="p">.</span><span class="n">on_disk</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">on_disk_addresses</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="n">slice_addresses</span><span class="p">.</span><span class="n">start</span><span class="p">())</span><span class="w"></span>
<span class="w">            </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">on_disk_addresses</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="n">slice_addresses</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"></span>
<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slice_addresses</span><span class="p">.</span><span class="n">start</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">on_disk_addresses</span><span class="p">.</span><span class="n">start</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="nb">Some</span><span class="p">(</span><span class="n">offset_from_usize</span><span class="p">(</span><span class="n">offset</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="nb">None</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
</code></pre></div>



<a name="246061716"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Safe%20offset_from%3F/near/246061716" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nagisa <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Safe.20offset_from.3F.html#246061716">(Jul 15 2021 at 07:47)</a>:</h4>
<p>It matters what offset_from_usize is offsetting from. If it's working off <code>on_disk_address</code> then this seems right to me</p>



<a name="246061815"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Safe%20offset_from%3F/near/246061815" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nagisa <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Safe.20offset_from.3F.html#246061815">(Jul 15 2021 at 07:48)</a>:</h4>
<p>you will end up with a pointer with the <code>on_disk_address</code>'s provenance. And since that object is strict superset of <code>slice</code> you aren't at risk of making an invalid pointer.</p>



<a name="246066164"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Safe%20offset_from%3F/near/246066164" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Simon Sapin <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Safe.20offset_from.3F.html#246066164">(Jul 15 2021 at 08:34)</a>:</h4>
<p>(Sorry I didn’t remove the parts less relevant, <code>offset_from_usize</code> does not offset pointers but returns a <code>struct Offset([u8; 4])</code> for 32-bit big-endian without alignment, for writing in a binary file format)</p>



<a name="246066521"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Safe%20offset_from%3F/near/246066521" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Simon Sapin <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Safe.20offset_from.3F.html#246066521">(Jul 15 2021 at 08:38)</a>:</h4>
<p>Why does <code>ptr::offset_from</code> have so much safety requirements compared to converting to <code>usize</code> and subtracting?</p>



<a name="246072543"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Safe%20offset_from%3F/near/246072543" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jacob Lifshay <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Safe.20offset_from.3F.html#246072543">(Jul 15 2021 at 09:47)</a>:</h4>
<p><span class="user-mention silent" data-user-id="219747">Simon Sapin</span> <a href="#narrow/stream/219381-t-libs/topic/Safe.20offset_from.3F/near/246066521">said</a>:</p>
<blockquote>
<p>Why does <code>ptr::offset_from</code> have so much safety requirements compared to converting to <code>usize</code> and subtracting?</p>
</blockquote>
<p>I'd expect the semantics are inherited from C. Part of requiring the offset to be divisible by <code>size_of::&lt;T&gt;()</code> is so the compiler can use fancy math to convert the division into a shift and/or multiplication.</p>



<a name="246076753"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Safe%20offset_from%3F/near/246076753" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nagisa <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Safe.20offset_from.3F.html#246076753">(Jul 15 2021 at 10:37)</a>:</h4>
<p>It preserves provenance of the object being offset from, which gives the compiler information about what the object ought to be.</p>



<a name="246076850"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Safe%20offset_from%3F/near/246076850" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nagisa <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Safe.20offset_from.3F.html#246076850">(Jul 15 2021 at 10:38)</a>:</h4>
<p>i.e. the operation of offsetting from a pointer to an object that compiler otherwise might not know anything about gives it useful information about what the object may be (e.g. its size)</p>



<a name="246076953"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Safe%20offset_from%3F/near/246076953" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nagisa <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Safe.20offset_from.3F.html#246076953">(Jul 15 2021 at 10:39)</a>:</h4>
<p>You can use <code>wrapping_offset</code> for a less strong variant.</p>



<a name="246077036"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Safe%20offset_from%3F/near/246077036" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nagisa <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Safe.20offset_from.3F.html#246077036">(Jul 15 2021 at 10:40)</a>:</h4>
<p>casting to an integer is the most flexible and most optimization defeating option.</p>



<a name="246077107"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Safe%20offset_from%3F/near/246077107" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nagisa <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Safe.20offset_from.3F.html#246077107">(Jul 15 2021 at 10:41)</a>:</h4>
<p>Ah, I guess we don't have a <code>wrapping_offset_from</code> <span aria-label="frown" class="emoji emoji-1f641" role="img" title="frown">:frown:</span></p>



<a name="246627999"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Safe%20offset_from%3F/near/246627999" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Safe.20offset_from.3F.html#246627999">(Jul 20 2021 at 18:07)</a>:</h4>
<p>There used to be, but it was deprecated a year and a bit ago: <a href="https://github.com/rust-lang/rust/pull/73580">https://github.com/rust-lang/rust/pull/73580</a></p>



<a name="248378779"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Safe%20offset_from%3F/near/248378779" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Simon Sapin <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Safe.20offset_from.3F.html#248378779">(Aug 04 2021 at 17:08)</a>:</h4>
<p><code>offset_from</code> returns <code>isize</code>, not another pointer. What does preserving provenance even mean there?</p>



<a name="248379334"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Safe%20offset_from%3F/near/248379334" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Safe.20offset_from.3F.html#248379334">(Aug 04 2021 at 17:13)</a>:</h4>
<p>provenance is not a feature of a type, but of a value, but you are right, that returned <code>isize</code> has no provenance if used on two pointers with the same provenance, you need a pointer with provenance in order to obtain a real pointer again. Using two pointers with different provenance as arguments to <code>offset_from</code> is UB as we don't have the concept of values with two separate provenances, and thus any behaviour with such values is undefined</p>



<a name="248380591"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Safe%20offset_from%3F/near/248380591" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Simon Sapin <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Safe.20offset_from.3F.html#248380591">(Aug 04 2021 at 17:23)</a>:</h4>
<p>Why is it useful to declare UB when <code>offset_from</code> arguments have different provenance, given that the return value does not have any provenance itself?</p>



<a name="248385511"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Safe%20offset_from%3F/near/248385511" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Safe.20offset_from.3F.html#248385511">(Aug 04 2021 at 18:02)</a>:</h4>
<p>the return value will have <em>two</em> provenances if you pass two args of different provenance, and we haven't defined what the meaning of two provenances is. There's probably more subtlety here, but this is as far as my understanding goes</p>



<a name="248385550"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Safe%20offset_from%3F/near/248385550" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Safe.20offset_from.3F.html#248385550">(Aug 04 2021 at 18:03)</a>:</h4>
<p>if you pass two arguments with the same provenance, the return value is indeed provenance-free</p>



<a name="248767905"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Safe%20offset_from%3F/near/248767905" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Simon Sapin <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Safe.20offset_from.3F.html#248767905">(Aug 08 2021 at 12:19)</a>:</h4>
<p>I don’t understand what having two provenances means, or what an integer having any provenance means</p>



<a name="248775539"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Safe%20offset_from%3F/near/248775539" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Safe.20offset_from.3F.html#248775539">(Aug 08 2021 at 15:22)</a>:</h4>
<p>it has no meaning, that why it is UB. Think about it this way: each pointer is actually a <code>(symbolic_id42, 99)</code> pair, where the <code>99</code> is some offset from the base address. if the symbolic ids are the same when subtracting two pointers, you get a <code>(None, 42)</code> like result, where the symbols cancel out and the offsets are subtracted as integers. This result has no provenance. Subtracting <code>(id69, 42)</code> from <code>(id21, 12)</code> would give you <code>(id21 - id69, -30)</code>, for which we are "simply" lacking rules for the meaning of. When I say "two provenances" that is wrong, what I mean is that the provenance is built from two distinct ones, which we haven't defined at all</p>



<a name="248775569"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Safe%20offset_from%3F/near/248775569" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Safe.20offset_from.3F.html#248775569">(Aug 08 2021 at 15:23)</a>:</h4>
<p>types are irrelevant for provenances (mostly). values can have provenance or not.</p>



<a name="248775858"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Safe%20offset_from%3F/near/248775858" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mara <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Safe.20offset_from.3F.html#248775858">(Aug 08 2021 at 15:30)</a>:</h4>
<p><span class="user-mention silent" data-user-id="219747">Simon Sapin</span> <a href="#narrow/stream/219381-t-libs/topic/Safe.20offset_from.3F/near/246055839">said</a>:</p>
<blockquote>
<p><a href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html#method.offset_from">https://doc.rust-lang.org/nightly/std/primitive.pointer.html#method.offset_from</a> has pretty steep safety requirements. Is it possible to build a safe API like it that works on slices and is fallible? (returns <code>None</code> if the parameter is not a sub-slice)</p>
</blockquote>
<p>i opened an rfc for such a feature a while ago: <a href="https://github.com/rust-lang/rfcs/pull/2796">https://github.com/rust-lang/rfcs/pull/2796</a>, but it got stuck</p>



<a name="248785734"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Safe%20offset_from%3F/near/248785734" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Simon Sapin <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Safe.20offset_from.3F.html#248785734">(Aug 08 2021 at 19:44)</a>:</h4>
<p><span class="user-mention" data-user-id="310399">@Mara</span>, it looks like if the RFC sticks to the proposed slice methods without the raw pointer alternative, then it only needs fixes to the proposed implementation? Would it help if I write up another proposed implementation based on the feedback?</p>



<a name="248785841"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Safe%20offset_from%3F/near/248785841" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mara <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Safe.20offset_from.3F.html#248785841">(Aug 08 2021 at 19:47)</a>:</h4>
<p>sure, that'd help :)   i should also read the comments again to figure out the state of it. it's been ages since i submitted that rfc ^^'</p>



<a name="248845232"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Safe%20offset_from%3F/near/248845232" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Simon Sapin <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Safe.20offset_from.3F.html#248845232">(Aug 09 2021 at 13:24)</a>:</h4>
<p>An RFC comment gives this example <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=7b663101329adc698e7b527c4af771b3">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=7b663101329adc698e7b527c4af771b3</a> where safe code can create slices where “The distance between the pointers, in bytes, must be an exact multiple of the size of T” does not hold. Given that, I have a hard time coming up for <em>any</em> use case where <code>offset_from</code> is valid and helpful to use. If I already need to manipulate addresses  as integers to do a modulo operation to check for that multiple constraint, I might as well do the division to implement the rest of what <code>offset_from</code> does.</p>



<a name="248845268"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Safe%20offset_from%3F/near/248845268" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Simon Sapin <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Safe.20offset_from.3F.html#248845268">(Aug 09 2021 at 13:24)</a>:</h4>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">bytemuck</span>::<span class="n">cast_slice</span><span class="p">;</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span>: <span class="kp">&amp;</span><span class="p">[[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]];</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">y</span>: <span class="kp">&amp;</span><span class="p">[[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cast_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cast_slice</span>::<span class="o">&lt;</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">]);</span><span class="w"></span>

<span class="w">    </span><span class="fm">dbg!</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">// x: [[1,2],[3,4]]</span>
<span class="w">    </span><span class="c1">// y: [[2,3]]</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>



<a name="248858738"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Safe%20offset_from%3F/near/248858738" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Simon Sapin <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Safe.20offset_from.3F.html#248858738">(Aug 09 2021 at 14:59)</a>:</h4>
<p>New proposed implementation for offset_of and range_of: <a href="https://github.com/rust-lang/rfcs/pull/2796#issuecomment-895296202">https://github.com/rust-lang/rfcs/pull/2796#issuecomment-895296202</a></p>



<a name="248868181"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Safe%20offset_from%3F/near/248868181" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mara <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Safe.20offset_from.3F.html#248868181">(Aug 09 2021 at 16:01)</a>:</h4>
<p><span class="user-mention" data-user-id="219747">@Simon Sapin</span> what happens if the subslice has a length of zero? i think it's sound to create a slice with <code>std::slice::from_raw_parts</code> to any place even outside any allocations as long as the length is zero and the pointer is aligned and non-null.  so you could make a zero-length slice from another allocation with an out-of-bounds offset that falls into another allocation. breaking provenance rules again?</p>



<a name="248868671"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Safe%20offset_from%3F/near/248868671" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mara <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Safe.20offset_from.3F.html#248868671">(Aug 09 2021 at 16:04)</a>:</h4>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">];</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Safety: All fine because the length is 0.</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">slice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">std</span>::<span class="n">slice</span>::<span class="n">from_raw_parts</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">as_ptr</span><span class="p">().</span><span class="n">offset</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">"a start = {:p}"</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">"a   end = {:p}"</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="o">..</span><span class="p">]);</span><span class="w"></span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">"b start = {:p}"</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">"b   end = {:p}"</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="o">..</span><span class="p">]);</span><span class="w"></span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">"slice   = {:p}"</span><span class="p">,</span><span class="w"> </span><span class="n">slice</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<div class="codehilite"><pre><span></span><code>a start = 0x7ffd3d103aa0
a   end = 0x7ffd3d103aa8
b start = 0x7ffd3d103aa8
b   end = 0x7ffd3d103ab0
slice   = 0x7ffd3d103aac
</code></pre></div>



<a name="248868820"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Safe%20offset_from%3F/near/248868820" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mara <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Safe.20offset_from.3F.html#248868820">(Aug 09 2021 at 16:05)</a>:</h4>
<p><code>slice</code> here is made from <code>a</code>, but happens to point inside <code>b</code>. <code>b.range_of(slice)</code> would run into UB now, right?</p>



<a name="248868980"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Safe%20offset_from%3F/near/248868980" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Simon Sapin <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Safe.20offset_from.3F.html#248868980">(Aug 09 2021 at 16:06)</a>:</h4>
<p>As far as I understand in that example <code>range_of</code> would run into UB if it used <code>&lt;*const T&gt;::offset_from</code></p>



<a name="248868985"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Safe%20offset_from%3F/near/248868985" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Simon Sapin <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Safe.20offset_from.3F.html#248868985">(Aug 09 2021 at 16:06)</a>:</h4>
<p>But my proposed implementation doesn’t</p>



<a name="248869501"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Safe%20offset_from%3F/near/248869501" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Safe.20offset_from.3F.html#248869501">(Aug 09 2021 at 16:09)</a>:</h4>
<blockquote>
<p>so you could make a zero-length slice from another allocation with an out-of-bounds offset</p>
</blockquote>
<p>I'm not sure that is legally doable in any way</p>



<a name="248869624"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Safe%20offset_from%3F/near/248869624" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mara <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Safe.20offset_from.3F.html#248869624">(Aug 09 2021 at 16:10)</a>:</h4>
<p>hm. well you're not using unsafe anyway, so must be fine ^^'. i wonder what it all looks like to llvm. subtracting usizes vs pointers.</p>



<a name="248869664"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Safe%20offset_from%3F/near/248869664" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mara <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Safe.20offset_from.3F.html#248869664">(Aug 09 2021 at 16:10)</a>:</h4>
<p><span class="user-mention" data-user-id="124288">@oli</span> why not? the docs say that a dangling pointer is fine with length zero</p>



<a name="248869668"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Safe%20offset_from%3F/near/248869668" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Simon Sapin <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Safe.20offset_from.3F.html#248869668">(Aug 09 2021 at 16:10)</a>:</h4>
<p>oh right, <code>offset</code> is unsafe and requires "same-object"</p>



<a name="248869821"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Safe%20offset_from%3F/near/248869821" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Simon Sapin <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Safe.20offset_from.3F.html#248869821">(Aug 09 2021 at 16:11)</a>:</h4>
<p><code>wrapping_offset</code> is safe but says using the returned pointer may be unsound</p>



<a name="248869881"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Safe%20offset_from%3F/near/248869881" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Simon Sapin <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Safe.20offset_from.3F.html#248869881">(Aug 09 2021 at 16:12)</a>:</h4>
<p>idk if that includes zero-length "uses"</p>



<a name="248869942"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Safe%20offset_from%3F/near/248869942" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mara <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Safe.20offset_from.3F.html#248869942">(Aug 09 2021 at 16:12)</a>:</h4>
<p>one-past-the-end pointers are valid too. so change the <code>3</code> for a <code>2</code> in my example to fix that, and the problem is still there</p>



<a name="248870041"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Safe%20offset_from%3F/near/248870041" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mara <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Safe.20offset_from.3F.html#248870041">(Aug 09 2021 at 16:13)</a>:</h4>
<p>then you can even do it safely. <code>let slice = a[2..];</code></p>



<a name="248870298"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Safe%20offset_from%3F/near/248870298" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mara <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Safe.20offset_from.3F.html#248870298">(Aug 09 2021 at 16:15)</a>:</h4>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">];</span><span class="w"></span>

<span class="w">    </span><span class="fm">dbg!</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">range_of</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="o">..</span><span class="p">]));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>gives either</p>
<div class="codehilite"><pre><span></span><code>[src/main.rs:118] b.range_of(&amp;a[2..]) = Some(
    0..0,
)
</code></pre></div>
<p>or</p>
<div class="codehilite"><pre><span></span><code>[src/main.rs:118] b.range_of(&amp;a[2..]) = None
</code></pre></div>
<p>depending on the phase of the moon</p>



<a name="248870553"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Safe%20offset_from%3F/near/248870553" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mara <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Safe.20offset_from.3F.html#248870553">(Aug 09 2021 at 16:16)</a>:</h4>
<p>what i'm wondering is if llvm may assume that this is always None (because different allocations), even though it might be Some().</p>



<a name="248870923"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Safe%20offset_from%3F/near/248870923" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mara <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Safe.20offset_from.3F.html#248870923">(Aug 09 2021 at 16:19)</a>:</h4>
<p>(that'd be a bigger problem than just this rfc though. since it's all safe code ^^)</p>



<a name="248872686"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Safe%20offset_from%3F/near/248872686" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Simon Sapin <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Safe.20offset_from.3F.html#248872686">(Aug 09 2021 at 16:33)</a>:</h4>
<blockquote>
<p>depending on the phase of the moon</p>
</blockquote>
<p>Is that with <code>offset_from</code>?</p>



<a name="248872800"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Safe%20offset_from%3F/near/248872800" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mara <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Safe.20offset_from.3F.html#248872800">(Aug 09 2021 at 16:34)</a>:</h4>
<p>nope. with your implementation.</p>



<a name="248872922"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Safe%20offset_from%3F/near/248872922" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mara <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Safe.20offset_from.3F.html#248872922">(Aug 09 2021 at 16:34)</a>:</h4>
<p>'phase of the moon' here means whether a and b are stored right next to eachother with b right after a, or not. (e.g. debug vs release build)</p>



<a name="248884532"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Safe%20offset_from%3F/near/248884532" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Simon Sapin <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Safe.20offset_from.3F.html#248884532">(Aug 09 2021 at 18:01)</a>:</h4>
<p>Ah I see. What <em>should</em> the behavior be in that case? If <code>&amp;a[2..]</code> and <code>&amp;b[..0]</code> have the same address and length they’re indistinguishable at runtime</p>



<a name="249121213"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Safe%20offset_from%3F/near/249121213" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mara <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Safe.20offset_from.3F.html#249121213">(Aug 11 2021 at 15:07)</a>:</h4>
<p>yes. i don't know</p>



<a name="249122277"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Safe%20offset_from%3F/near/249122277" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Safe.20offset_from.3F.html#249122277">(Aug 11 2021 at 15:15)</a>:</h4>
<p>I think it's a concept of the abstract machine. Like, the optimizer can assume they're different even if they are "physically" the same.</p>



<a name="249131302"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Safe%20offset_from%3F/near/249131302" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mara <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Safe.20offset_from.3F.html#249131302">(Aug 11 2021 at 16:19)</a>:</h4>
<p>if the optimizer can assume that in this case with Simon's implementation, we can cause UB without any unsafe code. that'd be bad.</p>



<a name="249208651"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Safe%20offset_from%3F/near/249208651" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Simon Sapin <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Safe.20offset_from.3F.html#249208651">(Aug 12 2021 at 08:21)</a>:</h4>
<p>I think we can have an unspecified outcome (among two possibilities, and may be affected by optimizer decisions) that is not necessarily UB</p>



<a name="249208785"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Safe%20offset_from%3F/near/249208785" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Simon Sapin <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Safe.20offset_from.3F.html#249208785">(Aug 12 2021 at 08:23)</a>:</h4>
<p>UB would be: the optimizer is allowed to <em>assume</em> a particular outcome and eliminate a call based on things it "knows" about the inputs. Then if assumptions are violated "impossible" things can happen, and therefore anything can happen</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>