<html>
<head><meta charset="utf-8"><title>Comparator in ordered collections · t-libs · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/index.html">t-libs</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Comparator.20in.20ordered.20collections.html">Comparator in ordered collections</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="266055801"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Comparator%20in%20ordered%20collections/near/266055801" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> TennyZhuang <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Comparator.20in.20ordered.20collections.html#266055801">(Dec 25 2021 at 11:45)</a>:</h4>
<p>Hi, all. I’m interested in add a Comparator API in ordered collections such as BTreeMap or BinaryHeap. </p>
<p>Currently, it can be done by wrapped types based on customized Ord implementation, but there are some problems. The entry types may need to be compared based on some extra dynamic information. E.g there are Row type in database, they may be composed as multiple fields a, b, c. And the compare rule may be dynamic generated by user sql “ORDER BY a ASC, b DESC, c ASC”, we may introduce a custom type OrderRule to describe the behavior. Then if we want to store Row in BTreeMap, we have to introduce a wrapper, OrderedRow with Row and a reference to OrderRule. Then we can implement Ord for OrederedRow. But the OrederedRow is at least 8 (raw reference, which is hard to use with lifetime) or 16 (Rc) bytes bigger then the original Row type, which is meaningless overhead. We also have to do unnecessary check in Ord implementation of OrderedRow that the OrderRule are same (in fact, they are always identical).</p>
<p>A best solution is introducing comparator into generic argument in  ordered collection, which is similar in C++.</p>
<p>I’m not sure whether there are some existing discussions about it. If not yet, I’d like to submit an RFC for it.</p>



<a name="266061135"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Comparator%20in%20ordered%20collections/near/266061135" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Comparator.20in.20ordered.20collections.html#266061135">(Dec 25 2021 at 14:15)</a>:</h4>
<p>For heaps, see <a href="https://crates.io/crates/binary-heap-plus">https://crates.io/crates/binary-heap-plus</a> and their references to past discussions.</p>



<a name="266061245"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Comparator%20in%20ordered%20collections/near/266061245" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Comparator.20in.20ordered.20collections.html#266061245">(Dec 25 2021 at 14:18)</a>:</h4>
<p>IIRC they did try adding a generic arg in std, and even with a default it caused a lot of type inference problems.</p>



<a name="266070272"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Comparator%20in%20ordered%20collections/near/266070272" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> TennyZhuang <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Comparator.20in.20ordered.20collections.html#266070272">(Dec 25 2021 at 18:32)</a>:</h4>
<p>I’ve found <a href="https://github.com/rust-lang/rust/issues/69454">#69454</a>, it seems that it was rejected due to potential compatibility breaking (but I think it is similar to allocator_api).</p>
<p>I’ve also found a pre-RFC in rust forum, but not any formal RFC to describe it.</p>



<a name="266071280"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Comparator%20in%20ordered%20collections/near/266071280" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Comparator.20in.20ordered.20collections.html#266071280">(Dec 25 2021 at 19:01)</a>:</h4>
<p>If the data isn't mutated frequently you could also try a sorted vec + binary search, those take comparison functions.</p>



<a name="266071407"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Comparator%20in%20ordered%20collections/near/266071407" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> TennyZhuang <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Comparator.20in.20ordered.20collections.html#266071407">(Dec 25 2021 at 19:05)</a>:</h4>
<p>Thanks, but unfortunately we are implementing a database, and the BTreeMap is a part of memory component. It’s impossible to assume the frequency of mutations.</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>