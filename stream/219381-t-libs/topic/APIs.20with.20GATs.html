<html>
<head><meta charset="utf-8"><title>APIs with GATs · t-libs · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/index.html">t-libs</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html">APIs with GATs</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="268091434"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/268091434" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#268091434">(Jan 15 2022 at 00:17)</a>:</h4>
<p>With GATs closing in on stabilization, I'm wondering if people have thoughts to what APIs might end up in std that use GATs. I'm thinking, for example, <code>LendingIterator</code>. Curious what peoples' thoughts are on starting to land those APIs as unstable?</p>



<a name="268093843"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/268093843" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Noah Lev <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#268093843">(Jan 15 2022 at 00:56)</a>:</h4>
<p>Somewhat off-topic, but I think the name <code>LendingIterator</code> might need more discussion since usually the terms "borrow" or "ref[erence]" are used rather than "loan".</p>



<a name="268093867"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/268093867" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Noah Lev <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#268093867">(Jan 15 2022 at 00:56)</a>:</h4>
<p>It could be that it's the clearest name among the possibilities, though.</p>



<a name="268099556"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/268099556" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jane Lusby [she/her] <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#268099556">(Jan 15 2022 at 02:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="232957">Jack Huey</span> <a href="#narrow/stream/219381-t-libs/topic/APIs.20with.20GATs/near/268091434">said</a>:</p>
<blockquote>
<p>With GATs closing in on stabilization, I'm wondering if people have thoughts to what APIs might end up in std that use GATs. I'm thinking, for example, <code>LendingIterator</code>. Curious what peoples' thoughts are on starting to land those APIs as unstable?</p>
</blockquote>
<p><span aria-label="+1" class="emoji emoji-1f44d" role="img" title="+1">:+1:</span> imo</p>



<a name="268099617"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/268099617" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jane Lusby [she/her] <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#268099617">(Jan 15 2022 at 02:40)</a>:</h4>
<p><span class="user-mention silent" data-user-id="307537">Noah Lev</span> <a href="#narrow/stream/219381-t-libs/topic/APIs.20with.20GATs/near/268093843">said</a>:</p>
<blockquote>
<p>Somewhat off-topic, but I think the name <code>LendingIterator</code> might need more discussion since usually the terms "borrow" or "ref[erence]" are used rather than "loan".</p>
</blockquote>
<p>and discussions about specific GAT apis like this can go in the PRs/tracking issues for those unstable APIs</p>



<a name="268099630"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/268099630" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jane Lusby [she/her] <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#268099630">(Jan 15 2022 at 02:40)</a>:</h4>
<p>no need to hash that out rn</p>



<a name="268100182"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/268100182" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#268100182">(Jan 15 2022 at 02:52)</a>:</h4>
<p>do you think we'll be able to have <code>impl&lt;I: Iterator&gt; LendingIterator for I</code>?</p>



<a name="268106262"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/268106262" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Simon Sapin <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#268106262">(Jan 15 2022 at 05:26)</a>:</h4>
<p>Is <code>LendingIterator</code> the same idea as <a href="https://docs.rs/streaming-iterator">https://docs.rs/streaming-iterator</a> ?</p>



<a name="268106318"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/268106318" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> TennyZhuang <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#268106318">(Jan 15 2022 at 05:28)</a>:</h4>
<p>They are the same thing, but it seems that StreamingIterator is an even worse name than LendingIterator.</p>



<a name="268106752"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/268106752" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#268106752">(Jan 15 2022 at 05:40)</a>:</h4>
<p>well I'm assuming it wouldn't be constrained to <code>&amp;Item</code> like <code>StreamingIterator</code> does</p>



<a name="268106758"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/268106758" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#268106758">(Jan 15 2022 at 05:40)</a>:</h4>
<p>GAT should allow stuff like <code>Ref&lt;'a, T&gt;</code></p>



<a name="268120238"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/268120238" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> TennyZhuang <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#268120238">(Jan 15 2022 at 11:08)</a>:</h4>
<p>It seems that it's possible to impl&lt;I: Iterator&gt; LendingIterator for I, but the same method name <code>next</code> looks a little strange.<br>
<a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=6f9642a08cd346a3be2002035445ba13">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=6f9642a08cd346a3be2002035445ba13</a></p>



<a name="268120257"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/268120257" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> TennyZhuang <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#268120257">(Jan 15 2022 at 11:09)</a>:</h4>
<p>Also, we may need another trait IntoLendingIterator</p>



<a name="268122425"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/268122425" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dominik Stolz <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#268122425">(Jan 15 2022 at 12:03)</a>:</h4>
<p>I imagine that once we have <code>AsyncIterator</code>, people may want a <code>LendingAsyncIterator</code> trait.<br>
Also GAT versions of the function traits could be useful for closures that return references to captured variables.</p>



<a name="268127006"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/268127006" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#268127006">(Jan 15 2022 at 13:56)</a>:</h4>
<p>I don't thing GAT is the thing preventing such closures to exist, <span class="user-mention" data-user-id="302700">@Dominik Stolz</span> :</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">trait</span><span class="w"> </span><span class="n">MyFnOnce</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Ret</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">my_call_once</span><span class="w"> </span><span class="p">(</span><span class="bp">self</span>: <span class="nc">Self</span><span class="p">,</span><span class="w"> </span><span class="n">_</span>: <span class="nc">Args</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span>-&gt; <span class="nc">Self</span>::<span class="n">Ret</span><span class="w"></span>
<span class="w">    </span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">R</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="w"> </span>: <span class="nb">FnOnce</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">R</span><span class="o">&gt;</span><span class="w"> </span><span class="n">MyFnOnce</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">R</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">my_call_once</span><span class="w"> </span><span class="p">(</span><span class="bp">self</span>: <span class="nc">F</span><span class="p">,</span><span class="w"> </span><span class="p">()</span>: <span class="p">())</span><span class="w"></span>
<span class="w">      </span>-&gt; <span class="nc">R</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="bp">self</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">foo</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"></span>
<span class="k">where</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="o">&lt;'</span><span class="na">any</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">        </span><span class="o">&amp;'</span><span class="na">any</span><span class="w"> </span><span class="n">F</span><span class="w"> </span>: <span class="nc">MyFnOnce</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">Ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;'</span><span class="na">any</span><span class="w"> </span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">    </span><span class="p">,</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span>: <span class="kp">&amp;</span><span class="kt">i32</span> <span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="p">).</span><span class="n">my_call_once</span><span class="p">(());</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<ul>
<li><a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=e5d7ae25e0cbee35b33da9bc3739504f">Playground</a></li>
</ul>
<p>works in current Rust, and the <code>MyFnOnce</code> alias is not even needed on nightly Rust with <code>fn_traits</code> around (we only need the explicit <code>.call_once(…)</code> syntax: <a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=bad54ccfd76b47b60e2a5c49c28e079d">Playground</a>).</p>
<p>The issue lies rather in <em>literal closure expressions</em>, such as <code>{ let x = 42; move || &amp;x }</code> being unable to be imbued with such a signature. We'd need a way to assert such signatures for closures.</p>



<a name="268135828"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/268135828" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#268135828">(Jan 15 2022 at 17:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="138448">cuviper</span> <a href="#narrow/stream/219381-t-libs/topic/APIs.20with.20GATs/near/268100182">said</a>:</p>
<blockquote>
<p>do you think we'll be able to have <code>impl&lt;I: Iterator&gt; LendingIterator for I</code>?</p>
</blockquote>



<a name="268135839"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/268135839" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#268135839">(Jan 15 2022 at 17:09)</a>:</h4>
<p>I feel like that would give problems with coherence</p>



<a name="268135858"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/268135858" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#268135858">(Jan 15 2022 at 17:09)</a>:</h4>
<p>Then, nobody can impl LendingIterator because somebody else could impl Iterator</p>



<a name="268135938"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/268135938" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#268135938">(Jan 15 2022 at 17:11)</a>:</h4>
<p>This is something I'd like to think about though</p>



<a name="268136008"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/268136008" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#268136008">(Jan 15 2022 at 17:12)</a>:</h4>
<p>Another alternative is to somehow just add a lifetime to Iterator::Item, and somehow make it use a default lifetime. But unsure how that would work</p>



<a name="268139013"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/268139013" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Noah Lev <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#268139013">(Jan 15 2022 at 18:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="232957">Jack Huey</span> <a href="#narrow/stream/219381-t-libs/topic/APIs.20with.20GATs/near/268136008">said</a>:</p>
<blockquote>
<p>Another alternative is to somehow just add a lifetime to Iterator::Item, and somehow make it use a default lifetime. But unsure how that would work</p>
</blockquote>
<p>Maybe it would default to <code>'static</code> if the lifetime wasn't used anyway?</p>



<a name="268139664"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/268139664" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#268139664">(Jan 15 2022 at 18:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="232957">Jack Huey</span> <a href="#narrow/stream/219381-t-libs/topic/APIs.20with.20GATs/near/268135858">said</a>:</p>
<blockquote>
<p>Then, nobody can impl LendingIterator because somebody else could impl Iterator</p>
</blockquote>
<p>I don't think that's a coherence issue? You can't implement <code>Iterator</code> or <code>LendingIterator</code> on types from another crate, and the crate itself can choose whether to implement <code>Iterator</code> or <code>LendingIterator</code> on its own types.</p>



<a name="268142145"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/268142145" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#268142145">(Jan 15 2022 at 19:23)</a>:</h4>
<p>It would only prevent you from implementing <em>both</em> yourself, but I admit sometimes that could be useful for wrapper types. e.g. <code>Either</code> was blocked from implementing <code>IntoIterator</code> because we already had <code>Iterator</code>, and the blanket impl would make that overlap.</p>



<a name="268142487"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/268142487" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Noah Lev <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#268142487">(Jan 15 2022 at 19:31)</a>:</h4>
<p>In the case of <code>Either</code>, why would you want to manually implement <code>IntoIterator</code>? (I'm curious)</p>



<a name="268142743"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/268142743" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#268142743">(Jan 15 2022 at 19:36)</a>:</h4>
<p>If you have <code>Either&lt;Vec&lt;T&gt;, Option&lt;T&gt;&gt;</code>, you might want that to transform to <code>Either&lt;vec::IntoIter&lt;T&gt;, option::IntoIter&lt;T&gt;&gt;</code>, and then that is a useful <code>Iterator</code>. But we couldn't do that directly because of the overlap, so we settled for an inherent <code>into_iter()</code>.</p>



<a name="268142758"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/268142758" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#268142758">(Jan 15 2022 at 19:37)</a>:</h4>
<p>In retrospect, <code>either</code>'s <code>Iterator</code> should have been a separate type.</p>



<a name="268143733"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/268143733" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#268143733">(Jan 15 2022 at 19:56)</a>:</h4>
<p>Another thing is that you would need a different type to wrap <code>LendingIterator</code> separately from <code>Iterator</code>.</p>



<a name="268144068"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/268144068" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#268144068">(Jan 15 2022 at 20:02)</a>:</h4>
<p>You wouldn't be able extend any of the iterator adaptors to also be used for <code>LendingIterator</code>, for example.</p>



<a name="268144342"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/268144342" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#268144342">(Jan 15 2022 at 20:07)</a>:</h4>
<p>Hmm, true. It's not obvious to me that we <em>should</em> reuse those adaptors, but I guess we could.</p>



<a name="268144429"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/268144429" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#268144429">(Jan 15 2022 at 20:09)</a>:</h4>
<p>The trade-off is that all source <code>Iterator</code>s that don't need GAT will have to manually implement <code>LendingIterator</code>.</p>



<a name="268144452"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/268144452" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#268144452">(Jan 15 2022 at 20:09)</a>:</h4>
<p>If we make that automatic, we might even switch <code>for</code> loops to lending.</p>



<a name="268145149"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/268145149" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#268145149">(Jan 15 2022 at 20:21)</a>:</h4>
<p>Any chance we could make <code>trait Iterator = LendingIterator&lt;...something here...&gt;;</code> work?</p>



<a name="268145352"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/268145352" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#268145352">(Jan 15 2022 at 20:25)</a>:</h4>
<p>Not sure, but note that a lot of <code>Iterator</code> methods are not compatible, like <code>collect</code>. Perhaps those could be <code>where Self: ...something...</code></p>



<a name="268147647"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/268147647" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#268147647">(Jan 15 2022 at 21:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="138448">cuviper</span> <a href="#narrow/stream/219381-t-libs/topic/APIs.20with.20GATs/near/268142758">said</a>:</p>
<blockquote>
<p>In retrospect, <code>either</code>'s <code>Iterator</code> should have been a separate type.</p>
</blockquote>
<p>I'm getting the general impression that in retrospect almost all types want to return a <em>different</em> type for their <code>Iterator</code> rather than using themselves.</p>



<a name="268147688"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/268147688" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#268147688">(Jan 15 2022 at 21:18)</a>:</h4>
<p>(see also <code>Range*</code> types)</p>



<a name="268149264"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/268149264" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Noah Lev <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#268149264">(Jan 15 2022 at 21:58)</a>:</h4>
<p>Is that the reason <code>Range*</code> aren't <code>Copy</code>?</p>



<a name="268149272"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/268149272" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Noah Lev <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#268149272">(Jan 15 2022 at 21:59)</a>:</h4>
<p>(I seem to recall it had something to do with <code>for</code> loops)</p>



<a name="268149937"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/268149937" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#268149937">(Jan 15 2022 at 22:13)</a>:</h4>
<p>Yes; iterators are generally not <code>Copy</code> because iterating a copy of something is often not what people expect.</p>
<p>IIRC sfackler had started on a plan splitting Range for 2021, but it didn't end up landing.  I can't find the conversation about it, but here's a previous related comment I'd made: <a href="#narrow/stream/219381-t-libs/topic/ridiculousfish.20Range.20feedback/near/211055146">https://rust-lang.zulipchat.com/#narrow/stream/219381-t-libs/topic/ridiculousfish.20Range.20feedback/near/211055146</a></p>
<p>And a comment from mouse: <a href="https://github.com/rust-lang/rust/pull/82489#issuecomment-785874949">https://github.com/rust-lang/rust/pull/82489#issuecomment-785874949</a></p>



<a name="268164794"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/268164794" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#268164794">(Jan 16 2022 at 04:49)</a>:</h4>
<p>Anyways, for things like <code>LendingIterator</code>, I don't personally have the bandwidth to make these PRs myself (and ensure there's good documentation). But I would be very willing to work with someone else that's interested to get things added.</p>



<a name="268164800"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/268164800" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#268164800">(Jan 16 2022 at 04:49)</a>:</h4>
<p><code>LendingIterator</code> was the obvious one - but I'm not sure if there are others that are interesting to add</p>



<a name="268175618"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/268175618" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dominik Stolz <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#268175618">(Jan 16 2022 at 09:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="232018">Daniel Henry-Mantilla</span> <a href="#narrow/stream/219381-t-libs/topic/APIs.20with.20GATs/near/268127006">said</a>:</p>
<blockquote>
<p>The issue lies rather in <em>literal closure expressions</em>, such as <code>{ let x = 42; move || &amp;x }</code> being unable to be imbued with such a signature. We'd need a way to assert such signatures for closures.</p>
</blockquote>
<p>Couldn't the same argument be made for iterators?</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span> <span class="nf">bar</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="p">(</span><span class="n">iter</span>: <span class="nc">I</span><span class="p">)</span><span class="w"></span>
<span class="k">where</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="o">&lt;'</span><span class="na">any</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;'</span><span class="na">any</span><span class="w"> </span><span class="n">I</span>: <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;'</span><span class="na">any</span><span class="w"> </span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="p">).</span><span class="n">next</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>also works in current Rust, which does not mean it is possible to implement <code>Iterator</code> such that the bound is satisfied.<br>
Which traits should the closure expression you gave as an example implement?<br>
This could be a new <code>BikeshedFn</code> trait with an <code>Output</code> GAT. (we might then also want <code>BikeshedFnMut</code> and <code>BikeshedFnOnce</code>)</p>



<a name="268176002"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/268176002" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dominik Stolz <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#268176002">(Jan 16 2022 at 09:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="232957">Jack Huey</span> <a href="#narrow/stream/219381-t-libs/topic/APIs.20with.20GATs/near/268136008">said</a>:</p>
<blockquote>
<p>Another alternative is to somehow just add a lifetime to Iterator::Item, and somehow make it use a default lifetime. But unsure how that would work</p>
</blockquote>
<p>I would love if that worked in a backward-compatible fashion. However, a previous <a href="https://internals.rust-lang.org/t/closures-that-can-return-references-to-captured-variables/14756">discussion on IRLO</a> concluded that a problem might arise with <code>I: Iterator</code> bounds that do not specify the associated type. To remain compatible, these would have to allow only non-lending iterators, which then poses the question how to write a bound that allows all iterators, lending or not.</p>



<a name="268182666"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/268182666" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#268182666">(Jan 16 2022 at 12:52)</a>:</h4>
<p><span class="user-mention" data-user-id="302700">@Dominik Stolz</span> you can "GAT-ize" an API where the method does not introduce "anonymous" lifetime parameters itself. This, in turn, requires that any methods be taking a <code>self: Self</code> receiver —hence why "GAT closures" will involve <code>FnOnce()</code> bounds, rather than <code>FnMut</code> or <code>Fn</code>—; <code>Iterator</code>'s <code>.next()</code>, however, is <code>&amp;'_ mut Self</code>-based, with that <code>'_</code> being unnameable in the return type.</p>
<ul>
<li>An interesting thing to notice is that in a world where Rust would fully figure out higher-order signatures, <code>F : FnMut(Args…) -&gt; R</code> is "an alias" for <code>for&lt;'_&gt; &amp;'_ mut F : FnOnce(Args…) -&gt; R</code>.<br>
    This seems relevant here given the <code>FnMut() -&gt; Option&lt;T&gt;</code> &lt;-&gt; <code>Iterator</code> equivalence (thanks to <code>move || iterator.next()</code> in one direction, and <code>iter::from_fn(fn_mut)</code> in the other).<br>
    So if <code>Iterator</code> is <code>FnMut() -&gt; Option&lt;T&gt;</code>, <em>i.e.</em>, <code>for&lt;'_&gt; &amp;'_ mut Self : FnOnce() -&gt; Option&lt;T&gt;</code>, then <code>LendingIterator</code> or other GAT constructs are <code>for&lt;'next&gt; &amp;'next mut Self : FnOnce() -&gt; Option&lt;T&lt;'next&gt;&gt;</code>, whereby the return type can depend on <code>'next</code>, the lifetime representing "the span of the current <code>.next()</code> call". <code>StreamingIterator</code> is a reduced example, wherein <code>T&lt;'next&gt; = &amp;'next U</code></li>
</ul>



<a name="268182714"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/268182714" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#268182714">(Jan 16 2022 at 12:53)</a>:</h4>
<p>This reminds me of a subtle detail that would need to be resolved beforehand: in order to write <code>.filter()</code>-like adaptors without having to resort to <code>unsafe</code>, one currently (without Polonius) needs to have that <code>.advance()</code> / <code>.get()</code> split, which I think doesn't generalize as well to GATed <code>Item</code>s:</p>
<ul>
<li><a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=2784c37ea61cf2738759f4328dc1211a">minimal repro of <code>StreamingIterator</code>'s problem</a></li>
</ul>



<a name="268197264"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/268197264" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ibraheem Ahmed <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#268197264">(Jan 16 2022 at 17:36)</a>:</h4>
<p>It would be <em>amazing</em> if traits like <code>Deref</code>, <code>Borrow</code>, and <code>Index</code> could be GAT-ified in a backwards compataible way.</p>



<a name="269138159"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/269138159" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#269138159">(Jan 24 2022 at 17:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="232957">Jack Huey</span> <a href="#narrow/stream/144729-wg-traits/topic/Considering.20a.20GATified.20Iterator/near/269137918">said</a>:</p>
<blockquote>
<p>Okay, for those following along: the next step here is probably to come up with some "user stories" for how we might expect people to use LendingIterator or a GATified Iterator (<a href="https://github.com/rust-lang/generic-associated-types-initiative/issues/1">https://github.com/rust-lang/generic-associated-types-initiative/issues/1</a>). We need to update the repo to have a place for them, but if you have some thoughts, please feel free to file an issue there, and I'll make sure it gets included. (Also welcome examples of other traits too, like Deref)</p>
</blockquote>



<a name="269213046"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/269213046" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sean Chen (he/him) <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#269213046">(Jan 25 2022 at 05:58)</a>:</h4>
<blockquote>
<p>It would be <em>amazing</em> if traits like <code>Deref</code>, <code>Borrow</code>, and <code>Index</code> could be GAT-ified in a backwards compataible way.</p>
</blockquote>
<p>Could you expand a bit on what such GATified traits would enable?</p>



<a name="269249708"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/269249708" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#269249708">(Jan 25 2022 at 12:34)</a>:</h4>
<p>The best example that comes to mind is the annoyance of <code>Pin&lt;&amp;mut _&gt;</code> not featuring _implicit reborrowing_, requiring people to call <code>.as_mut()</code> all the time. Instead, it would be nice if an <code>&amp;'reborrow mut Pin&lt;&amp;'_ mut _&gt;</code> could just magically become a <code>Pin&lt;&amp;'reborrow mut _&gt;</code>, and <code>DerefMut</code> looks like the ideal candidate for this.</p>
<ul>
<li>If reborrowing sounds a bit alien, you can also consider <code>&amp;mut Pin&lt;Box&lt;…&gt;&gt;</code> being able to become <code>Pin&lt;&amp;mut _&gt;</code> automagically as well.</li>
</ul>
<p>But it turns out that the current definitions of <code>Deref{,Mut}</code> are too restrictive in that regard:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span> <span class="nf">deref_mut</span><span class="p">(</span><span class="bp">self</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="bp">Self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="bp">Self</span>::<span class="n">Target</span><span class="p">;</span><span class="w"></span>
</code></pre></div>
<p>With <code>Self = Pin&lt;Box&lt;T&gt;&gt;</code>, we end up with:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span> <span class="nf">deref_mut</span><span class="p">(</span><span class="bp">self</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Pin</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="o">???</span><span class="w"></span>
</code></pre></div>
<p>when we wanted:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span> <span class="nf">deref_mut</span><span class="p">(</span><span class="bp">self</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Pin</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"></span>
</code></pre></div>
<p>If, instead, there was a <code>DerefMut</code> definition as:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">trait</span><span class="w"> </span><span class="n">BetterDerefMut</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">TargetMut</span><span class="o">&lt;'</span><span class="nb">__</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">deref_mut</span><span class="p">(</span><span class="bp">self</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="nb">_</span> <span class="nc">mut</span><span class="w"> </span><span class="bp">Self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">TargetMut</span><span class="o">&lt;'</span><span class="nb">_</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>then we'd be able to say <code>type TargetMut&lt;'__&gt; = Pin&lt;&amp;'__ mut T&gt;;</code> <em>and voilà</em>.</p>
<p>But then the challenge is making it retro-compatible (on top of a consistent <code>DerefMut : Deref</code>-like hierarchy). With a bunch of associated type defaults, and/or <strong>trait aliases</strong>, I believe it could be possible.</p>
<p>FWIW, the same applies to <code>Index</code> and <code>IndexMut</code> trait. Consider the <em>Realistic example</em> section of <code>::ref_cast</code>:</p>
<ul>
<li><a href="https://docs.rs/ref-cast/1.0.6/ref_cast/index.html#realistic-example">https://docs.rs/ref-cast/1.0.6/ref_cast/index.html#realistic-example</a></li>
</ul>
<p>They end up having to use an <code>unsafe</code> transmutation just to accomodate to the restrictive <code>Index</code> traits.</p>
<p>And that's just not possible for all the borrowing types: the <code>Out&lt;'_, T&gt;</code> pointer type from the <code>::uninit</code> crate, would love to be able to feature mut-indexing with the handy <code>[…]</code> sugar, but it just can't, and has to use a method instead:</p>
<ul>
<li><a href="https://docs.rs/uninit/0.5.0/uninit/out_ref/struct.Out.html#method.get_out">https://docs.rs/uninit/0.5.0/uninit/out_ref/struct.Out.html#method.get_out</a></li>
</ul>



<a name="269249986"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/269249986" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#269249986">(Jan 25 2022 at 12:36)</a>:</h4>
<p>Even recently, there has been this thread: <a href="#narrow/stream/122651-general/topic/GPU.20Slices">https://rust-lang.zulipchat.com/#narrow/stream/122651-general/topic/GPU.20Slices</a> which does talk of how the fact it's "reference to slice" type, by virtue of having to feature an FFI-compatible and well-defined behavior, can't be a <code>&amp; _</code> type, and how when they tried to use a custom borrowing type, they lost the <code>[…]</code> indexing sugar</p>



<a name="269250568"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/269250568" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#269250568">(Jan 25 2022 at 12:41)</a>:</h4>
<p>Same goes for <code>CStr</code>, which could have been featured as a slim pointer type (and thus, FFI-compatible, which is the whole <em>raison-d'être</em> of such a type to begin with!) had it been defined as a reference type rather than a referee type, like it is done in <a href="https://docs.rs/safer-ffi/0.0.6/safer_ffi/prelude/char_p/index.html">other crates</a>. But then we wouldn't have <code>CString : Deref&lt;Target = CStr&gt;</code>, <em>etc.</em></p>
<p>Consider also the <a href="https://doc.rust-lang.org/1.58.1/std/os/unix/io/trait.AsFd.html"><code>AsFd</code> more correct abstraction for file descriptors on Unix</a>: we have, again, a reference type (<code>BorrowedFd&lt;'_&gt;</code>), and thus, something like <a href="https://doc.rust-lang.org/1.58.1/std/os/unix/io/struct.OwnedFd.html"><code>OwnedFd</code></a> can't <code>Deref&lt;Target&lt;'__&gt; = BorrowedFd&lt;'__&gt;&gt;</code>.</p>
<p>The reality is that currently, only the Rust references types / referess get the love, and that any custom reference type is doomed to be awfully unergonomic. I do believe GATs could help that situation by a significant margin</p>



<a name="269254093"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/269254093" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#269254093">(Jan 25 2022 at 13:10)</a>:</h4>
<p>are these changes backwards-compatible?</p>



<a name="269299344"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/269299344" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#269299344">(Jan 25 2022 at 18:15)</a>:</h4>
<p>I think the more realistic approach to these things would be to have new gat traits (which the sugared ops would change to unsugar to), and then have blanket impls from the current ones to the new ones:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">trait</span><span class="w"> </span><span class="n">IndexGat</span><span class="o">&lt;</span><span class="n">Idx</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="o">&lt;'</span><span class="na">index</span><span class="o">&gt;</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="bp">Self</span><span class="w"> </span>: <span class="o">'</span><span class="na">index</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">index</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">_</span>: <span class="nc">Idx</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Output</span><span class="o">&lt;'</span><span class="nb">_</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="w"> </span>: <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span><span class="w"> </span><span class="n">Idx</span><span class="o">&gt;</span><span class="w"> </span><span class="n">IndexGat</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w"></span>
<span class="k">where</span><span class="w"></span>
<span class="w">    </span><span class="n">T</span><span class="w"> </span>: <span class="nc">Index</span><span class="o">&lt;</span><span class="n">Idx</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="o">&lt;'</span><span class="na">index</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">    </span><span class="k">where</span><span class="w"></span>
<span class="w">        </span><span class="bp">Self</span><span class="w"> </span>: <span class="o">'</span><span class="na">index</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="o">&amp;'</span><span class="na">index</span><span class="w"> </span><span class="o">&lt;</span><span class="n">T</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">Index</span><span class="o">&lt;</span><span class="n">Idx</span><span class="o">&gt;&gt;</span>::<span class="n">Output</span><span class="w"></span>
<span class="w">    </span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">index</span><span class="w"> </span><span class="c1">// …</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>A thorny point is what the hierarchy with the <code>…Mut</code> traits should be: the new gat traits would have their own GAT for the <code>mut</code> case, and I imagine some relationship would be expected between the non-mut GAT and the mut GAT? (such as some higher-order <code>AsRef</code> <span aria-label="see no evil" class="emoji emoji-1f648" role="img" title="see no evil">:see_no_evil:</span>)</p>



<a name="269310075"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/269310075" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#269310075">(Jan 25 2022 at 19:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="232018">Daniel Henry-Mantilla</span> <a href="#narrow/stream/219381-t-libs/topic/APIs.20with.20GATs/near/269299344">said</a>:</p>
<blockquote>
<p>I think the more realistic approach to these things would be to have new gat traits (which the sugared ops would change to unsugar to), and then have blanket impls from the current ones to the new ones.</p>
</blockquote>
<p>I want to push back on this a little. At least in my opinion, this is pretty unergonomic. I would <em>really</em> like to hear how people would like to use these traits (<code>Index</code>, <code>Deref</code>, <code>Iterator</code>, etc.) with GATs (and of course without). I don't want this to beholden to "realistic" - because then that really limits what our "shiny future" is. Let's start with what people want to do - and then we can worry about how we'll get there. GATs are stable yet - there might be design decisions we can make that allow us to get the best of both worlds.</p>



<a name="269310229"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/269310229" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#269310229">(Jan 25 2022 at 19:27)</a>:</h4>
<p>I implore people to open issues (on the GATs initiative repo - or on the rust repo if you really must) on specific "I wish you could just do this" examples</p>



<a name="269310456"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/269310456" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake Goulding <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#269310456">(Jan 25 2022 at 19:29)</a>:</h4>
<p><a href="https://github.com/rust-lang/generic-associated-types-initiative">GATs initiative repo</a> for others like myself.</p>



<a name="269310714"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/269310714" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake Goulding <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#269310714">(Jan 25 2022 at 19:30)</a>:</h4>
<p>Is "making <code>foo[bar]</code> return something that isn't <code>&amp;_</code>" something that's in the realm of GAT things? That's something that comes up fairly regularly, IMO.</p>



<a name="269311001"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/269311001" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#269311001">(Jan 25 2022 at 19:32)</a>:</h4>
<p>for example, <code>ndarray</code> would want to return <code>ArrayView&lt;'_, ..&gt;</code></p>



<a name="269311235"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/269311235" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#269311235">(Jan 25 2022 at 19:34)</a>:</h4>
<p>but for mutable, it would want <code>ArrayViewMut&lt;'_, ..&gt;</code>, so GAT indexing would need distinct <code>type Output&lt;'_&gt;</code></p>



<a name="269311516"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/269311516" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#269311516">(Jan 25 2022 at 19:36)</a>:</h4>
<p>currently without GAT, they use <code>slice</code> and <code>slice_mut</code> methods</p>



<a name="269315775"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/269315775" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ibraheem Ahmed <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#269315775">(Jan 25 2022 at 20:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="300743">Sean Chen (he/him)</span> <a href="#narrow/stream/219381-t-libs/topic/APIs.20with.20GATs/near/269213046">said</a>:</p>
<blockquote>
<blockquote>
<p>It would be <em>amazing</em> if traits like <code>Deref</code>, <code>Borrow</code>, and <code>Index</code> could be GAT-ified in a backwards compataible way.</p>
</blockquote>
<p>Could you expand a bit on what such GATified traits would enable?</p>
</blockquote>
<p>Returning something other than <code>&amp;T</code>.</p>



<a name="269315809"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/269315809" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ibraheem Ahmed <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#269315809">(Jan 25 2022 at 20:04)</a>:</h4>
<p>ie: <code>T&lt;'_&gt;</code></p>



<a name="269316298"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/269316298" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#269316298">(Jan 25 2022 at 20:08)</a>:</h4>
<p>For a second, my mind was thinking this was a weird method call lol. I'm not sure; this isn't necessarily a GAT problem in and of itself. I imagine you would need some way to change the Index trait to make Output have a lifetime param and simultaneously change the output of <code>index</code> to return <code>Output</code> rather than <code>&amp;Output</code>.</p>



<a name="269316751"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/269316751" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#269316751">(Jan 25 2022 at 20:11)</a>:</h4>
<p>It's a good use case though. Can someone file an issue on the initiative repo?</p>



<a name="269319622"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/269319622" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake Goulding <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#269319622">(Jan 25 2022 at 20:31)</a>:</h4>
<p><a href="https://github.com/rust-lang/generic-associated-types-initiative/issues/2">Extending core::ops::Index to return non-references</a></p>



<a name="269323340"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/269323340" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#269323340">(Jan 25 2022 at 21:00)</a>:</h4>
<p>Thank you so much <span aria-label="heart" class="emoji emoji-2764" role="img" title="heart">:heart:</span></p>



<a name="269324197"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/269324197" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ibraheem Ahmed <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#269324197">(Jan 25 2022 at 21:06)</a>:</h4>
<p>Another one is using borrowed versions of an enum for hashmap lookups.</p>



<a name="269324230"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/269324230" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#269324230">(Jan 25 2022 at 21:06)</a>:</h4>
<p>Example?</p>



<a name="269324272"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/269324272" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ibraheem Ahmed <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#269324272">(Jan 25 2022 at 21:06)</a>:</h4>
<p>like if you have</p>



<a name="269324302"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/269324302" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ibraheem Ahmed <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#269324302">(Jan 25 2022 at 21:06)</a>:</h4>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">enum</span> <span class="nc">Xy</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">X</span><span class="p">(</span><span class="nb">String</span><span class="p">),</span><span class="w"> </span><span class="n">Y</span><span class="p">(</span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</code></pre></div>



<a name="269324325"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/269324325" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ibraheem Ahmed <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#269324325">(Jan 25 2022 at 21:07)</a>:</h4>
<p>and you want to lookup where the key is <code>Xy("foo")</code></p>



<a name="269324345"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/269324345" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ibraheem Ahmed <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#269324345">(Jan 25 2022 at 21:07)</a>:</h4>
<p>you don't want to allocate a string for a lookup</p>



<a name="269324398"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/269324398" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Noah Lev <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#269324398">(Jan 25 2022 at 21:07)</a>:</h4>
<p>Ooh that would be cool</p>



<a name="269324402"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/269324402" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ibraheem Ahmed <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#269324402">(Jan 25 2022 at 21:07)</a>:</h4>
<p>ideally you could have <code>enum BorrowedXy&lt;'a&gt; { X(&amp;'a str), Y(i32) }</code></p>



<a name="269324422"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/269324422" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ibraheem Ahmed <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#269324422">(Jan 25 2022 at 21:07)</a>:</h4>
<p>and <code>impl Borrow for Xy { type Borrowed&lt;'a&gt; = BorrowedXy&lt;'a&gt; ... }</code></p>



<a name="269324497"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/269324497" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ibraheem Ahmed <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#269324497">(Jan 25 2022 at 21:08)</a>:</h4>
<p>there's a way to do this with <code>dyn</code>, but it's very hacky</p>



<a name="269324553"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/269324553" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake Goulding <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#269324553">(Jan 25 2022 at 21:08)</a>:</h4>
<p><code>dyn</code> version: <a href="https://stackoverflow.com/q/36480845/155423">How to avoid temporary allocations when using a complex key for a HashMap?</a> (not top answer)</p>



<a name="269335122"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/269335122" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#269335122">(Jan 25 2022 at 22:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="138448">cuviper</span> <a href="#narrow/stream/219381-t-libs/topic/APIs.20with.20GATs/near/269311235">said</a>:</p>
<blockquote>
<p>but for mutable, it would want <code>ArrayViewMut&lt;'_, ..&gt;</code>, so GAT indexing would need distinct <code>type Output&lt;'_&gt;</code></p>
</blockquote>
<p>I don't know if I follow this. Isn't the currently differentiated based on <code>Index</code> vs <code>IndexMut</code>?</p>



<a name="269335548"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/269335548" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#269335548">(Jan 25 2022 at 22:34)</a>:</h4>
<p>They're currently forced together, essentially:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">IndexMut</span><span class="o">&lt;</span><span class="n">Idx</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span>: <span class="nc">Index</span><span class="o">&lt;</span><span class="n">Idx</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">index_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">index</span>: <span class="nc">Idx</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="o">&lt;</span><span class="bp">Self</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">Index</span><span class="o">&gt;</span>::<span class="n">Output</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>



<a name="269335629"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/269335629" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#269335629">(Jan 25 2022 at 22:35)</a>:</h4>
<p>written as <code>Self::Output</code> in the implementation and docs, but that's the effect</p>



<a name="269357464"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/269357464" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#269357464">(Jan 26 2022 at 03:17)</a>:</h4>
<p>Ah that's...rough. Almost like we need an <code>OutputMut</code> that defaults to <code>Self::Output</code></p>



<a name="269429695"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/269429695" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Tavian Barnes <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#269429695">(Jan 26 2022 at 15:31)</a>:</h4>
<p>I think it's worse than that, for something like <code>vec[idx].method()</code>, the choice of <code>Index</code> vs. <code>IndexMut</code> depends on the receiver type of the method: <a href="https://github.com/rust-lang/generic-associated-types-initiative/issues/2#issuecomment-1021611276">https://github.com/rust-lang/generic-associated-types-initiative/issues/2#issuecomment-1021611276</a></p>



<a name="269430220"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/269430220" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Tavian Barnes <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#269430220">(Jan 26 2022 at 15:35)</a>:</h4>
<p>I think we'd need to do something like take mutability as a type parameter, e.g.</p>
<div class="codehilite"><pre><span></span><code>trait Index&lt;Idx&gt; {
    type Output&lt;&#39;a, ?mut&gt;;

    fn index&lt;&#39;a&gt;(&amp;&#39;a self, index: Idx) -&gt; Self::Output&lt;&#39;a, const&gt;;
}

trait IndexMut&lt;Idx&gt;: Index&lt;Idx&gt; {
    fn index_mut&lt;&#39;a&gt;(&amp;&#39;a self, index: Idx) -&gt; Self::Output&lt;&#39;a, mut&gt;;
}

impl&lt;T&gt; Index&lt;usize&gt; for Vec&lt;T&gt; {
    type Output&lt;&#39;a, ?mut&gt; = &amp;&#39;a ?mut T;
    ...
}
</code></pre></div>



<a name="269430755"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/269430755" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Tavian Barnes <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#269430755">(Jan 26 2022 at 15:38)</a>:</h4>
<p>(or if we can be generic over mutability, maybe <code>Index</code> should just have  a mutabilty parameter instead of a separate <code>IndexMut</code>)</p>



<a name="269485034"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/269485034" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Noah Lev <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#269485034">(Jan 26 2022 at 21:27)</a>:</h4>
<blockquote>
<p>I think we'd need to do something like take mutability as a type parameter</p>
</blockquote>
<p>With programming languages, in the end we want to be able to parametrize over everything ;)</p>



<a name="269498367"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/269498367" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#269498367">(Jan 26 2022 at 23:23)</a>:</h4>
<p>Fwiw, since gat traits will probably involve new traits, there could be an <code>OutputMut</code> assoc trait for <code>IndexMut</code>; the issue is indeed about method resolution leading to up to an exponential number of candidates as indexing is chained; with the classic <code>&amp;Output</code> / <code>&amp;mut Output</code>, the two mutability choices could be deferred up until the end, and "squashed" down to either always index or always indexmut.</p>



<a name="269498430"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/269498430" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#269498430">(Jan 26 2022 at 23:24)</a>:</h4>
<p>But that gives me an idea: what if chained sugared indexing always required there to be a consistent choice?</p>



<a name="269498572"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/APIs%20with%20GATs/near/269498572" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/APIs.20with.20GATs.html#269498572">(Jan 26 2022 at 23:25)</a>:</h4>
<p>That would take care of the exponentiality, and then we'd only have a good old ambiguity issue in some situations, which is not different than what we have with the current traits (I suspect it favors index in that case?)</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>