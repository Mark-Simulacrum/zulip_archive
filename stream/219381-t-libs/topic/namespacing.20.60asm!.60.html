<html>
<head><meta charset="utf-8"><title>namespacing `asm!` · t-libs · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/index.html">t-libs</a></h2>
<h3>Topic: <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html">namespacing `asm!`</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://rust-lang.github.io/zulip_archive/style.css" rel="stylesheet"></head>

<a name="233407632"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233407632" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233407632">(Apr 06 2021 at 23:36)</a>:</h4>
<p>One of the remaining unresolved questions for <code>asm!</code> stabilization is where it should live. FWIW, my opinion is that the current situation of most macros being effectively defined "in the prelude" is an unfortunate historical remnant that shouldn't be perpetuated with modern macro stabilizations (e.g. <code>std::ptr::addr_of!</code> does it right). At the very least I would be happy if <code>asm!</code> ended up at <code>std::arch::asm!</code>; whether or not to then include <code>asm!</code> in the prelude could be a separate decision. During the RFC, some people wanted to go even further and have <code>std::arch::x86::asm!</code>, <code>std::arch::arm::asm!</code>, etc. <span class="user-mention" data-user-id="143274">@Amanieu</span> , am I correct in thinking that even if <code>asm!</code> lived under arch-specific namespaces, that there would be <em>no</em> actual difference between any of them, and they would all delegate to the same internal implementation regardless of architecture? Which is to say, is the proposal for having architecture-specific <code>asm!</code> imports simply a roundabout lint to keep code from compiling on unanticipated platforms?</p>



<a name="233407838"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233407838" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233407838">(Apr 06 2021 at 23:39)</a>:</h4>
<p>One potential advantage of putting asm in <code>arch::x86_64</code> is that it could document any architecture-specific options/flags/examples/etc</p>



<a name="233408163"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233408163" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233408163">(Apr 06 2021 at 23:43)</a>:</h4>
<p>that would also make it more obvious which arches support <code>asm!</code>, since not all do -- and maybe some never will?</p>



<a name="233408208"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233408208" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233408208">(Apr 06 2021 at 23:44)</a>:</h4>
<p>that would imply that there are actually useful user-facing distinctions between <code>asm!</code> on different architectures, yes? I ask because there's nothing stopping the stdlib from having <em>both</em> <code>std::arch::x86::asm!</code> and <code>std::arch::asm!</code>, where the latter internally <code>cfg</code>s to the former when you're on X86, etc. <em>But</em>, the mere existence of <code>std::arch::asm!</code> would defeat the purpose if the goal is to <em>force</em> users to commit to specific archs for their code, a.k.a. the lint perspective</p>



<a name="233408296"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233408296" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233408296">(Apr 06 2021 at 23:45)</a>:</h4>
<p>I'm honestly not too worried about the lint side of things - I can't imagine anyone who's using <code>asm!</code> but isn't aware it's architecure specific</p>



<a name="233408376"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233408376" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233408376">(Apr 06 2021 at 23:46)</a>:</h4>
<p>well, I can probably imagine such a person exists, but that trip-up would be a valuable learning experience for them :P</p>



<a name="233408457"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233408457" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233408457">(Apr 06 2021 at 23:47)</a>:</h4>
<p><span class="user-mention silent" data-user-id="256342">bstrie</span> <a href="#narrow/stream/219381-t-libs/topic/namespacing.20.60asm!.60/near/233408208">said</a>:</p>
<blockquote>
<p>that would imply that there are actually useful user-facing distinctions between <code>asm!</code> on different architectures, yes?</p>
</blockquote>
<p>Besides the assembly code itself, there are also things like arch-specific register classes</p>



<a name="233408607"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233408607" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233408607">(Apr 06 2021 at 23:49)</a>:</h4>
<p>Yes, I'm talking about things aside from the assembly itself. :) Are arch-specific register classes implemented? I thought I recalled from the RFC that the goal was sort of a "lowest common denominator" design</p>



<a name="233408621"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233408621" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233408621">(Apr 06 2021 at 23:49)</a>:</h4>
<p>I know there was a discussion around handling x87 stack clobbers recently</p>



<a name="233408642"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233408642" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233408642">(Apr 06 2021 at 23:49)</a>:</h4>
<p>which would potentially involve an arch-specific flag to asm</p>



<a name="233408704"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233408704" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233408704">(Apr 06 2021 at 23:50)</a>:</h4>
<p>I haven't followed the implementation, but I see tests using <code>reg_abcd</code> at least</p>



<a name="233410957"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233410957" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233410957">(Apr 07 2021 at 00:13)</a>:</h4>
<p>looking at the intersection of supported architectures and modules under <code>std::arch</code>, it looks like new <code>std::arch::riscv</code> and <code>std::arch::hexagon</code> mods would need to be added. Any objections to that? (In particular I'm curious if RISC-V is homogenous enough for such a module to make sense; there are a lot of RISC-V target triples?)</p>



<a name="233411544"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233411544" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steven Fackler <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233411544">(Apr 07 2021 at 00:20)</a>:</h4>
<p>I'm not super familiar with riscv, but I think even if we did want separate modules it'd make sense to place them under a top-level <code>std::arch::riscv</code> module</p>



<a name="233411590"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233411590" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233411590">(Apr 07 2021 at 00:20)</a>:</h4>
<p>isn't there 32/64-bit RISC-V at least? we don't combine x86 for that...</p>



<a name="233411635"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233411635" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233411635">(Apr 07 2021 at 00:21)</a>:</h4>
<p>although it looks like std does combine nvptx and nvptx64 into one module, although this is still unstable</p>



<a name="233411675"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233411675" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233411675">(Apr 07 2021 at 00:21)</a>:</h4>
<p><code>target_arch</code> is either <code>riscv32</code> or <code>riscv64</code></p>



<a name="233411756"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233411756" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233411756">(Apr 07 2021 at 00:22)</a>:</h4>
<p>where's the canonical source for that? on the forge I see riscv32i, riscv32imac, riscv32imc, riscv64gc, riscv64imac</p>



<a name="233411855"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233411855" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233411855">(Apr 07 2021 at 00:24)</a>:</h4>
<p><code>git grep arch:.*riscv compiler/rustc_target</code></p>



<a name="233412137"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233412137" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233412137">(Apr 07 2021 at 00:27)</a>:</h4>
<p>I guess it's similar to how <code>x86</code> represents target triples called <code>i386</code>, <code>i586</code>, <code>i686</code></p>



<a name="233422849"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233422849" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233422849">(Apr 07 2021 at 02:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="256342">bstrie</span> <a href="#narrow/stream/219381-t-libs/topic/namespacing.20.60asm!.60/near/233407632">said</a>:</p>
<blockquote>
<p>One of the remaining unresolved questions for <code>asm!</code> stabilization is where it should live. FWIW, my opinion is that the current situation of most macros being effectively defined "in the prelude" is an unfortunate historical remnant that shouldn't be perpetuated with modern macro stabilizations (e.g. <code>std::ptr::addr_of!</code> does it right). At the very least I would be happy if <code>asm!</code> ended up at <code>std::arch::asm!</code>; whether or not to then include <code>asm!</code> in the prelude could be a separate decision. During the RFC, some people wanted to go even further and have <code>std::arch::x86::asm!</code>, <code>std::arch::arm::asm!</code>, etc. <span class="user-mention silent" data-user-id="143274">Amanieu</span> , am I correct in thinking that even if <code>asm!</code> lived under arch-specific namespaces, that there would be <em>no</em> actual difference between any of them, and they would all delegate to the same internal implementation regardless of architecture? Which is to say, is the proposal for having architecture-specific <code>asm!</code> imports simply a roundabout lint to keep code from compiling on unanticipated platforms?</p>
</blockquote>
<p>There was a fair bit of discussion in a few threads about where exactly <code>asm!</code> should live.</p>
<p>I feel strongly that it should <em>not</em> have the architecture in the path, since there are legitimate ways to write asm with abstractions that make it semi-portable (e.g. "both x86 and x86-64", or even "any supported target, with some macros that expand to arch-specific assembly, and portable syntax for labels and directives").</p>
<p>As an implementation detail, I think it'd be acceptable either for <code>asm!</code> to live in the prelude, or for <code>asm!</code> to live in <code>std::arch::asm!</code> and be re-exported in the prelude. I wouldn't be thrilled if it lived in <code>std::arch::asm!</code> and required an import.</p>



<a name="233422929"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233422929" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233422929">(Apr 07 2021 at 02:51)</a>:</h4>
<p>I don't want various crates to have to write (or pull in a crate for) <code>#[cfg(...)] pub use ...::asm as asm; #[cfg(...)] pub use ...::asm as asm; ...</code></p>



<a name="233423788"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233423788" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233423788">(Apr 07 2021 at 03:02)</a>:</h4>
<p>I saw a pretty compelling pattern that doesn't involve cfg overload:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">arch</span>::<span class="o">*</span><span class="p">;</span><span class="w"></span>

<span class="c1">// later, in your already-cfg'd code</span>
<span class="n">x86</span>::<span class="fm">asm!</span><span class="p">(</span><span class="o">..</span><span class="p">.);</span><span class="w"></span>
</code></pre></div>



<a name="233423926"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233423926" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joshua Nelson <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233423926">(Apr 07 2021 at 03:04)</a>:</h4>
<blockquote>
<p>I wouldn't be thrilled if it lived in std::arch::asm! and required an import.</p>
</blockquote>
<p>Hmm, why's that? asm! isn't exactly <em>uncommon</em>, but it's certainly not as common as HashMap or <code>mem::replace</code>, and those aren't in the prelude either</p>



<a name="233423936"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233423936" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233423936">(Apr 07 2021 at 03:04)</a>:</h4>
<p>for my part, I would like it to not live in the prelude; it's already bad that the stdlib documentation index has to list a ton of random macros just because they're otherwise homeless. IMO new macros should be treated like any other item, and be defined under a module and exported from the prelude as necessary</p>



<a name="233424002"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233424002" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233424002">(Apr 07 2021 at 03:05)</a>:</h4>
<p>(I'm halfway motivated to writing an RFC to migrate the existing macros to actual homes in the stdlib :P )</p>



<a name="233424074"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233424074" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233424074">(Apr 07 2021 at 03:06)</a>:</h4>
<p>(though I guess that wouldn't require an RFC, they'd all still be exported from the prelude)</p>



<a name="233424269"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233424269" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233424269">(Apr 07 2021 at 03:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="256342">bstrie</span> <a href="#narrow/stream/219381-t-libs/topic/namespacing.20.60asm!.60/near/233423936">said</a>:</p>
<blockquote>
<p>for my part, I would like it to not live in the prelude; it's already bad that the stdlib documentation index has to list a ton of random macros just because they're otherwise homeless. IMO new macros should be treated like any other item, and be defined under a module and exported from the prelude as necessary</p>
</blockquote>
<p>To clarify in case it came across otherwise, I have <em>zero</em> objection to defining it in a module and re-exporting it from the prelude. I do find the notion of making new prelude items <em>exclusively</em> re-exports rather compelling.</p>



<a name="233424415"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233424415" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233424415">(Apr 07 2021 at 03:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="232545">Joshua Nelson</span> <a href="#narrow/stream/219381-t-libs/topic/namespacing.20.60asm!.60/near/233423926">said</a>:</p>
<blockquote>
<p>asm! isn't exactly <em>uncommon</em>, but it's certainly not as common as HashMap or <code>mem::replace</code>, and those aren't in the prelude either</p>
</blockquote>
<p>HashMap <em>should</em> be. :)</p>



<a name="233424422"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233424422" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233424422">(Apr 07 2021 at 03:12)</a>:</h4>
<p>as for the architecture-specific <code>asm!</code> macros, I'm also of the opinion that just having a single <code>std::arch::asm!</code> is just fine, <em>unless</em> there are actually things that <code>asm!</code> would want to do differently on different architectures (e.g. reserved registers)</p>



<a name="233424490"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233424490" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233424490">(Apr 07 2021 at 03:12)</a>:</h4>
<p>And frankly I won't be at all surprised if <code>asm!</code> ends up reasonably common. We actually have a compelling advantage over C here. In C, there's no <em>portable</em> way to do inline assembly, and MSVC and GCC/clang do it differently, so you either have to mandate one compiler family (typically GCC/clang if you care about non-Windows users), or you avoid inline assembly. Even non-inline assembly is a pain, and sometimes involves mandating an assembler (e.g. nasm). In Rust, there will be one standardized way to do inline assembly, which means people writing Rust code <em>can</em> use it more readily than they can in portable C code.</p>



<a name="233424801"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233424801" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233424801">(Apr 07 2021 at 03:17)</a>:</h4>
<p>I wouldn't expect it to be <em>that</em> common; it's still unsafe, and like any unsafe people are going to want to push it out into leaf nodes and dependencies. that said, it's such a "systems-y" feature that I don't think anyone would bat an eye if it were in the prelude. And it' so sophisticated that it could credibly claim to warrant its own keyword and dedicated syntax someday, so having it available "by default" seems fine</p>



<a name="233426922"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233426922" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233426922">(Apr 07 2021 at 03:46)</a>:</h4>
<p>I'd expect it to end up more common than core::arch intrinsics because the intrinsics are at a very sour spot in the ergonomics spectrum</p>



<a name="233427029"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233427029" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233427029">(Apr 07 2021 at 03:48)</a>:</h4>
<p>i think the main value in arch separate asm macros is if we want to commit to having very arch specific docs on each assembly macro. if they're all just going to say "arm version of asm, x86 version of asm, ..." then there's no point</p>



<a name="233428046"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233428046" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233428046">(Apr 07 2021 at 04:01)</a>:</h4>
<p>Yeah, I'd expect to have the same documentation on every version.</p>



<a name="233428650"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233428650" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amanieu <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233428650">(Apr 07 2021 at 04:10)</a>:</h4>
<p>There is the <code>att_syntax</code> option which is specific to x86.</p>



<a name="233428663"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233428663" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amanieu <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233428663">(Apr 07 2021 at 04:10)</a>:</h4>
<p>And obviously the list of registers and register classes which are target-specific.</p>



<a name="233428779"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233428779" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amanieu <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233428779">(Apr 07 2021 at 04:13)</a>:</h4>
<p>I personally don't really care where <code>asm!</code> ends up: the cost of adding an import is tiny and I don't mind it (this is coming from a codebase with 200+ <code>asm!</code> blocks).</p>



<a name="233443497"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233443497" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> hyd-dev <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233443497">(Apr 07 2021 at 07:16)</a>:</h4>
<p>I'm worrying how would something like <a href="https://github.com/rust-lang/rust/blob/1c158b6a8b440f826d952c3a8f42bdc3f77a5ac1/library/core/src/hint.rs#L170"><code>core::hint::black_box</code></a> be implemented if (<code>llvm_asm!</code> becomes <code>asm!</code> and) <code>asm!</code> becomes <code>core::arch::&lt;arch&gt;::asm!</code>.</p>



<a name="233488272"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233488272" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233488272">(Apr 07 2021 at 13:36)</a>:</h4>
<p>inside the function it would just have a lot of cfg, or none at all if asm was in the prelude</p>



<a name="233488642"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233488642" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amanieu <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233488642">(Apr 07 2021 at 13:38)</a>:</h4>
<p>And you can always fall back to a volatile load/store for targets that don't support <code>asm!</code>.</p>



<a name="233500998"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233500998" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> BurntSushi <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233500998">(Apr 07 2021 at 14:48)</a>:</h4>
<p>i mostly agree with <span class="user-mention" data-user-id="256342">@bstrie</span>, and in particular, i don't think <code>asm!</code> should be in the prelude. it's just nowhere near common enough to justify it IMO. whether it should be <code>std::arch::asm!</code> or <code>std::arch::{x86,x86_64,...}::asm!</code> isn't totally clear to me. it sounds like there is arch-specific syntax. so if all we have is <code>std::arch::asm!</code>, then how is that handled? how is it documented?</p>



<a name="233504426"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233504426" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amanieu <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233504426">(Apr 07 2021 at 15:02)</a>:</h4>
<p>At the moment all the documentation is here: <a href="https://doc.rust-lang.org/nightly/unstable-book/library-features/asm.html">https://doc.rust-lang.org/nightly/unstable-book/library-features/asm.html</a></p>



<a name="233504458"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233504458" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233504458">(Apr 07 2021 at 15:03)</a>:</h4>
<p>there is arch specific lists of what you can put in the various places you'd write a register name, and the assembly language used of course, other than that it's not arch specific.</p>



<a name="233504759"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233504759" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233504759">(Apr 07 2021 at 15:03)</a>:</h4>
<p><span class="user-mention" data-user-id="143274">@Amanieu</span> would you mind if I did a big cleanup of the asm docs? They kinda need some work.</p>



<a name="233504908"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233504908" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amanieu <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233504908">(Apr 07 2021 at 15:04)</a>:</h4>
<p>Sure, go ahead.</p>



<a name="233504921"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233504921" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> BurntSushi <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233504921">(Apr 07 2021 at 15:04)</a>:</h4>
<p>gotya. in that case, <code>std::arch::asm!</code> sounds good. or at least, i don't have any strong opinions.</p>



<a name="233504939"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233504939" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amanieu <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233504939">(Apr 07 2021 at 15:04)</a>:</h4>
<p>What kind of cleanup do you have in mind?</p>



<a name="233505038"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233505038" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233505038">(Apr 07 2021 at 15:04)</a>:</h4>
<p>all the topics are kinda out of order</p>



<a name="233505172"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233505172" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amanieu <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233505172">(Apr 07 2021 at 15:05)</a>:</h4>
<p>Well there's 2 parts to it: the guide-level and reference-level explanation</p>



<a name="233505345"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233505345" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233505345">(Apr 07 2021 at 15:06)</a>:</h4>
<p>Right, the reference level explanation is mostly fine</p>



<a name="233505859"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233505859" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amanieu <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233505859">(Apr 07 2021 at 15:07)</a>:</h4>
<p>If we do namespace <code>asm!</code>, we will also have to do the same with <code>global_asm!</code>. And possibly <code>asm_snippet!</code> as well if we decide to implement that.</p>



<a name="233733411"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233733411" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233733411">(Apr 08 2021 at 21:27)</a>:</h4>
<p>What happens today if you use <code>asm!</code> on an unsupported platform? compiler error?</p>



<a name="233745085"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233745085" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233745085">(Apr 08 2021 at 23:17)</a>:</h4>
<p>yes, <code>error[E0472]: asm! is unsupported on this target</code></p>



<a name="233746163"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233746163" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233746163">(Apr 08 2021 at 23:31)</a>:</h4>
<p>I've opened <a href="https://github.com/rust-lang/rust/issues/84019">https://github.com/rust-lang/rust/issues/84019</a> to collect all the various pros/cons of each approach</p>



<a name="233773255"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233773255" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> XAMPPRocky <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233773255">(Apr 09 2021 at 06:16)</a>:</h4>
<p>One con about having <code>arch::&lt;arch&gt;::asm!</code> that I haven't seen mentioned is that this implicitly requires that the target architecture have the same stability as core (plus its stability attribute), and there are architectures that <code>asm!</code> has support for that have no corresponding <code>arch</code> submodule.</p>
<p>I think it would be better to have it as <code>arch::asm!</code> so that whether you can use inline assembly with a target isn't blocked by adding new public APIs in <code>core</code>.</p>



<a name="233773519"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233773519" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233773519">(Apr 09 2021 at 06:21)</a>:</h4>
<p>but can't you just have a stable arch module with the one stable macro in it?</p>



<a name="233796178"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233796178" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> XAMPPRocky <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233796178">(Apr 09 2021 at 10:05)</a>:</h4>
<p><span class="user-mention" data-user-id="224471">@Lokathor</span> What happens if support for that target was later dropped?</p>



<a name="233798883"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233798883" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jacob Lifshay <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233798883">(Apr 09 2021 at 10:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="219696">XAMPPRocky</span> <a href="#narrow/stream/219381-t-libs/topic/namespacing.20.60asm!.60/near/233796178">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="224471">Lokathor</span> What happens if support for that target was later dropped?</p>
</blockquote>
<p>Logically, since that module was only ever <code>cfg</code> enabled when compiling for that target, if that target disappears then that module is always <code>cfg</code> disabled -- aka. disappears too. though I imagine we'd probably just delete that source file.</p>



<a name="233810919"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233810919" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233810919">(Apr 09 2021 at 12:20)</a>:</h4>
<p>unlikely, since build-std is a thing and will continue to grow so we actually will basically never be able to confidently say we've dropped support for a target</p>



<a name="233811021"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233811021" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233811021">(Apr 09 2021 at 12:21)</a>:</h4>
<p>particularly, even the targets we have demoted so far we didn't drop core support for, just std support for</p>



<a name="233926043"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233926043" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> XAMPPRocky <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233926043">(Apr 10 2021 at 04:51)</a>:</h4>
<p><span class="user-mention" data-user-id="224471">@Lokathor</span> Not sure I agree, we could and have definitely come to a point where where a target is fully dropped. Off the top of my head CloudABI’s support was fully removed for example.</p>



<a name="233936892"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233936892" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mara <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233936892">(Apr 10 2021 at 08:04)</a>:</h4>
<p>you can still compile core for any target you like with a <code>&lt;target&gt;.json</code> file. would be nice if <code>asm(..)</code> is usable for those targets too</p>



<a name="233977996"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233977996" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233977996">(Apr 10 2021 at 18:51)</a>:</h4>
<p>Even with &lt;target&gt;.json the compiler still needs full knowledge about the arch to know for example which registers and register classes exist. If the compiler has support, libcore may just as well support it. If libcore drops supports, the compiler would likely drop support for asm! too I did guess.</p>



<a name="233978065"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233978065" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233978065">(Apr 10 2021 at 18:52)</a>:</h4>
<p>I would like to know more about this. One of my assumptions here is that, once Rust has <code>asm!</code> support for a given target, the only reason to ever deprecate that support is if LLVM drops support for that target. And if LLVM drops support for the target, there's no use even trying to provide a deprecation warning, because your code straight up won't compile anymore. (Insert &lt;any future backend&gt; for LLVM if you like.) Is this oversimplifying?</p>
<blockquote>
<p>I think it would be better to have it as arch::asm! so that whether you can use inline assembly with a target isn't blocked by adding new public APIs in core.</p>
</blockquote>
<p>I'm not sure about this. Assuming <code>arch::asm</code> is stabilized, adding any new target will either require changes to <code>asm!</code> or it won't. In the latter case, the act of merely adding target support to rustc insta-stabilizes <code>asm!</code> on that platform, which seems possibly undesirable. In the former case, adding the new target support to <code>asm!</code> isn't really made more onerous by needing to make a new module for that target. The fact that <code>arch::&lt;foo&gt;::asm</code> prevents the "accidental stabilization" case actually seems like it might be a point in its favor.</p>



<a name="233980676"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233980676" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233980676">(Apr 10 2021 at 19:31)</a>:</h4>
<p>Yeah, it's certainly the case that we won't want to stabilize asm for all arches at the same moment. x86, x86-64, arm, and aarch64 have had a lot of work and testing for bugs. other arches are much less used, but we don't want them to hold back stabilization for the most used arches. Same as the intrinsics story really.</p>



<a name="233982189"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233982189" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233982189">(Apr 10 2021 at 19:54)</a>:</h4>
<p>though I suppose with creative <code>#cfg</code> use anything is possible, including preventing accidental stabilization even with <code>arch::asm</code>. So file this as yet another instance of "it doesn't really matter which one gets chosen" :P</p>



<a name="233982676"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233982676" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233982676">(Apr 10 2021 at 20:02)</a>:</h4>
<p>One question that it might be prudent to answer first: do people want <code>asm!</code> in the prelude? because if so, then the choice between these two almost literally just boils down to "where should the documentation live"</p>



<a name="233984121"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233984121" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> BurntSushi <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233984121">(Apr 10 2021 at 20:24)</a>:</h4>
<p>Personally, i don't think asm! is anywhere close to common enough to deserve being in the prelude.</p>



<a name="233986389"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233986389" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233986389">(Apr 10 2021 at 20:58)</a>:</h4>
<p>i don't think having it in the prelude would clash with any other reasonable macro.</p>



<a name="233986422"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233986422" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233986422">(Apr 10 2021 at 20:59)</a>:</h4>
<p>I would prefer to have it in the prelude, for simplicity of usage. It's a built-in macro, and the intent is for it to "feel" like a native language feature.</p>



<a name="233986584"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233986584" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233986584">(Apr 10 2021 at 21:00)</a>:</h4>
<p>I don't think it would conflict with anything, and if someone defined their own, they'd just shadow it.</p>



<a name="233996592"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233996592" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233996592">(Apr 10 2021 at 23:06)</a>:</h4>
<p>I guess this comes back to the <a href="https://github.com/rust-lang/rfcs/pull/3090#issuecomment-787149824">"vocabulary"</a> argument again, like <code>drop</code>.  Even if you're not using it, you probably shouldn't ever be making an item with that name anyway...</p>



<a name="233998380"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233998380" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> BurntSushi <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233998380">(Apr 10 2021 at 23:35)</a>:</h4>
<p>to be clear, name clashing isn't really the thing that bothers me about putting it in the prelude. what bothers me is that it's uncommon.</p>
<p>now, i would be more sympathetic to an argument like "this is what we've done in the past with other macros like the arguably even more obscure <code>is_x86_feature_detected!</code>, and until we've come up with a good story for how to namespace those, we shouldn't be namespacing things like <code>asm!</code>." e.g., i think <code>is_x86_feature_detected!</code> shouldn't be in the prelude either. Just the other day I needed to use it and naively wrote <code>use std::arch::x86::is_x86_featured_detected</code> and was surprised when it didn't work. i thought to myself, "wait where is it? something that obscure can't be in the prelude..."</p>
<p>of course, back then, i don't think we had a way to nicely namespace macros, but i forgot that bit of context in the moment.</p>



<a name="233998461"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233998461" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233998461">(Apr 10 2021 at 23:36)</a>:</h4>
<p>FWIW, I do think it's perfectly reasonable to put it in <code>std::arch</code>. I just think the prelude should have a <code>pub use</code>.</p>



<a name="233998479"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233998479" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233998479">(Apr 10 2021 at 23:37)</a>:</h4>
<p>It's not that it's incredibly common. It's that it's a macro that serves as a language feature, and I think it should "feel" built-in.</p>



<a name="233998753"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/233998753" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#233998753">(Apr 10 2021 at 23:43)</a>:</h4>
<p>Yeah commonality isn't a factor to me</p>



<a name="234003422"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/234003422" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> isHavvy <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#234003422">(Apr 11 2021 at 01:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="239881">Josh Triplett</span> <a href="#narrow/stream/219381-t-libs/topic/namespacing.20.60asm!.60/near/233998479">said</a>:</p>
<blockquote>
<p>It's not that it's incredibly common. It's that it's a macro that serves as a language feature, and I think it should "feel" built-in.</p>
</blockquote>
<p>Shouldn't that apply to the new <code>ptr</code> macros as well then?</p>



<a name="234004742"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/234004742" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#234004742">(Apr 11 2021 at 01:28)</a>:</h4>
<p>that's an interesting angle. I'd say that the fact that <code>addr_of!</code> is "expected" to be deprecated in favor of <code>&amp;raw</code> someday is a good argument for it <em>not</em> being in the prelude, to make it marginally less disruptive to someday deprecate. It also suggests (to me, anyway) that this is not the "finished" version of this feature, not enough to warrant being included in the language "by default". But I don't know how well that applies to <code>asm!</code> vs a first-class <code>asm</code> keyword; do people actually have expectations that there will exist an <code>asm</code> keyword to supersede the <code>asm!</code> macro someday? Is there any proto-proposal that discusses what unique semantics it would have to warrant first-class syntax?</p>



<a name="234005957"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/234005957" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#234005957">(Apr 11 2021 at 01:52)</a>:</h4>
<p>I think MSVC <a href="https://docs.microsoft.com/en-us/cpp/assembler/inline/asm?view=msvc-160">supports</a> a <code>__asm { code ... }</code> syntax</p>



<a name="234015794"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/234015794" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#234015794">(Apr 11 2021 at 04:53)</a>:</h4>
<p>MSVC only supports it on 32-bit x86</p>



<a name="234016777"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/234016777" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#234016777">(Apr 11 2021 at 05:11)</a>:</h4>
<p>Speaking only of the syntax question, I think it is moderately ugly that code is being written inside a string, since this implies that the language understanding of the contents is minimal. (And this is, for the most part, true.) In a perfect world, the contents of the asm macro would be typechecked so that invalid opcodes, label references and all the rest are resolved correctly, just like a proper DSL</p>



<a name="234017407"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/234017407" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#234017407">(Apr 11 2021 at 05:25)</a>:</h4>
<p><span class="user-mention" data-user-id="271719">@Mario Carneiro</span> Ideally it would be. But that is a <em>monumental</em> amount of work and ongoing maintenance, compared to using existing assemblers such as LLVM's.</p>



<a name="234017498"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/234017498" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#234017498">(Apr 11 2021 at 05:27)</a>:</h4>
<p>Yes, I'm aware. That's very much a long term shiny future aspiration, not anything actionable in the near future</p>



<a name="234017551"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/234017551" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#234017551">(Apr 11 2021 at 05:28)</a>:</h4>
<p>Although, it's not actually that hard to write an assembler, particularly if you are sharing an official data source like some tables produced by intel</p>



<a name="234019817"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/234019817" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jacob Lifshay <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#234019817">(Apr 11 2021 at 06:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="271719">Mario Carneiro</span> <a href="#narrow/stream/219381-t-libs/topic/namespacing.20.60asm!.60/near/234017551">said</a>:</p>
<blockquote>
<p>Although, it's not actually that hard to write an assembler, particularly if you are sharing an official data source like some tables produced by intel</p>
</blockquote>
<p>I just wrote a RISC-V spec parser (from the official TeX) for use in generating a disassembler:<br>
<a href="https://crates.io/crates/riscv-instructions">https://crates.io/crates/riscv-instructions</a><br>
mostly-untested rv64gc disassembler generator:<br>
<a href="https://github.com/programmerjake/riscv-jit-emulator/tree/master/riscv-jit-emulator-instruction-parser-generator">https://github.com/programmerjake/riscv-jit-emulator/tree/master/riscv-jit-emulator-instruction-parser-generator</a></p>



<a name="234019930"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/234019930" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amanieu <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#234019930">(Apr 11 2021 at 06:17)</a>:</h4>
<p>The idea with providing a string-based API is that the community can always make a proc macro wrapper around it to provide a better interface.</p>



<a name="234050519"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/234050519" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> XAMPPRocky <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#234050519">(Apr 11 2021 at 14:47)</a>:</h4>
<blockquote>
<p>I would like to know more about this. One of my assumptions here is that, once Rust has <code>asm!</code> support for a given target, the only reason to ever deprecate that support is if LLVM drops support for that target. And if LLVM drops support for the target, there's no use even trying to provide a deprecation warning, because your code straight up won't compile anymore. (Insert &lt;any future backend&gt; for LLVM if you like.) Is this oversimplifying?</p>
</blockquote>
<p><span class="user-mention" data-user-id="256342">@bstrie</span> Well i think there are additional factors such as certain targets being only available with certain backends and not others. A real example of this is the SPIR-V <code>asm!</code>, which is only supported when using <code>rust-gpu</code> as your codegen backend. So that target's support isn't based on LLVM.</p>
<p>Of course using that target requires nightly, but it wouldn't be intuitive if you had to change all <code>asm!</code> calls with <code>arch::x86_64::asm!</code> or some other target that wasn't the arch being compiled for, and I don't think makes sense to add new API surface for experimental targets which just re-export the same macro that every architecture uses.</p>



<a name="234051108"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/234051108" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#234051108">(Apr 11 2021 at 14:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="271719">Mario Carneiro</span> <a href="#narrow/stream/219381-t-libs/topic/namespacing.20.60asm!.60/near/234016777">said</a>:</p>
<blockquote>
<p>In a perfect world, the contents of the asm macro would be typechecked so that invalid opcodes, label references and all the rest are resolved correctly, just like a proper DSL</p>
</blockquote>
<p>No, the opposite. The current ASM is specifically spec'd as being "the compiler is not allowed to examine the content of this string and is not allowed to assume that the instructions executed at runtime will even do what the content of this string says (in other words: you're allowed to replace the code at runtime and the compiler must not assume that you won't).</p>



<a name="234058211"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/234058211" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#234058211">(Apr 11 2021 at 16:25)</a>:</h4>
<p><span class="user-mention" data-user-id="224471">@Lokathor</span> That's an important property, but doesn't preclude the compiler understanding the assembly. We would need to require that the compiler cannot change the assembly, but it could check your assembly against your stated clobbers, for example.</p>



<a name="234058243"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/234058243" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#234058243">(Apr 11 2021 at 16:25)</a>:</h4>
<p>(you could clobber more than your assembly requires, but you could get an error if you clobber less.)</p>



<a name="234058339"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/234058339" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#234058339">(Apr 11 2021 at 16:27)</a>:</h4>
<p>fair enough</p>



<a name="234061261"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/234061261" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#234061261">(Apr 11 2021 at 17:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="143274">Amanieu</span> <a href="#narrow/stream/219381-t-libs/topic/namespacing.20.60asm!.60/near/234019930">said</a>:</p>
<blockquote>
<p>The idea with providing a string-based API is that the community can always make a proc macro wrapper around it to provide a better interface.</p>
</blockquote>
<p>If we think that this is likely, then I think that's a reasonable argument for <code>asm!</code> not being in the prelude. But I think people would find this to be an easier pill to swallow if any such libraries already existed in a usable form; do they yet?</p>



<a name="234061930"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/234061930" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#234061930">(Apr 11 2021 at 17:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="219696">XAMPPRocky</span> <a href="#narrow/stream/219381-t-libs/topic/namespacing.20.60asm!.60/near/234050519">said</a>:</p>
<blockquote>
<p>Of course using that target requires nightly, but it wouldn't be intuitive if you had to change all <code>asm!</code> calls with <code>arch::x86_64::asm!</code> or some other target that wasn't the arch being compiled for, and I don't think makes sense to add new API surface for experimental targets which just re-export the same macro that every architecture uses.</p>
</blockquote>
<p>Hm, it does seem undesirable to suggest that alternative backends fork core just to get their supported submodules into <code>arch</code>. Although, I suppose that whatever patch added SPIR-V support to <code>asm!</code> in nightly could have just as easily added a <code>arch::spirv</code> module if this policy had happened to already be in place, yes? Adding a nightly-only module to support a nightly-only target doesn't seem that onerous. However, it does start to make the relative procedural simplicity of <code>arch::asm</code> look more desirable.</p>



<a name="234062887"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/234062887" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amanieu <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#234062887">(Apr 11 2021 at 17:43)</a>:</h4>
<p><span class="user-mention silent" data-user-id="256342">bstrie</span> <a href="#narrow/stream/219381-t-libs/topic/namespacing.20.60asm!.60/near/234061261">said</a>:</p>
<blockquote>
<p>If we think that this is likely, then I think that's a reasonable argument for <code>asm!</code> not being in the prelude. But I think people would find this to be an easier pill to swallow if any such libraries already existed in a usable form; do they yet?</p>
</blockquote>
<p>I personally feel that it's unlikely to happen. It's the justification for not providing a higher-level API for inline asm in the compiler.</p>



<a name="234063070"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/234063070" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Gary Guo <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#234063070">(Apr 11 2021 at 17:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="138448">cuviper</span> <a href="#narrow/stream/219381-t-libs/topic/namespacing.20.60asm!.60/near/233411590">said</a>:</p>
<blockquote>
<p>isn't there 32/64-bit RISC-V at least? we don't combine x86 for that...</p>
</blockquote>
<p>It is actually very easy to write assembly code (and machine code!) that works for both RV32 and RV64. So probably it makes sense to combine them, but that'll might be a inconsistency compared to other architectures...</p>



<a name="234066015"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/234066015" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#234066015">(Apr 11 2021 at 18:33)</a>:</h4>
<p>Personally I don't think that a person is likely to write individual inline asm blocks so complex that they warrant an entire DSL proc-macro for checking. That just bloats the compile time for not much gain</p>



<a name="234066381"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/234066381" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#234066381">(Apr 11 2021 at 18:39)</a>:</h4>
<p>I'm actually having a hard time answering the questions of what architectures rustc <em>does</em> support; it's very easy to see what arches <code>asm!</code> supports: <a href="https://github.com/rust-lang/rust/blob/7953910464e073eb3876d1544a3fd5b5ba0ca49b/compiler/rustc_target/src/asm/mod.rs#L173">https://github.com/rust-lang/rust/blob/7953910464e073eb3876d1544a3fd5b5ba0ca49b/compiler/rustc_target/src/asm/mod.rs#L173</a> , but it looks rustc only inspects a String field to see what the current target's arch is. in particular I don't find anywhere that actually defines a Target whose arch is "spirv", even though <code>asm!</code> does support SPIR-V, and even though there is exactly one place in the tree that uses it: <code>#[cfg(not(target_arch = "spirv"))]</code>. if there's not a subset relationship between possible values of <code>target_arch</code> and the supported arches for <code>asm!</code>, then that's probably a big argument in favor of <code>arch::asm</code>.</p>



<a name="234066437"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/234066437" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#234066437">(Apr 11 2021 at 18:40)</a>:</h4>
<p>is the idea that external target specs are defining such a target?</p>



<a name="234066495"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/234066495" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#234066495">(Apr 11 2021 at 18:41)</a>:</h4>
<p>because even so, I'm kind of surprised that there's no explicit whitelist of targets supported by rustc, and that things are expected to Just Work</p>



<a name="234069653"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/234069653" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> XAMPPRocky <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#234069653">(Apr 11 2021 at 19:31)</a>:</h4>
<blockquote>
<p>is the idea that external target specs are defining such a target?</p>
</blockquote>
<p><span class="user-mention" data-user-id="256342">@bstrie</span> Yes, the spirv target is defined entirely in the <code>rust-gpu</code> backend. When rustc is provided an unknown target it checks the available backends if it supports them.</p>



<a name="234071321"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/234071321" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#234071321">(Apr 11 2021 at 19:57)</a>:</h4>
<p>I'm impressed that works without even having any kind of call ABI defined in <a href="https://github.com/rust-lang/rust/tree/7953910464e073eb3876d1544a3fd5b5ba0ca49b/compiler/rustc_target/src/abi/call">https://github.com/rust-lang/rust/tree/7953910464e073eb3876d1544a3fd5b5ba0ca49b/compiler/rustc_target/src/abi/call</a></p>



<a name="234071626"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/234071626" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#234071626">(Apr 11 2021 at 20:01)</a>:</h4>
<p>I'm wondering if this has any implication for the observable stability of different values of <code>target_arch</code>, since anyone can provide their own value as a string, and presumably rustc can then decide to do anything at all for any value of it. In particular, having distinct modules for every supported <code>asm!</code> target seems like it might be a stronger stability guarantee than is currently expected (well, disregarding the popular arches, anyway), which is worth keeping in mind.</p>



<a name="234102771"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/234102771" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> XAMPPRocky <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#234102771">(Apr 12 2021 at 04:44)</a>:</h4>
<blockquote>
<p>In particular, having distinct modules for every supported <code>asm!</code> target seems like it might be a stronger stability guarantee than is currently expected (well, disregarding the popular arches, anyway), which is worth keeping in mind.</p>
</blockquote>
<p>Yeah, which is why I’m of the opinion <code>asm!</code> should be treated more as a language feature and have its input fall under target support stability rather than <code>std</code>/<code>core</code> stability.</p>



<a name="234106036"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/234106036" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bart Massey <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#234106036">(Apr 12 2021 at 05:42)</a>:</h4>
<p>I will copy-paste what I said on the Github issue:</p>
<hr>
<p>Strongly support std::arch::foo64::asm.</p>
<p>I find the kind of issue discussed in "3. Error reporting in the event of unguarded asm: having arch::asm" to be determinative.</p>
<p>I'm less worried about error reporting, though, than about having something accidentally cleanly assemble with different semantics because of the wrong architecture.</p>
<p>I have an example lying around somewhere in the issue tracker that will assemble for both x86_64 and aarch64: this is scary, since the operand order for the default x86_64 assembler is source, dest while aarch64 is dest, source. So now you've got probably UB or at least a surprising bug when somebody accidentally compiles the unqualified code for the wrong architecture.</p>
<hr>
<p>The problem here is that the user experience for clients of some deeply-nested crate is not going to be ideal no matter what we do. I'd much rather be told that my dependency won't build because some asm buried in one of that crate's dependency has the wrong architecture; getting some weird build error from a dependent crate about illegal operands or something would be much more confusing. That's the best case — the worst case is the one I mentioned above, where the crate appears to compile and assemble fine but fails in some mysterious way at runtime. Not so Rustic, I think.</p>
<hr>
<p>The other thing I'm kind of sad about is that this discussion is happening here rather than on the Github issue. I would not even have known about it had @bstrie not linked this discussion to there. I think it's really valuable to capture this discussion in the issue tracker — more people may see it, and once it's resolved there will be an easily-located permanent record of the rationale that might be really valuable in the future.</p>



<a name="234207852"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/namespacing%20%60asm%21%60/near/234207852" class="zl"><img src="https://rust-lang.github.io/zulip_archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://rust-lang.github.io/zulip_archive/stream/219381-t-libs/topic/namespacing.20.60asm!.60.html#234207852">(Apr 12 2021 at 18:30)</a>:</h4>
<p><span class="user-mention" data-user-id="220717">@Bart Massey</span> , note that I made this Zulip thread prior to making the Github thread, and semi-intended that the GH thread would be a more prominent/permanent summary of the various discussions happening here (or elsewhere). I've been updating the main GH issue as pertinent information arises. In general people seem to find it preferable to use Zulip for fast-moving/bikesheddy topics, since 1) it avoids pinging every single person's email every time anyone comments, and 2) it doesn't exhibit Github's annoying auto-hide behavior for long threads.</p>



<hr><p>Last updated: Aug 07 2021 at 22:04 UTC</p>
</html>