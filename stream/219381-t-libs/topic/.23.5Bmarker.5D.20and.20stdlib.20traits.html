<html>
<head><meta charset="utf-8"><title>#[marker] and stdlib traits · t-libs · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/index.html">t-libs</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/.23.5Bmarker.5D.20and.20stdlib.20traits.html">#[marker] and stdlib traits</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="269563259"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/%23%5Bmarker%5D%20and%20stdlib%20traits/near/269563259" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/.23.5Bmarker.5D.20and.20stdlib.20traits.html#269563259">(Jan 27 2022 at 12:11)</a>:</h4>
<p>So, I posted a long rant about <code>#[marker]</code> on stdlib types <a href="#narrow/stream/213817-t-lang/topic/design.20meeting.3A.20backlog.20bonanza/near/269471299">over here</a>, claiming that in general, people relying on current limitations of the coherence system to assert lack of impls wasn't really a tenable situation, and that, for instance, the case of <code>#[marker]</code> loosening coherence causing unsoundness in some places was kind of the fault of "those some places" — that being said, it's true that macro authors (because this is the main case we're talking about) don't really have any other tool than coherence or <a href="https://docs.rs/impls/1.0.3/impls/macro.impls.html">resolution ambiguity</a> to ensure that a trait is not implemented in some cases, <em>even for a local type</em>. And for the very case of <code>Unpin</code>, in hindsight that trait should have been <code>unsafe</code>, so it's kind of normal that it not being the case leads to easier instances of unsoundness.</p>
<p>So the solution for <code>Unpin</code> is not to make it <code>#[marker]</code>, and then remained the question of <em>quid</em> of the other stdlib (empty) traits?</p>
<p>And I have realized that I don't think we <em>need</em> to mark specific traits as <code>#[marker]</code>, not even stdlib ones. So even though we <em>could</em>, for <code>unsafe</code> traits, and <em>maybe we could</em>, for non-<code>unsafe</code> traits, my new answer is <em>we don't need to</em>.</p>
<div class="spoiler-block"><div class="spoiler-header">
<p>A real-life example: when is ReentrantMutex Sync?</p>
</div><div class="spoiler-content" aria-hidden="true">
<p>To see that, let's take an example: <code>parking_lot</code>'s <code>ReentrantMutex&lt;T&gt;</code>. I find that wrapper to be an incredibly interesting case study, since while locking that mutex ensures lack of <em>parallelism</em>, as its name conveys, it's made to be reentrant-friendly, meaning that it's still allowing (single-threaded) <em>concurrency</em>. In other words, even after locking that mutex, you still can't get <code>&amp;mut</code> references to <code>T</code>, only <code>&amp;</code> references. But you are guaranteed that at any given point in time, all the outstanding <code>&amp;</code> references live in the same thread —unless <code>T : Sync</code>, in which case <code>ReentrantMutex</code> is useless (and thus harmless)—, even though that "group of <code>&amp;</code>-references may "spawn" in another thread afterwards.</p>
<p>Now, the interesting question is, when is <code>ReentrantMutex&lt;T&gt;</code> <code>Send</code>, and when is it <code>Sync</code>?</p>
<ul>
<li>
<p>Since <code>ReentrantMutex&lt;T&gt;</code> does not feature shared ownership, we don't need <code>T : Sync</code> for it to be <code>Send</code>, and since <code>&amp;mut RM&lt;T&gt;</code> -&gt; <code>&amp;mut T</code> (<em>e.g.</em>, on drop), then <code>T : Send</code> is necessary.<br>
    Hence: <code>impl &lt;T : Send&gt; Send for ReentrantMutex&lt;T&gt;</code>.</p>
</li>
<li>
<p>Since <code>ReentrantMutex&lt;T&gt;</code> is useless-and-thus-harmless when <code>T : Sync</code>, we already know that<br>
<code>impl&lt;T : Sync&gt; Sync for ReentrantMutex&lt;T&gt;</code> holds.<br>
    Also, and that's kind of the point of <code>ReentrantMutex&lt;T&gt;</code>, its API allows multiple <code>&amp;</code>s to cross thread boundaries if they <em>all do</em>. When <code>T : Send</code>, a single <code>&amp;mut T</code> can cross thread boundaries, and from there, one can derive multiple <code>&amp;</code>s in that thread. Thus, if <code>T : Send</code>, it must be safe for multiple <code>&amp;</code>s to cross thread boundaries if they <em>all do</em>, which means that if <code>T : Send</code>, it is safe to share <code>ReentrantMutex&lt;T&gt;</code>es across threads (the whole <em>raison d'être</em> of that wrapper).<br>
    Hence, <code>impl&lt;T : Send&gt; Sync for ReentrantMutex&lt;T&gt;</code>.</p>
</li>
</ul>
</div></div>
<p>But obviously those two impls of <code>Sync</code> currently overlap. <strong>So we might be tented to think <code>Sync</code> must be <code>#[marker]</code> in order to express this property</strong>. But it's not the case!</p>
<p>Indeed, <strong>a helper <code>#[marker]</code> trait suffices</strong>:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="sd">//! in parking_lot</span>
<span class="cp">#[marker]</span><span class="w"></span>
<span class="k">pub</span><span class="w"></span>
<span class="k">unsafe</span><span class="w"></span>
<span class="k">trait</span><span class="w"> </span><span class="n">SendOrSync</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="k">unsafe</span><span class="w"> </span><span class="c1">// {</span>
<span class="w">    </span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="w"> </span>: <span class="o">?</span><span class="nb">Sized</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="o">&gt;</span><span class="w"> </span><span class="n">SendOrSync</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="c1">// }</span>
<span class="k">unsafe</span><span class="w"> </span><span class="c1">// {</span>
<span class="w">    </span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="w"> </span>: <span class="o">?</span><span class="nb">Sized</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Sync</span><span class="o">&gt;</span><span class="w"> </span><span class="n">SendOrSync</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="c1">// }</span>
</code></pre></div>
<p>And from there, we get our desired impl:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">unsafe</span><span class="w"> </span><span class="c1">// {</span>
<span class="w">    </span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="w"> </span>: <span class="o">?</span><span class="nb">Sized</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">SendOrSync</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Sync</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">ReentrantMutex</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="c1">// }</span>
</code></pre></div>
<p>I thus generally think that this pattern allows anyone to, <em>locally</em>, make it as if the desired remote trait were <code>#[marker]</code>:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="w"> </span>: <span class="nc">A</span><span class="err">…</span><span class="o">&gt;</span><span class="w"> </span><span class="n">RemoteTrait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SomeType</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="w"> </span>: <span class="nc">B</span><span class="err">…</span><span class="o">&gt;</span><span class="w"> </span><span class="n">RemoteTrait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SomeType</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
</code></pre></div>
<p>becomes:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="c1">// #[sealed] /* if desired */</span>
<span class="cp">#[marker]</span><span class="w"></span>
<span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">AorB</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="w"> </span>: <span class="nc">A</span><span class="err">…</span><span class="o">&gt;</span><span class="w"> </span><span class="n">AorB</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="w"> </span>: <span class="nc">B</span><span class="err">…</span><span class="o">&gt;</span><span class="w"> </span><span class="n">AorB</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="w"> </span>: <span class="nc">AorB</span><span class="o">&gt;</span><span class="w"> </span><span class="n">RemoteTrait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SomeType</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
</code></pre></div>
<h3>TL,DR</h3>
<p>None of the stdlib traits thus need to be made <code>#[marker]</code>?</p>



<a name="269582499"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/%23%5Bmarker%5D%20and%20stdlib%20traits/near/269582499" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/.23.5Bmarker.5D.20and.20stdlib.20traits.html#269582499">(Jan 27 2022 at 14:47)</a>:</h4>
<p><code>#[marker]</code> always did seem like a hack, so I'd be happy if we could get rid of it, but how realistic is it do so backwards-compatibly, even taking editions into account?</p>



<a name="269582736"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/%23%5Bmarker%5D%20and%20stdlib%20traits/near/269582736" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Waffle Lapkin <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/.23.5Bmarker.5D.20and.20stdlib.20traits.html#269582736">(Jan 27 2022 at 14:48)</a>:</h4>
<p><code>#[marker]</code> is unstable <a href="https://github.com/rust-lang/rust/issues/29864">https://github.com/rust-lang/rust/issues/29864</a></p>



<a name="269586890"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/%23%5Bmarker%5D%20and%20stdlib%20traits/near/269586890" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/.23.5Bmarker.5D.20and.20stdlib.20traits.html#269586890">(Jan 27 2022 at 15:14)</a>:</h4>
<p>ah, I thought that <code>#[marker]</code> was already being used on stable items. I might have been confusing it with <code>#[fundamental]</code></p>



<a name="269591355"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/%23%5Bmarker%5D%20and%20stdlib%20traits/near/269591355" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/.23.5Bmarker.5D.20and.20stdlib.20traits.html#269591355">(Jan 27 2022 at 15:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="232018">Daniel Henry-Mantilla</span> <a href="#narrow/stream/219381-t-libs/topic/.23.5Bmarker.5D.20and.20stdlib.20traits/near/269563259">said</a>:</p>
<blockquote>
<p>to ensure that a trait is not implemented in some cases, <em>even for a local type</em></p>
</blockquote>
<p>For local types they could add a negative impl, no?</p>



<a name="269615592"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/%23%5Bmarker%5D%20and%20stdlib%20traits/near/269615592" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/.23.5Bmarker.5D.20and.20stdlib.20traits.html#269615592">(Jan 27 2022 at 18:21)</a>:</h4>
<p><span class="user-mention" data-user-id="125270">@scottmcm</span> it may not always be as easy as it sounds, since the negative impl would like to be the "complementary set" of the positive one, which has always been a thorny thing to express in Rust. But I'd love to see there is a proper way to achieve this</p>



<a name="269617734"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/%23%5Bmarker%5D%20and%20stdlib%20traits/near/269617734" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/.23.5Bmarker.5D.20and.20stdlib.20traits.html#269617734">(Jan 27 2022 at 18:36)</a>:</h4>
<p><span class="user-mention" data-user-id="232018">@Daniel Henry-Mantilla</span> I mean in the sense of <a href="https://doc.rust-lang.org/nightly/unstable-book/language-features/negative-impls.html">https://doc.rust-lang.org/nightly/unstable-book/language-features/negative-impls.html</a>, which already does the checking to make sure you don't have positive and negative impls for the same thing.</p>



<a name="269646353"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/%23%5Bmarker%5D%20and%20stdlib%20traits/near/269646353" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/.23.5Bmarker.5D.20and.20stdlib.20traits.html#269646353">(Jan 27 2022 at 22:04)</a>:</h4>
<p>Yeah, I imagined such, but that doesn't work with overlaps, does it? Does <code>negative_impls</code> on nightly currently involve that one, or the basic auto-trait one?</p>
<p>Basically what <code>pin_project</code> would need would be something like:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">exclusive</span><span class="w"></span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">PinnedField</span><span class="w"> </span>: <span class="nb">Unpin</span><span class="p">,</span><span class="w"> </span><span class="n">U</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Unpin</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Foo</span><span class="o">&lt;</span><span class="n">PinnedField</span><span class="p">,</span><span class="w"> </span><span class="n">U</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
</code></pre></div>
<p>It's that "complement set" reasoning which, AFAIK, can only be achieved through (unsound) specialization, and even then it's not obvious <span aria-label="thinking" class="emoji emoji-1f914" role="img" title="thinking">:thinking:</span></p>



<a name="272466105"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/%23%5Bmarker%5D%20and%20stdlib%20traits/near/272466105" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nikomatsakis <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/.23.5Bmarker.5D.20and.20stdlib.20traits.html#272466105">(Feb 18 2022 at 22:22)</a>:</h4>
<p><span class="user-mention" data-user-id="232018">@Daniel Henry-Mantilla</span> the intent going forward is that you can only rely on things for which you have explicit negative impls</p>



<a name="272466176"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/%23%5Bmarker%5D%20and%20stdlib%20traits/near/272466176" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nikomatsakis <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/.23.5Bmarker.5D.20and.20stdlib.20traits.html#272466176">(Feb 18 2022 at 22:22)</a>:</h4>
<p>I'd like to understand better what people are doing with pin</p>



<a name="272477307"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/%23%5Bmarker%5D%20and%20stdlib%20traits/near/272477307" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/.23.5Bmarker.5D.20and.20stdlib.20traits.html#272477307">(Feb 19 2022 at 00:21)</a>:</h4>
<p>Cc <span class="user-mention" data-user-id="213313">@Taiki Endo</span><br>
But the gist is that when you want to write a pinning projection to a field (<code>Pin&lt;&amp;mut Wrapper&lt;T&gt;&gt; -&gt; Pin&lt;&amp;mut T&gt;</code>), you can only _soundly_ write it if you know that for any <code>T</code>, if <code>Wrapper&lt;T&gt; : Unpin</code>, then <code>T : Unpin</code>.</p>
<p>And while this is a fine-ish requirement when somebody writes all the code, in the case of a helper macro, such as <code>pin-project</code>, <em>whose purpose is to allow people to offer a <strong>non-<code>unsafe</code></strong> API to express pin-projection semantics</em>, we end up between a conceptual code split between the macro-generated code, and the caller's code.</p>
<p>Usually, when an API needs a trait not be implemented in certain cases lest it malfunction, we have three thingsnthat help:</p>
<ul>
<li>
<p>the malfunction may not be UB/memory safety related, in which case the problem is not dire (buggy behavior in the presence of silly impls is acceptable);</p>
</li>
<li>
<p>the trait is <code>unsafe</code>, so the burden/responsibility of soundness is (in part) on the silly <code>unsafe impl</code>,</p>
</li>
<li>
<p>there is no macro involved, and so we can rely on cross-crate coherence to know we "own" the impls on our type / of our trait, etc.</p>
</li>
</ul>
<p>In the case of <code>pin-project</code>, we have none of these:</p>
<ul>
<li>
<p>Incorrect <code>Unpin</code> impls could allow constructing certsin <code>Pin</code> pointers without <code>unsafe</code>, circumventing the unsafety of <code>Pin::new_unchecked()</code>, so misusage can cause UB;</p>
</li>
<li>
<p><strong><code>Unpin</code> is not an <code>unsafe trait</code></strong></p>
</li>
<li>
<p>the macro API makes it so the non-unsafe code we need to guard against (as per the soundness contract) may live in the same crate, so there isn't much coherence can do in this area to prevent the silly impls.</p>
</li>
<li>
<p>the malfunctioning is not UB, just logic errors, and thus the trait doesn't have</p>
</li>
</ul>



<a name="272477838"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/%23%5Bmarker%5D%20and%20stdlib%20traits/near/272477838" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/.23.5Bmarker.5D.20and.20stdlib.20traits.html#272477838">(Feb 19 2022 at 00:28)</a>:</h4>
<p>Historically (actually, currently), the limitations of coherence have allowed "hacks" to achieve that third bullet: <code>pin-project</code> generates an impl which currently overlaps —even within the same crate—, with those a user may write atop it.</p>
<p>Example:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="sd">/// By macro</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="w"> </span>: <span class="nb">Unpin</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Unpin</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Wrapper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="c1">// If a user tries to write:</span>
<span class="k">impl</span><span class="w"> </span><span class="nb">Unpin</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Wrapper</span><span class="o">&lt;</span><span class="n">PhantomPinned</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
</code></pre></div>
<ul>
<li>Note: the impl used by pin-project is a bit more complex, relying on a helper local type that can only be named by the macro.</li>
</ul>
<p>then, even if the impls do not overlap, the coherence checker denies this, "luckily"! So the API is sound as long as the coherence checker is as limited as it is today.</p>
<p>But with things such as <code>negative_coherence</code>, or <code>Unpin</code> itself being <code>#[marker]</code>, coherence can be loosened enough to allow more of these impls, and thus "break" the actually fragile soundness of <code>pin-project</code>'s API</p>



<a name="272478008"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/%23%5Bmarker%5D%20and%20stdlib%20traits/near/272478008" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/.23.5Bmarker.5D.20and.20stdlib.20traits.html#272478008">(Feb 19 2022 at 00:31)</a>:</h4>
<h3>TL,DR</h3>
<p>pin-project's soundess requires negating a part of the possible impls of a trait, and currently achieves that by relying on coherence, a tool made to avoid _overlaps_ of impls. But since "evil" / "bad" impls would not need to overlap (not even when semver-future-proofing, since the type is local so technically there is no need to future proof, as far as coherence is concerned), coherence doesn't seem like the right tool, mid-term, to guarantee the soundness of <code>pin-project</code></p>



<a name="272478110"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/%23%5Bmarker%5D%20and%20stdlib%20traits/near/272478110" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/.23.5Bmarker.5D.20and.20stdlib.20traits.html#272478110">(Feb 19 2022 at 00:32)</a>:</h4>
<p>But back to <code>#[marker]</code> <em>specifically</em>, if <code>Unpin</code> is not, then pin-project is fine</p>



<a name="272604944"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/%23%5Bmarker%5D%20and%20stdlib%20traits/near/272604944" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/.23.5Bmarker.5D.20and.20stdlib.20traits.html#272604944">(Feb 20 2022 at 17:21)</a>:</h4>
<p>It seems like it would be edition-compatible to make Unpin an unsafe trait in the future, right? It would involve edition-specific hacks in compiler to allow old edition users to omit the <code>unsafe</code>, but that doesn't seem any worse than the IntoIter hack on arrays in the compiler</p>



<a name="272606045"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/%23%5Bmarker%5D%20and%20stdlib%20traits/near/272606045" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/.23.5Bmarker.5D.20and.20stdlib.20traits.html#272606045">(Feb 20 2022 at 17:43)</a>:</h4>
<p>Having two Unpin traits, exported in an edition-dependent manner and having one as parent of the other + blanket impl should work, I think. No new compiler hacks needed beyond the edition-dependent export which already is there.</p>



<a name="272609619"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/%23%5Bmarker%5D%20and%20stdlib%20traits/near/272609619" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/.23.5Bmarker.5D.20and.20stdlib.20traits.html#272609619">(Feb 20 2022 at 18:54)</a>:</h4>
<p>Remember, an unsoundness in the type system having an evolutionary path forward to fix it is something we do because we're nice, not actually required. The Rust project reserved the right to simply break unsound user code a long time ago. As far as I know we didn't clearly establish a story for "this is technically sound if you consider all the limitations in play but it breaks under any evolution of the system", however, so obviously it is much more rude to break them if it's "technically, currently, right now, this second" sound.</p>



<a name="272609811"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/%23%5Bmarker%5D%20and%20stdlib%20traits/near/272609811" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/.23.5Bmarker.5D.20and.20stdlib.20traits.html#272609811">(Feb 20 2022 at 18:58)</a>:</h4>
<p>And it's not like we're going to go all <code>${FP_LANG}</code> on people and rewrite the stdlib every year and break all user code by doing so, I am just noting that fixing a problem takes priority over making it a gentle transition, approximately with the ratio of it being an actual problem.</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>