<html>
<head><meta charset="utf-8"><title>Can we commit to `impl !Ord for f32`? · t-libs · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/index.html">t-libs</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Can.20we.20commit.20to.20.60impl.20!Ord.20for.20f32.60.3F.html">Can we commit to `impl !Ord for f32`?</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="269802270"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Can%20we%20commit%20to%20%60impl%20%21Ord%20for%20f32%60%3F/near/269802270" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Can.20we.20commit.20to.20.60impl.20!Ord.20for.20f32.60.3F.html#269802270">(Jan 28 2022 at 21:05)</a>:</h4>
<p>Starting a different thread for this.</p>
<p>I know there have been many people unhappy with the PartialOrd/Ord split, and wishing it could go away.  But we could <em>never</em> add <code>impl Ord for f32</code>, right, without breaking the existing <code>Ord</code> rules?</p>
<p>That says to me that if we did want to remove the difference, it would need to be more about changing trait bounds to <code>PartialOrd</code> instead of <code>Ord</code>, rather than making floats <code>Ord</code>.  And thus we'd be fine to put <code>impl !Ord for f32</code> in core, and use that as a place to document <em>why</em> it needs to be that way.</p>
<p>Is that correct?  I could open a PR for the negative impls...</p>



<a name="269803780"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Can%20we%20commit%20to%20%60impl%20%21Ord%20for%20f32%60%3F/near/269803780" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Can.20we.20commit.20to.20.60impl.20!Ord.20for.20f32.60.3F.html#269803780">(Jan 28 2022 at 21:17)</a>:</h4>
<p>I think the only way we could add <code>Ord</code> for <code>f32</code> and <code>f64</code> would be if we also added <code>Eq</code> and made <code>NAN == NAN</code>. Which would be a substantial change and not how other languages behave, though personally I would be thrilled if we'd done that from day 1.</p>



<a name="269809033"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Can%20we%20commit%20to%20%60impl%20%21Ord%20for%20f32%60%3F/near/269809033" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Can.20we.20commit.20to.20.60impl.20!Ord.20for.20f32.60.3F.html#269809033">(Jan 28 2022 at 22:02)</a>:</h4>
<p>it's pretty expensive in terms of time though, because hardware doesn't do that directly</p>



<a name="270021715"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Can%20we%20commit%20to%20%60impl%20%21Ord%20for%20f32%60%3F/near/270021715" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Can.20we.20commit.20to.20.60impl.20!Ord.20for.20f32.60.3F.html#270021715">(Jan 31 2022 at 12:17)</a>:</h4>
<p>surely the authors of the floating-point standard had <em>some</em> good reason to make NaN != NaN, right?</p>



<a name="270026323"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Can%20we%20commit%20to%20%60impl%20%21Ord%20for%20f32%60%3F/near/270026323" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Can.20we.20commit.20to.20.60impl.20!Ord.20for.20f32.60.3F.html#270026323">(Jan 31 2022 at 12:56)</a>:</h4>
<p>It's because <code>NaN</code> is intended to be an error, so it indicates that error by being incomparable with all values, including other NaNs, would could be caused by other unrelated errors, and thus making them compare equal could "hide" other errors.</p>
<p>See, for example,</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mf">1.0</span><span class="k">f32</span><span class="p">;</span><span class="w"> </span><span class="c1">// Pretend x comes from some input, possibly a computation on user-controlled input</span>
<span class="kd">let</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">f32</span>::<span class="n">INFINTIY</span><span class="p">;</span><span class="w"> </span><span class="c1">// Likewise</span>
<span class="k">if</span><span class="w"> </span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">==</span><span class="n">sin</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Pretend this is some check of two functions that makes sense</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">"Succeeded"</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>



<a name="270037930"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Can%20we%20commit%20to%20%60impl%20%21Ord%20for%20f32%60%3F/near/270037930" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mara <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Can.20we.20commit.20to.20.60impl.20!Ord.20for.20f32.60.3F.html#270037930">(Jan 31 2022 at 14:19)</a>:</h4>
<p>hot take: f32 and f64 shouldn't have supported NaN at all, and Result&lt;f64, NaN&gt; should've been the type representing ieee754 floats.</p>



<a name="270042400"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Can%20we%20commit%20to%20%60impl%20%21Ord%20for%20f32%60%3F/near/270042400" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Taylor Yu [they/she] <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Can.20we.20commit.20to.20.60impl.20!Ord.20for.20f32.60.3F.html#270042400">(Jan 31 2022 at 14:48)</a>:</h4>
<p>subnormal numbers and infinities can also represent exceptional conditions, depending on application, right? so you might need a family of "error" types for a float type</p>



<a name="270044548"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Can%20we%20commit%20to%20%60impl%20%21Ord%20for%20f32%60%3F/near/270044548" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Can.20we.20commit.20to.20.60impl.20!Ord.20for.20f32.60.3F.html#270044548">(Jan 31 2022 at 15:01)</a>:</h4>
<p>floats aren't numbers, they're just some packed bitfield with special abi treatment</p>



<a name="270245466"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Can%20we%20commit%20to%20%60impl%20%21Ord%20for%20f32%60%3F/near/270245466" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Simon Sapin <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Can.20we.20commit.20to.20.60impl.20!Ord.20for.20f32.60.3F.html#270245466">(Feb 01 2022 at 16:57)</a>:</h4>
<p>To avoid hiding the error <code>f32::NaN == x</code> should <em>just</em> return <code>bool::NaN</code>, the third boolean value ;)</p>



<a name="270245631"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Can%20we%20commit%20to%20%60impl%20%21Ord%20for%20f32%60%3F/near/270245631" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Simon Sapin <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Can.20we.20commit.20to.20.60impl.20!Ord.20for.20f32.60.3F.html#270245631">(Feb 01 2022 at 16:58)</a>:</h4>
<p>or maybe <code>bool::NaB</code> for not-a-boolean</p>



<a name="270246984"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Can%20we%20commit%20to%20%60impl%20%21Ord%20for%20f32%60%3F/near/270246984" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Can.20we.20commit.20to.20.60impl.20!Ord.20for.20f32.60.3F.html#270246984">(Feb 01 2022 at 17:05)</a>:</h4>
<p><span class="user-mention" data-user-id="116122">@simulacrum</span> <code>bool::FileNotFound</code></p>



<a name="270247030"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Can%20we%20commit%20to%20%60impl%20%21Ord%20for%20f32%60%3F/near/270247030" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Can.20we.20commit.20to.20.60impl.20!Ord.20for.20f32.60.3F.html#270247030">(Feb 01 2022 at 17:05)</a>:</h4>
<p>don't forget <code>bool::Inf</code> for the result of <code>true / false</code></p>



<a name="270247391"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Can%20we%20commit%20to%20%60impl%20%21Ord%20for%20f32%60%3F/near/270247391" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Can.20we.20commit.20to.20.60impl.20!Ord.20for.20f32.60.3F.html#270247391">(Feb 01 2022 at 17:07)</a>:</h4>
<p>(reference, for folks who haven't seen it: <a href="https://thedailywtf.com/articles/What_Is_Truth_0x3f_">https://thedailywtf.com/articles/What_Is_Truth_0x3f_</a> )</p>



<a name="270248586"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Can%20we%20commit%20to%20%60impl%20%21Ord%20for%20f32%60%3F/near/270248586" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Can.20we.20commit.20to.20.60impl.20!Ord.20for.20f32.60.3F.html#270248586">(Feb 01 2022 at 17:13)</a>:</h4>
<p>(I wonder if it would break anything to define <code>bool</code> as an enum in std as opposed to making it a primitive...)</p>



<a name="270248899"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Can%20we%20commit%20to%20%60impl%20%21Ord%20for%20f32%60%3F/near/270248899" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Can.20we.20commit.20to.20.60impl.20!Ord.20for.20f32.60.3F.html#270248899">(Feb 01 2022 at 17:15)</a>:</h4>
<p><span class="user-mention" data-user-id="256342">@bstrie</span> It'd have to be a language item so that <code>if</code> and <code>while</code> similar can expect it.</p>



<a name="270248984"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Can%20we%20commit%20to%20%60impl%20%21Ord%20for%20f32%60%3F/near/270248984" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Can.20we.20commit.20to.20.60impl.20!Ord.20for.20f32.60.3F.html#270248984">(Feb 01 2022 at 17:16)</a>:</h4>
<p>And I suspect it'd have performance issues if the compiler didn't "natively" understand it.</p>



<a name="270249000"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Can%20we%20commit%20to%20%60impl%20%21Ord%20for%20f32%60%3F/near/270249000" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Can.20we.20commit.20to.20.60impl.20!Ord.20for.20f32.60.3F.html#270249000">(Feb 01 2022 at 17:16)</a>:</h4>
<p>But I don't think in <em>principle</em> it'd be impossible.</p>



<a name="270249008"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Can%20we%20commit%20to%20%60impl%20%21Ord%20for%20f32%60%3F/near/270249008" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Taylor Yu [they/she] <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Can.20we.20commit.20to.20.60impl.20!Ord.20for.20f32.60.3F.html#270249008">(Feb 01 2022 at 17:16)</a>:</h4>
<p>RFC replacing bools with intuitionistic logic when?</p>



<a name="270250313"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Can%20we%20commit%20to%20%60impl%20%21Ord%20for%20f32%60%3F/near/270250313" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Can.20we.20commit.20to.20.60impl.20!Ord.20for.20f32.60.3F.html#270250313">(Feb 01 2022 at 17:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="239881">Josh Triplett</span> <a href="#narrow/stream/219381-t-libs/topic/Can.20we.20commit.20to.20.60impl.20!Ord.20for.20f32.60.3F/near/270248984">said</a>:</p>
<blockquote>
<p>And I suspect it'd have performance issues if the compiler didn't "natively" understand it.</p>
</blockquote>
<p>I doubt it. Aren't C-like enums as-performant as the underlying integer type?</p>



<a name="270250667"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Can%20we%20commit%20to%20%60impl%20%21Ord%20for%20f32%60%3F/near/270250667" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Can.20we.20commit.20to.20.60impl.20!Ord.20for.20f32.60.3F.html#270250667">(Feb 01 2022 at 17:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="256342">bstrie</span> <a href="#narrow/stream/219381-t-libs/topic/Can.20we.20commit.20to.20.60impl.20!Ord.20for.20f32.60.3F/near/270248586">said</a>:</p>
<blockquote>
<p>(I wonder if it would break anything to define <code>bool</code> as an enum in std as opposed to making it a primitive...)</p>
</blockquote>
<p>You can use <code>bool</code> and <code>true</code>/<code>false</code> in the global namespace w/o a prelude, which would be impossible if it was defined in <code>std</code>.</p>



<a name="270250830"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Can%20we%20commit%20to%20%60impl%20%21Ord%20for%20f32%60%3F/near/270250830" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Can.20we.20commit.20to.20.60impl.20!Ord.20for.20f32.60.3F.html#270250830">(Feb 01 2022 at 17:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="239881">Josh Triplett</span> <a href="#narrow/stream/219381-t-libs/topic/Can.20we.20commit.20to.20.60impl.20!Ord.20for.20f32.60.3F/near/270248899">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="256342">bstrie</span> It'd have to be a language item so that <code>if</code> and <code>while</code> similar can expect it.</p>
</blockquote>
<p>ah, but clearly we should redefine <code>if</code> and <code>while</code> in terms of <code>ops::ControlFlow</code> :P</p>



<a name="270251001"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Can%20we%20commit%20to%20%60impl%20%21Ord%20for%20f32%60%3F/near/270251001" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Can.20we.20commit.20to.20.60impl.20!Ord.20for.20f32.60.3F.html#270251001">(Feb 01 2022 at 17:27)</a>:</h4>
<p>ngl, that kinda makes sense for <code>while</code>. IDK how <code>if</code> would work, though? <code>Continue</code> enters body, <code>Break</code> doesn't/goes to else?</p>



<a name="270256067"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Can%20we%20commit%20to%20%60impl%20%21Ord%20for%20f32%60%3F/near/270256067" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Can.20we.20commit.20to.20.60impl.20!Ord.20for.20f32.60.3F.html#270256067">(Feb 01 2022 at 17:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/219381-t-libs/topic/Can.20we.20commit.20to.20.60impl.20!Ord.20for.20f32.60.3F/near/270250313">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="239881">Josh Triplett</span> <a href="#narrow/stream/219381-t-libs/topic/Can.20we.20commit.20to.20.60impl.20!Ord.20for.20f32.60.3F/near/270248984">said</a>:</p>
<blockquote>
<p>And I suspect it'd have performance issues if the compiler didn't "natively" understand it.</p>
</blockquote>
<p>I doubt it. Aren't C-like enums as-performant as the underlying integer type?</p>
</blockquote>
<p>Integer type, yes. But I'm not sure if all the optimizations the compiler does with <code>bool</code> are true for integers. The compiler sometimes generates code using an architecture's condition codes for bool control flow, rather than (for instance) having to compare the bool to 1 or 0.</p>



<a name="270256104"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Can%20we%20commit%20to%20%60impl%20%21Ord%20for%20f32%60%3F/near/270256104" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Can.20we.20commit.20to.20.60impl.20!Ord.20for.20f32.60.3F.html#270256104">(Feb 01 2022 at 17:57)</a>:</h4>
<p>I don't know if we could do all those optimizations just as well if we translated to <code>enum bool { false, true }</code>.</p>



<a name="270259777"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Can%20we%20commit%20to%20%60impl%20%21Ord%20for%20f32%60%3F/near/270259777" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jane Lusby [she/her] <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Can.20we.20commit.20to.20.60impl.20!Ord.20for.20f32.60.3F.html#270259777">(Feb 01 2022 at 18:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="256342">bstrie</span> <a href="#narrow/stream/219381-t-libs/topic/Can.20we.20commit.20to.20.60impl.20!Ord.20for.20f32.60.3F/near/270250830">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="239881">Josh Triplett</span> <a href="#narrow/stream/219381-t-libs/topic/Can.20we.20commit.20to.20.60impl.20!Ord.20for.20f32.60.3F/near/270248899">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="256342">bstrie</span> It'd have to be a language item so that <code>if</code> and <code>while</code> similar can expect it.</p>
</blockquote>
<p>ah, but clearly we should redefine <code>if</code> and <code>while</code> in terms of <code>ops::ControlFlow</code> :P</p>
</blockquote>
<p>Imaging control flow aware loop and exhaustive patterns</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">ControlFlow</span>::<span class="n">Break</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">loop</span><span class="w"> </span><span class="kr">try</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// ... };</span>
</code></pre></div>



<a name="270268596"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Can%20we%20commit%20to%20%60impl%20%21Ord%20for%20f32%60%3F/near/270268596" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jacob Lifshay <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Can.20we.20commit.20to.20.60impl.20!Ord.20for.20f32.60.3F.html#270268596">(Feb 01 2022 at 19:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="239881">Josh Triplett</span> <a href="#narrow/stream/219381-t-libs/topic/Can.20we.20commit.20to.20.60impl.20!Ord.20for.20f32.60.3F/near/270256067">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="257758">Connor Horman</span> <a href="#narrow/stream/219381-t-libs/topic/Can.20we.20commit.20to.20.60impl.20!Ord.20for.20f32.60.3F/near/270250313">said</a>:</p>
<blockquote>
<p>I doubt it. Aren't C-like enums as-performant as the underlying integer type?</p>
</blockquote>
<p>Integer type, yes. But I'm not sure if all the optimizations the compiler does with <code>bool</code> are true for integers. The compiler sometimes generates code using an architecture's condition codes for bool control flow, rather than (for instance) having to compare the bool to 1 or 0.</p>
</blockquote>
<p>afaict llvm is only ever told that you have an 8-bit integer, not that that 8-bit integer is a <code>bool</code> (except debug info). llvm has to handle C code which often uses an integer or <code>enum</code> instead of <code>bool</code>, so it should be pretty optimal.</p>



<a name="270270736"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Can%20we%20commit%20to%20%60impl%20%21Ord%20for%20f32%60%3F/near/270270736" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Can.20we.20commit.20to.20.60impl.20!Ord.20for.20f32.60.3F.html#270270736">(Feb 01 2022 at 19:28)</a>:</h4>
<p>llvm gets an i1, not i8</p>



<a name="270274006"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Can%20we%20commit%20to%20%60impl%20%21Ord%20for%20f32%60%3F/near/270274006" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jacob Lifshay <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Can.20we.20commit.20to.20.60impl.20!Ord.20for.20f32.60.3F.html#270274006">(Feb 01 2022 at 19:49)</a>:</h4>
<p>hmm, from what i can see, llvm treats <code>bool</code> and an enum identically here,even merging them into the same llvm ir function:<br>
<a href="https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2021&amp;gist=9de79677464a46a4883ff788ec4d51f3">https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2021&amp;gist=9de79677464a46a4883ff788ec4d51f3</a></p>



<a name="270701006"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Can%20we%20commit%20to%20%60impl%20%21Ord%20for%20f32%60%3F/near/270701006" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mara <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Can.20we.20commit.20to.20.60impl.20!Ord.20for.20f32.60.3F.html#270701006">(Feb 04 2022 at 11:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="411291">Taylor Yu [they/she]</span> <a href="#narrow/stream/219381-t-libs/topic/Can.20we.20commit.20to.20.60impl.20!Ord.20for.20f32.60.3F/near/270042400">said</a>:</p>
<blockquote>
<p>subnormal numbers and infinities can also represent exceptional conditions, depending on application, right? so you might need a family of "error" types for a float type</p>
</blockquote>
<p>nah, not really. not much more than that <code>0.0</code> or negative numbers might be exceptional for certain calculations.</p>



<a name="270851780"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Can%20we%20commit%20to%20%60impl%20%21Ord%20for%20f32%60%3F/near/270851780" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Can.20we.20commit.20to.20.60impl.20!Ord.20for.20f32.60.3F.html#270851780">(Feb 05 2022 at 22:05)</a>:</h4>
<p>Oh yes.<br>
Yeah, from the IEEE754 perspective, any value <code>-inf..=+inf</code> is <strong>a well-defined result</strong>.<br>
Now, the standard talks about how e.g. division by zero signals the "divideByZero" exception, even though it has a well-defined result (one of the infinities). But that's because it means that observing the exception state should be possible, not that it is mandatory to e.g. signal a hardware interrupt and "trap" the calculation. The intent was to allow it to be something a debugger could notice.</p>
<p>This is mostly: undersupported in hardware, unsupported in most PLs and compiler backends.</p>



<a name="271718332"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Can%20we%20commit%20to%20%60impl%20%21Ord%20for%20f32%60%3F/near/271718332" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ben Kimock (Saethlin) <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Can.20we.20commit.20to.20.60impl.20!Ord.20for.20f32.60.3F.html#271718332">(Feb 13 2022 at 00:40)</a>:</h4>
<p>I once worked on an F77 codebase which at the end of the program would print which floating-point exceptions that had occurred during execution. I think that's similar but not the same as what you're talking about? In any case, it was helpful.</p>



<a name="272342356"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/219381-t-libs/topic/Can%20we%20commit%20to%20%60impl%20%21Ord%20for%20f32%60%3F/near/272342356" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nagisa <a href="https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/Can.20we.20commit.20to.20.60impl.20!Ord.20for.20f32.60.3F.html#272342356">(Feb 18 2022 at 00:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="229517">Jacob Lifshay</span> <a href="#narrow/stream/219381-t-libs/topic/Can.20we.20commit.20to.20.60impl.20!Ord.20for.20f32.60.3F/near/270274006">said</a>:</p>
<blockquote>
<p>hmm, from what i can see, llvm treats <code>bool</code> and an enum identically here,even merging them into the same llvm ir function:<br>
<a href="https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2021&amp;gist=9de79677464a46a4883ff788ec4d51f3">https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2021&amp;gist=9de79677464a46a4883ff788ec4d51f3</a></p>
</blockquote>
<p>It is dependent on location, yes. For ABI purposes <code>bool</code> is an <code>i8</code>, for SSA purposes it is usually a <code>i1</code>. For what it is worth the enum in question will (I <em>believe</em>) eventually become the same due to how some LLVM pass reduces bit-width to account for valid value range.</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>