<html>
<head><meta charset="utf-8"><title>TIL that token streams are magic · t-compiler/rust-analyzer · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/185405-t-compiler/rust-analyzer/index.html">t-compiler/rust-analyzer</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/185405-t-compiler/rust-analyzer/topic/TIL.20that.20token.20streams.20are.20magic.html">TIL that token streams are magic</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="255965211"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/185405-t-compiler/rust-analyzer/topic/TIL%20that%20token%20streams%20are%20magic/near/255965211" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> matklad <a href="https://zulip-archive.rust-lang.org/stream/185405-t-compiler/rust-analyzer/topic/TIL.20that.20token.20streams.20are.20magic.html#255965211">(Oct 03 2021 at 17:14)</a>:</h4>
<p>identiy proc macro:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">proc_macro</span>::<span class="o">*</span><span class="p">;</span><span class="w"></span>

<span class="cp">#[proc_macro]</span><span class="w"></span>
<span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">identity</span><span class="p">(</span><span class="n">ts</span>: <span class="nc">TokenStream</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">TokenStream</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">eprintln!</span><span class="p">(</span><span class="s">"in  = {:#?}"</span><span class="p">,</span><span class="w"> </span><span class="n">ts</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ts_clone</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clone_stream</span><span class="p">(</span><span class="n">ts</span><span class="p">.</span><span class="n">clone</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="fm">eprintln!</span><span class="p">(</span><span class="s">"out = {:#?}"</span><span class="p">,</span><span class="w"> </span><span class="n">ts_clone</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">clone</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">clone</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">ts_clone</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">ts</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">clone_stream</span><span class="p">(</span><span class="n">ts</span>: <span class="nc">TokenStream</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">TokenStream</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ts</span><span class="p">.</span><span class="n">into_iter</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="n">clone_tree</span><span class="p">).</span><span class="n">collect</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">clone_tree</span><span class="p">(</span><span class="n">t</span>: <span class="nc">TokenTree</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">TokenTree</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">TokenTree</span>::<span class="n">Group</span><span class="p">(</span><span class="n">orig</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Group</span>::<span class="n">new</span><span class="p">(</span><span class="n">orig</span><span class="p">.</span><span class="n">delimiter</span><span class="p">(),</span><span class="w"> </span><span class="n">clone_stream</span><span class="p">(</span><span class="n">orig</span><span class="p">.</span><span class="n">stream</span><span class="p">()));</span><span class="w"></span>
<span class="w">            </span><span class="n">new</span><span class="p">.</span><span class="n">set_span</span><span class="p">(</span><span class="n">orig</span><span class="p">.</span><span class="n">span</span><span class="p">());</span><span class="w"></span>
<span class="w">            </span><span class="n">TokenTree</span>::<span class="n">Group</span><span class="p">(</span><span class="n">new</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">TokenTree</span>::<span class="n">Ident</span><span class="p">(</span><span class="n">orig</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">TokenTree</span>::<span class="n">Ident</span><span class="p">(</span><span class="n">Ident</span>::<span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">orig</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span><span class="w"> </span><span class="n">orig</span><span class="p">.</span><span class="n">span</span><span class="p">())),</span><span class="w"></span>
<span class="w">        </span><span class="n">TokenTree</span>::<span class="n">Punct</span><span class="p">(</span><span class="n">orig</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Punct</span>::<span class="n">new</span><span class="p">(</span><span class="n">orig</span><span class="p">.</span><span class="n">as_char</span><span class="p">(),</span><span class="w"> </span><span class="n">orig</span><span class="p">.</span><span class="n">spacing</span><span class="p">());</span><span class="w"></span>
<span class="w">            </span><span class="n">new</span><span class="p">.</span><span class="n">set_span</span><span class="p">(</span><span class="n">orig</span><span class="p">.</span><span class="n">span</span><span class="p">());</span><span class="w"></span>
<span class="w">            </span><span class="n">TokenTree</span>::<span class="n">Punct</span><span class="p">(</span><span class="n">new</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">TokenTree</span>::<span class="n">Literal</span><span class="p">(</span><span class="n">_orig</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">unimplemented!</span><span class="p">(),</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>usage: </p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="cp">#![allow(unused)]</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">m</span>::<span class="n">identity</span><span class="p">;</span><span class="w"></span>


<span class="fm">macro_rules!</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="cp">$e</span>:<span class="nc">expr</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span>: <span class="nc">identity</span><span class="o">!</span><span class="p">(</span><span class="cp">$e</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">None</span><span class="p">.</span><span class="n">unwrap</span><span class="p">();</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>


<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">m</span><span class="o">!</span><span class="p">(</span><span class="nb">String</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>



<a name="255965238"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/185405-t-compiler/rust-analyzer/topic/TIL%20that%20token%20streams%20are%20magic/near/255965238" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> matklad <a href="https://zulip-archive.rust-lang.org/stream/185405-t-compiler/rust-analyzer/topic/TIL.20that.20token.20streams.20are.20magic.html#255965238">(Oct 03 2021 at 17:15)</a>:</h4>
<p>The usage will compile only when we do clone the token stream</p>



<a name="255966663"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/185405-t-compiler/rust-analyzer/topic/TIL%20that%20token%20streams%20are%20magic/near/255966663" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> matklad <a href="https://zulip-archive.rust-lang.org/stream/185405-t-compiler/rust-analyzer/topic/TIL.20that.20token.20streams.20are.20magic.html#255966663">(Oct 03 2021 at 17:37)</a>:</h4>
<p>Ok, this is <strong>suuper</strong> weird</p>



<a name="255966664"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/185405-t-compiler/rust-analyzer/topic/TIL%20that%20token%20streams%20are%20magic/near/255966664" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> matklad <a href="https://zulip-archive.rust-lang.org/stream/185405-t-compiler/rust-analyzer/topic/TIL.20that.20token.20streams.20are.20magic.html#255966664">(Oct 03 2021 at 17:37)</a>:</h4>
<p><a href="/user_uploads/4715/gvoc0f60PF5VN-odwO_jrLCz/image.png">image.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/4715/gvoc0f60PF5VN-odwO_jrLCz/image.png" title="image.png"><img src="/user_uploads/4715/gvoc0f60PF5VN-odwO_jrLCz/image.png"></a></div>



<a name="255967736"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/185405-t-compiler/rust-analyzer/topic/TIL%20that%20token%20streams%20are%20magic/near/255967736" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Giacomo Stevanato <a href="https://zulip-archive.rust-lang.org/stream/185405-t-compiler/rust-analyzer/topic/TIL.20that.20token.20streams.20are.20magic.html#255967736">(Oct 03 2021 at 17:55)</a>:</h4>
<p>I think it's more like macro_rules! magic</p>



<a name="255967895"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/185405-t-compiler/rust-analyzer/topic/TIL%20that%20token%20streams%20are%20magic/near/255967895" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> matklad <a href="https://zulip-archive.rust-lang.org/stream/185405-t-compiler/rust-analyzer/topic/TIL.20that.20token.20streams.20are.20magic.html#255967895">(Oct 03 2021 at 17:57)</a>:</h4>
<p>Yeah, that's known. What was new to me is that the ts passed into proc_macro carries some of that magic, and those magical bits can't be duplicated</p>



<a name="255968114"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/185405-t-compiler/rust-analyzer/topic/TIL%20that%20token%20streams%20are%20magic/near/255968114" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> matklad <a href="https://zulip-archive.rust-lang.org/stream/185405-t-compiler/rust-analyzer/topic/TIL.20that.20token.20streams.20are.20magic.html#255968114">(Oct 03 2021 at 18:00)</a>:</h4>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="c1">// Procedural Macro</span>
<span class="k">use</span><span class="w"> </span><span class="n">proc_macro</span>::<span class="o">*</span><span class="p">;</span><span class="w"></span>

<span class="cp">#[proc_macro]</span><span class="w"></span>
<span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">identity</span><span class="p">(</span><span class="n">ts</span>: <span class="nc">TokenStream</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">TokenStream</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ts_clone</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clone_stream</span><span class="p">(</span><span class="n">ts</span><span class="p">.</span><span class="n">clone</span><span class="p">());</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">clone</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w"> </span><span class="c1">// change me</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">clone</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">ts_clone</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">ts</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">clone_stream</span><span class="p">(</span><span class="n">ts</span>: <span class="nc">TokenStream</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">TokenStream</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ts</span><span class="p">.</span><span class="n">into_iter</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="n">clone_tree</span><span class="p">).</span><span class="n">collect</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">clone_tree</span><span class="p">(</span><span class="n">t</span>: <span class="nc">TokenTree</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">TokenTree</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">TokenTree</span>::<span class="n">Group</span><span class="p">(</span><span class="n">orig</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Group</span>::<span class="n">new</span><span class="p">(</span><span class="n">orig</span><span class="p">.</span><span class="n">delimiter</span><span class="p">(),</span><span class="w"> </span><span class="n">clone_stream</span><span class="p">(</span><span class="n">orig</span><span class="p">.</span><span class="n">stream</span><span class="p">()));</span><span class="w"></span>
<span class="w">            </span><span class="n">new</span><span class="p">.</span><span class="n">set_span</span><span class="p">(</span><span class="n">orig</span><span class="p">.</span><span class="n">span</span><span class="p">());</span><span class="w"></span>
<span class="w">            </span><span class="n">TokenTree</span>::<span class="n">Group</span><span class="p">(</span><span class="n">new</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">TokenTree</span>::<span class="n">Ident</span><span class="p">(</span><span class="n">orig</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">TokenTree</span>::<span class="n">Ident</span><span class="p">(</span><span class="n">Ident</span>::<span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">orig</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span><span class="w"> </span><span class="n">orig</span><span class="p">.</span><span class="n">span</span><span class="p">())),</span><span class="w"></span>
<span class="w">        </span><span class="n">TokenTree</span>::<span class="n">Punct</span><span class="p">(</span><span class="n">orig</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Punct</span>::<span class="n">new</span><span class="p">(</span><span class="n">orig</span><span class="p">.</span><span class="n">as_char</span><span class="p">(),</span><span class="w"> </span><span class="n">orig</span><span class="p">.</span><span class="n">spacing</span><span class="p">());</span><span class="w"></span>
<span class="w">            </span><span class="n">new</span><span class="p">.</span><span class="n">set_span</span><span class="p">(</span><span class="n">orig</span><span class="p">.</span><span class="n">span</span><span class="p">());</span><span class="w"></span>
<span class="w">            </span><span class="n">TokenTree</span>::<span class="n">Punct</span><span class="p">(</span><span class="n">new</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">TokenTree</span>::<span class="n">Literal</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">t</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Main</span>
<span class="fm">macro_rules!</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="cp">$e</span>:<span class="nc">expr</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">m</span>::<span class="n">identity</span><span class="o">!</span><span class="p">(</span><span class="cp">$e</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="o">!</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="fm">eprintln!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>



<a name="255968301"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/185405-t-compiler/rust-analyzer/topic/TIL%20that%20token%20streams%20are%20magic/near/255968301" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> matklad <a href="https://zulip-archive.rust-lang.org/stream/185405-t-compiler/rust-analyzer/topic/TIL.20that.20token.20streams.20are.20magic.html#255968301">(Oct 03 2021 at 18:03)</a>:</h4>
<p>Minimized example</p>



<a name="256338799"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/185405-t-compiler/rust-analyzer/topic/TIL%20that%20token%20streams%20are%20magic/near/256338799" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/185405-t-compiler/rust-analyzer/topic/TIL.20that.20token.20streams.20are.20magic.html#256338799">(Oct 06 2021 at 00:11)</a>:</h4>
<p>This looks a bit like the <a href="https://github.com/danielhenrymantilla/rust-defile"><code>defile</code></a> proc-macro that <span class="user-mention" data-user-id="158561">@Daniel Henry-Mantilla</span> wrote, maybe they know what is going on here</p>



<a name="256338972"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/185405-t-compiler/rust-analyzer/topic/TIL%20that%20token%20streams%20are%20magic/near/256338972" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/185405-t-compiler/rust-analyzer/topic/TIL.20that.20token.20streams.20are.20magic.html#256338972">(Oct 06 2021 at 00:13)</a>:</h4>
<p>Ah, it's mentioned at the bottom:</p>
<blockquote>
<p><strong>Caveats</strong><br>
Currently (1.45.0), there are several bugs regarding the interaction between <code>macro_rules!</code> macros and procedural macros, that may lead to <code>defile!</code> and any other helper procedural macro to split groups that are not <code>@</code>-prefixed.</p>
<p>Hopefully those bugs are solved, making the actual implementation of <code>defile!</code> meaningful.</p>
</blockquote>



<a name="256398884"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/185405-t-compiler/rust-analyzer/topic/TIL%20that%20token%20streams%20are%20magic/near/256398884" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/185405-t-compiler/rust-analyzer/topic/TIL.20that.20token.20streams.20are.20magic.html#256398884">(Oct 06 2021 at 12:02)</a>:</h4>
<p>Thanks for the ping, <span class="user-mention" data-user-id="271719">@Mario Carneiro</span>.  Matklad is right, when they say:</p>
<p><span class="user-mention silent" data-user-id="133169">matklad</span> <a href="#narrow/stream/185405-t-compiler.2Frust-analyzer/topic/TIL.20that.20token.20streams.20are.20magic/near/255967895">said</a>:</p>
<blockquote>
<p>the ts passed into proc_macro carries some of that magic, and those magical bits can't be duplicated</p>
</blockquote>
<p>This behavior is indeed the one responsible for that "caveats" section you mentioned, and may even be the reason behing the workaround done in <code>macro_rules_attribute</code> (<a href="https://github.com/danielhenrymantilla/macro_rules_attribute-rs/blob/b673e96025485bd8120a44b6aeb7e738f1affe3f/src/proc_macro/mod.rs#L110-L112">https://github.com/danielhenrymantilla/macro_rules_attribute-rs/blob/b673e96025485bd8120a44b6aeb7e738f1affe3f/src/proc_macro/mod.rs#L110-L112</a>) just working.</p>
<p>Now, I've been experimenting a bit more given this thread, with the following stand-alone Playground:</p>
<ul>
<li><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=1b4169c1fa8d9dddf18153d0cbaf9b03">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=1b4169c1fa8d9dddf18153d0cbaf9b03</a></li>
</ul>
<p>My main observation is that the <code>TokenTree</code>s yielded by <code>.into_iter()</code> do indeed no longer carry all the information that the original <code>TokenTree</code>s carried:</p>
<ul>
<li>
<p><code>input</code> represents a stream of tokens which, <em>at any depth</em> (feel free to add parenthesis in <code>entrypoint!</code> and things like that when experimenting), feature <code>None</code>-delimited <code>Group</code>s imbued with the appropriate grammar-tagging semantics.</p>
</li>
<li>
<p>But the <code>TokenTree</code>s yielded by <code>input</code> through iteration, which represent a <em>seemingly</em> equivalent stream of tokens (they are <em>seemingly</em> still <code>Group</code>-ped as originally: if such stream is then <em>directly</em> fed to further proc-macros (through macro invocations I mean), then nothing seems to have changed), have actually changed!</p>
</li>
<li>
<p>Indeed, if such stream is to be parsed by either non-macro rust code, or by a <code>macro_rules!</code> macro, then those <code>Group</code>-layers seem to vanish.</p>
</li>
</ul>
<p>I know that the compiler tries to be quite smart with span manipulation and caching, and all while trying to be retro-compatible with the first semantics exposed to client proc-macro code: so there are some hacks there to preserve such retro-compat while enabling some "cached tokenstream" optimizations, and to try and feature as much span correctness as possible.</p>
<p><span class="user-mention" data-user-id="125294">@Aaron Hill</span> has been working a lot with such tweaks, so they definitely are the ones able to explain why the current proc-macro implementation behaves like it does.</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>