<html>
<head><meta charset="utf-8"><title>Example of odd composing of Send · wg-async-foundations · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async-foundations/index.html">wg-async-foundations</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async-foundations/topic/Example.20of.20odd.20composing.20of.20Send.html">Example of odd composing of Send</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="249676640"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async-foundations/topic/Example%20of%20odd%20composing%20of%20Send/near/249676640" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async-foundations/topic/Example.20of.20odd.20composing.20of.20Send.html#249676640">(Aug 17 2021 at 04:04)</a>:</h4>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=d68f48effd9419241e5323bb3cf86148">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=d68f48effd9419241e5323bb3cf86148</a></p>



<a name="249676661"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async-foundations/topic/Example%20of%20odd%20composing%20of%20Send/near/249676661" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async-foundations/topic/Example.20of.20odd.20composing.20of.20Send.html#249676661">(Aug 17 2021 at 04:05)</a>:</h4>
<p>This example doesn't type check because the two async blocks are !Send, therefore foo is not !Send, which is required by spawn</p>



<a name="249676716"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async-foundations/topic/Example%20of%20odd%20composing%20of%20Send/near/249676716" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async-foundations/topic/Example.20of.20odd.20composing.20of.20Send.html#249676716">(Aug 17 2021 at 04:06)</a>:</h4>
<p>One could fix this by using a Mutex or something, but it seems vaguely reasonable to fix this without needing more atomics, etc, by some kind of scoping composability of futures</p>



<a name="249676791"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async-foundations/topic/Example%20of%20odd%20composing%20of%20Send/near/249676791" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async-foundations/topic/Example.20of.20odd.20composing.20of.20Send.html#249676791">(Aug 17 2021 at 04:08)</a>:</h4>
<p>I.e., one could imagine that a future which owns the Cell and evaluates to join, should be Send, even though the join future is not Send because internal to that future, the sub-futures will be evaluated on the same thread and the reference to the Cell does not exist outside the future</p>



<a name="249676857"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async-foundations/topic/Example%20of%20odd%20composing%20of%20Send/near/249676857" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async-foundations/topic/Example.20of.20odd.20composing.20of.20Send.html#249676857">(Aug 17 2021 at 04:10)</a>:</h4>
<p>Is it possible to write something like that today (using async, rather than writing the futures manually)? Or is this on the radar for async work? (It feels a bit similar to the scopes deliverable, but I don't think it quite addresses it)</p>



<a name="249788825"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async-foundations/topic/Example%20of%20odd%20composing%20of%20Send/near/249788825" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async-foundations/topic/Example.20of.20odd.20composing.20of.20Send.html#249788825">(Aug 17 2021 at 22:48)</a>:</h4>
<p>Niko and I were actually talking about this a bit yesterday.. ideally we can separate the original call from the "polling state" somehow</p>



<a name="249888026"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async-foundations/topic/Example%20of%20odd%20composing%20of%20Send/near/249888026" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Matthias247 <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async-foundations/topic/Example.20of.20odd.20composing.20of.20Send.html#249888026">(Aug 18 2021 at 17:59)</a>:</h4>
<blockquote>
<p>I.e., one could imagine that a future which owns the Cell and evaluates to join, should be Send, even though the join future is not Send because internal to that future, the sub-futures will be evaluated on the same thread and the reference to the Cell does not exist outside the future</p>
</blockquote>
<p>That would need to be a guarantee that is given by the executor. And executors which are multi-threaded don't provide it. They might move the task between each <code>.poll()</code> operation.</p>



<a name="249888304"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async-foundations/topic/Example%20of%20odd%20composing%20of%20Send/near/249888304" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Matthias247 <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async-foundations/topic/Example.20of.20odd.20composing.20of.20Send.html#249888304">(Aug 18 2021 at 18:01)</a>:</h4>
<p>If you have an executor which provides guarantees of not moving tasks between threads (like a single-threaded one), it can take <code>!Send</code> <code>Future</code>s  and everything is fine. tokio <code>LocalSet</code> also does something like this.</p>



<a name="249888536"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async-foundations/topic/Example%20of%20odd%20composing%20of%20Send/near/249888536" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Matthias247 <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async-foundations/topic/Example.20of.20odd.20composing.20of.20Send.html#249888536">(Aug 18 2021 at 18:02)</a>:</h4>
<p>What I like to see for a while is that once we have structured concurrency you can create a sub-scope which has stronger executor guarantees, like tying everything onto a single thread. And from there on you can do <code>.spawn_local(task)</code> to start non-synchronized tasks</p>



<a name="249889605"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async-foundations/topic/Example%20of%20odd%20composing%20of%20Send/near/249889605" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Matthias247 <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async-foundations/topic/Example.20of.20odd.20composing.20of.20Send.html#249889605">(Aug 18 2021 at 18:09)</a>:</h4>
<p>Although it seems like I might just have gotten half of the question, and the other half is why it requires <code>Sync</code> here and not just <code>Send</code>. I'm not sure on this.</p>



<a name="249902481"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async-foundations/topic/Example%20of%20odd%20composing%20of%20Send/near/249902481" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Alice Ryhl <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async-foundations/topic/Example.20of.20odd.20composing.20of.20Send.html#249902481">(Aug 18 2021 at 19:47)</a>:</h4>
<p>Right, this has to do with Rust not having a concept of "not <code>Send</code> unless you move every instance simultaneously", which applies to both <code>Rc</code> and <code>&amp;T</code> for non-Sync <code>T</code>.</p>



<a name="249914769"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async-foundations/topic/Example%20of%20odd%20composing%20of%20Send/near/249914769" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async-foundations/topic/Example.20of.20odd.20composing.20of.20Send.html#249914769">(Aug 18 2021 at 21:33)</a>:</h4>
<p>^ that's interesting. to me it feels conceptually similar to self-borrows</p>



<a name="249914937"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async-foundations/topic/Example%20of%20odd%20composing%20of%20Send/near/249914937" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async-foundations/topic/Example.20of.20odd.20composing.20of.20Send.html#249914937">(Aug 18 2021 at 21:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="204219">Matthias247</span> <a href="#narrow/stream/187312-wg-async-foundations/topic/Example.20of.20odd.20composing.20of.20Send/near/249888026">said</a>:</p>
<blockquote>
<blockquote>
<p>I.e., one could imagine that a future which owns the Cell and evaluates to join, should be Send, even though the join future is not Send because internal to that future, the sub-futures will be evaluated on the same thread and the reference to the Cell does not exist outside the future</p>
</blockquote>
<p>That would need to be a guarantee that is given by the executor. And executors which are multi-threaded don't provide it. They might move the task between each <code>.poll()</code> operation.</p>
</blockquote>
<p>You could have an executor which assigns futures to a potentially different thread on spawn, but does not move them between polls. That seems like a common enough use case that's worth considering</p>



<a name="249946376"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async-foundations/topic/Example%20of%20odd%20composing%20of%20Send/near/249946376" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Matthias247 <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async-foundations/topic/Example.20of.20odd.20composing.20of.20Send.html#249946376">(Aug 19 2021 at 06:26)</a>:</h4>
<p>You could. But to make use of that you would have to change the spawn signature, since the <code>Future</code> type is the same between having been polled or not being polled yet. Something along: <code>spawn&lt;Func: Send + FnOnce() -&gt; Fut, Fut: Future&gt;(f:  Func)</code>. </p>
<p>Not sure if you would want that, or just start/enter a sub-scope first which is ok with <code>!Send</code> and from there on spawn the tasks.</p>



<a name="250241417"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async-foundations/topic/Example%20of%20odd%20composing%20of%20Send/near/250241417" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async-foundations/topic/Example.20of.20odd.20composing.20of.20Send.html#250241417">(Aug 21 2021 at 22:52)</a>:</h4>
<p>I get that the executor can move the future between threads between polls and that's why the futures need to be Send, I'm wondering if its possible to deduce somehow that the Join future should be Send even though the 'child' futures are !Send, essentially because its OK to move the 'whole thing' but not 'components of the thing'</p>



<a name="250256755"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async-foundations/topic/Example%20of%20odd%20composing%20of%20Send/near/250256755" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Kestrer <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async-foundations/topic/Example.20of.20odd.20composing.20of.20Send.html#250256755">(Aug 22 2021 at 05:43)</a>:</h4>
<p>Theoretically we could have an API like this</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="k">fn</span> <span class="nf">with_unsync_ref</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Send</span><span class="p">,</span><span class="w"> </span><span class="n">O</span><span class="o">&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">value</span>: <span class="nc">T</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">f</span>: <span class="nc">impl</span><span class="w"> </span><span class="k">for</span><span class="o">&lt;'</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">S</span>: <span class="o">?</span><span class="nb">Send</span><span class="o">&gt;</span><span class="w"> </span><span class="n">AsyncFnOnce</span><span class="o">&lt;</span><span class="p">(</span><span class="n">Ref</span><span class="o">&lt;'</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">S</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">,),</span><span class="w"> </span><span class="n">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">O</span><span class="p">,</span><span class="w"> </span><span class="n">Future</span>: <span class="nc">S</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">O</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">..</span><span class="p">.</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>The HRTB would require that the <code>AsyncFnOnce</code> doesn't use any <code>!Send</code> types inside it other than the <code>Ref</code>, so the future returned by <code>with_unsync_ref</code> would always be <code>Send</code>.</p>



<a name="250534082"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async-foundations/topic/Example%20of%20odd%20composing%20of%20Send/near/250534082" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nikomatsakis <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async-foundations/topic/Example.20of.20odd.20composing.20of.20Send.html#250534082">(Aug 24 2021 at 19:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="256841">Nick Cameron</span> <a href="#narrow/stream/187312-wg-async-foundations/topic/Example.20of.20odd.20composing.20of.20Send/near/250241417">said</a>:</p>
<blockquote>
<p>I get that the executor can move the future between threads between polls and that's why the futures need to be Send, I'm wondering if its possible to deduce somehow that the Join future should be Send even though the 'child' futures are !Send, essentially because its OK to move the 'whole thing' but not 'components of the thing'</p>
</blockquote>
<p>In what scenario would that be ok?</p>



<a name="250545073"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async-foundations/topic/Example%20of%20odd%20composing%20of%20Send/near/250545073" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Kestrer <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async-foundations/topic/Example.20of.20odd.20composing.20of.20Send.html#250545073">(Aug 24 2021 at 20:37)</a>:</h4>
<p>When you have a future containing a Cell and a reference to the Cell. You can move the whole thing, but can't separate the owned value &amp; reference because that could cause data races.</p>



<a name="250553801"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async-foundations/topic/Example%20of%20odd%20composing%20of%20Send/near/250553801" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async-foundations/topic/Example.20of.20odd.20composing.20of.20Send.html#250553801">(Aug 24 2021 at 21:47)</a>:</h4>
<p><span class="user-mention" data-user-id="116009">@nikomatsakis</span> see the playground at the start of the thread. I haven't thought about generalisations</p>



<a name="251772474"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async-foundations/topic/Example%20of%20odd%20composing%20of%20Send/near/251772474" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async-foundations/topic/Example.20of.20odd.20composing.20of.20Send.html#251772474">(Sep 02 2021 at 19:28)</a>:</h4>
<p>Here's a strawman called <a href="https://hackmd.io/m5ooA3drSJWjHQYJlJ5KxQ?view">Shards</a> that I think could work for expressing this in the language. I'm not proposing actually adding this, so do with it what you will (:</p>



<a name="251780048"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async-foundations/topic/Example%20of%20odd%20composing%20of%20Send/near/251780048" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eholk <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async-foundations/topic/Example.20of.20odd.20composing.20of.20Send.html#251780048">(Sep 02 2021 at 20:19)</a>:</h4>
<blockquote>
<ul>
<li>This is ugly and not worth complicating the language!<ul>
<li>I tend to agree. It could serve as a starting point for a better idea or a more general “capabilities” mechanism, however.</li>
</ul>
</li>
</ul>
</blockquote>
<p>I also tend to agree, but I'm intrigued by the idea of a more general capabilities system. Have you thought any about what that would look like, <span class="user-mention" data-user-id="116883">@tmandry</span>?</p>



<a name="251780232"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async-foundations/topic/Example%20of%20odd%20composing%20of%20Send/near/251780232" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eholk <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async-foundations/topic/Example.20of.20odd.20composing.20of.20Send.html#251780232">(Sep 02 2021 at 20:20)</a>:</h4>
<p>I actually kind of like the idea, I just think it's weird to have something so similar to lifetimes alongside the lifetimes system</p>



<a name="251780389"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async-foundations/topic/Example%20of%20odd%20composing%20of%20Send/near/251780389" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async-foundations/topic/Example.20of.20odd.20composing.20of.20Send.html#251780389">(Sep 02 2021 at 20:21)</a>:</h4>
<p>not really. <span class="user-mention" data-user-id="116009">@nikomatsakis</span> mentioned it to me in passing</p>



<a name="251780602"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async-foundations/topic/Example%20of%20odd%20composing%20of%20Send/near/251780602" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async-foundations/topic/Example.20of.20odd.20composing.20of.20Send.html#251780602">(Sep 02 2021 at 20:23)</a>:</h4>
<p>I assume there is prior art in type systems research, I’m just not familiar with it</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>