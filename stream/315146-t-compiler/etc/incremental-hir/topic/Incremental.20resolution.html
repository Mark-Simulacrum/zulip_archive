<html>
<head><meta charset="utf-8"><title>Incremental resolution · t-compiler/etc/incremental-hir · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/315146-t-compiler/etc/incremental-hir/index.html">t-compiler/etc/incremental-hir</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/315146-t-compiler/etc/incremental-hir/topic/Incremental.20resolution.html">Incremental resolution</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="275871058"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/315146-t-compiler/etc/incremental-hir/topic/Incremental%20resolution/near/275871058" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cjgillot <a href="https://zulip-archive.rust-lang.org/stream/315146-t-compiler/etc/incremental-hir/topic/Incremental.20resolution.html#275871058">(Mar 18 2022 at 22:39)</a>:</h4>
<p>Once we get incremental HIR, we will have to progress towards incremental name resolution.  A first step is probably to split up resolution.  There are two axes: by expansion vs by definition.<br>
In the current state, splitting up late resolution by definition would probably easiest, and give time to design an incremental resolver.  The question would be: can we compose a speciative "early" resolution in TypeNS and ValueNS, corrected by a late resolution which has no access to <code>Resolver</code>?<br>
What would you recommend <span class="user-mention" data-user-id="123856">@Vadim Petrochenkov</span>?</p>



<a name="275896540"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/315146-t-compiler/etc/incremental-hir/topic/Incremental%20resolution/near/275896540" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Vadim Petrochenkov <a href="https://zulip-archive.rust-lang.org/stream/315146-t-compiler/etc/incremental-hir/topic/Incremental.20resolution.html#275896540">(Mar 19 2022 at 07:53)</a>:</h4>
<p>I'm not sure what do you mean.</p>
<ul>
<li>What is "splitting by definition"?</li>
<li>Which part of the work do you plan to do without accessing <code>Resolver</code>? To resolve a path in <code>TypeNS</code> you need a significant part of data from resolver, especially if the current diagnostics are preserved.</li>
</ul>



<a name="275899765"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/315146-t-compiler/etc/incremental-hir/topic/Incremental%20resolution/near/275899765" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cjgillot <a href="https://zulip-archive.rust-lang.org/stream/315146-t-compiler/etc/incremental-hir/topic/Incremental.20resolution.html#275899765">(Mar 19 2022 at 09:14)</a>:</h4>
<p>Right now, late resolution walks the whole crate in one go.  The idea would be to late-resolve each item independently.  However, the <code>Resolver</code> is not compatible with the incremental engine, because it has mutable state everywhere.  One way out would be to separate the part that requires a proper <code>Resolver</code> (for instance paths in <code>TypeNS</code>) from a part which does not (for instance locals).</p>



<a name="275906203"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/315146-t-compiler/etc/incremental-hir/topic/Incremental%20resolution/near/275906203" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Vadim Petrochenkov <a href="https://zulip-archive.rust-lang.org/stream/315146-t-compiler/etc/incremental-hir/topic/Incremental.20resolution.html#275906203">(Mar 19 2022 at 11:47)</a>:</h4>
<blockquote>
<p>for instance locals</p>
</blockquote>
<p>If we have a single-segment path <code>x</code> that may resolve to a local variable, we still need to go through blocks from inside to outside to find the closest definition of <code>x</code> (whether a local variable or not).<br>
So we can't just resolve <code>x</code> before the locals are available (res1, needs <code>Resolver</code>), and then resolve <code>x</code> as a local variable only (res2, no <code>Resolver</code> needed), and then fall back from res2 to res1 if necessary.<br>
Locals and non-locals either need to be walked in a single pass (needs <code>Resolver</code>), or you need to keep the resolution positions in some form to choose from res1 and res2 correctly.</p>



<a name="275906529"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/315146-t-compiler/etc/incremental-hir/topic/Incremental%20resolution/near/275906529" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Vadim Petrochenkov <a href="https://zulip-archive.rust-lang.org/stream/315146-t-compiler/etc/incremental-hir/topic/Incremental.20resolution.html#275906529">(Mar 19 2022 at 11:53)</a>:</h4>
<p>One of the most annoying things is that late and early resolutions share a lot of common logic (which is good, that allows to avoid a huge amount of duplication and possible mismatches), but that common logic will modify the resolver (populate its structures) if run early and won't modify the resolver if run late.</p>



<a name="275906709"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/315146-t-compiler/etc/incremental-hir/topic/Incremental%20resolution/near/275906709" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Vadim Petrochenkov <a href="https://zulip-archive.rust-lang.org/stream/315146-t-compiler/etc/incremental-hir/topic/Incremental.20resolution.html#275906709">(Mar 19 2022 at 11:56)</a>:</h4>
<p>I wonder which parts of the resolver are actually mutable during late resolution (modulo resolver outputs).<br>
Maybe we can try splitting <code>Resolver</code> into <code>ResolverEarly</code> and (much less mutable) <code>ResolverLate</code> and making all its methods generic on some set of functions that will modify <code>ResolverEarly</code> when run early and panic when run late (with <code>ResolverLate</code> as <code>self</code>).</p>



<a name="275907500"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/315146-t-compiler/etc/incremental-hir/topic/Incremental%20resolution/near/275907500" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> oli <a href="https://zulip-archive.rust-lang.org/stream/315146-t-compiler/etc/incremental-hir/topic/Incremental.20resolution.html#275907500">(Mar 19 2022 at 12:12)</a>:</h4>
<p>When we're talking about incremental resolution, what does that actually mean? Resolve modules without resolving inside items first? Then resolve item bodies individually?</p>



<a name="275908255"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/315146-t-compiler/etc/incremental-hir/topic/Incremental%20resolution/near/275908255" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/315146-t-compiler/etc/incremental-hir/topic/Incremental.20resolution.html#275908255">(Mar 19 2022 at 12:30)</a>:</h4>
<p>Reusing as much of the results of resolution when compiling again in incremental mode I think.</p>



<a name="275932667"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/315146-t-compiler/etc/incremental-hir/topic/Incremental%20resolution/near/275932667" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cjgillot <a href="https://zulip-archive.rust-lang.org/stream/315146-t-compiler/etc/incremental-hir/topic/Incremental.20resolution.html#275932667">(Mar 19 2022 at 22:13)</a>:</h4>
<p><span class="user-mention" data-user-id="124288">@oli</span> The end-goal is end-to-end queries, with incremental parsing and incremental macro expansion.  To get there, I chose to progress from lowering towards the front-end.  The next step is then to refactor all that happens in <code>Resolver</code> into queries.  This is a large task, and the current <code>Resolver</code> has a lot of mutable state, so is not incremental-friendly.</p>
<p>Late resolution is a large pass that walks the whole crate.  My objective is to split it into:</p>
<ul>
<li>a whole-crate pass that uses <code>Resolver</code>;</li>
<li>an item-local pass that only accesses resolver outputs, and could be made a query.</li>
</ul>
<p>Why item-local? It seems the most logical barrier, which allows to treat an impl-block as a whole (to handle stuff like <code>Self</code>), while being able to ignore what happens elsewhere.  The global influences (like types or functions) should be done by the whole-crate pass.</p>
<p>My high-level view of the resolution algorithm is a mix of early resolution (ie. the same algorithm that macro resolution uses, which accounts for modules), and of a simpler lexical resolution (ie. walking scopes to find locals).  However, both are very intertwined, and splitting them up is very difficult.</p>
<p>In your example <span class="user-mention" data-user-id="123856">@Vadim Petrochenkov</span>, my vision was:</p>
<ol>
<li>try resolving <code>x</code> using the early algorithm and a simplified lexical algorithm (don't account for locals, labels...), and stash the result;</li>
<li>try to resolve <code>x</code> using the full lexical algorithm, and chose the better resolution between the stashed one and the new one.</li>
</ol>
<p>I wonder how much of the lexical algorithm we need to keep to have step 1 working properly.  <code>use</code> statements in a function body will definitely account for something, but isn't that already handled for macro resolution?</p>



<a name="275952340"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/315146-t-compiler/etc/incremental-hir/topic/Incremental%20resolution/near/275952340" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Vadim Petrochenkov <a href="https://zulip-archive.rust-lang.org/stream/315146-t-compiler/etc/incremental-hir/topic/Incremental.20resolution.html#275952340">(Mar 20 2022 at 07:01)</a>:</h4>
<blockquote>
<p>I wonder how much of the lexical algorithm we need to keep to have step 1 working properly.</p>
</blockquote>
<p>Most of it, if we are talking about the top-level algorithm.<br>
The simplified algorithm is  "search in all places from <code>enum Scope</code>" (<code>fn visit_scopes</code>, <code>fn early_resolve_ident_in_lexical_scope</code>), and the full algorithm is "search in all places from <code>enum Scope</code> and in local variables" (<code>fn resolve_ident_in_lexical_scope</code>, currently has some bugs in corner cases).</p>



<a name="275952601"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/315146-t-compiler/etc/incremental-hir/topic/Incremental%20resolution/near/275952601" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Vadim Petrochenkov <a href="https://zulip-archive.rust-lang.org/stream/315146-t-compiler/etc/incremental-hir/topic/Incremental.20resolution.html#275952601">(Mar 20 2022 at 07:11)</a>:</h4>
<p>I'd expect performing all the late resolution in incremental way a more promising alternative than resolving just locals incrementally.<br>
If we split current <code>Resolver</code> into <code>ResolverEarly</code> and <code>ResolverLate</code> implementing a common <code>ResolverTrait</code> interface, then I'd expect <code>ResolverLate</code> to be mostly immutable, except for 1) the outputs that it builds 2) maybe some caches like external modules that are loaded lazily on demand.</p>



<a name="275952691"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/315146-t-compiler/etc/incremental-hir/topic/Incremental%20resolution/near/275952691" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Vadim Petrochenkov <a href="https://zulip-archive.rust-lang.org/stream/315146-t-compiler/etc/incremental-hir/topic/Incremental.20resolution.html#275952691">(Mar 20 2022 at 07:13)</a>:</h4>
<blockquote>
<p>maybe some caches like external modules ...</p>
</blockquote>
<p>Ah, and new crates in cstore, which are also loaded on demand, that may be more annoying.</p>



<a name="275957796"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/315146-t-compiler/etc/incremental-hir/topic/Incremental%20resolution/near/275957796" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/315146-t-compiler/etc/incremental-hir/topic/Incremental.20resolution.html#275957796">(Mar 20 2022 at 09:35)</a>:</h4>
<p>External modules are loaded as part of macro expansion I believe.</p>



<a name="275960614"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/315146-t-compiler/etc/incremental-hir/topic/Incremental%20resolution/near/275960614" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Vadim Petrochenkov <a href="https://zulip-archive.rust-lang.org/stream/315146-t-compiler/etc/incremental-hir/topic/Incremental.20resolution.html#275960614">(Mar 20 2022 at 10:46)</a>:</h4>
<p>If some path resolved during late resolution like type <code>a::b::c::Type</code> touches a module from other crate that wasn't touched before, then the module will be loaded during late resolution (see how <code>ModuleData::populate_on_access</code> is used).</p>



<a name="276737164"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/315146-t-compiler/etc/incremental-hir/topic/Incremental%20resolution/near/276737164" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cjgillot <a href="https://zulip-archive.rust-lang.org/stream/315146-t-compiler/etc/incremental-hir/topic/Incremental.20resolution.html#276737164">(Mar 26 2022 at 17:43)</a>:</h4>
<p>Ok, so I understand that migrating layer by layer will be hard.  Besides the outputs, is there a lot of mutable state in the resolver.  Is there a documentation of which is used where and for what purpose?  I mean: distinguish outputs from memorization from transitory state.</p>



<a name="276744051"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/315146-t-compiler/etc/incremental-hir/topic/Incremental%20resolution/near/276744051" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Vadim Petrochenkov <a href="https://zulip-archive.rust-lang.org/stream/315146-t-compiler/etc/incremental-hir/topic/Incremental.20resolution.html#276744051">(Mar 26 2022 at 20:24)</a>:</h4>
<blockquote>
<p>Is there a documentation of which is used where and for what purpose?</p>
</blockquote>
<p>Of course not!</p>



<a name="276744068"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/315146-t-compiler/etc/incremental-hir/topic/Incremental%20resolution/near/276744068" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Vadim Petrochenkov <a href="https://zulip-archive.rust-lang.org/stream/315146-t-compiler/etc/incremental-hir/topic/Incremental.20resolution.html#276744068">(Mar 26 2022 at 20:25)</a>:</h4>
<p>The outputs are the easiest to recognize though because they all have the same names as in <code>ResolverOutputs</code>.</p>



<a name="276751810"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/315146-t-compiler/etc/incremental-hir/topic/Incremental%20resolution/near/276751810" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cjgillot <a href="https://zulip-archive.rust-lang.org/stream/315146-t-compiler/etc/incremental-hir/topic/Incremental.20resolution.html#276751810">(Mar 26 2022 at 23:25)</a>:</h4>
<p>I feel like I need to dive right into the resolver to understand it better.  Do you have any "I'd be great if" refactoring to give me as an exercise?</p>



<a name="276752860"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/315146-t-compiler/etc/incremental-hir/topic/Incremental%20resolution/near/276752860" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Vadim Petrochenkov <a href="https://zulip-archive.rust-lang.org/stream/315146-t-compiler/etc/incremental-hir/topic/Incremental.20resolution.html#276752860">(Mar 26 2022 at 23:50)</a>:</h4>
<p>It'd be great if all the diagnostic-reporting code lived in <code>compiler\rustc_resolve\src\diagnostics.rs</code> and <code>compiler\rustc_resolve\src\late\diagnostics.rs</code>.</p>



<a name="276752940"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/315146-t-compiler/etc/incremental-hir/topic/Incremental%20resolution/near/276752940" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Vadim Petrochenkov <a href="https://zulip-archive.rust-lang.org/stream/315146-t-compiler/etc/incremental-hir/topic/Incremental.20resolution.html#276752940">(Mar 26 2022 at 23:51)</a>:</h4>
<p>I recently did a public review of the rustc_resolve code in <a href="#narrow/stream/305296-rustc-reading-club/topic/resolver.20presentation.20from.20vadim.20petrochenkov">https://rust-lang.zulipchat.com/#narrow/stream/305296-rustc-reading-club/topic/resolver.20presentation.20from.20vadim.20petrochenkov</a> but you'll probably have to set the speed to 2x for it to become watchable.</p>



<a name="277431722"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/315146-t-compiler/etc/incremental-hir/topic/Incremental%20resolution/near/277431722" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cjgillot <a href="https://zulip-archive.rust-lang.org/stream/315146-t-compiler/etc/incremental-hir/topic/Incremental.20resolution.html#277431722">(Apr 01 2022 at 15:04)</a>:</h4>
<p>Here is a proposal for a battle plan:</p>
<ol>
<li>wrap all mutable state in <code>Resolver</code> inside <code>RefCell</code>s, and take the resolver by non-mutable reference everywhere;</li>
<li>wrap the resolver as a trait object inside the <code>TyCtxt</code>, with appropriate plumbing for accesses to the <code>CrateStore</code> and <code>Definitions</code>, and implement <code>resolutions</code> query that drops the reference to the resolver;</li>
<li>start querifying passes.</li>
</ol>
<p>These queries' results will replace the <code>RefCell</code>s we put inside the resolver. All these queries are <code>eval_always</code> and forced by <code>resolutions</code> before dropping the resolver. The first passes to querify are probably the visibilities, access levels, and late resolution.</p>
<p>From here, the plan get a bit blurrier:</p>
<ol start="4">
<li>integrate loading new crates and loading modules from metadata into the query system;</li>
<li>make the macro expansion code recursive and pull-based;</li>
<li>make querify early resolution and macro expansion, keyed on the <code>LocalExpnId</code>;</li>
<li>remove the <code>resolutions</code> query, remove <code>Resolver, and stop releasing </code>ResolverArenas` memory.</li>
</ol>



<a name="277432164"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/315146-t-compiler/etc/incremental-hir/topic/Incremental%20resolution/near/277432164" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cjgillot <a href="https://zulip-archive.rust-lang.org/stream/315146-t-compiler/etc/incremental-hir/topic/Incremental.20resolution.html#277432164">(Apr 01 2022 at 15:07)</a>:</h4>
<p>In your public review, you mentionned that late resolution could be refactored to operate per-module.  Do you know if somebody has started doing it yet?</p>



<a name="277446569"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/315146-t-compiler/etc/incremental-hir/topic/Incremental%20resolution/near/277446569" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Vadim Petrochenkov <a href="https://zulip-archive.rust-lang.org/stream/315146-t-compiler/etc/incremental-hir/topic/Incremental.20resolution.html#277446569">(Apr 01 2022 at 16:47)</a>:</h4>
<blockquote>
<p>Do you know if somebody has started doing it yet?</p>
</blockquote>
<p>I'm not aware of any such work.</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>