<html>
<head><meta charset="utf-8"><title>Dylib ABI compatibility · new members · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/122652-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/122652-new-members/topic/Dylib.20ABI.20compatibility.html">Dylib ABI compatibility</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="254424362"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122652-new%20members/topic/Dylib%20ABI%20compatibility/near/254424362" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Markus Ineichen <a href="https://zulip-archive.rust-lang.org/stream/122652-new-members/topic/Dylib.20ABI.20compatibility.html#254424362">(Sep 22 2021 at 19:29)</a>:</h4>
<p>Hello everyone<br>
After reading the following <a href="https://nullderef.com/blog/plugin-start/#_abi_unstability_its_much_worse_than_it_seems">article</a>, I was very surprised, that apparently, rustc could change the memory layout with each recompilation and not just when using different versions of rustc. Can anybody explain, how layout stability  is upheld when linking stdlib dynamically?</p>



<a name="254427392"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122652-new%20members/topic/Dylib%20ABI%20compatibility/near/254427392" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wesley Wiser <a href="https://zulip-archive.rust-lang.org/stream/122652-new-members/topic/Dylib.20ABI.20compatibility.html#254427392">(Sep 22 2021 at 19:48)</a>:</h4>
<p>I think there's a few different aspects to this:</p>
<ul>
<li>The article points out that Rust doesn't <em>guarantee</em> memory layout will be compatible across different compilations. <em>In practice</em>, they will be which is where the commonly cited advice mentioned in the article comes from. </li>
<li>The flag doesn't literally randomize layout on every recompilation. That would completely break incremental builds. Instead the random seed is deterministically generated from the crate source. Thus <em>in practice</em>, you will get the same randomized layout across two different builds of the same source. </li>
<li>stdlib is special and can take advantage of unspecified behavior because it's part of the distribution and is intertwined with the compiler. For example, the stdlib uses specialization internally for performance even though the compiler you use is (probably) a stable compiler. For example, some parts of the stdlib are just compiler intrinsics. </li>
<li>The flag supports cross-crate scenarios <a href="https://github.com/rust-lang/rust/blob/8c4e116fe1e95eed34768000eafd3fc62d9bf789/compiler/rustc_middle/src/ty/mod.rs#L1541-L1543">https://github.com/rust-lang/rust/blob/8c4e116fe1e95eed34768000eafd3fc62d9bf789/compiler/rustc_middle/src/ty/mod.rs#L1541-L1543</a></li>
</ul>



<a name="254429041"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122652-new%20members/topic/Dylib%20ABI%20compatibility/near/254429041" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Markus Ineichen <a href="https://zulip-archive.rust-lang.org/stream/122652-new-members/topic/Dylib.20ABI.20compatibility.html#254429041">(Sep 22 2021 at 19:58)</a>:</h4>
<p>Thank you for your answer. In my project, I have an executable which loads a dylib with libloading. Both projects reference a common external library. If the executable passes a struct from that library to the dylib, everything works like charm right now, even if executable and dylib use different features of the common library. But I'm worried that it could fall back on me in the future when the codebase grows.</p>



<a name="254434773"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122652-new%20members/topic/Dylib%20ABI%20compatibility/near/254434773" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wesley Wiser <a href="https://zulip-archive.rust-lang.org/stream/122652-new-members/topic/Dylib.20ABI.20compatibility.html#254434773">(Sep 22 2021 at 20:34)</a>:</h4>
<p>Can you make that struct <code>#[repr(C)]</code>?</p>



<a name="254441839"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/122652-new%20members/topic/Dylib%20ABI%20compatibility/near/254441839" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Markus Ineichen <a href="https://zulip-archive.rust-lang.org/stream/122652-new-members/topic/Dylib.20ABI.20compatibility.html#254441839">(Sep 22 2021 at 21:24)</a>:</h4>
<p>No, it is an external library I have no control over. I guess it  wouldn't help if I wrap the external struct like <code>MyWrapper(ExternalNoReprC)</code>in a fourth project, right? What about passing trait objects like <code>Box&lt;dyn MyTrait&gt;</code>? Do you see any way to reliably accomplish something like that? It's quite difficult to find information about this topic.</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>