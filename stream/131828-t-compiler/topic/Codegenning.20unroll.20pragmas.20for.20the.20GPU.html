<html>
<head><meta charset="utf-8"><title>Codegenning unroll pragmas for the GPU · t-compiler · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/index.html">t-compiler</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Codegenning.20unroll.20pragmas.20for.20the.20GPU.html">Codegenning unroll pragmas for the GPU</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="256173580"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Codegenning%20unroll%20pragmas%20for%20the%20GPU/near/256173580" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Riccardo D&#x27;Ambrosio <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Codegenning.20unroll.20pragmas.20for.20the.20GPU.html#256173580">(Oct 05 2021 at 04:00)</a>:</h4>
<p>It is possible to somehow codegen LLVM unroll metadata through an attr on statements/exprs in a custom codegen which uses LLVM?<br>
The codegen i am working on targets the GPU, and on the GPU, unrolling is especially important, so i would like to provide ways of telling llvm/libnvvm to unroll certain loops, e.g.</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="cp">#[unroll]</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="mi">20</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ...</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>I can easily implement this at the function level, but i don't think its possible to implement it at the statement level currently. This is because to be able to do this, i would probably have to track back a cg_ssa-dispatched method on the builder trait, to its MIR counterpart, so that i can then see if it contains an attr, check if the instruction is the back-edge of a loop... and it just seems impossible.</p>
<p>Is there perhaps any other way? I cant think of a way to do this without physically tracking how MIR maps to instructions. Maybe i could desugar unroll to something like <code>__nvvm_unroll_next(0..20)</code> then have the codegen treat that function explicitly when it sees it being called? But then again id have to find the back-edge with that or something.</p>



<a name="256174640"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Codegenning%20unroll%20pragmas%20for%20the%20GPU/near/256174640" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Codegenning.20unroll.20pragmas.20for.20the.20GPU.html#256174640">(Oct 05 2021 at 04:14)</a>:</h4>
<p><span class="user-mention" data-user-id="276242">@Riccardo D'Ambrosio</span> Could you have the compiler just detect that it should unroll that loop?</p>



<a name="256174690"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Codegenning%20unroll%20pragmas%20for%20the%20GPU/near/256174690" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Codegenning.20unroll.20pragmas.20for.20the.20GPU.html#256174690">(Oct 05 2021 at 04:14)</a>:</h4>
<p>Another approach would be a macro that unrolls the loop manually.</p>



<a name="256174722"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Codegenning%20unroll%20pragmas%20for%20the%20GPU/near/256174722" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Riccardo D&#x27;Ambrosio <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Codegenning.20unroll.20pragmas.20for.20the.20GPU.html#256174722">(Oct 05 2021 at 04:15)</a>:</h4>
<p>LLVM will already unroll some of the loops, but it won't unroll every single loop, and in CUDA it is often useful to tell the compile to unroll fully or by a certain factor</p>



<a name="256174771"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Codegenning%20unroll%20pragmas%20for%20the%20GPU/near/256174771" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Riccardo D&#x27;Ambrosio <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Codegenning.20unroll.20pragmas.20for.20the.20GPU.html#256174771">(Oct 05 2021 at 04:15)</a>:</h4>
<p>I would rather not use a macro approach, it feels a bit hacky to me, and id like to support loops more complex than just simple ranges</p>



<a name="256174841"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Codegenning%20unroll%20pragmas%20for%20the%20GPU/near/256174841" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Riccardo D&#x27;Ambrosio <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Codegenning.20unroll.20pragmas.20for.20the.20GPU.html#256174841">(Oct 05 2021 at 04:16)</a>:</h4>
<p>it would have to be a proc macro too which would murder intellisense...</p>



<a name="256174884"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Codegenning%20unroll%20pragmas%20for%20the%20GPU/near/256174884" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Codegenning.20unroll.20pragmas.20for.20the.20GPU.html#256174884">(Oct 05 2021 at 04:17)</a>:</h4>
<p>I'd be really hesitant to add that degree of tuning attribute, rather than just teaching the compiler to figure out the right amount to unroll.</p>



<a name="256174910"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Codegenning%20unroll%20pragmas%20for%20the%20GPU/near/256174910" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Codegenning.20unroll.20pragmas.20for.20the.20GPU.html#256174910">(Oct 05 2021 at 04:17)</a>:</h4>
<p>How would you know how much to partially or fully unroll? Based on the number of instructions, or the amount of parallelism available on the GPU, or what?</p>



<a name="256174981"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Codegenning%20unroll%20pragmas%20for%20the%20GPU/near/256174981" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Riccardo D&#x27;Ambrosio <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Codegenning.20unroll.20pragmas.20for.20the.20GPU.html#256174981">(Oct 05 2021 at 04:18)</a>:</h4>
<p>The right amount to unroll is not easily figured out, oftentimes a programmer can guess it better, utilizing registers more efficiently</p>



<a name="256175017"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Codegenning%20unroll%20pragmas%20for%20the%20GPU/near/256175017" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Riccardo D&#x27;Ambrosio <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Codegenning.20unroll.20pragmas.20for.20the.20GPU.html#256175017">(Oct 05 2021 at 04:19)</a>:</h4>
<p>Unroll would try to unroll it fully, that usually yields good perf benefits if the kernel is not using a lot of registers</p>



<a name="256175056"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Codegenning%20unroll%20pragmas%20for%20the%20GPU/near/256175056" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Riccardo D&#x27;Ambrosio <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Codegenning.20unroll.20pragmas.20for.20the.20GPU.html#256175056">(Oct 05 2021 at 04:19)</a>:</h4>
<p>The amount of registers available depends a lot on launch bounds, compute capability, virtual architecture, etc</p>



<a name="256175059"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Codegenning%20unroll%20pragmas%20for%20the%20GPU/near/256175059" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Codegenning.20unroll.20pragmas.20for.20the.20GPU.html#256175059">(Oct 05 2021 at 04:19)</a>:</h4>
<p>"unroll the right amount to use the right number of registers" seems like something the compiler could do well if it were taught to.</p>



<a name="256175077"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Codegenning%20unroll%20pragmas%20for%20the%20GPU/near/256175077" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Riccardo D&#x27;Ambrosio <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Codegenning.20unroll.20pragmas.20for.20the.20GPU.html#256175077">(Oct 05 2021 at 04:19)</a>:</h4>
<p>Well the thing is, it cannot really do it until the ptx is assembled</p>



<a name="256175079"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Codegenning%20unroll%20pragmas%20for%20the%20GPU/near/256175079" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Codegenning.20unroll.20pragmas.20for.20the.20GPU.html#256175079">(Oct 05 2021 at 04:19)</a>:</h4>
<p>If, for instance, you gave a specific GPU target and the compiler knew the capabilities of that target.</p>



<a name="256175150"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Codegenning%20unroll%20pragmas%20for%20the%20GPU/near/256175150" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Riccardo D&#x27;Ambrosio <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Codegenning.20unroll.20pragmas.20for.20the.20GPU.html#256175150">(Oct 05 2021 at 04:20)</a>:</h4>
<p>PTX uses a virtual architecture, which means that it uses virtual registers because it doesnt know the amount of registers available until it jit compiles it to SASS</p>



<a name="256175160"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Codegenning%20unroll%20pragmas%20for%20the%20GPU/near/256175160" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Riccardo D&#x27;Ambrosio <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Codegenning.20unroll.20pragmas.20for.20the.20GPU.html#256175160">(Oct 05 2021 at 04:20)</a>:</h4>
<p>so LLVM/libnvvm cannot reliably guess how many registers are available</p>



<a name="256175167"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Codegenning%20unroll%20pragmas%20for%20the%20GPU/near/256175167" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Riccardo D&#x27;Ambrosio <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Codegenning.20unroll.20pragmas.20for.20the.20GPU.html#256175167">(Oct 05 2021 at 04:20)</a>:</h4>
<p>it can to some degree, but not fully</p>



<a name="256175180"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Codegenning%20unroll%20pragmas%20for%20the%20GPU/near/256175180" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Riccardo D&#x27;Ambrosio <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Codegenning.20unroll.20pragmas.20for.20the.20GPU.html#256175180">(Oct 05 2021 at 04:20)</a>:</h4>
<p>its kind of like "why have #[inline] if llvm does inlining already?"</p>



<a name="256175228"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Codegenning%20unroll%20pragmas%20for%20the%20GPU/near/256175228" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Riccardo D&#x27;Ambrosio <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Codegenning.20unroll.20pragmas.20for.20the.20GPU.html#256175228">(Oct 05 2021 at 04:21)</a>:</h4>
<p>this explains it pretty well <a href="https://www.nvidia.com/docs/IO/116711/sc11-unrolling-parallel-loops.pdf">https://www.nvidia.com/docs/IO/116711/sc11-unrolling-parallel-loops.pdf</a></p>



<a name="256175400"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Codegenning%20unroll%20pragmas%20for%20the%20GPU/near/256175400" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Riccardo D&#x27;Ambrosio <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Codegenning.20unroll.20pragmas.20for.20the.20GPU.html#256175400">(Oct 05 2021 at 04:23)</a>:</h4>
<p>CUDA provides plenty of tools to analyze the occupancy/utilization of the total GPU resources, for example, Nsight compute. Nsight can offer some pretty useful statistics about registers which users can use to base unrolling decisions on. It can't always be guessed by the compiler</p>



<a name="256175671"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Codegenning%20unroll%20pragmas%20for%20the%20GPU/near/256175671" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Codegenning.20unroll.20pragmas.20for.20the.20GPU.html#256175671">(Oct 05 2021 at 04:26)</a>:</h4>
<p>This seems like a limitation of generating PTX rather than doing codegen for a specific target GPU with a given "compute capability" level.</p>



<a name="256175679"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Codegenning%20unroll%20pragmas%20for%20the%20GPU/near/256175679" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Riccardo D&#x27;Ambrosio <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Codegenning.20unroll.20pragmas.20for.20the.20GPU.html#256175679">(Oct 05 2021 at 04:26)</a>:</h4>
<p>moreover, because LLVM generally assumes its working on CPU code, it is more conservative with its unrolling, but on the gpu, there are thousands of registers readily available for each iteration to utilize</p>



<a name="256175696"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Codegenning%20unroll%20pragmas%20for%20the%20GPU/near/256175696" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Codegenning.20unroll.20pragmas.20for.20the.20GPU.html#256175696">(Oct 05 2021 at 04:27)</a>:</h4>
<p>But even with PTX, it would be possible to tune for a specific GPU, if the backend knew approximately how many registers to use.</p>



<a name="256175708"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Codegenning%20unroll%20pragmas%20for%20the%20GPU/near/256175708" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Riccardo D&#x27;Ambrosio <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Codegenning.20unroll.20pragmas.20for.20the.20GPU.html#256175708">(Oct 05 2021 at 04:27)</a>:</h4>
<p>The compute capability passed to libnvvm says nothing about register amount</p>



<a name="256175729"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Codegenning%20unroll%20pragmas%20for%20the%20GPU/near/256175729" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Riccardo D&#x27;Ambrosio <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Codegenning.20unroll.20pragmas.20for.20the.20GPU.html#256175729">(Oct 05 2021 at 04:27)</a>:</h4>
<p>register amount isnt a thing until the PTX is JIT compiled to SASS when you actually run it with the cuda driver API</p>



<a name="256175752"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Codegenning%20unroll%20pragmas%20for%20the%20GPU/near/256175752" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Codegenning.20unroll.20pragmas.20for.20the.20GPU.html#256175752">(Oct 05 2021 at 04:27)</a>:</h4>
<p>I know that's true for PTX, but I also know the toolchain is capable of generating target-specific binaries...</p>



<a name="256175758"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Codegenning%20unroll%20pragmas%20for%20the%20GPU/near/256175758" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Codegenning.20unroll.20pragmas.20for.20the.20GPU.html#256175758">(Oct 05 2021 at 04:28)</a>:</h4>
<p>I'm assuming <em>something</em> knows the number of registers.</p>



<a name="256175804"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Codegenning%20unroll%20pragmas%20for%20the%20GPU/near/256175804" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Riccardo D&#x27;Ambrosio <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Codegenning.20unroll.20pragmas.20for.20the.20GPU.html#256175804">(Oct 05 2021 at 04:28)</a>:</h4>
<p>And there is no physical way to tell libnvvm to target a specific GPU with some amount of registers, it leaves that control to the user</p>



<a name="256175837"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Codegenning%20unroll%20pragmas%20for%20the%20GPU/near/256175837" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Riccardo D&#x27;Ambrosio <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Codegenning.20unroll.20pragmas.20for.20the.20GPU.html#256175837">(Oct 05 2021 at 04:28)</a>:</h4>
<p>yes, ptxas does, but that runs at runtime, not at compile time, PTX is deliberately gpu-agnostic (other than compute capabilities, but thats a virtual architecture)</p>



<a name="256175879"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Codegenning%20unroll%20pragmas%20for%20the%20GPU/near/256175879" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Codegenning.20unroll.20pragmas.20for.20the.20GPU.html#256175879">(Oct 05 2021 at 04:29)</a>:</h4>
<p>This sounds like a problem with libnvvm.</p>



<a name="256175887"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Codegenning%20unroll%20pragmas%20for%20the%20GPU/near/256175887" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Codegenning.20unroll.20pragmas.20for.20the.20GPU.html#256175887">(Oct 05 2021 at 04:29)</a>:</h4>
<p>(And a limitation of not actually having an open toolchain.)</p>



<a name="256175906"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Codegenning%20unroll%20pragmas%20for%20the%20GPU/near/256175906" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Codegenning.20unroll.20pragmas.20for.20the.20GPU.html#256175906">(Oct 05 2021 at 04:29)</a>:</h4>
<p>I'm not trying to belabor that point, but this is the kind of thing that <em>should</em> be better, and there's no technical reason it <em>can't</em> be better.</p>



<a name="256175917"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Codegenning%20unroll%20pragmas%20for%20the%20GPU/near/256175917" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Riccardo D&#x27;Ambrosio <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Codegenning.20unroll.20pragmas.20for.20the.20GPU.html#256175917">(Oct 05 2021 at 04:30)</a>:</h4>
<p>In what way? Id argue this is actually a really good thing, because u can compile to PTX and have that run efficiently on every GPU</p>



<a name="256175971"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Codegenning%20unroll%20pragmas%20for%20the%20GPU/near/256175971" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Riccardo D&#x27;Ambrosio <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Codegenning.20unroll.20pragmas.20for.20the.20GPU.html#256175971">(Oct 05 2021 at 04:30)</a>:</h4>
<p>if i compiled to SASS, you couldnt redistribute that, it would only work on your GPU</p>



<a name="256175976"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Codegenning%20unroll%20pragmas%20for%20the%20GPU/near/256175976" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Codegenning.20unroll.20pragmas.20for.20the.20GPU.html#256175976">(Oct 05 2021 at 04:30)</a>:</h4>
<p><span class="user-mention silent" data-user-id="276242">Riccardo D'Ambrosio</span> <a href="#narrow/stream/131828-t-compiler/topic/Codegenning.20unroll.20pragmas.20for.20the.20GPU/near/256175917">said</a>:</p>
<blockquote>
<p>u can compile to PTX and have that run efficiently on every GPU</p>
</blockquote>
<p>Evidently not as efficiently as it could.</p>



<a name="256176001"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Codegenning%20unroll%20pragmas%20for%20the%20GPU/near/256176001" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Codegenning.20unroll.20pragmas.20for.20the.20GPU.html#256176001">(Oct 05 2021 at 04:30)</a>:</h4>
<p>And in any case, it would be reasonable to allow running on any GPU but <em>tuning</em> for a specific GPU.</p>



<a name="256176017"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Codegenning%20unroll%20pragmas%20for%20the%20GPU/near/256176017" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Codegenning.20unroll.20pragmas.20for.20the.20GPU.html#256176017">(Oct 05 2021 at 04:30)</a>:</h4>
<p>On x86-64, you can compile for a certain baseline but tune for a specific newer CPU, so that it knows the timings and capabilities of that newer CPU.</p>



<a name="256176038"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Codegenning%20unroll%20pragmas%20for%20the%20GPU/near/256176038" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Codegenning.20unroll.20pragmas.20for.20the.20GPU.html#256176038">(Oct 05 2021 at 04:31)</a>:</h4>
<p>You could do the same with PTX: compile generic code but tune for the capabilities of a given generation of GPU so it runs well on that GPU.</p>



<a name="256176047"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Codegenning%20unroll%20pragmas%20for%20the%20GPU/near/256176047" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Riccardo D&#x27;Ambrosio <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Codegenning.20unroll.20pragmas.20for.20the.20GPU.html#256176047">(Oct 05 2021 at 04:31)</a>:</h4>
<p>I mean i guess if ptxas could dynamically unroll during codegen yeah, but that seems weird to me, not to mention expensive</p>



<a name="256176048"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Codegenning%20unroll%20pragmas%20for%20the%20GPU/near/256176048" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Codegenning.20unroll.20pragmas.20for.20the.20GPU.html#256176048">(Oct 05 2021 at 04:31)</a>:</h4>
<p>(Or, for that matter, generate a few different binaries for different generations and ship them all.)</p>



<a name="256176070"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Codegenning%20unroll%20pragmas%20for%20the%20GPU/near/256176070" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Riccardo D&#x27;Ambrosio <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Codegenning.20unroll.20pragmas.20for.20the.20GPU.html#256176070">(Oct 05 2021 at 04:31)</a>:</h4>
<p>i know ptxas does some optimizations, but they are limited because PTX -&gt; SASS is meant to be extremely fast</p>



<a name="256176135"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Codegenning%20unroll%20pragmas%20for%20the%20GPU/near/256176135" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Codegenning.20unroll.20pragmas.20for.20the.20GPU.html#256176135">(Oct 05 2021 at 04:32)</a>:</h4>
<p>If PTX-&gt;SASS runs once per GPU rather than once per frame or similar, it doesn't seem unreasonable to do some larger optimizations and cache the result.</p>



<a name="256176164"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Codegenning%20unroll%20pragmas%20for%20the%20GPU/near/256176164" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Codegenning.20unroll.20pragmas.20for.20the.20GPU.html#256176164">(Oct 05 2021 at 04:32)</a>:</h4>
<p>In any case, it sounds like that isn't what libnvvm supports, and you're stuck using libnvvm.</p>



<a name="256176185"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Codegenning%20unroll%20pragmas%20for%20the%20GPU/near/256176185" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Riccardo D&#x27;Ambrosio <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Codegenning.20unroll.20pragmas.20for.20the.20GPU.html#256176185">(Oct 05 2021 at 04:33)</a>:</h4>
<p>but that would evidently introduce feature creep, PTX is meant to be a minimal assembly format, if you start pouring everything including tons of optimization hints in there, you end up with a very bloated format</p>



<a name="256176193"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Codegenning%20unroll%20pragmas%20for%20the%20GPU/near/256176193" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Codegenning.20unroll.20pragmas.20for.20the.20GPU.html#256176193">(Oct 05 2021 at 04:33)</a>:</h4>
<p>But it still seems <em>possible</em> to at least teach LLVM to generate PTX with a specific number of registers.</p>



<a name="256176211"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Codegenning%20unroll%20pragmas%20for%20the%20GPU/near/256176211" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Riccardo D&#x27;Ambrosio <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Codegenning.20unroll.20pragmas.20for.20the.20GPU.html#256176211">(Oct 05 2021 at 04:33)</a>:</h4>
<p>LLVM is not generating the PTX, it is just optimizing</p>



<a name="256176221"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Codegenning%20unroll%20pragmas%20for%20the%20GPU/near/256176221" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Riccardo D&#x27;Ambrosio <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Codegenning.20unroll.20pragmas.20for.20the.20GPU.html#256176221">(Oct 05 2021 at 04:33)</a>:</h4>
<p>i could tell LLVM to unroll more by modifying the pass manager, but other than that, not much</p>



<a name="256176233"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Codegenning%20unroll%20pragmas%20for%20the%20GPU/near/256176233" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Riccardo D&#x27;Ambrosio <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Codegenning.20unroll.20pragmas.20for.20the.20GPU.html#256176233">(Oct 05 2021 at 04:33)</a>:</h4>
<p>but id rather introduce per-function and per-loop hints than global hints</p>



<a name="256176576"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Codegenning%20unroll%20pragmas%20for%20the%20GPU/near/256176576" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Codegenning.20unroll.20pragmas.20for.20the.20GPU.html#256176576">(Oct 05 2021 at 04:38)</a>:</h4>
<p>I don't see how those hints would be useful for any other backend, where the compiler can know the capabilities of the target and optimize accordingly.</p>



<a name="256176598"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Codegenning%20unroll%20pragmas%20for%20the%20GPU/near/256176598" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Riccardo D&#x27;Ambrosio <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Codegenning.20unroll.20pragmas.20for.20the.20GPU.html#256176598">(Oct 05 2021 at 04:38)</a>:</h4>
<p>This is not for cg_llvm, this is just for my own codegen, this would not make it into "normal" rust</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>