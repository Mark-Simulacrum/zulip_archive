<html>
<head><meta charset="utf-8"><title>future of incremental compilation · t-compiler · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/index.html">t-compiler</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html">future of incremental compilation</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="272794314"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272794314" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272794314">(Feb 22 2022 at 12:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="232957">Jack Huey</span> <a href="#narrow/stream/131828-t-compiler/topic/roadmap.20for.202022.20discussion/near/272744001">said</a>:</p>
<blockquote>
<p>Should this be moved to its own topic</p>
</blockquote>
<p>seconded, this deserves its own topic</p>



<a name="272795054"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272795054" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272795054">(Feb 22 2022 at 12:22)</a>:</h4>
<p>I will say that the last time that incremental was disabled it resulted in overwhelming discontent from the community and a large number of projects that simply pinned to the prior version. This needs to be handled carefully, because if people start talking about simply removing incremental without talking about what's going to replace it, there's going to be an enormous negative backlash</p>



<a name="272809449"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272809449" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272809449">(Feb 22 2022 at 14:25)</a>:</h4>
<p>to clarify, <em>is</em> incremental being last-minute disabled for 1.59? I don't know what discussion or document is being referenced in the original comment</p>



<a name="272809587"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272809587" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> simulacrum <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272809587">(Feb 22 2022 at 14:26)</a>:</h4>
<p>Yes, that's the case -- current thread is <a href="https://github.com/rust-lang/rust/issues/94124">https://github.com/rust-lang/rust/issues/94124</a>.</p>



<a name="272823670"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272823670" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272823670">(Feb 22 2022 at 16:00)</a>:</h4>
<p>I wonder if chalk will help at all with tracking trait selection dependencies</p>



<a name="272823752"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272823752" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272823752">(Feb 22 2022 at 16:01)</a>:</h4>
<p>Since IIRC there's an explicit abstraction layer mapping from chalk types to rustc types (and associated 'db lookups')</p>



<a name="272823756"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272823756" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> mw <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272823756">(Feb 22 2022 at 16:01)</a>:</h4>
<p>out of curiosity: what do people think about the query system in general, as in: Is it desirable to describe the compilation process as a set of side-effect-free functions that produce their results by "pulling on them" (setting aside the question of whether these functions are memoized or executed in parallel)? Is such a model a good fit for the kinds of tasks that a compiler has to do? Can the major algorithms be implemented that way without going through contortions?</p>



<a name="272824059"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272824059" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272824059">(Feb 22 2022 at 16:02)</a>:</h4>
<p>I think that's worked out pretty well so far - the main side effect that we need is diagnostics</p>



<a name="272824132"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272824132" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272824132">(Feb 22 2022 at 16:03)</a>:</h4>
<p>Many of the nasty incremental bugs have resulted from the fact that we always need to call the actual query</p>



<a name="272824203"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272824203" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272824203">(Feb 22 2022 at 16:03)</a>:</h4>
<p>which causes issues if we try to cache the result in a thread-local or tcx map, even if the query itself is pure</p>



<a name="272824929"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272824929" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272824929">(Feb 22 2022 at 16:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="124287">mw</span> <a href="#narrow/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation/near/272823756">said</a>:</p>
<blockquote>
<p>out of curiosity: what do people think about the query system in general, as in: Is it desirable to describe the compilation process as a set of side-effect-free functions that produce their results by "pulling on them" (setting aside the question of whether these functions are memoized or executed in parallel)? Is such a model a good fit for the kinds of tasks that a compiler has to do? Can the major algorithms be implemented that way without going through contortions?</p>
</blockquote>
<p>FWIW, I love the concept of "pull-based" compilation, and I'm really hopeful that it might enable parallel compilation in a way that seems like it'd be much harder in a traditional compiler architecture.</p>



<a name="272827128"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272827128" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cjgillot <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272827128">(Feb 22 2022 at 16:21)</a>:</h4>
<p><span class="user-mention silent" data-user-id="124287">mw</span> <a href="#narrow/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation/near/272823756">said</a>:</p>
<blockquote>
<p>out of curiosity: what do people think about the query system in general, as in: Is it desirable to describe the compilation process as a set of side-effect-free functions that produce their results by "pulling on them" (setting aside the question of whether these functions are memoized or executed in parallel)? Is such a model a good fit for the kinds of tasks that a compiler has to do? Can the major algorithms be implemented that way without going through contortions?</p>
</blockquote>
<p>One such "contorsion" is the <code>WithOptConstParam</code>business for anonymous constants. Using side-effects, typechecking could just declare that one constant has such type based on the const parameter it replaces, and compilation could go on with it.<br>
There are some examples of queries which perform a bunch of computations together, just for other queries to unbundle the results. This happens for lifetime resolution for instance. Meanwhile, some other queries are tightly coupled because they work on the same data (type parameter &amp; predicate collection?).<br>
One other difficulty is that the information flow is <em>really</em> difficult to understand. For most queries, I have absolutely no idea which code uses them, and how.</p>



<a name="272828792"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272828792" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cjgillot <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272828792">(Feb 22 2022 at 16:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="239881">Josh Triplett</span> <a href="#narrow/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation/near/272824929">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="124287">mw</span> <a href="#narrow/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation/near/272823756">said</a>:</p>
<blockquote>
<p>out of curiosity: what do people think about the query system in general, as in: Is it desirable to describe the compilation process as a set of side-effect-free functions that produce their results by "pulling on them" (setting aside the question of whether these functions are memoized or executed in parallel)? Is such a model a good fit for the kinds of tasks that a compiler has to do? Can the major algorithms be implemented that way without going through contortions?</p>
</blockquote>
<p>FWIW, I love the concept of "pull-based" compilation, and I'm really hopeful that it might enable parallel compilation in a way that seems like it'd be much harder in a traditional compiler architecture.</p>
</blockquote>
<p>I'm not sure I agree with you. We can have parallel compilation in a stage-based model, as long as we specify stages as pure functions on a limited part of the code (an item or a body?). This could be relaxed to allow some side effects, but with a lot of care.<br>
A lot of passes are embarrassingly parallel: lints, typechecking a function body, borrowck, MIR opts. Load balancing and synchronization points will also be an issue.<br>
Of course, the main complexity will be the feedback between CTFE and typechecking, that on-demand compilation handles very nicely.</p>



<a name="272829270"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272829270" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272829270">(Feb 22 2022 at 16:34)</a>:</h4>
<p>Why do we need a side effect to collect what should be a simple refinement?</p>



<a name="272829443"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272829443" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> lcnr <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272829443">(Feb 22 2022 at 16:35)</a>:</h4>
<p>i think that using a query system is generally really cool  though it currently doesn't currently feel strong enough to express what we want</p>



<a name="272829589"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272829589" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> lcnr <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272829589">(Feb 22 2022 at 16:36)</a>:</h4>
<p>that is something we can incrementally improve, e.g. by allowing cyclic queries where one query only accesses a part of the results of the other query, locking these results to prevent any future mutation</p>



<a name="272829659"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272829659" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> lcnr <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272829659">(Feb 22 2022 at 16:37)</a>:</h4>
<p>that would remove the need for <code>WithoptConstParam</code> and some other issue i can't remember rn</p>



<a name="272830006"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272830006" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> lcnr <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272830006">(Feb 22 2022 at 16:39)</a>:</h4>
<p>though i think that if incremental compilation doesn't pull its weight, having a staged compiler with some "pseudo queries" for typeck to deal with const generics would probably be easier to maintain</p>



<a name="272830010"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272830010" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272830010">(Feb 22 2022 at 16:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="216206">lcnr</span> <a href="#narrow/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation/near/272829589">said</a>:</p>
<blockquote>
<p>that is something we can incrementally improve, e.g. by allowing cyclic queries where one query only accesses a part of the results of the other query, locking these results to prevent any future mutation</p>
</blockquote>
<p>You mean like haskell's lazy evaluation which can do weird time traveling things? <a href="https://hackage.haskell.org/package/tardis-0.4.1.0/docs/Control-Monad-Tardis.html">https://hackage.haskell.org/package/tardis-0.4.1.0/docs/Control-Monad-Tardis.html</a></p>



<a name="272830149"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272830149" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272830149">(Feb 22 2022 at 16:40)</a>:</h4>
<p>A lot of the design involving queries has been heavily inspired by a paradigm of constraint-driven programming. In constraint programming you have one of two choices. You can push an update to a value and then everything adjusts based on that update (the "functional reactive" or "perturbation" model) or you can use refinement where something's value at any given point is the range of values it can possibly be. Until you evaluate it to a single one, anyways.</p>



<a name="272830450"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272830450" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> lcnr <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272830450">(Feb 22 2022 at 16:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="133247">bjorn3</span> <a href="#narrow/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation/near/272830010">said</a>:</p>
<blockquote>
<p>You mean like haskell's lazy evaluation which can do weird time traveling things? <a href="https://hackage.haskell.org/package/tardis-0.4.1.0/docs/Control-Monad-Tardis.html">https://hackage.haskell.org/package/tardis-0.4.1.0/docs/Control-Monad-Tardis.html</a></p>
</blockquote>
<p>haven't seen that before and i can't say for sure. never worked with a reverse state monad and can't really tell how it's useful</p>



<a name="272830806"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272830806" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> lcnr <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272830806">(Feb 22 2022 at 16:45)</a>:</h4>
<p>the query system also suffers from <code>Ord</code> impls which are incorrect wrt incremental compilation, i think that this is largely an issue with our current impl and not a general one though</p>



<a name="272830982"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272830982" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> lcnr <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272830982">(Feb 22 2022 at 16:46)</a>:</h4>
<p><em>having a query system would be so much nicer if rust was actually just a functional language</em> <span aria-label="sparkles" class="emoji emoji-2728" role="img" title="sparkles">:sparkles:</span></p>



<a name="272831534"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272831534" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272831534">(Feb 22 2022 at 16:49)</a>:</h4>
<p>Or even if rust had an effect system of some kind, though at that point the line with fp starts to get real blurry</p>



<a name="272832616"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272832616" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272832616">(Feb 22 2022 at 16:55)</a>:</h4>
<p>AN EFFECT SYSTEM YOU SAY</p>



<a name="272832705"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272832705" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272832705">(Feb 22 2022 at 16:56)</a>:</h4>
<p>hahaha the <span class="user-mention" data-user-id="220273">@Jane Lusby [she/her]</span> signal.</p>



<a name="272834010"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272834010" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272834010">(Feb 22 2022 at 17:03)</a>:</h4>
<p>As a not so frequent contributor, I do want to add this: The query system makes it fairly easy for me to figure out where I should go to get the information I need. It provides a fairly uniform API, at least in the sense that I know that with a <code>tcx</code>and the appropriate parameters, I can basically always solve my problem. There are definitely things to improve as well here (some way to answer the question "can I call this query at this point without inducing a query cycle" for example), but in general I think it is relatively friendly model. Other models run the risk of "fragmenting" the APIs in some way that would increase the difficulty of contributing significantly</p>



<a name="272834533"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272834533" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pierwill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272834533">(Feb 22 2022 at 17:06)</a>:</h4>
<p><span class="user-mention silent" data-user-id="216206">lcnr</span> <a href="#narrow/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation/near/272830806">said</a>:</p>
<blockquote>
<p>the query system also suffers from <code>Ord</code> impls which are incorrect wrt incremental compilation, i think that this is largely an issue with our current impl and not a general one though</p>
</blockquote>
<p>This is something we're definitely making progress on.</p>



<a name="272834738"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272834738" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272834738">(Feb 22 2022 at 17:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="125294">Aaron Hill</span> <a href="#narrow/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation/near/272823752">said</a>:</p>
<blockquote>
<p>Since IIRC there's an explicit abstraction layer mapping from chalk types to rustc types (and associated 'db lookups')</p>
</blockquote>
<p>this is correct for now, but the goal is to eventually make this a no-op</p>



<a name="272834998"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272834998" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272834998">(Feb 22 2022 at 17:10)</a>:</h4>
<p><span class="user-mention silent" data-user-id="125294">Aaron Hill</span> <a href="#narrow/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation/near/272823670">said</a>:</p>
<blockquote>
<p>I wonder if chalk will help at all with tracking trait selection dependencies</p>
</blockquote>
<p>I did think about this a little bit though. But more generally in the "what does incremental look like during trait selection". For the current rustc trait solver, there's caching done in selection &amp; confirmation. For Chalk, that's likely <code>program_clauses_that_could_match</code></p>



<a name="272839413"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272839413" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272839413">(Feb 22 2022 at 17:40)</a>:</h4>
<blockquote>
<p>What also might be interesting: Could we have a compiler based on rust-analyzer that only supports debug builds (rust-analyzer was built with the Salsa model from the get-go and I suspect it has much fewer incr. comp. related problems).</p>
</blockquote>
<p><span class="user-mention" data-user-id="133169">@matklad</span> , any thoughts?</p>



<a name="272845606"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272845606" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cjgillot <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272845606">(Feb 22 2022 at 18:23)</a>:</h4>
<p>I think we are at a tipping point.  We can either continue using the current on-demand query system, or we can reverse directions and use a more stage-based design.  This can be done step by step, starting from lowering, and pushing towards typechecking.  We can use this as an opportunity to rebuild parallel compilation from the ground up: drop all parallel stuff from the current compiler (which is not tested anyway), and re-implement lowering to process each item in parallel.</p>



<a name="272847327"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272847327" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Florian Diebold <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272847327">(Feb 22 2022 at 18:35)</a>:</h4>
<blockquote>
<p>What also might be interesting: Could we have a compiler based on rust-analyzer that only supports debug builds (rust-analyzer was built with the Salsa model from the get-go and I suspect it has much fewer incr. comp. related problems).</p>
</blockquote>
<p>that'd be interesting and probably fun, but rust-analyzer is still very far from it being viable</p>



<a name="272848411"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272848411" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272848411">(Feb 22 2022 at 18:43)</a>:</h4>
<blockquote>
<p>(which is not tested anyway)</p>
</blockquote>
<p>The alt builders all run with the parallel compiler enabled aiui</p>



<a name="272849095"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272849095" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cjgillot <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272849095">(Feb 22 2022 at 18:48)</a>:</h4>
<p>Some ui tests have been ICEing for a few months.</p>



<a name="272849608"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272849608" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272849608">(Feb 22 2022 at 18:52)</a>:</h4>
<p><span class="user-mention silent" data-user-id="248906">cjgillot</span> <a href="#narrow/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation/near/272845606">said</a>:</p>
<blockquote>
<p>I think we are at a tipping point.  We can either continue using the current on-demand query system, or we can reverse directions and use a more stage-based design.  This can be done step by step, starting from lowering, and pushing towards typechecking.  We can use this as an opportunity to rebuild parallel compilation from the ground up: drop all parallel stuff from the current compiler (which is not tested anyway), and re-implement lowering to process each item in parallel.</p>
</blockquote>
<p>Do you (or others) have any kind of intuition what the benefits of a complete re-implementation of the query system would be? I know very little about this, but could a push towards librarification or some other large design change alleviate many of the problems?</p>



<a name="272850883"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272850883" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cjgillot <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272850883">(Feb 22 2022 at 19:00)</a>:</h4>
<p>I'm not suggesting a re-implementation of the query system.  I'm suggesting to gradually stop using it, or restricted to some stages (trait selection?).</p>



<a name="272851050"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272851050" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pnkfelix <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272851050">(Feb 22 2022 at 19:01)</a>:</h4>
<p>It seems like there's enough meat on this topic to drive a Friday meeting (or a series of them)</p>



<a name="272851134"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272851134" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cjgillot <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272851134">(Feb 22 2022 at 19:02)</a>:</h4>
<p>I don't have any quantified evidence of the benefits, of course.  On the contrary, we will have to take great care to avoid introducing regressions when incremental skips a lot of work.</p>



<a name="272851371"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272851371" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272851371">(Feb 22 2022 at 19:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="248906">cjgillot</span> <a href="#narrow/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation/near/272850883">said</a>:</p>
<blockquote>
<p>I'm not suggesting a re-implementation of the query system.  I'm suggesting to gradually stop using it, or restricted to some stages (trait selection?).</p>
</blockquote>
<p>Sorry, I should have been more clear. I didn't mean to imply that you were suggesting that, I was asking a separate question</p>



<a name="272851426"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272851426" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> simulacrum <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272851426">(Feb 22 2022 at 19:04)</a>:</h4>
<p>FWIW, I'm expecting to post a PR (for running perf) soon that drops incremental entirely per my earlier point, to try and see what the impact on regular compilations it has. Obviously, not intending for that to be merged in any shape.</p>



<a name="272851795"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272851795" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cjgillot <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272851795">(Feb 22 2022 at 19:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="116122">simulacrum</span> <a href="#narrow/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation/near/272851426">said</a>:</p>
<blockquote>
<p>FWIW, I'm expecting to post a PR (for running perf) soon that drops incremental entirely per my earlier point, to try and see what the impact on regular compilations it has. Obviously, not intending for that to be merged in any shape.</p>
</blockquote>
<p>I expect a perf regression between 200% and 300% on incr-unchanged benchmarks (= pretty much the ratio full/incr-unchanged).  We may get &lt;10% back by dropping the weight of the query engine.</p>



<a name="272852194"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272852194" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cjgillot <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272852194">(Feb 22 2022 at 19:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310518">Jake</span> <a href="#narrow/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation/near/272851371">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="248906">cjgillot</span> <a href="#narrow/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation/near/272850883">said</a>:</p>
<blockquote>
<p>I'm not suggesting a re-implementation of the query system.  I'm suggesting to gradually stop using it, or restricted to some stages (trait selection?).</p>
</blockquote>
<p>Sorry, I should have been more clear. I didn't mean to imply that you were suggesting that, I was asking a separate question</p>
</blockquote>
<p>What would be the constraints of this re-implementation?  Dropping parallel-compiler cfg may simplify a lot of things, but I wouldn't expect it to have a very large effect on perf.</p>



<a name="272852809"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272852809" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272852809">(Feb 22 2022 at 19:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="248906">cjgillot</span> <a href="#narrow/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation/near/272852194">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="310518">Jake</span> <a href="#narrow/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation/near/272851371">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="248906">cjgillot</span> <a href="#narrow/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation/near/272850883">said</a>:</p>
<blockquote>
<p>I'm not suggesting a re-implementation of the query system.  I'm suggesting to gradually stop using it, or restricted to some stages (trait selection?).</p>
</blockquote>
<p>Sorry, I should have been more clear. I didn't mean to imply that you were suggesting that, I was asking a separate question</p>
</blockquote>
<p>What would be the constraints of this re-implementation?  Dropping parallel-compiler cfg may simplify a lot of things, but I wouldn't expect it to have a very large effect on perf.</p>
</blockquote>
<p>I was not thinking about perf, mostly just about correctness. People above seemed to feel that the complexity of the existing system was a problem - is this something that could be fixed be fixed by a ground up re-implementation, or is the complexity just inherent in the task? (ofc, whether this is a good idea even if the answer is yes is a different question)</p>



<a name="272853268"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272853268" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272853268">(Feb 22 2022 at 19:17)</a>:</h4>
<p>I think the complexity is inherent in the way that the current system needs to work</p>



<a name="272853364"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272853364" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272853364">(Feb 22 2022 at 19:18)</a>:</h4>
<p>We need to ensure that we always call the actual query functions (no caching in thread-locals / tcx), so that we properly register all dependencies</p>



<a name="272853455"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272853455" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272853455">(Feb 22 2022 at 19:19)</a>:</h4>
<p>Whenever we have any mutable global state in the compiler, we need to make sure it interacts properly with incremental complation (since one query could read a result written by a different query)</p>



<a name="272853602"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272853602" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272853602">(Feb 22 2022 at 19:20)</a>:</h4>
<p>Types like <code>DefId</code> cannot implement <code>Ord</code> in the expected way, since that leaks untracked state (the preciese <code>DefIndex</code> value). This transitively affects a large number of types containing a <code>DefId</code> (see <span class="user-mention" data-user-id="316352">@pierwill</span> 's work)</p>



<a name="272853745"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272853745" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272853745">(Feb 22 2022 at 19:21)</a>:</h4>
<p>Code inside <code>Decodable</code> impls is heavily restricted - it cannot invoke queries, since we may invoke the <code>Decodable</code> impl while decoding the result for another query (or even the same query!)</p>



<a name="272853794"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272853794" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272853794">(Feb 22 2022 at 19:21)</a>:</h4>
<p>Getting any of this wrong will lead to ICEs at best, and miscompilations at worse</p>



<a name="272853848"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272853848" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272853848">(Feb 22 2022 at 19:22)</a>:</h4>
<p>there are probably a bunch of other things that I'm not thinking of</p>



<a name="272853902"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272853902" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272853902">(Feb 22 2022 at 19:22)</a>:</h4>
<p>oh, yeah, the whole <code>Ident</code> impl of <code>PartialEq</code>/<code>Eq</code></p>



<a name="272853928"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272853928" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272853928">(Feb 22 2022 at 19:22)</a>:</h4>
<p>it's supposed to agree with <code>HashStable</code>, but the current impl ignores the <code>Span</code> location</p>



<a name="272853952"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272853952" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272853952">(Feb 22 2022 at 19:22)</a>:</h4>
<p>to fix that, I have a PR open creating an new trait <code>HashStableEq</code> with a ton of impls</p>



<a name="272854145"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272854145" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272854145">(Feb 22 2022 at 19:24)</a>:</h4>
<p>I think that the worst aspect by far is the infectious nature of this. If this was all 'confined' to a singlar part of the compiler, it would probably be manageable. For example, the codegen backends are very complex, but someone working on a separate part of the compiler (e.g. macro invocation) doesn't need to think about it at all</p>



<a name="272854190"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272854190" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272854190">(Feb 22 2022 at 19:24)</a>:</h4>
<p>However, virtually <em>every</em> part of the compiler needs to have its interactions with incr comp properly managed</p>



<a name="272854249"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272854249" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272854249">(Feb 22 2022 at 19:25)</a>:</h4>
<p>For example, there's a ton of logic around properly encoding/decoding <code>ExpnId</code>s and <code>SyntaxContext</code>s (which are created during parsing and expasion) into the incremental cache</p>



<a name="272854302"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272854302" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272854302">(Feb 22 2022 at 19:25)</a>:</h4>
<p>Trait selection has a weird 'anon query' thing to allow us to do global caching in a way that doesn't break incr comp</p>



<a name="272854317"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272854317" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272854317">(Feb 22 2022 at 19:25)</a>:</h4>
<p>and on and on</p>



<a name="272854418"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272854418" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272854418">(Feb 22 2022 at 19:26)</a>:</h4>
<p>This is difficult even for experienced contributors, and is probably a huge footgun for new contributors (though maybe not very much in practice, since newer contributors tend to make localized changs that don't add new global state)</p>



<a name="272854454"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272854454" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272854454">(Feb 22 2022 at 19:27)</a>:</h4>
<p>TL;DR - I would <em>love</em> to replace the current system with something that's much more self-contained</p>



<a name="272854611"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272854611" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272854611">(Feb 22 2022 at 19:28)</a>:</h4>
<p>Of course, what we <em>gain</em> by all of this complexity is the ability to do fine-grained re-use during incremental complation</p>



<a name="272854690"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272854690" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272854690">(Feb 22 2022 at 19:29)</a>:</h4>
<p>Knowing that we can re-use the optimized MIR for a function, for example, despite other modifications that have happened in the same file</p>



<a name="272854783"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272854783" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272854783">(Feb 22 2022 at 19:30)</a>:</h4>
<p>It's also worth noting that we're heavily constrained by the design of the Rust language itself</p>



<a name="272854876"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272854876" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272854876">(Feb 22 2022 at 19:30)</a>:</h4>
<p>In C/C++, you get a large amount of re-use and parallelism for free, since the code author is responsible for writing header files such that you can compile one <code>.c</code>/<code>.cpp</code> file without looking at any other <code>.c</code>/<code>.cpp</code> files</p>



<a name="272854992"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272854992" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272854992">(Feb 22 2022 at 19:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="248906">cjgillot</span> <a href="#narrow/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation/near/272851795">said</a>:</p>
<blockquote>
<p>I expect a perf regression between 200% and 300% on incr-unchanged benchmarks (= pretty much the ratio full/incr-unchanged).  We may get &lt;10% back by dropping the weight of the query engine.</p>
</blockquote>
<p>This definitely makes me curious what kinds of paradigm shifts would be needed to get that ratio up to like 20x (or, if I'm dreaming, 100x).  Is there anything about Rust itself that's forcing something to be awkward, and which removing (or heavily restricting) could help simplify the work needed?</p>
<p>EDIT: Thanks, <span class="user-mention silent" data-user-id="125294">Aaron Hill</span>, for writing an answer before I finished typing the question <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p>



<a name="272855011"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272855011" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272855011">(Feb 22 2022 at 19:31)</a>:</h4>
<p>In Rust, that burden is shifted to the compiler - allowing for things like cyclic dependencies between modules in the same crate, but also forcing us to parse + expand the entire crate in one go</p>



<a name="272855204"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272855204" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272855204">(Feb 22 2022 at 19:33)</a>:</h4>
<p>We converged on the same topic from two different directions :)</p>



<a name="272855458"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272855458" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272855458">(Feb 22 2022 at 19:35)</a>:</h4>
<p>I don't have much to contribute as a response, but this was interesting and helpful, thanks for sharing!</p>



<a name="272856184"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272856184" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272856184">(Feb 22 2022 at 19:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="125294">Aaron Hill</span> <a href="#narrow/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation/near/272855011">said</a>:</p>
<blockquote>
<p>In Rust, that burden is shifted to the compiler - allowing for things like cyclic dependencies between modules in the same crate, but also forcing us to parse + expand the entire crate in one go</p>
</blockquote>
<p>Would it be possible to first expand everything except function bodies and then incrementally expand function bodies individually as a separate step? Or can macros leak out of function bodies?</p>



<a name="272856315"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272856315" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> simulacrum <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272856315">(Feb 22 2022 at 19:42)</a>:</h4>
<p>you can impl traits inside function bodies, which are globally visible</p>



<a name="272856382"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272856382" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272856382">(Feb 22 2022 at 19:43)</a>:</h4>
<p>Sure, but I was talking about macro expansion, not typechecking.</p>



<a name="272856420"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272856420" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272856420">(Feb 22 2022 at 19:43)</a>:</h4>
<p>Some related conversation: <a href="https://github.com/rust-lang/rust/issues/65516">
[Edition vNext] Consider deprecating weird nesting of items
#65516 </a></p>



<a name="272856423"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272856423" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272856423">(Feb 22 2022 at 19:43)</a>:</h4>
<p>HIR lowering doesn't depend on which traits are implemented afaik.</p>



<a name="272856424"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272856424" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> simulacrum <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272856424">(Feb 22 2022 at 19:43)</a>:</h4>
<p>I think if you define a macro_rules! macro inside a function, it can be used anywhere latter in the file/crate</p>



<a name="272856488"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272856488" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> simulacrum <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272856488">(Feb 22 2022 at 19:44)</a>:</h4>
<p>but not 100% sure on that.</p>



<a name="272856501"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272856501" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272856501">(Feb 22 2022 at 19:44)</a>:</h4>
<p>The rules around <code>macro_rules!</code> importing are really weird</p>



<a name="272856602"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272856602" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272856602">(Feb 22 2022 at 19:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="116122">simulacrum</span> <a href="#narrow/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation/near/272856424">said</a>:</p>
<blockquote>
<p>I think if you define a macro_rules! macro inside a function, it can be used anywhere latter in the file/crate</p>
</blockquote>
<p>Looks like it can't. <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=5ef4869ffeb87a178627f2b3249284cc">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=5ef4869ffeb87a178627f2b3249284cc</a></p>



<a name="272856604"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272856604" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272856604">(Feb 22 2022 at 19:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="116122">simulacrum</span> <a href="#narrow/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation/near/272856424">said</a>:</p>
<blockquote>
<p>I think if you define a macro_rules! macro inside a function, it can be used anywhere latter in the file/crate</p>
</blockquote>
<p>Looks like that's no longer true, at least in 2021: <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=94f45d831cf93be23116d975494adda7">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=94f45d831cf93be23116d975494adda7</a></p>



<a name="272856655"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272856655" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272856655">(Feb 22 2022 at 19:45)</a>:</h4>
<p>Same in the 2015 edition.</p>



<a name="272856687"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272856687" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272856687">(Feb 22 2022 at 19:45)</a>:</h4>
<p>Oh, but maybe you can put a <code>#[macro_use] extern crate foo</code> inside a function body?</p>



<a name="272856809"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272856809" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cjgillot <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272856809">(Feb 22 2022 at 19:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="125270">scottmcm</span> <a href="#narrow/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation/near/272856604">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="116122">simulacrum</span> <a href="#narrow/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation/near/272856424">said</a>:</p>
<blockquote>
<p>I think if you define a macro_rules! macro inside a function, it can be used anywhere latter in the file/crate</p>
</blockquote>
<p>Looks like that's no longer true, at least in 2021: <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=94f45d831cf93be23116d975494adda7">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=94f45d831cf93be23116d975494adda7</a></p>
</blockquote>
<p>Works if you <code>#[macro_export]</code>...</p>



<a name="272856826"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272856826" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272856826">(Feb 22 2022 at 19:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="125270">scottmcm</span> <a href="#narrow/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation/near/272856687">said</a>:</p>
<blockquote>
<p>Oh, but maybe you can put a <code>#[macro_use] extern crate foo</code> inside a function body?</p>
</blockquote>
<div class="codehilite"><pre><span></span><code>error[E0468]: an `extern crate` loading macros must be at the crate root
 --&gt; src/lib.rs:2:18
  |
2 |     #[macro_use] extern crate serde_derive;
  |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^

For more information about this error, try `rustc --explain E0468`.
error: could not compile `playground` due to previous error
</code></pre></div>



<a name="272856878"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272856878" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272856878">(Feb 22 2022 at 19:47)</a>:</h4>
<p><span class="user-mention silent" data-user-id="248906">cjgillot</span> <a href="#narrow/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation/near/272856809">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="125270">scottmcm</span> <a href="#narrow/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation/near/272856604">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="116122">simulacrum</span> <a href="#narrow/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation/near/272856424">said</a>:</p>
<blockquote>
<p>I think if you define a macro_rules! macro inside a function, it can be used anywhere latter in the file/crate</p>
</blockquote>
<p>Looks like that's no longer true, at least in 2021: <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=94f45d831cf93be23116d975494adda7">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=94f45d831cf93be23116d975494adda7</a></p>
</blockquote>
<p>Works if you <code>#[macro_export]</code>...</p>
</blockquote>
<p>That's really unfortunate</p>



<a name="272856918"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272856918" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272856918">(Feb 22 2022 at 19:47)</a>:</h4>
<p>Can we crater disallowing this?</p>



<a name="272857036"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272857036" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272857036">(Feb 22 2022 at 19:48)</a>:</h4>
<p>IIRC, part of the discussion around petrochenkov's <code>pub macro_rules!</code> PR was related to the fact that you can do weird shadowing of <code>macro_rules!</code> in a way that couldn't easily be replicated otherwise</p>



<a name="272857065"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272857065" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272857065">(Feb 22 2022 at 19:48)</a>:</h4>
<p>I can't remember if anyone was found to actually be using that</p>



<a name="272857079"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272857079" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272857079">(Feb 22 2022 at 19:48)</a>:</h4>
<p>but this seems like a similar case, conceptually</p>



<a name="272857184"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272857184" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272857184">(Feb 22 2022 at 19:49)</a>:</h4>
<p>Is there any case where that shadowing would be useful to leak out of a function?</p>



<a name="272857510"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272857510" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272857510">(Feb 22 2022 at 19:52)</a>:</h4>
<p>I'm sure someone like dtolany or yandros could make something that used it :) I have no idea whether or not there's any practical use-case that <em>require</em>s it, though</p>



<a name="272857578"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272857578" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cjgillot <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272857578">(Feb 22 2022 at 19:53)</a>:</h4>
<p>This discussion is oscillating back towards end-to-end queries :)</p>



<a name="272858093"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272858093" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272858093">(Feb 22 2022 at 19:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="133247">bjorn3</span> <a href="#narrow/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation/near/272856918">said</a>:</p>
<blockquote>
<p>Can we crater disallowing this?</p>
</blockquote>
<p>I went and <a href="#narrow/stream/213817-t-lang/topic/Deprecating.20macro.20scoping.20shenanigans/near/272857859">made a lang thread</a> about "just say no"ing this.  I'd love to find out that nobody is using it and just make it disallowed.</p>



<a name="272872919"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272872919" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cjgillot <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272872919">(Feb 22 2022 at 22:04)</a>:</h4>
<p>To continue on the discussion, a small write-up of what would be required to move towards staged compilation.  This does not go all the way, but paves some steps.  The hard part is the remaining steps keeping typeck &amp; cfte self-consistent.</p>



<a name="272872926"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272872926" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cjgillot <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272872926">(Feb 22 2022 at 22:04)</a>:</h4>
<p><a href="https://hackmd.io/WX8ioGMFSZ2ErL_m_3QTsw?view">https://hackmd.io/WX8ioGMFSZ2ErL_m_3QTsw?view</a></p>



<a name="272906537"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272906537" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272906537">(Feb 23 2022 at 05:29)</a>:</h4>
<p>A couple of random thoughts:</p>



<a name="272906543"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272906543" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272906543">(Feb 23 2022 at 05:29)</a>:</h4>
<ul>
<li>I find the query system very hard to understand. So many layers of macros.</li>
</ul>



<a name="272906649"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272906649" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272906649">(Feb 23 2022 at 05:31)</a>:</h4>
<ul>
<li>I've always felt like the incr. comp. approach doesn't align nicely with parallel compilation. Making a single global data structure (the incr. comp. cache) the bottleneck for everything make things hard for parallel. Sure you can shard the tables, but that only gets you so far.</li>
</ul>



<a name="272925234"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272925234" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272925234">(Feb 23 2022 at 09:48)</a>:</h4>
<p>Another thing that would be nice to improve would be disk space usage. This is the reason I currently don't use incr comp when building rust on my system.</p>



<a name="272926500"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272926500" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272926500">(Feb 23 2022 at 09:59)</a>:</h4>
<p>If I can add my two cents: </p>
<p>I don't know if this is intrinsic to query based approaches or just Rust's implementation, but a limitation I encounter fairly often is the 'immutability' of inputs. For my usecases of the API, I find myself wanting to add trait implementations, or even create DefIds (for 'synthetic' items) which don't correspond to source code the user wrote. With a more traditional pass based compiler I feel like I could sneak in between two passes to add information to the relevant tables. </p>
<p>On the other hand, I am worried that a pass based approach would have a more coarse-grained API: ie where do the passes end? I find myself needing to stop different items at different stages: HIR, THIR, MIR depending on what I intend to do with them.</p>



<a name="272932574"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272932574" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> mw <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272932574">(Feb 23 2022 at 10:57)</a>:</h4>
<p>Some thoughts:</p>
<ul>
<li>I think the query system as implemented right now is not in good shape. It is incredibly hard to understand what's going on internally (even though its basically just a system that allows for caching the results of functions). Some of that is due to parallel support, some of it is just because it has grown over the years without a major trim-down and gone through many performance optimizations that regressed readability. It probably could be moved to a completely external library like Salsa.</li>
<li>I think one of main problems of the current system is that the abstractions are so leaky. Everything still has access to what is in Session and there are many other things in the tcx that should really only be accessible as a query. And types like Span and DefId, which are constructed before the query system kicks in, just don't fit the model -- these are things that probably would never have shown up as an issue for something that was written atop of e.g. Salsa from the start.</li>
<li>I think query-based / pull-based architectures have a lot going for them. They force you to make data dependencies explicit. One can read a query provider and look at what other queries it calls until one reaches the inputs. Having a common kind of API, as <span class="user-mention" data-user-id="310518">@Jake</span> mentions is a big plus. A query-based architecture also makes it "easy enough" to synchronize parallel evaluation of things because all computations are explicitly structured into a DAG. And you can only partially compile a crate, as <span class="user-mention" data-user-id="239881">@Josh Triplett</span> mentions.</li>
<li>Pull-based architectures also have their downsides. One kind of has to think about everything backwards. And it is hard to know when resources are not needed anymore and thus can be dropped.</li>
<li>IIRC, at the time when the query system was adopted, it was still the plan to have rustc be an LSP server. So there was no real alternative to having a fine-grained on-demand system. I don't think this a requirement anymore.</li>
<li>A pass-based architecture sounds appealing if it can be kept simple. There is a risk though, that it would end up as a complex mix of forward passes and ad-hoc on-demand evaluation, just without a clear governing structure, like a query system (in theory) can provide.</li>
<li>It would really be awesome if one could view the compiler as a series of passes, each with a clear inputs and outputs.</li>
<li>Independently of pass-based or on-demand, dealing with incremental compilation introduces a strong requirement for producing deterministic and "stable" intermediate artifacts and being able to match values between compilation sessions. One still has to know if something from an on-disk cache can be re-used or not. Getting rid of queries would not solve things like DefId drift. On the other hand, there might be simpler ways of keeping things stable. </li>
<li>I suspect that doing any kind of interning of complex values actually introduces some of the same constraints that we have for incr. comp. at the moment, like <code>Eq</code> not ignoring parts of the interned value. The current incr. comp. system however makes it much more likely that a failure of upholding these constraints turns into an ICE.</li>
<li>For a pass-based approach that supports parallelism one will likely want to write most data transformations as side-effect-free functions that don't access global state. A which point you are pretty close to a query system :)</li>
<li>Many of the current system's problems stem from dependency tracking, not from being on-demand, I think. A pass-based approach that also tries to do dependency tracking would have to solve the same problems.</li>
<li>Many of our current problems also stem from refactoring the compiler in-place. That would also be a problem for any other kind of global refactoring.</li>
</ul>



<a name="272969778"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272969778" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272969778">(Feb 23 2022 at 16:06)</a>:</h4>
<p><span class="user-mention" data-user-id="124287">@mw</span> I had the impression that the long-term plan was for rustc and r-a to share more and more code?</p>



<a name="272969805"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272969805" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272969805">(Feb 23 2022 at 16:06)</a>:</h4>
<p>Is that not still a goal?</p>



<a name="272976984"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272976984" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272976984">(Feb 23 2022 at 16:57)</a>:</h4>
<p>Having rustc and r-a share more code does not necessarily imply that they share the same way of implementing incremental compilation. If anything they probably need a different way. Rust-analyzer needs to be as lazy as possible up to ignoring any errors for not currently open files, while rustc needs to at least check for errors in the whole crate and more eagerly calculate things.</p>



<a name="272977455"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272977455" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272977455">(Feb 23 2022 at 17:00)</a>:</h4>
<p>I think the parts shared between rustc and r-a could be externally driven to do one unit of work. It is then up to rustc and r-a do run the code either always (rustc) or only when necessary (r-a)</p>



<a name="272978532"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272978532" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cjgillot <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272978532">(Feb 23 2022 at 17:06)</a>:</h4>
<p>We probably shouldn't consider fully dropping incremental compilation, just reform which flavour we prefer it.<br>
We are actually discussion with two orthogonal questions:</p>
<ul>
<li>code execution: pull-based (the current system) vs push-based (explicit calls which are eventually skipped);</li>
<li>dependency handling: registration-based (the current system) vs forward-declared (a closed list of dependencies a query is allowed to use at will).</li>
</ul>
<p>On the code execution side:<br>
Pull-based execution allows to re-compute information just-in-time when required, while push-based execution can only skip computations if the value can be loaded from disk.<br>
OTOH, pull-based makes execution order unpredictable and does not handle cycles, while push-based execution allows to reason about the order of execution, and allows to handle cycles explicitly. For instance, trait selection switches from pull- to push-based execution to handle cycles.<br>
Re-implementation of the parallel compiler would be much easier with a push-based compiler than with the pull-based version: we know what is executed, when it is executed, and we don't have to detect cycles.</p>
<p>On dependency handling:<br>
Registration-based system needs to be able to exhaust all possible data dependencies, where code basically rely on a global <code>TyCtxt</code> handling everything.<br>
Forward-declared dependencies are opt-in, and the available information each query can access is restricted. This is much more cumbersome to work with, but the abstraction is more robust.</p>



<a name="272980438"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272980438" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> simulacrum <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272980438">(Feb 23 2022 at 17:19)</a>:</h4>
<p>perf results for deleting most of the incremental code - <a href="https://perf.rust-lang.org/compare.html?start=c651ba8a542c7d89b271efbf024a31091c824f4b&amp;end=08f996275290797d9c0192603890eb7ae11d7ebd">https://perf.rust-lang.org/compare.html?start=c651ba8a542c7d89b271efbf024a31091c824f4b&amp;end=08f996275290797d9c0192603890eb7ae11d7ebd</a></p>



<a name="272980542"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272980542" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272980542">(Feb 23 2022 at 17:19)</a>:</h4>
<p>So up to 4% wins. Not a whole lot.</p>



<a name="272980702"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272980702" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272980702">(Feb 23 2022 at 17:20)</a>:</h4>
<p>It does save a minute (8%) in compiling rustc a single crate at a time though.</p>



<a name="272981124"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272981124" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> simulacrum <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272981124">(Feb 23 2022 at 17:23)</a>:</h4>
<p>I suspect there's a long tail of removing the duplicate hashmaps that incremental semi-forces on us due to the caching of 'trivial' queries that consist of just a hashmap lookup</p>



<a name="272981169"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/272981169" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> simulacrum <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#272981169">(Feb 23 2022 at 17:23)</a>:</h4>
<p>though some of that can be mitigated without actually deleting code, it's just more work to do so.</p>



<a name="273069352"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/273069352" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> mw <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#273069352">(Feb 24 2022 at 10:10)</a>:</h4>
<p><span class="user-mention silent" data-user-id="239881">Josh Triplett</span> <a href="#narrow/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation/near/272969778">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="124287">mw</span> I had the impression that the long-term plan was for rustc and r-a to share more and more code?<br>
Is that not still a goal?</p>
</blockquote>
<p>First a disclaimer: I don't set goals or have special insight into what the "plans" are. I'm just putting down my personal thoughts. As far as I know, the roadmap discussion on the other thread is the closest thing to a plan that we have. </p>
<p>With that in mind, I agree with <span class="user-mention silent" data-user-id="133247">bjorn3</span>'s statement: re-using code between the two projects can happen at a different level, by implementing complex logic in an environment-independent manner (as I think e.g. Chalk attempts to do). I think this has been referred to as "librarification" of the compiler. And I think that would be a good way to go about it (because things can be tested in isolation and implementation details don't creep into the logic), but I guess it's non-trivial to properly abstract the environment away in many cases.</p>



<a name="273272750"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/273272750" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cjgillot <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#273272750">(Feb 25 2022 at 19:16)</a>:</h4>
<p>Triggered by a discussion with <span class="user-mention" data-user-id="312719">@Xavier Denis</span>, extending the discussion with hybrid incr. comp. models:</p>
<blockquote>
<p>The (pull-based, registration) and (push-based, declaration) models kind of work well together. However, I imagine the hybrids as follows:<br>
- push-based + registration model: each query would be invoked in two ways:<br>
   compute which calls the backing function and stores its result, and get which recovers the result but does not compute it.<br>
   Calling compute in the right order would be the responsibility of an orchestrator. A query would not be allowed to call compute, only the orchestrator can. This can be enshrined into types, having a OrchestrationCtxtand a DataCtxt in place of the TyCtxt. When compute is called, the dependency graph is probed to see if the node is green. If it is and the value can be recovered from disk, the computation is skipped.<br>
   Calling get is only allowed from queries. When the data has not been computed yet, get would return None. Dependency handling would happen in calls to get, like it does now. We could add the possibility for a query to push a result into another one as a side effect, with a specific marker for dependency handling (this allows to handle cycles).<br>
- pull-based + forward declaration: each query would list all of its dependencies in a separate function, and the actual query code would ICE if it accesses information outside of this list. (There may be a better way to do this, for instance to have compile-time checks, but I haven't tought of it yet.) As the list of dependencies is known in advance, the query system can walk the dependency graph, and detect cycles before calling any computation. This would allow to have dedicated code to handle the cycle.</p>
</blockquote>



<a name="273274626"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/273274626" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#273274626">(Feb 25 2022 at 19:32)</a>:</h4>
<p>agreed that there should be only one set of "red" computational functions, and agreed that we should have much more representation of "ambiguous" state if we really want to go all Prolog on everything.</p>



<a name="273275022"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/273275022" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#273275022">(Feb 25 2022 at 19:36)</a>:</h4>
<p>It should be possible, for debugging purposes if nothing else, however, for queries to determine what unsatisfied edges remain for a computation.</p>



<a name="273275319"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/273275319" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cjgillot <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#273275319">(Feb 25 2022 at 19:38)</a>:</h4>
<p>This would also be useful for profiling.  One blind spot we have right now is profiling the dependency graph, especially: what are the "almost useless" dependency edges we have in it.</p>



<a name="273719060"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/273719060" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#273719060">(Mar 01 2022 at 22:10)</a>:</h4>
<p>To move this forward: What would be a good way to start prototyping this?</p>



<a name="273800726"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/273800726" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cjgillot <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#273800726">(Mar 02 2022 at 12:47)</a>:</h4>
<p>Once we make a decision, the migration can be made step by step, starting with lowering and pushing towards type checking. The work on the incr. comp. infra can be done at the same time, using already-existing tools for dependency tracking.<br>
The question is merely to provide an accurate description of the trade-off to decide upon.</p>



<a name="273801675"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/273801675" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pnkfelix <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#273801675">(Mar 02 2022 at 12:56)</a>:</h4>
<p>Our next T-compiler planning meeting is on <time datetime="2022-03-11T15:00:00Z">2022-03-11T10:00:00-05:00</time> . So,  one possible (and very easy) next step would be to have a <em>meeting proposal</em> ready by that date (note, "meeting", not the full document that drives the meeting). (We can of course work on making forward progress well before that time, but I think a steering meeting will be necessary before we take any major action here.)</p>



<a name="273801764"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/273801764" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pnkfelix <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#273801764">(Mar 02 2022 at 12:57)</a>:</h4>
<p>like all meeting proposals, it would need 1. what is the meeting about (which, in this case, is probably a matter of identifying a suitable <em>restriction</em>/<em>subset</em> of the scope of the possible topic areas), and 2. specifying <em>who</em> is going to own creating the document that will drive the meeting.</p>



<a name="274127732"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/274127732" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#274127732">(Mar 04 2022 at 13:28)</a>:</h4>
<p>I have another stone to cast in the pit, as an external api user I make heavy use of the laziness that the query system provides: in particular I need to be able to handle functions which don’t satisfy the borrow checker, which I do by only requesting thir for those functions. At the same time, I request mir for different functions. </p>
<p>If we switch to a pass &amp; table based approach, it would be very important to me and other similar users that it be possible to mutate the tables between passes (to force certain definitions to get “skipped” by later passes)</p>



<a name="274129047"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/274129047" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#274129047">(Mar 04 2022 at 13:37)</a>:</h4>
<p>What functions don't pass borrowck?</p>



<a name="274129969"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/274129969" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#274129969">(Mar 04 2022 at 13:44)</a>:</h4>
<p>I encode specifications as rust functions but don’t enforce single ownership on them as they are not program functions</p>



<a name="274130067"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/274130067" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#274130067">(Mar 04 2022 at 13:45)</a>:</h4>
<p>I do this as I need access to rust’s resolution and type checking / inference</p>



<a name="274130139"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/274130139" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xavier Denis <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#274130139">(Mar 04 2022 at 13:45)</a>:</h4>
<p>And until a future in which the rust compiler is truly librarified it’s hard to develop a satisfactory alternative</p>



<a name="274138271"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/274138271" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> mw <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#274138271">(Mar 04 2022 at 14:45)</a>:</h4>
<p>FYI, I just posted <a href="https://github.com/rust-lang/compiler-team/issues/490">this meeting proposal</a> for discussing concrete ways of improving the state of the current system in the short-to-medium term.</p>



<a name="274138795"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/274138795" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> mw <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#274138795">(Mar 04 2022 at 14:49)</a>:</h4>
<p>^^^ cc <span class="user-mention" data-user-id="116083">@pnkfelix</span> &amp; <span class="user-mention" data-user-id="125250">@Wesley Wiser</span></p>



<a name="274151081"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/274151081" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bstrie <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#274151081">(Mar 04 2022 at 16:08)</a>:</h4>
<p>mind if I copy out that hackmd into a read-only medium and share it more widely? I think after seeing incremental get disabled twice a lot of people at large are curious about why incremental is so difficult, and getting to peer behind the curtain might be instructive</p>



<a name="274151383"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/274151383" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> mw <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#274151383">(Mar 04 2022 at 16:11)</a>:</h4>
<p>idk, it's just a very rough brain dump</p>



<a name="274151589"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/future%20of%20incremental%20compilation/near/274151589" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> mw <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/future.20of.20incremental.20compilation.html#274151589">(Mar 04 2022 at 16:13)</a>:</h4>
<p>and it hasn't had input from other folks working on incr. comp. yet. Maybe it's better to wait until after it has been discussed in the planning meeting.</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>