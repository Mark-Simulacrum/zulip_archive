<html>
<head><meta charset="utf-8"><title>Excessive monomorphization of `BitSet`? · t-compiler · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/index.html">t-compiler</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Excessive.20monomorphization.20of.20.60BitSet.60.3F.html">Excessive monomorphization of `BitSet`?</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="272222100"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Excessive%20monomorphization%20of%20%60BitSet%60%3F/near/272222100" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Excessive.20monomorphization.20of.20.60BitSet.60.3F.html#272222100">(Feb 17 2022 at 07:25)</a>:</h4>
<p><code>BitSet&lt;T&gt;</code> is defined <a href="https://github.com/rust-lang/rust/blob/master/compiler/rustc_index/src/bit_set.rs#L91-L95">here</a>. The <code>T</code> must impl <code>Idx</code> and in practice it's always a <code>newtype_index</code>.</p>
<p>My question: does this kind of type cause <code>BitSet</code>'s methods to be monomorphized for every different <code>BitSet&lt;T&gt;</code>? Because they're all going to be identical...</p>



<a name="272222213"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Excessive%20monomorphization%20of%20%60BitSet%60%3F/near/272222213" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> lcnr <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Excessive.20monomorphization.20of.20.60BitSet.60.3F.html#272222213">(Feb 17 2022 at 07:26)</a>:</h4>
<p>yes, it does. even with the current impl of polymorphization this would still happen</p>



<a name="272222249"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Excessive%20monomorphization%20of%20%60BitSet%60%3F/near/272222249" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> lcnr <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Excessive.20monomorphization.20of.20.60BitSet.60.3F.html#272222249">(Feb 17 2022 at 07:27)</a>:</h4>
<p>is the impact big enough that it would make sense to add a non generic bitset version?</p>



<a name="272222262"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Excessive%20monomorphization%20of%20%60BitSet%60%3F/near/272222262" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> lcnr <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Excessive.20monomorphization.20of.20.60BitSet.60.3F.html#272222262">(Feb 17 2022 at 07:27)</a>:</h4>
<p>(which is then used by the generic bitsets)</p>



<a name="272250756"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Excessive%20monomorphization%20of%20%60BitSet%60%3F/near/272250756" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Excessive.20monomorphization.20of.20.60BitSet.60.3F.html#272250756">(Feb 17 2022 at 12:19)</a>:</h4>
<p>Not sure, I haven't measured it</p>



<a name="272250808"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Excessive%20monomorphization%20of%20%60BitSet%60%3F/near/272250808" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Excessive.20monomorphization.20of.20.60BitSet.60.3F.html#272250808">(Feb 17 2022 at 12:19)</a>:</h4>
<p>It's unfortunate. I guess <code>IndexVec</code> will have the same problem.</p>



<a name="272250896"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Excessive%20monomorphization%20of%20%60BitSet%60%3F/near/272250896" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Excessive.20monomorphization.20of.20.60BitSet.60.3F.html#272250896">(Feb 17 2022 at 12:20)</a>:</h4>
<p>"newtypes are great, they promote type safety and they're zero cost"... <br>
"well, not quite..."</p>



<a name="272251512"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Excessive%20monomorphization%20of%20%60BitSet%60%3F/near/272251512" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jake <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Excessive.20monomorphization.20of.20.60BitSet.60.3F.html#272251512">(Feb 17 2022 at 12:26)</a>:</h4>
<p>Is it possible that LLVM (or the linker? I forget what's responsible for this) is de-duplicating the functions?</p>



<a name="272252353"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Excessive%20monomorphization%20of%20%60BitSet%60%3F/near/272252353" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Excessive.20monomorphization.20of.20.60BitSet.60.3F.html#272252353">(Feb 17 2022 at 12:35)</a>:</h4>
<p>Quite possible, but even if that's the case it'll still be slowing down compilation</p>



<a name="272262883"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Excessive%20monomorphization%20of%20%60BitSet%60%3F/near/272262883" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Excessive.20monomorphization.20of.20.60BitSet.60.3F.html#272262883">(Feb 17 2022 at 14:01)</a>:</h4>
<p>How hard would it be to make some intrinsic or type magic that could give a type-erased version of a type?  I've been looking at things like <code>reverse</code> and <code>swap_with_slice</code> too, where it's a real waste to emit them for <code>u32</code>+<code>i32</code>+<code>f32</code>+...</p>
<p>(Of course the nicest version would be a compiler feature to just automatically do that if it can tell there's no bound in use other than <code>Sized</code>, but that's probably hard.)</p>



<a name="272266496"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Excessive%20monomorphization%20of%20%60BitSet%60%3F/near/272266496" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> lqd <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Excessive.20monomorphization.20of.20.60BitSet.60.3F.html#272266496">(Feb 17 2022 at 14:27)</a>:</h4>
<p>that kinda sounds like polymorphization ? (david and lcnr are working on it; it has a lot of potential :)</p>



<a name="272281845"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Excessive%20monomorphization%20of%20%60BitSet%60%3F/near/272281845" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Excessive.20monomorphization.20of.20.60BitSet.60.3F.html#272281845">(Feb 17 2022 at 16:07)</a>:</h4>
<p>LLVM opaque pointers may eventually make it more likely for this kind of duplication to be merged</p>



<a name="272350537"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Excessive%20monomorphization%20of%20%60BitSet%60%3F/near/272350537" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Gary Guo <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Excessive.20monomorphization.20of.20.60BitSet.60.3F.html#272350537">(Feb 18 2022 at 01:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="125270">scottmcm</span> <a href="#narrow/stream/131828-t-compiler/topic/Excessive.20monomorphization.20of.20.60BitSet.60.3F/near/272262883">said</a>:</p>
<blockquote>
<p>(Of course the nicest version would be a compiler feature to just automatically do that if it can tell there's no bound in use other than <code>Sized</code>, but that's probably hard.)</p>
</blockquote>
<p>Why would it be hard?</p>



<a name="272350766"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Excessive%20monomorphization%20of%20%60BitSet%60%3F/near/272350766" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Gary Guo <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Excessive.20monomorphization.20of.20.60BitSet.60.3F.html#272350766">(Feb 18 2022 at 02:01)</a>:</h4>
<p>If ABI matches and <code>Sized</code> is the only bound then the compiler should be have enough info to dedup..</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>