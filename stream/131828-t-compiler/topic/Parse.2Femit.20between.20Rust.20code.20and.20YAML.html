<html>
<head><meta charset="utf-8"><title>Parse/emit between Rust code and YAML · t-compiler · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/index.html">t-compiler</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Parse.2Femit.20between.20Rust.20code.20and.20YAML.html">Parse/emit between Rust code and YAML</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="268935365"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Parse/emit%20between%20Rust%20code%20and%20YAML/near/268935365" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Samuel Marks <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Parse.2Femit.20between.20Rust.20code.20and.20YAML.html#268935365">(Jan 22 2022 at 04:08)</a>:</h4>
<p>To parse and emit Rust code, what's the current recommendation? - I'm about to breathe life into this old repo <a href="https://github.com/offscale/cdd-rust">https://github.com/offscale/cdd-rust</a> - that had a bunch of <a href="https://github.com/dtolnay/syn"><code>syn</code></a> usage - or my slightly newer repo that was all custom code - <a href="https://github.com/offscale/cdd-openapi">https://github.com/offscale/cdd-openapi</a></p>
<p>The idea is to:</p>
<p>0. parse a language/framework (Rust with diesel + actix was the previous [planned] combination);<br>
   1. extract pertinent information (in this case, JSON schema for the [diesel] 'models' extraction, and any exposed routes—e.g., with actix—and related tests &amp; mocks &amp; docs);<br>
   2. generate a new OpenAPI schema from this structure.</p>
<p>Then in reverse, support this workflow:</p>
<div class="codehilite"><pre><span></span><code>0. Take OpenAPI schema as input;
1. Either:
    a. Existing codebase:
        i. parse existing codebase;
        ii. merge new changes matching existing structure to expected structure (OpenAPI in this scenario is the &#39;gold standard&#39;);
    b. Nonexistent codebase:
        i. Generate boilerplate + CRUD API endpoints + tests &amp; mocks + docs matching OpenAPI schema… potentially using  fancy emitter library but potentially just using simple string templates.
</code></pre></div>

<p>Oh and I'll probably CC0 the project at some point… it's currently (Apache-2.0 OR MIT). <strong>Which crates would you recommend depending on to achieve these aforementioned goals?</strong></p>
<p>Thanks for your insights</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>