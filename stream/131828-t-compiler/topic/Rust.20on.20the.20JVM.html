<html>
<head><meta charset="utf-8"><title>Rust on the JVM · t-compiler · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/index.html">t-compiler</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Rust.20on.20the.20JVM.html">Rust on the JVM</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="251074458"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Rust%20on%20the%20JVM/near/251074458" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> ruster <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Rust.20on.20the.20JVM.html#251074458">(Aug 28 2021 at 18:44)</a>:</h4>
<p>I'm probably missing something obvious but what exactly is the reason that there are seemingly no plans to have inbuilt support in the compiler to compile Rust to run on the Java virtual machine? Is there something that makes Rust fundamentally unsuitable to bring to Java platforms? I mean just look at something like Kotlin. It can run on the JVM and natively. I know there's stuff like <a href="https://github.com/jni-rs/jni-rs">https://github.com/jni-rs/jni-rs</a> which surely helps (although it seems its development has slightly ceased) but I don't understand why having inbuilt JVM compiler support right in <code>rustc</code> isn't a big priority considering that the Java market is so huge. Rust would literally gain access to an entirely new big market.<br>
I mean, just imagine if Rust couldn't just be a replacement for languages like C or C++ and others but even for a language as widely used as Java.</p>



<a name="251074808"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Rust%20on%20the%20JVM/near/251074808" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Rust.20on.20the.20JVM.html#251074808">(Aug 28 2021 at 18:51)</a>:</h4>
<p>Essentially anything that can run a JVM can also be targeted for native Rust compilation. And JVM code can call to native code already. So I don't understand why you can't already use Rust as part of a JVM project.</p>
<p>For similar situations: you can call a native compiled Rust library from Python and Erlang/Elixir.</p>



<a name="251074970"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Rust%20on%20the%20JVM/near/251074970" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Rust.20on.20the.20JVM.html#251074970">(Aug 28 2021 at 18:54)</a>:</h4>
<p>Could you elaborate on what you see as the benefits of being compiled to JVM byte code as opposed to just being called via JNI? Do you see it as a portability issue?</p>



<a name="251075110"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Rust%20on%20the%20JVM/near/251075110" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> ruster <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Rust.20on.20the.20JVM.html#251075110">(Aug 28 2021 at 18:57)</a>:</h4>
<p>Hmm I suppose you are right but then why can't we use the same argument for Kotlin? Why didn't Kotlin only implement native support and then have itself just be called via JNI?</p>



<a name="251075193"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Rust%20on%20the%20JVM/near/251075193" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> ruster <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Rust.20on.20the.20JVM.html#251075193">(Aug 28 2021 at 18:59)</a>:</h4>
<p>For one, there's an overhead. And also I'm pretty sure making use of the existing Java ecosystem is harder through JNI compared to if Rust were compiled to JVM byte code.</p>



<a name="251075347"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Rust%20on%20the%20JVM/near/251075347" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> ruster <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Rust.20on.20the.20JVM.html#251075347">(Aug 28 2021 at 19:01)</a>:</h4>
<p>And if Rust had first-class support for Java, actual Java developers would also see and consider it more, simply for that reason.<br>
If Kotlin had only native support and had just said "just call me through JNI, no need to compile me to Java byte code" then I doubt as much Java code would have been rewritten in Kotlin as it has.<br>
And again, I'm pretty sure easy access to the Java ecosystem (which is a huge one) is harder to do only through JNI.</p>



<a name="251075762"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Rust%20on%20the%20JVM/near/251075762" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Rust.20on.20the.20JVM.html#251075762">(Aug 28 2021 at 19:09)</a>:</h4>
<p>Compiling rust to jvm is difficult to say the least, and nearly impossible without emulating memory (which is highly inefficient).</p>



<a name="251075793"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Rust%20on%20the%20JVM/near/251075793" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> ruster <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Rust.20on.20the.20JVM.html#251075793">(Aug 28 2021 at 19:09)</a>:</h4>
<p>Can you elaborate on that? Will Rust be required to be GCed when it's compiled to the JVM?</p>



<a name="251075870"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Rust%20on%20the%20JVM/near/251075870" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Rust.20on.20the.20JVM.html#251075870">(Aug 28 2021 at 19:10)</a>:</h4>
<p>I (attempted) to write a C/++ compiler to JVM byte code, and while I was unsuccessful, I noted that it could be done reasonably efficiently by exploiting strict aliasing. Rust does not have similar requirements, and rather treats memory as a flat object space (which you can read and write as any type you choose, provided the validity invariants remain intact).</p>



<a name="251075875"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Rust%20on%20the%20JVM/near/251075875" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lokathor <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Rust.20on.20the.20JVM.html#251075875">(Aug 28 2021 at 19:10)</a>:</h4>
<p>First I will say that Kotlin started as a JVM language, "java but better" essentially, and Rust did not. So what's good for Kotlin isn't necessarily good for Rust.</p>
<p>Second I will echo what Connor just said: Rust and Java have <em>radically</em> different ideas of how the universe works, and you would be very very limited trying to map large portions of one onto the other. The JNI works because you transmit through the very tiny, limited interface of the C ABI</p>



<a name="251075977"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Rust%20on%20the%20JVM/near/251075977" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> ruster <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Rust.20on.20the.20JVM.html#251075977">(Aug 28 2021 at 19:12)</a>:</h4>
<p>Hmm, then I suppose the problem will indeed be that Rust is fundamentally unsuitable to run on the JVM with acceptable performance. That's a bummer.</p>



<a name="251075996"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Rust%20on%20the%20JVM/near/251075996" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Rust.20on.20the.20JVM.html#251075996">(Aug 28 2021 at 19:13)</a>:</h4>
<p>If I write 4 bytes as a float in C++, I can't just read them as an int, so I can internally store it as a float, and use pointers that only act properly on floats. In rust, I can store an f32 then read it as an i32.</p>



<a name="251076010"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Rust%20on%20the%20JVM/near/251076010" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Connor Horman <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Rust.20on.20the.20JVM.html#251076010">(Aug 28 2021 at 19:13)</a>:</h4>
<p>There isn't a reasonable way of doing that, other than storing the f32 in a large byte[].</p>



<a name="251076092"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Rust%20on%20the%20JVM/near/251076092" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> ruster <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Rust.20on.20the.20JVM.html#251076092">(Aug 28 2021 at 19:15)</a>:</h4>
<p>I see. The environments are too different after all. To make Rust work on the JVM in a nice manner with acceptable performance it would probably require breaking changes that would have to change the whole language which will obviously not happen.</p>



<a name="251079132"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Rust%20on%20the%20JVM/near/251079132" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Rust.20on.20the.20JVM.html#251079132">(Aug 28 2021 at 20:08)</a>:</h4>
<p>I think graalvm can run llvm-ir and thus possibly rust.</p>



<a name="251079174"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Rust%20on%20the%20JVM/near/251079174" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tglman <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Rust.20on.20the.20JVM.html#251079174">(Aug 28 2021 at 20:09)</a>:</h4>
<p>In the JVM world there are actually efforts to start to support wasm that is already targeted by rust, like for example: <a href="https://github.com/oracle/graal/tree/master/wasm">https://github.com/oracle/graal/tree/master/wasm</a> or <a href="https://github.com/cretz/asmble">https://github.com/cretz/asmble</a></p>



<a name="251079324"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Rust%20on%20the%20JVM/near/251079324" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tglman <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Rust.20on.20the.20JVM.html#251079324">(Aug 28 2021 at 20:12)</a>:</h4>
<p>actually searching graalvm and llvm-ir I got this <a href="https://gist.github.com/eginez/c9c033a75ac85627996dd0a102981532">https://gist.github.com/eginez/c9c033a75ac85627996dd0a102981532</a> simple example on how to do that</p>



<a name="251079358"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Rust%20on%20the%20JVM/near/251079358" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Rust.20on.20the.20JVM.html#251079358">(Aug 28 2021 at 20:13)</a>:</h4>
<p>They're also working in the other direction, to improve their FFI story. Instead of JNI you'll be able to call C functions once they have been linked.<br>
Parts of that seem to be in JDK16. <a href="https://openjdk.java.net/projects/panama/">https://openjdk.java.net/projects/panama/</a></p>



<a name="251079383"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Rust%20on%20the%20JVM/near/251079383" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Rust.20on.20the.20JVM.html#251079383">(Aug 28 2021 at 20:13)</a>:</h4>
<p>So you can export C APIs from rust and then import them in java.</p>



<a name="251079547"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Rust%20on%20the%20JVM/near/251079547" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Rust.20on.20the.20JVM.html#251079547">(Aug 28 2021 at 20:16)</a>:</h4>
<p>more of that in 17: <a href="https://download.java.net/java/early_access/jdk17/docs/api/jdk.incubator.foreign/jdk/incubator/foreign/package-summary.html">https://download.java.net/java/early_access/jdk17/docs/api/jdk.incubator.foreign/jdk/incubator/foreign/package-summary.html</a></p>



<a name="251080117"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Rust%20on%20the%20JVM/near/251080117" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> ruster <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Rust.20on.20the.20JVM.html#251080117">(Aug 28 2021 at 20:27)</a>:</h4>
<p>I wonder how GraalVM and others solve those performance issues we've discussed above when compiling LLVM IR or WASM. Seems it's not so impossible after all?</p>



<a name="251080220"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Rust%20on%20the%20JVM/near/251080220" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Rust.20on.20the.20JVM.html#251080220">(Aug 28 2021 at 20:29)</a>:</h4>
<p>graalvm is a superset of regular jvms, it acts more like a general-purpose compiler than of a java bytecode compiler</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>