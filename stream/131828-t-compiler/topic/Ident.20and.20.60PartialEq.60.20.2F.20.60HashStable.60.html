<html>
<head><meta charset="utf-8"><title>Ident and `PartialEq` / `HashStable` · t-compiler · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/index.html">t-compiler</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html">Ident and `PartialEq` / `HashStable`</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="268637584"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/268637584" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#268637584">(Jan 20 2022 at 03:46)</a>:</h4>
<p>I recently realized that the <code>Ident</code> impl of <code>PartialEq</code> ignores the span location: <a href="https://github.com/rust-lang/rust/blob/237949b6c8e5b387e0a9d1e7a22e0397c95fe488/compiler/rustc_span/src/symbol.rs#L1576-L1580">https://github.com/rust-lang/rust/blob/237949b6c8e5b387e0a9d1e7a22e0397c95fe488/compiler/rustc_span/src/symbol.rs#L1576-L1580</a></p>
<p>This violates the contract of <code>HashStable</code>, since the <code>HashStable</code> implementation hashes the full span (including the location).</p>
<p>Unfortunately, the <code>PartialEq</code> impl for <code>Ident</code> is very widely used in the codebase. In particular, it's often used as a map key when we want to perform a hygienic match (which should take the <code>SyntaxContext</code> into account, but not the source location).</p>
<p>I'm not sure what the best way to resolve this is. cc <span class="user-mention" data-user-id="123856">@Vadim Petrochenkov</span> <span class="user-group-mention" data-user-group-id="3282">@wg-incr-comp</span></p>



<a name="268641740"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/268641740" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Vadim Petrochenkov <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#268641740">(Jan 20 2022 at 04:57)</a>:</h4>
<blockquote>
<p>This violates the contract of <code>HashStable</code>, since the <code>HashStable</code> implementation hashes the full span (including the location).</p>
</blockquote>
<p>Is the implementation of <code>PartialEq</code> ever used together with <code>HashStable</code>?<br>
If it were, things would be broken entirely, but apparently everything mostly works now.</p>



<a name="268641838"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/268641838" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Vadim Petrochenkov <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#268641838">(Jan 20 2022 at 04:59)</a>:</h4>
<p><code>PartialEq</code> is often used with regular <code>Hash</code>, and that's where comparison and hashing of <code>Ident</code> behave in compatible way.</p>



<a name="268642091"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/268642091" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Vadim Petrochenkov <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#268642091">(Jan 20 2022 at 05:02)</a>:</h4>
<blockquote>
<p>I'm not sure what the best way to resolve this is</p>
</blockquote>
<p>See <code>struct MacroRulesNormalizedIdent</code> for one possibility.<br>
It's equivalent for macro 2.0 normalization would take care of majority of maps storing <code>Ident</code>s as keys.<br>
It's just kind of annoying and inconvenient.</p>



<a name="268643180"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/268643180" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#268643180">(Jan 20 2022 at 05:18)</a>:</h4>
<p>That struct won't help, since we'd still be comparing the file location inside the <code>Span</code></p>



<a name="268643253"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/268643253" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#268643253">(Jan 20 2022 at 05:19)</a>:</h4>
<p>See <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_data_structures/stable_hasher/trait.HashStable.html">https://doc.rust-lang.org/nightly/nightly-rustc/rustc_data_structures/stable_hasher/trait.HashStable.html</a> - I'm not actually sure where in the compiler we rely on the PartialEq/HashStable correspondence</p>



<a name="268683989"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/268683989" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pnkfelix <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#268683989">(Jan 20 2022 at 12:28)</a>:</h4>
<p>What could go wrong if we changed HashStable here to also ignore the location? It seems like the intention is that such “distinct” Idents are meant to be treated as the Same thing in all contexts…?</p>



<a name="268684038"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/268684038" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pnkfelix <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#268684038">(Jan 20 2022 at 12:28)</a>:</h4>
<p>(I mean solely in the context of Ident, of course; not that HashStable should ignore the location for all Spans)</p>



<a name="268685606"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/268685606" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cjgillot <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#268685606">(Jan 20 2022 at 12:43)</a>:</h4>
<blockquote>
<p>This violates the contract of HashStable, since the HashStable implementation hashes the full span (including the location).</p>
</blockquote>
<p>IIUC, the contract is that <code>a == b</code> implies <code>hash(a) == hash(b)</code>, but not the converse. I don't think there is any breach of contract from the partial eq being actually partial.<br>
What <code>HashStable</code>is interested in is tracking information flow. Having HashStable more complete than PartialEq is not really a cause for concern.</p>
<p>Nevertheless, having <code>Ident</code>implement <code>Eq</code>is a bit surprising.</p>



<a name="268686554"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/268686554" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#268686554">(Jan 20 2022 at 12:52)</a>:</h4>
<p>If we have two idents that only differ in the span location, then we have <code>a == b</code> and <code>hash_stable(a) != hash_stable(b)</code>, which violates the contract</p>



<a name="268686753"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/268686753" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#268686753">(Jan 20 2022 at 12:54)</a>:</h4>
<p>Also, we get the requirement that "<code>hash_stable(a) == hash_stable(b)</code> implies <code>a == b</code>" from the contrapositive of the second requirement</p>



<a name="268687094"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/268687094" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#268687094">(Jan 20 2022 at 12:56)</a>:</h4>
<p><span class="user-mention" data-user-id="116083">@pnkfelix</span> The location can get used when emitting diagnostics, so we could re-use a diagnostic with a stale location</p>



<a name="268693215"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/268693215" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Vadim Petrochenkov <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#268693215">(Jan 20 2022 at 13:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="125294">Aaron Hill</span> <a href="#narrow/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60/near/268643180">said</a>:</p>
<blockquote>
<p>That struct won't help, since we'd still be comparing the file location inside the <code>Span</code></p>
</blockquote>
<p>I mean the "normalized" ident structures would implement <code>PartialEq</code> and regular <code>Hash</code> ignoring locations, but not <code>StableHash</code>.<br>
Then <code>PartialEq</code> and <code>Hash</code> impls would be removed from regular <code>Ident</code> while keeping its <code>StableHash</code> impl including the location.</p>



<a name="268702540"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/268702540" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#268702540">(Jan 20 2022 at 14:49)</a>:</h4>
<p>One issue I ran into is that Ident is embedded inside other structures that are themselves used as keys (e.g. hir::{ParamName, LifetimeName})</p>



<a name="268702643"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/268702643" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#268702643">(Jan 20 2022 at 14:49)</a>:</h4>
<p>so I either need to duplicate those structures or make them generic with a defaulted parameter</p>



<a name="268734068"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/268734068" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#268734068">(Jan 20 2022 at 18:11)</a>:</h4>
<p>This is a situation where it would be nice to be able to specify a custom hash and eq function for a HashMap for use with non hash/eq keys</p>



<a name="268734233"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/268734233" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#268734233">(Jan 20 2022 at 18:12)</a>:</h4>
<p>That would allow us to adjust the various places relying on using Ident inside a key, without needing to write PartialEq/Hash impls that are available to other code</p>



<a name="268734718"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/268734718" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#268734718">(Jan 20 2022 at 18:16)</a>:</h4>
<p>I think hashbrown's raw api comes close to allowing that by taking in the hash as an argument, but it still requires the key to implement Eq</p>



<a name="268734841"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/268734841" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#268734841">(Jan 20 2022 at 18:17)</a>:</h4>
<p>Oh, wait, you can actually provide a closure: <a href="https://docs.rs/hashbrown/latest/hashbrown/hash_map/struct.RawEntryBuilderMut.html#method.from_hash">https://docs.rs/hashbrown/latest/hashbrown/hash_map/struct.RawEntryBuilderMut.html#method.from_hash</a></p>



<a name="268734882"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/268734882" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#268734882">(Jan 20 2022 at 18:17)</a>:</h4>
<p>I think that approach might actually work</p>



<a name="268735265"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/268735265" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#268735265">(Jan 20 2022 at 18:20)</a>:</h4>
<p>This way, we can remove the Eq and Hash impls from structs like ParamName (keeping the HashStable implementation), and still use them as a HashMap key that ignores the span location</p>



<a name="268737961"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/268737961" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#268737961">(Jan 20 2022 at 18:38)</a>:</h4>
<p><span class="user-mention silent" data-user-id="125294">Aaron Hill</span> <a href="#narrow/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60/near/268734068">said</a>:</p>
<blockquote>
<p>This is a situation where it would be nice to be able to specify a custom hash and eq function for a HashMap for use with non hash/eq keys</p>
</blockquote>
<p>There was a bit of a conversation along these lines on IRLO recently, <a href="https://internals.rust-lang.org/t/pre-rfc-add-comparator-api-for-ordered-collections/15889/21?u=scottmcm">https://internals.rust-lang.org/t/pre-rfc-add-comparator-api-for-ordered-collections/15889/21?u=scottmcm</a></p>



<a name="268739780"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/268739780" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cjgillot <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#268739780">(Jan 20 2022 at 18:50)</a>:</h4>
<p>About the use of <code>&lt;Ident as PartialEq&gt;</code> for ParamName and LifetimeName, I'm planning to drop them once I finish <a href="https://github.com/rust-lang/rust/issues/91557">#91557</a>.</p>



<a name="268938952"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/268938952" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#268938952">(Jan 22 2022 at 05:38)</a>:</h4>
<p>A side effect of the current behavior of the <code>PartialEq</code> and <code>Hash</code> impls is that any query keys containing <code>Ident</code> may unexpectedly re-use the cached value</p>



<a name="268938962"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/268938962" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#268938962">(Jan 22 2022 at 05:39)</a>:</h4>
<p>e.g. <code>type_param_predicate</code> has an <code>Ident</code> in the key, so two query inputs that only different in the ident location will re-use the same cached query result</p>



<a name="268939035"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/268939035" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#268939035">(Jan 22 2022 at 05:41)</a>:</h4>
<p>By the way, where do we actually rely on the correspondence between <code>HashStable</code> and <code>PartialEq</code> ?</p>



<a name="268951297"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/268951297" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cjgillot <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#268951297">(Jan 22 2022 at 10:49)</a>:</h4>
<p>I don't think we rely on it anywhere.</p>



<a name="268980439"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/268980439" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#268980439">(Jan 22 2022 at 21:49)</a>:</h4>
<p>Could we 'just' remove the requirement from the docs, and keep the <code>Ident</code> impls the same?</p>



<a name="269112656"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/269112656" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pnkfelix <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#269112656">(Jan 24 2022 at 14:26)</a>:</h4>
<p>I don’t know, even if its possible to remove the requirement, it seems like a natural one for a developer to <em>expect</em>, and violations of it strike me as a “code smell"</p>



<a name="269112733"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/269112733" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pnkfelix <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#269112733">(Jan 24 2022 at 14:26)</a>:</h4>
<p>(“natural to expect” apart from the information theoretic problem with it not actually being possible to impelement in general…)</p>



<a name="269112821"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/269112821" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#269112821">(Jan 24 2022 at 14:27)</a>:</h4>
<p>probabilities lower than random bitflips are generally considered sufficient.</p>



<a name="269112965"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/269112965" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#269112965">(Jan 24 2022 at 14:28)</a>:</h4>
<p>also, it's actually quite surprising to see the requirement on a non-cryptographic hash function, not expected at all.</p>



<a name="269113551"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/269113551" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pnkfelix <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#269113551">(Jan 24 2022 at 14:33)</a>:</h4>
<p>Its true, I often come back to that basic probabilistic argument that is used here. Except that I’m not sure how good a job we do of confirming that our implementation comes close to meeting those expectations. (I’ve been wondering if it could make sense to do something analogous to a <a href="https://en.wikipedia.org/wiki/Spectral_test">Spectral test</a> to try to evaluation how well the StableHash method is distributing its outputs...</p>



<a name="269113676"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/269113676" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pnkfelix <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#269113676">(Jan 24 2022 at 14:34)</a>:</h4>
<p>(though that wiki article specifically says that the spectrual test cannot be applied to PRNGs besides LCGs)</p>



<a name="269114047"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/269114047" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#269114047">(Jan 24 2022 at 14:37)</a>:</h4>
<p>We have to separate two properties here. That programmers feed distinct inputs to the hash function for distinct values and that siphash doesn't have excess collisions (barring cryptographic attacks). Maybe someone already did the work for the latter part.</p>



<a name="269115237"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/269115237" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pnkfelix <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#269115237">(Jan 24 2022 at 14:45)</a>:</h4>
<p>hmm, I’ll have to think about that. I <em>think</em> what I’m concerned about is the “feed distinct inputs to the hash function for distinct values”, but that might be just because that’s the part that doesn’t already have a firm theoretical foundation.</p>



<a name="269120776"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/269120776" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#269120776">(Jan 24 2022 at 15:21)</a>:</h4>
<p>The concern is that the theory is wrong? It does seem pretty straight-forward to me. It's a series of functions applied to sets. We handwave the hashfunction itself to be bijective by saying collisions don't matter in practice. And we require the struct value -&gt; hash-input to be bijective by API contract. Chaining two bijections is a bijection. Which means distinct inputs will have distinct outputs, which is what the contract says.</p>



<a name="269123343"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/269123343" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pnkfelix <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#269123343">(Jan 24 2022 at 15:37)</a>:</h4>
<p>I’m not saying the theory is wrong. I’m saying that I’m not sure we have a good way to validate that we are maintaining the “feed distinct inputs to the hash function for distinct values” (and analogously, "feed same inputs to hash function for ‘same’ (congruent? what is good word here) values” )</p>



<a name="269123423"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/269123423" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pnkfelix <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#269123423">(Jan 24 2022 at 15:38)</a>:</h4>
<p>We currently have internal consistency checks that catch us when we outright fail</p>



<a name="269123454"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/269123454" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pnkfelix <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#269123454">(Jan 24 2022 at 15:38)</a>:</h4>
<p>but I’m wondering if there are other tests that might predict that we are doing a bad job</p>



<a name="269125706"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/269125706" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#269125706">(Jan 24 2022 at 15:54)</a>:</h4>
<p>We could extend partialeq implementations to check hash equality in debug mode or something like that</p>



<a name="269154284"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/269154284" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pnkfelix <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#269154284">(Jan 24 2022 at 19:05)</a>:</h4>
<p>One thing I’ve been idly wondering is if there’s some way to compare the hash method behavior in a way that will detect <em>risk</em> well before ouright <em>collision</em>. But I’m having trouble expressing exactly what I mean here. I guess what I’m thinking is something like: if hash(<code>struct S(X,Y);</code>) != hash(<code>struct S(A,B);</code>), it would be cool if there were some way to observe behavior that would predict that hash(<code>struct S(X,Y);</code>) == hash(<code>struct S(X,B);</code>); i..e, that the second component ends up being ignored by the hash method...</p>



<a name="269155022"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/269155022" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pnkfelix <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#269155022">(Jan 24 2022 at 19:10)</a>:</h4>
<p>(but also: Maybe you don’t need much sophistication here. Some well-directed fuzzing might suffice to catch 80% of the cases that we care about…)</p>



<a name="269415612"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/269415612" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> mw <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#269415612">(Jan 26 2022 at 14:04)</a>:</h4>
<p>Regarding hash function quality: I've been using the data from the smhasher test suite as guidance: <a href="https://github.com/rurban/smhasher#readme">https://github.com/rurban/smhasher#readme</a>. It was the most thorough source of that I could find.</p>



<a name="269548775"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/269548775" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> mw <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#269548775">(Jan 27 2022 at 10:02)</a>:</h4>
<p>I think that <code>HashStable</code> should behave the same as <code>Eq</code>. The main reason <code>HashStable</code> exists is to enable equality comparisons of values (query keys and query results) without the actual value being available (e.g. because they are only available in serialized form or are not contained in the cache at all). So I think it would be surprising and very hard to reason about if <code>hash_stable(x) == hash_stable(y)</code> did not imply <code>x.eq(y)</code> and vice versa. I suspect that trying to lift that invariant would cause lots of subtle bugs.</p>
<p>Maybe we can improve the naming and documentation around this. For example, the term "hash" might evoke the wrong assumptions (e.g. that this hash is used for hash maps and thus collisions would only have performance implications). I think the term "Fingerprint" captures pretty well what the intended use case for "stable hashes" is. Wikipedia puts it like [this](<a href="https://en.wikipedia.org/wiki/Fingerprint_(computing)">https://en.wikipedia.org/wiki/Fingerprint_(computing)</a>:</p>
<blockquote>
<p>In computer science, a fingerprinting algorithm is a procedure that maps an arbitrarily large data item (such as a computer file) to a much shorter bit string, its fingerprint, that uniquely identifies the original data for all practical purposes</p>
</blockquote>
<blockquote>
<p>Fingerprint functions may be seen as high-performance hash functions used to uniquely identify substantial blocks of data where cryptographic hash functions may be unnecessary.</p>
</blockquote>



<a name="269550654"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/269550654" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> mw <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#269550654">(Jan 27 2022 at 10:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="116083">pnkfelix</span> <a href="#narrow/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60/near/268683989">said</a>:</p>
<blockquote>
<p>What could go wrong if we changed HashStable here to also ignore the location? It seems like the intention is that such “distinct” Idents are meant to be treated as the Same thing in all contexts…?</p>
</blockquote>
<p>HashStable needs to capture any aspect of a value that can influence decisions. Query providers must be deterministic, that is, given the same inputs it must produce the same outputs. So, if we had two query invocations with an Ident as input, we would consider it them same if their input has the same stable hash, but if the stable hash does not include the span and then the query implementation does things differently dependent on that span, the output would not be deterministic anymore. IIUC, the same is true if PartialEq ignores some fields because we always look up the query key in a HashMap to see if the result is already cached in memory. Consequently we would get a different result depending on which invocation came first.</p>



<a name="269603765"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/269603765" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pnkfelix <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#269603765">(Jan 27 2022 at 17:05)</a>:</h4>
<p>So is the real bug here that Ident is ignoring its Location, and there should be a different predicate for that relationship?</p>



<a name="269629758"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/269629758" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cjgillot <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#269629758">(Jan 27 2022 at 20:02)</a>:</h4>
<p>I'd rather say that the real bug is that Ident conflates two distinct abstractions: it's a symbol with both hygiene and location, which behaves like a symbol with only hygiene.</p>



<a name="269711784"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/269711784" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> mw <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#269711784">(Jan 28 2022 at 09:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="248906">cjgillot</span> <a href="#narrow/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60/near/269629758">said</a>:</p>
<blockquote>
<p>I'd rather say that the real bug is that Ident conflates two distinct abstractions: it's a symbol with both hygiene and location, which behaves like a symbol with only hygiene.</p>
</blockquote>
<p>Yes, that sounds right to me (with my limited knowledge of hygiene). It would be great if we could make <code>Ident</code> retain the needed hygiene information but get rid of the span field.</p>



<a name="269712701"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/269712701" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Vadim Petrochenkov <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#269712701">(Jan 28 2022 at 10:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="124287">mw</span> <a href="#narrow/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60/near/269711784">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="248906">cjgillot</span> <a href="#narrow/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60/near/269629758">said</a>:</p>
<blockquote>
<p>I'd rather say that the real bug is that Ident conflates two distinct abstractions: it's a symbol with both hygiene and location, which behaves like a symbol with only hygiene.</p>
</blockquote>
<p>Yes, that sounds right to me (with my limited knowledge of hygiene). It would be great if we could make <code>Ident</code> retain the needed hygiene information but get rid of the span field.</p>
</blockquote>
<p>Which is the setup that we had before <del>maybe 2017</del> 2018.<br>
Identifiers very much need spans though, that's why it was changed.</p>



<a name="269713021"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/269713021" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Vadim Petrochenkov <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#269713021">(Jan 28 2022 at 10:09)</a>:</h4>
<p><a href="https://github.com/rust-lang/rust/pull/49154">https://github.com/rust-lang/rust/pull/49154</a></p>



<a name="269713343"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/269713343" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> mw <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#269713343">(Jan 28 2022 at 10:12)</a>:</h4>
<p>So the spans are used for diagnostics a lot?</p>



<a name="269713644"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/269713644" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> mw <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#269713644">(Jan 28 2022 at 10:15)</a>:</h4>
<p>If the span data is needed as part of Ident then I think both HashStable and PartialEq should take it into account.</p>



<a name="269724370"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/269724370" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> mw <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#269724370">(Jan 28 2022 at 11:56)</a>:</h4>
<p>(Thinking out loud here, this is not a thought-through proposal)</p>
<p>Maybe we could introduce a <code>QueryValue</code> trait that must be implement by all types that show up in query keys and values. That trait would have its own, stronger version of <code>Eq</code> and replace <code>HashStable</code>. And then the hashmaps in the query system would use the stronger form of <code>Eq</code>:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">trait</span><span class="w"> </span><span class="n">QueryValue</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="sd">/// Feed this value into a fingerprinter</span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">update_fingerprint</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">context</span>: <span class="kp">&amp;</span><span class="nc">FingerprintingContext</span><span class="p">,</span><span class="w"> </span><span class="n">fingerprinter</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Fingerprinter</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="sd">/// Same as Eq, but with the additional guarantee that no part of the value is ignored.</span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">is_equal_to</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>



<a name="269724651"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/269724651" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> mw <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#269724651">(Jan 28 2022 at 11:59)</a>:</h4>
<p><span class="user-mention" data-user-id="116009">@nikomatsakis</span> mentioned the other day that Salsa faces a similar problem with regular <code>Eq</code> not actually being strong enough in all cases.</p>



<a name="269725079"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/269725079" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> mw <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#269725079">(Jan 28 2022 at 12:02)</a>:</h4>
<p>Putting fingerprinting and strong equality into a single trait might make it easier to uphold the condition that the two have to behave equivalently.</p>



<a name="269725589"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/269725589" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> mw <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#269725589">(Jan 28 2022 at 12:07)</a>:</h4>
<p>(I added an <code>unsafe</code> to the trait in the sample above, which might help enforce that any impl not generated by <code>#[derive(QueryValue)]</code> needs to be done with a great deal of care)</p>



<a name="269753713"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/269753713" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Cameron Steffen <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#269753713">(Jan 28 2022 at 15:31)</a>:</h4>
<p>Isn't it a common problem that we want a type to have extra data for diagnostics that shouldn't be hashed? We could have two different structs for these cases and a trait to convert one way.</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">impl</span><span class="w"> </span><span class="n">IntoQueryValue</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Ident</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">QueryValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RawIdent</span><span class="p">;</span><span class="w"></span>
<span class="o">..</span><span class="p">.</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>



<a name="269756572"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/269756572" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> mw <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#269756572">(Jan 28 2022 at 15:50)</a>:</h4>
<p>Unfortunately, I think that would lead to a similar situation as we have today, where it is easy to think that part of the data is "just for diagnostics" but it breaks the query system's invariants in subtle ways that are hard to debug.</p>



<a name="269761337"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/269761337" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cjgillot <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#269761337">(Jan 28 2022 at 16:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="124287">mw</span> <a href="#narrow/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60/near/269711784">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="248906">cjgillot</span> <a href="#narrow/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60/near/269629758">said</a>:</p>
<blockquote>
<p>I'd rather say that the real bug is that Ident conflates two distinct abstractions: it's a symbol with both hygiene and location, which behaves like a symbol with only hygiene.</p>
</blockquote>
<p>Yes, that sounds right to me (with my limited knowledge of hygiene). It would be great if we could make <code>Ident</code> retain the needed hygiene information but get rid of the span field.</p>
</blockquote>
<p>Like Vadim Petrochenkov says, we actually need the span in Ident.  I'd rather do the opposite: keep <code>Ident</code> with symbol+span, and remove the PartialEq impl.  When the PartialEq impl is required (for instance for name resolution), use a specific <code>struct HygienicSymbol { name: Symbol, ctxt: SyntaxContext }</code>.</p>



<a name="269767438"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/269767438" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#269767438">(Jan 28 2022 at 17:05)</a>:</h4>
<p>I think adding the additional trait sounds like a great idea</p>



<a name="269767505"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/269767505" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#269767505">(Jan 28 2022 at 17:05)</a>:</h4>
<p>It would also allow us to make Idents behave properly in query keys</p>



<a name="269767659"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/269767659" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#269767659">(Jan 28 2022 at 17:06)</a>:</h4>
<p>Right now, we'll use the same in-memory cache key for two Idents that only differ in the location</p>



<a name="269767777"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/269767777" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#269767777">(Jan 28 2022 at 17:07)</a>:</h4>
<p><span class="user-mention" data-user-id="248906">@cjgillot</span> I tried removing the PartialEq impl, but it ended causing a large amount of churn, and worse ergonomics</p>



<a name="269767884"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/269767884" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#269767884">(Jan 28 2022 at 17:08)</a>:</h4>
<p>Additionally, there are places where we have an Ident behind several structs (e.g. hir::LifetimeName) which need a PartialEq impl</p>



<a name="269769290"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/269769290" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#269769290">(Jan 28 2022 at 17:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="124287">mw</span> <a href="#narrow/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60/near/269756572">said</a>:</p>
<blockquote>
<p>Unfortunately, I think that would lead to a similar situation as we have today, where it is easy to think that part of the data is "just for diagnostics" but it breaks the query system's invariants in subtle ways that are hard to debug.</p>
</blockquote>
<p>Maybe the diagnostic-only info could be hidden inside a nested struct to make it clear that it shouldn't be used for anything else? If you're calling <code>diagnostic_info()</code> on a non-diagnostic path that'd make it more obvious.</p>



<a name="269776300"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/269776300" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#269776300">(Jan 28 2022 at 18:00)</a>:</h4>
<p>The issue is that diagnostic-related information still matters for incremental compilation</p>



<a name="269776363"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/269776363" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#269776363">(Jan 28 2022 at 18:01)</a>:</h4>
<p>For example, we capture and store the diagnostic emitted during a query invocation, so that we can replay them if we load the result from disk in the next compilation session</p>



<a name="269776429"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/269776429" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#269776429">(Jan 28 2022 at 18:01)</a>:</h4>
<p>any information that goes into the diagnostic (e.g. ident spans) needs to be properly tracked, so that we don't re-use a stale diagnostic</p>



<a name="269776663"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/269776663" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#269776663">(Jan 28 2022 at 18:02)</a>:</h4>
<p><span class="user-mention" data-user-id="124287">@mw</span> Do you think we could just add <code>is_equal_to</code> to the existing <code>HashStable</code> trait? AFAIK, we already use <code>HashStable</code>to indicate types that can be used in query keys/values</p>



<a name="269807964"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/269807964" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#269807964">(Jan 28 2022 at 21:53)</a>:</h4>
<p>On further thought, I think we would want a trait <code>HashStableEq: HashStable</code> that has an <code>is_equal_to</code> method. There are types that have no need for any kind of equality impl (e.g. <code>mir::Body</code>), but that show up in query values</p>



<a name="269997396"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/269997396" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> mw <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#269997396">(Jan 31 2022 at 08:51)</a>:</h4>
<p><span class="user-mention silent" data-user-id="125294">Aaron Hill</span> <a href="#narrow/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60/near/269807964">said</a>:</p>
<blockquote>
<p>On further thought, I think we would want a trait <code>HashStableEq: HashStable</code> that has an <code>is_equal_to</code> method. There are types that have no need for any kind of equality impl (e.g. <code>mir::Body</code>), but that show up in query values</p>
</blockquote>
<p>That's an interesting observation! Yes, <code>is_equal_to</code> might only be needed for things that show up in query keys. I'll think about it some more.</p>



<a name="269998021"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/269998021" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> mw <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#269998021">(Jan 31 2022 at 08:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="248906">cjgillot</span> <a href="#narrow/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60/near/269761337">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="124287">mw</span> <a href="#narrow/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60/near/269711784">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="248906">cjgillot</span> <a href="#narrow/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60/near/269629758">said</a>:</p>
<blockquote>
<p>I'd rather say that the real bug is that Ident conflates two distinct abstractions: it's a symbol with both hygiene and location, which behaves like a symbol with only hygiene.</p>
</blockquote>
<p>Yes, that sounds right to me (with my limited knowledge of hygiene). It would be great if we could make <code>Ident</code> retain the needed hygiene information but get rid of the span field.</p>
</blockquote>
<p>Like Vadim Petrochenkov says, we actually need the span in Ident.  I'd rather do the opposite: keep <code>Ident</code> with symbol+span, and remove the PartialEq impl.  When the PartialEq impl is required (for instance for name resolution), use a specific <code>struct HygienicSymbol { name: Symbol, ctxt: SyntaxContext }</code>.</p>
</blockquote>
<p>If we don't use PartialEq for query key comparison anymore (as suggested above) then it should be fine for PartialEq to behave however needed in other usage contexts, I'd say.</p>



<a name="269998673"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/269998673" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> mw <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#269998673">(Jan 31 2022 at 09:01)</a>:</h4>
<p><span class="user-mention silent" data-user-id="330154">The 8472</span> <a href="#narrow/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60/near/269769290">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="124287">mw</span> <a href="#narrow/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60/near/269756572">said</a>:</p>
<blockquote>
<p>Unfortunately, I think that would lead to a similar situation as we have today, where it is easy to think that part of the data is "just for diagnostics" but it breaks the query system's invariants in subtle ways that are hard to debug.</p>
</blockquote>
<p>Maybe the diagnostic-only info could be hidden inside a nested struct to make it clear that it shouldn't be used for anything else? If you're calling <code>diagnostic_info()</code> on a non-diagnostic path that'd make it more obvious.</p>
</blockquote>
<p>I think another issue is that it is just deviously hard to implement this correctly and then keep it correct while the codebase keeps evolving. No one really has global knowledge of the codebase anymore. I think it is safe to say that virtually all cases where we tried to be clever about ignoring parts of values in the query system have ended in subtle, hard to find, and often hard to fix, bugs.</p>



<a name="270056817"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/270056817" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#270056817">(Jan 31 2022 at 16:09)</a>:</h4>
<p>I opened <a href="https://github.com/rust-lang/rust/pull/93467">https://github.com/rust-lang/rust/pull/93467</a> to add HashStableEq</p>



<a name="270056896"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/270056896" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Aaron Hill <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#270056896">(Jan 31 2022 at 16:09)</a>:</h4>
<p>There are some perf regressions, so I might try adding some <code>#[inline]</code>s</p>



<a name="270180876"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/270180876" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> mw <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#270180876">(Feb 01 2022 at 10:05)</a>:</h4>
<p>One thing I realized: Interners must also use HashStableEq -- at least for things that end up in query keys. When we intern something and then doing equality checking by comparing pointer values, we are essentially caching the equality check done when the value was initially interned. So if the interner uses Eq then HashStableEq would be forced to do a deep equality check on such values. </p>
<p>I personally think that it is preferably for interning to use a complete equality check in any case, independent of incr. comp., because anything else seems like a footgun (similar to e.g. having a RefCell in an interned value).</p>
<p>In general, I would prefer it if PartialEq and Eq impls always take the entire value into account because that's the most predictable. And then, when a specialized, limited form of equality checking is need in a particular case, introduce a new-type that implements that (as <span class="user-mention silent" data-user-id="248906">cjgillot</span> suggested <a href="#narrow/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60/near/269761337">above</a>). The question is whether that is properly enforceable throughout the  entire codebase. I doubt that we can, unless we can automate it via a lint for example.</p>
<p>Having <code>HashStableEq</code> seems like the next best approach. We just have to be careful that we actually use it in all the places that require it.</p>



<a name="270181479"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/270181479" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> mw <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#270181479">(Feb 01 2022 at 10:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="125294">Aaron Hill</span> <a href="#narrow/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60/near/270056896">said</a>:</p>
<blockquote>
<p>There are some perf regressions, so I might try adding some <code>#[inline]</code>s</p>
</blockquote>
<p>I'm wondering where those come from. In theory the current Eq implementation should already do the same amount of work, except for minor cases like <code>Ident</code>.</p>



<a name="270232070"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Ident%20and%20%60PartialEq%60%20/%20%60HashStable%60/near/270232070" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pnkfelix <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60.html#270232070">(Feb 01 2022 at 15:43)</a>:</h4>
<p><span class="user-mention silent" data-user-id="124287">mw</span> <a href="#narrow/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60/near/270180876">said</a>:</p>
<blockquote>
<p>In general, I would prefer it if PartialEq and Eq impls always take the entire value into account because that's the most predictable. And then, when a specialized, limited form of equality checking is need in a particular case, introduce a new-type that implements that (as <span class="user-mention silent" data-user-id="248906">cjgillot</span> suggested <a href="#narrow/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60/near/269761337">above</a>). The question is whether that is properly enforceable throughout the  entire codebase. I doubt that we can, unless we can automate it via a lint for example.</p>
</blockquote>
<p>I would prefer this as well. I think an internal lint could be worth investigating...</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>