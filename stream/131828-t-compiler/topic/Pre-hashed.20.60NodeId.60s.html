<html>
<head><meta charset="utf-8"><title>Pre-hashed `NodeId`s · t-compiler · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/index.html">t-compiler</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html">Pre-hashed `NodeId`s</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="263101707"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263101707" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263101707">(Nov 30 2021 at 04:51)</a>:</h4>
<p><span class="user-mention" data-user-id="384014">@Patrick Walton</span> had an interesting suggestion to avoid hashing <code>NodeId</code>s: <a href="https://twitter.com/pcwalton/status/1464687523628609537">https://twitter.com/pcwalton/status/1464687523628609537</a></p>
<div class="inline-preview-twitter"><div class="twitter-tweet"><a href="https://twitter.com/pcwalton/status/1464687523628609537"><img class="twitter-avatar" src="https://uploads.zulipusercontent.net/106ebf871f7e16a9c776d347794ede671c46a992/68747470733a2f2f7062732e7477696d672e636f6d2f70726f66696c655f696d616765732f3631393038383731382f747769747465722d69636f6e5f6e6f726d616c2e6a706567"></a><p>Is there a reason why rustc can't just generate NodeIds with a hardcoded 2^32 period LCG (instead of sequential integers) so hashing them is literally free? <a href="https://twitter.com/eddyb_r">@eddyb_r</a> <a href="https://twitter.com/nnethercote">@nnethercote</a></p><span>- Patrick Walton (@pcwalton)</span></div></div>



<a name="263101763"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263101763" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pnkfelix <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263101763">(Nov 30 2021 at 04:52)</a>:</h4>
<p>I’ve been thinking a lot about that tweet.</p>



<a name="263101777"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263101777" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pnkfelix <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263101777">(Nov 30 2021 at 04:52)</a>:</h4>
<p>are there not cheap scrambling functions that would achieve the same end effect when used as the hash function on an i32 ?</p>



<a name="263101778"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263101778" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263101778">(Nov 30 2021 at 04:52)</a>:</h4>
<p><a href="https://github.com/rust-lang/rust/blob/master/compiler/rustc_ast/src/node_id.rs#L21-L24">https://github.com/rust-lang/rust/blob/master/compiler/rustc_ast/src/node_id.rs#L21-L24</a> says we initially use <code>DUMMY_NODE_ID</code>, and then fill them in later</p>



<a name="263101783"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263101783" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263101783">(Nov 30 2021 at 04:52)</a>:</h4>
<p>Where are they filled in?</p>



<a name="263101805"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263101805" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263101805">(Nov 30 2021 at 04:53)</a>:</h4>
<p><span class="user-mention" data-user-id="116083">@pnkfelix</span> One might argue that <code>FxHasher</code> is a cheap scrambling function, but I guess you mean something even cheaper</p>



<a name="263101881"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263101881" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pnkfelix <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263101881">(Nov 30 2021 at 04:55)</a>:</h4>
<p>yeah I guess I was thinking of some operation that would just permute the bits.</p>



<a name="263101889"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263101889" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pnkfelix <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263101889">(Nov 30 2021 at 04:55)</a>:</h4>
<p>But then that might not achieve the desired goal</p>



<a name="263101933"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263101933" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pnkfelix <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263101933">(Nov 30 2021 at 04:56)</a>:</h4>
<p>I guess part of the problem is that I need to revisit what a “good” hash function needs to do in order to perform well with our hashtables.</p>



<a name="263101940"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263101940" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263101940">(Nov 30 2021 at 04:56)</a>:</h4>
<p>If it's just for a hash table, and these IDs are assigned linearly from 0 on up, is there anything wrong with just using the identity?</p>



<a name="263101943"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263101943" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pnkfelix <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263101943">(Nov 30 2021 at 04:56)</a>:</h4>
<p>Thank god someone else asked that Q</p>



<a name="263101948"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263101948" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263101948">(Nov 30 2021 at 04:56)</a>:</h4>
<p>LOL</p>



<a name="263101954"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263101954" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pnkfelix <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263101954">(Nov 30 2021 at 04:56)</a>:</h4>
<p>i.e. I’ve been assuming there’s some reason that the identity function is a no-no here</p>



<a name="263102167"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263102167" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263102167">(Nov 30 2021 at 05:00)</a>:</h4>
<p>Oh, linear numbers are bad for hash tables, you want the entries spread out.</p>



<a name="263102205"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263102205" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263102205">(Nov 30 2021 at 05:01)</a>:</h4>
<p>Otherwise you get bad behaviour on collisions</p>



<a name="263102209"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263102209" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pnkfelix <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263102209">(Nov 30 2021 at 05:01)</a>:</h4>
<p>because of how other entries are inserted on collisions, yes, okay</p>



<a name="263102215"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263102215" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pnkfelix <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263102215">(Nov 30 2021 at 05:01)</a>:</h4>
<p>So alright. What if you reverse the bits?</p>



<a name="263102221"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263102221" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pnkfelix <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263102221">(Nov 30 2021 at 05:01)</a>:</h4>
<p>is risk there that the hash table will only look at least significant bits?</p>



<a name="263102235"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263102235" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263102235">(Nov 30 2021 at 05:02)</a>:</h4>
<p>Quite possible</p>



<a name="263102243"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263102243" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263102243">(Nov 30 2021 at 05:02)</a>:</h4>
<p>/me reads <a href="https://en.wikipedia.org/wiki/Perfect_hash_function">https://en.wikipedia.org/wiki/Perfect_hash_function</a></p>



<a name="263102255"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263102255" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pnkfelix <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263102255">(Nov 30 2021 at 05:02)</a>:</h4>
<p>yeah okay</p>



<a name="263102285"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263102285" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pnkfelix <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263102285">(Nov 30 2021 at 05:02)</a>:</h4>
<p>see also: <a href="https://stackoverflow.com/questions/38304877/why-stdhashint-seems-to-be-identity-function">https://stackoverflow.com/questions/38304877/why-stdhashint-seems-to-be-identity-function</a></p>



<a name="263102375"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263102375" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pnkfelix <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263102375">(Nov 30 2021 at 05:04)</a>:</h4>
<p>(nonetheless, I suspect that some fixed permutation of the bits might actually work quite well in practice here…)</p>



<a name="263102389"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263102389" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pnkfelix <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263102389">(Nov 30 2021 at 05:04)</a>:</h4>
<p><del>(which the Perfect_hash_function page probably discusses, I now realize)</del> (or maybe not)</p>



<a name="263102459"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263102459" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263102459">(Nov 30 2021 at 05:06)</a>:</h4>
<p>Well, Patrick's suggestion is basically a way to compute a perfect hash function incrementally -- for each new integer, you compute its hash based on the previous integer's hash (cheap), and you store it for free by using it as the ID <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="263102559"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263102559" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263102559">(Nov 30 2021 at 05:08)</a>:</h4>
<p>To answer my own question from above, looks like <code>NodeId</code>s are generated here: <a href="https://github.com/rust-lang/rust/blob/master/compiler/rustc_resolve/src/lib.rs#L1432-L1440">https://github.com/rust-lang/rust/blob/master/compiler/rustc_resolve/src/lib.rs#L1432-L1440</a></p>



<a name="263103551"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263103551" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263103551">(Nov 30 2021 at 05:30)</a>:</h4>
<p>Hmm:</p>
<div class="codehilite"><pre><span></span><code>    pub fn next_node_id(&amp;mut self) -&gt; NodeId {
        let next = self
            .next_node_id
            .as_usize()
            .checked_add(1)
            .expect(&quot;input too large; ran out of NodeIds&quot;);
        self.next_node_id = ast::NodeId::from_usize(next);
        self.next_node_id
    }
</code></pre></div>
<p><code>NodeId</code> is 32 bits. Why does this function convert it to a usize before doing the checked add, and then converts the result back to 32 bits?</p>



<a name="263103565"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263103565" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263103565">(Nov 30 2021 at 05:31)</a>:</h4>
<p>Surely <code>as_u32()</code>/<code>from_u32()</code> is the right thing here?</p>



<a name="263103742"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263103742" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263103742">(Nov 30 2021 at 05:35)</a>:</h4>
<p>Back to the viability of the idea: we have a couple of <code>IndexVec&lt;NodeId, T&gt;</code> occurrences:</p>
<ul>
<li><code>node_id_to_hir_id: IndexVec&lt;NodeId, Option&lt;hir::HirId&gt;&gt;</code></li>
<li><code>nodes: IndexVec&lt;NodeId, Node&lt;'tcx&gt;&gt;</code></li>
</ul>



<a name="263103965"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263103965" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263103965">(Nov 30 2021 at 05:41)</a>:</h4>
<p>There's also the question: how much time do we actually spend hashing <code>NodeId</code>s? I just looked at a profile, seems like the answer is "not much"...</p>



<a name="263105013"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263105013" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Vadim Petrochenkov <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263105013">(Nov 30 2021 at 06:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120989">nnethercote</span> <a href="#narrow/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s/near/263103965">said</a>:</p>
<blockquote>
<p>There's also the question: how much time do we actually spend hashing <code>NodeId</code>s? I just looked at a profile, seems like the answer is "not much"...</p>
</blockquote>
<p>That's the first thought I had after seeing this thread - do we even hash node IDs at this point.<br>
They exist for a pretty short period of time starting from macro expansion and ending with lowering AST to HIR, and even during that time all "coarse grained" nodes are identified with <code>LocalDefId</code>s.</p>



<a name="263105066"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263105066" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pnkfelix <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263105066">(Nov 30 2021 at 06:05)</a>:</h4>
<p>so then the question becomes: Is pcwalton seeing hashing of NodeID’s in their profiling results? Or was this just idle thinking on their part?</p>



<a name="263105080"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263105080" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pnkfelix <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263105080">(Nov 30 2021 at 06:06)</a>:</h4>
<p>I’ll privmsg pcwalton and ask</p>



<a name="263161791"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263161791" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pnkfelix <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263161791">(Nov 30 2021 at 15:35)</a>:</h4>
<p>pcwalton clarified: they meant Defid’s, not node-ids. pcwalton also says that the relevant hashing code will not show up  will be inlined and "smeared all over the code” (I believe that tooo).</p>



<a name="263163514"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263163514" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pnkfelix <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263163514">(Nov 30 2021 at 15:46)</a>:</h4>
<p>pcwalton also mentioned something that I had not considered: The FxHash constants are copy-and-pasted over and over, which hurts code size. (I need to investigate that aspect of this more; there’s a mismatch of what pcwalton is saying and my mental model of what FxHash does.)</p>



<a name="263164316"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263164316" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joshua Nelson <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263164316">(Nov 30 2021 at 15:53)</a>:</h4>
<p>oh hmm, you mean these constants here? <a href="https://docs.rs/rustc-hash/1.1.0/src/rustc_hash/lib.rs.html#64-67">https://docs.rs/rustc-hash/1.1.0/src/rustc_hash/lib.rs.html#64-67</a></p>



<a name="263164361"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263164361" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joshua Nelson <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263164361">(Nov 30 2021 at 15:53)</a>:</h4>
<p>it should be pretty easy to change those to <code>static</code> and run perf to see whether that hurts or helps</p>



<a name="263164492"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263164492" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joshua Nelson <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263164492">(Nov 30 2021 at 15:54)</a>:</h4>
<p>I only see that constant used once, and in a non-generic function: <a href="https://docs.rs/rustc-hash/1.1.0/src/rustc_hash/lib.rs.html#79">https://docs.rs/rustc-hash/1.1.0/src/rustc_hash/lib.rs.html#79</a></p>



<a name="263164563"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263164563" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joshua Nelson <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263164563">(Nov 30 2021 at 15:54)</a>:</h4>
<p>although that function is marked <code>inline</code>, and called quite a lot from other functions also marked inline ... yeah this seems like a worthwhile experiment</p>



<a name="263164634"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263164634" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joshua Nelson <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263164634">(Nov 30 2021 at 15:55)</a>:</h4>
<p>(maybe we should also experiment with removing <code>#[inline]</code>? a lot of those functions are quite big)</p>



<a name="263164896"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263164896" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pnkfelix <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263164896">(Nov 30 2021 at 15:57)</a>:</h4>
<p>i was assuming a big reason they are inlined is to give LLVM a chance to optimize them heavily</p>



<a name="263164978"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263164978" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pnkfelix <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263164978">(Nov 30 2021 at 15:57)</a>:</h4>
<p>i.e. the kind of code they provide lends itself to massive optimization in each invocation context, right?</p>



<a name="263165095"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263165095" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pnkfelix <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263165095">(Nov 30 2021 at 15:58)</a>:</h4>
<p>(i might be wrong about that, I don’t know how much the panic machinery will mess with that in those unwrap calls.)</p>



<a name="263165204"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263165204" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pnkfelix <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263165204">(Nov 30 2021 at 15:59)</a>:</h4>
<p>((I wonder if we should be replace <code>unwrap()</code> with <code>unwrap_or(0)</code> there… that would then not have any panic stuff injected, right?))</p>



<a name="263165319"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263165319" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joshua Nelson <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263165319">(Nov 30 2021 at 15:59)</a>:</h4>
<p>yeah these functions are called so much I can imagine even tiny changes having a big impact</p>



<a name="263165694"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263165694" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joshua Nelson <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263165694">(Nov 30 2021 at 16:01)</a>:</h4>
<p><span class="user-mention silent" data-user-id="116083">pnkfelix</span> <a href="#narrow/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s/near/263164978">said</a>:</p>
<blockquote>
<p>i.e. the kind of code they provide lends itself to massive optimization in each invocation context, right?</p>
</blockquote>
<p>hmm, I'm a little confused - do you mean massive optimization <em>compared to optimizing them on their own</em>, without LTO / MIR inlining? I'm not sure how to predict how big the difference is</p>



<a name="263165909"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263165909" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pnkfelix <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263165909">(Nov 30 2021 at 16:02)</a>:</h4>
<p>yes, I’m talking about without LTO/MIR inlining.</p>



<a name="263166070"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263166070" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joshua Nelson <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263166070">(Nov 30 2021 at 16:03)</a>:</h4>
<p>seems like it wouldn't be too hard to test :)</p>



<a name="263166488"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263166488" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pnkfelix <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263166488">(Nov 30 2021 at 16:06)</a>:</h4>
<p>(i also assume the #[inline] attributes on these functions long predate our support for LTO and MIR-inlining. It probably mattered a lot more at that time.)</p>



<a name="263168448"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263168448" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joshua Nelson <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263168448">(Nov 30 2021 at 16:18)</a>:</h4>
<p><span class="user-mention" data-user-id="116083">@pnkfelix</span> I have some time - do you want to make a PR experimenting with <code>#[inline]</code>/<code>static</code> or should I? :)</p>



<a name="263168513"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263168513" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> simulacrum <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263168513">(Nov 30 2021 at 16:18)</a>:</h4>
<p>static will not make a difference, LLVM will still codegen the constants inline, is my guess</p>



<a name="263168560"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263168560" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> simulacrum <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263168560">(Nov 30 2021 at 16:19)</a>:</h4>
<p>it only really potentially matters for larger structs and references, but typically not too significant</p>



<a name="263168587"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263168587" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263168587">(Nov 30 2021 at 16:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="116083">pnkfelix</span> <a href="#narrow/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s/near/263165204">said</a>:</p>
<blockquote>
<p>((I wonder if we should be replace <code>unwrap()</code> with <code>unwrap_or(0)</code> there… that would then not have any panic stuff injected, right?))</p>
</blockquote>
<p>I am pretty sure LLVM can optimize the <code>.unwrap()</code> for <code>.try_into()</code> out in any case.</p>



<a name="263168596"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263168596" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> simulacrum <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263168596">(Nov 30 2021 at 16:19)</a>:</h4>
<p>inline will likely make a difference.</p>



<a name="263168653"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263168653" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joshua Nelson <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263168653">(Nov 30 2021 at 16:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="133247">bjorn3</span> <a href="#narrow/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s/near/263168587">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="116083">pnkfelix</span> <a href="#narrow/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s/near/263165204">said</a>:</p>
<blockquote>
<p>((I wonder if we should be replace <code>unwrap()</code> with <code>unwrap_or(0)</code> there… that would then not have any panic stuff injected, right?))</p>
</blockquote>
<p>I am pretty sure LLVM can optimize the <code>.unwrap()</code> for <code>.try_into()</code> out in any case.</p>
</blockquote>
<p>these functions are hot enough it would be nice to verify that (maybe just by looking at the ASM once?)</p>



<a name="263169171"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263169171" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263169171">(Nov 30 2021 at 16:23)</a>:</h4>
<p>The disassembly for <code>write</code> doesn't contain any panic at <code>-Copt-level=3</code>: <a href="https://rust.godbolt.org/z/KrhbaqPzd">https://rust.godbolt.org/z/KrhbaqPzd</a></p>



<a name="263170434"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263170434" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pnkfelix <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263170434">(Nov 30 2021 at 16:32)</a>:</h4>
<p>even so, why make LLVM do the work there?</p>



<a name="263176491"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263176491" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263176491">(Nov 30 2021 at 17:10)</a>:</h4>
<p>It still has to do the work for <code>.unwrap_or(0)</code>.</p>



<a name="263190303"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263190303" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263190303">(Nov 30 2021 at 18:49)</a>:</h4>
<p>By the way, my original thought was to change that function to <code>crc32</code>, which was a 15% improvement in my tests.</p>



<a name="263190318"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263190318" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263190318">(Nov 30 2021 at 18:49)</a>:</h4>
<p>The <code>crc32</code> instruction on x86, that is.</p>



<a name="263190481"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263190481" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263190481">(Nov 30 2021 at 18:50)</a>:</h4>
<p>But then I realized we could just get rid of the hash entirely by using an LCG. (BTW I think it might be possible to run the hash in reverse and go back to sequential def ids if for whatever reason we need them.)</p>



<a name="263190614"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263190614" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263190614">(Nov 30 2021 at 18:51)</a>:</h4>
<p>I seem to recall that every little hash table improvement made measurable differences in rustc performance.</p>



<a name="263191315"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263191315" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263191315">(Nov 30 2021 at 18:56)</a>:</h4>
<p>In any case, I'm pretty sure there is room for improvement in the <code>rustc-hash</code> crate by using SSE4.2 (and the ARM crc32 instruction) if available. (Unless the hash has to be stable across platforms for some reason -- and I don't think it does?)</p>



<a name="263198353"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263198353" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263198353">(Nov 30 2021 at 19:45)</a>:</h4>
<p>I think it has to be for the crate metadata to remain stable across platforms. This is necessary to allow a cross-compiled standard library to be used.</p>



<a name="263201004"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263201004" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cjgillot <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263201004">(Nov 30 2021 at 20:06)</a>:</h4>
<p>I'm not sure that crate metadata depends on the hashing algorithm. At least it should not, it should only include information from <code>HashStable</code>.</p>



<a name="263201447"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263201447" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263201447">(Nov 30 2021 at 20:09)</a>:</h4>
<p>Forgot about <code>HashStable</code>.</p>



<a name="263201624"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263201624" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263201624">(Nov 30 2021 at 20:10)</a>:</h4>
<p>It does have the potential to introduce platform specific results for things like error ordering or object output though if something depends on hashmap iteration order.</p>



<a name="263202867"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263202867" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263202867">(Nov 30 2021 at 20:21)</a>:</h4>
<p><span class="user-mention silent" data-user-id="384014">Patrick Walton</span> <a href="#narrow/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s/near/263190303">said</a>:</p>
<blockquote>
<p>By the way, my original thought was to change that function to <code>crc32</code>, which was a 15% improvement in my tests.</p>
</blockquote>
<p>What did the test do?</p>



<a name="263203573"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263203573" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263203573">(Nov 30 2021 at 20:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="116083">pnkfelix</span> <a href="#narrow/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s/near/263161791">said</a>:</p>
<blockquote>
<p>pcwalton clarified: they meant Defid’s, not node-ids.</p>
</blockquote>
<p><code>DefId</code> is a struct contains a <code>CrateNum</code> and a <code>DefIndex</code>. Perhap they meant <code>DefIndex</code>? We have two <code>IndexVec&lt;DefIndex, T&gt;</code> types I can see that would need changing.</p>



<a name="263206195"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263206195" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cjgillot <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263206195">(Nov 30 2021 at 20:47)</a>:</h4>
<p>The IndexVec&lt;LocalDefId, _&gt; will need changing too.</p>



<a name="263206259"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263206259" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cjgillot <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263206259">(Nov 30 2021 at 20:48)</a>:</h4>
<p>LocalDefId is a newtype around DefIndex.</p>



<a name="263209634"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263209634" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263209634">(Nov 30 2021 at 21:13)</a>:</h4>
<p><span class="user-mention" data-user-id="232545">@Joshua Nelson</span> Do you want to experiment? I can do local profiling easily, so I can try different things more easily than having to do a CI run.</p>



<a name="263209713"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263209713" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joshua Nelson <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263209713">(Nov 30 2021 at 21:14)</a>:</h4>
<p>I ended up getting sidetracked with <a href="https://github.com/rust-lang/rust/issues/90852">https://github.com/rust-lang/rust/issues/90852</a> <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span> so feel free to tackle it yourself :)</p>



<a name="263214499"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263214499" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263214499">(Nov 30 2021 at 21:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120989">nnethercote</span> <a href="#narrow/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s/near/263203573">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="116083">pnkfelix</span> <a href="#narrow/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s/near/263161791">said</a>:</p>
<blockquote>
<p>pcwalton clarified: they meant Defid’s, not node-ids.</p>
</blockquote>
<p><code>DefId</code> is a struct contains a <code>CrateNum</code> and a <code>DefIndex</code>. Perhap they meant <code>DefIndex</code>? We have two <code>IndexVec&lt;DefIndex, T&gt;</code> types I can see that would need changing.</p>
</blockquote>
<p>DefIndex I guess. I'm not up to date on all the renames of things :)</p>



<a name="263214520"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263214520" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263214520">(Nov 30 2021 at 21:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120989">nnethercote</span> <a href="#narrow/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s/near/263202867">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="384014">Patrick Walton</span> <a href="#narrow/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s/near/263190303">said</a>:</p>
<blockquote>
<p>By the way, my original thought was to change that function to <code>crc32</code>, which was a 15% improvement in my tests.</p>
</blockquote>
<p>What did the test do?</p>
</blockquote>
<p>Just a raw benchmark of hashing performance for integer keys.</p>



<a name="263226406"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263226406" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263226406">(Nov 30 2021 at 23:57)</a>:</h4>
<p>I tried removing the <code>#[inline]</code>s on all the <code>write_*</code> functions:</p>
<div class="codehilite"><pre><span></span><code>diff --git a/src/lib.rs b/src/lib.rs
index ee9ad31..4f919a7 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -81,7 +81,6 @@ impl FxHasher {
 }

 impl Hasher for FxHasher {
-    #[inline]
     fn write(&amp;mut self, mut bytes: &amp;[u8]) {
         #[cfg(target_pointer_width = &quot;32&quot;)]
         let read_usize = |bytes: &amp;[u8]| u32::from_ne_bytes(bytes[..4].try_into().unwrap());
@@ -108,35 +107,29 @@ impl Hasher for FxHasher {
         self.hash = hash.hash;
     }

-    #[inline]
     fn write_u8(&amp;mut self, i: u8) {
         self.add_to_hash(i as usize);
     }

-    #[inline]
     fn write_u16(&amp;mut self, i: u16) {
         self.add_to_hash(i as usize);
     }

-    #[inline]
     fn write_u32(&amp;mut self, i: u32) {
         self.add_to_hash(i as usize);
     }

     #[cfg(target_pointer_width = &quot;32&quot;)]
-    #[inline]
     fn write_u64(&amp;mut self, i: u64) {
         self.add_to_hash(i as usize);
         self.add_to_hash((i &gt;&gt; 32) as usize);
     }

     #[cfg(target_pointer_width = &quot;64&quot;)]
-    #[inline]
     fn write_u64(&amp;mut self, i: u64) {
         self.add_to_hash(i as usize);
     }

-    #[inline]
     fn write_usize(&amp;mut self, i: usize) {
         self.add_to_hash(i);
     }
</code></pre></div>
<p>Results were <em>terrible</em>. Here's the first quarter of the results:</p>
<div class="codehilite"><pre><span></span><code>externs debug   full    13.61%  68.04x
externs opt     full    13.59%  67.94x
ctfe-stress-4 debug     full    7.32%   36.58x
ctfe-stress-4 check     full    7.31%   36.57x
ctfe-stress-4 opt   full    7.24%   36.18x
coercions check     full    7.09%   35.43x
deeply-nested check     full    6.97%   34.87x
wg-grammar check    full    6.17%   30.86x
wg-grammar debug    full    6.12%   30.60x
coercions opt   full    5.94%   29.68x
regression-31157 check  full    5.93%   29.64x
wg-grammar opt  full    5.85%   29.25x
unused-warnings check   full    5.49%   27.46x
stm32f4 check   full    5.27%   26.34x
webrender check     full    5.27%   26.33x
clap-rs check   full    5.25%   26.24x
regex check     full    5.21%   26.05x
webrender-wrench check  full    5.21%   26.05x
ripgrep check   full    5.16%   25.78x
derive check    full    5.09%   25.45x
piston-image check  full    5.07%   25.34x
match-stress-exhaustive_patterns check  full    5.02%   25.12x
futures check   full    4.99%   24.95x
unused-warnings debug   full    4.98%   24.92x
tokio-webpush-simple check  full    4.98%   24.89x
</code></pre></div>



<a name="263226474"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263226474" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263226474">(Nov 30 2021 at 23:58)</a>:</h4>
<p>I.e. those are compile time increases of 5 to 13%</p>



<a name="263226554"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263226554" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263226554">(Nov 30 2021 at 23:59)</a>:</h4>
<p>That's instruction counts. Cycles and wall-time also regressed, not quite as badly</p>



<a name="263226752"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263226752" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joshua Nelson <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263226752">(Dec 01 2021 at 00:00)</a>:</h4>
<p>what if you only remove inline from <code>write</code> and nothing else?</p>



<a name="263226784"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263226784" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joshua Nelson <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263226784">(Dec 01 2021 at 00:00)</a>:</h4>
<p>that's the largest one I think</p>



<a name="263226839"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263226839" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263226839">(Dec 01 2021 at 00:01)</a>:</h4>
<p>I'll try it, but I suspect we don't call that one all that much</p>



<a name="263227325"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263227325" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263227325">(Dec 01 2021 at 00:05)</a>:</h4>
<p><a href="https://github.com/rust-lang/rust/issues/69153">https://github.com/rust-lang/rust/issues/69153</a> was the PR where I tried switching back to SipHash, BTW, results were awful</p>



<a name="263227946"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263227946" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263227946">(Dec 01 2021 at 00:11)</a>:</h4>
<p>How is <code>rustc-hash</code> at 1.1.0 at <a href="https://crates.io/crates/rustc-hash">https://crates.io/crates/rustc-hash</a>, but its <code>Cargo.toml</code> is only at 1.0.1: <a href="https://github.com/rust-lang/rustc-hash/blob/master/Cargo.toml">https://github.com/rust-lang/rustc-hash/blob/master/Cargo.toml</a> ?</p>



<a name="263229608"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263229608" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263229608">(Dec 01 2021 at 00:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="232545">Joshua Nelson</span> <a href="#narrow/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s/near/263226752">said</a>:</p>
<blockquote>
<p>what if you only remove inline from <code>write</code> and nothing else?</p>
</blockquote>
<p>A handful of tiny instruction count regressions:</p>



<a name="263229615"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263229615" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263229615">(Dec 01 2021 at 00:31)</a>:</h4>
<div class="codehilite"><pre><span></span><code>coercions check     full    0.72%   3.58x
coercions opt   full    0.70%   3.51x
ucd check   full    0.38%   1.88x
tuple-stress check  full    0.36%   1.78x
ucd debug   full    0.35%   1.77x
tuple-stress opt    full    0.35%   1.76x
tuple-stress debug  full    0.35%   1.75x
</code></pre></div>



<a name="263231449"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263231449" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263231449">(Dec 01 2021 at 00:57)</a>:</h4>
<p>I also tried changing the multiply constant from 0x517cc1b727220a95 to 0x517cc1b727220a97 and it made negligible differences</p>



<a name="263232091"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263232091" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263232091">(Dec 01 2021 at 01:06)</a>:</h4>
<p>I bet the inlining is important because of that constant. When you are hashing multiple things in sequence, you only need to load the constant into a register once</p>



<a name="263232414"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263232414" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263232414">(Dec 01 2021 at 01:10)</a>:</h4>
<p>Plus the function entry/exit, of course</p>



<a name="263234213"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263234213" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263234213">(Dec 01 2021 at 01:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120989">nnethercote</span> <a href="#narrow/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s/near/263227946">said</a>:</p>
<blockquote>
<p>How is <code>rustc-hash</code> at 1.1.0 at <a href="https://crates.io/crates/rustc-hash">https://crates.io/crates/rustc-hash</a>, but its <code>Cargo.toml</code> is only at 1.0.1: <a href="https://github.com/rust-lang/rustc-hash/blob/master/Cargo.toml">https://github.com/rust-lang/rustc-hash/blob/master/Cargo.toml</a> ?</p>
</blockquote>
<p>Someone probably cargo published it after making the edition change. I opened <a href="https://github.com/rust-lang/rustc-hash/pull/11">https://github.com/rust-lang/rustc-hash/pull/11</a> an age ago but no one reviewed/merged it, so.</p>



<a name="263237424"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263237424" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263237424">(Dec 01 2021 at 02:32)</a>:</h4>
<p>Thank! I added a comment to that PR. <span class="user-mention" data-user-id="116009">@nikomatsakis</span> started rustc-hash, so he should have merge permissions <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="263261342"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263261342" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> mw <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263261342">(Dec 01 2021 at 09:08)</a>:</h4>
<p>For reference: we already have <a href="https://github.com/rust-lang/rust/blob/673d0db5e393e9c64897005b470bfeb6d5aec61b/compiler/rustc_data_structures/src/unhash.rs">UnhashMap</a> which is a hashmap that expects keys to already be good hash values.</p>



<a name="263448385"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263448385" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> mw <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263448385">(Dec 02 2021 at 14:54)</a>:</h4>
<p>Somewhat related: We often use pointers to interned things as hashmap keys, right? Have we ever tried using the pointer as hash value verbatim (or maybe shifted to the right by a few bits to make up for alignment)? Our hashbrown hashmaps should be pretty good at dealing with low-quality hash values (as you already get via FxHash).</p>



<a name="263455757"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263455757" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263455757">(Dec 02 2021 at 15:40)</a>:</h4>
<p>Lower bits find the initial bucket, but hashbrown also uses the upper 7 bits for simd matching. A pointer will need more of a transform to be useful on both ends.</p>



<a name="263581752"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263581752" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> mw <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263581752">(Dec 03 2021 at 13:49)</a>:</h4>
<p>Right, I forget about that. I suspect that, for a single pointer value, FxHash is pretty close to being free anyway.</p>



<a name="263674919"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263674919" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Noah Lev <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263674919">(Dec 04 2021 at 01:40)</a>:</h4>
<p>What about using BTreeMap or other order-based maps? I seem to recall someone saying that for small keys like DefId it could be faster.</p>



<a name="263674945"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263674945" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Noah Lev <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263674945">(Dec 04 2021 at 01:41)</a>:</h4>
<p>With randomly-generated DefIds, how are collisions handled? Would every creation of a DefId check that it's not already in use?</p>



<a name="263798465"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263798465" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263798465">(Dec 06 2021 at 00:43)</a>:</h4>
<p>Going back to the original topic of this thread: the critical function is this:</p>
<div class="codehilite"><pre><span></span><code>impl FxHasher {
    #[inline]
    fn add_to_hash(&amp;mut self, i: usize) {
        self.hash = self.hash.rotate_left(5).bitxor(i).wrapping_mul(K);
    }
}
</code></pre></div>
<p>You don't just hash an integer in isolation, you combine it with the running hash. So now I'm not sure how pcwalton's original suggestion would even work? Maybe you could skip the multiply for DefId if it's already effectively been hashed, or something</p>



<a name="263800508"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263800508" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> simulacrum <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263800508">(Dec 06 2021 at 01:28)</a>:</h4>
<p>If you have <code>FxHashMap&lt;NodeId, ...&gt;</code>, if the NodeId was pre-hashed, you'd use <code>UnHashMap</code> or so, where the hasher is just expecting a single write_u64, IIRC</p>



<a name="263800530"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263800530" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> simulacrum <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263800530">(Dec 06 2021 at 01:29)</a>:</h4>
<p><a href="https://github.com/rust-lang/rust/blob/e2116acae59654bfab2a9729a024f3e2fd6d4b02/compiler/rustc_data_structures/src/unhash.rs#L4">https://github.com/rust-lang/rust/blob/e2116acae59654bfab2a9729a024f3e2fd6d4b02/compiler/rustc_data_structures/src/unhash.rs#L4</a></p>



<a name="263801025"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263801025" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263801025">(Dec 06 2021 at 01:40)</a>:</h4>
<p>That only works if the type being hashed is a single u64. Most of the types we hash are compound, like a pair of integers, etc.</p>



<a name="263801202"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263801202" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> simulacrum <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263801202">(Dec 06 2021 at 01:45)</a>:</h4>
<p>There's potentially simpler combine functions, but yeah, I agree that for those cases there's less/no benefit</p>



<a name="263805713"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263805713" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263805713">(Dec 06 2021 at 03:41)</a>:</h4>
<p>No, <code>Unhash</code> <em>requires</em> that you only hash a single <code>u64</code>. Debug assertions enforce this.</p>



<a name="263805731"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263805731" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263805731">(Dec 06 2021 at 03:41)</a>:</h4>
<p>I've been looking today at FxHasher use some more, I'm understanding better why it's so hard to beat.</p>



<a name="263805788"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263805788" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263805788">(Dec 06 2021 at 03:42)</a>:</h4>
<p>One of the common invocations of FxHasher process just two integers, e.g. for a struct with two integer fields <code>a</code> and <code>b</code>. With inlining, FxHasher gives something like this:</p>
<div class="codehilite"><pre><span></span><code>let hash = FxHasher { hash: 0 };
self.hash = self.hash.rotate_left(5).bitxor(self.a).wrapping_mul(K);
self.hash = self.hash.rotate_left(5).bitxor(self.b).wrapping_mul(K);
self.hash as u64
</code></pre></div>



<a name="263805797"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263805797" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263805797">(Dec 06 2021 at 03:43)</a>:</h4>
<p>(deleted)</p>



<a name="263805812"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263805812" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263805812">(Dec 06 2021 at 03:43)</a>:</h4>
<p>Single integer cases are even more common. Longer ones are increasingly less common.</p>



<a name="263805872"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263805872" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263805872">(Dec 06 2021 at 03:44)</a>:</h4>
<p>FxHasher is so fast because:</p>
<ul>
<li>No setup</li>
<li>No teardown</li>
<li>Brutally fast for each integer</li>
<li>Can be inlined, so no function call costs</li>
<li>Is just high quality enough</li>
</ul>



<a name="263805911"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263805911" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263805911">(Dec 06 2021 at 03:45)</a>:</h4>
<p>I tried fiddling with it a bunch, without much luck. E.g. I tried moving the multiply out of each iteration and just to the <code>finish</code>, and there were huge slowdowsn (e.g. 350% was the worst!)</p>



<a name="263806074"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263806074" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263806074">(Dec 06 2021 at 03:49)</a>:</h4>
<p>One thing that does bug me is that if the first integer hashed is 0 (very common, something like 20% of the cases) the <code>hash</code> value isn't changed at all, stays at 0. I tried setting <code>hash</code> to 1 instead to start with, but it made barely any difference (+/- 1.5% at most on a few benchmarks, roughly equal wins and losses)</p>



<a name="263814515"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263814515" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263814515">(Dec 06 2021 at 07:04)</a>:</h4>
<p>I think that would only matter if you had collisions from hashing <code>0,x,..</code> vs. <code>x,..</code> -- but for types of variable size we typically hash the length too, so there will still be a distinguishing factor.</p>



<a name="263819221"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263819221" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263819221">(Dec 06 2021 at 08:20)</a>:</h4>
<p>Here's some data on frequencies of hashing sequence: between <code>new</code> and <code>finish</code>, what values are passed to <code>add_to_hash</code>?<br>
(<code>0</code> = zero, <code>s</code> &lt; 256, <code>m</code> &lt; 2^32, <code>l</code> otherwise):</p>
<div class="codehilite"><pre><span></span><code>272772788 counts:
(  1) 60359935 (22.1%, 22.1%): m
(  2) 41010721 (15.0%, 37.2%): 0 m
(  3) 32512233 (11.9%, 49.1%): s
(  4) 14003400 ( 5.1%, 54.2%): l l
(  5) 12665764 ( 4.6%, 58.9%): s m
(  6) 12202604 ( 4.5%, 63.3%): s l l
(  7)  9553654 ( 3.5%, 66.8%):
(  8)  7824521 ( 2.9%, 69.7%): m 0
(  9)  7664300 ( 2.8%, 72.5%): s l
( 10)  7499810 ( 2.7%, 75.3%): 0
( 11)  7464398 ( 2.7%, 78.0%): s 0
( 12)  5835356 ( 2.1%, 80.1%): l
( 13)  5035969 ( 1.8%, 82.0%): s s
( 14)  3207243 ( 1.2%, 83.2%): m s
( 15)  2636992 ( 1.0%, 84.1%): 0 l l l
( 16)  2395809 ( 0.9%, 85.0%): 0 s
( 17)  2159919 ( 0.8%, 85.8%): 0 s m l 0 0 l
( 18)  1818917 ( 0.7%, 86.5%): 0 0 m s
( 19)  1561616 ( 0.6%, 87.0%): s s m
( 20)  1499057 ( 0.5%, 87.6%): s s s l s
( 21)  1322186 ( 0.5%, 88.1%): 0 0 m l 0 0 l
( 22)  1228112 ( 0.5%, 88.5%): s l l l
( 23)  1184468 ( 0.4%, 89.0%): s 0 s
( 24)  1053428 ( 0.4%, 89.3%): 0 l s m l 0
( 25)   975966 ( 0.4%, 89.7%): s s l s
( 26)   941603 ( 0.3%, 90.0%): s s 0
( 27)   843387 ( 0.3%, 90.4%): 0 0 s s
( 28)   804405 ( 0.3%, 90.6%): m 0 s 0
( 29)   774534 ( 0.3%, 90.9%): 0 l 0 m l 0
( 30)   764697 ( 0.3%, 91.2%): 0 0
</code></pre></div>



<a name="263819413"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263819413" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263819413">(Dec 06 2021 at 08:22)</a>:</h4>
<p>The <code>rotate_left</code> does nothing for the first integer in the sequence, because it's just rotating 0, which is a shame.</p>



<a name="263819443"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263819443" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263819443">(Dec 06 2021 at 08:22)</a>:</h4>
<p>But yes, all of the following will hash to zero: empty sequence, [0], [0, 0]</p>



<a name="263819596"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263819596" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263819596">(Dec 06 2021 at 08:24)</a>:</h4>
<p>I tried just removing the <code>rotate_left</code> altogether. Gave small instr count wins of up to 1.5% on quite a few benchmarks, but up to 12% losses on two of the artificial ones, so doesn't seem worthwhile.</p>



<a name="263819634"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263819634" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263819634">(Dec 06 2021 at 08:24)</a>:</h4>
<p>I also tried changing the order from rol/xor/mul to xor/rol/mul, it was a slight loss, up to 3%</p>



<a name="263819767"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263819767" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263819767">(Dec 06 2021 at 08:26)</a>:</h4>
<p>Changing <code>inline</code> to <code>inline(always)</code> on every method except for <code>FxHasher::write()</code> was up to a 1.5% win on <code>keccak</code> and <code>inflate</code>, and no change on anything else. Those two benchmarks stress ObligationForest code heavily, so there must be some hash calls in that code that currently aren't inlined</p>



<a name="263830530"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263830530" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263830530">(Dec 06 2021 at 10:24)</a>:</h4>
<p>add, xor, rol based hashes instead of a mul, xor, rol aren't good enough in quality?</p>



<a name="263882448"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263882448" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263882448">(Dec 06 2021 at 17:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120989">nnethercote</span> <a href="#narrow/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s/near/263819443">said</a>:</p>
<blockquote>
<p>But yes, all of the following will hash to zero: empty sequence, [0], [0, 0]</p>
</blockquote>
<p>not if the sequence type also hashes the length, as <code>[T]</code> does. i.e. <code>[]</code> hashes <code>0</code>, <code>[0]</code> hashes <code>1,0</code>, and <code>[0,0]</code> hashes <code>2,0,0</code></p>



<a name="263882506"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263882506" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263882506">(Dec 06 2021 at 17:09)</a>:</h4>
<p><code>[T]</code> does, but does <code>[T; N]</code>?</p>



<a name="263882965"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263882965" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263882965">(Dec 06 2021 at 17:12)</a>:</h4>
<p>yes, arrays just forward to slice hashing, and they <strong>must</strong> because <code>Borrow</code> requires that they agree</p>



<a name="263885664"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263885664" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263885664">(Dec 06 2021 at 17:30)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120989">nnethercote</span> <a href="#narrow/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s/near/263805788">said</a>:</p>
<blockquote>
<p>One of the common invocations of FxHasher process just two integers, e.g. for a struct with two integer fields <code>a</code> and <code>b</code>. With inlining, FxHasher gives something like this:</p>
<p><div class="codehilite"><pre><span></span><code>let hash = FxHasher { hash: 0 };
self.hash = self.hash.rotate_left(5).bitxor(self.a).wrapping_mul(K);
self.hash = self.hash.rotate_left(5).bitxor(self.b).wrapping_mul(K);
self.hash as u64
</code></pre></div><br>
</p>
</blockquote>
<p>This doesn't look very ILP-friendly.</p>



<a name="263895442"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263895442" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263895442">(Dec 06 2021 at 18:33)</a>:</h4>
<p>hmm, what if you moved the <code>mul</code> onto the input alone, then those should be done in parallel -- the dependent instruction chain would only be the faster rotate and xor</p>



<a name="263895621"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263895621" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263895621">(Dec 06 2021 at 18:34)</a>:</h4>
<p>it'll probably be weaker, but maybe still good enough?</p>



<a name="263924956"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263924956" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263924956">(Dec 06 2021 at 21:09)</a>:</h4>
<p>@cuviper You mean this?</p>
<div class="codehilite"><pre><span></span><code>self.hash = self.hash.rotate_left(5).bitxor(self.a.wrapping_mul(K));
</code></pre></div>



<a name="263925098"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263925098" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263925098">(Dec 06 2021 at 21:10)</a>:</h4>
<p><span class="user-mention" data-user-id="330154">@The 8472</span> I think the mul is important for spreading the bits out, but I'm happy to try an add/xor/rol hash. Any suggestions?</p>



<a name="263925307"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263925307" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263925307">(Dec 06 2021 at 21:12)</a>:</h4>
<p>I'm thinking about writing a blog post on this topic, calling it "A brutally effective hash function used in Rust", and talking about how unreasonably effective <code>FxHasher</code> is in the hope that it angers someone who has forgotten more about hash functions than I'll ever know into telling me how to make it better</p>



<a name="263925310"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263925310" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263925310">(Dec 06 2021 at 21:12)</a>:</h4>
<p>No concrete suggestions, I was just basing this on ARX constructions seems to be "good enough" for some ciphers to achieve mixing, but that might be due to many more rounds.</p>



<a name="263927690"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263927690" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263927690">(Dec 06 2021 at 21:33)</a>:</h4>
<p>But yeah, it's hard to beat the 3 instructions for a single <code>usize</code>. You have to give up some quality for that. Or maybe replace two of them with a CRC32 instruction.</p>



<a name="263927747"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263927747" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263927747">(Dec 06 2021 at 21:33)</a>:</h4>
<p>For more than 1 usize it should be possible to beat it with exploiting parallelism.</p>



<a name="263928145"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263928145" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263928145">(Dec 06 2021 at 21:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120989">nnethercote</span> <a href="#narrow/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s/near/263924956">said</a>:</p>
<blockquote>
<p>@cuviper You mean this?</p>
<p><div class="codehilite"><pre><span></span><code>self.hash = self.hash.rotate_left(5).bitxor(self.a.wrapping_mul(K));
</code></pre></div><br>
</p>
</blockquote>
<p>Yeah that should improve ILP since for each input the mul can be computed independently and only rol/xor would form a dependency chain.</p>



<a name="263929716"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263929716" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263929716">(Dec 06 2021 at 21:51)</a>:</h4>
<blockquote>
<p>Or maybe replace two of them with a CRC32 instruction.</p>
</blockquote>
<p>How would that work? I'm imagining this, but it's only one CRC32 instruction per field:</p>
<div class="codehilite"><pre><span></span><code>let hash = FxHasher { hash: 0 };
self.hash = _mm_crc32_u64(self.hash, self.a);
self.hash = _mm_crc32_u64(self.hash, self.b);
self.hash as u64
</code></pre></div>



<a name="263933009"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263933009" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263933009">(Dec 06 2021 at 22:17)</a>:</h4>
<p><span class="user-mention" data-user-id="120989">@nnethercote</span> That honestly seems worth trying on any hardware that has one-instruction CRC32.</p>



<a name="263933061"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263933061" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263933061">(Dec 06 2021 at 22:17)</a>:</h4>
<p>x86 and aarch64 both have CRC32 instructions on sufficiently new hardware.</p>



<a name="263933138"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263933138" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263933138">(Dec 06 2021 at 22:18)</a>:</h4>
<p>I'll try it out shortly, thanks</p>



<a name="263933396"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263933396" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pnkfelix <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263933396">(Dec 06 2021 at 22:21)</a>:</h4>
<p><span class="user-mention silent" data-user-id="384014">Patrick Walton</span> <a href="#narrow/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s/near/263190303">said</a>:</p>
<blockquote>
<p>By the way, my original thought was to change that function to <code>crc32</code>, which was a 15% improvement in my tests.</p>
</blockquote>
<p>^ as a reminder, at least one experiment along these lines <em>did</em> bear fruit (at some point in the past).</p>



<a name="263933722"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263933722" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263933722">(Dec 06 2021 at 22:24)</a>:</h4>
<blockquote>
<p>x86 and aarch64 both have CRC32 instructions on sufficiently new hardware.</p>
</blockquote>
<p>At least macos could benefit. No/few other targets have it in their baselines and it would take a lot of branches or indirect calls to do this at runtime.</p>



<a name="263935471"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263935471" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263935471">(Dec 06 2021 at 22:43)</a>:</h4>
<p>/me wonders how much performance boost we could get by optimizing rustc for a high baseline, and if we could reasonably do that by shipping a second binary (or letting rustup do feature detection, or something).</p>



<a name="263935716"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263935716" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> simulacrum <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263935716">(Dec 06 2021 at 22:46)</a>:</h4>
<p>IIRC, very little - someone tried targeting znver2 (which is the perf machine) and it had minimal effect. Of course, if we start actively developing to target this use case, that might change. (e.g. with specialized crc instructions and such)</p>



<a name="263936984"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263936984" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263936984">(Dec 06 2021 at 22:59)</a>:</h4>
<p>On the libs side we could use higher baselines in core, e.g. for faster string validation or wider vectors when implementing compares as SIMD.</p>



<a name="263937196"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263937196" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263937196">(Dec 06 2021 at 23:01)</a>:</h4>
<p>So even if user crates don't immediately benefit we could still dogfood simd/intrinsics-in-core if the compiler used a higher baseline by default.</p>



<a name="263939820"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263939820" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263939820">(Dec 06 2021 at 23:31)</a>:</h4>
<p>What is the x86-64 baseline instruction set?</p>



<a name="263941019"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263941019" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263941019">(Dec 06 2021 at 23:47)</a>:</h4>
<p>stolen from another thread:</p>
<blockquote>
<p>x86-64: CMOV, CMPXCHG8B, FPU, FXSR, MMX, FXSR, SCE, SSE, SSE2<br>
x86-64-v2: (close to Nehalem) CMPXCHG16B, LAHF-SAHF, POPCNT, SSE3, SSE4.1, SSE4.2, SSSE3<br>
x86-64-v3: (close to Haswell) AVX, AVX2, BMI1, BMI2, F16C, FMA, LZCNT, MOVBE, XSAVE<br>
x86-64-v4: AVX512F, AVX512BW, AVX512CD, AVX512DQ, AVX512VL</p>
</blockquote>



<a name="263941156"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263941156" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263941156">(Dec 06 2021 at 23:49)</a>:</h4>
<p>crc32 is part of sse4.2</p>



<a name="263941438"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263941438" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263941438">(Dec 06 2021 at 23:53)</a>:</h4>
<p>Thanks! Where are those v2, v3, v4 definitions from -- is it a Rust-specific thing? What can we use within rustc?</p>



<a name="263941615"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263941615" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263941615">(Dec 06 2021 at 23:55)</a>:</h4>
<p>They were defined last year. You can use them as <code>-Ctarget-cpu=x86-64-v2</code> instead of native, icelake, znver2 etc.</p>



<a name="263942454"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263942454" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> simulacrum <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263942454">(Dec 07 2021 at 00:05)</a>:</h4>
<p>They're not rust specific - I think origins in gcc? But have now been included in llvm (and so rustc), as well</p>



<a name="263942544"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263942544" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263942544">(Dec 07 2021 at 00:06)</a>:</h4>
<p>Also part of the sysv abi specs now</p>



<a name="263945501"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263945501" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263945501">(Dec 07 2021 at 00:47)</a>:</h4>
<p>They were defined in collaboration with glibc.</p>



<a name="263945529"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263945529" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263945529">(Dec 07 2021 at 00:47)</a>:</h4>
<p>Partly as a replacement for some of the classic hwcap support glibc had, where it'd search a combinatorial set of feature directories looking for optimized libraries.</p>



<a name="263945722"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263945722" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263945722">(Dec 07 2021 at 00:50)</a>:</h4>
<p>Running <code>LD_LIBRARY_PATH=/dir-in-ld-library-path strace ./hello</code> produces this:</p>



<a name="263945744"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263945744" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263945744">(Dec 07 2021 at 00:50)</a>:</h4>
<div class="codehilite" data-code-language="Text only"><pre><span></span><code>openat(AT_FDCWD, "/dir-in-ld-library-path/tls/haswell/avx512_1/x86_64/libc.so.6", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
stat("/dir-in-ld-library-path/tls/haswell/avx512_1/x86_64", 0x7ffd41ac8980) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/dir-in-ld-library-path/tls/haswell/avx512_1/libc.so.6", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
stat("/dir-in-ld-library-path/tls/haswell/avx512_1", 0x7ffd41ac8980) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/dir-in-ld-library-path/tls/haswell/x86_64/libc.so.6", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
stat("/dir-in-ld-library-path/tls/haswell/x86_64", 0x7ffd41ac8980) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/dir-in-ld-library-path/tls/haswell/libc.so.6", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
stat("/dir-in-ld-library-path/tls/haswell", 0x7ffd41ac8980) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/dir-in-ld-library-path/tls/avx512_1/x86_64/libc.so.6", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
stat("/dir-in-ld-library-path/tls/avx512_1/x86_64", 0x7ffd41ac8980) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/dir-in-ld-library-path/tls/avx512_1/libc.so.6", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
stat("/dir-in-ld-library-path/tls/avx512_1", 0x7ffd41ac8980) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/dir-in-ld-library-path/tls/x86_64/libc.so.6", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
stat("/dir-in-ld-library-path/tls/x86_64", 0x7ffd41ac8980) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/dir-in-ld-library-path/tls/libc.so.6", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
stat("/dir-in-ld-library-path/tls", 0x7ffd41ac8980) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/dir-in-ld-library-path/haswell/avx512_1/x86_64/libc.so.6", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
stat("/dir-in-ld-library-path/haswell/avx512_1/x86_64", 0x7ffd41ac8980) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/dir-in-ld-library-path/haswell/avx512_1/libc.so.6", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
stat("/dir-in-ld-library-path/haswell/avx512_1", 0x7ffd41ac8980) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/dir-in-ld-library-path/haswell/x86_64/libc.so.6", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
stat("/dir-in-ld-library-path/haswell/x86_64", 0x7ffd41ac8980) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/dir-in-ld-library-path/haswell/libc.so.6", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
stat("/dir-in-ld-library-path/haswell", 0x7ffd41ac8980) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/dir-in-ld-library-path/avx512_1/x86_64/libc.so.6", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
stat("/dir-in-ld-library-path/avx512_1/x86_64", 0x7ffd41ac8980) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/dir-in-ld-library-path/avx512_1/libc.so.6", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
stat("/dir-in-ld-library-path/avx512_1", 0x7ffd41ac8980) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/dir-in-ld-library-path/x86_64/libc.so.6", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
stat("/dir-in-ld-library-path/x86_64", 0x7ffd41ac8980) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/dir-in-ld-library-path/libc.so.6", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
stat("/dir-in-ld-library-path", 0x7ffd41ac8980) = -1 ENOENT (No such file or directory)
</code></pre></div>



<a name="263945770"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263945770" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263945770">(Dec 07 2021 at 00:51)</a>:</h4>
<p>Note the combinatorial explosion here: <code>tls</code>, <code>haswell</code>, <code>x86_64</code>, <code>avx512_1</code>, that's just 4, and the dynamic linker made two syscalls for each of the 16 possible combinations.</p>



<a name="263945777"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263945777" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263945777">(Dec 07 2021 at 00:51)</a>:</h4>
<p>It does that for <em>each</em> library.</p>



<a name="263945799"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263945799" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263945799">(Dec 07 2021 at 00:51)</a>:</h4>
<p>The new hwcaps mechanism and the microarchitectural feature levels (v2, v3, v4) are an effort to turn that linear.</p>



<a name="263945873"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263945873" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263945873">(Dec 07 2021 at 00:52)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120989">nnethercote</span> <a href="#narrow/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s/near/263941438">said</a>:</p>
<blockquote>
<p>Thanks! Where are those v2, v3, v4 definitions from -- is it a Rust-specific thing? What can we use within rustc?</p>
</blockquote>
<p>Within rustc, unfortunately we can't assume any more than the <code>x86-64</code> baseline on general x86-64 platforms.</p>



<a name="263946530"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263946530" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263946530">(Dec 07 2021 at 01:01)</a>:</h4>
<p>I guess it'd need a new <code>stable-x86_64_v3-pc-windows-msvc</code> toolchain and such?</p>



<a name="263949202"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263949202" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263949202">(Dec 07 2021 at 01:43)</a>:</h4>
<p><span class="user-mention silent" data-user-id="239881">Josh Triplett</span> <a href="#narrow/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s/near/263945873">said</a>:</p>
<blockquote>
<p>Within rustc, unfortunately we can't assume any more than the <code>x86-64</code> baseline on general x86-64 platforms.</p>
</blockquote>
<p>Well, I have some good news then: the <code>_mm_crc32_u64</code> results were bad</p>



<a name="263949284"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263949284" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263949284">(Dec 07 2021 at 01:44)</a>:</h4>
<p>Instruction counts were up to 20% higher, cycles and wall-times were similar</p>



<a name="263949301"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263949301" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263949301">(Dec 07 2021 at 01:45)</a>:</h4>
<p>This is at least part of the story:</p>
<div class="codehilite"><pre><span></span><code>        .           #[inline]
        .           #[target_feature(enable = &quot;sse4.2&quot;)]
        .           #[cfg_attr(test, assert_instr(crc32))]
        .           #[stable(feature = &quot;simd_x86&quot;, since = &quot;1.27.0&quot;)]
1,351,933 ( 0.68%)  pub unsafe fn _mm_crc32_u64(crc: u64, v: u64) -&gt; u64 {
1,351,933 ( 0.68%)      crc32_64_64(crc, v)
1,351,933 ( 0.68%)  }
</code></pre></div>



<a name="263949310"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263949310" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263949310">(Dec 07 2021 at 01:45)</a>:</h4>
<p>That's marked with <code>inline</code> but it's not being inlined</p>



<a name="263949352"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263949352" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263949352">(Dec 07 2021 at 01:46)</a>:</h4>
<p>Also, I don't know what's within <code>crc32_64_64</code>.</p>



<a name="263949395"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263949395" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263949395">(Dec 07 2021 at 01:46)</a>:</h4>
<p>And there seems to be extra instructions happening around all the places where hashing is being triggered, presumably due to codegen effects</p>



<a name="263949430"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263949430" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263949430">(Dec 07 2021 at 01:47)</a>:</h4>
<p>I'm increasingly in awe of <code>FxHasher</code>, it's like a machete; crude, but unbeatable for certain tasks</p>



<a name="263949775"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263949775" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> simulacrum <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263949775">(Dec 07 2021 at 01:53)</a>:</h4>
<p>yeah, inlining is problematic across target_feature boundaries iirc</p>



<a name="263951102"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263951102" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263951102">(Dec 07 2021 at 02:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120989">nnethercote</span> <a href="#narrow/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s/near/263924956">said</a>:</p>
<blockquote>
<p>@cuviper You mean this?</p>
<p><div class="codehilite"><pre><span></span><code>self.hash = self.hash.rotate_left(5).bitxor(self.a.wrapping_mul(K));
</code></pre></div><br>
</p>
</blockquote>
<p>I just tried that. Up to 5% instruction count regressions.</p>



<a name="263951159"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263951159" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263951159">(Dec 07 2021 at 02:18)</a>:</h4>
<p>The cachegrind diff is a bit hard to interpret. I would have thought the hash function itself is unchanged in terms of how many instructions it runs in. Perhaps the quality is worse so there are more collisions</p>



<a name="263951556"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263951556" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263951556">(Dec 07 2021 at 02:27)</a>:</h4>
<p>Too bad, oh well</p>



<a name="263951611"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263951611" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263951611">(Dec 07 2021 at 02:28)</a>:</h4>
<p>Thanks for trying it</p>



<a name="263958610"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263958610" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263958610">(Dec 07 2021 at 04:56)</a>:</h4>
<p><span class="user-mention" data-user-id="120989">@nnethercote</span> Very strange that that wasn't inlined; that would completely break performance.</p>



<a name="263958624"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263958624" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263958624">(Dec 07 2021 at 04:57)</a>:</h4>
<p>The whole point of instruction intrinsics is to turn into a single instruction.</p>



<a name="263958935"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263958935" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263958935">(Dec 07 2021 at 05:01)</a>:</h4>
<p>Doesn't guarantee that the function containing the intrinsic is inlined, though?</p>



<a name="263958991"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263958991" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263958991">(Dec 07 2021 at 05:02)</a>:</h4>
<p>I could try putting <code>inline(always)</code> on <code>_mm_crc32_u64</code>, see if it helps</p>



<a name="263961819"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263961819" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Thom Chiovoloni <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263961819">(Dec 07 2021 at 05:54)</a>:</h4>
<p>The design of #[target_feature] means simd instructions cannot be inline(always), I think. Usually they... should get inlined unless you have a mismatch of enabled target features between caller and callee though (probably the case here?), but this has historically been very annoying to work through.</p>



<a name="263969253"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263969253" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263969253">(Dec 07 2021 at 08:09)</a>:</h4>
<p>Indeed: <code>error: cannot use '#[inline(always)]' with '#[target_feature]'</code></p>



<a name="263981897"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263981897" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263981897">(Dec 07 2021 at 10:28)</a>:</h4>
<p>You'd have to build the compiler with <code>RUSTFLAGS=-Ctarget-feature=+sse4.2</code> and replace <code>#[target_feature(enable = "sse4.2")]</code> with <code>#[cfg(target-feature = "sse4.2")]</code> and have the fxhash fallback as <code>#[cfg(not(target-feature = "sse4.2"))]</code> then there shouldn't be an inlining barrier. But then you also need a sse4.2 without crc32 hashing as benchmark baseline.</p>



<a name="263983167"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263983167" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Hans Kratz <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263983167">(Dec 07 2021 at 10:41)</a>:</h4>
<p><code>RUSTFLAGS=-Ctarget-feature=+sse4.2</code> should be enough to allow inlining, shouldn't it?</p>



<a name="263988511"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/263988511" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nagisa <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#263988511">(Dec 07 2021 at 11:35)</a>:</h4>
<p>Yes.</p>



<a name="264083956"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264083956" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264083956">(Dec 07 2021 at 22:38)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120989">nnethercote</span> <a href="#narrow/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s/near/263925307">said</a>:</p>
<blockquote>
<p>I'm thinking about writing a blog post on this topic, calling it "A brutally effective hash function used in Rust", and talking about how unreasonably effective <code>FxHasher</code> is in the hope that it angers someone who has forgotten more about hash functions than I'll ever know into telling me how to make it better</p>
</blockquote>
<p>I have done this. The post is up on my blog but hasn't been publicized yet. If anyone wants to give feedback I'd be happy to hear it before I put it on blast later today. Thanks!  <a href="https://nnethercote.github.io/2021/12/08/a-brutally-effective-hash-function-in-rust.html">Link</a></p>



<a name="264086001"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264086001" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joshua Nelson <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264086001">(Dec 07 2021 at 22:58)</a>:</h4>
<blockquote>
<p>I like the optimism of that #[inline] attribute!</p>
</blockquote>
<p><span aria-label="joy" class="emoji emoji-1f602" role="img" title="joy">:joy:</span></p>



<a name="264086267"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264086267" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joshua Nelson <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264086267">(Dec 07 2021 at 23:00)</a>:</h4>
<p>looks good to me :)</p>



<a name="264086369"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264086369" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pnkfelix <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264086369">(Dec 07 2021 at 23:01)</a>:</h4>
<p><span class="user-mention" data-user-id="120989">@nnethercote</span> thank you for including the origin of the <code>0x517cc1b727220a95</code> constant.</p>



<a name="264086442"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264086442" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264086442">(Dec 07 2021 at 23:02)</a>:</h4>
<p>It should really be a comment in the code <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="264086551"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264086551" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264086551">(Dec 07 2021 at 23:03)</a>:</h4>
<p>My memory was that it was 1/e, I was surprised to find it was 1/pi</p>



<a name="264086593"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264086593" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264086593">(Dec 07 2021 at 23:03)</a>:</h4>
<p>I think the golden ratio wasn't used here because it flukily ends up being a binary number that ends in like 10 zeroes</p>



<a name="264086677"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264086677" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joshua Nelson <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264086677">(Dec 07 2021 at 23:04)</a>:</h4>
<p>have you tried 1/e? :P</p>



<a name="264086728"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264086728" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joshua Nelson <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264086728">(Dec 07 2021 at 23:04)</a>:</h4>
<blockquote>
<p>Different multiplication constants: sometimes negligible differences, sometimes terrible results.</p>
</blockquote>
<p>(this suggests probably yes)</p>



<a name="264086785"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264086785" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264086785">(Dec 07 2021 at 23:05)</a>:</h4>
<p>I tried the 32-bit constant, that gave terrible results</p>



<a name="264086804"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264086804" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264086804">(Dec 07 2021 at 23:05)</a>:</h4>
<p>I think any 64-bit irrational constant would probably give similar results</p>



<a name="264086828"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264086828" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264086828">(Dec 07 2021 at 23:05)</a>:</h4>
<p>Though I'm secretly hoping some hashing genius will say "use this K instead" and it's an improvement <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="264087507"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264087507" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264087507">(Dec 07 2021 at 23:12)</a>:</h4>
<p>1/pi sounds like it was picked as a "nothing up my sleeve" number rather than based on any mathematical principle.</p>



<a name="264087654"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264087654" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> mati865 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264087654">(Dec 07 2021 at 23:13)</a>:</h4>
<p>With enough computational power one could find another viable constant using brute-force.</p>



<a name="264087841"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264087841" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264087841">(Dec 07 2021 at 23:15)</a>:</h4>
<p>With enough computational power we could have the compiler written by beam search over all possible source code only given unit tests <span aria-label="monkey" class="emoji emoji-1f412" role="img" title="monkey">:monkey:</span><span aria-label="keyboard" class="emoji emoji-2328" role="img" title="keyboard">:keyboard:</span>️</p>



<a name="264088416"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264088416" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264088416">(Dec 07 2021 at 23:21)</a>:</h4>
<p>The firefox code comments give some explanation of the constant choice</p>



<a name="264088545"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264088545" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264088545">(Dec 07 2021 at 23:22)</a>:</h4>
<p>It claims any constant will suffice if it is (a) odd, and (b) has a reasonable mix of 1s and 0s</p>



<a name="264097091"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264097091" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264097091">(Dec 08 2021 at 00:49)</a>:</h4>
<p>Ok, blog post is now publicized</p>



<a name="264097105"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264097105" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264097105">(Dec 08 2021 at 00:49)</a>:</h4>
<p>Let the wailing and gnashing of teeth begin</p>



<a name="264100158"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264100158" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264100158">(Dec 08 2021 at 01:35)</a>:</h4>
<p>I'm a little surprised that the constant is not prime, but I guess it only needs to be odd, relatively prime to the modulus 2^64</p>



<a name="264101538"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264101538" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264101538">(Dec 08 2021 at 01:58)</a>:</h4>
<p>I'm happy to try other constants <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="264104952"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264104952" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264104952">(Dec 08 2021 at 02:50)</a>:</h4>
<p>maybe a "good" PRNG multiplier? e.g. <a href="https://arxiv.org/abs/2001.05304">https://arxiv.org/abs/2001.05304</a> (page 18, tables 4-7)</p>



<a name="264104981"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264104981" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264104981">(Dec 08 2021 at 02:51)</a>:</h4>
<p>I think it probably doesn't matter too much, but that would be a little more principled, I guess</p>



<a name="264105982"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264105982" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264105982">(Dec 08 2021 at 03:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120989">nnethercote</span> <a href="#narrow/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s/near/264086804">said</a>:</p>
<blockquote>
<p>I think any 64-bit irrational constant would probably give similar results</p>
</blockquote>
<p>Part of my wants to say it should be transcendental, but the rest of me knows that's not actually important.</p>
<p>That said, when it's doing <code>.wrapping_mul(K)</code>, it might still be a good idea to not pick <code>K</code> that's a root of an integer.</p>



<a name="264117675"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264117675" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264117675">(Dec 08 2021 at 06:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="138448">cuviper</span> <a href="#narrow/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s/near/264104952">said</a>:</p>
<blockquote>
<p>maybe a "good" PRNG multiplier? e.g. <a href="https://arxiv.org/abs/2001.05304">https://arxiv.org/abs/2001.05304</a> (page 18, tables 4-7)</p>
</blockquote>
<p>I tried two different ones, negligible changes</p>



<a name="264117685"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264117685" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264117685">(Dec 08 2021 at 06:42)</a>:</h4>
<p>Thanks for the suggestion!</p>



<a name="264249646"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264249646" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264249646">(Dec 09 2021 at 02:40)</a>:</h4>
<p>For two pre-hashed u64s you should be able to just xor them.</p>



<a name="264249657"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264249657" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264249657">(Dec 09 2021 at 02:41)</a>:</h4>
<p>Pre-hashed crate ID and pre-hashed node ID.</p>



<a name="264249737"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264249737" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264249737">(Dec 09 2021 at 02:42)</a>:</h4>
<p>I don't think crate IDs need to be sequential unless we're putting them in a smallintmap somewhere (and there are ways to work around this if they are, I still can't imagine that hashing them over and over millions of times during compilation is the fastest thing)</p>



<a name="264249853"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264249853" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264249853">(Dec 09 2021 at 02:44)</a>:</h4>
<p>I also idly wonder whether we could get away with, say, 16-bit crate IDs and 48-bit node IDs. Will anyone have 65,536 crates, or 281,474,976,710,656 AST nodes, in a single rustc invocation?</p>



<a name="264250021"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264250021" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264250021">(Dec 09 2021 at 02:47)</a>:</h4>
<p>There must be zillions of def IDs stored everywhere during compilation and shaving 8 bytes off each one could add up, in addition to cutting hash time down by half</p>



<a name="264251102"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264251102" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Noah Lev <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264251102">(Dec 09 2021 at 03:04)</a>:</h4>
<p>How do you accomplish 48-bit node IDs given that there's no <code>u48</code>? Do you have an array of <code>u8</code>s?</p>



<a name="264252997"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264252997" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264252997">(Dec 09 2021 at 03:40)</a>:</h4>
<p><span class="user-mention" data-user-id="384014">@Patrick Walton</span> I can imagine getting away with, say, 20-bit crate IDs and 44-bit node IDs.</p>



<a name="264253005"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264253005" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264253005">(Dec 09 2021 at 03:40)</a>:</h4>
<p>64k crates doesn't seem <em>utterly</em> ridiculous, if you're constructing crates.</p>



<a name="264253049"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264253049" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264253049">(Dec 09 2021 at 03:42)</a>:</h4>
<p>Are we talking about <a href="https://github.com/rust-lang/rust/blob/master/compiler/rustc_span/src/def_id.rs#L209-L212">DefId</a>? Because it's currently 32-bits for the crate and 32-bits for the <code>DefIndex</code></p>



<a name="264254846"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264254846" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joshua Nelson <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264254846">(Dec 09 2021 at 04:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="239881">Josh Triplett</span> <a href="#narrow/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s/near/264253005">said</a>:</p>
<blockquote>
<p>64k crates doesn't seem <em>utterly</em> ridiculous, if you're constructing crates.</p>
</blockquote>
<p><span class="user-mention" data-user-id="239881">@Josh Triplett</span> what do you mean by constructing crates?</p>
<p>for comparison, there are about 30k crates on <a href="http://crates.io">crates.io</a> right now; putting them all in a single dependency graph seems kind of absurd.</p>



<a name="264254894"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264254894" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joshua Nelson <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264254894">(Dec 09 2021 at 04:14)</a>:</h4>
<p>(at that point rustc would probably run out of memory just loading the metadata)</p>



<a name="264261419"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264261419" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264261419">(Dec 09 2021 at 06:16)</a>:</h4>
<p><span class="user-mention" data-user-id="232545">@Joshua Nelson</span> Code generation. It's not hard for me to imagine generating a pile of utility crates as inputs to something. I'm not talking about real unique crates downloaded from <a href="http://crates.io">crates.io</a>; I'm imagining a scenario like <code>codegen19581::generated_function</code>.</p>



<a name="264261438"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264261438" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264261438">(Dec 09 2021 at 06:17)</a>:</h4>
<p>I've seen weird enough build systems out there that the idea of generating a crate (or a couple of crates) for every unique source file in a project would not be <em>shocking</em>.</p>



<a name="264261443"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264261443" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264261443">(Dec 09 2021 at 06:17)</a>:</h4>
<p>And I've seen projects with tens of thousands of source files.</p>



<a name="264261453"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264261453" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264261453">(Dec 09 2021 at 06:17)</a>:</h4>
<p>I could even imagine weird scenarios like "make a library crate for every function".</p>



<a name="264261495"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264261495" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264261495">(Dec 09 2021 at 06:18)</a>:</h4>
<p>In short, I've seen weird enough stuff that the idea of hitting 64k crates didn't seem <em>out of the realm of future possibility</em>.</p>



<a name="264266367"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264266367" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264266367">(Dec 09 2021 at 07:50)</a>:</h4>
<p>Well 20 bits will fit more than 640k, which ought to be enough for anyone.</p>



<a name="264266855"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264266855" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264266855">(Dec 09 2021 at 07:58)</a>:</h4>
<p>We shouldn't overfocus on <code>DefIndex</code>, though. I have some data, not the highest quality, but it indicates that other types like <code>GenericArg</code>, <code>TyKind</code>, and <code>RegionKind</code> are hashed as often as <code>DefIndex</code>, if not more often.</p>



<a name="264278330"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264278330" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264278330">(Dec 09 2021 at 09:59)</a>:</h4>
<p>crate ids are used as an index into an IndexVec (or at least an equivalent to this) used for storing crate metadata so they need to be sequential.</p>



<a name="264279638"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264279638" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264279638">(Dec 09 2021 at 10:10)</a>:</h4>
<p>a significant part of the hashing costs come from rehashing the interning maps. if we could avoid resizes somehow that'd also help</p>



<a name="264332815"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264332815" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wesley Wiser <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264332815">(Dec 09 2021 at 17:09)</a>:</h4>
<p>Perhaps we could store some statistics about the sizes of those interning maps in the incremental cache and use that data to appropriately size the maps in subsequent compilation sessions?</p>



<a name="264337291"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264337291" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264337291">(Dec 09 2021 at 17:38)</a>:</h4>
<p>So it turns out that crate IDs and node IDs are all 32-bit anyway. I'm testing a simple change that hashes them in one go instead of individually <span class="user-mention" data-user-id="120989">@nnethercote</span></p>



<a name="264337492"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264337492" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264337492">(Dec 09 2021 at 17:39)</a>:</h4>
<p>Note that FxHash reduces to just a single multiply (i.e. a Lehmer RNG) if you are hashing just a single 64-bit value.</p>



<a name="264339790"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264339790" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264339790">(Dec 09 2021 at 17:55)</a>:</h4>
<p>hello did someone say SIMD</p>



<a name="264339923"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264339923" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264339923">(Dec 09 2021 at 17:55)</a>:</h4>
<p>I don't think SIMD will help here. <code>DefId</code> is only 64bit.</p>



<a name="264340057"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264340057" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264340057">(Dec 09 2021 at 17:56)</a>:</h4>
<p><em>checks</em> Ah we were just talking about feature levels.</p>



<a name="264340210"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264340210" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264340210">(Dec 09 2021 at 17:57)</a>:</h4>
<p>I think hashing DefId in one go (still rebuilding the compiler to test) will probably get us most of the way there, because it shrinks mul+ror+xor+mul into just mul.</p>



<a name="264340337"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264340337" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264340337">(Dec 09 2021 at 17:58)</a>:</h4>
<p>(since xor(ror(0, x), y) is just y.)</p>



<a name="264340724"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264340724" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264340724">(Dec 09 2021 at 18:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="281757">Jubilee</span> <a href="#narrow/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s/near/264340057">said</a>:</p>
<blockquote>
<p><em>checks</em> Ah we were just talking about feature levels.</p>
</blockquote>
<p>that was for crc32</p>



<a name="264340889"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264340889" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264340889">(Dec 09 2021 at 18:01)</a>:</h4>
<p>A single mul should be unbeatable except by unhash</p>



<a name="264345570"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264345570" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> lqd <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264345570">(Dec 09 2021 at 18:30)</a>:</h4>
<p>hashing defids as a single u64 is being tried, with some success, in <a href="https://github.com/rust-lang/rust/pull/91660">https://github.com/rust-lang/rust/pull/91660</a></p>



<a name="264346420"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264346420" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264346420">(Dec 09 2021 at 18:35)</a>:</h4>
<p>oh, OK, beat me to it</p>



<a name="264348918"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264348918" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264348918">(Dec 09 2021 at 18:52)</a>:</h4>
<p><code>TyKind</code> looks nasty to hash. Might be good to pre-hash that.</p>



<a name="264349963"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264349963" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> lqd <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264349963">(Dec 09 2021 at 19:00)</a>:</h4>
<p>there are also other fun things being hashed IIRC, like big strings -- which is not fx's forte but doesn't seem terrible since it's pretty rare in the following case: I seem to recall the coercions benchmark (which is a 2MB source file) hashing like a million bytes array ^^</p>



<a name="264350160"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264350160" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joshua Nelson <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264350160">(Dec 09 2021 at 19:01)</a>:</h4>
<p>oh yeah I've been meaning to look at <a href="https://github.com/rust-lang/rust/issues/81124">https://github.com/rust-lang/rust/issues/81124</a> at some point</p>



<a name="264350199"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264350199" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joshua Nelson <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264350199">(Dec 09 2021 at 19:01)</a>:</h4>
<p>(more discussion around <a href="https://github.com/rust-lang/rust/issues/81188#issuecomment-763532889">https://github.com/rust-lang/rust/issues/81188#issuecomment-763532889</a>)</p>



<a name="264350649"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264350649" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> lqd <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264350649">(Dec 09 2021 at 19:04)</a>:</h4>
<p>it will be good to check again indeed, e.g. 81124 seemed related to borrowck, and (IIRC) mark has a couple PRs helping the scalability there (<del>but maybe not RSS per se</del> <a href="https://github.com/rust-lang/rust/pull/90637">https://github.com/rust-lang/rust/pull/90637</a> does help with RSS in at least one case similar to that issue)</p>



<a name="264356327"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264356327" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264356327">(Dec 09 2021 at 19:48)</a>:</h4>
<p>Combining the two u32 fields in <code>DefIndex</code> exposed <code>FxHasher</code>'s weakness with upper bits. If the <code>CrateNum</code> was in the upper bits, that was fine because it's a low-entropy value. But if the <code>DefIndex</code> was in the upper bits the increase in collisions was catastrophic. Normally this weakness isn't exposed because, in rustc, <code>FxHasher</code>is mostly hashing u32 or smaller integers (which have zero entropy in the upper bits of a usize, on 64-bit platforms at least) or pointers (which have not much entropy in the upper bits).</p>
<p>The <a href="https://github.com/tkaitchuck/aHash/blob/e77cab8c1e15bfc9f54dfd28bd8820c2a7bb27c4/src/fallback_hash.rs#L97-L99"><code>update</code></a> function in ahash does a clever folded multiply that avoids this problem while remaining competitive in raw speed with <code>FxHasher</code>. I'll probably update my blog post to mention this, and I'm considering switching <code>FxHasher</code> to using it.</p>



<a name="264356675"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264356675" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> lqd <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264356675">(Dec 09 2021 at 19:50)</a>:</h4>
<p>zoxc also had a change that seemed to perform better in rustc <a href="https://github.com/rust-lang/rustc-hash/pull/18">https://github.com/rust-lang/rustc-hash/pull/18</a> (but also mentions ahash's fallback)</p>



<a name="264356932"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264356932" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> scottmcm <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264356932">(Dec 09 2021 at 19:52)</a>:</h4>
<p>Oh, taking advantage of the x64 multiply producing the high word too?  That's a nice touch.</p>



<a name="264379137"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264379137" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264379137">(Dec 09 2021 at 22:51)</a>:</h4>
<p>If I were to change the hash function to use the folded multiply, I guess it would make sense to make a new crate? Because <code>FxHasher</code> is a misnomer if it's not the hash function from Firefox. Maybe <code>FmHasher</code> for "folded multiply hasher".</p>



<a name="264379161"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264379161" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264379161">(Dec 09 2021 at 22:51)</a>:</h4>
<p>I don't know how to go about getting a new repo created under <code>rust-lang</code>, though.</p>



<a name="264379308"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264379308" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264379308">(Dec 09 2021 at 22:53)</a>:</h4>
<p>the crate is not "fx" though, just make a breaking change with new items :)</p>



<a name="264379504"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264379504" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264379504">(Dec 09 2021 at 22:55)</a>:</h4>
<p>Oh, so have both <code>FxHasher</code> and <code>FmHasher</code> in <code>rustc-hash</code>? That runs the risk of people still using <code>FxHasher</code> when they should use <code>FmHasher</code>, but I guess we already have a lint about using the default hashmaps</p>



<a name="264379627"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264379627" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264379627">(Dec 09 2021 at 22:56)</a>:</h4>
<p>if you want to keep both, sure, else move to rustc-hash v2 with <code>RustcHasher</code> without any implications</p>



<a name="264381466"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264381466" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264381466">(Dec 09 2021 at 23:18)</a>:</h4>
<p>Sure, but in v2 would the name <code>FxHasher</code> still be used?</p>



<a name="264381983"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264381983" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264381983">(Dec 09 2021 at 23:25)</a>:</h4>
<p>probably not</p>



<a name="264382002"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264382002" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264382002">(Dec 09 2021 at 23:25)</a>:</h4>
<p>crate <code>fxhash</code> also exists for that</p>



<a name="264382137"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264382137" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264382137">(Dec 09 2021 at 23:26)</a>:</h4>
<p>(open bike shed) <code>RustcHasher</code>, <code>RsHasher</code>, <code>RHasher</code></p>



<a name="264382866"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264382866" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264382866">(Dec 09 2021 at 23:35)</a>:</h4>
<p><code>Rustc</code> kind of implies it's only for the compiler (like <code>RustcSerialize</code> or whatever it's called now). SimpleFastHasher (SfHasher) or something might be better :)</p>



<a name="264382894"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264382894" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264382894">(Dec 09 2021 at 23:35)</a>:</h4>
<p>Or TinyHasher</p>



<a name="264382939"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264382939" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264382939">(Dec 09 2021 at 23:35)</a>:</h4>
<p>Since you can kind of see this as an exercise in optimizing for code size for small keys.</p>



<a name="264383154"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264383154" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264383154">(Dec 09 2021 at 23:38)</a>:</h4>
<p>hashers are not that big, we could also move this into <code>rustc_data_structures</code> and make it really just the compiler's own toy</p>



<a name="264384114"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264384114" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264384114">(Dec 09 2021 at 23:49)</a>:</h4>
<p>True, but I kind of want to use this for lots of my projects :)</p>



<a name="264394873"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264394873" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264394873">(Dec 10 2021 at 02:07)</a>:</h4>
<p>aside, as far as features go we have certainly discussed shipping copies of rustc or std optimized for x86 feature levels in the past as possible new targets or something.</p>



<a name="264398136"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264398136" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264398136">(Dec 10 2021 at 03:11)</a>:</h4>
<p><span class="user-mention" data-user-id="384014">@Patrick Walton</span> I was just told about <a href="https://crates.io/crates/zwohash">https://crates.io/crates/zwohash</a>, which may be of interest to you</p>



<a name="264398211"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264398211" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264398211">(Dec 10 2021 at 03:13)</a>:</h4>
<p>Interesting, I'm worried about the extra mixing step though.</p>



<a name="264398262"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264398262" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264398262">(Dec 10 2021 at 03:14)</a>:</h4>
<p>I'm more curious to try unhash now that we have 64 bit single-word def ids.</p>



<a name="264398278"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264398278" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264398278">(Dec 10 2021 at 03:14)</a>:</h4>
<p>There are a couple of Index</p>



<a name="264398737"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264398737" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264398737">(Dec 10 2021 at 03:24)</a>:</h4>
<p>For unhash, you might want reverse bits on the upper part to get interesting stuff in the 7 MSBs.</p>



<a name="264398756"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264398756" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264398756">(Dec 10 2021 at 03:25)</a>:</h4>
<p>Also, hashbrown truncates to <code>usize</code>.</p>



<a name="264411704"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264411704" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> NeoRaider <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264411704">(Dec 10 2021 at 07:42)</a>:</h4>
<p>AFAIK, the author of zwohash already evaluated the use in rustc and found that FxHash performs better, as the inputs that zwohash is optimized for are uncommon in rustc</p>



<a name="264413794"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264413794" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264413794">(Dec 10 2021 at 08:10)</a>:</h4>
<p>I updated <a href="https://nnethercote.github.io/2021/12/08/a-brutally-effective-hash-function-in-rust.html">https://nnethercote.github.io/2021/12/08/a-brutally-effective-hash-function-in-rust.html</a> with some extra details</p>



<a name="264633444"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264633444" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jannis Harder <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264633444">(Dec 12 2021 at 17:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="294290">NeoRaider</span> <a href="#narrow/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s/near/264411704">said</a>:</p>
<blockquote>
<p>AFAIK, the author of zwohash already evaluated the use in rustc and found that FxHash performs better, as the inputs that zwohash is optimized for are uncommon in rustc</p>
</blockquote>
<p>I did, see the <a href="#narrow/stream/247081-t-compiler.2Fperformance/topic/Testing.20another.20alternative.20to.20FxHash">"Testing another alternative to FxHash"</a> topic and <a href="https://github.com/rust-lang/rust/pull/75679#issuecomment-675897456">the corresponding perf run</a>. That was over a year ago though and I didn't really look into what's different between rustc's usage patterns where it doesn't seem to help and those of my code, where it is faster.</p>



<a name="264767246"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/264767246" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> llogiq <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#264767246">(Dec 13 2021 at 20:43)</a>:</h4>
<p>I wonder if we can reduce the assembly generated for hashing <code>TyKind</code>. While that likely will have little direct effect, it may reduce cache usage on the hot path.</p>



<a name="265253409"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/265253409" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#265253409">(Dec 17 2021 at 04:38)</a>:</h4>
<p>I just looked at FxHasher again, thinking about changing it to use the clever folded multiply I mentioned in the update on my <a href="https://nnethercote.github.io/2021/12/08/a-brutally-effective-hash-function-in-rust.html">blog post</a></p>



<a name="265253413"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/265253413" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#265253413">(Dec 17 2021 at 04:38)</a>:</h4>
<p>The core update function would be changed from rol/xor/mul to xor/mul/xor, so it seems like it should be just as fast, but give higher quality results</p>



<a name="265253421"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/265253421" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#265253421">(Dec 17 2021 at 04:38)</a>:</h4>
<p>I tried doing this before I wrote the post and found it slightly increased instruction counts</p>



<a name="265253433"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/265253433" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#265253433">(Dec 17 2021 at 04:39)</a>:</h4>
<p>Now I worked out why, with some <a href="https://rust.godbolt.org/z/58vGdzEhP">help from godbolt</a></p>



<a name="265253486"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/265253486" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#265253486">(Dec 17 2021 at 04:40)</a>:</h4>
<p>Imagine a type with two fields. The FxHasher code, once inlined, boils down to this:</p>
<div class="codehilite"><pre><span></span><code>    hash = 0
    --
    rol hash          // eval&#39;d at compile time
    xor a into hash   // eval&#39;d at compile time
    mul hash
    ---
    rol hash
    xor b into hash
    mul hash
</code></pre></div>



<a name="265253492"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/265253492" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#265253492">(Dec 17 2021 at 04:40)</a>:</h4>
<p>The folded multiply version boils down to this:</p>
<div class="codehilite"><pre><span></span><code>    hash = 0
    --
    xor a into hash  // eval&#39;d at compile time
    mul hash
    xor for fold
    --
    xor b into hash
    mul hash
    xor for fold
</code></pre></div>



<a name="265253497"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/265253497" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#265253497">(Dec 17 2021 at 04:41)</a>:</h4>
<p>That one extra instruction being compile time evaluated gives FxHasher the instruction count advantage</p>



<a name="265253562"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/265253562" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#265253562">(Dec 17 2021 at 04:42)</a>:</h4>
<p>An even bigger difference if you're hashing a type with a single field, where FxHasher is basically just a single multiply</p>



<a name="265296232"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/265296232" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pnkfelix <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#265296232">(Dec 17 2021 at 13:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120989">nnethercote</span> <a href="#narrow/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s/near/265253413">said</a>:</p>
<blockquote>
<p>The core update function would be changed from rol/xor/mul to xor/mul/xor, so it seems like it should be just as fast, but give higher quality results</p>
</blockquote>
<p>In theory the high quality results would correspond to a better hash distribution, right? I would have hoped that better hash distribution would itself lower instruction counts enough to compensate for the effect you describe, but I guess it does not.</p>



<a name="265297583"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/265297583" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pnkfelix <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#265297583">(Dec 17 2021 at 13:53)</a>:</h4>
<p>(or maybe removing the left-rotate (rol) has other effects on the distribution that need to be accounted for in my naive analysis…)</p>



<a name="265341150"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/265341150" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#265341150">(Dec 17 2021 at 18:41)</a>:</h4>
<p><span class="user-mention" data-user-id="120989">@nnethercote</span> I wonder if we could change xor into an add, and then do an FMA intrinsic?</p>



<a name="265341310"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/265341310" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#265341310">(Dec 17 2021 at 18:42)</a>:</h4>
<p>Something similar was already tried with crc32c, which was tried but ran into issues with inlining barriers around target features.</p>



<a name="265344078"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/265344078" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#265344078">(Dec 17 2021 at 19:03)</a>:</h4>
<p>Ah, right, that'd only work if std was built with the requisite target features to guarantee those instructions.</p>



<a name="265351337"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/265351337" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> cuviper <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#265351337">(Dec 17 2021 at 19:47)</a>:</h4>
<p><span class="user-mention silent" data-user-id="120989">nnethercote</span> <a href="#narrow/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s/near/265253413">said</a>:</p>
<blockquote>
<p>The core update function would be changed from rol/xor/mul to xor/mul/xor, so it seems like it should be just as fast, but give higher quality results</p>
</blockquote>
<p>I guess what you're seeing is that <code>FxHasher</code> is already Good Enough at avoiding collisions for our workload</p>



<a name="265351498"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/265351498" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#265351498">(Dec 17 2021 at 19:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="239881">Josh Triplett</span> <a href="#narrow/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s/near/265341150">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="120989">nnethercote</span> I wonder if we could change xor into an add, and then do an FMA intrinsic?</p>
</blockquote>
<p>you want to FMA <strong>integers</strong>?</p>



<a name="265351673"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/265351673" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#265351673">(Dec 17 2021 at 19:50)</a>:</h4>
<p>Like no one invested in that circuitry for integers until very recently, when Intel's engineers were passing around ideas after Having A Few.</p>



<a name="265354002"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/265354002" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#265354002">(Dec 17 2021 at 20:07)</a>:</h4>
<p>Hrm. For some reason I thought there was an intrinsic to do that for integers, but it would seem not.</p>



<a name="265354270"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/265354270" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#265354270">(Dec 17 2021 at 20:08)</a>:</h4>
<p>Only for AVX512.</p>



<a name="265354717"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/265354717" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#265354717">(Dec 17 2021 at 20:12)</a>:</h4>
<p>Nevermind then.</p>



<a name="265354721"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/265354721" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#265354721">(Dec 17 2021 at 20:12)</a>:</h4>
<blockquote>
<p>I guess what you're seeing is that FxHasher is already Good Enough at avoiding collisions for our workload</p>
</blockquote>
<p>Well, the attempt of cramming 2x u32 into an u64 for hashing showed that that is fragile.</p>



<a name="265354922"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/265354922" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#265354922">(Dec 17 2021 at 20:14)</a>:</h4>
<p>can we detect collision rate somehow?</p>



<a name="265355558"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/265355558" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#265355558">(Dec 17 2021 at 20:21)</a>:</h4>
<p>With a chaining hash table, we could look at the distribution of chain lengths. With a non-chaining hash table like hashbrown, I think you'd have to look at "number of probes required per item in the table" or similar.</p>



<a name="265355575"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/265355575" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#265355575">(Dec 17 2021 at 20:21)</a>:</h4>
<p>Which seems like an easy stat to collect at the end of a hash table's lifespan.</p>



<a name="265356785"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/265356785" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> The 8472 <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#265356785">(Dec 17 2021 at 20:33)</a>:</h4>
<p>or the dumb way, calculate hashes for all items and count duplicates (modulo whatever masking hashbrown does)</p>



<a name="265358838"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/265358838" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#265358838">(Dec 17 2021 at 20:53)</a>:</h4>
<blockquote>
<p>I guess what you're seeing is that FxHasher is already Good Enough at avoiding collisions for our workload</p>
</blockquote>
<p>Yes, on 64-bit platforms at least. Because so many inputs have little entropy (pointers) or no entropy (32-bit and smaller integers) in the upper usize bits. <a href="https://github.com/rust-lang/rust/pull/91660">https://github.com/rust-lang/rust/pull/91660</a> was an interesting test for this, it combined two 32-bit fields into a 64-bit value before hashing, and the ordering choice made a huge difference with FxHasher, but didn't matter when I changed it to use a folded-multiply.</p>



<a name="265358876"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/265358876" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#265358876">(Dec 17 2021 at 20:53)</a>:</h4>
<p>I wonder what things are like on a 32-bit build of the compiler, where usize inputs <em>do</em> have significant entropy in the upper bits.</p>



<a name="265358957"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/265358957" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#265358957">(Dec 17 2021 at 20:54)</a>:</h4>
<p>But I suspect the number of people using a 32-bit build of the compiler seriously is very small</p>



<a name="265359155"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/265359155" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#265359155">(Dec 17 2021 at 20:56)</a>:</h4>
<p>The whole thing is a bit frustrating; FxHasher is terrible, but it's a real worse is better case</p>



<a name="265361972"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/265361972" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#265361972">(Dec 17 2021 at 21:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="281757">Jubilee</span> <a href="#narrow/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s/near/265354270">said</a>:</p>
<blockquote>
<p>Only for AVX512.</p>
</blockquote>
<p>And for this case, what they do is they don't actually offer a full 64-bit FMA. They offer a <strong>52-bit</strong> FMA, because they just allow you to do an integer FMA using the existing floating point circuitry.</p>



<a name="265362571"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/265362571" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nnethercote <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#265362571">(Dec 17 2021 at 21:24)</a>:</h4>
<p>It's quite possible that people have tried a 32-bit compiler and it was terribly slow and they gave up, assuming it was an address space issue, but really it was an FxHasher issue(!)</p>



<a name="265379804"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/265379804" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pnkfelix <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#265379804">(Dec 18 2021 at 00:24)</a>:</h4>
<p>I would have thought exhausting your address space just leads to crashes, not slowness. Its not like virtual memory swap space can save you when you’re out of address space. (One <em>could</em> of course imagine flushing software caches, storing stuff to disk, adopting alterantive data representations, etc. But … I don’t think rustc is doing anything like that to accommodate address space exhaustion…)</p>



<a name="265379926"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/Pre-hashed%20%60NodeId%60s/near/265379926" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pnkfelix <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/Pre-hashed.20.60NodeId.60s.html#265379926">(Dec 18 2021 at 00:27)</a>:</h4>
<p>(clearly the right answer is for me to “just try it and see…”)</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>