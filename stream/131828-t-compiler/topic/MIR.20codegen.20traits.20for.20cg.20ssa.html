<html>
<head><meta charset="utf-8"><title>MIR codegen traits for cg ssa · t-compiler · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/index.html">t-compiler</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/MIR.20codegen.20traits.20for.20cg.20ssa.html">MIR codegen traits for cg ssa</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="257583658"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/MIR%20codegen%20traits%20for%20cg%20ssa/near/257583658" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Riccardo D&#x27;Ambrosio <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/MIR.20codegen.20traits.20for.20cg.20ssa.html#257583658">(Oct 14 2021 at 18:36)</a>:</h4>
<p>For my codegen, one of the issues i have with cg_ssa is that i would like to control some parts of the mir lowering process, for example, to optimize thread index calculation (for the gpu), optimize out bounds checks better, and make shared mem codegen easier. However, this cannot really be done through cg_ssa because cg_ssa is basically "opaque" to the original MIR and the lowering process. So i was thinking, would it be acceptable to refactor cg_ssa a little bit to use traits for the MIR lowering too?<br>
For example, a <code>LowerMir</code> or <code>LowerStmt</code> trait, then cg_ssa defaults to its own MIR lowering struct that implements that, but also allows you to override it with your own, as well as supplement impls with cg_ssa's lowering (for example, preprocessing a stmt before giving it to cg_ssa).<br>
This would not break existing code, it would only supplement existing code, allowing users to potentially handle more exotic codegen cases. I am aware that it is possible to just call the cg_ssa driver for codegenning individual functions, but cg_ssa has a lot of logic that is not really feasible or useful to reimplement.<br>
Moreover, this may help cg_gcc in refactoring certain cases that are hard to handle for libgccjit, what do you think <span class="user-mention" data-user-id="404242">@antoyo</span> ?</p>
<p>what do you think <span class="user-mention" data-user-id="133247">@bjorn3</span> <span class="user-mention" data-user-id="123586">@nagisa</span> ?</p>



<a name="257584764"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/MIR%20codegen%20traits%20for%20cg%20ssa/near/257584764" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> antoyo <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/MIR.20codegen.20traits.20for.20cg.20ssa.html#257584764">(Oct 14 2021 at 18:44)</a>:</h4>
<p>In my case, it could help in some cases, but it would feel more like a hack. What I really need to do is to fix the actual cg_ssa API.</p>



<a name="257585906"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/MIR%20codegen%20traits%20for%20cg%20ssa/near/257585906" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Riccardo D&#x27;Ambrosio <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/MIR.20codegen.20traits.20for.20cg.20ssa.html#257585906">(Oct 14 2021 at 18:51)</a>:</h4>
<p>I see, yeah for cg_gcc’s case the actual API being more specific in terms of stuff like values would help, for my codegen having more control over analyzing gpu kernels would help a lot</p>



<a name="257590192"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/131828-t-compiler/topic/MIR%20codegen%20traits%20for%20cg%20ssa/near/257590192" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Riccardo D&#x27;Ambrosio <a href="https://zulip-archive.rust-lang.org/stream/131828-t-compiler/topic/MIR.20codegen.20traits.20for.20cg.20ssa.html#257590192">(Oct 14 2021 at 19:19)</a>:</h4>
<p>For context, the issues im having with shared mem on the gpu is:</p>
<ul>
<li>for static shared mem, libnvvm/llvm expects you to declare an extern variable in the shared addrspace, this is a bit hard to do because i need to tell the codegen to somehow generate a global every time the user calls a function. This can prob be done by "intercepting" calls to a special intrinsic like <code>__nvvm_get_shared_mem_ptr</code>, but its a bit of a hack.</li>
<li>for dynamic shared mem, this one is a bit more exotic, because in CUDA, if you ask for dynamic shared mem multiple times in a kernel, it yields the same exact pointer. Therefore i need to somehow limit accesses to a function to get the shared mem, or a mutable ref to it may be aliased.</li>
</ul>
<p>I would also like to potentially analyze access patterns for buffers and encoded them in the final ptx to make kernel launches safer. As well as eliminate multiple bounds checks by verifying launch dimensions once.</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>