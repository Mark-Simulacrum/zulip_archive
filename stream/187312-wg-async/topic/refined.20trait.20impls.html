<html>
<head><meta charset="utf-8"><title>refined trait impls · wg-async · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/index.html">wg-async</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/refined.20trait.20impls.html">refined trait impls</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="275457954"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/refined%20trait%20impls/near/275457954" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/refined.20trait.20impls.html#275457954">(Mar 16 2022 at 01:33)</a>:</h4>
<p>I posted a draft of a new RFC I've been working on: <a href="https://rust-lang.github.io/async-fundamentals-initiative/RFC/refined_impls.html">Refined trait impls</a></p>



<a name="275458111"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/refined%20trait%20impls/near/275458111" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/refined.20trait.20impls.html#275458111">(Mar 16 2022 at 01:36)</a>:</h4>
<p>Part of the motivation for this is <a href="https://github.com/rust-lang/rfcs/pull/3193">RPITIT</a>; it makes the feature much more useful and answers some questions raised in the discussion of that RFC</p>



<a name="275458136"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/refined%20trait%20impls/near/275458136" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/refined.20trait.20impls.html#275458136">(Mar 16 2022 at 01:37)</a>:</h4>
<p>But this RFC also fixes some surprising inconsistencies in the language today</p>



<a name="275524746"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/refined%20trait%20impls/near/275524746" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/refined.20trait.20impls.html#275524746">(Mar 16 2022 at 15:09)</a>:</h4>
<p>In the 'Automatic migration for the next edition' section, I don't understand why rewriting is necessary? I'd think the only rewrite necessary is to remove #[refine] attributes? Methods which look refined will still continue to work (and would have triggered a warning in any case) and no behaviour of existing programs will change, but more valid programs could be written after the edition change</p>



<a name="275525191"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/refined%20trait%20impls/near/275525191" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/refined.20trait.20impls.html#275525191">(Mar 16 2022 at 15:12)</a>:</h4>
<p>For refinement of where clauses, I would expect that we have to look at where type variables are used, not just at the bounds in the where clause? I.e., if a type variable is used only in arguments, then we check bounds are refined contravariantly, covariant if they're used in return types, and invariant in return types, plus apply the rules for variance of type variables in nested position</p>



<a name="275525385"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/refined%20trait%20impls/near/275525385" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/refined.20trait.20impls.html#275525385">(Mar 16 2022 at 15:13)</a>:</h4>
<p>I like the RFC in general!</p>



<a name="275525932"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/refined%20trait%20impls/near/275525932" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/refined.20trait.20impls.html#275525932">(Mar 16 2022 at 15:17)</a>:</h4>
<p>Another area I would like to allow is that impls should be able to name lifetimes which are elided in super traits, e.g., if <code>fn foo(&amp;self) -&gt; &amp;str</code> is in the trait, then an impl with <code>fn foo&lt;'a&gt;(&amp;'a self) -&gt; &amp;'a str</code> should be allowed, and furthermore stronger constraints on lifetimes should be allowed, e.g., if <code>fn bar(a: &amp;T, b &amp;T)</code> is in the trait, <code>fn bar&lt;'a&gt;(a: &amp;'a T, b: 'a T)</code> should be allowed, as well as the straightforward expansion</p>



<a name="275546868"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/refined%20trait%20impls/near/275546868" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/refined.20trait.20impls.html#275546868">(Mar 16 2022 at 17:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="256841">Nick Cameron</span> <a href="#narrow/stream/187312-wg-async/topic/refined.20trait.20impls/near/275524746">said</a>:</p>
<blockquote>
<p>In the 'Automatic migration for the next edition' section, I don't understand why rewriting is necessary? I'd think the only rewrite necessary is to remove #[refine] attributes? Methods which look refined will still continue to work (and would have triggered a warning in any case) and no behaviour of existing programs will change, but more valid programs could be written after the edition change</p>
</blockquote>
<p>All that is true. My concern is that we end up stabilizing new API surface that libraries didn't mean to stabilize because they weren't as careful about how their impls were written before this feature was introduced. This might turn out to be a non issue, though.</p>



<a name="275547875"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/refined%20trait%20impls/near/275547875" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/refined.20trait.20impls.html#275547875">(Mar 16 2022 at 17:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="256841">Nick Cameron</span> <a href="#narrow/stream/187312-wg-async/topic/refined.20trait.20impls/near/275525191">said</a>:</p>
<blockquote>
<p>For refinement of where clauses, I would expect that we have to look at where type variables are used, not just at the bounds in the where clause? I.e., if a type variable is used only in arguments, then we check bounds are refined contravariantly, covariant if they're used in return types, and invariant in return types, plus apply the rules for variance of type variables in nested position</p>
</blockquote>
<p>I went down this path for awhile but I don't think it's actually right. Where clauses are <em>always</em> proved by the caller; they can't be used purely to promise things about the callee's return type (unlike RPIT). So contravariance (removing bounds that the caller has to prove) is always the right direction.</p>



<a name="275548306"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/refined%20trait%20impls/near/275548306" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/refined.20trait.20impls.html#275548306">(Mar 16 2022 at 17:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="256841">Nick Cameron</span> <a href="#narrow/stream/187312-wg-async/topic/refined.20trait.20impls/near/275525932">said</a>:</p>
<blockquote>
<p>Another area I would like to allow is that impls should be able to name lifetimes which are elided in super traits, e.g., if <code>fn foo(&amp;self) -&gt; &amp;str</code> is in the trait, then an impl with <code>fn foo&lt;'a&gt;(&amp;'a self) -&gt; &amp;'a str</code> should be allowed, and furthermore stronger constraints on lifetimes should be allowed, e.g., if <code>fn bar(a: &amp;T, b &amp;T)</code> is in the trait, <code>fn bar&lt;'a&gt;(a: &amp;'a T, b: 'a T)</code> should be allowed, as well as the straightforward expansion</p>
</blockquote>
<p>Yeah, this overlaps with the future direction of allowing added generic parameters that I talk about at the end. I can add something on lifetimes there too. Btw, your last example would only work in the opposite direction (relaxing bounds in the implementation).</p>



<a name="275550912"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/refined%20trait%20impls/near/275550912" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/refined.20trait.20impls.html#275550912">(Mar 16 2022 at 17:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="116883">tmandry</span> <a href="#narrow/stream/187312-wg-async/topic/refined.20trait.20impls/near/275547875">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="256841">Nick Cameron</span> <a href="#narrow/stream/187312-wg-async/topic/refined.20trait.20impls/near/275525191">said</a>:</p>
<blockquote>
<p>For refinement of where clauses, I would expect that we have to look at where type variables are used, not just at the bounds in the where clause? I.e., if a type variable is used only in arguments, then we check bounds are refined contravariantly, covariant if they're used in return types, and invariant in return types, plus apply the rules for variance of type variables in nested position</p>
</blockquote>
<p>I went down this path for awhile but I don't think it's actually right. Where clauses are <em>always</em> proved by the caller; they can't be used purely to promise things about the callee's return type (unlike RPIT). So contravariance (removing bounds that the caller has to prove) is always the right direction.</p>
</blockquote>
<p>Yeah, that makes sense. I'm not exactly sure what is going on here with the types, but thinking about it practically that seems right.</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>