<html>
<head><meta charset="utf-8"><title>Async IO traits proposal · wg-async · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/index.html">wg-async</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html">Async IO traits proposal</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="271979680"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/271979680" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#271979680">(Feb 15 2022 at 14:17)</a>:</h4>
<p><a href="https://www.ncameron.org/blog/async-read-and-write-traits/">https://www.ncameron.org/blog/async-read-and-write-traits/</a></p>



<a name="271980591"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/271980591" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Alice Ryhl <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#271980591">(Feb 15 2022 at 14:23)</a>:</h4>
<p>The publish date is tomorrow?</p>



<a name="271980780"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/271980780" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#271980780">(Feb 15 2022 at 14:24)</a>:</h4>
<p>Probably thinks I'm in NZ?</p>



<a name="271983194"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/271983194" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ibraheem Ahmed <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#271983194">(Feb 15 2022 at 14:40)</a>:</h4>
<p>Did you consider <code>trait AsyncRead: Read</code> versus <code>non_blocking_*</code>?</p>



<a name="271983234"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/271983234" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ibraheem Ahmed <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#271983234">(Feb 15 2022 at 14:40)</a>:</h4>
<p>I think the distinction is useful, but worth a mention</p>



<a name="271985312"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/271985312" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lucio Franco <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#271985312">(Feb 15 2022 at 14:54)</a>:</h4>
<p><span class="user-mention" data-user-id="256841">@Nick Cameron</span> do you have a link to carl's proposal? Wonder if it would be useful to link that</p>



<a name="271985421"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/271985421" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#271985421">(Feb 15 2022 at 14:55)</a>:</h4>
<p><span class="user-mention" data-user-id="207781">@Lucio Franco</span> <a href="https://gist.github.com/carllerche/5d7037bd55dac1cb72891529a4ff1540">https://gist.github.com/carllerche/5d7037bd55dac1cb72891529a4ff1540</a></p>



<a name="271985443"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/271985443" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#271985443">(Feb 15 2022 at 14:55)</a>:</h4>
<p>I can add that link</p>



<a name="271985507"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/271985507" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ibraheem Ahmed <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#271985507">(Feb 15 2022 at 14:56)</a>:</h4>
<p><a href="https://rust-lang.github.io/wg-async/vision/roadmap/portable/read_write.html?highlight=CArl#variant-a-readiness">https://rust-lang.github.io/wg-async/vision/roadmap/portable/read_write.html?highlight=CArl#variant-a-readiness</a></p>



<a name="271985523"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/271985523" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ibraheem Ahmed <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#271985523">(Feb 15 2022 at 14:56)</a>:</h4>
<p>Oh, beat me to it :)</p>



<a name="271985595"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/271985595" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#271985595">(Feb 15 2022 at 14:56)</a>:</h4>
<p>done</p>



<a name="271985766"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/271985766" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#271985766">(Feb 15 2022 at 14:57)</a>:</h4>
<p><span class="user-mention" data-user-id="363998">@Ibraheem Ahmed</span> I did consider that, but its a requirement that the sync read function is non-blocking, i.e., returns on e-would-block, rather than blocks on it, so the implemention of Read::read will be different to async::Read::non_blocking_read</p>



<a name="271985865"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/271985865" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#271985865">(Feb 15 2022 at 14:58)</a>:</h4>
<p>That is required so that one can use the readiness loop for many readers simultaneously</p>



<a name="271985944"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/271985944" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ibraheem Ahmed <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#271985944">(Feb 15 2022 at 14:58)</a>:</h4>
<p>The idea would be Read implementations on an async resource would be non blocking</p>



<a name="271985977"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/271985977" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ibraheem Ahmed <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#271985977">(Feb 15 2022 at 14:59)</a>:</h4>
<p>Like a std::TcpStream in non blocking mode</p>



<a name="271986032"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/271986032" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ibraheem Ahmed <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#271986032">(Feb 15 2022 at 14:59)</a>:</h4>
<p>I do like an explicitly different method with that requirement better though</p>



<a name="271986423"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/271986423" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ibraheem Ahmed <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#271986423">(Feb 15 2022 at 15:01)</a>:</h4>
<p>I can see people accidentally calling Read::read on an async type</p>



<a name="271986766"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/271986766" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lucio Franco <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#271986766">(Feb 15 2022 at 15:03)</a>:</h4>
<p><span class="user-mention" data-user-id="256841">@Nick Cameron</span> thanks! whats the reason for <code>non_blocking</code> over <code>try_</code>?</p>



<a name="271986836"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/271986836" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lucio Franco <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#271986836">(Feb 15 2022 at 15:04)</a>:</h4>
<p>Its unfortunate that io uring will still need a BufRead so won't be 100% drop in</p>



<a name="271986915"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/271986915" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#271986915">(Feb 15 2022 at 15:04)</a>:</h4>
<p>try_ is conventionally used to indicate a version of a function which returns a Result rather than making an assumption, which is not what is going on here</p>



<a name="271987026"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/271987026" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#271987026">(Feb 15 2022 at 15:05)</a>:</h4>
<p>There might be a better name than non_blocking_, but I dislike try_ for the above reason and non_blocking_ seems ok since it is a version of read which does not block</p>



<a name="271987273"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/271987273" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ibraheem Ahmed <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#271987273">(Feb 15 2022 at 15:07)</a>:</h4>
<p>I think it's potentially confusing, I've seen people try to use a non-blocking std type like an async IO type, people might call nom_blocking_read instead of read().await because they want "non blocking IO"</p>



<a name="271988808"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/271988808" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Toby Lawrence <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#271988808">(Feb 15 2022 at 15:18)</a>:</h4>
<p>there's also a conceptual issue (at least in my mind) about implying that the read is non-blocking, which it may not be</p>



<a name="271988870"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/271988870" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Toby Lawrence <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#271988870">(Feb 15 2022 at 15:18)</a>:</h4>
<p>I suppose <code>try_</code> vs <code>non_blocking_</code> is six of one/half a dozen of the other in that case, but... intent in naming can be useful</p>



<a name="271991755"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/271991755" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Yoshua Wuyts [he/they] <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#271991755">(Feb 15 2022 at 15:39)</a>:</h4>
<blockquote>
<p>However, this approach adds some complexity for the simple cases of read, would be a radical departure from the existing sync traits, and it's unclear if the lifetimes can be made to work in all cases.</p>
</blockquote>
<p>I was hoping to see a more thorough evaluation of this alternative, instead of just asserting that it has certain qualities. This applies to the other alternatives as well. It's hard to assess whether the proposal put forward is indeed optimal, if none of the alternatives are evaluated in the same way.</p>
<p>For example if I ask: "Okay, and <em>how</em> does it add complexity for the simple cases of read", the post provides no answer.</p>



<a name="271991866"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/271991866" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Yoshua Wuyts [he/they] <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#271991866">(Feb 15 2022 at 15:40)</a>:</h4>
<p>I guess I'm hoping to see a follow-up to this post which goes in more depth (doesn't need to be a post itself necessarily; for example an mdbook might work well for this level of detail).</p>



<a name="271991907"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/271991907" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Yoshua Wuyts [he/they] <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#271991907">(Feb 15 2022 at 15:40)</a>:</h4>
<p>Does that make sense?</p>



<a name="271992775"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/271992775" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#271992775">(Feb 15 2022 at 15:47)</a>:</h4>
<p>Yeah, it makes sense but if I gave each alternative that much detail it would be very long</p>



<a name="271992874"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/271992874" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#271992874">(Feb 15 2022 at 15:48)</a>:</h4>
<p>Probably some examples to illustrate in the repo would be good</p>



<a name="271993136"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/271993136" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Yoshua Wuyts [he/they] <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#271993136">(Feb 15 2022 at 15:50)</a>:</h4>
<p>heh, yeah I understand that - but this is also very important, and I'd actually like to understand every aspect that lead you to this conclusion. Right now it doesn't feel like I can meaningfully engage with your conclusion because I don't have the same information you have when you arrived at it.</p>



<a name="271993390"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/271993390" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Yoshua Wuyts [he/they] <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#271993390">(Feb 15 2022 at 15:51)</a>:</h4>
<p>I like the list of "goals" put forward at the start of the post. I'd like to see all other alternatives evaluated against these goals too.</p>



<a name="271998524"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/271998524" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Toby Lawrence <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#271998524">(Feb 15 2022 at 16:22)</a>:</h4>
<p>is this happening prior to or in parallel with an actual RFC? I love blogs for reading about ideas, but they kind of suck for meaningfully engaging in terms of trying to go from idea to design/plan</p>



<a name="271999179"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/271999179" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#271999179">(Feb 15 2022 at 16:27)</a>:</h4>
<p>I would like to discuss now, then implement in futures-rs, getting buy-in from runtimes in parallel with these two steps, then RFC to land in std</p>



<a name="271999387"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/271999387" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Toby Lawrence <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#271999387">(Feb 15 2022 at 16:28)</a>:</h4>
<p>yeah, I guess the mdbook approach hits this mark, but said another way: something more amenable to commenting inline would be appreciated; blogs fail badly on that front <span aria-label="pray" class="emoji emoji-1f64f" role="img" title="pray">:pray:</span></p>



<a name="271999540"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/271999540" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Toby Lawrence <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#271999540">(Feb 15 2022 at 16:29)</a>:</h4>
<p>err, not mdbook, I was thinking of hackmd</p>



<a name="272019669"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/272019669" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#272019669">(Feb 15 2022 at 18:45)</a>:</h4>
<p><span class="user-mention" data-user-id="256841">@Nick Cameron</span> I'm not getting syntax highlighting on my end, is that expected?</p>
<p><a href="/user_uploads/4715/eVWobt-K4uQr_UPWILW76V-l/Screen-Shot-2022-02-15-at-19.45.43.png">Screen-Shot-2022-02-15-at-19.45.43.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/4715/eVWobt-K4uQr_UPWILW76V-l/Screen-Shot-2022-02-15-at-19.45.43.png" title="Screen-Shot-2022-02-15-at-19.45.43.png"><img src="/user_uploads/4715/eVWobt-K4uQr_UPWILW76V-l/Screen-Shot-2022-02-15-at-19.45.43.png"></a></div>



<a name="272022248"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/272022248" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#272022248">(Feb 15 2022 at 19:03)</a>:</h4>
<p>Unfortunately yeah</p>



<a name="272035077"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/272035077" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#272035077">(Feb 15 2022 at 20:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="363998">Ibraheem Ahmed</span> <a href="#narrow/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal/near/271985944">said</a>:</p>
<blockquote>
<p>The idea would be Read implementations on an async resource would be non blocking</p>
</blockquote>
<p>I don't think that assumption would work in some cases. Some resources may want to support both blocking and non-blocking operations.</p>



<a name="272035284"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/272035284" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#272035284">(Feb 15 2022 at 20:45)</a>:</h4>
<p>Regarding the <code>AsyncIo</code> trait, that seems like it would break something that <code>AsyncRead</code> and <code>AsyncWrite</code> don't: with <code>AsyncRead</code> and <code>AsyncWrite</code> it's possible to handle underlying systems that can't wait for something without providing a buffer.</p>



<a name="272035377"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/272035377" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#272035377">(Feb 15 2022 at 20:46)</a>:</h4>
<p><code>select</code>/<code>epoll</code>-style systems work on a file descriptor, and can just ask for readiness; those would work just fine with <code>AsyncIo</code>.</p>



<a name="272035454"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/272035454" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#272035454">(Feb 15 2022 at 20:47)</a>:</h4>
<p>iocb-based systems or Windows overlapped I/O or EFI I/O or io_uring, on the other hand, all really want to have the buffer available to queue the read/write with.</p>



<a name="272039283"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/272039283" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#272039283">(Feb 15 2022 at 21:15)</a>:</h4>
<p>Yeah, if you want optimal performance for completion systems you have to use the BufRead trait. They’ll work with Read and Ready, but it will need to do a copy</p>



<a name="272040622"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/272040622" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#272040622">(Feb 15 2022 at 21:26)</a>:</h4>
<p>Same with <code>Write</code>: you want to supply the data to be written as early as possible, not just when the device is ready.</p>



<a name="272040661"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/272040661" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#272040661">(Feb 15 2022 at 21:27)</a>:</h4>
<p>(It's less of an issue with <code>Write</code> because OSes typically indicate things as ready even when they're not, to be able to capture and queue things sooner, but still.)</p>



<a name="272041058"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/272041058" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#272041058">(Feb 15 2022 at 21:30)</a>:</h4>
<p>Yeah, everything applies the same to writing as reading</p>



<a name="272051697"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/272051697" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#272051697">(Feb 15 2022 at 23:13)</a>:</h4>
<p>Another potential footgun with <code>AsyncReady</code>: you can't wait for two or more things to be ready, and assume they all will be simultaneously. So, for instance, you can't wait for a reader and a writer to be ready, then read from the reader and write to the writer and assume the latter won't block and leave you holding a buffer.</p>



<a name="272051738"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/272051738" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#272051738">(Feb 15 2022 at 23:13)</a>:</h4>
<p>Since another reader might have consumed the data, or another writer might have written data to the writer and filled it up.</p>



<a name="272051830"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/272051830" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#272051830">(Feb 15 2022 at 23:14)</a>:</h4>
<blockquote>
<p>The optimal way to use completion-based IO is to use the async version of the BufRead trait. The design of that is left for future work, but I don't anticipate any significant issues.</p>
</blockquote>
<p>I do think we want the design of that to be present <em>before</em> we commit to a read/write design that assumes BufRead will be feasible for that case.</p>



<a name="272051997"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/272051997" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#272051997">(Feb 15 2022 at 23:16)</a>:</h4>
<p>On a different note: since we're designing these traits without a backwards compatibility concern, should we have <em>any</em> implementation that uses initialized buffers rather than <code>ReadBuf</code>?</p>



<a name="272052046"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/272052046" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#272052046">(Feb 15 2022 at 23:17)</a>:</h4>
<p>It seems like we can make <code>ReadBuf</code> sufficiently ergonomic to use that we don't need <code>&amp;[u8]</code> versions.</p>



<a name="272084683"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/272084683" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#272084683">(Feb 16 2022 at 08:14)</a>:</h4>
<p>I plan on doing BufRead next, so should be done way before moving into std</p>



<a name="272084764"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/272084764" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#272084764">(Feb 16 2022 at 08:15)</a>:</h4>
<p>It’s a good question about whether we need the bytes version at all, I’ll add it as an alternative. My feeling is that we should try to be as close as possible to the sync versions and it’s worth the small cost to have the extra methods, but I don’t feel strongly about it</p>



<a name="272084844"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/272084844" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#272084844">(Feb 16 2022 at 08:16)</a>:</h4>
<p>I should clarify that ready can always return false positives, so the caller needs to be prepared for these situations</p>



<a name="272090935"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/272090935" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#272090935">(Feb 16 2022 at 09:22)</a>:</h4>
<p>Wait, false <em>positives</em>? So ready can say that it's ready when it isn't ready?</p>



<a name="272091002"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/272091002" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#272091002">(Feb 16 2022 at 09:23)</a>:</h4>
<p>So if you called <code>read</code> after <code>ready</code>, expecting data, you could just hang? And <code>non_blocking_read</code> could return no data?</p>



<a name="272091011"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/272091011" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#272091011">(Feb 16 2022 at 09:24)</a>:</h4>
<p>What's the use case for that?</p>



<a name="272095227"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/272095227" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#272095227">(Feb 16 2022 at 10:05)</a>:</h4>
<p>Yep. There's not so much a use case as a constraint of the underlying systems. AIUI, epoll can return false positives, but even if not, another process could have another handle to the same resource and read from it before our process gets a chance so that when we read there is nothing left. This is why the non-blocking functions can return would block errors and the memory-optimal path has to deal with those explicitly rather than leaving them to the runtime</p>



<a name="272095261"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/272095261" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#272095261">(Feb 16 2022 at 10:05)</a>:</h4>
<p>To be clear, nothing hangs, you would immediately get WouldBlock</p>



<a name="272148070"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/272148070" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Justin Karneges <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#272148070">(Feb 16 2022 at 17:24)</a>:</h4>
<p>if a goal is to mimic the sync traits, the methods should probably use [u8] slices. and if we'd rather have ReadBuf, then maybe it should be adopted by the sync traits first?</p>



<a name="272149210"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/272149210" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#272149210">(Feb 16 2022 at 17:31)</a>:</h4>
<p>ReadBuf has been adopted on nightly</p>



<a name="272149772"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/272149772" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Justin Karneges <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#272149772">(Feb 16 2022 at 17:35)</a>:</h4>
<p>oh! well then :)</p>



<a name="272150273"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/272150273" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Justin Karneges <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#272150273">(Feb 16 2022 at 17:38)</a>:</h4>
<p>how about <code>read_nonblocking</code> instead of <code>non_blocking_read</code> ? thinking about existing methods like <code>TcpStream::set_nonblocking</code> and the fact that most of the methods in the Read trait begin with <code>read_</code></p>



<a name="272151257"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/272151257" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#272151257">(Feb 16 2022 at 17:45)</a>:</h4>
<p><span class="user-mention" data-user-id="256841">@Nick Cameron</span> I'm curious, you referenced <code>smol</code> in your post, have you seen the <code>smol::Async</code> helper and its readiness functions, and the style of implementation those support?</p>



<a name="272152630"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/272152630" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#272152630">(Feb 16 2022 at 17:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="462944">Justin Karneges</span> <a href="#narrow/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal/near/272150273">said</a>:</p>
<blockquote>
<p>how about <code>read_nonblocking</code> instead of <code>non_blocking_read</code> ? thinking about existing methods like <code>TcpStream::set_nonblocking</code> and </p>
</blockquote>
<p>That sounds reasonable and at the least it sounds like we should drop the <code>_</code>. I'll note though that TcpStream::set_nonblocking sets a property called non-blocking, it is not a variant of a set function which does not block.</p>
<blockquote>
<p>the fact that most of the methods in the Read trait begin with <code>read_</code></p>
</blockquote>
<p>I think it might be useful to distinguish at a glance the non-blocking functions from the various other read variants - if nonblocking is a suffix then the suffix position for all these functions gets very busy.</p>



<a name="272152858"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/272152858" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#272152858">(Feb 16 2022 at 17:55)</a>:</h4>
<blockquote>
<p>I'm curious, you referenced smol in your post, have you seen the smol::Async helper and its readiness functions, and the style of implementation those support?</p>
</blockquote>
<p>I've seen Async but not looked at the implementation, I'm not sure which readiness functions you're referring to?</p>



<a name="272153898"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/272153898" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#272153898">(Feb 16 2022 at 18:01)</a>:</h4>
<p><span class="user-mention" data-user-id="256841">@Nick Cameron</span> <code>Async&lt;T&gt;</code> wraps anything that has a file descriptor or handle, automatically puts it into non-blocking mode, and then provides async functions <code>readable</code> and <code>writable</code> that wait until that condition, or helpers like <code>read_with</code>/<code>read_with_mut</code> that handle the readiness conditions automatically and call your closure when the condition is met.</p>



<a name="272153946"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/272153946" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#272153946">(Feb 16 2022 at 18:01)</a>:</h4>
<p>Very convenient for implementing async types.</p>



<a name="272157557"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/272157557" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Justin Karneges <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#272157557">(Feb 16 2022 at 18:24)</a>:</h4>
<p>another idea I'll throw out there, which may be crazy, is to consider having the async traits depend on the sync traits, and using the sync traits for I/O. after all, people use the sync traits for non-blocking I/O and this is a legitimate use of them</p>



<a name="272238377"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/272238377" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dirkjan Ochtman <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#272238377">(Feb 17 2022 at 10:13)</a>:</h4>
<p>The first memory-sensitive implementation made me think that the <code>ready()</code> method should return a separate type that you can run the <code>non_blocking_read()</code> against</p>



<a name="272241128"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/272241128" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#272241128">(Feb 17 2022 at 10:38)</a>:</h4>
<p>You don't have to wait for ready(), its perfectly safe and legal (though sub-optimal) to just poll the non_blocking methods and handle the would-block errors</p>



<a name="272241164"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/272241164" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#272241164">(Feb 17 2022 at 10:38)</a>:</h4>
<p>(not sure if there is any reason to actually do that)</p>



<a name="272247348"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/272247348" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Yoshua Wuyts [he/they] <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#272247348">(Feb 17 2022 at 11:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="239881">Josh Triplett</span> <a href="#narrow/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal/near/272153946">said</a>:</p>
<blockquote>
<p>Very convenient for implementing async types.</p>
</blockquote>
<p>That's actually a good point. If <code>std</code> would provide a <code>smol::Async</code>-like type, then those who want to could just open a <code>std::fs::File</code> in non-blocking mode, and manually wait for readiness events. Afaict there's no real difference between <code>std::io::Read::read</code> and <code>AsyncRead::read_non_blocking</code>.</p>
<p>Instead of extending the async APIs with non-async capabilities for performance, this builds up the non-async APIs with the ability to wait for readiness events.</p>



<a name="272247571"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/272247571" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Yoshua Wuyts [he/they] <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#272247571">(Feb 17 2022 at 11:47)</a>:</h4>
<p>In std we could even imagine that for example <code>std::async_fs::File</code> is implemented in terms of an <code>Async&lt;std::fs::File&gt;</code>. So we could expose a safe cast to access the internal value for specialized uses.</p>



<a name="272247869"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/272247869" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Yoshua Wuyts [he/they] <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#272247869">(Feb 17 2022 at 11:50)</a>:</h4>
<p>I feel like we've already acknowledged that waiting on readiness APIs and <code>non_blocking_read</code> is a niche (but valid!) use case. So moving it off the main API into its own section might be the right way to go about this.</p>
<p>Idk, this feels like the most balanced direction I've seen proposed so far. And I wonder if we could try thinking this through entirely.</p>



<a name="272250599"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/272250599" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Yoshua Wuyts [he/they] <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#272250599">(Feb 17 2022 at 12:17)</a>:</h4>
<p>Stepped away for a sec, and now realizing that <code>smol::Async</code> is in fact a <em>concrete</em> runtime building block, and what we're looking for is an <em>abstract</em> interface that expresses the same capabilities. So we can't lift the implementation 1:1 for this purpose - so this will require some design work. But I think this has potential.</p>



<a name="272263641"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/272263641" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ibraheem Ahmed <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#272263641">(Feb 17 2022 at 14:06)</a>:</h4>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">struct</span> <span class="nc">Token</span><span class="p">(</span><span class="kt">u64</span><span class="p">);</span><span class="w"></span>

<span class="k">trait</span><span class="w"> </span><span class="n">Registry</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">register</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">fd</span>: <span class="nc">RawFd</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="n">Token</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">poll_ready</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">token</span>: <span class="nc">Token</span><span class="p">,</span><span class="w"> </span><span class="n">interest</span>: <span class="nc">Interest</span><span class="p">,</span><span class="w"> </span><span class="n">cx</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;'</span><span class="nb">_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="n">Poll</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;&gt;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">deregister</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">token</span>: <span class="nc">Token</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">Async</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">AsRawFd</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">fd</span>: <span class="nc">RawFd</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">token</span>: <span class="nc">Token</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Async</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">io</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="bp">Self</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">        </span><span class="n">with</span><span class="w"> </span><span class="n">registry</span>: <span class="nc">Registry</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// ...</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>



<a name="272349153"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/272349153" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#272349153">(Feb 18 2022 at 01:38)</a>:</h4>
<p><span class="user-mention" data-user-id="256841">@Nick Cameron</span> I shared your blog post with the Fuchsia filesystems team and got this feedback:</p>
<blockquote>
<p>The proposal suggests that for optimal performance, Ready should be used followed by a read call later. I think that might be quite challenging for us to implement because it would require locking between the ready notification and the read (to prevent the kernel discarding pages under memory pressure) and AFAICT, there's no indication of how much should be locked in the ready call.</p>
</blockquote>



<a name="272349237"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/272349237" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#272349237">(Feb 18 2022 at 01:39)</a>:</h4>
<p>I'm wondering if a byte count could be added to <code>Interest</code></p>



<a name="272377766"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/272377766" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#272377766">(Feb 18 2022 at 09:17)</a>:</h4>
<p>Thanks for running it by them! So, I know nothing about Fuchsia, so excuse my basic questions :-) Is it a readiness model for async IO it supports? Do they want to lock the pages for correctness or performance? The ready method is allowed false positives, so from the APIs PoV, if Fuchsia says a resource is ready but the page is discarded so read/write returns would-block, that is fine. Of course if that happens a lot then it isn't very performant. OTOH if ready locks a page and the user never calls read/write, then that seems bad unless the lock can timeout?</p>



<a name="272377928"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/272377928" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#272377928">(Feb 18 2022 at 09:19)</a>:</h4>
<p>We could add a byte count to interest</p>



<a name="272378081"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/272378081" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#272378081">(Feb 18 2022 at 09:20)</a>:</h4>
<p>I wonder whether this might be a case where the optimal API for Fuchsia is different to epoll? Similarly to how for IOCP or io_uring the BufRead API will be more optimal?</p>



<a name="272378779"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/272378779" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#272378779">(Feb 18 2022 at 09:28)</a>:</h4>
<blockquote>
<p>another idea I'll throw out there, which may be crazy, is to consider having the async traits depend on the sync traits, and using the sync traits for I/O. after all, people use the sync traits for non-blocking I/O and this is a legitimate use of them</p>
</blockquote>



<a name="272379479"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/272379479" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#272379479">(Feb 18 2022 at 09:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="239881">Josh Triplett</span> <a href="#narrow/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal/near/272153898">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="256841">Nick Cameron</span> <code>Async&lt;T&gt;</code> wraps anything that has a file descriptor or handle, automatically puts it into non-blocking mode, and then provides async functions <code>readable</code> and <code>writable</code> that wait until that condition, or helpers like <code>read_with</code>/<code>read_with_mut</code> that handle the readiness conditions automatically and call your closure when the condition is met.</p>
</blockquote>
<p>So, readable/writable are less general forms of the <code>ready</code> method from my proposal, I discuss having methods like readable /writable as an alternative, and it seems reasonable though not as flexible. The read_with style of helper looks interesting, that could potentially make the memory-optimal path more ergonomic.</p>



<a name="272379723"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/272379723" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#272379723">(Feb 18 2022 at 09:39)</a>:</h4>
<p>However, for that seems limited to waiting for a single operation on a single resource, whereas often users will want to wait on either multiple resources in a single loop and/or multiple operations on a resource, and in that case the helper methods wouldn't help. I'm not sure how often these use cases come up though. It would depend on how often a user would just use the async fn vs use the helper vs write the loop, whether its worth adding them</p>



<a name="272379768"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/272379768" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#272379768">(Feb 18 2022 at 09:39)</a>:</h4>
<p>In any case, I'll add a note on the tracking issue. Thanks for pointing it out!</p>



<a name="272380164"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/272380164" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#272380164">(Feb 18 2022 at 09:44)</a>:</h4>
<blockquote>
<p>Stepped away for a sec, and now realizing that smol::Async is in fact a concrete runtime building block, and what we're looking for is an abstract interface that expresses the same capabilities. So we can't lift the implementation 1:1 for this purpose - so this will require some design work. But I think this has potential.</p>
</blockquote>
<p>This seems like a really interesting idea, though I don't see exactly how this would work without fleshing out the design. A couple of problems I see are making sure this still works nicely for generic programming, i.e., we can still write a bound equivalent to <code>T: AsyncRead + AsyncWrite</code>, and I'm wary of adding to the sync traits anything that is not relevant for people not doing async programming, since that would be making the 'easy' path in the language harder. (Violating some principal of zero-cost abstractions applied to ergonomics rather than performance)</p>



<a name="272435308"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/272435308" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Justin Karneges <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#272435308">(Feb 18 2022 at 18:01)</a>:</h4>
<blockquote>
<p>the sync ones should handle would-block internally</p>
</blockquote>
<p>if you mean using std::io::Read/Write for blocking I/O shouldn't return WouldBlock, I agree. however, those traits can be used for non-blocking I/O too. perhaps "sync" is the wrong word to describe the std::io traits, since they are not strictly limited to synchronous use-cases</p>
<blockquote>
<p>They may also want to be different concrete types</p>
</blockquote>
<p>sure, and they still could be, unless I'm missing something. for example, std::net::TcpStream implements std::io::Read/Write, and a hypothetical async::TcpStream could implement both async::Read/Write and std::io::Read/Write.</p>
<blockquote>
<p>having types with modes (in this case sync vs async) which are not reflected in the types is confusing and error-prone</p>
</blockquote>
<p>I suspect most developers would create multiple types rather than create single types with modes. what I'm mainly suggesting here is a way to avoid duplicating interfaces. if async::Read needs a helper method that is more or else identical to the read method in std::io::Read, then there could be value in reusing the interface. it may also make wrapping &amp; forwarding easier. for example, async::TcpStream wrapping a std::net::TcpStream, setting it to non-blocking mode, and forwarding the std::io methods</p>



<a name="272443321"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/272443321" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#272443321">(Feb 18 2022 at 19:04)</a>:</h4>
<p>I think that would still be a bit confusing, especially with generic programming - a function which takes an impl or dyn Read expects blocking behaviour and won't handle the would-block error properly</p>



<a name="272451092"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/272451092" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ibraheem Ahmed <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#272451092">(Feb 18 2022 at 20:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="256841">Nick Cameron</span> <a href="#narrow/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal/near/272443321">said</a>:</p>
<blockquote>
<p>I think that would still be a bit confusing, especially with generic programming - a function which takes an impl or dyn Read expects blocking behaviour and won't handle the would-block error properly</p>
</blockquote>
<p>That's not entirely true, there are APIs that expect a <code>T: Read</code> set to non-blocking mode</p>



<a name="272455150"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/272455150" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#272455150">(Feb 18 2022 at 20:46)</a>:</h4>
<p>Right but that’s a requirement of the api, this would be up to the concrete type so there is no way that the callee could always do the right thing</p>



<a name="272461929"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/272461929" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Justin Karneges <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#272461929">(Feb 18 2022 at 21:47)</a>:</h4>
<p>it's always up to the concrete type to decide whether to operate in blocking mode or not</p>



<a name="273029961"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/273029961" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#273029961">(Feb 24 2022 at 00:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="256841">Nick Cameron</span> <a href="#narrow/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal/near/272377766">said</a>:</p>
<blockquote>
<p>Is it a readiness model for async IO it supports?</p>
</blockquote>
<p>Just catching up from vacation, sorry for the delay. Yes, the readiness model seems like a good fit for the <a href="https://fuchsia.googlesource.com/fuchsia/+/refs/heads/main/sdk/lib/zxio/#asynchronously-waiting-for-state-changes">zxio APIs</a></p>



<a name="273029989"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/273029989" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#273029989">(Feb 24 2022 at 00:05)</a>:</h4>
<p>I'm waiting to hear back on the locking question</p>



<a name="273030058"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/273030058" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#273030058">(Feb 24 2022 at 00:06)</a>:</h4>
<p>Another thing that was brought up:</p>
<blockquote>
<p>one thing to be concerned with is how readiness works when it's queued multiple times, there are subtle differences between kqueue/epoll/uring/etc behavior for those use cases, and the api might want to be clear about user expectations if it's trying to be portable</p>
</blockquote>



<a name="273031412"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/273031412" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> James Robinson <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#273031412">(Feb 24 2022 at 00:23)</a>:</h4>
<p>Hi folks! I work on parts of Fuchsia's IO stack (such as zxio mentioned by Tyler). There was a question earlier about the readiness model. We do support a readiness model for all IO objects. Whether that's the right model to use for a given operation and the details of the operation is a different issue. Catching up here it's not clear to me exactly what the intended use cases are for this API vs others.</p>



<a name="273032102"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/273032102" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> James Robinson <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#273032102">(Feb 24 2022 at 00:32)</a>:</h4>
<p>At a high level, it'll generally be more efficient to have clients tell the OS what operation they want completed in order for them to make progress and then we can signal them when that is complete. In the read case a program can usually make useful forward progress once the data that they want to read is available, not just when they can start the read. There's sometimes more refinement - such as asking to be informed when a socket has at least a certain amount of data available.</p>



<a name="273034803"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/273034803" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#273034803">(Feb 24 2022 at 01:05)</a>:</h4>
<p>I think this boils down to adding an optional byte count to the <code>Interest</code> type.</p>



<a name="273035457"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/273035457" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#273035457">(Feb 24 2022 at 01:13)</a>:</h4>
<blockquote>
<p>Catching up here it's not clear to me exactly what the intended use cases are for this API vs others.</p>
</blockquote>
<p>To summarize my understanding (<span class="user-mention" data-user-id="256841">@Nick Cameron</span> can correct me if I'm wrong), it's to provide an asynchronous analogue to the <a href="https://doc.rust-lang.org/stable/std/io/trait.Read.html"><code>io::Read</code></a> and <a href="https://doc.rust-lang.org/stable/std/io/trait.Write.html"><code>io::Write</code></a> traits, which <em>allow the caller to fully manage the target buffer</em> between calls and are used for file I/O, sockets, and "middleware" layers. The interface should resemble the original traits without giving up performance (under the constraint that the caller fully manages the target buffer).</p>
<p>Interfaces that allow the underlying implementation to manage the target buffer (i.e. completion-backed APIs that hand the kernel a target buffer to write to) would be abstracted behind an async version of the <a href="https://doc.rust-lang.org/nightly/std/io/trait.BufRead.html"><code>io::BufRead</code></a> trait, which hasn't been specced out yet.</p>



<a name="273089474"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/273089474" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#273089474">(Feb 24 2022 at 13:37)</a>:</h4>
<p>Yep, that's a good summary</p>



<a name="273089941"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/273089941" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#273089941">(Feb 24 2022 at 13:41)</a>:</h4>
<p>It sounds from the above and from the zxio docs that zxio is more of a completion based system? I.e., for a read, the kernel gets a buffer pointer, fills the buffer, and notifies the client when the read is done (i.e., data has been written in to the buffer). Even though the user is responsible for keeping the buffer alive for the duration of the call, I think ownership is still morally transferred to the kernel. Thus the BufRead/BufWrite traits are going to be a better match for Fuschia.</p>



<a name="273090082"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/273090082" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#273090082">(Feb 24 2022 at 13:42)</a>:</h4>
<blockquote>
<p>I think this boils down to adding an optional byte count to the Interest type.</p>
</blockquote>
<p>I think this makes more sense for the BufRead case than for Read. For Read, I'd expect a notification as soon as any data is ready to be read, and the kernel may not even know how much there is. For BufRead, it makes sense because it is customising the notion of when the IO is complete</p>



<a name="273308379"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/273308379" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> James Robinson <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#273308379">(Feb 26 2022 at 01:43)</a>:</h4>
<p>In zxio there are two modes of asynchronous operations. One is to ask the object to perform the operation and asynchronously notify the caller when it is complete (completion based, as you say). We support this on some operations and plan to expand support. The other is a two-phase approach where you first ask the object to notify you asynchronously when an operation of a certain type (read/write/etc) could start, and when you ask the object to attempt the operation (zxio doesn't block if the operation can't be performed but it returns an error). The two-phase approach is supported by all objects and maps naturally to common patterns like select/poll/epoll and O_NONBLOCK semantics. I believe it's pretty similar to the async Read proposal above. The completion based approach may map well to BufRead - although I'm not sure precisely what that proposal is</p>
<p>While we do support the two-phase mode universally it can be significantly less efficient than performing the operation itself asynchronously. There are several challenges for the implementation of the file object (kernel, filesystem, whatnot). The implementation has to maintain many invariants on the file for each operation - such as atomicity and ordering w.r.t. the seek positioning and size - so it can't perform much work when told that someone is interested in a type. It's also difficult to avoid thundering herds when many clients are asking to perform the same operation on the same object.</p>



<a name="274581403"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/274581403" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Suter <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#274581403">(Mar 08 2022 at 18:12)</a>:</h4>
<p>BTW, I'm the author of the "The proposal suggests that for optimal performance" comment. I'm interested in this API for filesystem I/O (not so much stream based I/O) and I've been thinking about an async kernel interface (which we haven't really done yet on Fuchsia). Even with a byte count for Interest, I think it's still problematic for the reasons mentioned: locking pages is impractical so we'd end up retrying but that's undesirable for a high performance interface — the last thing you want is for performance to drop off a cliff at the limits. One thing that might be worth thinking about is how cancellation is going to work and limiting the number of memory copies we do. We'd either need to support a syscall that cancels a queued I/O operation, or buffers need to change owners or be 'static or something else (cf. BufReader). It would be nice to sketch out the ideal kernel interface for Rust async I/O.</p>



<a name="275674626"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/275674626" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#275674626">(Mar 17 2022 at 15:50)</a>:</h4>
<p>I've started to write up the IO traits proposal in a GH repo and will continue to evolve it there: <a href="https://github.com/nrc/portable-interoperable/tree/master/io-traits">https://github.com/nrc/portable-interoperable/tree/master/io-traits</a></p>



<a name="275674760"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/275674760" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#275674760">(Mar 17 2022 at 15:50)</a>:</h4>
<p>I haven't started to address the 'Fuchsia' comments yet, but I'll try and get a better understanding of those issues next</p>



<a name="275674928"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/275674928" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#275674928">(Mar 17 2022 at 15:51)</a>:</h4>
<p>cc <span class="user-mention" data-user-id="211722">@Yoshua Wuyts [he/they]</span> I've included some expanded discussion of the alternatives for async::Read/Write. Could you file issues or send a PR for anything you think is misrepresented or should be further addressed?</p>



<a name="275679258"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/275679258" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Yoshua Wuyts [he/they] <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#275679258">(Mar 17 2022 at 16:08)</a>:</h4>
<p>Will do! -- I'll make sure to make some time for that</p>



<a name="275697971"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/275697971" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Yoshua Wuyts [he/they] <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#275697971">(Mar 17 2022 at 17:28)</a>:</h4>
<p><span class="user-mention" data-user-id="256841">@Nick Cameron</span> done: <a href="https://github.com/nrc/portable-interoperable/issues/7">https://github.com/nrc/portable-interoperable/issues/7</a> -- it's a chonky issue that suggests a rather large change. But I can make time to help with this work.</p>



<a name="275698453"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/275698453" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Yoshua Wuyts [he/they] <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#275698453">(Mar 17 2022 at 17:32)</a>:</h4>
<p>I guess what I'm suggesting is loosely inspired by the "decision tree" approach we've taken for other designs in the past.  That worked rather well in creating shared understanding, ensuring everyone's opinion was represented, and allowing others to follow along with the rationale.</p>
<p>I believe <span class="user-mention" data-user-id="116009">@nikomatsakis</span> introduced me to that? - was it for the <code>async/.await</code> syntax?</p>



<a name="275702278"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/275702278" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#275702278">(Mar 17 2022 at 18:00)</a>:</h4>
<p><span class="user-mention" data-user-id="256841">@Nick Cameron</span> Under what circumstances do you expect the Ready trait to be implemented via some means other than epoll/WaitForMultipleObjects?</p>



<a name="275702447"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/275702447" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#275702447">(Mar 17 2022 at 18:01)</a>:</h4>
<p>I'm asking because I wonder if we could simplify the design by relying on AsFd/AsHandle.</p>



<a name="275771753"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/275771753" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#275771753">(Mar 18 2022 at 08:26)</a>:</h4>
<p>I'm not quite clear what that means. I would expect all IO systems to implement Ready. For completion systems it would be a sub-optimal implementation and the optimal path is using BufRead, but they would probably still want to implement it for completeness. I would expect any readiness system to implement it directly. I don't have an exhaustive list of these systems, but KQueue is an example. I'm not sure either what a simplification using FDs/handles would look like?</p>



<a name="275772547"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/275772547" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#275772547">(Mar 18 2022 at 08:36)</a>:</h4>
<p><span class="user-mention" data-user-id="211722">@Yoshua Wuyts [he/they]</span> one thing is that the designs should be read in conjunction with the blog posts which explicitly list requirements (under 'goals'), etc. I would like to evolve the design work in the repo to include that (and more) so that they standalone, but for now there is a lot of supporting work in the blog posts. I also list for the alternatives where they fall down against those goals. So I think there is most of the information you want but in a different format?</p>



<a name="275788692"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/275788692" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Yoshua Wuyts [he/they] <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#275788692">(Mar 18 2022 at 11:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="256841">Nick Cameron</span> <a href="#narrow/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal/near/275772547">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="211722">Yoshua Wuyts [he/they]</span> I would like to evolve the design work in the repo to include that (and more) so that they standalone [...].</p>
</blockquote>
<p>Yes, that would be fantastic. I'm looking forward to it!</p>



<a name="275788717"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/275788717" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Yoshua Wuyts [he/they] <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#275788717">(Mar 18 2022 at 11:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="256841">Nick Cameron</span> <a href="#narrow/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal/near/275772547">said</a>:</p>
<blockquote>
<p>So I think there is most of the information you want but in a different format?</p>
</blockquote>
<p>I'm not sure. I feel like some of the requirements I care about haven't been sufficiently addressed. And there are definitely experiments which I think we should conduct which don't have a clear place to put. The way the information is currently structured makes it hard to say anything for sure, so that's why I'm keen that on us addressing that first.</p>



<a name="275816480"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Async%20IO%20traits%20proposal/near/275816480" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Async.20IO.20traits.20proposal.html#275816480">(Mar 18 2022 at 15:16)</a>:</h4>
<p>I've started moving blog post text to the repo, including the requirements and some accounting of how well the proposal meets them</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>