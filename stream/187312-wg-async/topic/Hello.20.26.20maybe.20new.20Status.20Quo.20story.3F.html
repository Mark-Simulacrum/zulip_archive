<html>
<head><meta charset="utf-8"><title>Hello &amp; maybe new Status Quo story? · wg-async · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/index.html">wg-async</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Hello.20.26.20maybe.20new.20Status.20Quo.20story.3F.html">Hello &amp; maybe new Status Quo story?</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="256018871"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Hello%20%26%20maybe%20new%20Status%20Quo%20story%3F/near/256018871" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> JonRoss <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Hello.20.26.20maybe.20new.20Status.20Quo.20story.3F.html#256018871">(Oct 04 2021 at 07:48)</a>:</h4>
<p>Hello. I'm new-ish to Rust and very new to community involvement. If this is an inappropriate place to post this, I apologize in advance. </p>
<p>I have a story (maybe a few?) they are closely related to the "Grace wants a zero-copy API". I do ultra-low latency work. Think high-frequency trading or stock exchanges. I've been using Rust for some pet projects, but I'm now evaluating Rust for an upcoming ULL project.  Specifically, I'm looking at the async / await abstraction, as it's a lot nicer to read/write async code rather than callback-hell. If I can make it performant enough, I'd like to use it.</p>
<p>So first a little background, and then the issues I've run into.  ULL code has these properties :</p>
<p>It will use one and only one thread.<br>
It will never call epool/poll/select. It only communicates via shared memory. Either DMA'd data from the NICs (EFVI, DPDK, OpenOnload, etc). Or from other processes on the box. A big spin-loop across multiple queues.<br>
It will never cancel a task. Most are created at startup. The few ephemeral ones that pop up, exit when finished (TCP backpressure. A task works that "socket" until the stream is "current", then goes away).</p>
<p>So the problem I've run into is that in a single-threaded context, async / await seems to devolve into coroutines except way harder to use. The abstraction to separate executors and reactors breaks down. If they aren't the same code, they are calling into each other. Every call to wake() is a direct call to poll().   The Future itself loses meaning. Getting data from the reactor into the Future is a PIA (await holds the mut ref on the Future). Moving data from the Future to the reactor is less hard but awkward.</p>
<p>Unrelated to my problem, but every runtime has a multi-threaded and single-threaded version that only differs by the requirement for mutex/sync. (at least from a users POV)</p>
<p>This is likely unworkable, but I'm gonna throw it out here anyway: I was playing with zig, and they have a --single-threaded you can pass to the compiler. It does a bunch of neat tricks, like:<br>
making mutex a no-op<br>
making Async Functions equivalent to function call overhead<br>
converting thread-local data to continer/statc data.<br>
So in theory Rust could convert sync/mutex to rc/refcell (might break every library in existence though). You wouldn't need two different APIs for each runtime anymore. Also maybe the bower checker could "ease up" a little if the developer pinky swears there will only be 1 thread? </p>
<p>If this is a domain Rust is interested in working on, I'd be happy to help. It's pretty niche though. It might not be worth the changes required. </p>
<p>I'm working on some benchmarks of different async implementations in various languages. I hope to have something to submit for review if anyone is interested.</p>
<p>Thanks for your time,</p>
<p>-Jon</p>



<a name="256083483"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Hello%20%26%20maybe%20new%20Status%20Quo%20story%3F/near/256083483" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eholk <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Hello.20.26.20maybe.20new.20Status.20Quo.20story.3F.html#256083483">(Oct 04 2021 at 16:03)</a>:</h4>
<p>Hi <span class="user-mention" data-user-id="418973">@JonRoss</span>, if you want to contribute a status quo story, we'd be happy to take one. It sounds like your domain has some interesting constraints, so another story would definitely give some new aspects to consider.</p>



<a name="256083718"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Hello%20%26%20maybe%20new%20Status%20Quo%20story%3F/near/256083718" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eholk <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Hello.20.26.20maybe.20new.20Status.20Quo.20story.3F.html#256083718">(Oct 04 2021 at 16:04)</a>:</h4>
<p>I'd be interesting in seeing your benchmark results when you have them. For example, I don't see any reason why async calls in Rust (at least that are immediately awaited) couldn't be about as cheap as a function call, but if we aren't there yet it'd be interesting to see why.</p>



<a name="256337815"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Hello%20%26%20maybe%20new%20Status%20Quo%20story%3F/near/256337815" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Hello.20.26.20maybe.20new.20Status.20Quo.20story.3F.html#256337815">(Oct 06 2021 at 00:00)</a>:</h4>
<blockquote>
<p>The abstraction to separate executors and reactors breaks down.</p>
</blockquote>
<p>I don't think there's much of an abstraction to separate these in general, FWIW. That's something we would likely tackle as part of the <a href="https://rust-lang.github.io/wg-async-foundations/vision/roadmap/portable.html">portability across runtimes</a> goal.</p>



<a name="256338085"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Hello%20%26%20maybe%20new%20Status%20Quo%20story%3F/near/256338085" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Hello.20.26.20maybe.20new.20Status.20Quo.20story.3F.html#256338085">(Oct 06 2021 at 00:03)</a>:</h4>
<p>Generality across single/multi-threadedness is something I care about too</p>



<a name="256338164"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Hello%20%26%20maybe%20new%20Status%20Quo%20story%3F/near/256338164" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Hello.20.26.20maybe.20new.20Status.20Quo.20story.3F.html#256338164">(Oct 06 2021 at 00:04)</a>:</h4>
<p>See <a href="https://rust-lang.github.io/wg-async-foundations/vision/roadmap/threadsafe_portability.html">threadsafe portability</a> :)</p>



<a name="256338186"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Hello%20%26%20maybe%20new%20Status%20Quo%20story%3F/near/256338186" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Hello.20.26.20maybe.20new.20Status.20Quo.20story.3F.html#256338186">(Oct 06 2021 at 00:04)</a>:</h4>
<p>Also <a href="https://rust-lang.github.io/wg-async-foundations/vision/roadmap/async_overloading.html">async overloading</a></p>



<a name="256382196"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Hello%20%26%20maybe%20new%20Status%20Quo%20story%3F/near/256382196" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> JonRoss <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Hello.20.26.20maybe.20new.20Status.20Quo.20story.3F.html#256382196">(Oct 06 2021 at 09:26)</a>:</h4>
<p>I'll take a stab at a draft in the next week or so.<br>
I should have benchmarks to review by then as well. so far the results are... odd? rust-async is faster than plain rust. Same w/ zig, but only on AMD CPUs. Maybe something wrong with my methodology.</p>



<a name="256672850"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Hello%20%26%20maybe%20new%20Status%20Quo%20story%3F/near/256672850" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ibraheem Ahmed <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Hello.20.26.20maybe.20new.20Status.20Quo.20story.3F.html#256672850">(Oct 08 2021 at 00:53)</a>:</h4>
<p>There is the cost of running the state machine</p>



<a name="256673117"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Hello%20%26%20maybe%20new%20Status%20Quo%20story%3F/near/256673117" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ibraheem Ahmed <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Hello.20.26.20maybe.20new.20Status.20Quo.20story.3F.html#256673117">(Oct 08 2021 at 00:56)</a>:</h4>
<p>I can't see how that could be as cheap as a regular function call</p>



<a name="257444428"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Hello%20%26%20maybe%20new%20Status%20Quo%20story%3F/near/257444428" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> JonRoss <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Hello.20.26.20maybe.20new.20Status.20Quo.20story.3F.html#257444428">(Oct 13 2021 at 21:51)</a>:</h4>
<p>Here are my benchmarks. Happy to hear feedback:<br>
<a href="https://github.com/TwoClocks/coroutine-benchmarks">https://github.com/TwoClocks/coroutine-benchmarks</a></p>



<a name="257445672"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Hello%20%26%20maybe%20new%20Status%20Quo%20story%3F/near/257445672" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> JonRoss <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Hello.20.26.20maybe.20new.20Status.20Quo.20story.3F.html#257445672">(Oct 13 2021 at 22:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="363998">Ibraheem Ahmed</span> <a href="#narrow/stream/187312-wg-async-foundations/topic/Hello.20.26.20maybe.20new.20Status.20Quo.20story.3F/near/256672850">said</a>:</p>
<blockquote>
<p>There is the cost of running the state machine</p>
</blockquote>
<p>I think in the basic coroutines use case, it should/could get down to a function call. Or close to it.</p>



<a name="258120541"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Hello%20%26%20maybe%20new%20Status%20Quo%20story%3F/near/258120541" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eholk <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Hello.20.26.20maybe.20new.20Status.20Quo.20story.3F.html#258120541">(Oct 18 2021 at 23:57)</a>:</h4>
<p>Hey <span class="user-mention" data-user-id="418973">@JonRoss</span>, thanks for the benchmarks! I know you weren't really trying to compare languages, but it looks like all the languages were actually pretty similar.</p>



<a name="258120614"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Hello%20%26%20maybe%20new%20Status%20Quo%20story%3F/near/258120614" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eholk <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Hello.20.26.20maybe.20new.20Status.20Quo.20story.3F.html#258120614">(Oct 18 2021 at 23:58)</a>:</h4>
<p>I didn't read as deeply into the code, so I could probably find this there, but it wasn't really clear to me how each of the variants you tried were different.</p>



<a name="258120630"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Hello%20%26%20maybe%20new%20Status%20Quo%20story%3F/near/258120630" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eholk <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Hello.20.26.20maybe.20new.20Status.20Quo.20story.3F.html#258120630">(Oct 18 2021 at 23:58)</a>:</h4>
<p>Is there one that corresponds to kind of a vanilla async/await implementation in Rust?</p>



<a name="258123830"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Hello%20%26%20maybe%20new%20Status%20Quo%20story%3F/near/258123830" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> JonRoss <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Hello.20.26.20maybe.20new.20Status.20Quo.20story.3F.html#258123830">(Oct 19 2021 at 00:36)</a>:</h4>
<p>Thanks for looking. Does the Rust implementation look sane?</p>
<p>The absolute #s are small. But Rust's behavior seems variable across<br>
different CPUs. For example, callbacks are fast everywhere, except<br>
Rust on Intel. That seems odd / bug? I also think the absolute #s are<br>
a bit higher than the C++/Zig. The market for people who care about<br>
that kind of difference is small, it might not be worth addressing. On<br>
the other hand, it could be made to be the same.</p>
<p>I think the most apparent ergonomic difference is that in all the<br>
other languages, the event-loop doing the suspend needs no information<br>
about the task being suspended. It just gets handed a magic context<br>
from the compiler that it can resume later. In Rust, the future needs<br>
to somehow get it's waker to the event-loop on the first call to<br>
poll(). I could not figure out how to do that w/o a  RefCell to some<br>
shared context.</p>
<p>Perhaps for the more general case, the Rust model is better. But for<br>
my use case, where I just want to use suspend everywhere I'd normally<br>
have a callback, it's "funky" to use, and hard to encapsulate into a<br>
library (I think?).</p>
<p>In the future, if you have other version to try, I'd be happy to<br>
re-run the tests on the same hardware.</p>
<p>I'd be happy to write coroutine version on nightly, if you fell that<br>
code is stable enough for the results to be useful.</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>