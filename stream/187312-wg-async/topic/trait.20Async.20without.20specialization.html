<html>
<head><meta charset="utf-8"><title>trait Async without specialization · wg-async · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/index.html">wg-async</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/trait.20Async.20without.20specialization.html">trait Async without specialization</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="271035909"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/trait%20Async%20without%20specialization/near/271035909" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Frank Steffahn <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/trait.20Async.20without.20specialization.html#271035909">(Feb 07 2022 at 20:15)</a>:</h4>
<p>Hey, I’ve just happened to read into this page <a href="https://rust-lang.github.io/wg-async/vision/roadmap/scopes/capability/variant_async_trait.html">https://rust-lang.github.io/wg-async/vision/roadmap/scopes/capability/variant_async_trait.html</a> when answering a question in a different topic, and wanted to share a rough idea on how to avoid any need for (technically challenging, and also not very pretty) specialization features while creating such an alternative version of the <code>Future</code> trait.</p>
<p>Instead, what one would need is an (opt-in) way to decouple traits from trait impls so that legacy <code>Future</code> implementations would imply an <code>Async</code> implementations, but new implementations, particularly for combinators (addressing the problem discussed on that linked website) can opt-out of the implicit implied <code>Async</code> implementation, and write their own instead.</p>
<p>For anyone interested, here’s a demonstration of some imagined syntax with a few explanations</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">core</span>::<span class="n">pin</span>::<span class="n">Pin</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">core</span>::<span class="n">task</span>::<span class="n">Context</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">core</span>::<span class="n">task</span>::<span class="n">Poll</span><span class="p">;</span><span class="w"></span>

<span class="c1">// "sealed" prevents direct implementations outside of defining crate</span>
<span class="n">sealed</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">Future</span>: <span class="nc">Async</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">poll</span><span class="p">(</span><span class="bp">self</span>: <span class="nc">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">Self</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">cx</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;'</span><span class="nb">_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Poll</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">Output</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">trait</span><span class="w"> </span><span class="n">Async</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="k">fn</span> <span class="nf">apoll</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">cx</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;'</span><span class="nb">_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Poll</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">Output</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// methods implemented in a template aren’t callable outside of defining crate</span>
<span class="c1">// and never callable without fully qualified syntax</span>
<span class="c1">//</span>
<span class="c1">// trait bounds involving template#Future aren’t possible outside of defining crate</span>
<span class="k">trait</span><span class="w"> </span><span class="n">template</span><span class="w"> </span><span class="n">Future</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">poll</span><span class="p">(</span><span class="bp">self</span>: <span class="nc">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">Self</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">cx</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;'</span><span class="nb">_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Poll</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">Output</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// a template trait can have the same name as a sealed trait</span>
<span class="c1">// in bounds, the trait takes precedence, in trait impls the template takes precedence</span>
<span class="c1">//</span>
<span class="c1">// in the defining crate, some disambiguating syntax can be used when necessary</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">template</span>#<span class="n">Future</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Async</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="bp">Self</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">template</span>#<span class="n">Future</span><span class="o">&gt;</span>::<span class="n">Output</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="k">fn</span> <span class="nf">apoll</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">cx</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;'</span><span class="nb">_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Poll</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">Output</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="o">&lt;</span><span class="bp">Self</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">template</span>#<span class="n">Future</span><span class="o">&gt;</span>::<span class="n">poll</span><span class="p">(</span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Pin</span>::<span class="n">new_unchecked</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="n">cx</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">template</span>#<span class="n">Future</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="k">trait</span>#<span class="n">Future</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">poll</span><span class="p">(</span><span class="bp">self</span>: <span class="nc">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">Self</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">cx</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;'</span><span class="nb">_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Poll</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">Output</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="o">&lt;</span><span class="bp">Self</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">template</span>#<span class="n">Future</span><span class="o">&gt;</span>::<span class="n">poll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">cx</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">trait</span><span class="w"> </span><span class="n">template</span><span class="w"> </span><span class="n">OnlyFuture</span>: <span class="nc">Async</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">poll</span><span class="p">(</span><span class="bp">self</span>: <span class="nc">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">Self</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">cx</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;'</span><span class="nb">_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Poll</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">Output</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">OnlyFuture</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="k">trait</span>#<span class="n">Future</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">poll</span><span class="p">(</span><span class="bp">self</span>: <span class="nc">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">Self</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">cx</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;'</span><span class="nb">_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Poll</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">Output</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="o">&lt;</span><span class="bp">Self</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">OnlyFuture</span><span class="o">&gt;</span>::<span class="n">poll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">cx</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// templates can actually be like ordinary traits w.r.t. coherence,</span>
<span class="c1">// we would need to allow a situation like</span>
<span class="c1">//</span>
<span class="c1">// trait A {} trait B {} trait C {}</span>
<span class="c1">// impl&lt;T: A&gt; C for T {}</span>
<span class="c1">// impl&lt;T: B&gt; C for T {}</span>
<span class="c1">//</span>
<span class="c1">// though. This seems reasonable: just disallow downstream implementors to implement</span>
<span class="c1">// *both* A and B, just like a situation like</span>
<span class="c1">//</span>
<span class="c1">// trait A {} trait B {}</span>
<span class="c1">// impl&lt;T: A&gt; B for T {}</span>
<span class="c1">//</span>
<span class="c1">// already prevents downstream implementors from implementing both A and B</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////</span>

<span class="c1">// REMAINDER IN A DIFFERENT CRATE:</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////</span>

<span class="c1">// legacy code still works</span>
<span class="c1">// this implements the trait through the template,</span>
<span class="c1">// hence implementing *both* Future *and* Async trait:</span>
<span class="k">impl</span><span class="w"> </span><span class="n">Future</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">poll</span><span class="p">(</span><span class="bp">self</span>: <span class="nc">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">Self</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">cx</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;'</span><span class="nb">_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Poll</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">Output</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="fm">todo!</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="c1">// even a “recursive” call here would actually call the trait#Future::poll method,</span>
<span class="w">        </span><span class="c1">// because template#Future::</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////</span>

<span class="c1">// new combinators have the ability to implement Future directly with the OnlyFuture template</span>

<span class="k">struct</span> <span class="nc">Join</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="o">&gt;</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">);</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="n">OnlyFuture</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Join</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">where</span><span class="w"></span>
<span class="w">    </span><span class="n">A</span>: <span class="nc">Future</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">B</span>: <span class="nc">Future</span><span class="p">,</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">poll</span><span class="p">(</span><span class="bp">self</span>: <span class="nc">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">Self</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">cx</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;'</span><span class="nb">_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Poll</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">Output</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="fm">todo!</span><span class="p">()</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Async</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Join</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">where</span><span class="w"></span>
<span class="w">    </span><span class="n">A</span>: <span class="nc">Async</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">B</span>: <span class="nc">Async</span><span class="p">,</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="k">fn</span> <span class="nf">apoll</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">cx</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;'</span><span class="nb">_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Poll</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">Output</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="fm">todo!</span><span class="p">()</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// these implementations should have no conflicts</span>
</code></pre></div>
<p>Feel free to ask questions or give feedback; perhaps with such a non-breaking redesign of <code>Future</code> as a motivating use-case, we could work on bringing such features to live (provided they <em>actually</em> turn out to be useful in the way I imagined). The main points above are</p>
<ul>
<li>a dedicated mechanism for use-only traits, i.e. <code>sealed trait</code> (these of course are well-known for having their own dedicated uses)</li>
<li>a mechanism for implement-only traits which I called <code>trait template</code> above, the main motivation above is that a <code>trait template</code> and a <code>sealed trait</code> could have the same name so they – together – form an overall interaction that “looks like” an ordinary trait</li>
<li>a new rule to allow multiple blanked implementations of the same trait based on different trait bounds, which should be possible soundly if the necessary restriction on implementing these “precondition” traits are enforced</li>
</ul>
<p>Other use-cases of <code>trait template</code>s are things like e.g. a template to implement <code>Ord + Eq + PartialOrd + PartialEq</code> all at once by providing only a single <code>cmp</code> method, i.e. implementing a whole trait hierarchy with less boilerplate. (And there could be yet-another template that allows you to implement is in terms of <code>le</code> only. There could be a template for implementing <code>Iterator</code> in terms of <code>try_fold</code> only. Etc…)</p>
<p>The fact that methods of such templates aren’t callable allows you to re-use the same method names as methods in the traits implemented this way; the property that trait bounds involving the <code>template trait</code>s are disallowed makes switching from using a template to manually implementing the hierarchy (or using a different template) a non-breaking change because nobody can rely on the fact that a certain type implements the template.</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>