<html>
<head><meta charset="utf-8"><title>async fn in dyn traits · wg-async · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/index.html">wg-async</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html">async fn in dyn traits</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="275046097"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/async%20fn%20in%20dyn%20traits/near/275046097" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nikomatsakis <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html#275046097">(Mar 11 2022 at 23:01)</a>:</h4>
<p>I've posted a first draft of the "async fn in dyn traits" explainer:</p>
<p><a href="https://rust-lang.github.io/async-fundamentals-initiative/explainer/async_fn_in_dyn_trait.html">https://rust-lang.github.io/async-fundamentals-initiative/explainer/async_fn_in_dyn_trait.html</a></p>



<a name="275067718"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/async%20fn%20in%20dyn%20traits/near/275067718" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nikomatsakis <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html#275067718">(Mar 12 2022 at 00:54)</a>:</h4>
<p>You'll note that it ends on a cliffhanger :)</p>



<a name="275195089"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/async%20fn%20in%20dyn%20traits/near/275195089" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html#275195089">(Mar 14 2022 at 05:18)</a>:</h4>
<p>One thing that is not mentioned in the proposal is how lifetimes work with dynx things, since it seems like <code>&amp;</code> and <code>&amp;mut</code> are on the list of things that can be used in dynx. I would love to see an example with the <code>async fn count()</code> calling something that is returning a <code>&amp;mut MyFuture</code>. Maybe it all just works with the same mechanisms as used in <code>dyn Trait</code> but the fact that futures might be larger than a provided stack allocation seems like it might cause a problem here</p>



<a name="275224922"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/async%20fn%20in%20dyn%20traits/near/275224922" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Olivier FAURE <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html#275224922">(Mar 14 2022 at 11:52)</a>:</h4>
<p>I'm a little surprised the draft doesn't mention <a href="https://poignardazur.github.io/2022/02/23/rust-unsized-vars-analysis/">unsized returns</a> at all.</p>



<a name="275224967"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/async%20fn%20in%20dyn%20traits/near/275224967" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Olivier FAURE <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html#275224967">(Mar 14 2022 at 11:52)</a>:</h4>
<p>Like, I get that the proposal was initially reject/postponed because implementing it was too complex for something that wasn't a lang team priority.</p>



<a name="275225193"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/async%20fn%20in%20dyn%20traits/near/275225193" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Olivier FAURE <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html#275225193">(Mar 14 2022 at 11:55)</a>:</h4>
<p>But right now you're proposing to introduce an entire new <code>dynx Trait</code> compiler concept, with unclear interactions with other concepts. It seems complex enough to justify revisiting RFC 2884.</p>



<a name="275276095"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/async%20fn%20in%20dyn%20traits/near/275276095" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Gus Wynn <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html#275276095">(Mar 14 2022 at 18:09)</a>:</h4>
<p>Is the idea that <code>dyner</code> is a testing crate using proc-macros, but the <code>dynx</code> keywork might natively support what it does in the future?</p>



<a name="275276342"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/async%20fn%20in%20dyn%20traits/near/275276342" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nikomatsakis <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html#275276342">(Mar 14 2022 at 18:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="263609">Olivier FAURE</span> <a href="#narrow/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits/near/275224967">said</a>:</p>
<blockquote>
<p>Like, I get that the proposal was initially reject/postponed because implementing it was too complex for something that wasn't a lang team priority.</p>
</blockquote>
<p>unsized returns have a bunch of flaws, in my view, but chief among them is that they are plain incompatible with our async model, which assumes that it knows how big a stack frame is (so that it can allocate a struct of that size). One thing that <span class="user-mention" data-user-id="116883">@tmandry</span> and I were saying today is that we should add a thorough comparison amongst the alternatives, so I'm going to add that.</p>



<a name="275276359"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/async%20fn%20in%20dyn%20traits/near/275276359" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nikomatsakis <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html#275276359">(Mar 14 2022 at 18:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="257428">Gus Wynn</span> <a href="#narrow/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits/near/275276095">said</a>:</p>
<blockquote>
<p>Is the idea that <code>dyner</code> is a testing crate using proc-macros, but the <code>dynx</code> keywork might natively support what it does in the future?</p>
</blockquote>
<p>no, <code>dynx</code> is never meant to be a syntax used by anyone</p>



<a name="275276412"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/async%20fn%20in%20dyn%20traits/near/275276412" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nikomatsakis <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html#275276412">(Mar 14 2022 at 18:11)</a>:</h4>
<p>I would say dyner is...probably just done. one could imagine adding some of its capability elsewhere at some point, but you would always be "adapting" an existing instance to specify how it uses its memory</p>



<a name="275276493"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/async%20fn%20in%20dyn%20traits/near/275276493" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nikomatsakis <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html#275276493">(Mar 14 2022 at 18:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="116009">nikomatsakis</span> <a href="#narrow/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits/near/275276359">said</a>:</p>
<blockquote>
<p>no, <code>dynx</code> is never meant to be a syntax used by anyone</p>
</blockquote>
<p>(that said, I do think that -- given some <em>other</em> syntax -- it'd be cool to replace the idea of dyn trait with "Some kind of pointer to trait", I would just never make that syntax be <code>dynx</code>)</p>



<a name="275276530"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/async%20fn%20in%20dyn%20traits/near/275276530" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nikomatsakis <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html#275276530">(Mar 14 2022 at 18:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="271719">Mario Carneiro</span> <a href="#narrow/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits/near/275195089">said</a>:</p>
<blockquote>
<p>One thing that is not mentioned in the proposal is how lifetimes work with dynx things, since it seems like <code>&amp;</code> and <code>&amp;mut</code> are on the list of things that can be used in dynx. I would love to see an example with the <code>async fn count()</code> calling something that is returning a <code>&amp;mut MyFuture</code>. Maybe it all just works with the same mechanisms as used in <code>dyn Trait</code> but the fact that futures might be larger than a provided stack allocation seems like it might cause a problem here</p>
</blockquote>
<p>like a <code>dyn</code> type, a <code>dynx</code> type needs a lifetime bound</p>



<a name="275276624"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/async%20fn%20in%20dyn%20traits/near/275276624" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nikomatsakis <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html#275276624">(Mar 14 2022 at 18:13)</a>:</h4>
<p>I think you could return a <code>Pin&lt;&amp;mut Future&gt;</code>, but you'd have to get that pointer from somewhere, I'm not sure that's very realistic</p>



<a name="275276706"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/async%20fn%20in%20dyn%20traits/near/275276706" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nikomatsakis <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html#275276706">(Mar 14 2022 at 18:14)</a>:</h4>
<p>the "inline" adapter uses stack allocation, but it does it by "pre-allocating" the stack storage space earlier</p>



<a name="275308572"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/async%20fn%20in%20dyn%20traits/near/275308572" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Gus Wynn <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html#275308572">(Mar 14 2022 at 22:51)</a>:</h4>
<p><span class="user-mention silent" data-user-id="116009">nikomatsakis</span> <a href="#narrow/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits/near/275276530">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="271719">Mario Carneiro</span> <a href="#narrow/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits/near/275195089">said</a>:</p>
<blockquote>
<p>One thing that is not mentioned in the proposal is how lifetimes work with dynx things, since it seems like <code>&amp;</code> and <code>&amp;mut</code> are on the list of things that can be used in dynx. I would love to see an example with the <code>async fn count()</code> calling something that is returning a <code>&amp;mut MyFuture</code>. Maybe it all just works with the same mechanisms as used in <code>dyn Trait</code> but the fact that futures might be larger than a provided stack allocation seems like it might cause a problem here</p>
</blockquote>
<p>like a <code>dyn</code> type, a <code>dynx</code> type needs a lifetime bound</p>
</blockquote>
<p>the lifetime bound is the bound on the pointer to where-ever the concrete impl is on the stack, right?</p>



<a name="275308866"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/async%20fn%20in%20dyn%20traits/near/275308866" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mario Carneiro <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html#275308866">(Mar 14 2022 at 22:54)</a>:</h4>
<p>It is a bit odd that <code>dynx</code> is introduced as a way of generalizing the <code>Pin&lt;Box&lt;dyn Trait&gt;&gt;</code> pattern but the only example that is given is essentially <code>Pin&lt;Box&lt;dyn Trait&gt;&gt;</code> itself. If we are trying to avoid heap allocation then I thought <code>Pin&lt;&amp;mut dyn Trait&gt;</code> would be how to do it, but it sounds like this doesn't work?</p>



<a name="275331314"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/async%20fn%20in%20dyn%20traits/near/275331314" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html#275331314">(Mar 15 2022 at 05:29)</a>:</h4>
<p>You could turn a <code>Pin&lt;&amp;mut T&gt;</code> into a <code>dynx</code>. From a <code>#[dyn(identity)]</code> method the return type is: <code>impl Future + IntoRawPointer</code></p>



<a name="275331391"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/async%20fn%20in%20dyn%20traits/near/275331391" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html#275331391">(Mar 15 2022 at 05:30)</a>:</h4>
<p>The lifetime of the reference would become the lifetime bound of the <code>dynx</code></p>



<a name="275331430"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/async%20fn%20in%20dyn%20traits/near/275331430" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html#275331430">(Mar 15 2022 at 05:31)</a>:</h4>
<p>The key point of <code>dynx</code> is that the caller doesn't have to care if the pointer is an owned pointer like <code>Box</code> or an unowned pointer like <code>&amp;mut</code> (or a even shared pointer like <code>Arc</code>).</p>



<a name="275331628"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/async%20fn%20in%20dyn%20traits/near/275331628" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html#275331628">(Mar 15 2022 at 05:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="116883">tmandry</span> <a href="#narrow/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits/near/275331314">said</a>:</p>
<blockquote>
<p>You could turn a <code>Pin&lt;&amp;mut T&gt;</code> into a <code>dynx</code>. From a <code>#[dyn(identity)]</code> method the return type is: <code>impl Future + IntoRawPointer</code></p>
</blockquote>
<p>Here <code>T</code> is the concrete type that implements <code>Future</code></p>



<a name="275353863"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/async%20fn%20in%20dyn%20traits/near/275353863" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Olivier FAURE <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html#275353863">(Mar 15 2022 at 10:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="116009">nikomatsakis</span> <a href="#narrow/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits/near/275276342">said</a>:</p>
<blockquote>
<p>unsized returns have a bunch of flaws, in my view, but chief among them is that they are plain incompatible with our async model, which assumes that it knows how big a stack frame is (so that it can allocate a struct of that size).</p>
</blockquote>
<p>Incompatible how?</p>
<p>To be clear, unsized returns don't imply unsized locals. They could be stored in Boxes, RCs, or reusable local storage, just like you propose with <code>InlineAsyncIterator</code>. The biggest difference would be that the storage method would be decided by the function using <code>dyn AsyncIterator</code> and not the function creating it, which to me seems more predictable. (Also FWIW would involve fewer vtable lookups)</p>



<a name="275354384"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/async%20fn%20in%20dyn%20traits/near/275354384" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Olivier FAURE <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html#275354384">(Mar 15 2022 at 10:28)</a>:</h4>
<p>To be clear, I don't want to go into a discussion of feature tradeoffs if you're not interested. Ultimately, you're the lang team member, you're the one who knows how compiler internals work, etc. But to me it feels like you've been thinking about the <code>dynx</code> idea for months (I remember you mentioning something similar in your async blog posts), and now that you're starting to formalize it,  you're looking for quick-and-easy reasons to dismiss unsized returns because you haven't seriously considered them.</p>



<a name="275354636"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/async%20fn%20in%20dyn%20traits/near/275354636" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Olivier FAURE <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html#275354636">(Mar 15 2022 at 10:30)</a>:</h4>
<p>What I'm saying is, I think you should seriously sit down and spend some actual time considering the unsized returns proposal and how it could work with async, before dismissing it. I might be wrong, but to me it feels you haven't done that so far.</p>



<a name="275459854"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/async%20fn%20in%20dyn%20traits/near/275459854" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html#275459854">(Mar 16 2022 at 02:07)</a>:</h4>
<p>One of the design goals is for this feature to work in no-std environments with no allocator. To handle unsized returns you would need to either</p>
<ul>
<li>Extend the stack (alloca), which isn't possible in async contexts or generators for the reasons Niko described above</li>
<li>Allocate on the heap, which isn't possible in no-std</li>
</ul>
<p>So, yes, we did consider unsized returns (I was initially excited about this direction) but didn't find a way to use them in a way that meets these design goals. Using adapters does: it allows code that statically knows the type to pre-allocate space for those futures on the stack before erasing type information.</p>



<a name="275461718"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/async%20fn%20in%20dyn%20traits/near/275461718" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html#275461718">(Mar 16 2022 at 02:49)</a>:</h4>
<p>Side note, <span class="user-mention" data-user-id="263609">@Olivier FAURE</span>, I appreciate your interest in the discussion but in those last couple of messages you're coming off as a little hostile. There was plenty of thought that went into this and I welcome feedback on the technical merits (I know Niko does too), but let's try to stick to that please</p>



<a name="275480155"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/async%20fn%20in%20dyn%20traits/near/275480155" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html#275480155">(Mar 16 2022 at 08:41)</a>:</h4>
<p>Currently reading.</p>



<a name="275480165"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/async%20fn%20in%20dyn%20traits/near/275480165" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html#275480165">(Mar 16 2022 at 08:41)</a>:</h4>
<p>Typo: On the 'how it feels' page, the example impl under "How you implement a trait with async fns", the impl of <code>next</code> is missing its return type</p>



<a name="275480487"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/async%20fn%20in%20dyn%20traits/near/275480487" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html#275480487">(Mar 16 2022 at 08:44)</a>:</h4>
<p>And on the next page</p>



<a name="275483732"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/async%20fn%20in%20dyn%20traits/near/275483732" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html#275483732">(Mar 16 2022 at 09:15)</a>:</h4>
<p>Question: about drop, is the proposal different from what already happens? I assume that is how drop for pointers to DSTs works already?</p>



<a name="275490319"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/async%20fn%20in%20dyn%20traits/near/275490319" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html#275490319">(Mar 16 2022 at 10:16)</a>:</h4>
<p>Does the dynx wrapper affect the drop analysis done for closures for 2229 (I couldn't find documentation of how <code>rustc_insignificant_dtor</code> works)? I expect at worse that analysis will just need to become dynx aware.</p>



<a name="275499839"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/async%20fn%20in%20dyn%20traits/near/275499839" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html#275499839">(Mar 16 2022 at 11:56)</a>:</h4>
<p>Regarding <code>no_std</code> support, it could be interesting to, <em>later on</em>, extend the framework to play with some arena / bump allocator, which could be capped and stack-memory backed, so that an <code>async fn</code> signature would be:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span> <span class="nf">method</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">arena</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">arena</span> <span class="nc">Arena</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">args</span><span class="err">…</span><span class="w"></span>
<span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Pin</span><span class="o">&lt;&amp;'</span><span class="na">arena</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="k">dyn</span><span class="w"> </span><span class="n">Future</span><span class="o">&lt;</span><span class="n">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">R</span><span class="o">&gt;&gt;</span><span class="w">  </span><span class="cm">/* maybe option wrapped with the panic on capacity exhaustion is not desirable */</span><span class="w"></span>
</code></pre></div>
<ul>
<li>(I think the blog post already hints at that at some point <span aria-label="ok" class="emoji emoji-1f44c" role="img" title="ok">:ok:</span> , but we may want to further discuss about it over here)</li>
</ul>
<p>and then erase that <code>Pin&lt;&amp;mut …&gt;</code> as the suggested <del><code>dynx</code></del> <code>VirtualPtr&lt;dyn Future&lt;Output = R&gt;&gt;</code></p>



<a name="275499965"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/async%20fn%20in%20dyn%20traits/near/275499965" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html#275499965">(Mar 16 2022 at 11:57)</a>:</h4>
<p>Aside: I prefer something with <code>ptr</code> in the name to the <code>dynx</code> naming, to be honest, since a <code>dyn Trait</code> is the pointee, but a <code>dynx</code> is the pointer. Indeed, consider:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span> <span class="nf">some_function</span><span class="o">&lt;'</span><span class="na">lt</span><span class="o">&gt;</span><span class="w"> </span><span class="p">()</span><span class="w"></span>
<span class="w">  </span>-&gt; <span class="nc">VirtualPtr</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="o">'</span><span class="na">lt</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Future</span><span class="o">&lt;</span><span class="n">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">i32</span><span class="o">&gt;&gt;</span><span class="w"></span>
<span class="c1">// vs.</span>
<span class="k">fn</span> <span class="nf">some_function</span><span class="o">&lt;'</span><span class="na">lt</span><span class="o">&gt;</span><span class="w"> </span><span class="p">()</span><span class="w"></span>
<span class="w">  </span>-&gt; <span class="nc">dynx</span><span class="w"> </span><span class="o">'</span><span class="na">lt</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Future</span><span class="o">&lt;</span><span class="n">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"></span>
</code></pre></div>
<div class="spoiler-block"><div class="spoiler-header">
<p>VirtualPtr can already be defined in Rust (with manual impls for each supported trait, of course)</p>
</div><div class="spoiler-content" aria-hidden="true">
<h3>Core definition</h3>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">mod</span> <span class="nn">ty</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Erased</span><span class="p">(());</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">pub</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">VirtualPtr</span><span class="o">&lt;</span><span class="n">DynTrait</span><span class="w"> </span>: <span class="o">?</span><span class="nb">Sized</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">VirtualPtrVTable</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ptr</span>: <span class="nc">ptr</span>::<span class="n">NonNull</span><span class="o">&lt;</span><span class="n">ty</span>::<span class="n">Erased</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">vtable</span>: <span class="nc">ptr</span>::<span class="n">NonNull</span><span class="o">&lt;</span><span class="w"></span>
<span class="w">        </span><span class="o">&lt;</span><span class="n">DynTrait</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">VirtualPtrVTable</span><span class="o">&gt;</span>::<span class="n">T</span><span class="w"></span>
<span class="w">    </span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">pub</span><span class="w"></span>
<span class="k">trait</span><span class="w"> </span><span class="n">VirtualPtrVTable</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">T</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">unsafe</span><span class="w"></span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">DynTrait</span><span class="w"> </span>: <span class="o">?</span><span class="nb">Sized</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">VirtualPtrVTable</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">    </span><span class="nb">Send</span><span class="w"></span>
<span class="k">for</span><span class="w"></span>
<span class="w">    </span><span class="n">VirtualPtr</span><span class="o">&lt;</span><span class="n">DynTrait</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">where</span><span class="w"></span>
<span class="w">    </span><span class="n">DynTrait</span><span class="w"> </span>: <span class="nb">Send</span><span class="p">,</span><span class="w"></span>
<span class="p">{}</span><span class="w"></span>

<span class="k">unsafe</span><span class="w"></span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">DynTrait</span><span class="w"> </span>: <span class="o">?</span><span class="nb">Sized</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">VirtualPtrVTable</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">    </span><span class="nb">Sync</span><span class="w"></span>
<span class="k">for</span><span class="w"></span>
<span class="w">    </span><span class="n">VirtualPtr</span><span class="o">&lt;</span><span class="n">DynTrait</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">where</span><span class="w"></span>
<span class="w">    </span><span class="n">DynTrait</span><span class="w"> </span>: <span class="nb">Sync</span><span class="p">,</span><span class="w"></span>
<span class="p">{}</span><span class="w"></span>
</code></pre></div>
<h3>An example for <code>Future</code></h3>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="sd">/// generated for trait Future</span>
<span class="k">const</span><span class="w"> </span><span class="n">_</span>: <span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">use</span><span class="w"> </span>::<span class="n">core</span>::<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// future::Futurrs</span>
<span class="w">        </span><span class="n">task</span>::<span class="p">{</span><span class="n">Context</span><span class="p">,</span><span class="w"> </span><span class="n">Poll</span><span class="p">},</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="k">pub</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">FutureVirtualPtrVTable</span><span class="o">&lt;</span><span class="n">Output</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">drop_owned</span>: <span class="nc">unsafe</span><span class="w"> </span><span class="k">fn</span><span class="p">(</span><span class="n">ptr</span>::<span class="n">NonNull</span><span class="o">&lt;</span><span class="n">ty</span>::<span class="n">Erased</span><span class="o">&gt;</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="n">poll</span>:
            <span class="nc">unsafe</span><span class="w"></span>
<span class="w">            </span><span class="k">fn</span><span class="p">(</span><span class="n">ptr</span>::<span class="n">NonNull</span><span class="o">&lt;</span><span class="n">ty</span>::<span class="n">Erased</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">cx</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="nb">_</span> <span class="nc">mut</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;'</span><span class="nb">_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"></span>
<span class="w">              </span>-&gt; <span class="nc">Poll</span><span class="o">&lt;</span><span class="n">Output</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">        </span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">impl</span><span class="o">&lt;</span><span class="n">Output</span><span class="o">&gt;</span><span class="w"> </span><span class="n">VirtualPtrVTable</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="k">dyn</span><span class="w"> </span><span class="o">'</span><span class="nb">_</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Future</span><span class="o">&lt;</span><span class="n">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Output</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">type</span> <span class="nc">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FutureVirtualPtrVTable</span><span class="o">&lt;</span><span class="n">Output</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">impl</span><span class="o">&lt;</span><span class="n">Output</span><span class="o">&gt;</span><span class="w"> </span><span class="n">VirtualPtrVTable</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="k">dyn</span><span class="w"> </span><span class="o">'</span><span class="nb">_</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Future</span><span class="o">&lt;</span><span class="n">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Output</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">type</span> <span class="nc">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FutureVirtualPtrVTable</span><span class="o">&lt;</span><span class="n">Output</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="cp">#[cfg(TODO)]</span><span class="w"></span>
<span class="w">    </span><span class="k">impl</span><span class="o">&lt;'</span><span class="na">usability</span><span class="p">,</span><span class="w"> </span><span class="n">Fut</span><span class="p">,</span><span class="w"> </span><span class="n">P</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">        </span><span class="nb">From</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"></span>
<span class="w">        </span><span class="n">VirtualPtr</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="o">'</span><span class="na">usability</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Future</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">    </span><span class="k">where</span><span class="w"></span>
<span class="w">        </span><span class="n">Fut</span><span class="w"> </span>: <span class="o">'</span><span class="na">usability</span> <span class="o">+</span><span class="w"> </span><span class="n">Future</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">P</span><span class="w"> </span>: <span class="nc">SomePtrTrait</span><span class="o">&lt;</span><span class="n">Fut</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="cm">/* … */</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</code></pre></div>
<ul>
<li><strong><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=8805e8f802b37bcc8a696da2335bb32b">Playground</a></strong></li>
</ul>
</div></div>



<a name="275501436"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/async%20fn%20in%20dyn%20traits/near/275501436" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html#275501436">(Mar 16 2022 at 12:11)</a>:</h4>
<p>Some more thoughts: I'm pleasantly surprised how well this all works out. It's not totally friction-free, but it seems that the common case is and the non-common case is fairly good. So this seems overall a great design.</p>



<a name="275501711"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/async%20fn%20in%20dyn%20traits/near/275501711" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html#275501711">(Mar 16 2022 at 12:14)</a>:</h4>
<p>For the syntax, the downside seems to be that we do implicit allocation in the common case and that seems not perfect (I do see the argument for making the common case so easy, don't get me wrong). An obvious alternative would be to make the explicit <code>#[dyn(Box)]</code> required rather than the default and have the default be a type error. I think that alternative is worse, but I wanted to bring it up anyway :-)</p>



<a name="275501839"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/async%20fn%20in%20dyn%20traits/near/275501839" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html#275501839">(Mar 16 2022 at 12:15)</a>:</h4>
<p>I'd be curious to see how this generalises to <code>impl Trait</code> and returning type params other than async, I don't expect  there to be any surprises but  maybe there are more bounds to take account of or something?</p>



<a name="275502111"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/async%20fn%20in%20dyn%20traits/near/275502111" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html#275502111">(Mar 16 2022 at 12:17)</a>:</h4>
<p>I wonder also if being able to specify how a future is wrapped (e.g., Boxed vs by value) is more generally useful? E.g., I think a non-cancellable future could be expressed as a &amp; pointer to a future with the owner of the future being sufficiently far up the stack? Or maybe an Rc&lt;Future&gt; where the runtime (or nursery in the structured concurrency case) also keeps a reference.</p>



<a name="275502270"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/async%20fn%20in%20dyn%20traits/near/275502270" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html#275502270">(Mar 16 2022 at 12:18)</a>:</h4>
<p>Another random wondering is if the mechanism for allocating a value somewhere and then returning a pointer to it is also generalisable? Being able to do this would make the ReadBuf design better, for example.</p>



<a name="275502433"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/async%20fn%20in%20dyn%20traits/near/275502433" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html#275502433">(Mar 16 2022 at 12:20)</a>:</h4>
<p>There is an assumption that fat pointers are always two words, but if we allow custom DST (or even non-custom but with custom size hidden data), then that will no longer hold. Not sure there's anything we can do about that though.</p>



<a name="275503188"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/async%20fn%20in%20dyn%20traits/near/275503188" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Olivier FAURE <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html#275503188">(Mar 16 2022 at 12:27)</a>:</h4>
<p>I reread the InlineAsyncIterator and I understand it better now. One objection I have is: how does it handle multiple call to the async method?</p>



<a name="275503614"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/async%20fn%20in%20dyn%20traits/near/275503614" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Olivier FAURE <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html#275503614">(Mar 16 2022 at 12:32)</a>:</h4>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">async</span><span class="w"> </span><span class="k">fn</span> <span class="nf">window</span><span class="p">(</span><span class="n">i</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="k">dyn</span><span class="w"> </span><span class="n">AsyncIterator</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="p">[</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">.</span><span class="n">next</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">.</span><span class="n">next</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">.</span><span class="n">next</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">[</span><span class="n">a</span><span class="p">.</span><span class="k">await</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="k">await</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="k">await</span><span class="p">]</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>



<a name="275503987"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/async%20fn%20in%20dyn%20traits/near/275503987" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Olivier FAURE <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html#275503987">(Mar 16 2022 at 12:36)</a>:</h4>
<p>You can't reuse pre-allocated space since the variables are live at the same time.</p>



<a name="275504142"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/async%20fn%20in%20dyn%20traits/near/275504142" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Olivier FAURE <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html#275504142">(Mar 16 2022 at 12:37)</a>:</h4>
<p>You could use GATs to prevent this use case but (1) that has to be integrated in the design (2) this use case seems like something users would actually want.</p>



<a name="275709769"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/async%20fn%20in%20dyn%20traits/near/275709769" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html#275709769">(Mar 17 2022 at 18:58)</a>:</h4>
<p>Yeah, the inline futures for <code>&amp;self</code> methods each have to be wrapped in a <code>RefCell</code> (or its equivalent) to prevent that. For <code>&amp;mut self</code> it will be prevented statically, since <code>async fn</code> captures all input lifetimes in its return value.</p>



<a name="275725039"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/async%20fn%20in%20dyn%20traits/near/275725039" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nikomatsakis <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html#275725039">(Mar 17 2022 at 20:54)</a>:</h4>
<p><span class="user-mention" data-user-id="263609">@Olivier FAURE</span> you can't write that code because the future returned by <code>next()</code> holds a borrow on <code>i</code></p>



<a name="275725075"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/async%20fn%20in%20dyn%20traits/near/275725075" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nikomatsakis <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html#275725075">(Mar 17 2022 at 20:54)</a>:</h4>
<p>for an <code>&amp;self</code> method, though, it could work; that is one reason I didn't want to build this mechanism <em>in</em>, because it's "imperfect", it doesn't work great on <em>all</em> traits</p>



<a name="275725085"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/async%20fn%20in%20dyn%20traits/near/275725085" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nikomatsakis <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html#275725085">(Mar 17 2022 at 20:54)</a>:</h4>
<p>I think that's ok for a kind of niche case thing</p>



<a name="275747205"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/async%20fn%20in%20dyn%20traits/near/275747205" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> simulacrum <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html#275747205">(Mar 18 2022 at 00:41)</a>:</h4>
<p>I'm reading the lang document (thanks Niko for preparing it early :) and this thread, and one question that I haven't seen answered yet is why we need dyn(box) vs. dyn(identity) etc with the current design, other than as a special-case form of static assert. It seems like one simple approach could be that if the returned value is &lt;= size_of(usize), we automatically skip boxing it (basically just putting it in the ptr slot for dynx) and if it is larger, then we do box. This means that if you don't care you can still get fast behavior if your future is compact, and if you do care you just need to be careful to return something 'small enough' (and probably assert it, perhaps with an attribute, perhaps with something else).</p>
<p>For the example in the lang hackmd (<a href="https://hackmd.io/@nikomatsakis/S1xxjkZGc#How-to-write-an-adapter">https://hackmd.io/@nikomatsakis/S1xxjkZGc#How-to-write-an-adapter</a>), if the allocator you chose is something that isn't a ZST (for example, the arena allocator example above), then presumably there's a monomorphization-time error for dyn(identity) telling you the return type is too big, which seems quite unfortunate. Maybe there's nothing we can do to solve this nicely without providing better abstractions in dyner or equivalents.</p>



<a name="275747329"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/async%20fn%20in%20dyn%20traits/near/275747329" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> simulacrum <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html#275747329">(Mar 18 2022 at 00:43)</a>:</h4>
<p>One other question I'm not quite seeing the answer to yet is what the expected flow is around lints etc to let users opt-out of Box by default in some cases, or otherwise identifying where that has happened.</p>



<a name="275747483"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/async%20fn%20in%20dyn%20traits/near/275747483" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> simulacrum <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html#275747483">(Mar 18 2022 at 00:45)</a>:</h4>
<p>(One reason I ask about lints is that it seems sad that you have to constantly import InlineAdapter or MyOwnBoxAdapter etc in every place you go from impl Trait to dyn Trait -- it seems like ideally we'd have some way to have a "global" allocator for dyn Trait converters. But that can be left for the future, I guess.)</p>



<a name="275747566"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/async%20fn%20in%20dyn%20traits/near/275747566" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html#275747566">(Mar 18 2022 at 00:46)</a>:</h4>
<p>Yeah a global lint and/or "adaptation mode" is something I'd like to see</p>



<a name="275747604"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/async%20fn%20in%20dyn%20traits/near/275747604" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html#275747604">(Mar 18 2022 at 00:47)</a>:</h4>
<p>I think we could optimize automatically and turn <code>#[dyn(identity)]</code> to something more like a lint that asserts that boxing is skipped. It ties into some of the other questions (that we intentionally left out of scope for that doc) about the rules around pointers</p>



<a name="275747814"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/async%20fn%20in%20dyn%20traits/near/275747814" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> simulacrum <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html#275747814">(Mar 18 2022 at 00:51)</a>:</h4>
<p>I also am wondering how much of an impediment we expect the manual trait definition copying to be -- it seems pretty annoying to me. You could imagine that we can avoid that by 'just' providing a magic compiler feature which lets you pass in a <code>fn dynify_with&lt;T: SomeTrait&gt;(value: T) -&gt; dynx SomeTrait</code> to a <code>adapt(impl AsyncIterator, dynify_with) -&gt; dyn AsyncIterator</code> -- basically moving the "derive" into the compiler, just generating the shim based on it</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">dyner</span>::<span class="n">inline</span>::<span class="n">adapter_struct</span><span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">InlineAsyncIterator</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">MyTrait</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">async</span><span class="w"> </span><span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>



<a name="275747914"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/async%20fn%20in%20dyn%20traits/near/275747914" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> simulacrum <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html#275747914">(Mar 18 2022 at 00:52)</a>:</h4>
<p>Anyway, this is super exciting, really happy to see this coming along</p>



<a name="275879991"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/async%20fn%20in%20dyn%20traits/near/275879991" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html#275879991">(Mar 19 2022 at 01:00)</a>:</h4>
<blockquote>
<p>if the allocator you chose is something that isn't a ZST (for example, the arena allocator example above), then presumably there's a monomorphization-time error for dyn(identity) telling you the return type is too big, which seems quite unfortunate.</p>
</blockquote>
<p>In our current iteration you need to implement a trait called <code>IntoRawPointer</code> for <code>Box&lt;T, YourAllocator&gt;</code>, and the size requirements are baked into the <code>IntoRawPointer</code> API. So your smart pointer has to be convertible to/from a raw pointer, but doesn't necessarily have to <em>be</em> one. This can all be determined during type check.</p>



<a name="275880131"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/async%20fn%20in%20dyn%20traits/near/275880131" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html#275880131">(Mar 19 2022 at 01:03)</a>:</h4>
<p>...there's one tiny problem with that, though, which is that writing such an impl yourself violates current orphan rules</p>



<a name="275881675"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/async%20fn%20in%20dyn%20traits/near/275881675" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html#275881675">(Mar 19 2022 at 01:37)</a>:</h4>
<p>I added a page on a more "advanced topic", <a href="https://rust-lang.github.io/async-fundamentals-initiative/explainer/async_fn_in_dyn_trait/nested_impl_trait.html">adapting nested <code>impl Trait</code></a></p>



<a name="275881775"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/async%20fn%20in%20dyn%20traits/near/275881775" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits.html#275881775">(Mar 19 2022 at 01:39)</a>:</h4>
<p>this one has had less scrutiny, so it could be flawed</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>