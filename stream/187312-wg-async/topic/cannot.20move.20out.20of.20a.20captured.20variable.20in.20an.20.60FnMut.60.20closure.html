<html>
<head><meta charset="utf-8"><title>cannot move out of a captured variable in an `FnMut` closure · wg-async · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/index.html">wg-async</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/cannot.20move.20out.20of.20a.20captured.20variable.20in.20an.20.60FnMut.60.20closure.html">cannot move out of a captured variable in an `FnMut` closure</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="271228737"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/cannot%20move%20out%20of%20a%20captured%20variable%20in%20an%20%60FnMut%60%20closure/near/271228737" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/cannot.20move.20out.20of.20a.20captured.20variable.20in.20an.20.60FnMut.60.20closure.html#271228737">(Feb 09 2022 at 04:11)</a>:</h4>
<p>I ran into the following error, and in the course of trying to work around it, I found myself wondering if there's a usability improvement to be had here:</p>



<a name="271228778"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/cannot%20move%20out%20of%20a%20captured%20variable%20in%20an%20%60FnMut%60%20closure/near/271228778" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/cannot.20move.20out.20of.20a.20captured.20variable.20in.20an.20.60FnMut.60.20closure.html#271228778">(Feb 09 2022 at 04:12)</a>:</h4>
<div class="codehilite" data-code-language="Text only"><pre><span></span><code>error[E0507]: cannot move out of `workdir`, a captured variable in an `FnMut` closure
   --&gt; src/main.rs:584:52
    |
425 |        let workdir = if let Some(workdir) = repo.workdir() {
    |            ------- captured outer variable
...
584 |                move |(state, mut objects)| async move {
    |  ______________-______________________________________^
    | | _____________|
    | ||
585 | ||                 match state {
586 | ||                     StreamState::Header =&gt; match objects.pop_front() {
587 | ||                         None =&gt; Ok(Some((
...   ||
639 | ||                                     let full_path = workdir.join(relpath.to_path_lossy());
    | ||                                                     -------
    | ||                                                     |
    | ||                                                     move occurs because `workdir` has type `PathBuf`, which does not implement the `Copy` trait
    | ||                                                     move occurs due to use in generator
...   ||
665 | ||                 }
666 | ||             },
    | ||             ^
    | ||_____________|
    | |______________captured by this `FnMut` closure
    |                move out of `workdir` occurs here
</code></pre></div>



<a name="271228817"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/cannot%20move%20out%20of%20a%20captured%20variable%20in%20an%20%60FnMut%60%20closure/near/271228817" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/cannot.20move.20out.20of.20a.20captured.20variable.20in.20an.20.60FnMut.60.20closure.html#271228817">(Feb 09 2022 at 04:13)</a>:</h4>
<p>Why yes, <code>workdir</code> isn't Copy; that's why I wrote <code>move</code>, twice, and expected the compiler to move it rather than copy it.</p>



<a name="271228826"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/cannot%20move%20out%20of%20a%20captured%20variable%20in%20an%20%60FnMut%60%20closure/near/271228826" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/cannot.20move.20out.20of.20a.20captured.20variable.20in.20an.20.60FnMut.60.20closure.html#271228826">(Feb 09 2022 at 04:13)</a>:</h4>
<p>I'm wondering if this is an instance of why we need <code>async ||</code> rather than <code>|| async</code>?</p>



<a name="271228836"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/cannot%20move%20out%20of%20a%20captured%20variable%20in%20an%20%60FnMut%60%20closure/near/271228836" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/cannot.20move.20out.20of.20a.20captured.20variable.20in.20an.20.60FnMut.60.20closure.html#271228836">(Feb 09 2022 at 04:13)</a>:</h4>
<p>(Leaving aside that scoped futures would <em>also</em> solve this, by letting me borrow.)</p>



<a name="271228879"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/cannot%20move%20out%20of%20a%20captured%20variable%20in%20an%20%60FnMut%60%20closure/near/271228879" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/cannot.20move.20out.20of.20a.20captured.20variable.20in.20an.20.60FnMut.60.20closure.html#271228879">(Feb 09 2022 at 04:14)</a>:</h4>
<p>For context, the closure here is appearing in a <code>futures_util::stream::try_unfold</code>.</p>



<a name="271228984"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/cannot%20move%20out%20of%20a%20captured%20variable%20in%20an%20%60FnMut%60%20closure/near/271228984" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/cannot.20move.20out.20of.20a.20captured.20variable.20in.20an.20.60FnMut.60.20closure.html#271228984">(Feb 09 2022 at 04:16)</a>:</h4>
<p>And for further context: this is all in <code>futures_util::TryStreamExt::into_async_read(Box::pin(futures_util::stream::try_unfold(</code>, which in an ideal world would just be a generator of some kind.</p>



<a name="271229052"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/cannot%20move%20out%20of%20a%20captured%20variable%20in%20an%20%60FnMut%60%20closure/near/271229052" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/cannot.20move.20out.20of.20a.20captured.20variable.20in.20an.20.60FnMut.60.20closure.html#271229052">(Feb 09 2022 at 04:18)</a>:</h4>
<p>But those issues aside, I'm interested in how, in stable Rust, to move a variable into a closure-returning-async.</p>



<a name="271269021"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/cannot%20move%20out%20of%20a%20captured%20variable%20in%20an%20%60FnMut%60%20closure/near/271269021" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/cannot.20move.20out.20of.20a.20captured.20variable.20in.20an.20.60FnMut.60.20closure.html#271269021">(Feb 09 2022 at 12:28)</a>:</h4>
<p>Does removing that second <code>move</code> work? Basically that closure is a <code>Future</code> factory (<code>FnMut</code>), so a signle returned future can't <em>take</em> (ownership of) that <code>workdir</code> out of the factory: how would the factory handle the next items?</p>
<p>This is is basically the issue that</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">F</span><span class="w"> </span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">R</span><span class="w"></span>
<span class="c1">// is equivalent to:</span>
<span class="k">for</span><span class="o">&lt;'</span><span class="na">any</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">    </span><span class="o">&amp;'</span><span class="na">any</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">F</span><span class="w"> </span>: <span class="nb">FnOnce</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">R</span><span class="w"></span>
<span class="p">,</span><span class="w"></span>
</code></pre></div>
<p>Notice how <code>R</code> does not mention <code>'any</code> (in this instance <code>R</code> is expected to be an <code>impl Future</code>, but that's not the core issue to begin with).</p>
<p>In some cases where <code>workdir</code> would be an outer / long-living thing, you'd be able to capture a <code>T = &amp;PathBuf</code>, and then copy those references for each <code>R</code>. But I suspect you won't be able to do that here because that original borrow over the <code>PathBuf</code> is not long-lived enough.</p>



<a name="271269107"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/cannot%20move%20out%20of%20a%20captured%20variable%20in%20an%20%60FnMut%60%20closure/near/271269107" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/cannot.20move.20out.20of.20a.20captured.20variable.20in.20an.20.60FnMut.60.20closure.html#271269107">(Feb 09 2022 at 12:29)</a>:</h4>
<p>It's kind of a limitation of <code>unfold</code>'s API: it could offer a <code>.lending_unfold()</code> API, that would explicitly take a <code>T</code> to be own, and then offer <code>&amp;T</code>s (or <code>&amp;mut T</code>s, depending on how concurrent the different <code>.next()</code> calls are) for the <code>Future</code> to capture</p>



<a name="271269268"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/cannot%20move%20out%20of%20a%20captured%20variable%20in%20an%20%60FnMut%60%20closure/near/271269268" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/cannot.20move.20out.20of.20a.20captured.20variable.20in.20an.20.60FnMut.60.20closure.html#271269268">(Feb 09 2022 at 12:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="232018">Daniel Henry-Mantilla</span> <a href="#narrow/stream/187312-wg-async/topic/cannot.20move.20out.20of.20a.20captured.20variable.20in.20an.20.60FnMut.60.20closure/near/271269021">said</a>:</p>
<blockquote>
<p>This is basically the issue that:</p>
<p><div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">F</span><span class="w"> </span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">R</span><span class="w"></span>
<span class="c1">// is equivalent to:</span>
<span class="k">for</span><span class="o">&lt;'</span><span class="na">any</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">    </span><span class="o">&amp;'</span><span class="na">any</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">F</span><span class="w"> </span>: <span class="nb">FnOnce</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">R</span><span class="w"></span>
<span class="p">,</span><span class="w"></span>
</code></pre></div><br>
</p>
</blockquote>
<p>To expand on this: neither the <code>FnMut</code> nor the <code>Fn</code> traits allow naming the lifetime of the borrow of <code>*self</code>. Thus, only <code>FnOnce</code>, for <code>Self = &amp;…</code> itself, is able to do so. But there is no way to have a <em>literal / compiler-generated closure</em>  get that kind of higher-order signature</p>



<a name="271270658"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/cannot%20move%20out%20of%20a%20captured%20variable%20in%20an%20%60FnMut%60%20closure/near/271270658" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/cannot.20move.20out.20of.20a.20captured.20variable.20in.20an.20.60FnMut.60.20closure.html#271270658">(Feb 09 2022 at 12:44)</a>:</h4>
<p>But worry not: <code>unfold</code>'s API has thought of this case, and handles it by using "take and give back" rather than <code>&amp;mut</code> borrowing (sometimes these simpler approaches can be surprisingly powerful):</p>
<ol>
<li>You give ownership of <code>workdir</code> to the factory,</li>
<li>The factory gives ownership of <code>workdir</code> to the returned value (the <code>Fut</code>ure),</li>
<li>The <code>impl Future</code>, when resolved, <strong>gives back that <code>workdir</code> to the factory</strong> (second value of the <code>Option</code> tuple).</li>
</ol>
<p>Demo:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>
<span class="k">match</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// | _fails_because_of_short_borrow =&gt; Box::new({</span>
<span class="w">    </span><span class="c1">//     unfold((), |()| async { /* captures `&amp;s` */</span>
<span class="w">    </span><span class="c1">//         Some((s.len(), ()))</span>
<span class="w">    </span><span class="c1">//     })</span>
<span class="w">    </span><span class="c1">// }),</span>
<span class="w">    </span><span class="c1">// | _fails_because_moved =&gt; Box::new({</span>
<span class="w">    </span><span class="c1">//     unfold((), |()| async move { /* captures `s` due to the `move` */</span>
<span class="w">    </span><span class="c1">//         Some((s.len(), ()))</span>
<span class="w">    </span><span class="c1">//     })</span>
<span class="w">    </span><span class="c1">// }),</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">_works</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">({</span><span class="w"></span>
<span class="w">        </span><span class="n">unfold</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">s</span><span class="o">|</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="nb">Some</span><span class="p">((</span><span class="n">s</span><span class="p">.</span><span class="n">len</span><span class="p">(),</span><span class="w"> </span><span class="n">s</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="p">})</span><span class="w"></span>
<span class="w">    </span><span class="p">}),</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<ul>
<li>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=3ad7c3b74750ede507e69321c114042f">Playground</a></p>
</li>
<li>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=04397e40650dc09538ef81cec61583a8">Bonus Playground</a>: a situation where the short-lived borrow is fine (because long-lived enough)</p>
</li>
</ul>



<a name="271270834"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/cannot%20move%20out%20of%20a%20captured%20variable%20in%20an%20%60FnMut%60%20closure/near/271270834" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/cannot.20move.20out.20of.20a.20captured.20variable.20in.20an.20.60FnMut.60.20closure.html#271270834">(Feb 09 2022 at 12:46)</a>:</h4>
<p>So, in your case, you'll need to attach <code>workdir</code> to that <code>(state, mut objects)</code> tuple</p>



<a name="271313974"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/cannot%20move%20out%20of%20a%20captured%20variable%20in%20an%20%60FnMut%60%20closure/near/271313974" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/cannot.20move.20out.20of.20a.20captured.20variable.20in.20an.20.60FnMut.60.20closure.html#271313974">(Feb 09 2022 at 17:22)</a>:</h4>
<p>The <code>unfold</code> way of handling this is clever, but it makes me want generators that much more</p>



<a name="271318121"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/cannot%20move%20out%20of%20a%20captured%20variable%20in%20an%20%60FnMut%60%20closure/near/271318121" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/cannot.20move.20out.20of.20a.20captured.20variable.20in.20an.20.60FnMut.60.20closure.html#271318121">(Feb 09 2022 at 17:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="232018">Daniel Henry-Mantilla</span> <a href="#narrow/stream/187312-wg-async/topic/cannot.20move.20out.20of.20a.20captured.20variable.20in.20an.20.60FnMut.60.20closure/near/271269021">said</a>:</p>
<blockquote>
<p>Does removing that second <code>move</code> work? Basically that closure is a <code>Future</code> factory (<code>FnMut</code>), so a signle returned future can't <em>take</em> (ownership of) that <code>workdir</code> out of the factory: how would the factory handle the next items?</p>
</blockquote>
<p>No, removing the second <code>move</code> doesn't work:</p>
<div class="codehilite"><pre><span></span><code>error: captured variable cannot escape `FnMut` closure body
   --&gt; src/main.rs:575:41
    |
555 |       let unknown_blobs: HashSet&lt;Oid&gt; = has_blobs_bits
    |           ------------- variable defined here
...
575 |               move |(state, mut objects)| async {
    |  _______________________________________-_^
    | |                                       |
    | |                                       inferred to be a `FnMut` closure
576 | |                 match state {
577 | |                     StreamState::Header =&gt; match objects.pop_front() {
578 | |                         None =&gt; Ok(Some((
...   |
613 | |                             if known || !unknown_blobs.contains(&amp;oid) {
    | |                                          ------------- variable captured here
...   |
666 | |                 }
667 | |             },
    | |_____________^ returns an `async` block that contains a reference to a captured variable, which then escapes the closure body
    |
    = note: `FnMut` closures only have access to their captured variables while they are executing...
    = note: ...therefore, they cannot allow references to captured variables to escape
</code></pre></div>



<a name="271318413"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/cannot%20move%20out%20of%20a%20captured%20variable%20in%20an%20%60FnMut%60%20closure/near/271318413" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/cannot.20move.20out.20of.20a.20captured.20variable.20in.20an.20.60FnMut.60.20closure.html#271318413">(Feb 09 2022 at 17:45)</a>:</h4>
<p><span class="user-mention" data-user-id="232018">@Daniel Henry-Mantilla</span> And yes, I know that I can pass the values in and out of the unfold closure, but that's painful (especially since I have a half-dozen return points that all have to include those values), and makes me feel like I'm doing the compiler's job by manually constructing a closure's context.</p>



<a name="271318707"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/cannot%20move%20out%20of%20a%20captured%20variable%20in%20an%20%60FnMut%60%20closure/near/271318707" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/cannot.20move.20out.20of.20a.20captured.20variable.20in.20an.20.60FnMut.60.20closure.html#271318707">(Feb 09 2022 at 17:47)</a>:</h4>
<p>Also, I just confirmed that async closures don't seem to solve this problem, either.</p>



<a name="271319825"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/cannot%20move%20out%20of%20a%20captured%20variable%20in%20an%20%60FnMut%60%20closure/near/271319825" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/cannot.20move.20out.20of.20a.20captured.20variable.20in.20an.20.60FnMut.60.20closure.html#271319825">(Feb 09 2022 at 17:53)</a>:</h4>
<p>Short of generators, is there any way I can solve this on stable today, without having to pass the values in-and-out of the closure?</p>



<a name="271319898"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/cannot%20move%20out%20of%20a%20captured%20variable%20in%20an%20%60FnMut%60%20closure/near/271319898" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/cannot.20move.20out.20of.20a.20captured.20variable.20in.20an.20.60FnMut.60.20closure.html#271319898">(Feb 09 2022 at 17:53)</a>:</h4>
<p>And if not, then is there any planned change short of full generators that would help?</p>



<a name="271321061"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/cannot%20move%20out%20of%20a%20captured%20variable%20in%20an%20%60FnMut%60%20closure/near/271321061" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Frank Steffahn <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/cannot.20move.20out.20of.20a.20captured.20variable.20in.20an.20.60FnMut.60.20closure.html#271321061">(Feb 09 2022 at 18:00)</a>:</h4>
<p>Afaict, the only way this can be solved with async closure is if async closures were to implement something similar to a trait bound</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">for</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;'</span><span class="na">a</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">F</span>: <span class="nb">FnOnce</span><span class="o">&lt;</span><span class="p">(</span><span class="n">Args</span><span class="o">..</span><span class="p">.,)</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="k">for</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&lt;&amp;'</span><span class="na">a</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">FnOnce</span><span class="o">&lt;</span><span class="p">(</span><span class="n">Args</span><span class="o">..</span><span class="p">.,)</span><span class="o">&gt;</span>::<span class="n">Output</span>: <span class="nc">Future</span><span class="o">&lt;</span><span class="n">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ReturnType</span><span class="p">,</span><span class="w"></span>
</code></pre></div>
<p>or equivalently, a new trait like</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">trait</span><span class="w"> </span><span class="n">AsyncFnMut</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">async</span><span class="w"> </span><span class="k">fn</span> <span class="nf">call_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">args</span>: <span class="nc">Args</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Output</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>(which is under hypothetical async-trait desugaring equivalent to)</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">trait</span><span class="w"> </span><span class="n">AsyncFnMut</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">CallFuture</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span>: <span class="nc">Future</span><span class="o">&lt;</span><span class="n">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">Self</span>::<span class="n">Output</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">    </span><span class="k">where</span><span class="w"></span>
<span class="w">        </span><span class="bp">Self</span>: <span class="o">'</span><span class="na">a</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">call_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">args</span>: <span class="nc">Args</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">CallFuture</span><span class="o">&lt;'</span><span class="nb">_</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<hr>
<p>In this case then, furthermore, <code>unfold</code> would need to change its type signature to accept such an <code>AsyncFnMut</code>. The current type signature with its</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="w">    </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Fut</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">Fut</span>: <span class="nc">TryFuture</span><span class="o">&lt;</span><span class="nb">Ok</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="n">Item</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w"></span>
</code></pre></div>
<p>bound simply cannot support what you’d need here: the returned future would need to be able to _borrow_ from the closure itself! But <code>FnMut(T) -&gt; Fut</code> clearly disallows this. In fact, a function with</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="w">    </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Fut</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">Fut</span>: <span class="nc">TryFuture</span><span class="o">&lt;</span><span class="nb">Ok</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="n">Item</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w"></span>
</code></pre></div>
<p>bounds could easily be running multiple futures returned by the <code>F</code>-closure in concurrently (if it was somehow able to fabricate multiple instance of <code>T</code>, that is), and also it can run a future after the closure it came from was dropped. So with this type signature, no, there’s no possible way at all to avoid needing to “pass the values in-and-out” when using the existing <code>futures_util::stream::try_unfold</code> with it’s current type signature, because that <code>T</code>-value being passed around is the only thing that ensures any kind of sequential evaluation of the futures involved at all, and also it doesn’t prevent at all the closure from being dropped before the final evaluation of one of the futures finishes.</p>



<a name="271323386"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/cannot%20move%20out%20of%20a%20captured%20variable%20in%20an%20%60FnMut%60%20closure/near/271323386" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/cannot.20move.20out.20of.20a.20captured.20variable.20in.20an.20.60FnMut.60.20closure.html#271323386">(Feb 09 2022 at 18:13)</a>:</h4>
<p>Thanks for the clear breakdowns, <span class="user-mention" data-user-id="232018">@Daniel Henry-Mantilla</span> and <span class="user-mention" data-user-id="280891">@Frank Steffahn</span></p>



<a name="271323410"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/cannot%20move%20out%20of%20a%20captured%20variable%20in%20an%20%60FnMut%60%20closure/near/271323410" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/cannot.20move.20out.20of.20a.20captured.20variable.20in.20an.20.60FnMut.60.20closure.html#271323410">(Feb 09 2022 at 18:13)</a>:</h4>
<p>I think we will need <code>Async</code> variants of all the <code>Fn</code> traits for async closures</p>



<a name="271329211"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/cannot%20move%20out%20of%20a%20captured%20variable%20in%20an%20%60FnMut%60%20closure/near/271329211" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Frank Steffahn <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/cannot.20move.20out.20of.20a.20captured.20variable.20in.20an.20.60FnMut.60.20closure.html#271329211">(Feb 09 2022 at 18:53)</a>:</h4>
<p>For ordinary closures, too, it is occasionally requested to add a way of referring/relating to the lifetime of the <code>Self</code>-borrow in the return type. This could mean e.g. introducing a trait hierarchy with new traits  (actual naming TBD)</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">GatFnMut</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">GatOutput</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="bp">Self</span>: <span class="o">'</span><span class="na">a</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">call_mut</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">args</span>: <span class="nc">Args</span><span class="w"></span>
<span class="w">    </span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">GatOutput</span><span class="o">&lt;'</span><span class="nb">_</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">GatFn</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span>: <span class="nc">GatFnMut</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">call</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">args</span>: <span class="nc">Args</span><span class="w"></span>
<span class="w">    </span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">GatOutput</span><span class="o">&lt;'</span><span class="nb">_</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>relating the existing function traits as follows</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="nb">FnOnce</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">call_once</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">args</span>: <span class="nc">Args</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Output</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="nb">FnMut</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span>: <span class="nb">FnOnce</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">GatFnMut</span><span class="o">&lt;</span><span class="n">Args</span><span class="p">,</span><span class="w"> </span><span class="k">for</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="n">GatOutput</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">Self</span>::<span class="n">Output</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="nb">Fn</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span>: <span class="nb">FnMut</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">GatFn</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
</code></pre></div>
<p><code>FnMut</code> and <code>Fn</code> would pretty-much be synonyms of their super-trait bounds at that point, they wouldn’t actually need any dedicated methods anymore.</p>
<hr>
<p>In any case, with such traits, you could have things like</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">move</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
</code></pre></div>
<p>work with <code>y</code>'s type implementing <code>GatFn&lt;(), for&lt;'a&gt; Output&lt;'a&gt; = &amp;'a String&gt;</code>. (Perhaps inferring this kind of stuff could turn out to be super hard, but at least allowing such closures to work when passed to a function that explicitly expects them should be a fairly straightforward MVP.)</p>
<p>Interestingly, in this case, we wouldn’t even need any dedicated <code>async ||</code> closure feature to make the original example in this thread work, instead the solution would simply be to “leave out the second <code>move</code>” so the contained future can _borrow_ from the captured variables of the containing closure. The most important aspect of async-closures (vs closures containing async blocks) is AFAIK something different anyways, that is: the ability to <em>move</em> all the closure arguments onto the contained async blocks unconditionally. Currently <code>|x, y, z| async { … }</code> in the non-<code>move</code> case is problematic: you might not want to move all <em>captured</em> variables into the closure+async block construct, hence deliberately not put any <code>move</code>, but you <em>need</em> to move the closure arguments into the returned future (because otherwise you get errors about borrowing the local variables <code>x</code>/<code>y</code>/<code>z</code> in the async block) which is completely impossible to do without using <code>move</code> if any of the arguments are <code>Copy</code> AFAIK. (Introducing <code>move</code> then forces you to explicitly create references for all the captured variables so you can avoid the <code>move</code>s there.)</p>
<hr>
<p>For the record, with the traits above, the <code>unfold</code> function (without the extra <code>T</code> being passed around) could have a signature expecting <code>F: GatFnMut&lt;()&gt;, for&lt;'a&gt; F::GatOutput&lt;'a&gt;: Future&lt;Output = Item&gt;</code>.</p>
<p>How to actually name these things and whether there are good ways to make these kind of things shorter and/or better to write is a separate question. I suppose, dedicated trait synonyms for the async case might be a good approach.</p>



<a name="271329587"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/cannot%20move%20out%20of%20a%20captured%20variable%20in%20an%20%60FnMut%60%20closure/near/271329587" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sam Sartor <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/cannot.20move.20out.20of.20a.20captured.20variable.20in.20an.20.60FnMut.60.20closure.html#271329587">(Feb 09 2022 at 18:56)</a>:</h4>
<p>So many traits need attached versions (e.g. Iterator, Stream, Fn*, Future, etc) it would be really nice to have a general way of saying "yah this associated type borrows from self".</p>



<a name="271339129"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/cannot%20move%20out%20of%20a%20captured%20variable%20in%20an%20%60FnMut%60%20closure/near/271339129" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/cannot.20move.20out.20of.20a.20captured.20variable.20in.20an.20.60FnMut.60.20closure.html#271339129">(Feb 09 2022 at 20:01)</a>:</h4>
<p><span class="user-mention" data-user-id="280891">@Frank Steffahn</span> I see; I think when I wrote <code>async move |...|</code> I was effectively assuming the semantics of such a trait, where the compiler would "know" that the function could safely own the moved value. But with the <code>FnMut</code> signature in <code>try_unfold</code> it couldn't actually know that.</p>



<a name="271339197"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/cannot%20move%20out%20of%20a%20captured%20variable%20in%20an%20%60FnMut%60%20closure/near/271339197" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/cannot.20move.20out.20of.20a.20captured.20variable.20in.20an.20.60FnMut.60.20closure.html#271339197">(Feb 09 2022 at 20:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="116883">tmandry</span> <a href="#narrow/stream/187312-wg-async/topic/cannot.20move.20out.20of.20a.20captured.20variable.20in.20an.20.60FnMut.60.20closure/near/271323410">said</a>:</p>
<blockquote>
<p>I think we will need <code>Async</code> variants of all the <code>Fn</code> traits for async closures</p>
</blockquote>
<p>Would that involve having blanket impls for backwards compatibility?</p>



<a name="271340371"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/cannot%20move%20out%20of%20a%20captured%20variable%20in%20an%20%60FnMut%60%20closure/near/271340371" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/cannot.20move.20out.20of.20a.20captured.20variable.20in.20an.20.60FnMut.60.20closure.html#271340371">(Feb 09 2022 at 20:10)</a>:</h4>
<p><span class="user-mention silent" data-user-id="239881">Josh Triplett</span> <a href="#narrow/stream/187312-wg-async/topic/cannot.20move.20out.20of.20a.20captured.20variable.20in.20an.20.60FnMut.60.20closure/near/271319825">said</a>:</p>
<blockquote>
<p>Short of generators, is there any way I can solve this on stable today, without having to pass the values in-and-out of the closure?</p>
</blockquote>
<p>You would need a new <code>unfold</code> API which would take ownership of a state only to let the future borrow it:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span> <span class="nf">lending_unfold</span><span class="o">&lt;'</span><span class="na">lt</span><span class="p">,</span><span class="w"> </span><span class="n">State</span><span class="w"> </span>: <span class="o">'</span><span class="na">lt</span><span class="p">,</span><span class="w"> </span><span class="n">Item</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">state</span>: <span class="nc">State</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">factory</span>: <span class="nc">impl</span><span class="w"> </span><span class="o">'</span><span class="na">lt</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">FnMut</span><span class="p">(</span><span class="o">&amp;'</span><span class="nb">_</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">State</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">BoxFuture</span><span class="o">&lt;'</span><span class="nb">_</span><span class="p">,</span><span class="w"> </span><span class="n">Item</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">impl</span><span class="w"> </span><span class="o">'</span><span class="na">lt</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Unpin</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Stream</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Item</span><span class="o">&gt;</span><span class="w"></span>
</code></pre></div>
<p>something along those lines.</p>



<a name="271340678"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/cannot%20move%20out%20of%20a%20captured%20variable%20in%20an%20%60FnMut%60%20closure/near/271340678" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Triplett <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/cannot.20move.20out.20of.20a.20captured.20variable.20in.20an.20.60FnMut.60.20closure.html#271340678">(Feb 09 2022 at 20:13)</a>:</h4>
<p>Fair enough; that'd be more convenient, but not necessarily worth adding rather than waiting for better language features.</p>



<a name="271352144"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/cannot%20move%20out%20of%20a%20captured%20variable%20in%20an%20%60FnMut%60%20closure/near/271352144" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/cannot.20move.20out.20of.20a.20captured.20variable.20in.20an.20.60FnMut.60.20closure.html#271352144">(Feb 09 2022 at 21:47)</a>:</h4>
<p><span class="user-mention silent" data-user-id="239881">Josh Triplett</span> <a href="#narrow/stream/187312-wg-async/topic/cannot.20move.20out.20of.20a.20captured.20variable.20in.20an.20.60FnMut.60.20closure/near/271339197">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="116883">tmandry</span> <a href="#narrow/stream/187312-wg-async/topic/cannot.20move.20out.20of.20a.20captured.20variable.20in.20an.20.60FnMut.60.20closure/near/271323410">said</a>:</p>
<blockquote>
<p>I think we will need <code>Async</code> variants of all the <code>Fn</code> traits for async closures</p>
</blockquote>
<p>Would that involve having blanket impls for backwards compatibility?</p>
</blockquote>
<p>Most likely. I haven't spent much time exploring all the options here, though</p>



<a name="271353385"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/cannot%20move%20out%20of%20a%20captured%20variable%20in%20an%20%60FnMut%60%20closure/near/271353385" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/cannot.20move.20out.20of.20a.20captured.20variable.20in.20an.20.60FnMut.60.20closure.html#271353385">(Feb 09 2022 at 21:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="222520">Sam Sartor</span> <a href="#narrow/stream/187312-wg-async/topic/cannot.20move.20out.20of.20a.20captured.20variable.20in.20an.20.60FnMut.60.20closure/near/271329587">said</a>:</p>
<blockquote>
<p>So many traits need attached versions (e.g. Iterator, Stream, Fn*, Future, etc) it would be really nice to have a general way of saying "yah this associated type borrows from self".</p>
</blockquote>
<p><span class="user-mention" data-user-id="116009">@nikomatsakis</span> This reminds me somewhat of the <code>Struct + 'a</code> thing we were talking about. It would be nice if we didn't need separate versions of all of these traits and could just come up with a general way to spell them differently that meant the "attached" version</p>



<a name="272297644"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/cannot%20move%20out%20of%20a%20captured%20variable%20in%20an%20%60FnMut%60%20closure/near/272297644" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nikomatsakis <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/cannot.20move.20out.20of.20a.20captured.20variable.20in.20an.20.60FnMut.60.20closure.html#272297644">(Feb 17 2022 at 17:54)</a>:</h4>
<p><span class="user-mention" data-user-id="232957">@Jack Huey</span> and I have been looking into this</p>



<a name="272297663"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/cannot%20move%20out%20of%20a%20captured%20variable%20in%20an%20%60FnMut%60%20closure/near/272297663" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nikomatsakis <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/cannot.20move.20out.20of.20a.20captured.20variable.20in.20an.20.60FnMut.60.20closure.html#272297663">(Feb 17 2022 at 17:54)</a>:</h4>
<p>what it would take to upgrade "iterator" "in place"</p>



<a name="272297727"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/cannot%20move%20out%20of%20a%20captured%20variable%20in%20an%20%60FnMut%60%20closure/near/272297727" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jack Huey <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/cannot.20move.20out.20of.20a.20captured.20variable.20in.20an.20.60FnMut.60.20closure.html#272297727">(Feb 17 2022 at 17:54)</a>:</h4>
<p>oh. at first I was like "wait we have?"</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>