<html>
<head><meta charset="utf-8"><title>Synchronous cancellation and C++ interop · wg-async · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/index.html">wg-async</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Synchronous.20cancellation.20and.20C.2B.2B.20interop.html">Synchronous cancellation and C++ interop</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="264107825"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Synchronous%20cancellation%20and%20C%2B%2B%20interop/near/264107825" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Synchronous.20cancellation.20and.20C.2B.2B.20interop.html#264107825">(Dec 08 2021 at 03:35)</a>:</h4>
<p>I thought this group might want to know what the current status of cancellation is in our C++ async interop solution, <a href="https://github.com/pcwalton/cxx-async">https://github.com/pcwalton/cxx-async</a></p>



<a name="264107905"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Synchronous%20cancellation%20and%20C%2B%2B%20interop/near/264107905" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Synchronous.20cancellation.20and.20C.2B.2B.20interop.html#264107905">(Dec 08 2021 at 03:36)</a>:</h4>
<p>The problem is that C++ coroutines generally want to run to completion (note that the standard doesn't specify this, but libraries generally assume it), while Rust futures can be dropped at any time</p>



<a name="264107967"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Synchronous%20cancellation%20and%20C%2B%2B%20interop/near/264107967" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Synchronous.20cancellation.20and.20C.2B.2B.20interop.html#264107967">(Dec 08 2021 at 03:37)</a>:</h4>
<p>What I've done is to create a lazily-spawned, process-global thread called the "reaper", where C++ coroutines are reparented to if the Rust future wrapping them is dropped</p>



<a name="264108015"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Synchronous%20cancellation%20and%20C%2B%2B%20interop/near/264108015" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Synchronous.20cancellation.20and.20C.2B.2B.20interop.html#264108015">(Dec 08 2021 at 03:38)</a>:</h4>
<p>The reaper is a simple executor that just drives coroutines to completion and discards their results</p>



<a name="264108066"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Synchronous%20cancellation%20and%20C%2B%2B%20interop/near/264108066" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Synchronous.20cancellation.20and.20C.2B.2B.20interop.html#264108066">(Dec 08 2021 at 03:39)</a>:</h4>
<p>This actually seems to work well. The downside is that C++ may need to copy references to stack locals if the future gets reparented. But cxx-async currently requires wrapped C++ futures to be <code>'static</code> anyway, so this doesn't matter right now.</p>



<a name="264230683"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Synchronous%20cancellation%20and%20C%2B%2B%20interop/near/264230683" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eholk <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Synchronous.20cancellation.20and.20C.2B.2B.20interop.html#264230683">(Dec 08 2021 at 22:32)</a>:</h4>
<p>That's awesome! I had no idea this work was happening, but I'm glad to see it.</p>



<a name="264230759"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Synchronous%20cancellation%20and%20C%2B%2B%20interop/near/264230759" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eholk <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Synchronous.20cancellation.20and.20C.2B.2B.20interop.html#264230759">(Dec 08 2021 at 22:33)</a>:</h4>
<p>Do you run into issues mixing Rust and C++ executors? I would expect problems with that even between different Rust executors, so doing it with C++ seems even more challenging.</p>



<a name="264336848"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Synchronous%20cancellation%20and%20C%2B%2B%20interop/near/264336848" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Walton <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Synchronous.20cancellation.20and.20C.2B.2B.20interop.html#264336848">(Dec 09 2021 at 17:35)</a>:</h4>
<p>It was challenging to get executor interop working, but it seems to be working well now :)</p>



<a name="264741093"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Synchronous%20cancellation%20and%20C%2B%2B%20interop/near/264741093" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Yoshua Wuyts [he/they] <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Synchronous.20cancellation.20and.20C.2B.2B.20interop.html#264741093">(Dec 13 2021 at 17:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="384014">Patrick Walton</span> <a href="#narrow/stream/187312-wg-async-foundations/topic/Synchronous.20cancellation.20and.20C.2B.2B.20interop/near/264107905">said</a>:</p>
<blockquote>
<p>The problem is that C++ coroutines generally want to run to completion (note that the standard doesn't specify this, but libraries generally assume it), while Rust futures can be dropped at any time</p>
</blockquote>
<p>I thought the spec mentioned it was undefined behavior if a C++ future wasn't run to completion? It sounds like I might have misunderstood?</p>



<a name="264965255"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Synchronous%20cancellation%20and%20C%2B%2B%20interop/near/264965255" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Synchronous.20cancellation.20and.20C.2B.2B.20interop.html#264965255">(Dec 15 2021 at 04:46)</a>:</h4>
<p>+1 to what <span class="user-mention" data-user-id="421986">@eholk</span> said, this is very cool. Annoying that you had to navigate this mismatch, but I'm glad you found something that actually works well.</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>