<html>
<head><meta charset="utf-8"><title>Example of odd composing of Send · wg-async · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/index.html">wg-async</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Example.20of.20odd.20composing.20of.20Send.html">Example of odd composing of Send</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="249676640"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Example%20of%20odd%20composing%20of%20Send/near/249676640" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Example.20of.20odd.20composing.20of.20Send.html#249676640">(Aug 17 2021 at 04:04)</a>:</h4>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=d68f48effd9419241e5323bb3cf86148">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=d68f48effd9419241e5323bb3cf86148</a></p>



<a name="249676661"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Example%20of%20odd%20composing%20of%20Send/near/249676661" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Example.20of.20odd.20composing.20of.20Send.html#249676661">(Aug 17 2021 at 04:05)</a>:</h4>
<p>This example doesn't type check because the two async blocks are !Send, therefore foo is not !Send, which is required by spawn</p>



<a name="249676716"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Example%20of%20odd%20composing%20of%20Send/near/249676716" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Example.20of.20odd.20composing.20of.20Send.html#249676716">(Aug 17 2021 at 04:06)</a>:</h4>
<p>One could fix this by using a Mutex or something, but it seems vaguely reasonable to fix this without needing more atomics, etc, by some kind of scoping composability of futures</p>



<a name="249676791"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Example%20of%20odd%20composing%20of%20Send/near/249676791" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Example.20of.20odd.20composing.20of.20Send.html#249676791">(Aug 17 2021 at 04:08)</a>:</h4>
<p>I.e., one could imagine that a future which owns the Cell and evaluates to join, should be Send, even though the join future is not Send because internal to that future, the sub-futures will be evaluated on the same thread and the reference to the Cell does not exist outside the future</p>



<a name="249676857"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Example%20of%20odd%20composing%20of%20Send/near/249676857" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Example.20of.20odd.20composing.20of.20Send.html#249676857">(Aug 17 2021 at 04:10)</a>:</h4>
<p>Is it possible to write something like that today (using async, rather than writing the futures manually)? Or is this on the radar for async work? (It feels a bit similar to the scopes deliverable, but I don't think it quite addresses it)</p>



<a name="249788825"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Example%20of%20odd%20composing%20of%20Send/near/249788825" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Example.20of.20odd.20composing.20of.20Send.html#249788825">(Aug 17 2021 at 22:48)</a>:</h4>
<p>Niko and I were actually talking about this a bit yesterday.. ideally we can separate the original call from the "polling state" somehow</p>



<a name="249888026"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Example%20of%20odd%20composing%20of%20Send/near/249888026" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Matthias247 <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Example.20of.20odd.20composing.20of.20Send.html#249888026">(Aug 18 2021 at 17:59)</a>:</h4>
<blockquote>
<p>I.e., one could imagine that a future which owns the Cell and evaluates to join, should be Send, even though the join future is not Send because internal to that future, the sub-futures will be evaluated on the same thread and the reference to the Cell does not exist outside the future</p>
</blockquote>
<p>That would need to be a guarantee that is given by the executor. And executors which are multi-threaded don't provide it. They might move the task between each <code>.poll()</code> operation.</p>



<a name="249888304"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Example%20of%20odd%20composing%20of%20Send/near/249888304" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Matthias247 <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Example.20of.20odd.20composing.20of.20Send.html#249888304">(Aug 18 2021 at 18:01)</a>:</h4>
<p>If you have an executor which provides guarantees of not moving tasks between threads (like a single-threaded one), it can take <code>!Send</code> <code>Future</code>s  and everything is fine. tokio <code>LocalSet</code> also does something like this.</p>



<a name="249888536"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Example%20of%20odd%20composing%20of%20Send/near/249888536" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Matthias247 <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Example.20of.20odd.20composing.20of.20Send.html#249888536">(Aug 18 2021 at 18:02)</a>:</h4>
<p>What I like to see for a while is that once we have structured concurrency you can create a sub-scope which has stronger executor guarantees, like tying everything onto a single thread. And from there on you can do <code>.spawn_local(task)</code> to start non-synchronized tasks</p>



<a name="249889605"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Example%20of%20odd%20composing%20of%20Send/near/249889605" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Matthias247 <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Example.20of.20odd.20composing.20of.20Send.html#249889605">(Aug 18 2021 at 18:09)</a>:</h4>
<p>Although it seems like I might just have gotten half of the question, and the other half is why it requires <code>Sync</code> here and not just <code>Send</code>. I'm not sure on this.</p>



<a name="249902481"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Example%20of%20odd%20composing%20of%20Send/near/249902481" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Alice Ryhl <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Example.20of.20odd.20composing.20of.20Send.html#249902481">(Aug 18 2021 at 19:47)</a>:</h4>
<p>Right, this has to do with Rust not having a concept of "not <code>Send</code> unless you move every instance simultaneously", which applies to both <code>Rc</code> and <code>&amp;T</code> for non-Sync <code>T</code>.</p>



<a name="249914769"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Example%20of%20odd%20composing%20of%20Send/near/249914769" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Example.20of.20odd.20composing.20of.20Send.html#249914769">(Aug 18 2021 at 21:33)</a>:</h4>
<p>^ that's interesting. to me it feels conceptually similar to self-borrows</p>



<a name="249914937"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Example%20of%20odd%20composing%20of%20Send/near/249914937" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Example.20of.20odd.20composing.20of.20Send.html#249914937">(Aug 18 2021 at 21:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="204219">Matthias247</span> <a href="#narrow/stream/187312-wg-async-foundations/topic/Example.20of.20odd.20composing.20of.20Send/near/249888026">said</a>:</p>
<blockquote>
<blockquote>
<p>I.e., one could imagine that a future which owns the Cell and evaluates to join, should be Send, even though the join future is not Send because internal to that future, the sub-futures will be evaluated on the same thread and the reference to the Cell does not exist outside the future</p>
</blockquote>
<p>That would need to be a guarantee that is given by the executor. And executors which are multi-threaded don't provide it. They might move the task between each <code>.poll()</code> operation.</p>
</blockquote>
<p>You could have an executor which assigns futures to a potentially different thread on spawn, but does not move them between polls. That seems like a common enough use case that's worth considering</p>



<a name="249946376"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Example%20of%20odd%20composing%20of%20Send/near/249946376" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Matthias247 <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Example.20of.20odd.20composing.20of.20Send.html#249946376">(Aug 19 2021 at 06:26)</a>:</h4>
<p>You could. But to make use of that you would have to change the spawn signature, since the <code>Future</code> type is the same between having been polled or not being polled yet. Something along: <code>spawn&lt;Func: Send + FnOnce() -&gt; Fut, Fut: Future&gt;(f:  Func)</code>. </p>
<p>Not sure if you would want that, or just start/enter a sub-scope first which is ok with <code>!Send</code> and from there on spawn the tasks.</p>



<a name="250241417"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Example%20of%20odd%20composing%20of%20Send/near/250241417" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Example.20of.20odd.20composing.20of.20Send.html#250241417">(Aug 21 2021 at 22:52)</a>:</h4>
<p>I get that the executor can move the future between threads between polls and that's why the futures need to be Send, I'm wondering if its possible to deduce somehow that the Join future should be Send even though the 'child' futures are !Send, essentially because its OK to move the 'whole thing' but not 'components of the thing'</p>



<a name="250256755"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Example%20of%20odd%20composing%20of%20Send/near/250256755" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Kestrer <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Example.20of.20odd.20composing.20of.20Send.html#250256755">(Aug 22 2021 at 05:43)</a>:</h4>
<p>Theoretically we could have an API like this</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="k">fn</span> <span class="nf">with_unsync_ref</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Send</span><span class="p">,</span><span class="w"> </span><span class="n">O</span><span class="o">&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">value</span>: <span class="nc">T</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">f</span>: <span class="nc">impl</span><span class="w"> </span><span class="k">for</span><span class="o">&lt;'</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">S</span>: <span class="o">?</span><span class="nb">Send</span><span class="o">&gt;</span><span class="w"> </span><span class="n">AsyncFnOnce</span><span class="o">&lt;</span><span class="p">(</span><span class="n">Ref</span><span class="o">&lt;'</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">S</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">,),</span><span class="w"> </span><span class="n">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">O</span><span class="p">,</span><span class="w"> </span><span class="n">Future</span>: <span class="nc">S</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">O</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">..</span><span class="p">.</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>The HRTB would require that the <code>AsyncFnOnce</code> doesn't use any <code>!Send</code> types inside it other than the <code>Ref</code>, so the future returned by <code>with_unsync_ref</code> would always be <code>Send</code>.</p>



<a name="250534082"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Example%20of%20odd%20composing%20of%20Send/near/250534082" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> nikomatsakis <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Example.20of.20odd.20composing.20of.20Send.html#250534082">(Aug 24 2021 at 19:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="256841">Nick Cameron</span> <a href="#narrow/stream/187312-wg-async-foundations/topic/Example.20of.20odd.20composing.20of.20Send/near/250241417">said</a>:</p>
<blockquote>
<p>I get that the executor can move the future between threads between polls and that's why the futures need to be Send, I'm wondering if its possible to deduce somehow that the Join future should be Send even though the 'child' futures are !Send, essentially because its OK to move the 'whole thing' but not 'components of the thing'</p>
</blockquote>
<p>In what scenario would that be ok?</p>



<a name="250545073"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Example%20of%20odd%20composing%20of%20Send/near/250545073" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Kestrer <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Example.20of.20odd.20composing.20of.20Send.html#250545073">(Aug 24 2021 at 20:37)</a>:</h4>
<p>When you have a future containing a Cell and a reference to the Cell. You can move the whole thing, but can't separate the owned value &amp; reference because that could cause data races.</p>



<a name="250553801"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Example%20of%20odd%20composing%20of%20Send/near/250553801" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Cameron <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Example.20of.20odd.20composing.20of.20Send.html#250553801">(Aug 24 2021 at 21:47)</a>:</h4>
<p><span class="user-mention" data-user-id="116009">@nikomatsakis</span> see the playground at the start of the thread. I haven't thought about generalisations</p>



<a name="251772474"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Example%20of%20odd%20composing%20of%20Send/near/251772474" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Example.20of.20odd.20composing.20of.20Send.html#251772474">(Sep 02 2021 at 19:28)</a>:</h4>
<p>Here's a strawman called <a href="https://hackmd.io/m5ooA3drSJWjHQYJlJ5KxQ?view">Shards</a> that I think could work for expressing this in the language. I'm not proposing actually adding this, so do with it what you will (:</p>



<a name="251780048"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Example%20of%20odd%20composing%20of%20Send/near/251780048" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eholk <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Example.20of.20odd.20composing.20of.20Send.html#251780048">(Sep 02 2021 at 20:19)</a>:</h4>
<blockquote>
<ul>
<li>This is ugly and not worth complicating the language!<ul>
<li>I tend to agree. It could serve as a starting point for a better idea or a more general “capabilities” mechanism, however.</li>
</ul>
</li>
</ul>
</blockquote>
<p>I also tend to agree, but I'm intrigued by the idea of a more general capabilities system. Have you thought any about what that would look like, <span class="user-mention" data-user-id="116883">@tmandry</span>?</p>



<a name="251780232"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Example%20of%20odd%20composing%20of%20Send/near/251780232" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eholk <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Example.20of.20odd.20composing.20of.20Send.html#251780232">(Sep 02 2021 at 20:20)</a>:</h4>
<p>I actually kind of like the idea, I just think it's weird to have something so similar to lifetimes alongside the lifetimes system</p>



<a name="251780389"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Example%20of%20odd%20composing%20of%20Send/near/251780389" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Example.20of.20odd.20composing.20of.20Send.html#251780389">(Sep 02 2021 at 20:21)</a>:</h4>
<p>not really. <span class="user-mention" data-user-id="116009">@nikomatsakis</span> mentioned it to me in passing</p>



<a name="251780602"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Example%20of%20odd%20composing%20of%20Send/near/251780602" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> tmandry <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Example.20of.20odd.20composing.20of.20Send.html#251780602">(Sep 02 2021 at 20:23)</a>:</h4>
<p>I assume there is prior art in type systems research, I’m just not familiar with it</p>



<a name="274196768"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Example%20of%20odd%20composing%20of%20Send/near/274196768" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eholk <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Example.20of.20odd.20composing.20of.20Send.html#274196768">(Mar 04 2022 at 22:25)</a>:</h4>
<p>So resurrecting this thread, I'm thinking some more about the case where you do</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SomeSendType</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">..</span><span class="p">.</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="n">foo</span><span class="p">().</span><span class="k">await</span><span class="p">;</span><span class="w"></span>
<span class="n">println</span><span class="p">(</span><span class="s">"{y:?}"</span><span class="p">);</span><span class="w"></span>
</code></pre></div>
<p>Under current rules, the resulting generator isn't <code>Send</code> since <code>&amp;SomeSendType</code> is not send because <code>SomeSendType</code> is not <code>Sync</code> (I guess that's not explicitly stated, but let's assume it's true).  But it seems like it should be safe for the generator to be <code>Send</code> since we can't really send <code>y</code> without sending <code>x</code> with it (I'd love to have a clear counterexample where we could break something like this if there is one).</p>
<p>I wonder if we could support this using just the borrow checker? The idea would be to insert a special <code>'current_stack_frame</code> region and then if the lifetime on <code>&amp;x</code> is <code>'a</code> and <code>'current_stack_frame</code> outlives <code>'a</code> then it's okay for the generator to be <code>Send</code>?</p>
<p>Of course, implementing this is a little tricky because we currently figure out auto traits before we run the borrow checker, and this particular rule wouldn't mean we're adding a constraint but rather changing the type depending on whether a constraint holds.</p>



<a name="274317761"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Example%20of%20odd%20composing%20of%20Send/near/274317761" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Example.20of.20odd.20composing.20of.20Send.html#274317761">(Mar 06 2022 at 17:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="421986">eholk</span> <a href="#narrow/stream/187312-wg-async/topic/Example.20of.20odd.20composing.20of.20Send/near/274196768">said</a>:</p>
<blockquote>
<p>But it seems like it should be safe for the generator to be <code>Send</code> since we can't really send <code>y</code> without sending <code>x</code> with it (I'd love to have a clear counterexample where we could break something like this if there is one).</p>
</blockquote>
<p>So, it's a bit of a contrived API <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span> , but honestly not <em>that</em> much:</p>
<div class="spoiler-block"><div class="spoiler-header">
<p>code</p>
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">use</span><span class="w"> </span>::<span class="n">core</span>::<span class="p">{</span><span class="n">cell</span>::<span class="n">Cell</span><span class="p">,</span><span class="w"> </span><span class="n">marker</span>::<span class="n">PhantomData</span><span class="p">};</span><span class="w"></span>

<span class="k">pub</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">ZstRef</span><span class="o">&lt;'</span><span class="na">c</span><span class="o">&gt;</span><span class="w"> </span><span class="cm">/* = */</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="c1">// As if</span>
<span class="w">    </span><span class="n">PhantomData</span><span class="o">&lt;</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Self had this =&gt; not Send</span>
<span class="w">        </span><span class="o">&amp;'</span><span class="na">c</span><span class="w"> </span><span class="n">Cell</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>

<span class="fm">thread_local!</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">PTR</span>: <span class="nc">Cell</span><span class="o">&lt;*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u8</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">Cell</span>::<span class="n">new</span><span class="p">(</span>::<span class="n">core</span>::<span class="n">ptr</span>::<span class="n">null_mut</span><span class="p">())</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;'</span><span class="na">c</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ZstRef</span><span class="o">&lt;'</span><span class="na">c</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="w"> </span><span class="p">(</span><span class="n">r</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">c</span> <span class="nc">Cell</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">ZstRef</span><span class="o">&lt;'</span><span class="na">c</span><span class="o">&gt;&gt;</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">impl</span><span class="o">&lt;'</span><span class="na">c</span><span class="o">&gt;</span><span class="w"> </span>::<span class="n">core</span>::<span class="n">ops</span>::<span class="n">Deref</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">ZstRef</span><span class="o">&lt;'</span><span class="na">c</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">type</span> <span class="nc">Target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Cell</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>

<span class="w">            </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">            </span><span class="k">fn</span> <span class="nf">deref</span><span class="w"> </span><span class="p">(</span><span class="bp">self</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="nb">_</span> <span class="nc">ZstRef</span><span class="o">&lt;'</span><span class="na">c</span><span class="o">&gt;</span><span class="p">)</span><span class="w"></span>
<span class="w">              </span>-&gt; <span class="kp">&amp;</span><span class="o">'</span><span class="na">c</span> <span class="nc">Cell</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">            </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="c1">// # Safety</span>
<span class="w">                    </span><span class="c1">//   - PTR filled at construction</span>
<span class="w">                    </span><span class="c1">//   - Self : !Send, so *this is the same PTR as the one filled at construction*</span>
<span class="w">                    </span><span class="o">&amp;*</span><span class="n">PTR</span><span class="p">.</span><span class="n">with</span><span class="p">(</span><span class="n">Cell</span>::<span class="n">get</span><span class="p">).</span><span class="n">cast</span><span class="p">()</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="c1">// PTR filled at construction indeed:</span>
<span class="w">        </span><span class="n">PTR</span><span class="p">.</span><span class="n">with</span><span class="p">(</span><span class="o">|</span><span class="n">it</span><span class="o">|</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">it</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">is_null</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">it</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">as_ptr</span><span class="p">());</span><span class="w"></span>
<span class="w">            </span><span class="nb">Some</span><span class="p">(</span><span class="bp">Self</span><span class="p">(</span><span class="n">PhantomData</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="nb">None</span><span class="w"></span>
<span class="w">        </span><span class="p">})</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
</div></div>
<ul>
<li>
<p><a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=7fd1bd10faf5cd870abf774a424b0f78">Playground</a></p>
</li>
<li>
<p>Note that this example, for the sake of simplicity, wraps the reference itself, but it could be made to be a transparent newtype around <code>Cell</code>, and then have a <code>&amp;'c MyRef&lt;Cell&lt;u8&gt;&gt;</code> rather than a <code>MyRef&lt;&amp;'c Cell&lt;u8&gt;&gt;</code> so to speak (granted the "zst ref" pseudo justification of such an API would be a bit moot, at that point <span aria-label="big smile" class="emoji emoji-1f604" role="img" title="big smile">:big_smile:</span>); so saying "the forced <code>Sync</code>ness mechanism would not apply for wrapped references" would not be a valid way to dodge the issue.</p>
</li>
</ul>



<a name="274317964"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Example%20of%20odd%20composing%20of%20Send/near/274317964" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Example.20of.20odd.20composing.20of.20Send.html#274317964">(Mar 06 2022 at 17:26)</a>:</h4>
<p>Also, in case the issue wasn't clear:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Cell</span>::<span class="n">new</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ZstRef</span>::<span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
<span class="n">foo</span><span class="p">().</span><span class="k">await</span><span class="p">;</span><span class="w"> </span><span class="c1">// &lt;- the future may be sent to another thread during this suspension, if allowed to be Send</span>
<span class="n">println</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">.</span><span class="n">get</span><span class="p">());</span><span class="w"> </span><span class="c1">//  &lt;- if run from a distinct thread, this derefs a null ptr</span>
</code></pre></div>



<a name="274318387"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Example%20of%20odd%20composing%20of%20Send/near/274318387" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Example.20of.20odd.20composing.20of.20Send.html#274318387">(Mar 06 2022 at 17:35)</a>:</h4>
<p>I personally believe that the way to tackle this, from the point of view of a user, is to use <code>let y = &amp;mut x</code> when possible, and <a href="https://docs.rs/sync_wrapper/0.1.1/sync_wrapper/struct.SyncWrapper.html"><code>SyncWrapper</code></a> otherwise.</p>



<a name="274318388"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Example%20of%20odd%20composing%20of%20Send/near/274318388" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Daniel Henry-Mantilla <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Example.20of.20odd.20composing.20of.20Send.html#274318388">(Mar 06 2022 at 17:35)</a>:</h4>
<p>There is one are of "improvement", language-wise, which would be to somehow be able to express that a <code>Future</code> needs to be <code>Send</code> up until the point where it is first polled: that it may cease to be <code>Send</code> afterwards, since there could be non-work-stealing but multi-threaded executors that could work with such bounds, and it is currently not something expressible in current Rust, thus such an executor, nowadays, would have to require <code>Fut : Send</code>, and thus refuse a future such as:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">async</span><span class="w"> </span><span class="k">fn</span> <span class="nf">non_send_future</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Cell</span>::<span class="n">new</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">c</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">async</span><span class="w"> </span><span class="p">{}.</span><span class="k">await</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">r</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>(something akin to <code>impl Send + FnOnce() -&gt; (impl ?Send + Future)</code> maybe?)</p>



<a name="274431302"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Example%20of%20odd%20composing%20of%20Send/near/274431302" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eholk <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Example.20of.20odd.20composing.20of.20Send.html#274431302">(Mar 07 2022 at 17:57)</a>:</h4>
<p>Yeah, I agree that being able to separate the type of a future before the first await point versus after would be handy, although I think it might be hard to add that in a way that doesn't add a lot more complexity to the language than the feature is worth, but I could be wrong (to be fair, my proposal for changing auto trait inference with rules around a 'current_stack_frame lifetime is also likely more complexity than it's worth).</p>



<a name="274433251"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Example%20of%20odd%20composing%20of%20Send/near/274433251" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eholk <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Example.20of.20odd.20composing.20of.20Send.html#274433251">(Mar 07 2022 at 18:09)</a>:</h4>
<p>Thanks for the counter example you showed, <span class="user-mention" data-user-id="232018">@Daniel Henry-Mantilla</span> ! It definitely shows some complexity I hadn't thought about. I don't _think_ it's contradicts my proposal but whether it does probably depends on what's considered acceptable in an <code>unsafe</code> block. The reason is that by putting a reference in a thread-local variable, it does escape the current stack frame, and on the dereference side, the value is pulled again from outside the current stack frame. The compiler can't see this because it's laundered by <code>unsafe</code>, but I think a case could be made that this isn't actually a safe use of <code>unsafe</code>.</p>
<p>Of course, it's only hypothetically unsafe because of the rule I'm proposing that says non-Send values aren't considered in generator auto traits if they and all references are bound by <code>'current_stack_frame</code>, so under the current rules I agree that you're example's fine.</p>



<a name="274433599"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/187312-wg-async/topic/Example%20of%20odd%20composing%20of%20Send/near/274433599" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> eholk <a href="https://zulip-archive.rust-lang.org/stream/187312-wg-async/topic/Example.20of.20odd.20composing.20of.20Send.html#274433599">(Mar 07 2022 at 18:11)</a>:</h4>
<p>Of course, as I understand it, our current unsafe rules are more behavioral/operational rather than structural, by which I mean it's more about how you dereference raw pointers than where you store them. I'm guessing moving to a structural view would be hard to define and also break a lot of code that's currently considered safe.</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>