<html>
<head><meta charset="utf-8"><title>Workaround for E0401 · project-const-generics · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/260443-project-const-generics/index.html">project-const-generics</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/260443-project-const-generics/topic/Workaround.20for.20E0401.html">Workaround for E0401</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="269054169"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/260443-project-const-generics/topic/Workaround%20for%20E0401/near/269054169" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Delicious Scheme <a href="https://zulip-archive.rust-lang.org/stream/260443-project-const-generics/topic/Workaround.20for.20E0401.html#269054169">(Jan 24 2022 at 02:36)</a>:</h4>
<p>I have a struct defined like</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">struct</span> <span class="nc">PackedMonomial</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">L</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">E</span>: <span class="kt">usize</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">where</span><span class="w"></span>
<span class="w">    </span><span class="p">[</span><span class="kt">u64</span><span class="p">;</span><span class="w"> </span><span class="p">((</span><span class="n">E</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">L</span><span class="o">+</span><span class="mi">64</span><span class="p">)</span><span class="o">/</span><span class="mi">64</span><span class="p">]</span>: <span class="nb">Sized</span><span class="p">,</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">bits</span>: <span class="p">[</span><span class="kt">u64</span><span class="p">;</span><span class="w"> </span><span class="p">((</span><span class="n">E</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">L</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">64</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">64</span><span class="p">],</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">L</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">E</span>: <span class="kt">usize</span><span class="o">&gt;</span><span class="w"> </span><span class="n">PackedMonomial</span><span class="o">&lt;</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">E</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">where</span><span class="w"></span>
<span class="w">    </span><span class="p">[</span><span class="kt">u64</span><span class="p">;</span><span class="w"> </span><span class="p">((</span><span class="n">E</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">L</span><span class="o">+</span><span class="mi">64</span><span class="p">)</span><span class="o">/</span><span class="mi">64</span><span class="p">]</span>: <span class="nb">Sized</span><span class="p">,</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">K</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="p">(((</span><span class="n">E</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">L</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">64</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">64</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">bits</span>: <span class="p">[</span><span class="kt">u64</span><span class="p">;</span><span class="w"> </span><span class="n">K</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">K</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">bits</span>: <span class="nc">bits</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>but the rust compile gives the error</p>
<div class="codehilite" data-code-language="Julia"><pre><span></span><code><span class="mi">69</span> <span class="o">|</span>         <span class="k">const</span> <span class="n">K</span><span class="o">:</span> <span class="n">usize</span> <span class="o">=</span> <span class="p">(((</span><span class="n">E</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">L</span> <span class="o">+</span> <span class="mi">64</span><span class="p">)</span> <span class="o">/</span> <span class="mi">64</span><span class="p">);</span>
   <span class="o">|</span>                             <span class="o">^</span> <span class="n">use</span> <span class="n">of</span> <span class="n">generic</span> <span class="n">parameter</span> <span class="n">from</span> <span class="n">outer</span> <span class="k">function</span>
</code></pre></div>
<p>Is there any workaround for this issue?</p>



<a name="269066168"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/260443-project-const-generics/topic/Workaround%20for%20E0401/near/269066168" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> lcnr <a href="https://zulip-archive.rust-lang.org/stream/260443-project-const-generics/topic/Workaround.20for.20E0401.html#269066168">(Jan 24 2022 at 07:01)</a>:</h4>
<p>jup, there are 3 workarounds: </p>
<ul>
<li>change <code>K</code> to be an associated constant of <code>PackedMonomial</code>, this only works if you don't need any generic arguments from <code>fn new</code>:</li>
</ul>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">impl</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">L</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">E</span>: <span class="kt">usize</span><span class="o">&gt;</span><span class="w"> </span><span class="n">PackedMonomial</span><span class="o">&lt;</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">E</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">where</span><span class="w"></span>
<span class="w">    </span><span class="p">[</span><span class="kt">u64</span><span class="p">;</span><span class="w"> </span><span class="p">((</span><span class="n">E</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">L</span><span class="o">+</span><span class="mi">64</span><span class="p">)</span><span class="o">/</span><span class="mi">64</span><span class="p">]</span>: <span class="nb">Sized</span><span class="p">,</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">K</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="p">(((</span><span class="n">E</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">L</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">64</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">64</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">bits</span>: <span class="p">[</span><span class="kt">u64</span><span class="p">;</span><span class="w"> </span><span class="bp">Self</span>::<span class="n">K</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="bp">Self</span>::<span class="n">K</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">bits</span>: <span class="nc">bits</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>



<a name="269066445"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/260443-project-const-generics/topic/Workaround%20for%20E0401/near/269066445" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> lcnr <a href="https://zulip-archive.rust-lang.org/stream/260443-project-const-generics/topic/Workaround.20for.20E0401.html#269066445">(Jan 24 2022 at 07:07)</a>:</h4>
<ul>
<li>wait for me to open an rfc for generic named constants and successfully implement it:</li>
</ul>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">impl</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">L</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">E</span>: <span class="kt">usize</span><span class="o">&gt;</span><span class="w"> </span><span class="n">PackedMonomial</span><span class="o">&lt;</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">E</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">where</span><span class="w"></span>
<span class="w">    </span><span class="p">[</span><span class="kt">u64</span><span class="p">;</span><span class="w"> </span><span class="p">((</span><span class="n">E</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">L</span><span class="o">+</span><span class="mi">64</span><span class="p">)</span><span class="o">/</span><span class="mi">64</span><span class="p">]</span>: <span class="nb">Sized</span><span class="p">,</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">K</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">L</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">E</span>: <span class="kt">usize</span><span class="o">&gt;</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="p">(((</span><span class="n">E</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">L</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">64</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">64</span><span class="p">);</span><span class="w"> </span><span class="c1">// using 2 const params is kinda ugly here though '^^</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">bits</span>: <span class="p">[</span><span class="kt">u64</span><span class="p">;</span><span class="w"> </span><span class="n">K</span>::<span class="o">&lt;</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">E</span><span class="o">&gt;</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">K</span>::<span class="o">&lt;</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">E</span><span class="o">&gt;</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">bits</span>: <span class="nc">bits</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>



<a name="269066538"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/260443-project-const-generics/topic/Workaround%20for%20E0401/near/269066538" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> lcnr <a href="https://zulip-archive.rust-lang.org/stream/260443-project-const-generics/topic/Workaround.20for.20E0401.html#269066538">(Jan 24 2022 at 07:08)</a>:</h4>
<p>i don't think we want to automatically have named functions in bodies inherit their parents generics, even though that would definitely be nice in quite a few cases</p>



<a name="269066564"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/260443-project-const-generics/topic/Workaround%20for%20E0401/near/269066564" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> lcnr <a href="https://zulip-archive.rust-lang.org/stream/260443-project-const-generics/topic/Workaround.20for.20E0401.html#269066564">(Jan 24 2022 at 07:09)</a>:</h4>
<p>e.g. i don't know how that should work without breaking backcompat</p>



<a name="269066842"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/260443-project-const-generics/topic/Workaround%20for%20E0401/near/269066842" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Delicious Scheme <a href="https://zulip-archive.rust-lang.org/stream/260443-project-const-generics/topic/Workaround.20for.20E0401.html#269066842">(Jan 24 2022 at 07:14)</a>:</h4>
<p>Thanks a lot! I tried your first suggestion</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">struct</span> <span class="nc">PackedMonomial</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">L</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">E</span>: <span class="kt">usize</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">where</span><span class="w"></span>
<span class="w">    </span><span class="p">[</span><span class="kt">u64</span><span class="p">;</span><span class="w"> </span><span class="p">((</span><span class="n">E</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">L</span><span class="o">+</span><span class="mi">64</span><span class="p">)</span><span class="o">/</span><span class="mi">64</span><span class="p">]</span>: <span class="nb">Sized</span><span class="p">,</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">bits</span>: <span class="p">[</span><span class="kt">u64</span><span class="p">;</span><span class="w"> </span><span class="p">((</span><span class="n">E</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">L</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">64</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">64</span><span class="p">],</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">L</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">E</span>: <span class="kt">usize</span><span class="o">&gt;</span><span class="w"> </span><span class="n">PackedMonomial</span><span class="o">&lt;</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">E</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">where</span><span class="w"></span>
<span class="w">    </span><span class="p">[</span><span class="kt">u64</span><span class="p">;</span><span class="w"> </span><span class="p">((</span><span class="n">E</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">L</span><span class="o">+</span><span class="mi">64</span><span class="p">)</span><span class="o">/</span><span class="mi">64</span><span class="p">]</span>: <span class="nb">Sized</span><span class="p">,</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">K</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="p">(((</span><span class="n">E</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">L</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">64</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">64</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">bits</span>: <span class="p">[</span><span class="kt">u64</span><span class="p">;</span><span class="w"> </span><span class="bp">Self</span>::<span class="n">K</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="bp">Self</span>::<span class="n">K</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">bits</span>: <span class="nc">bits</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>and got the new error</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">error</span><span class="p">[</span><span class="n">E0308</span><span class="p">]</span>: <span class="nc">mismatched</span><span class="w"> </span><span class="n">types</span><span class="w"></span>
<span class="w">  </span><span class="o">-</span>-&gt; <span class="nc">src</span><span class="o">/</span><span class="n">symbolics</span><span class="p">.</span><span class="n">rs</span>:<span class="mi">71</span>:<span class="mi">22</span><span class="w"></span>
<span class="w">   </span><span class="o">|</span><span class="w"></span>
<span class="mi">71</span><span class="w"> </span><span class="o">|</span><span class="w">         </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">bits</span>: <span class="nc">bits</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="o">|</span><span class="w">                      </span><span class="o">^^^^</span><span class="w"> </span><span class="n">expected</span><span class="w"> </span><span class="err">`</span><span class="p">((</span><span class="n">E</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">L</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">64</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">64</span><span class="err">`</span><span class="p">,</span><span class="w"> </span><span class="n">found</span><span class="w"> </span><span class="err">`</span><span class="bp">Self</span>::<span class="n">K</span><span class="err">`</span><span class="w"></span>
<span class="w">   </span><span class="o">|</span><span class="w"></span>
<span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">note</span>: <span class="nc">expected</span><span class="w"> </span><span class="k">type</span> <span class="err">`</span><span class="p">((</span><span class="n">E</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">L</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">64</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">64</span><span class="err">`</span><span class="w"></span>
<span class="w">              </span><span class="n">found</span><span class="w"> </span><span class="k">type</span> <span class="err">`</span><span class="bp">Self</span>::<span class="n">K</span><span class="err">`</span><span class="w"></span>

<span class="n">error</span>: <span class="nc">unconstrained</span><span class="w"> </span><span class="n">generic</span><span class="w"> </span><span class="n">constant</span><span class="w"></span>
<span class="w">  </span><span class="o">-</span>-&gt; <span class="nc">src</span><span class="o">/</span><span class="n">symbolics</span><span class="p">.</span><span class="n">rs</span>:<span class="mi">70</span>:<span class="mi">19</span><span class="w"></span>
<span class="w">   </span><span class="o">|</span><span class="w"></span>
<span class="mi">70</span><span class="w"> </span><span class="o">|</span><span class="w">         </span><span class="kd">let</span><span class="w"> </span><span class="n">bits</span>: <span class="p">[</span><span class="kt">u64</span><span class="p">;</span><span class="w"> </span><span class="bp">Self</span>::<span class="n">K</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="bp">Self</span>::<span class="n">K</span><span class="p">];</span><span class="w"></span>
<span class="w">   </span><span class="o">|</span><span class="w">                   </span><span class="o">^^^^^^^^^^^^^^</span><span class="w"></span>
<span class="w">   </span><span class="o">|</span><span class="w"></span>
<span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">help</span>: <span class="nc">try</span><span class="w"> </span><span class="n">adding</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="err">`</span><span class="k">where</span><span class="err">`</span><span class="w"> </span><span class="n">bound</span><span class="w"> </span><span class="n">using</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">expression</span>: <span class="err">`</span><span class="k">where</span><span class="w"> </span><span class="p">[();</span><span class="w"> </span><span class="bp">Self</span>::<span class="n">K</span><span class="p">]</span>:<span class="err">`</span><span class="w"></span>

<span class="n">error</span>: <span class="nc">unconstrained</span><span class="w"> </span><span class="n">generic</span><span class="w"> </span><span class="n">constant</span><span class="w"></span>
<span class="w">  </span><span class="o">-</span>-&gt; <span class="nc">src</span><span class="o">/</span><span class="n">symbolics</span><span class="p">.</span><span class="n">rs</span>:<span class="mi">70</span>:<span class="mi">40</span><span class="w"></span>
<span class="w">   </span><span class="o">|</span><span class="w"></span>
<span class="mi">70</span><span class="w"> </span><span class="o">|</span><span class="w">         </span><span class="kd">let</span><span class="w"> </span><span class="n">bits</span>: <span class="p">[</span><span class="kt">u64</span><span class="p">;</span><span class="w"> </span><span class="bp">Self</span>::<span class="n">K</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="bp">Self</span>::<span class="n">K</span><span class="p">];</span><span class="w"></span>
<span class="w">   </span><span class="o">|</span><span class="w">                                        </span><span class="o">^^^^^^^</span><span class="w"></span>
<span class="w">   </span><span class="o">|</span><span class="w"></span>
<span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">help</span>: <span class="nc">try</span><span class="w"> </span><span class="n">adding</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="err">`</span><span class="k">where</span><span class="err">`</span><span class="w"> </span><span class="n">bound</span><span class="w"> </span><span class="n">using</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">expression</span>: <span class="err">`</span><span class="k">where</span><span class="w"> </span><span class="p">[();</span><span class="w"> </span><span class="bp">Self</span>::<span class="n">K</span><span class="p">]</span>:<span class="err">`</span><span class="w"></span>
</code></pre></div>



<a name="269067113"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/260443-project-const-generics/topic/Workaround%20for%20E0401/near/269067113" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> lcnr <a href="https://zulip-archive.rust-lang.org/stream/260443-project-const-generics/topic/Workaround.20for.20E0401.html#269067113">(Jan 24 2022 at 07:18)</a>:</h4>
<p>ah right, we don't look into associated constants rn '^^</p>



<a name="269067146"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/260443-project-const-generics/topic/Workaround%20for%20E0401/near/269067146" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> lcnr <a href="https://zulip-archive.rust-lang.org/stream/260443-project-const-generics/topic/Workaround.20for.20E0401.html#269067146">(Jan 24 2022 at 07:19)</a>:</h4>
<p>using the following associated type should work <span aria-label="thinking" class="emoji emoji-1f914" role="img" title="thinking">:thinking:</span> </p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">type</span> <span class="nc">Bits</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">L</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">E</span>: <span class="kt">usize</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="p">[</span><span class="kt">u64</span><span class="p">;</span><span class="w"> </span><span class="p">((</span><span class="n">E</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">L</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">64</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">64</span><span class="p">];</span><span class="w"></span>
</code></pre></div>



<a name="269067220"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/260443-project-const-generics/topic/Workaround%20for%20E0401/near/269067220" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Delicious Scheme <a href="https://zulip-archive.rust-lang.org/stream/260443-project-const-generics/topic/Workaround.20for.20E0401.html#269067220">(Jan 24 2022 at 07:20)</a>:</h4>
<p>Sorry, I am new to Rust. How exactly can I use that?</p>



<a name="269067811"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/260443-project-const-generics/topic/Workaround%20for%20E0401/near/269067811" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> lcnr <a href="https://zulip-archive.rust-lang.org/stream/260443-project-const-generics/topic/Workaround.20for.20E0401.html#269067811">(Jan 24 2022 at 07:31)</a>:</h4>
<p>that also doesn't work :( thought of something like</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="cp">#![feature(generic_const_exprs)]</span><span class="w"></span>

<span class="k">type</span> <span class="nc">Bits</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">L</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">E</span>: <span class="kt">usize</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="p">[</span><span class="kt">u64</span><span class="p">;</span><span class="w"> </span><span class="p">((</span><span class="n">E</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">L</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">64</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">64</span><span class="p">];</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">PackedMonomial</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">L</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">E</span>: <span class="kt">usize</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">where</span><span class="w"></span>
<span class="w">    </span><span class="n">Bits</span><span class="o">&lt;</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">E</span><span class="o">&gt;</span>: <span class="nb">Sized</span><span class="p">,</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">bits</span>: <span class="nc">Bits</span><span class="o">&lt;</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">E</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">array_zero</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">N</span>: <span class="kt">usize</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="p">[</span><span class="kt">u64</span><span class="p">;</span><span class="w"> </span><span class="n">N</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">N</span><span class="p">]</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">L</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">E</span>: <span class="kt">usize</span><span class="o">&gt;</span><span class="w"> </span><span class="n">PackedMonomial</span><span class="o">&lt;</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">E</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">where</span><span class="w"></span>
<span class="w">    </span><span class="n">Bits</span><span class="o">&lt;</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">E</span><span class="o">&gt;</span>: <span class="nb">Sized</span><span class="p">,</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">bits</span>: <span class="nc">Bits</span><span class="o">&lt;</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">E</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">array_zero</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">bits</span>: <span class="nc">bits</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>



<a name="269067820"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/260443-project-const-generics/topic/Workaround%20for%20E0401/near/269067820" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> lcnr <a href="https://zulip-archive.rust-lang.org/stream/260443-project-const-generics/topic/Workaround.20for.20E0401.html#269067820">(Jan 24 2022 at 07:31)</a>:</h4>
<p>but that doesn't work because of the way we treat type aliases rn</p>



<a name="269067911"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/260443-project-const-generics/topic/Workaround%20for%20E0401/near/269067911" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> lcnr <a href="https://zulip-archive.rust-lang.org/stream/260443-project-const-generics/topic/Workaround.20for.20E0401.html#269067911">(Jan 24 2022 at 07:32)</a>:</h4>
<p>that means i don't think there exists a good solution for this rn, though you will definitely be able to deal with that once <code>generic_const_exprs</code> is stable. There's a reason it is currently still an incomplete feature</p>



<a name="269067920"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/260443-project-const-generics/topic/Workaround%20for%20E0401/near/269067920" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Delicious Scheme <a href="https://zulip-archive.rust-lang.org/stream/260443-project-const-generics/topic/Workaround.20for.20E0401.html#269067920">(Jan 24 2022 at 07:32)</a>:</h4>
<p>This worked!!!</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">type</span> <span class="nc">Bits</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">L</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">E</span>: <span class="kt">usize</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="p">[</span><span class="kt">u64</span><span class="p">;</span><span class="w"> </span><span class="p">((</span><span class="n">E</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">L</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">64</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">64</span><span class="p">];</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">array_zero</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">N</span>: <span class="kt">usize</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="p">[</span><span class="kt">u64</span><span class="p">;</span><span class="w"> </span><span class="n">N</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">N</span><span class="p">]</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">PackedMonomial</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">L</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">E</span>: <span class="kt">usize</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">where</span><span class="w"></span>
<span class="w">    </span><span class="p">[</span><span class="kt">u64</span><span class="p">;</span><span class="w"> </span><span class="p">((</span><span class="n">E</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">L</span><span class="o">+</span><span class="mi">64</span><span class="p">)</span><span class="o">/</span><span class="mi">64</span><span class="p">]</span>: <span class="nb">Sized</span><span class="p">,</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">bits</span>: <span class="nc">Bits</span><span class="o">&lt;</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">E</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">L</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">E</span>: <span class="kt">usize</span><span class="o">&gt;</span><span class="w"> </span><span class="n">PackedMonomial</span><span class="o">&lt;</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">E</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">where</span><span class="w"></span>
<span class="w">    </span><span class="p">[</span><span class="kt">u64</span><span class="p">;</span><span class="w"> </span><span class="p">((</span><span class="n">E</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">L</span><span class="o">+</span><span class="mi">64</span><span class="p">)</span><span class="o">/</span><span class="mi">64</span><span class="p">]</span>: <span class="nb">Sized</span><span class="p">,</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">K</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="p">(((</span><span class="n">E</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">L</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">64</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">64</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">bits</span>: <span class="nc">Bits</span><span class="o">&lt;</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">E</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">array_zero</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">bits</span>: <span class="nc">bits</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>Thanks a lot for your help!</p>



<a name="269067970"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/260443-project-const-generics/topic/Workaround%20for%20E0401/near/269067970" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> lcnr <a href="https://zulip-archive.rust-lang.org/stream/260443-project-const-generics/topic/Workaround.20for.20E0401.html#269067970">(Jan 24 2022 at 07:33)</a>:</h4>
<p>i would probably recommend</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="cp">#![feature(generic_const_exprs)]</span><span class="w"></span>

<span class="fm">macro_rules!</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">()</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">((</span><span class="n">E</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">L</span><span class="o">+</span><span class="mi">64</span><span class="p">)</span><span class="o">/</span><span class="mi">64</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">PackedMonomial</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">L</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">E</span>: <span class="kt">usize</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">where</span><span class="w"></span>
<span class="w">    </span><span class="p">[</span><span class="kt">u64</span><span class="p">;</span><span class="w"> </span><span class="n">len</span><span class="o">!</span><span class="p">()]</span>: <span class="nb">Sized</span><span class="p">,</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">bits</span>: <span class="p">[</span><span class="kt">u64</span><span class="p">;</span><span class="w"> </span><span class="n">len</span><span class="o">!</span><span class="p">()],</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">L</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">E</span>: <span class="kt">usize</span><span class="o">&gt;</span><span class="w"> </span><span class="n">PackedMonomial</span><span class="o">&lt;</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">E</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">where</span><span class="w"></span>
<span class="w">    </span><span class="p">[</span><span class="kt">u64</span><span class="p">;</span><span class="w"> </span><span class="n">len</span><span class="o">!</span><span class="p">()]</span>: <span class="nb">Sized</span><span class="p">,</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">bits</span>: <span class="p">[</span><span class="kt">u64</span><span class="p">;</span><span class="w"> </span><span class="n">len</span><span class="o">!</span><span class="p">()]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">len</span><span class="o">!</span><span class="p">()];</span><span class="w"></span>
<span class="w">        </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">bits</span>: <span class="nc">bits</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>for now</p>



<a name="269068034"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/260443-project-const-generics/topic/Workaround%20for%20E0401/near/269068034" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Delicious Scheme <a href="https://zulip-archive.rust-lang.org/stream/260443-project-const-generics/topic/Workaround.20for.20E0401.html#269068034">(Jan 24 2022 at 07:34)</a>:</h4>
<p>hahahahaha, cool beans</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>