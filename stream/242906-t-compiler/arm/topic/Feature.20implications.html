<html>
<head><meta charset="utf-8"><title>Feature implications · t-compiler/arm · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://zulip-archive.rust-lang.org/stream/242906-t-compiler/arm/index.html">t-compiler/arm</a></h2>
<h3>Topic: <a href="https://zulip-archive.rust-lang.org/stream/242906-t-compiler/arm/topic/Feature.20implications.html">Feature implications</a></h3>

<hr>

<base href="https://rust-lang.zulipchat.com">

<head><link href="https://zulip-archive.rust-lang.org/style.css" rel="stylesheet"></head>

<a name="276460339"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/242906-t-compiler/arm/topic/Feature%20implications/near/276460339" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jacob Bramley <a href="https://zulip-archive.rust-lang.org/stream/242906-t-compiler/arm/topic/Feature.20implications.html#276460339">(Mar 24 2022 at 11:13)</a>:</h4>
<p><span class="user-mention" data-user-id="120518">@Eric Huss</span>  <span class="user-mention" data-user-id="281757">@Jubilee</span> Regarding <a href="https://github.com/rust-lang/reference/pull/1184">#1184</a>:<br>
Thanks for <a href="https://github.com/rust-lang/rust/pull/91608#issuecomment-1076821903">tagging</a> <span class="user-mention" data-user-id="382356">@Adam Gemmell</span>, but in case you were waiting for a response, note that he's on leave until next week.<br>
In the interest of clarity, and making sure that we all have the same understanding, I want to make clear that the feature implications in <a href="https://github.com/rust-lang/reference/pull/1184/files#diff-11f03f772eabdb1a762b90f1ce58afd34c7938b20beae226e451da44d4fcd73a">the table that #1184 updates</a> are just those that LLVM applies itself. That means, for example, that "dotprod" doesn't imply "neon", even though architecturally it doesn't make sense without it. (I can invoke at least the old version of Clang I have to hand with <code>-march=armv8-a+nosimd+dotprod</code>, for example.)</p>
<p>The LLVM implication behaviour is also duplicated in <a href="https://github.com/rust-lang/stdarch/blob/master/crates/std_detect/src/detect/os/linux/aarch64.rs#L206">std_detect</a>. Note that <a href="https://github.com/rust-lang/stdarch/blob/master/crates/std_detect/src/detect/os/linux/aarch64.rs#L217">std_detect itself does still expose "fp"</a>. My instinct is that that's correct at that level, but you <a href="https://github.com/rust-lang/rust/pull/91608/files#diff-36d95266eaed8a01edd4caaf54210bd5e3ae8a22b72fb49067e562557c3a3c3e">removed a test for it</a> so perhaps I've misunderstood the intention.</p>



<a name="276507116"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/242906-t-compiler/arm/topic/Feature%20implications/near/276507116" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/242906-t-compiler/arm/topic/Feature.20implications.html#276507116">(Mar 24 2022 at 16:59)</a>:</h4>
<p>Eh, I just viewed the line in the test as irrelevant (...and was perhaps overenthusiastically stomping out instances of "fp" after having the PR bounce on missing a few). I drafted a PR for removing +fp from std_detect proper but I am not sure if I should actually open it for yeah, basically that reason: it's technically still valid to query the OS for.</p>
<p>Noted re: the implications being LLVM's. I think we should probably bring most of that hierarchical logic into Rust on our side.</p>



<a name="276611207"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/242906-t-compiler/arm/topic/Feature%20implications/near/276611207" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jacob Bramley <a href="https://zulip-archive.rust-lang.org/stream/242906-t-compiler/arm/topic/Feature.20implications.html#276611207">(Mar 25 2022 at 12:29)</a>:</h4>
<p>The problem, and the reason that we (really Adam) didn't do that, is that LLVM's inferences are incomplete. My thinking was that bringing that logic into Rust, with the objective of matching LLVM, would mean that we'd have to then stay in sync with LLVM updates. The next intuitive thought is to complete those inferences in Rust, so that we decouple this from LLVM's policy. However, that's harder than it sounds.</p>
<p>I'm not aware of an official (architectural) feature inference graph, at least not all in once place, and even if someone extracts it from the architecture reference manual, we have to cope with the OS hiding features that it doesn't want to support. We could probably do _obvious_ cases, like making <code>dotprod</code> imply <code>neon</code> (since it uses NEON registers and generally _looks_ like NEON instructions) but they're open to interpretation, which makes them hard to validate. They're also an ongoing maintenance burden, as the features are quite fine-grained.</p>



<a name="276611248"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/242906-t-compiler/arm/topic/Feature%20implications/near/276611248" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jacob Bramley <a href="https://zulip-archive.rust-lang.org/stream/242906-t-compiler/arm/topic/Feature.20implications.html#276611248">(Mar 25 2022 at 12:29)</a>:</h4>
<p>I suppose the question is, how far do you think we should go with feature inference in Rust, and how valuable is it to have that in the front end?</p>
<p>I must admit that I just thought that since no-one else does it (much), Rust probably doesn't need to either, but some level of inference could be really nice from a user perspective.</p>



<a name="276653026"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/242906-t-compiler/arm/topic/Feature%20implications/near/276653026" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/242906-t-compiler/arm/topic/Feature.20implications.html#276653026">(Mar 25 2022 at 17:28)</a>:</h4>
<p>Hmm. And LLVM does not have as strict a stability process.<br>
We might want to strike the entire implications column until we have an actually worked story for that.</p>



<a name="276679355"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/242906-t-compiler/arm/topic/Feature%20implications/near/276679355" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/242906-t-compiler/arm/topic/Feature.20implications.html#276679355">(Mar 25 2022 at 21:11)</a>:</h4>
<blockquote>
<p>I'm not aware of an official (architectural) feature inference graph, at least not all in once place, and even if someone extracts it from the architecture reference manual, we have to cope with the OS hiding features that it doesn't want to support.</p>
</blockquote>
<p>Yes, I asserted we should link Neon and FP and call them one feature mostly because they have a "static dependency" via being controlled by the same hardware in AArch64 mode (and thus they are the same feature level), and in the Arm docs:</p>
<blockquote>
<p>This field must have the same value as the AdvSIMD field.<br>
This field must have the same value as the FP field.</p>
</blockquote>



<a name="276679442"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/242906-t-compiler/arm/topic/Feature%20implications/near/276679442" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/242906-t-compiler/arm/topic/Feature.20implications.html#276679442">(Mar 25 2022 at 21:12)</a>:</h4>
<p>Though FP16 doesn't have a way to express support for it that doesn't also include FP and ASIMD, so we can keep "+fp16 is +neon".</p>



<a name="276681287"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/242906-t-compiler/arm/topic/Feature%20implications/near/276681287" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/242906-t-compiler/arm/topic/Feature.20implications.html#276681287">(Mar 25 2022 at 21:33)</a>:</h4>
<p>Looking at the way the registers ought to work...<br>
JSCVT mandates Neon also (and is mandated by Neon + v8.3).<br>
FCMA mandates Neon (and is mandated by Neon + v8.3).<br>
So jsconv and fcma actually should imply each other, if we're permitted to reason by versioning.<br>
SHA3 mandates SHA2 mandates SHA1.</p>



<a name="276742496"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/242906-t-compiler/arm/topic/Feature%20implications/near/276742496" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/242906-t-compiler/arm/topic/Feature.20implications.html#276742496">(Mar 26 2022 at 19:48)</a>:</h4>
<p>Looks like FHM does in fact require FP16:</p>
<blockquote>
<p>If SVE or FEAT_FHM is implemented, FEAT_FP16 is implemented. From Armv8.4, if<br>
FEAT_FHM is not implemented, FEAT_FP16 is not implemented.</p>
</blockquote>



<a name="276743063"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/242906-t-compiler/arm/topic/Feature%20implications/near/276743063" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/242906-t-compiler/arm/topic/Feature.20implications.html#276743063">(Mar 26 2022 at 20:00)</a>:</h4>
<p>Yeah, after reviewing the std_detect code more closely, I believe that while we shouldn't consider it a core functionality of Rust, for the sake of completeness, if the OS exposes an answer to "is FP on or not?", even if the answer <strong>has</strong> to be the same as the answer to Neon (and FP16, if that's on), then it's fine to ask.</p>
<p>Looks like SVE should imply FEAT_FCMA as well, not just FEAT_FP16.</p>



<a name="276882992"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/242906-t-compiler/arm/topic/Feature%20implications/near/276882992" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jacob Bramley <a href="https://zulip-archive.rust-lang.org/stream/242906-t-compiler/arm/topic/Feature.20implications.html#276882992">(Mar 28 2022 at 14:40)</a>:</h4>
<p><span class="user-mention silent" data-user-id="281757">Jubilee</span> <a href="#narrow/stream/242906-t-compiler.2Farm/topic/Feature.20implications/near/276679442">said</a>:</p>
<blockquote>
<p>Though FP16 doesn't have a way to express support for it that doesn't also include FP and ASIMD, so we can keep "+fp16 is +neon".</p>
</blockquote>
<p>Right, well in the hardware it's a different value for the FP and NEON ID registers, so they're bound in exactly the same way as base FP and NEON. So architecturally, neon16 -&gt; neon, fp16 -&gt; fp and neon == fp (where "-&gt;" means "implies). From our perspective, with neon and fp merged, fp16 -&gt; neon.</p>



<a name="276884431"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/242906-t-compiler/arm/topic/Feature%20implications/near/276884431" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jacob Bramley <a href="https://zulip-archive.rust-lang.org/stream/242906-t-compiler/arm/topic/Feature.20implications.html#276884431">(Mar 28 2022 at 14:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="281757">Jubilee</span> <a href="#narrow/stream/242906-t-compiler.2Farm/topic/Feature.20implications/near/276681287">said</a>:</p>
<blockquote>
<p>Looking at the way the registers ought to work...<br>
JSCVT mandates Neon also (and is mandated by Neon + v8.3).<br>
FCMA mandates Neon (and is mandated by Neon + v8.3).<br>
So jsconv and fcma actually should imply each other, if we're permitted to reason by versioning.<br>
SHA3 mandates SHA2 mandates SHA1.</p>
</blockquote>
<p>That's more tricky... From the <a href="https://developer.arm.com/documentation/ddi0487/latest">Arm ARM</a>:</p>
<blockquote>
<p>An Armv8.x compliant implementation can include any arbitrary subset of the architectural features of Armv8.(x+1), subject only to those constraints that require that certain features be implemented together.</p>
</blockquote>
<p>In addition, there exist features that can be implemented earlier than one hop. Making inferences through Armv8.x releases is technically possible, but probably quite unwise! Not to mention that the OS may hide FCMA, but expose JSCVT (for some reason).</p>
<p>On the other hand, SHA3 -&gt; SHA2 -&gt; SHA1 is probably reasonable, and therein lies the problem: it's tempting, and easy to make inferences in simple cases, but very difficult to do it in general.</p>



<a name="276885718"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/242906-t-compiler/arm/topic/Feature%20implications/near/276885718" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jacob Bramley <a href="https://zulip-archive.rust-lang.org/stream/242906-t-compiler/arm/topic/Feature.20implications.html#276885718">(Mar 28 2022 at 14:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="281757">Jubilee</span> <a href="#narrow/stream/242906-t-compiler.2Farm/topic/Feature.20implications/near/276743063">said</a>:</p>
<blockquote>
<p>Looks like SVE should imply FEAT_FCMA as well, not just FEAT_FP16.</p>
</blockquote>
<p><code>FEAT_FCMA</code> is mandatory in Armv8.3, and adds some NEON (not scalable-vector) instructions.<br>
<code>FEAT_SVE</code> is optional in Armv8.2, and includes instructions like <code>fcadd</code> for SVE use, but these aren't dependent on <code>FEAT_FCMA</code>.<br>
If I understand it correctly, an Armv8.2 implementation can have <code>FEAT_SVE</code>, NEON, but no <code>FEAT_FCMA</code>, so the <code>fcadd</code> mnemonic is only available under SVE. I don't think there's any inference relationship between the two features.</p>



<a name="276926029"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/242906-t-compiler/arm/topic/Feature%20implications/near/276926029" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/242906-t-compiler/arm/topic/Feature.20implications.html#276926029">(Mar 28 2022 at 20:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="399135">Jacob Bramley</span> <a href="#narrow/stream/242906-t-compiler.2Farm/topic/Feature.20implications/near/276884431">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="281757">Jubilee</span> <a href="#narrow/stream/242906-t-compiler.2Farm/topic/Feature.20implications/near/276681287">said</a>:</p>
<blockquote>
<p>So jsconv and fcma actually should imply each other, if we're permitted to reason by versioning.</p>
</blockquote>
<p>That's more tricky... From the <a href="https://developer.arm.com/documentation/ddi0487/latest">Arm ARM</a>:</p>
<blockquote>
<p>An Armv8.x compliant implementation can include any arbitrary subset of the architectural features of Armv8.(x+1), subject only to those constraints that require that certain features be implemented together.<br>
</p>
</blockquote>
</blockquote>
<p>aha.</p>



<a name="276926165"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/242906-t-compiler/arm/topic/Feature%20implications/near/276926165" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/242906-t-compiler/arm/topic/Feature.20implications.html#276926165">(Mar 28 2022 at 20:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="399135">Jacob Bramley</span> <a href="#narrow/stream/242906-t-compiler.2Farm/topic/Feature.20implications/near/276885718">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="281757">Jubilee</span> <a href="#narrow/stream/242906-t-compiler.2Farm/topic/Feature.20implications/near/276743063">said</a>:</p>
<blockquote>
<p>Looks like SVE should imply FEAT_FCMA as well, not just FEAT_FP16.</p>
</blockquote>
<p><code>FEAT_FCMA</code> is mandatory in Armv8.3, and adds some NEON (not scalable-vector) instructions.<br>
<code>FEAT_SVE</code> is optional in Armv8.2, and includes instructions like <code>fcadd</code> for SVE use, but these aren't dependent on <code>FEAT_FCMA</code>.<br>
If I understand it correctly, an Armv8.2 implementation can have <code>FEAT_SVE</code>, NEON, but no <code>FEAT_FCMA</code>, so the <code>fcadd</code> mnemonic is only available under SVE. I don't think there's any inference relationship between the two features.</p>
</blockquote>
<p><code>FEAT_FCMA</code> is mandated by SVE, actually.</p>



<a name="276926353"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/242906-t-compiler/arm/topic/Feature%20implications/near/276926353" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/242906-t-compiler/arm/topic/Feature.20implications.html#276926353">(Mar 28 2022 at 20:21)</a>:</h4>
<p>"<code>FEAT_SVE</code> requires implementation of <code>FEAT_FP16</code> and <code>FEAT_FCMA</code>."</p>



<a name="276926471"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/242906-t-compiler/arm/topic/Feature%20implications/near/276926471" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/242906-t-compiler/arm/topic/Feature.20implications.html#276926471">(Mar 28 2022 at 20:22)</a>:</h4>
<blockquote>
<p>On the other hand, SHA3 -&gt; SHA2 -&gt; SHA1 is probably reasonable, and therein lies the problem: it's tempting, and easy to make inferences in simple cases, but very difficult to do it in general.</p>
</blockquote>
<p>Yeah the SHA flow is actually specified as part of the way those features are expressed in the registers and manual.</p>



<a name="276926702"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/242906-t-compiler/arm/topic/Feature%20implications/near/276926702" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/242906-t-compiler/arm/topic/Feature.20implications.html#276926702">(Mar 28 2022 at 20:24)</a>:</h4>
<p>So alright, no ability to reason via JSCVT &lt;-&gt; FCMA.</p>



<a name="276969359"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/242906-t-compiler/arm/topic/Feature%20implications/near/276969359" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jacob Bramley <a href="https://zulip-archive.rust-lang.org/stream/242906-t-compiler/arm/topic/Feature.20implications.html#276969359">(Mar 29 2022 at 07:52)</a>:</h4>
<p><span class="user-mention silent" data-user-id="281757">Jubilee</span> <a href="#narrow/stream/242906-t-compiler.2Farm/topic/Feature.20implications/near/276926353">said</a>:</p>
<blockquote>
<p>"<code>FEAT_SVE</code> requires implementation of <code>FEAT_FP16</code> and <code>FEAT_FCMA</code>."</p>
</blockquote>
<p>Ooh, there might be an inconsistency there. This statement (under ID_AA64ISAR1_EL1) seems incorrect: "In Armv8.0, Armv8.1, and Armv8.2, the only permitted value is 0b0000."<br>
I can't find the text you quoted but I can find words to the same effect in the <a href="https://developer.arm.com/documentation/ddi0584/ba/?lang=en">SVE supplement</a>.</p>



<a name="277388560"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/242906-t-compiler/arm/topic/Feature%20implications/near/277388560" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jacob Bramley <a href="https://zulip-archive.rust-lang.org/stream/242906-t-compiler/arm/topic/Feature.20implications.html#277388560">(Apr 01 2022 at 09:07)</a>:</h4>
<p>I think the point is that there's a set of obvious inferences we can make, and a set of obviously-questionable ones, but we probably need at least a heuristic for deciding whether or not to accept an inference that lies in the gap.<br>
(This is for <code>target_features</code>; the runtime detection shouldn't do any inference by default, though it might be a useful API helper.)</p>



<a name="277443115"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/242906-t-compiler/arm/topic/Feature%20implications/near/277443115" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/242906-t-compiler/arm/topic/Feature.20implications.html#277443115">(Apr 01 2022 at 16:22)</a>:</h4>
<p>Yeah, runtime can just look at the right value.</p>



<a name="277443254"></a>
<h4><a href="https://rust-lang.zulipchat.com#narrow/stream/242906-t-compiler/arm/topic/Feature%20implications/near/277443254" class="zl"><img src="https://zulip-archive.rust-lang.org/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jubilee <a href="https://zulip-archive.rust-lang.org/stream/242906-t-compiler/arm/topic/Feature.20implications.html#277443254">(Apr 01 2022 at 16:23)</a>:</h4>
<p>Especially since at least some platforms, as I understand it, just let you read the right registers, like you were privileged (catching your thread on the illegal privileged instruction use and then doing the actual read in privileged space, ofc).</p>



<hr><p>Last updated: Apr 12 2022 at 20:01 UTC</p>
</html>