[
    {
        "content": "<p>The propagate-rust-panic-through-native-frame.md feels inconsistent and/or unsound.</p>",
        "id": 178028440,
        "sender_full_name": "gnzlbg",
        "timestamp": 1570956945
    },
    {
        "content": "<p>IIUC, even in the minimum viable feature version, <code>extern \"C unwind\"</code> functions can be called by foreign code, and follow the C ABI with native unwinding</p>",
        "id": 178028486,
        "sender_full_name": "gnzlbg",
        "timestamp": 1570956991
    },
    {
        "content": "<p>If that is correct, that file saying that some of the behavior at the other side of the FFI is undefined can only be a consequence of the <code>extern \"C unwind\"</code> function not actually following the ABI that it says it follows, which would make them unsound since that ABI can be used in safe Rust code</p>",
        "id": 178028508,
        "sender_full_name": "gnzlbg",
        "timestamp": 1570957074
    },
    {
        "content": "<p>For example, that file says that unwinding into native code is UB</p>",
        "id": 178028553,
        "sender_full_name": "gnzlbg",
        "timestamp": 1570957099
    },
    {
        "content": "<p>while simultaneously saying that those functions can unwind</p>",
        "id": 178028556,
        "sender_full_name": "gnzlbg",
        "timestamp": 1570957114
    },
    {
        "content": "<p>If the function can unwind in the Rust side just fine, then whether that unwinding exhibits UB on the native code itself or not depends on what the native code semantics are</p>",
        "id": 178028631,
        "sender_full_name": "gnzlbg",
        "timestamp": 1570957212
    },
    {
        "content": "<p>For example, that file devotes most of its lines to C++, saying that unwinding frames without or with destructors is UB, catch blocks are UB, etc.</p>",
        "id": 178028641,
        "sender_full_name": "gnzlbg",
        "timestamp": 1570957257
    },
    {
        "content": "<p>But most C++ implementation says that a \"foreign\" unwind into it can be catched in <code>catch(...)</code> blocks just fine, re-thrown, guarantees that destructors run in a particular order when that happens, etc. (there are some things that C++ says are UB for foreign code, but the file does not mention them though).</p>",
        "id": 178028660,
        "sender_full_name": "gnzlbg",
        "timestamp": 1570957291
    },
    {
        "content": "<p>So the only way in which the behavior could then be undefined in C++ is if <code>extern \"C unwind\"</code> functions do not actually follow the ABI that they say they do</p>",
        "id": 178028740,
        "sender_full_name": "gnzlbg",
        "timestamp": 1570957387
    },
    {
        "content": "<p>The root of the problem here is that this file tries to specifies what the behavior of other programming languages are.</p>",
        "id": 178028796,
        "sender_full_name": "gnzlbg",
        "timestamp": 1570957454
    },
    {
        "content": "<p>That's not up to us.</p>",
        "id": 178028799,
        "sender_full_name": "gnzlbg",
        "timestamp": 1570957462
    },
    {
        "content": "<p>And is as meaningful as the C++ standard specifying that evaluating the expression <code>2 + 2</code> in Rust is UB.</p>",
        "id": 178028805,
        "sender_full_name": "gnzlbg",
        "timestamp": 1570957479
    },
    {
        "content": "<p>When a foreign exception unwinds into a programming language, most (all?) unwinding ABIs leave it up to the language how to handle it</p>",
        "id": 178028823,
        "sender_full_name": "gnzlbg",
        "timestamp": 1570957535
    },
    {
        "content": "<p>The language can just abort, or it can unwind, or do something else like assume that it doesn't happen</p>",
        "id": 178028829,
        "sender_full_name": "gnzlbg",
        "timestamp": 1570957549
    },
    {
        "content": "<p>Independently of what that does, Rust cannot specify what that is for other languages, much less guarantee anything about it (e.g. guarantee that it doesn't change)</p>",
        "id": 178028896,
        "sender_full_name": "gnzlbg",
        "timestamp": 1570957625
    },
    {
        "content": "<p>The only thing Rust can do is specify how foreign exceptions are handled in Rust, and well, it could also forbid <code>extern \"C unwind\"</code> functions from being called from a different language than Rust, but that doesn't seem very useful.</p>",
        "id": 178028956,
        "sender_full_name": "gnzlbg",
        "timestamp": 1570957692
    },
    {
        "content": "<p>Part of the specification of an unwinding mechanism _is_ what happens when code tries to interact with the exception object. The relevant implementation detail, I believe, is the personality function. I still need to spend some time researching how personality functions work, but it's my understanding that for C++ to be \"well behaved\" when trying to catch a Rust exception, there _is_ a burden on Rust to partially define that behavior.</p>",
        "id": 178117415,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571070282
    },
    {
        "content": "<p>And, of course, everything is \"undefined\" until we say otherwise, _even though_ in many cases we believe that the implementation should behave \"safely\".</p>",
        "id": 178117467,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571070342
    },
    {
        "content": "<p>Relatedly: I'm not sure I understand your last comment on the double-throw issue. You said something about defining the behavior of native (non-Rust) code when attempting to <code>throw</code> while a Rust <code>panic</code> is already in-flight; that actually does sound entirely out of Rust's hands to me, so I'm not sure why you think that's something Rust can define.</p>",
        "id": 178117546,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571070419
    },
    {
        "content": "<blockquote>\n<p>but it's my understanding that for C++ to be \"well behaved\" when trying to catch a Rust exception, there _is_ a burden on Rust to partially define that behavior.</p>\n</blockquote>\n<p>No, there isn't.</p>",
        "id": 178175892,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571132286
    },
    {
        "content": "<p>The I in ABI stands for \"interface\"</p>",
        "id": 178175898,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571132300
    },
    {
        "content": "<p>C++ doesn't care about the programming language the code it interfaces with is written in, as long as it properly implements the ABI</p>",
        "id": 178175916,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571132331
    },
    {
        "content": "<p>The only thing Rust needs to define is whether it exposes a feature to conform to that ABI or not</p>",
        "id": 178175966,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571132397
    },
    {
        "content": "<p>If Rust exposes such a feature other code that correctly conforms to the ABI \"just works\"</p>\n<p>If Rust doesn't expose such a feature, one cannot interface with code that uses such an ABI in Rust, and the behavior for code that tries to do that is undefined (we provide no guaranteed way for this to work).</p>",
        "id": 178176026,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571132431
    },
    {
        "content": "<p>The following two statements: \"Rust implements the ABI correctly\" and \"Calling code that conforms to the ABI is UB\" cannot be both true. The only way for the second statement to be true, is if the first statement is false.</p>",
        "id": 178176069,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571132476
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 178176213,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571132611
    },
    {
        "content": "<blockquote>\n<p>And, of course, everything is \"undefined\" until we say otherwise, _even though_ in many cases we believe that the implementation should behave \"safely\".</p>\n</blockquote>\n<p>This misses the point. The current proposal says \"The behavior is defined as both doing X and being undefined\".</p>",
        "id": 178176576,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571132967
    },
    {
        "content": "<p>That's an inconsistent specification.</p>",
        "id": 178176584,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571132984
    },
    {
        "content": "<blockquote>\n<p>I'm not sure I understand your last comment on the double-throw issue. </p>\n</blockquote>\n<p>Which comment?</p>\n<blockquote>\n<p>You said something about defining the behavior of native (non-Rust) code when attempting to throw while a Rust panic is already in-flight; </p>\n</blockquote>\n<p>I doubt I said that, since I was very clear that Rust cannot specify anything about how other languages should work. The only thing Rust can specify is how Rust works, and for this particular feature, whether Rust supports the ABI or not.</p>",
        "id": 178176906,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571133265
    },
    {
        "content": "<p>In particular, C++ already specifies what happens if an exception from any other programming language that conforms to the native ABI unwinds into C++, and that causes a double throw.</p>",
        "id": 178176930,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571133300
    },
    {
        "content": "<p>Saying something in Rust about how the code at the other side of the ABI should behave risks being a statement that Rust does not implement the ABI correctly.</p>",
        "id": 178177074,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571133463
    },
    {
        "content": "<p>Saying nothing would mean that as long as the C++ code doesn't triggern an error in the Rust and C++ abstract machines, everything is tight</p>",
        "id": 178177173,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571133552
    },
    {
        "content": "<p>While explicitly saying that behavior that's defined by the ABI is undefined means that we don't implement the ABI correctly</p>",
        "id": 178177258,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571133615
    },
    {
        "content": "<blockquote>\n<p>That's not up to us.</p>\n</blockquote>\n<p>Still catching up, but my thinking was this: there is some point at which the Rust panic propagates <em>out</em> from Rust -- at that point, we can say that it is UB. In particular, that we do not yet how the Rust panic will \"present itself\" on the other side.  Given that we haven't defined that, there is no way that the other language could intercept it in a stable, reliable fashion.</p>",
        "id": 178189556,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1571143987
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> IIUC the intent is to say that the panic is propagated with an ABI</p>",
        "id": 178190376,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571144566
    },
    {
        "content": "<p>The ABI spec must precisely say what that looks like, and all the common ones do.</p>",
        "id": 178190507,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571144643
    },
    {
        "content": "<p>If the ABI spec says, \"this looks like this, and you can do A, B, C with it\", but the Rust spec says \"we don't guarantee how this looks and doing A, B, and C is UB\" then Rust does not implement that ABI</p>",
        "id": 178190613,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571144702
    },
    {
        "content": "<p>It might implement a \"subset\" of the ABI, maybe?</p>",
        "id": 178190945,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571144934
    },
    {
        "content": "<p>MSVC doesn't actually have a fully stable ABI here. And the C++ standard says nothing about foreign exceptions.</p>",
        "id": 178192256,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571145839
    },
    {
        "content": "<p>MSVC doesn't, but the windows msvc targets do</p>",
        "id": 178193473,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571146588
    },
    {
        "content": "<p>As in, when MSVC compiles C++ exceptions, these exceptions are described as \"C++\" exceptions IIUC</p>",
        "id": 178193571,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571146662
    },
    {
        "content": "<p>So if you use two different incompatible MSVC toolchains to compile C++ code, and these code throws through the ABI</p>",
        "id": 178193627,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571146683
    },
    {
        "content": "<p>how the exception is propagated through the ABI is guaranteed to work</p>",
        "id": 178193651,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571146699
    },
    {
        "content": "<p>but since both pieces of code have different expectations of what a C++ exception is, things go wrong</p>",
        "id": 178193693,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571146723
    },
    {
        "content": "<p>....sort of. <a href=\"https://clang.llvm.org/docs/MSVCCompatibility.html\" target=\"_blank\" title=\"https://clang.llvm.org/docs/MSVCCompatibility.html\">https://clang.llvm.org/docs/MSVCCompatibility.html</a></p>",
        "id": 178193720,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571146740
    },
    {
        "content": "<p>This is the same thing that happens if Rust compiled with a different toolchain that's slightly incompatible interfaces with each other</p>",
        "id": 178193739,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571146754
    },
    {
        "content": "<p>Note that support for SEH is \"partial\"</p>",
        "id": 178193751,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571146762
    },
    {
        "content": "<p>The problem is that clang wants its exceptions to be C++ exceptions</p>",
        "id": 178193793,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571146792
    },
    {
        "content": "<p>as opposed to \"foreign\" exceptions</p>",
        "id": 178193801,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571146798
    },
    {
        "content": "<p>The C++ standard doesn't have a concept of \"foreign\" exceptions. So in that sense, their behavior is <em>already</em> \"undefined\" from a language spec point of view.</p>",
        "id": 178193916,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571146865
    },
    {
        "content": "<p>The C++ standard doesn't allow calls to C to unwind either</p>",
        "id": 178193948,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571146903
    },
    {
        "content": "<p>So if that's your argument, interfacing with C++ cannot ever work from Rust</p>",
        "id": 178193960,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571146916
    },
    {
        "content": "<p>I don't believe it explicitly says anything to that effect? Do you have a citation?</p>",
        "id": 178194030,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571146935
    },
    {
        "content": "<p>My point is that you seem to be discussing \"implementation defined\" behavior here.</p>",
        "id": 178194059,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571146967
    },
    {
        "content": "<p>I posted it in the original thread, <code>extern \"C\"</code> functions in C++ are not required to support unwinding</p>",
        "id": 178194067,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571146972
    },
    {
        "content": "<p>Which original thread? Could you please just post it again here?</p>",
        "id": 178194137,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571147008
    },
    {
        "content": "<p>The tracking issue with 500 comments that aren't shown by github and aren't searchable</p>",
        "id": 178194193,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571147042
    },
    {
        "content": "<p>If you call a C function, and C doesn't allow those functions to unwind</p>",
        "id": 178194236,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571147055
    },
    {
        "content": "<p>(nothing in the C standard says that's allowed)</p>",
        "id": 178194249,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571147063
    },
    {
        "content": "<p>How could the C++ standard say that C function calls can unwind ?</p>",
        "id": 178194267,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571147074
    },
    {
        "content": "<p>What could cause them to unwind?</p>",
        "id": 178194290,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571147088
    },
    {
        "content": "<p>Either way, the current proposal doesn't say that the behavior is implementation-defined</p>",
        "id": 178194514,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571147199
    },
    {
        "content": "<p>depending on what the ABI allows</p>",
        "id": 178194520,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571147203
    },
    {
        "content": "<p>it says that it is undefined, and if that's incompatible with the ABI, then such platform cannot IMO be reported as supporting the feature</p>",
        "id": 178194558,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571147223
    },
    {
        "content": "<p>Windows does support foreign exceptions as well</p>",
        "id": 178194585,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571147249
    },
    {
        "content": "<p>that's the mechanism that longjmp uses there, which isn't treated as a C++ exception</p>",
        "id": 178194604,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571147269
    },
    {
        "content": "<p><code>extern \"C\"</code> doesn't mean \"a function conforming to the C standard\" in either C++ or C. C++ must be able to invoke a C++ function that is defined in an <code>extern \"C\"</code> block, and C++ functions can unwind, so I don't believe the standard states or implies any connection between exceptions and linkage specification.</p>",
        "id": 178195417,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571147746
    },
    {
        "content": "<p>But I feel like we're a bit in the weeds here. When, in roadmap documents, RFCs, and the Reference, we say that something is \"undefined\", we mean it's not defined <em>by Rust</em> - yet.</p>",
        "id": 178195633,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571147875
    },
    {
        "content": "<p><a href=\"https://docs.microsoft.com/en-us/cpp/c-runtime-library/internal-crt-globals-and-functions?view=vs-2019\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/cpp/c-runtime-library/internal-crt-globals-and-functions?view=vs-2019\">https://docs.microsoft.com/en-us/cpp/c-runtime-library/internal-crt-globals-and-functions?view=vs-2019</a> shows how the C++ unwind ABI is evolved for the target (e.g. if you consider <code>__CxxFrameHandler</code>, there are now <code>__CxxFrameHandler2</code>, <code>__CxxFrameHandler3</code>, and the latest release has a new <code>__CxxFrameHandler4</code> API. The older symbols are still available, so can still be called, even when new functionality is added.</p>",
        "id": 178195710,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571147900
    },
    {
        "content": "<p>The point is not that rustc might somehow reach into C++ code and perform optimizations based on Rust's concept of UB.</p>",
        "id": 178195747,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571147929
    },
    {
        "content": "<blockquote>\n<p>extern \"C\" doesn't mean \"a function conforming to the C standard\" in either C++ or C. </p>\n</blockquote>\n<p>It does in C, which doesn't has a notion of unwinding.</p>",
        "id": 178195784,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571147954
    },
    {
        "content": "<p>Nothing in the C standard says that a function can unwind. The only similar thing offered is a longjmp.</p>",
        "id": 178195811,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571147982
    },
    {
        "content": "<p>?? C doesn't have <code>extern \"C\"</code></p>",
        "id": 178195817,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571147983
    },
    {
        "content": "<p>No, but it could call a C++ function that unwinds, and the behavior is undefined according to the standard, even with <code>-fexceptions</code></p>",
        "id": 178195909,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571148016
    },
    {
        "content": "<p>Once we are satisfied that the ABI is specified in an implementation-compatible way, then we can say that the behavior is \"implementation defined\"</p>",
        "id": 178195913,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571148017
    },
    {
        "content": "<p>Until then, we err on the side of caution, which is to say, \"undefined\"</p>",
        "id": 178195934,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571148033
    },
    {
        "content": "<p>So I read that as \"the behavior of <code>\"C unwind\"</code> is undefined if the function unwinds\"</p>",
        "id": 178195966,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571148058
    },
    {
        "content": "<p>that is, the compiler can assume that it does not happen</p>",
        "id": 178195987,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571148072
    },
    {
        "content": "<p>Users cannot write code that unwinds through those</p>",
        "id": 178196010,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571148086
    },
    {
        "content": "<p>It also does not implement the \"native ABI of the platform\" if the platform supports unwinding</p>",
        "id": 178196037,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571148112
    },
    {
        "content": "<p>That's why I added the bit about LLVM-UB. Yes, the behavior <em>is</em> undefined, but <em>even though we haven't yet specified it</em>, we don't want to let rustc optimize on the assumption that it can't happen.</p>",
        "id": 178196127,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571148142
    },
    {
        "content": "<p>Still, this feature would need a motivation for which problem it intends to solve.</p>",
        "id": 178196169,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571148169
    },
    {
        "content": "<p>With the current specification, it adds no value over <code>extern \"C\"</code></p>",
        "id": 178196185,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571148179
    },
    {
        "content": "<p>There is nothing valid that you can do with <code>\"C unwind\"</code> as proposed that cannot be done with <code>extern \"C\"</code></p>",
        "id": 178196226,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571148194
    },
    {
        "content": "<p>The intent, <em>for now</em>, is only to prohibit aborting and inserting <code>nounwind</code></p>",
        "id": 178196266,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571148215
    },
    {
        "content": "<p>But, yes, there is nothing defined-by-standardeze that can be done, <em>yet</em>.</p>",
        "id": 178196308,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571148241
    },
    {
        "content": "<p>By \"for now\", do you mean that this is going to be the intent of the RFC?</p>",
        "id": 178196357,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571148251
    },
    {
        "content": "<p>Yes. Part of the purpose of this WG is to permit providing <em>partial</em> guarantees as part of the full development of the feature.</p>",
        "id": 178196412,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571148298
    },
    {
        "content": "<p>I see.</p>",
        "id": 178196429,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571148305
    },
    {
        "content": "<p>It's ok to disagree then.</p>",
        "id": 178196482,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571148354
    },
    {
        "content": "<p>I don't think that an RFC that proposes a feature that adds no value can be reviewed.</p>",
        "id": 178196615,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571148439
    },
    {
        "content": "<p>It's impossible to know if the trade-offs the RFC makes are correct if the value it adds is zero, or unknown.</p>",
        "id": 178196639,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571148459
    },
    {
        "content": "<p>If you want to add an experimental ABI that doesn't have abort-on-panic shims, you don't need an RFC, just a PR to nightly with an FCP, or not even that.</p>",
        "id": 178196809,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571148544
    },
    {
        "content": "<p>The behavior of -fexceptions is undefined in a formal language-spec sense; do you not see value in that feature?</p>",
        "id": 178196835,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571148553
    },
    {
        "content": "<p>The toolchain defines its behavior to something useful.</p>",
        "id": 178196849,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571148569
    },
    {
        "content": "<p>So its undefined in C, but defined in GCC-C on Linux</p>",
        "id": 178196860,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571148582
    },
    {
        "content": "<p>Exactly. We want rustc to define the behavior here, to the extent that it can.</p>",
        "id": 178196892,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571148602
    },
    {
        "content": "<p>Rust currently doesn't have any feature like this</p>",
        "id": 178196944,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571148617
    },
    {
        "content": "<p>For similar features, the behavior is not specified as \"undefined\"</p>",
        "id": 178196955,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571148626
    },
    {
        "content": "<p>Indeed!</p>",
        "id": 178196957,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571148628
    },
    {
        "content": "<p>but as \"implementation-defined\"</p>",
        "id": 178196961,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571148630
    },
    {
        "content": "<p>and the sets of behaviors allowed is constrained by the RFC</p>",
        "id": 178196976,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571148641
    },
    {
        "content": "<p>It is possible that \"implementation defined\" is the best way to phrase this, but there was concern about this in RFC 2699, I think. One issue is that C++ formally defines the phrase \"implementation defined\", but as of right now, Rust does not.</p>",
        "id": 178197032,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571148680
    },
    {
        "content": "<p>We already have a lot of implementation-defined behavior in Rust</p>",
        "id": 178197119,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571148727
    },
    {
        "content": "<p>e.g. the size of an <code>usize</code></p>",
        "id": 178197126,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571148733
    },
    {
        "content": "<p>We also don't necessarily want to guarantee that all implementations must define this behavior.</p>",
        "id": 178197127,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571148733
    },
    {
        "content": "<p>So say that?</p>",
        "id": 178197140,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571148740
    },
    {
        "content": "<p>I'm not sure that counts, at least, not in the same sense</p>",
        "id": 178197147,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571148749
    },
    {
        "content": "<p>Its the same thing.</p>",
        "id": 178197161,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571148756
    },
    {
        "content": "<p>You can say: \"C unwind\" is an ABI string that's only available on certain targets and that implements the platform C ABI with unwinding support (e.g. C + <code>-fexceptions</code>), when such an ABI exists.</p>",
        "id": 178197235,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571148801
    },
    {
        "content": "<p><code>usize</code> refers to a basic concept that must exist on every platform, by definition</p>",
        "id": 178197252,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571148810
    },
    {
        "content": "<p>If you try to use an ABI string on a target that doesn't support it, you get a compiler-error already</p>",
        "id": 178197257,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571148816
    },
    {
        "content": "<p>Every Rust compiler is already required to diagnose that</p>",
        "id": 178197262,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571148824
    },
    {
        "content": "<p>After such a definition like the above, you can go on and say whatever might make sense for what happens when such functions unwind into Rust.</p>",
        "id": 178197565,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571149023
    },
    {
        "content": "<p>What I don't think makes much sense is to say that if a <code>\"C unwind\"</code> function unwinds, the behavior is undefined, because that means that, as proposed, such a feature does not add any value over <code>extern \"C\"</code></p>",
        "id": 178197696,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571149091
    },
    {
        "content": "<p>What you propose of only allowing those functions to unwind through <code>Copy</code> frames seems a very reasonable first step that adds a lot of value.</p>",
        "id": 178197769,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571149157
    },
    {
        "content": "<p>And has none of the complications of double-panics.</p>",
        "id": 178197792,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571149179
    },
    {
        "content": "<p>It also means that Rust panics can unwind out of Rust through that ABI, where they might do \"whatever\".</p>",
        "id": 178197891,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571149223
    },
    {
        "content": "<p>On Itanium when unwinding into C++, C++ code can catch them, rethrow them, etc.</p>",
        "id": 178197931,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571149247
    },
    {
        "content": "<p>On windows, C++ might or might not be able to do that. That's something for the C++ implementation of the platform to say.</p>",
        "id": 178198025,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571149310
    },
    {
        "content": "<p>OK, there are a lot of comments here, and it would be good to review them, but I still don't understand your original point, <span class=\"user-mention\" data-user-id=\"132920\">@gnzlbg</span> . It seems to me that we can say \"if a Rust panic occurs, we don't specify any details about how it is translated into  native terms\" and thus leave the behavior undefined at the point of crossing the boundary. I'm not expert on any of this stuff, but I'm sure every exception propagation mechanism has some kind of \"structure\" or way to specify metadata -- for example, the \"personality\" function or whatever -- and we are effectively saying that we have not defined this <em>yet</em>. Another way to look at it would be that <code>extern \"C unwind\"</code> as an ABI is simply not fully defined on any targets.</p>",
        "id": 178222624,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1571165365
    },
    {
        "content": "<blockquote>\n<p>What I don't think makes much sense is to say that if a <code>\"C unwind\"</code> function unwinds, the behavior is undefined, because that means that, as proposed, such a feature does not add any value over <code>extern \"C\"</code></p>\n</blockquote>\n<p>Is this your main point? This is true, but it is a temporary state of affairs, which is the whole point. =)</p>",
        "id": 178222886,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1571165528
    },
    {
        "content": "<blockquote>\n<p>It also means that Rust panics can unwind out of Rust through that ABI, where they might do \"whatever\".</p>\n</blockquote>\n<p>As an example of the sort of thing I would prefer we leave \"undefined\" for the moment, when I skim the <a href=\"https://llvm.org/docs/ExceptionHandling.html\" target=\"_blank\" title=\"https://llvm.org/docs/ExceptionHandling.html\">LLVM docs around exception handling</a>, they state:</p>\n<blockquote>\n<p>When execution resumes at a landing pad, it receives an exception structure and a selector value corresponding to the type of exception thrown. </p>\n</blockquote>\n<p>presumably we might not yet want to define much about the \"selector value\" we use for Rust panics</p>",
        "id": 178223073,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1571165648
    },
    {
        "content": "<blockquote>\n<p>OK, there are a lot of comments here, and it would be good to review them...</p>\n</blockquote>\n<p>I wonder if it would be good to start writing up summaries of longish discussions like this and putting them in the repo.</p>\n<p>In this case, I think the important points are all captured in comments on PR <a href=\"https://github.com/rust-lang/rust/issues/8\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/8\">#8</a> in the repo, but I don't know if <span class=\"user-mention\" data-user-id=\"132920\">@gnzlbg</span> would agree, necessarily.</p>",
        "id": 178223582,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571166010
    },
    {
        "content": "<blockquote>\n<p>It seems to me that we can say \"if a Rust panic occurs, we don't specify any details about how it is translated into native terms\" and thus leave the behavior undefined at the point of crossing the boundary.</p>\n</blockquote>\n<p>The translation from whatever mechanism Rust uses for unwinding is unspecified (because the Rust unwinding mechanism is unspecified), but this specifies that there is a translation to \"native terms\". How that translation happens doesn't matter. What matters is that those \"native terms\" are specified by the ABI spec.</p>",
        "id": 178223645,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571166027
    },
    {
        "content": "<p>Maybe I should ask: What are we trying to achieve by making this undefined behavior ?</p>",
        "id": 178223716,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571166083
    },
    {
        "content": "<blockquote>\n<p>presumably we might not yet want to define much about the \"selector value\" we use for Rust panics</p>\n</blockquote>\n<p>For example, the Itanium ABI says that there is a unique C string for every programming language (kind of)</p>",
        "id": 178223845,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571166169
    },
    {
        "content": "<blockquote>\n<p>Maybe I should ask: What are we trying to achieve by making this undefined behavior ?</p>\n</blockquote>\n<p>Perhaps the term \"undefined behavior\" is throwing you off. The point is that this behavior is not <strong>yet</strong> specified.</p>",
        "id": 178223887,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1571166204
    },
    {
        "content": "<p>We are trying to break the work into pieces</p>",
        "id": 178223889,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1571166210
    },
    {
        "content": "<p>We don't have to say which string we use for Rust (probably just \"Rust\"), but if we were to use \"C++\", then C++ code would be expecting our code to be precisely C++ exceptions.</p>",
        "id": 178223896,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571166213
    },
    {
        "content": "<p>This is a perfect example. The behavior is effectively unspecified at this time because we don't say what string it will be.</p>",
        "id": 178223970,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1571166248
    },
    {
        "content": "<p>So if you rely on that string to be a particular thing, you will have trouble.</p>",
        "id": 178223980,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1571166257
    },
    {
        "content": "<p>Saying that the behavior is currently \"undefined\" is a maximal version of this.</p>",
        "id": 178223997,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1571166267
    },
    {
        "content": "<p>You can rely on it not being \"C++\" though</p>",
        "id": 178224000,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571166270
    },
    {
        "content": "<p>No, you cannot</p>",
        "id": 178224004,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1571166274
    },
    {
        "content": "<p>Because we didn't say :)</p>",
        "id": 178224007,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1571166278
    },
    {
        "content": "<p>Then we don't implement the ABI spec :D</p>",
        "id": 178224014,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571166286
    },
    {
        "content": "<p>That's what I'm saying?</p>",
        "id": 178224022,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1571166295
    },
    {
        "content": "<p>Because it says we can only use \"C++\" if we implement \"C++\"</p>",
        "id": 178224023,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571166296
    },
    {
        "content": "<p>I thought you were also saying that \"C unwind\" implements the native ABI</p>",
        "id": 178224050,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571166320
    },
    {
        "content": "<p>I'm saying that it's intention is to implement the native ABI, yes, but that its' behavior on any given platform is not yet fully defined -- and that we will take it platform by platform, but until your platform has a <span aria-label=\"check mark\" class=\"emoji emoji-2714\" role=\"img\" title=\"check mark\">:check_mark:</span> you can expect that details may change</p>",
        "id": 178224094,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1571166360
    },
    {
        "content": "<p>By undefined behavior I also understand that we make no guarantees. What I'm not 100% sure is where the documents say \"undefined behavior\" means that the RFC for this feature will say that, and therefore, no guarantees is part of the initial version of this feature. Or that we will define that behavior before that first RFC.</p>",
        "id": 178224199,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571166416
    },
    {
        "content": "<p>If it's the second, I'd prefer to use TBD or similar</p>",
        "id": 178224213,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571166427
    },
    {
        "content": "<p>The latter, and TBD is perfectly fine</p>",
        "id": 178224223,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1571166436
    },
    {
        "content": "<p>I find \"not yet specified\" also relatively clear</p>",
        "id": 178224235,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1571166445
    },
    {
        "content": "<p>I also think RFC is not a relevant thing here</p>",
        "id": 178224247,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1571166458
    },
    {
        "content": "<p>Like, RFCs are always an initial design in any case, and changes can and do happen</p>",
        "id": 178224317,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1571166492
    },
    {
        "content": "<p>Maybe the more pertinent question is, \"how much specification constitutes an MVP?\"</p>",
        "id": 178224336,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571166510
    },
    {
        "content": "<p>Sure, but for an RFC it is kind of important to know what problems the feature solve</p>",
        "id": 178224339,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571166514
    },
    {
        "content": "<p>Yeah, I think that's something that we should all agree first</p>",
        "id": 178224349,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571166523
    },
    {
        "content": "<p>Yes. And the problem that the feature solves is that <code>extern \"C\"</code> is undefined behavior <strong>and expected to remain so</strong> -- and hence we may start to actively abort execution etc. <code>extern \"C unwind\"</code> is <strong>not</strong> expected to remain so</p>",
        "id": 178224390,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1571166554
    },
    {
        "content": "<blockquote>\n<p>Sure, but for an RFC it is kind of important to know what problems the feature solve</p>\n</blockquote>\n<p>I appreciate your concerns about stability/well-defined-ness, but I'm always a bit confused when you say something like this, because it seems to imply that the motivations for the feature are not well understood; from my perspective, they seem pretty well established.</p>",
        "id": 178224411,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571166573
    },
    {
        "content": "<p>I too feel a bit confused about what is confusing :)</p>",
        "id": 178224443,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1571166598
    },
    {
        "content": "<p>Regardless, this all seems pretty moot</p>",
        "id": 178224507,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1571166616
    },
    {
        "content": "<p>Are you distinguishing between \"problems the feature solve\" and \"motivating use-cases for this feature\"? If so, I don't understand the distinction</p>",
        "id": 178224508,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571166616
    },
    {
        "content": "<blockquote>\n<p>Yes. And the problem that the feature solves is that extern \"C\" is undefined behavior and expected to remain so -- and hence we may start to actively abort execution etc. extern \"C unwind\" is not expected to remain so</p>\n</blockquote>\n<p>That makes sense. I'm just skeptic of \"placeholder language features\"</p>",
        "id": 178224512,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571166618
    },
    {
        "content": "<p>whose semantics are to be defined later</p>",
        "id": 178224533,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571166624
    },
    {
        "content": "<p>(In the sense that -- for the time being -- I would expect \"C unwind\" to be nightly only until we stabilize it.)</p>",
        "id": 178224545,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1571166634
    },
    {
        "content": "<p>For this kind of work, we can just add the ABI string, and remove nounwind, and that will work on nightly</p>",
        "id": 178224582,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571166657
    },
    {
        "content": "<p>That would usually not even require an FCP</p>",
        "id": 178224597,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571166667
    },
    {
        "content": "<p>The point of the RFC is basically to <strong>commit to the design work</strong></p>",
        "id": 178224641,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1571166691
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"132920\">@gnzlbg</span> It's my understanding that \"undefined behavior\" was originally (i.e. in the ANSII C standard) used in precisely the sense of \"placeholder language features\", at least in some cases! So in a sense using it that way is a return to the term's roots :D</p>",
        "id": 178224647,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571166699
    },
    {
        "content": "<p>So my confusion is that I view this as the actual guarantees that such a stable feature would offer</p>",
        "id": 178224650,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571166703
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> </p>\n<blockquote>\n<p>The point of the RFC is basically to commit to the design work</p>\n</blockquote>\n<p>So that sounds like an eRFC to me.</p>",
        "id": 178224737,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571166740
    },
    {
        "content": "<p>Some general design direction, and the actual semantics will be nailed down down the road</p>",
        "id": 178224774,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571166767
    },
    {
        "content": "<p>We are designing a new process that replaces eRFCs, yes</p>",
        "id": 178224792,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1571166777
    },
    {
        "content": "<blockquote>\n<p>Some general design direction, and the actual semantics will be nailed down down the road</p>\n</blockquote>\n<p>also the point of the table and repo is to show what \"the road\" is</p>",
        "id": 178224861,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1571166827
    },
    {
        "content": "<p>So for an eRFC saying that we want to pursue \"C unwind\" and land part of an implementation on nightly to gain experience, and that we don't know what the semantics would be, I think is completely reasonable</p>",
        "id": 178224943,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571166859
    },
    {
        "content": "<blockquote>\n<p>I wonder if it would be good to start writing up summaries of longish discussions like this and putting them in the repo.</p>\n</blockquote>\n<p>this seems very good btw</p>",
        "id": 178224960,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1571166873
    },
    {
        "content": "<p>what I've found I try to do in long-ish zulip conversations</p>",
        "id": 178224972,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1571166883
    },
    {
        "content": "<p>is to create hackmd documents on the fly</p>",
        "id": 178224983,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1571166886
    },
    {
        "content": "<p>(not saying that would necessarily have made sense here)</p>",
        "id": 178225001,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1571166898
    },
    {
        "content": "<p>I think another reason I was confused is because the repo does have an rfc document.</p>",
        "id": 178225025,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571166914
    },
    {
        "content": "<p>Anyway, <span class=\"user-mention\" data-user-id=\"132920\">@gnzlbg</span> it sounds like you might be well-postiioned to help in enumerating \"what would need to be defined for ecah platform\"</p>",
        "id": 178225044,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1571166924
    },
    {
        "content": "<p>I have a fork of the rfc document that provides the guarantees that I thought might be worth discussing for an MVP</p>",
        "id": 178225073,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571166947
    },
    {
        "content": "<p>sounds good -- I am certainly game to provide more guarantees than \"none\", though I don't really think it should hold up the intial RFC</p>",
        "id": 178225177,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1571166994
    },
    {
        "content": "<p>basically I'd like us to reach agreement on \"small things\" first</p>",
        "id": 178225194,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1571167004
    },
    {
        "content": "<p>which can include what we will reach agreement on <em>later</em></p>",
        "id": 178225199,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1571167009
    },
    {
        "content": "<p>Maybe I can split that in different documents, where we collect motivating examples, constraints on the design, etc. that can be later on after discussion and consensus be put in an RFC, or at least used to show where do we want to end</p>",
        "id": 178225205,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571167014
    },
    {
        "content": "<blockquote>\n<p>I think another reason I was confused is because the repo does have an rfc document.</p>\n</blockquote>\n<p>That's fair. To be honest I haven't even looked at that other than to note that the \"summary\" was something Niko, Adam, and I drafted together</p>",
        "id": 178225212,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571167018
    },
    {
        "content": "<p>I think the rest is just copied from the old RFC, and should be deleted</p>",
        "id": 178225240,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1571167031
    },
    {
        "content": "<p>I think we probably want to land an implementation before the actual RFC here, to get a feeling for the actual details</p>",
        "id": 178225396,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571167114
    },
    {
        "content": "<p>Yep!</p>",
        "id": 178225443,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1571167146
    },
    {
        "content": "<p>So it would probably better to start by getting lang team support for doing just that (all feature gated)</p>",
        "id": 178225459,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571167152
    },
    {
        "content": "<p>After that we will know much better what's easy to guarantee and what's harder than we expected.</p>",
        "id": 178225487,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571167177
    },
    {
        "content": "<p>So the point of the RFC (as indicated by the summarY) is basically:</p>\n<ul>\n<li>\n<p>we want to add this ABI string <br>\n    * there's lots of details to figure out still, we have more the \"high level idea\" at this point</p>\n</li>\n<li>\n<p>we create this group to figure out those details</p>\n</li>\n<li>we plan to be experimenting on nightly</li>\n<li>we may stabilize some aspects as we go (e.g., the ABI string, or certain platforms but not others)</li>\n</ul>",
        "id": 178225491,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1571167182
    },
    {
        "content": "<p>The goal maybe could be initially to implement something that <span class=\"user-mention\" data-user-id=\"237472\">@Adam C. Foltzer</span> could use</p>",
        "id": 178225502,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571167196
    },
    {
        "content": "<p>and then the next step (which is what we were working on) is to elaborate for ourselves the order of steps we plan to take</p>",
        "id": 178225583,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1571167233
    },
    {
        "content": "<p>so yeah I think working towards goals like that is exactly right</p>",
        "id": 178225587,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1571167240
    },
    {
        "content": "<blockquote>\n<p>So it would probably better to start by getting lang team support for doing just that (all feature gated)</p>\n</blockquote>\n<p>to be clear, the lang team is already basically on board with this plan :)</p>",
        "id": 178225643,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1571167279
    },
    {
        "content": "<blockquote>\n<p>we may stabilize some aspects as we go (e.g., the ABI string, or certain platforms but not others)</p>\n</blockquote>\n<p>So as long as these require a proper RFC this is fine with me.</p>",
        "id": 178225654,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571167286
    },
    {
        "content": "<p>I'm not sure what the procedural step is there</p>",
        "id": 178225721,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1571167302
    },
    {
        "content": "<p>it might be a full RFC, it might also be an FCP</p>",
        "id": 178225743,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1571167319
    },
    {
        "content": "<p>So maybe we could replace some used of \"undefined behavior\" with \"we don't know\" ?</p>",
        "id": 178225744,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571167320
    },
    {
        "content": "<p>\"not yet specified\"?</p>",
        "id": 178225809,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1571167332
    },
    {
        "content": "<p>\"to be determined\"?</p>",
        "id": 178225824,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1571167339
    },
    {
        "content": "<p>I'd be happy with either of those</p>",
        "id": 178225825,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1571167342
    },
    {
        "content": "<p>TBD sounds good to me as well</p>",
        "id": 178225850,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571167350
    },
    {
        "content": "<p>ok, let's use TBD</p>",
        "id": 178225905,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1571167370
    },
    {
        "content": "<p>where is that fork you mentioned, <span class=\"user-mention\" data-user-id=\"132920\">@gnzlbg</span> ?</p>",
        "id": 178225908,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1571167374
    },
    {
        "content": "<p>that differentiates from things we might explicitly not want to support, for things that we just haven't considered yet</p>",
        "id": 178225925,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571167389
    },
    {
        "content": "<p>I would sort of like to see this proceeding a bit like UCG (but with more \"confirmation\" steps than we've mansged so foar)</p>",
        "id": 178225942,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1571167399
    },
    {
        "content": "<p>i.e., we should have an \"in-progress spec\" per platform</p>",
        "id": 178225950,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1571167404
    },
    {
        "content": "<p><a href=\"https://github.com/gnzlbg/project-ffi-unwind\" target=\"_blank\" title=\"https://github.com/gnzlbg/project-ffi-unwind\">https://github.com/gnzlbg/project-ffi-unwind</a></p>",
        "id": 178225952,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571167405
    },
    {
        "content": "<p>where we can start with just notes <em>about</em> the platform</p>",
        "id": 178226046,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1571167445
    },
    {
        "content": "<p>what's UCG?</p>",
        "id": 178227381,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571168127
    },
    {
        "content": "<p>unsafe code guidelines</p>",
        "id": 178227675,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571168350
    },
    {
        "content": "<blockquote>\n<p>unsafe code guidelines</p>\n</blockquote>\n<p>Ah, thanks</p>",
        "id": 178231955,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571171291
    }
]