[
    {
        "content": "<p>Here is my \"current stance\" -- subject to change as ever. Something we didn't quite get into when considering the various options is \"what the choice says about Rust\" -- or maybe, what kind of coding we would ultimately recommend. It seems to me that a strong Rust value is that:</p>\n<ul>\n<li>idiomatic Rust code is portable by default, both across platforms but also across panic=unwind and panic=abort;</li>\n<li>but we offer the ability to maximally take advantage of your platform as well.</li>\n</ul>\n<p>To that end, no matter what proposal we wound up with, it seems like we would recommend that code authors:</p>\n<ul>\n<li>catch your C++-based exceptions in C++ land and convert them to error codes, so that you are portable across panic=abort and panic=unwind;</li>\n<li>only use longjmp or pthread-exit when there are no destructors, so that you are portable across platforms as well as panic=abort/unwind.</li>\n</ul>\n<p>I think that this implies to me that it might be beneficial to separate \"C\" and \"C unwind\". It means that you have to be a bit explicit when you're relying on something non-portable, but that's perhaps a good thing, and it lets us lint more effectively. It also means we can put shims that detect <em>all</em> non-forced-unwinding across a C boundary and abort, thus helping to detect portability hazards. We might want to limit those to debug-mode because they would make binaries somewhat bigger, though we also ought to measure that more carefully (it wasn't too hard to implement when I tried).</p>\n<p>I think I'll try to do a longer write-up, and also experiment a bit with what I see as the strongest argument the other way, but I was curious to write this one out. =)</p>\n<p>(I feel that the strongest argument the other way is one that speaks to Rust enabling smooth interop with native code, and the overall simplicity of the ABI story -- extern \"C\" means the native ABI, full stop. But this argument of course is limited by the fact that we still enable interop in both proposals, albeit with a small speedbump of using the \"C unwind\" ABI, and my feeling that people will ultimately be able to understand that propagating exceptions across Rust code requires you to \"opt in\".)</p>\n<p><strong>Side note that this exercise is making me really want to take a stab at writing out the values that Rust strives for.</strong></p>",
        "id": 191043558,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584566330
    }
]