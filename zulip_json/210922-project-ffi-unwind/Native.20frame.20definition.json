[
    {
        "content": "<p>For calling a function following the “native” platform ABI, there are often many constraints imposed by the platform. </p>\n<p>For example, if the platform ABI is a C ABI, there is often the concept of a contiguous stack, with stack frames, which have to satisfy an ABI.</p>\n<p>This causes problems, for example, when Go calls into C, it needs to copy its segmented stacks into a contiguous stack, which has some cost. </p>\n<p>By “native” frames, I was referring to how the platform defines frames for its ABI. Same for unwinding, and the call ABI. Those are the constraints that must be satisfied when interfacing with the OS kernel, etc.</p>",
        "id": 178319895,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571253361
    },
    {
        "content": "<p>Makes sense. I'm not sure what this is in reference to, though :)</p>",
        "id": 178321407,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1571254609
    },
    {
        "content": "<p>I think this could come into play for trying to unwind frames that lack call frame information</p>",
        "id": 178324493,
        "sender_full_name": "acfoltzer",
        "timestamp": 1571256925
    },
    {
        "content": "<p>we basically have a segmented stack on Lucet, though, and while it's tricky to write the CFI to wire up the pieces of the different stacks, it works without having to do any copying</p>",
        "id": 178324531,
        "sender_full_name": "acfoltzer",
        "timestamp": 1571256955
    },
    {
        "content": "<blockquote>\n<p>I'm not sure what this is in reference to, though :)</p>\n</blockquote>\n<p>Oh sorry, this was me branching <span class=\"user-mention\" data-user-id=\"237472\">@acfoltzer</span> comment from the other thread into its own discussion: <a href=\"#narrow/stream/210922-wg-ffi-unwind/topic/lucent.20use.20case/near/178318996\" title=\"#narrow/stream/210922-wg-ffi-unwind/topic/lucent.20use.20case/near/178318996\">https://rust-lang.zulipchat.com/#narrow/stream/210922-wg-ffi-unwind/topic/lucent.20use.20case/near/178318996</a></p>\n<blockquote>\n<p>the one thing I'd point out based on your comments here is that the \"native\" frames in the Lucet use case are generated from Wasm, not Rust. I believe Weld generates their code from LLVM, so \"native\" for them also means non-Rust</p>\n</blockquote>",
        "id": 178362434,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571302792
    },
    {
        "content": "<p>So if we agree on what native frames are, then we just need to agree on what Rust frames are, and then we can see what's going on there.</p>",
        "id": 178362659,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571302931
    },
    {
        "content": "<p>For example, if you use Rust to compile WASM and that WASM to emit a native frame, is that native frame a Rust frame of the same kind that if you just go from Rust to native on that platform ?</p>",
        "id": 178362702,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571302983
    },
    {
        "content": "<p>Or if like weld, you just have LLVM-IR and emit a native frame, is that a Rust native frame ?</p>",
        "id": 178362740,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571303025
    },
    {
        "content": "<p>I think that a reasonable way to say what Rust native frames are would be to say that \"they are frames generated by the Rust toolchain\"</p>",
        "id": 178362799,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571303058
    },
    {
        "content": "<p>Since weld and lucet are different toolchains, the frames they generate aren't Rust frames.</p>",
        "id": 178362836,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571303082
    },
    {
        "content": "<p>That is, if lucet wasm \"unwinds\", that exception should be foreign in Rust</p>",
        "id": 178362850,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571303102
    },
    {
        "content": "<p>and if lucet Rust unwinds through a \"lucet-wasm native frame\" back into Rust, then the Rust panic should be foreign in the \"lucet wasm native frame\"</p>",
        "id": 178362888,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571303140
    },
    {
        "content": "<p>However, I can imagine that for lucet's application it might make sense to allow those \"lucet-wasm native frames\" to handle Rust panics as non-foreign</p>",
        "id": 178363021,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571303227
    },
    {
        "content": "<p>Yep, you've got it right. \"Rust frames\" to me are only those frames for functions emitted by <code>rustc</code>; the fact that the Lucet and Weld compilers are implemented in Rust is incidental</p>\n<blockquote>\n<p>However, I can imagine that for lucet's application it might make sense to allow those \"lucet-wasm native frames\" to handle Rust panics as non-foreign</p>\n</blockquote>\n<p>This isn't in our future plans. The only reason the wasm frames might need to have more than just <code>.eh_frame</code> information is if we choose native unwinding as the means to support the Wasm exceptions proposal. In this case, Wasm would be treated as its own language for, e.g., the <code>exceptionClass</code> field in the ABI. If we needed to unwind from a Rust frame such that the Wasm frames would be able to catch it, we would use <code>_RaiseException</code> with a custom-made exception object rather than using a Rust panic</p>",
        "id": 178398900,
        "sender_full_name": "acfoltzer",
        "timestamp": 1571330571
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"237472\">@acfoltzer</span> makes sense - Can those WASM exceptions unwinding out-of-wasm into rust ?</p>",
        "id": 178399065,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571330700
    },
    {
        "content": "<p>they would be able to, but again this is a double-hypothetical that 1. the Wasm exceptions proposal is accepted and 2. we choose to use native unwinding to implement it</p>",
        "id": 178399136,
        "sender_full_name": "acfoltzer",
        "timestamp": 1571330762
    },
    {
        "content": "<p>but one could imagine <code>Rust -&gt; Wasm (catches) -&gt; Rust -&gt; Wasm (throws)</code></p>",
        "id": 178399212,
        "sender_full_name": "acfoltzer",
        "timestamp": 1571330799
    },
    {
        "content": "<p>what I <em>can't</em> imagine happening is a Wasm exception unwinding out to the outermost frames outside the initial call to the guest, since that would be analogous to an exception unwinding beyond the entrypoint of a normal program</p>",
        "id": 178399292,
        "sender_full_name": "acfoltzer",
        "timestamp": 1571330855
    },
    {
        "content": "<p>we would always want to catch that case and return a <code>GuestUnhandledException</code> error to the runtime user or something along those lines</p>",
        "id": 178399425,
        "sender_full_name": "acfoltzer",
        "timestamp": 1571330925
    },
    {
        "content": "<blockquote>\n<p>but one could imagine Rust -&gt; Wasm (catches) -&gt; Rust -&gt; Wasm (throws)</p>\n</blockquote>\n<p>That's what I was referring to. This would require supporting unwinding Rust frames with foreign exceptions</p>",
        "id": 178400720,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571331764
    },
    {
        "content": "<p>I'm going to take a look at the WASM exception proposal, this might be relevant for WASI</p>",
        "id": 178400774,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571331805
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"237472\">@acfoltzer</span> <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> <span class=\"user-mention\" data-user-id=\"132920\">@gnzlbg</span> </p>\n<p>I'm finally reading Niko's RFC draft, and it's pushing me towards avoiding the phrase \"native frames\" entirely. I think we should refer to \"Rust frames\" and \"foreign frames\", which is more explicit and lines up with the F for \"foreign\" in \"cross-FFI unwinding\".</p>",
        "id": 178713063,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571704825
    },
    {
        "content": "<p>(One thing that led me to this conclusion is that in many cases we've been saying \"native\" where we mean \"foreign\", and those are _very odd_ words to treat synonymously!)</p>",
        "id": 178713089,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571704866
    },
    {
        "content": "<p>\"Native\" as a descriptor should, I think, only be used to refer to the \"native unwinding mechanism\" or other details of the platform-provided ABI.</p>",
        "id": 178713112,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571704919
    },
    {
        "content": "<p>(\"Foreign\" also has a connection to the Itanium ABI spec, which refers to \"foreign exceptions.\")</p>",
        "id": 178713172,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571704952
    },
    {
        "content": "<blockquote>\n<p>I'm finally reading Niko's RFC draft, and it's pushing me towards avoiding the phrase \"native frames\" entirely. I think we should refer to \"Rust frames\" and \"foreign frames\", which is more explicit and lines up with the F for \"foreign\" in \"cross-FFI unwinding\".</p>\n</blockquote>\n<p>seems good, btw</p>",
        "id": 179270994,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1572293741
    }
]