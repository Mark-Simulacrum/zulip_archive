[
    {
        "content": "<p>I've been looking into how C++ deals with exceptions in FFI and come up with this idea: what if we made extern \"C\" allow unwinding by default, unless specifically marked with a <code>#[no_unwind]</code> attribute.</p>",
        "id": 178725735,
        "sender_full_name": "Amanieu",
        "timestamp": 1571724415
    },
    {
        "content": "<p>This matches the behavior of C++ in a few ways:<br>\n- <code>extern \"C\"</code> functions in C++ are allowed to throw exceptions.<br>\n- Functions declared <code>noexcept</code> cannot throw exceptions<br>\n- Functions defined <code>noexcept</code> will call <code>std::terminate</code> if an uncaught exception reaches them.</p>",
        "id": 178725815,
        "sender_full_name": "Amanieu",
        "timestamp": 1571724537
    },
    {
        "content": "<p>I believe this matches the advice given to me by nlewycky when I consulted them about the unwinding issue some time ago. (I don't think they've personally chimed in on any of the issues or RFCs except to describe their personal use case here: <a href=\"https://github.com/rust-lang/rfcs/pull/2753#issuecomment-527587083\" target=\"_blank\" title=\"https://github.com/rust-lang/rfcs/pull/2753#issuecomment-527587083\">https://github.com/rust-lang/rfcs/pull/2753#issuecomment-527587083</a>)</p>",
        "id": 178728245,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571727356
    },
    {
        "content": "<p>nlewycky is an ex-LLVM dev, which I expect informs their opinion on the matter.</p>",
        "id": 178728311,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571727404
    },
    {
        "content": "<p>That said, <code>extern \"C\"</code> is already substantially different from its C++ counterpart, because it doesn't prevent name-mangling. (<code>#[no_mangle]</code> is arguably closer to the semantics of C++'s <code>extern \"C\"</code> than Rust's <code>extern \"C\"</code> is.)</p>",
        "id": 178728396,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571727486
    },
    {
        "content": "<p>I just feel that we should have the safe version be the default, and if you really want to tell the optimizer that an FFI function does not unwind then you can add an attribute.</p>",
        "id": 178728427,
        "sender_full_name": "Amanieu",
        "timestamp": 1571727560
    },
    {
        "content": "<p>Well....</p>",
        "id": 178728713,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571727879
    },
    {
        "content": "<p>Have you read much or all of the discussions in RFCs 2699 and 2753?</p>",
        "id": 178728721,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571727894
    },
    {
        "content": "<p>The main arguments against that view, as I understood them, were that (1) _exposing_ unwinding (from Rust <code>extern \"C\"</code> functions) would be _less_ safe than <code>abort</code>ing, and (2) having a different assumption about unwinding for <code>extern \"C\"</code> depending on whether the function is being \"imported\" vs defined would be inconsistent and therefore confusing.</p>",
        "id": 178728806,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571727984
    },
    {
        "content": "<p>I am of the opinion that the \"consistently conservative\" behavior would be to prohibit _exposing_ unwinding by default (i.e. Rust <code>extern \"C\"</code> functions would have the abort logic), but to assume that \"imported\" <code>extern \"C\"</code> functions may unwind (and that the caller therefore needs a landing pad).</p>",
        "id": 178728855,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571728079
    },
    {
        "content": "<p>Let me get the link to the prior discussion....</p>",
        "id": 178728915,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571728107
    },
    {
        "content": "<p>Here's where I brought up the idea that the defaults should be opposites: <a href=\"https://github.com/rust-lang/rfcs/pull/2753#issuecomment-528945332\" target=\"_blank\" title=\"https://github.com/rust-lang/rfcs/pull/2753#issuecomment-528945332\">https://github.com/rust-lang/rfcs/pull/2753#issuecomment-528945332</a></p>",
        "id": 178729277,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571728547
    },
    {
        "content": "<p>I'm not sure anyone in either RFC recommended making the default <code>unwind(allow)</code> for both cases.</p>",
        "id": 178729322,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571728567
    },
    {
        "content": "<p>A major concern there is that without <code>-fexceptions</code>, C code on most major non-Windows platforms can't properly support unwinding.</p>",
        "id": 178729338,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571728610
    },
    {
        "content": "<p>Not having -fexceptions doesn't block unwinding though, unwinding through C code still works fine.</p>",
        "id": 178729738,
        "sender_full_name": "Amanieu",
        "timestamp": 1571729126
    },
    {
        "content": "<p>Unwinding just skips frames with no unwind info.</p>",
        "id": 178729750,
        "sender_full_name": "Amanieu",
        "timestamp": 1571729151
    },
    {
        "content": "<p>Hmm technically LLVM says it's UB because we use the <code>nounwind</code> attribute</p>",
        "id": 178729910,
        "sender_full_name": "Amanieu",
        "timestamp": 1571729351
    },
    {
        "content": "<p>for any ABI specifier where we don't <code>abort</code> on unwind, we'd stop emitting <code>nounwind</code></p>",
        "id": 178729933,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571729382
    },
    {
        "content": "<p>...I did not realize that it's well-defined behavior to not have landing pads in intermediate frames.</p>",
        "id": 178729997,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571729417
    },
    {
        "content": "<p>That definitely changes my understanding of <code>-fexceptions</code>. I had thought that without <code>-fexceptions</code>, the behavior of a C++ <code>throw</code> crossing over C frames would be undefined.</p>",
        "id": 178730029,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571729463
    },
    {
        "content": "<p>....in an actually-dangerous way, not just a \"the C++ standard can't state what the C language does, and C doesn't mention exceptions, therefore it's undefined\" way.</p>",
        "id": 178730055,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571729504
    },
    {
        "content": "<p>Here is Centril's response to my statement (linked above) that there should be opposite defaults: <a href=\"https://github.com/rust-lang/rfcs/pull/2753#issuecomment-529084321\" target=\"_blank\" title=\"https://github.com/rust-lang/rfcs/pull/2753#issuecomment-529084321\">https://github.com/rust-lang/rfcs/pull/2753#issuecomment-529084321</a></p>",
        "id": 178730221,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571729643
    },
    {
        "content": "<p>Though note that he's objecting to treating <code>extern \"C\"</code> function pointers (rather than import declarations) as unwind-allowed-by-default</p>",
        "id": 178730258,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571729703
    },
    {
        "content": "<p>...but I think that the one would imply the other, since at the point of usage, function pointers have less associate information.</p>",
        "id": 178730276,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571729745
    },
    {
        "content": "<p>There is also a separate argument in that thread about why <code>extern \"C\"</code> shouldn't unwind, namely, because of the name \"C\", since the C language doesn't have exceptions.</p>",
        "id": 178730337,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571729799
    },
    {
        "content": "<p>Since <code>C</code> can in fact have unwinding (e.g. in Windows with SEH) and <code>extern \"C\"</code> is taken from C++ (not from C), I don't really agree with that particular argument.</p>",
        "id": 178730360,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571729840
    },
    {
        "content": "<p>Can you think of any scenario where emitting a <code>panic</code> from Rust into foreign (C, C++, D, etc) code compiled with the corresponding backend would cause undefined behavior? (Assuming that the foreign code has no RAII or <code>finally</code> constructs, and assuming that it doesn't attempt to catch or otherwise interact with the unwind operation)</p>",
        "id": 178730832,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571730390
    },
    {
        "content": "<p>If not, and if we have some confidence that this is considered \"well defined\" for the various platforms, then I would be strongly inclined to just change the (non) specification of Rust's <code>extern \"C\"</code> unwinding from \"undefined\" to \"implementation defined\".</p>",
        "id": 178731058,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571730627
    },
    {
        "content": "<p>...and providing some kind of <code>unwind(abort)</code> annotation, for use anywhere in the language, since that seems potentially useful.</p>",
        "id": 178731084,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571730667
    },
    {
        "content": "<p>With that said, I expect (based on the conversations in those RFCs) that not all the stakeholders would agree with this direction.</p>",
        "id": 178731294,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571730898
    },
    {
        "content": "<p>Additionally, one benefit of having separate ABI strings for functions that can unwind versus those that can't is that the type system can ensure that the information is preserved even via function pointers. Of course, that also carries with it the downside of introducing a new incompatible function pointer type.</p>",
        "id": 178731402,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571730995
    },
    {
        "content": "<p>Early on when this issue was being discussed, I asked on StackOverflow about \"how undefined\" the behavior _even with_ <code>-fexceptions</code> is. Here's one of the answers: <a href=\"https://stackoverflow.com/a/55818675/1858225\" target=\"_blank\" title=\"https://stackoverflow.com/a/55818675/1858225\">https://stackoverflow.com/a/55818675/1858225</a></p>",
        "id": 178731899,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571731379
    },
    {
        "content": "<p>I consider that answer unhelpful and probably wrong, but I'm certainly not an expert.</p>",
        "id": 178731933,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571731418
    },
    {
        "content": "<p>In any case, it's an example of an attitude that makes me hesitant to push for letting exceptions escape from <code>extern \"C\"</code> in Rust by default.</p>",
        "id": 178731993,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571731448
    },
    {
        "content": "<p>Technically a Rust panic unwinding into C code (compiled without -fexceptions) would be UB. But in practice it would work as expected with the unwinder simply skipping the C frames.</p>",
        "id": 178732212,
        "sender_full_name": "Amanieu",
        "timestamp": 1571731712
    },
    {
        "content": "<p>Does the Itanium ABI not specify what happens when there aren't landing pads?</p>",
        "id": 178732241,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571731757
    },
    {
        "content": "<p>(in frames being crossed by an exception)</p>",
        "id": 178732247,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571731765
    },
    {
        "content": "<p>Nothing happens, it just continues unwinding.</p>",
        "id": 178732277,
        "sender_full_name": "Amanieu",
        "timestamp": 1571731791
    },
    {
        "content": "<p>Let me double check</p>",
        "id": 178732319,
        "sender_full_name": "Amanieu",
        "timestamp": 1571731803
    },
    {
        "content": "<p>If it does specify that, then wouldn't the behavior be implementation-defined on platforms supporting that ABI, as long as Rust says it is?</p>",
        "id": 178732330,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571731806
    },
    {
        "content": "<p>OK, so here's what happens. First of all, the C code must have unwinding tables. This is usually on by default, even without -fexceptions.</p>",
        "id": 178732389,
        "sender_full_name": "Amanieu",
        "timestamp": 1571731891
    },
    {
        "content": "<p>Ah! Okay, so that seems important - without unwinding tables, the behavior would be undefined even at the platform level, correct?</p>",
        "id": 178732458,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571731929
    },
    {
        "content": "<p>Without unwinding tables the C code is basically treated as \"end-of-stack\"</p>",
        "id": 178732478,
        "sender_full_name": "Amanieu",
        "timestamp": 1571731952
    },
    {
        "content": "<p>What does that mean?</p>",
        "id": 178732486,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571731964
    },
    {
        "content": "<p>Excluding the case of missing unwinding tables, I guess what I'm trying to say is that it seems like this is only UB because the various language standards don't say otherwise, but most (or all?) of the platforms providing the ABIs seem to actually provide well-defined behavior.</p>",
        "id": 178732501,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571731983
    },
    {
        "content": "<p>No handler found, unwinding fails, std::terminate is called (in C++)</p>",
        "id": 178732506,
        "sender_full_name": "Amanieu",
        "timestamp": 1571731985
    },
    {
        "content": "<p>So, still not UB!</p>",
        "id": 178732543,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571732005
    },
    {
        "content": "<p>If you search for <code>nounwind</code> in LLVM's LangRef, it talks about UB.</p>",
        "id": 178732549,
        "sender_full_name": "Amanieu",
        "timestamp": 1571732016
    },
    {
        "content": "<p>Right, I'm excluding <code>nounwind</code> in my thought process here</p>",
        "id": 178732570,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571732030
    },
    {
        "content": "<p>When LLVM compiles C code it uses <code>nounwind</code> everywhere. So it would be UB for a Rust panic to unwind through that code.</p>",
        "id": 178732645,
        "sender_full_name": "Amanieu",
        "timestamp": 1571732074
    },
    {
        "content": "<p>It seems like exceptions are perhaps much less dangerous and scary than I had been led to believe, at the ABI/platform level</p>",
        "id": 178732651,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571732081
    },
    {
        "content": "<p>Ahhh.</p>",
        "id": 178732660,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571732086
    },
    {
        "content": "<p>(LLVM does generate unwind tables for C code though)</p>",
        "id": 178732661,
        "sender_full_name": "Amanieu",
        "timestamp": 1571732087
    },
    {
        "content": "<p>But then again, the only thing LLVM uses <code>nounwind</code> for is optimizing away \"dead\" landing pads. Which there aren't any in C anyways. So it will work in practice.</p>",
        "id": 178733225,
        "sender_full_name": "Amanieu",
        "timestamp": 1571732562
    },
    {
        "content": "<p>Hm, I can't find a reference for LLVM emitting <code>nounwind</code> on C code; does it still do so even with <code>-fexceptions</code>? (Surely not?)</p>",
        "id": 178733364,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571732708
    },
    {
        "content": "<p>Try it on godbolt</p>",
        "id": 178734218,
        "sender_full_name": "Amanieu",
        "timestamp": 1571733378
    },
    {
        "content": "<p><a href=\"https://godbolt.org/z/9eRIQs\" target=\"_blank\" title=\"https://godbolt.org/z/9eRIQs\">https://godbolt.org/z/9eRIQs</a></p>",
        "id": 178734257,
        "sender_full_name": "Amanieu",
        "timestamp": 1571733410
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> LLVM <code>nounwind</code> does not mean \"does not unwind\"</p>",
        "id": 178748792,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571746295
    },
    {
        "content": "<p><code>nounwind</code> functions are allowed to unwind</p>",
        "id": 178748802,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571746304
    },
    {
        "content": "<p>the more relevant questions are whether you want the unwind to run destructors or call abort (some safe Rust code requires destructors to run for soundness)</p>",
        "id": 178748911,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571746392
    },
    {
        "content": "<p>notice that LLVM also has the <code>nouwtable</code> attribute as well</p>",
        "id": 178748930,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571746413
    },
    {
        "content": "<p>also, when you talk about <code>extern \"C\"</code> you are not being specific if what you are proposing applies to function definitions, function declarations, or both</p>",
        "id": 178749051,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571746486
    },
    {
        "content": "<p>Does <code>extern \"C\" { #[no_unwind] fn foo(); }</code> abort on unwinding under your proposal ? If so, how would that be implemented ?</p>",
        "id": 178749091,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571746521
    },
    {
        "content": "<p>Finally, C++ <code>noexcept</code> is part of the C++ type system, but <code>#[no_unwind]</code> would not be.</p>",
        "id": 178749475,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571746796
    },
    {
        "content": "<p>Would it be possible for users to somehow specify at a call site that calling a function does not unwind ?</p>",
        "id": 178749579,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571746868
    },
    {
        "content": "<blockquote>\n<p>Does <code>extern \"C\" { #[no_unwind] fn foo(); }</code> abort on unwinding under your proposal ? If so, how would that be implemented ?</p>\n</blockquote>\n<p>It would be UB on unwind (same as <code>extern noexcept</code> in C++).</p>",
        "id": 178752418,
        "sender_full_name": "Amanieu",
        "timestamp": 1571748977
    },
    {
        "content": "<p>(In practice it still unwinds but destructors may have been optimized out by LLVM assuming that unwinding can't happen)</p>",
        "id": 178752471,
        "sender_full_name": "Amanieu",
        "timestamp": 1571749021
    },
    {
        "content": "<p>Also regarding LLVM <code>nounwind</code>:</p>\n<blockquote>\n<p>If the function does raise an exception, its runtime behavior is undefined.</p>\n</blockquote>",
        "id": 178754432,
        "sender_full_name": "Amanieu",
        "timestamp": 1571750293
    },
    {
        "content": "<p>Keep reading</p>",
        "id": 178754439,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571750300
    },
    {
        "content": "<blockquote>\n<p>However, functions marked nounwind may still trap or generate asynchronous exceptions.</p>\n</blockquote>\n<p>But we're talking about normal exceptions here.</p>",
        "id": 178754516,
        "sender_full_name": "Amanieu",
        "timestamp": 1571750345
    },
    {
        "content": "<p>Keep reading</p>",
        "id": 178754539,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571750361
    },
    {
        "content": "<p>In particular the note about SEH</p>",
        "id": 178754618,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571750403
    },
    {
        "content": "<p>Eh sure, but even then that's debatable.</p>",
        "id": 178754661,
        "sender_full_name": "Amanieu",
        "timestamp": 1571750431
    },
    {
        "content": "<p>Keep in mind we do use SJLJ unwinding on at least one target (iOS ARM32)</p>",
        "id": 178754681,
        "sender_full_name": "Amanieu",
        "timestamp": 1571750445
    },
    {
        "content": "<p>notice that <code>longjmp</code> on windows uses SEH, and it is correct to <code>longjmp</code> over <code>noexcept</code> functions</p>",
        "id": 178754687,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571750449
    },
    {
        "content": "<p>which are <code>nounwind</code></p>",
        "id": 178754727,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571750478
    },
    {
        "content": "<p>Sure, but the key point here is that LLVM will optimize away destructors with the assumption that they are unreachable.</p>",
        "id": 178754948,
        "sender_full_name": "Amanieu",
        "timestamp": 1571750640
    },
    {
        "content": "<p>I don't know how we can explain that except through UB.</p>",
        "id": 178755004,
        "sender_full_name": "Amanieu",
        "timestamp": 1571750657
    },
    {
        "content": "<p>That's why I mentioned that the key thing about <code>nounwind</code> is whether destructors should or should not be run on unwinding</p>",
        "id": 178755015,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571750669
    },
    {
        "content": "<p>Not running destructors is ok, e.g., if the frame does not contain any destructors to run</p>",
        "id": 178755035,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571750689
    },
    {
        "content": "<p>When calling a function that's <code>nounwind</code>, if the function is actually unwound, destructors might or might not be run (it depends, its even possible that only some destructors would be run, but not all), but there is a lot of code for which the distinction does not matter.</p>",
        "id": 178755143,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571750764
    },
    {
        "content": "<p>Except that LLVM is clearly using the UB rule to allow itself to optimize away unreachable destructors. I don't think we should rely on LLVM's interpretation of UB remaining consistent.</p>",
        "id": 178755211,
        "sender_full_name": "Amanieu",
        "timestamp": 1571750837
    },
    {
        "content": "<p>We do not need to guarantee that destructors are / aren't run consistently</p>",
        "id": 178755238,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571750866
    },
    {
        "content": "<p>We just need to say that the behavior is unspecified, and that means that either all destructors run, no destructors run, or some destructors run, and that implementations do not need to write down nor guarantee what they do.</p>",
        "id": 178755316,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571750904
    },
    {
        "content": "<p>In practice, if your frame doesn't contain destructors, or the destructors are not required for safety, and you are ok with some or all of them not running, then you are fine.</p>",
        "id": 178755360,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571750930
    },
    {
        "content": "<p>(This is what we could say at the Rust side - how we lower this to LLVM would be a different matter, but on platforms such as windows, making them <code>nounwind</code> might be fine, because LLVM says that the behavior there is implementation-defined)</p>",
        "id": 178755494,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571751016
    },
    {
        "content": "<p>I disagree with your interpretation of LLVM's paragraph. I read it as: unwinding with an exception is UB, but unwinding with a trap or asynchronous exception is implementation-defined.</p>",
        "id": 178755740,
        "sender_full_name": "Amanieu",
        "timestamp": 1571751209
    },
    {
        "content": "<p>LLVM can't remove the destructors unless it can prove that the destructors are only reachable through UB.</p>",
        "id": 178755860,
        "sender_full_name": "Amanieu",
        "timestamp": 1571751294
    },
    {
        "content": "<p>So are you arguing that SEH is synchronous ?</p>",
        "id": 178756489,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571751609
    },
    {
        "content": "<p>Or how do you interpret the behavior of <code>nounwind</code> on windows, where SEH exceptions are asynchronous, and that's the mechanism that <code>longjmp</code> and C++ use ?</p>",
        "id": 178756609,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571751704
    },
    {
        "content": "<p>It can be either. If you raise an exception yourself by calling <code>RaiseException</code> then it is. If you trigger an exception through a trap then it isn't.</p>",
        "id": 178756625,
        "sender_full_name": "Amanieu",
        "timestamp": 1571751716
    },
    {
        "content": "<p><code>RaiseException</code> is what <code>longjmp</code> uses</p>",
        "id": 178756808,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571751820
    },
    {
        "content": "<p>Synchronous exception = something you explicitly throw<br>\nTrap = a faulting instruction<br>\nAsynchronous exception = an exceptions injected into your thread from another thread</p>",
        "id": 178756810,
        "sender_full_name": "Amanieu",
        "timestamp": 1571751821
    },
    {
        "content": "<p>Hmm <code>longjmp</code> is wierd.</p>",
        "id": 178757030,
        "sender_full_name": "Amanieu",
        "timestamp": 1571751947
    },
    {
        "content": "<p>So under your interpretation, because <code>longjmp</code> on windows uses a synchronous exception, it would be UB for it to unwind out of a <code>noexcept</code> function (which is <code>nounwind</code>). However, AFAICT from LLVM and the MSVC docs, it isn't, and that's actually guaranteed to work</p>",
        "id": 178757143,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571751993
    },
    {
        "content": "<p>MSVC mentions <a href=\"https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/longjmp?view=vs-2019\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/longjmp?view=vs-2019\">here</a>:</p>\n<blockquote>\n<p>If the code is compiled by using /EHs or /EHsc and the function that contains the longjmp call is noexcept then local objects in that function may not be destructed during the stack unwind.</p>\n</blockquote>",
        "id": 178757235,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571752050
    },
    {
        "content": "<p>I think we would need a confirmation from LLVM devs to guarantee that the only consequence of misusing <code>nounwind</code> is that destructors may not get called.</p>",
        "id": 178757325,
        "sender_full_name": "Amanieu",
        "timestamp": 1571752085
    },
    {
        "content": "<p>And yes, <code>longjmp</code> is considered a synchronous exception by my definition.</p>",
        "id": 178757389,
        "sender_full_name": "Amanieu",
        "timestamp": 1571752125
    },
    {
        "content": "<p>The same happens in the Itanium-C++ ABI (for the Itanium target), where <code>longjmp</code> uses <code>Unwind_ForceUnwind</code> to unwind through frames, and it can actually unwind through <code>noexcept</code> functions</p>",
        "id": 178757405,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571752133
    },
    {
        "content": "<p>Notice that while it is UB to do that if the frames contain destructors, it isn't if they don't, yet that means that one would need to be able to unwind with a <code>Unwind_ForceUnwind</code> through a <code>nounwind</code> function.</p>",
        "id": 178757579,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571752221
    },
    {
        "content": "<p>Yes, this is arguably a mistake in LLVM's definition of <code>nounwind</code>.</p>",
        "id": 178757611,
        "sender_full_name": "Amanieu",
        "timestamp": 1571752236
    },
    {
        "content": "<p>I think what you propose for <code>extern \"C\"</code> is fine, but we should focus on what semantics make sense for Rust first, and worry what LLVM-IR we generate about it \"on the side\"</p>",
        "id": 178757685,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571752278
    },
    {
        "content": "<p>In particular for <code>#[no_unwind]</code></p>",
        "id": 178757721,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571752305
    },
    {
        "content": "<p>It would be fine to say that unwinding from a <code>#[no_unwind]</code> function is UB in Rust</p>",
        "id": 178757791,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571752326
    },
    {
        "content": "<p>and if someone uses <code>longjmp</code>, then they just can't use <code>#[no_unwind]</code></p>",
        "id": 178757808,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571752341
    },
    {
        "content": "<p>I'm happy with that.</p>",
        "id": 178757907,
        "sender_full_name": "Amanieu",
        "timestamp": 1571752419
    },
    {
        "content": "<p>I'm happy to I think.</p>",
        "id": 178757986,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571752449
    },
    {
        "content": "<p>By the way I've just done a little searching and it seems that pthread_exit (which uses unwinding in glibc) has poor interactions with <code>noexcept</code>.</p>",
        "id": 178758001,
        "sender_full_name": "Amanieu",
        "timestamp": 1571752458
    },
    {
        "content": "<p>But I think this has been fixed now.</p>",
        "id": 178758028,
        "sender_full_name": "Amanieu",
        "timestamp": 1571752476
    },
    {
        "content": "<p>The issue of leaving the Rust unwinding ABI unspecified could be then just solved by enforcing the translation at the <code>extern \"C\"</code> ABI layer</p>",
        "id": 178758030,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571752479
    },
    {
        "content": "<blockquote>\n<p>By the way I've just done a little searching and it seems that pthread_exit (which uses unwinding in glibc) has poor interactions with noexcept.</p>\n</blockquote>\n<p>I think that this is simpler to workaround in Rust, since these exceptions are foreign, and we can just not catch them ever, not even by the <code>abort-on-panic</code> shims at the <code>#[no_unwind] extern \"C\"</code> boundary</p>",
        "id": 178758110,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571752544
    },
    {
        "content": "<p>That might mean that when such a function unwinds due to a <code>pthread_exit</code>, not all destructors might be run though :/</p>",
        "id": 178758174,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571752571
    },
    {
        "content": "<p>So then we are back to whether there are some situations for which a <code>#[no_unwind]</code> function can unwind</p>",
        "id": 178758230,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571752610
    },
    {
        "content": "<p>That's a bad idea, if someone calls <code>pthread_exit</code>, then no function in the stack can be <code>#[no_unwind]</code>, I'd be fine with that</p>",
        "id": 178758341,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571752680
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;pthread.h&gt;</span><span class=\"cp\"></span>\n\n<span class=\"kt\">void</span><span class=\"o\">*</span> <span class=\"nf\">thread</span><span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"o\">*</span><span class=\"p\">)</span> <span class=\"k\">noexcept</span> <span class=\"p\">{</span>\n  <span class=\"n\">pthread_exit</span><span class=\"p\">(</span><span class=\"nb\">NULL</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n\n<span class=\"kt\">int</span> <span class=\"nf\">main</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n  <span class=\"n\">pthread_t</span> <span class=\"n\">t</span><span class=\"p\">;</span>\n  <span class=\"n\">pthread_create</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"nb\">NULL</span><span class=\"p\">,</span> <span class=\"kr\">thread</span><span class=\"p\">,</span> <span class=\"nb\">NULL</span><span class=\"p\">);</span>\n  <span class=\"n\">pthread_join</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"nb\">NULL</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</pre></div>",
        "id": 178759351,
        "sender_full_name": "Amanieu",
        "timestamp": 1571753320
    },
    {
        "content": "<p>This program crashes with:</p>\n<div class=\"codehilite\"><pre><span></span>terminate called without an active exception\n[1]    601165 abort (core dumped)  ./a.out\n</pre></div>",
        "id": 178759369,
        "sender_full_name": "Amanieu",
        "timestamp": 1571753340
    },
    {
        "content": "<p>Should it crash?</p>",
        "id": 178763720,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571756177
    },
    {
        "content": "<p>(What if instead of phtread_exit, a cancellation point + pthread_cancel are used ?)</p>",
        "id": 178763748,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571756194
    },
    {
        "content": "<p>If you remove the <code>noexcept</code> it works fine. What happens is that <code>noexcept</code> catches any exceptions from within the function and calls <code>std::terminate</code>.</p>",
        "id": 178766243,
        "sender_full_name": "Amanieu",
        "timestamp": 1571757755
    },
    {
        "content": "<p>A cancellation point does the same thing as <code>pthread_exit</code>, they're both forced unwinds.</p>",
        "id": 178766265,
        "sender_full_name": "Amanieu",
        "timestamp": 1571757777
    },
    {
        "content": "<p>By the way all of this only applies to glibc, musl doesn't use unwinding for cancellation.</p>",
        "id": 178767100,
        "sender_full_name": "Amanieu",
        "timestamp": 1571758294
    },
    {
        "content": "<p>I understand why the call to <code>std::terminate</code> happens, what I'm asking is if this is actually is the correct behavior, or if this behavior is by design</p>",
        "id": 178767945,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571758869
    },
    {
        "content": "<p>For example, in Rust we can make <code>#[no_unwind]</code> functions <code>abort</code> when <code> longjmp</code> is used on Windows</p>",
        "id": 178767973,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571758895
    },
    {
        "content": "<p>Or when <code>pthread_exit</code> and similar are used on Linux</p>",
        "id": 178767990,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571758907
    },
    {
        "content": "<p>But we can also just unwind those functions just like msvc does for <code>longjmp</code>+<code>noexcept</code> in C++ code</p>",
        "id": 178768070,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571758948
    },
    {
        "content": "<p>which is in fact we currently do for <code>extern \"C\"</code> function definitions that are <code>nounwind</code> on windows</p>",
        "id": 178768171,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571759023
    },
    {
        "content": "<p>If the unwind is due to a <code>longjmp</code> on windows, instead of <code>abort</code>ing on abort-on-panic-shims, we let the unwind continue</p>",
        "id": 178768250,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571759064
    },
    {
        "content": "<p>and some libraries like rlua rely on this working</p>",
        "id": 178768274,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571759080
    },
    {
        "content": "<p>On Linux, we could do the same, e.g., if the unwind is due to a force unwind, not abort on abort-on-panic-shims.</p>",
        "id": 178768306,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571759100
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span>  an alternative is making <code>#[no_unwind]</code> functions always abort on unwinding including for force unwinds, asynchronous exceptions, etc. and maybe say that <code>longjmp</code>s over these are UB.</p>",
        "id": 178769053,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571759652
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"126931\">@centril</span> do you have some time to skim this thread and let us know if you have any immediate objections to the proposal of letting unwinding through <code>extern \"C\"</code> happen, and considering it implementation-defined, pending LLVM confirmation that the behavior on their end is well defined?</p>",
        "id": 178900018,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571867113
    },
    {
        "content": "<p>I do have objections.</p>\n<p>- It's debatable whether allowing <code>extern \"C\"</code> code to unwind is a breaking change or not (there's an argument that you cannot do negative reasoning about undefined behavior but to some extent I think such reasoning is legitimate).<br>\n- Existing code is written with an assumption that <code>extern \"C\"</code> emits nounwind for code size and other benefits.<br>\n- Making unwind-allowed the default makes it all the more likely that we freeze the unwinding implementation for Rust.<br>\n- \"Implementation defined\" entails that e.g. for the <code>x86_64-unknown-linux-gnu</code>target, the compiler team is free to define the behavior. Given that we currently have one backend and one compiler I think that makes it in practice not implementation defined but defined for the whole language. I also think we should be free to change things for important tier-1 targets.<br>\n- Given the back &amp; forth with respect to what LLVMs actual semantics are, I would want to see whatever guarantees we want from LLVM written directly into LangRef.<br>\n- <code>no_unwind</code> is an attribute; this does not seem to cover function pointers.</p>",
        "id": 178900804,
        "sender_full_name": "centril",
        "timestamp": 1571867804
    },
    {
        "content": "<p>Also... we have a soundness hole to fix... (sooner rather than later)</p>",
        "id": 178900823,
        "sender_full_name": "centril",
        "timestamp": 1571867823
    },
    {
        "content": "<p>I don't think the \"one backend and one compiler\" issue really applies here: unwinding is pretty well standardized with SEH on Windows and libunwind/dwarf for all other platforms.</p>",
        "id": 178901573,
        "sender_full_name": "Amanieu",
        "timestamp": 1571868543
    },
    {
        "content": "<p>Re: soundness, can we re-open RalfJ's PR to stop emitting <code>nounwind</code>?</p>",
        "id": 178902213,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571869087
    },
    {
        "content": "<p>I am not sure I understand how this could be considered a breaking change. Does <code>rustc</code> actually make any promises with respect to optimization regressions? That would be surprising to me.</p>",
        "id": 178902275,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571869138
    },
    {
        "content": "<blockquote>\n<p>Re: soundness, can we re-open RalfJ's PR to stop emitting nounwind?</p>\n</blockquote>\n<p>I'm not going to say more than I've already said about this other than to note that <span class=\"user-mention\" data-user-id=\"132920\">@gnzlbg</span>  has a PR which fixes the soundness hole without changing the implementation UB to not UB.</p>",
        "id": 178902663,
        "sender_full_name": "centril",
        "timestamp": 1571869530
    },
    {
        "content": "<blockquote>\n<p>Does rustc actually make any promises with respect to optimization regressions? That would be surprising to me.</p>\n</blockquote>\n<p>The reasoning here is that a set of behaviors are spec/implementation-UB and people could write code based on this assumption that such code will not occur (negative reasoning) for soundness.</p>",
        "id": 178902774,
        "sender_full_name": "centril",
        "timestamp": 1571869629
    },
    {
        "content": "<p>You could argue that such negative reasoning is dubious</p>",
        "id": 178902790,
        "sender_full_name": "centril",
        "timestamp": 1571869649
    },
    {
        "content": "<p>I understand how allowing <code>extern \"C\"</code> to unwind <em>now</em> and then prohibiting that in the future would be a breaking change, but that's not being proposed; essentially, the proposal here is to treat <code>extern \"C\"</code> the way we were planning to treat <code>extern \"C unwind\"</code>.</p>\n<p>What I don't understand is your first bullet point, saying that permitting the unwind _now_ would be a breaking change. I can't think of any way that code could rely on the current behavior (not aborting but emitting <code>nounwind</code>) in a way that would be broken by no longer emitting <code>nounwind</code>. Am I misunderstanding that bullet point?</p>",
        "id": 178907845,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571874426
    },
    {
        "content": "<p>Also, re: freezing the implementation, if we were to proceed with this plan, it would include requiring a translation layer at an <code>extern \"C\"</code> boundary if the default Rust panic mechanism ever changes, just like <code>extern \"C unwind\"</code> would have.</p>",
        "id": 178907951,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571874559
    },
    {
        "content": "<p>I think that what <span class=\"user-mention\" data-user-id=\"126931\">@centril</span> is saying is that code may currently assume that FFI doesn't unwind and rely on this invariant for safety. If we change this to allow unwinding then such code may become unsound.</p>",
        "id": 178927609,
        "sender_full_name": "Amanieu",
        "timestamp": 1571902344
    },
    {
        "content": "<p>That's a good argument, but I think its incorrect</p>",
        "id": 178927645,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571902406
    },
    {
        "content": "<p>Currently, unwinding through <code>extern \"C\"</code> is UB</p>",
        "id": 178927649,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571902414
    },
    {
        "content": "<p>This does not mean that code can be written to assume it will never happen</p>",
        "id": 178927664,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571902427
    },
    {
        "content": "<p>UB is \"we make no guarantees\" and that includes \"we do not gurantee that this will be UB forever\"</p>",
        "id": 178927724,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571902454
    },
    {
        "content": "<p>So defining that \"UB\" to say \"unwinding is ok\" is allowed</p>",
        "id": 178927740,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571902472
    },
    {
        "content": "<p>Code that assumes otherwise is already broken, since it is expecting UB to be making some guarantees (e.g. that UB remains UB forever), which is something that we do not guarantee for UB - otherwise, we can't ever remove UB from the language.</p>",
        "id": 178927755,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571902497
    },
    {
        "content": "<blockquote>\n<p>I don't think the \"one backend and one compiler\" issue really applies here: unwinding is pretty well standardized with SEH on Windows and libunwind/dwarf for all other platforms.</p>\n</blockquote>\n<p>GCC 3 to GCC 4 changed the linux unwinding ABI from SJLJ to DWARF</p>",
        "id": 178928184,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571902941
    },
    {
        "content": "<p>That wasn't that long ago</p>",
        "id": 178928197,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571902961
    },
    {
        "content": "<p>I'd rather not commit to a solution that assumes that something like this will never happen again</p>",
        "id": 178928274,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571903065
    },
    {
        "content": "<p>I just read through this whole thread, and the idea of allowing unwinding by default seems reasonable to me.</p>",
        "id": 179020165,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1571976290
    },
    {
        "content": "<p>Thank you for the detailed analysis, <span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> .</p>",
        "id": 179020176,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1571976307
    },
    {
        "content": "<p>For what it's worth, I think opening the RFC with <code>extern \"C unwind\"</code> (and possibly even landing it) would not necessarily prevent us from making <code>extern \"C\"</code> match the proposed \"C unwind\" behavior. That's the main reason why I think we should proceed with \"C unwind\" for now.</p>",
        "id": 179036013,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571996939
    }
]