[
    {
        "content": "<p>It's very unfortunate that \"C-unwind\" is blocked on an edge case behavior when mixing crates compiled with <code>-C panic=unwind</code> and <code>-C panic=abort</code>. Could we simply say that such a combination is not supported?</p>\n<p>The only use case for this at the moment is to allow a pre-built <code>std</code> with <code>-C panic=unwind</code> to link with crates compiled with <code>-C panic=abort</code>, but we could just use an unstable crate attribute on <code>std</code> to override the check in that particular case. The only restriction is that in return, <code>std</code> needs to be careful to not call any <code>\"C-unwind\"</code> functions that could generate a foreign exception which could get passed on to frames compiled with <code>-C panic=abort</code>.</p>",
        "id": 267694089,
        "sender_full_name": "Amanieu",
        "timestamp": 1641976272
    },
    {
        "content": "<p>I did some research into the proposed solution of using a personality function that aborts:</p>\n<ul>\n<li>Unfortunately this require emitting unwinding information for all functions which can have an unacceptable memory cost on embedded platforms that are never going to unwind.</li>\n<li>LLVM currently optimizes the personality of a function away if that function has no landing pads. This is normally a perfectly valid optimization that will require changes to LLVM to inhibit. The \"proper\" way of handling this is to actually emit a landing pad that aborts in <em>all</em> functions and stop using the <code>nounwind</code> attribute, but that pretty much defeats the point of <code>-C panic=abort</code>.</li>\n<li>It <em>is</em> possible to do this on Windows, possibly by modifying LLVM to not guess the EH type from the personality function name. However the actual implementation of the personality function can't just abort since that would break longjmp and SEH. I can't see an easy way to only block C++ exceptions without relying on internal implementation details of the MSVC runtime.</li>\n</ul>",
        "id": 267695911,
        "sender_full_name": "Amanieu",
        "timestamp": 1641977473
    },
    {
        "content": "<p>Not allowing mixing panic strategies seems reasonable as a restriction.</p>",
        "id": 267749856,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1642005383
    },
    {
        "content": "<p>Does \"not supported\" mean the combination is effectively UB?</p>",
        "id": 267764503,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642011373
    },
    {
        "content": "<p>I wonder if there are use cases where a library requires unwinding to function correctly internally, but this use case sounds fairly niche.</p>",
        "id": 267776801,
        "sender_full_name": "Gary Guo",
        "timestamp": 1642017082
    },
    {
        "content": "<p>Having a single <code>panic=abort</code> crate already forces panics to abort for all rust crates. It is just that <code>panic=abort</code> and <code>panic=unwind</code> crates codegen <code>extern \"C-unwind\"</code> differently enough that mixing them currently allows unwinding past <code>panic=abort</code> crates (rather than abort at the <code>extern \"C-unwind\"</code> boundary) which is UB.</p>",
        "id": 267781474,
        "sender_full_name": "bjorn3",
        "timestamp": 1642019343
    },
    {
        "content": "<p>I was thinking about the case where a crate depends on foreign exception (e.g. C++) being able to propagate through Rust frames to function properly</p>",
        "id": 267786732,
        "sender_full_name": "Gary Guo",
        "timestamp": 1642021826
    },
    {
        "content": "<blockquote>\n<p>LLVM currently optimizes the personality of a function away if that function has no landing pads. This is normally a perfectly valid optimization that will require changes to LLVM to inhibit. The \"proper\" way of handling this is to actually emit a landing pad that aborts in all functions and stop using the nounwind attribute, but that pretty much defeats the point of <code>-C panic=abort</code>.</p>\n</blockquote>\n<p>How bad will it be if we only generate <code>nounwind</code> attributes for calls that are known to not unwind? I.e. if the call target is compiled with <code>panic=abort</code>, then generate it; if the call tagret is <code>panic=unwind</code> or it's a indirect Rust-ABI call then omit it and create an aborting landing pad?</p>",
        "id": 267787386,
        "sender_full_name": "Gary Guo",
        "timestamp": 1642022178
    },
    {
        "content": "<p>BTW I think I should also point out that an aborting landing pad is not inherently expensive: it's super cheap in GCC but not so in Clang/LLVM: <a href=\"https://godbolt.org/z/bK34Wrxj7\">https://godbolt.org/z/bK34Wrxj7</a>. I believe that this is GCC encoding the aborting information in LSDA so the personality function calls <code>terminate()</code> (kinda similar to <span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span> 's proposed solution) while in LLVM you don't have the ability to do this and thus an explicit landing pad is needed.</p>",
        "id": 267787811,
        "sender_full_name": "Gary Guo",
        "timestamp": 1642022423
    },
    {
        "content": "<p>I would prefer to keep things simple and not try to support a weird combination that nobody is using anyways.</p>",
        "id": 267827161,
        "sender_full_name": "Amanieu",
        "timestamp": 1642053311
    },
    {
        "content": "<p>We haven't had our biweekly checkin for quite some time, but can we discuss this synchronously in about half an hour?</p>\n<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> <span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> <span class=\"user-mention\" data-user-id=\"303710\">@Gary Guo</span> <span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span> <span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> <span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span></p>",
        "id": 267907916,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1642097246
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143274\">Amanieu</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/Unblocking.20.22C-unwind.22/near/267694089\">said</a>:</p>\n<blockquote>\n<p>It's very unfortunate that \"C-unwind\" is blocked on an edge case behavior when mixing crates compiled with <code>-C panic=unwind</code> and <code>-C panic=abort</code>. Could we simply say that such a combination is not supported?</p>\n<p>The only use case for this at the moment is to allow a pre-built <code>std</code> with <code>-C panic=unwind</code> to link with crates compiled with <code>-C panic=abort</code>, but we could just use an unstable crate attribute on <code>std</code> to override the check in that particular case. The only restriction is that in return, <code>std</code> needs to be careful to not call any <code>\"C-unwind\"</code> functions that could generate a foreign exception which could get passed on to frames compiled with <code>-C panic=abort</code>.</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/Unblocking.20.22C-unwind.22/near/267781474\">said</a>:</p>\n<blockquote>\n<p>Having a single <code>panic=abort</code> crate already forces panics to abort for all rust crates. It is just that <code>panic=abort</code> and <code>panic=unwind</code> crates codegen <code>extern \"C-unwind\"</code> differently enough that mixing them currently allows unwinding past <code>panic=abort</code> crates (rather than abort at the <code>extern \"C-unwind\"</code> boundary) which is UB.</p>\n</blockquote>\n<p>I'm not certain I'm following. It sounds like <span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> is talking about dynamically linking binaries, whereas <span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span> is talking about the more typical situation of static compilation. Is that correct?</p>",
        "id": 267911547,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1642099030
    },
    {
        "content": "<p>sorry</p>",
        "id": 270449954,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1643832670
    },
    {
        "content": "<p>I've been totally checked out from this</p>",
        "id": 270449959,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1643832673
    }
]