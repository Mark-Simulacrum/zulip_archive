[
    {
        "content": "<p>I opened <a href=\"https://github.com/rust-lang/rust/issues/92911\">#92911</a> to guard against double unwinding case.</p>",
        "id": 268091732,
        "sender_full_name": "Gary Guo",
        "timestamp": 1642206153
    },
    {
        "content": "<p>Another possible approach is to add a <code>foreign_unwind_enter</code> call when an C-unwind function unwinds to Rust code and call <code>foreign_unwind_leave</code> when Rust code unwinds out from an <code>extern \"C-unwind\"</code> function. The enter function could incremenet a counter and the leave function decrement it. Then PANIC_COUNT plus this counter can be used to determine if unwinding is currently in progress.</p>",
        "id": 268206896,
        "sender_full_name": "Gary Guo",
        "timestamp": 1642367244
    },
    {
        "content": "<p>Could that be at the discretion of the implementation (abort/terminate out of Destructor vs. immediate abort)?</p>",
        "id": 268207061,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642367423
    },
    {
        "content": "<p>What does immediate abort mean here? Second unwinding never takes place instead of unwinding and abort when it reaches Rust code?</p>",
        "id": 268207167,
        "sender_full_name": "Gary Guo",
        "timestamp": 1642367586
    },
    {
        "content": "<p>AFAIK with MSVC SEH it's not possible to do multiple unwinds and it will always cause an immediate abort.</p>",
        "id": 268207228,
        "sender_full_name": "Gary Guo",
        "timestamp": 1642367649
    },
    {
        "content": "<p>I'm personally not too happy about <code>PANIC_COUNT</code> because it prevents things like using <code>catch_unwind</code> in a drop during unwinding. I would much prefer basing the decision of whether to abort immediately on the unwinding information.</p>",
        "id": 268214431,
        "sender_full_name": "Amanieu",
        "timestamp": 1642377464
    },
    {
        "content": "<p>It's unfortunately needed for <a href=\"https://doc.rust-lang.org/nightly/std/thread/fn.panicking.html\">std::thread::panicking</a> which is stable (and which I am not particularly a fan of either).</p>",
        "id": 268214510,
        "sender_full_name": "Amanieu",
        "timestamp": 1642377589
    },
    {
        "content": "<p>We used to update PANIC_COUNT in <code>catch_unwind</code> but this was removed because we wanted it to be zero-cost.</p>",
        "id": 268214628,
        "sender_full_name": "Amanieu",
        "timestamp": 1642377651
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143274\">Amanieu</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/Double.20unwind/near/268214431\">said</a>:</p>\n<blockquote>\n<p>I'm personally not too happy about <code>PANIC_COUNT</code> because it prevents things like using <code>catch_unwind</code> in a drop during unwinding. I would much prefer basing the decision of whether to abort immediately on the unwinding information.</p>\n</blockquote>\n<p>In that case we would definitely need to guard against double unwinding (like <a href=\"https://github.com/rust-lang/rust/issues/92911\">#92911</a> does). <code>PANIC_COUNT</code> does seem like a cheaper option (at least in terms of compile time)</p>",
        "id": 268216058,
        "sender_full_name": "Gary Guo",
        "timestamp": 1642379667
    },
    {
        "content": "<p>The best way seems to improve LLVM so that it can encode an \"terminate\" action like GCC does.</p>",
        "id": 268216151,
        "sender_full_name": "Gary Guo",
        "timestamp": 1642379829
    },
    {
        "content": "<p>There's been discussions about this on the LLVM mailing list, I can't remember what the main issues were.</p>",
        "id": 268216377,
        "sender_full_name": "Amanieu",
        "timestamp": 1642380236
    },
    {
        "content": "<p><a href=\"https://lists.llvm.org/pipermail/llvm-dev/2014-May/072892.html\">https://lists.llvm.org/pipermail/llvm-dev/2014-May/072892.html</a></p>",
        "id": 268216489,
        "sender_full_name": "Amanieu",
        "timestamp": 1642380374
    },
    {
        "content": "<p>Basically it gets tricky when inlining is involved.</p>",
        "id": 268216493,
        "sender_full_name": "Amanieu",
        "timestamp": 1642380386
    },
    {
        "content": "<p>TBH it's only \"tricky\" when GCC-compatible LSDA needs to be produced. If there is a way to encode arbitrary LSDA then it would be fairly straightforward (but I guess then even a larger scale change is needed for LLVM).</p>",
        "id": 268216667,
        "sender_full_name": "Gary Guo",
        "timestamp": 1642380678
    },
    {
        "content": "<blockquote>\n<p>What does immediate abort mean here? Second unwinding never takes place instead of unwinding and abort when it reaches Rust code?</p>\n</blockquote>\n<p>Or abort when it does reach rust code, rather than when it exits the destructor.</p>",
        "id": 268216677,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642380709
    },
    {
        "content": "<p>It's possible if we encode terminate info in LSDA (aka not possible at the moment with LLVM)</p>",
        "id": 268216825,
        "sender_full_name": "Gary Guo",
        "timestamp": 1642380866
    },
    {
        "content": "<p>To prevent the destructor from running then the info must be available to the personality function</p>",
        "id": 268216834,
        "sender_full_name": "Gary Guo",
        "timestamp": 1642380885
    },
    {
        "content": "<p>Could it be made that an implementation is permitted to do that, though?</p>",
        "id": 268216936,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642381064
    },
    {
        "content": "<p>I don't think we have any specification in that regard yet, so we certainly <em>could</em>. And actually I think it's preferred to abort early.</p>",
        "id": 268217244,
        "sender_full_name": "Gary Guo",
        "timestamp": 1642381391
    },
    {
        "content": "<p>Indeed, though by the same, I would also prefer the option to abort when it leaves the destructor.</p>",
        "id": 268217449,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642381609
    }
]