[
    {
        "content": "<p>Trying out a sync meeting for the first time in a while...</p>\n<p>Context is in the <code>Unblocking \"C-unwind\"</code> thread.</p>\n<p><span class=\"user-group-mention\" data-user-group-id=\"1866\">@WG-ffi-unwind</span></p>",
        "id": 267911067,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1642098783
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303710\">Gary Guo</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/Unblocking.20.22C-unwind.22/near/267776801\">said</a>:</p>\n<blockquote>\n<p>I wonder if there are use cases where a library requires unwinding to function correctly internally, but this use case sounds fairly niche.</p>\n</blockquote>\n<p>There are; I believe we had some examples brought up before, but unfortunately I'm struggling to remember the specifics.</p>",
        "id": 267911323,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1642098913
    },
    {
        "content": "<p>I do know of one example: libfringe uses unwinding to clean up coroutine stacks when they are dropped.</p>",
        "id": 267911438,
        "sender_full_name": "Amanieu",
        "timestamp": 1642098963
    },
    {
        "content": "<p>But I'm not sure that's directly relevant to this topic.</p>",
        "id": 267911467,
        "sender_full_name": "Amanieu",
        "timestamp": 1642098981
    },
    {
        "content": "<p>Anyways, what I am proposing is to simply disallow mixing panic=abort crates with panic=unwind crates. With one big exception for the standard library.</p>",
        "id": 267911550,
        "sender_full_name": "Amanieu",
        "timestamp": 1642099031
    },
    {
        "content": "<p>Ah, my <a href=\"https://docs.rs/stackful/latest/stackful/\"><code>stackful</code></a> crate also uses unwinding for cancellation. But yeah I don't think this is related to FFI unwind.</p>",
        "id": 267911623,
        "sender_full_name": "Gary Guo",
        "timestamp": 1642099073
    },
    {
        "content": "<p>How would <code>extern \"C-unwind\"</code> work in this case for foreign Rust-Rust (Externally linked, but defined in rust and called from rust) unwinding, involving only one implementation, or two unwind-compatible implementations.</p>",
        "id": 267911636,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642099076
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> would that mean that there would be no way for a crate to be \"agnostic\" about unwinding? That seems very non-desirable.</p>",
        "id": 267911711,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1642099101
    },
    {
        "content": "<p>(Where the caller side is panic=abort, and the calee is panic=unwind)</p>",
        "id": 267911715,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642099103
    },
    {
        "content": "<p>I would just say that it's UB if a panic happens.</p>",
        "id": 267911756,
        "sender_full_name": "Amanieu",
        "timestamp": 1642099124
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/meeting.202022-1-13/near/267911636\">said</a>:</p>\n<blockquote>\n<p>How would <code>extern \"C-unwind\"</code> work in this case for foreign Rust-Rust (Externally linked, but defined in rust and called from rust) unwinding, involving only one implementation, or two unwind-compatible implementations.</p>\n</blockquote>\n<p>Yeah, I have been thinking about this as well.</p>",
        "id": 267911769,
        "sender_full_name": "Gary Guo",
        "timestamp": 1642099134
    },
    {
        "content": "<blockquote>\n<p>I'm not certain I'm following. It sounds like @Amanieu is talking about dynamically linking binaries, whereas @bjorn3 is talking about the more typical situation of static compilation. Is that correct?</p>\n</blockquote>\n<p>When dynamically linking the <code>panic=...</code> is forced by the dynamic library. If a dynamic library is <code>panic=unwind</code>, it is impossible for a <code>panic=abort</code> crate to depend on it.</p>",
        "id": 267911775,
        "sender_full_name": "bjorn3",
        "timestamp": 1642099136
    },
    {
        "content": "<p>That could only apply to dylib crates, though, right?</p>",
        "id": 267911878,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642099199
    },
    {
        "content": "<p>This is talking about a Rust dynamic library rather than a cdylib, right?</p>",
        "id": 267911913,
        "sender_full_name": "Gary Guo",
        "timestamp": 1642099209
    },
    {
        "content": "<p>Is this really something that people are relying on right now? I believe it's currently UB to unwind through panic=abort code, so at the very least we're not making the situation worse.</p>",
        "id": 267911914,
        "sender_full_name": "Amanieu",
        "timestamp": 1642099212
    },
    {
        "content": "<p>Yes, for static linking using any panic=abort crate forces everything panic=abort.</p>",
        "id": 267911942,
        "sender_full_name": "bjorn3",
        "timestamp": 1642099228
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303710\">Gary Guo</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/meeting.202022-1-13/near/267911913\">said</a>:</p>\n<blockquote>\n<p>This is talking about a Rust dynamic library rather than a cdylib, right?</p>\n</blockquote>\n<p>In my case, it's being <em>used</em> as a cdylib (though it's written in Rust).</p>",
        "id": 267911983,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642099253
    },
    {
        "content": "<p>Yeah, I think <span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> is talking about a cdylib uses unwinding and something that depends on that cdylib using <code>extern \"Rust\"</code></p>",
        "id": 267912040,
        "sender_full_name": "Gary Guo",
        "timestamp": 1642099288
    },
    {
        "content": "<p>In this case I don't UB is desirable if the cdylib panics.</p>",
        "id": 267912069,
        "sender_full_name": "Gary Guo",
        "timestamp": 1642099303
    },
    {
        "content": "<p>A cdylib should never export an <code>extern \"Rust\"</code> function. That is unsound as it allows unwinding across multiple unwind runtimes/standard libraries when using <code>panic=unwind</code>.</p>",
        "id": 267912193,
        "sender_full_name": "bjorn3",
        "timestamp": 1642099353
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/meeting.202022-1-13/near/267911942\">said</a>:</p>\n<blockquote>\n<p>Yes, for static linking using any panic=abort crate forces everything panic=abort.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> to be clear -- you're not suggesting that statically linking <code>panic=unwind</code> crates with <code>panic=abort</code> crates would be a problem, are you? <code>panic=unwind</code> should \"coerce\" to <code>panic=abort</code> in that case.</p>",
        "id": 267912224,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1642099371
    },
    {
        "content": "<p>If you use <code>extern \"C\"</code>/<code>extern \"C-unwind\"</code> at module boundaries then everything works fine.</p>",
        "id": 267912253,
        "sender_full_name": "Amanieu",
        "timestamp": 1642099389
    },
    {
        "content": "<p>The whole problem is that using a <code>panic=unwind</code> crate calling an <code>extern \"C-unwind</code> function from a <code>panic=abort</code>crate is unsound as it doesn't abort at the moment.</p>",
        "id": 267912316,
        "sender_full_name": "bjorn3",
        "timestamp": 1642099426
    },
    {
        "content": "<p>It's just <code>extern \"Rust\"</code> that is a problem since you can't know whether it is <code>nounwind</code> unless you know which <code>-C panic=XXX</code> option was used to compile it.</p>",
        "id": 267912388,
        "sender_full_name": "Amanieu",
        "timestamp": 1642099447
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/meeting.202022-1-13/near/267912193\">said</a>:</p>\n<blockquote>\n<p>A cdylib should never export an <code>extern \"Rust\"</code> function. That is unsound as it allows unwinding across multiple unwind runtimes/standard libraries when using <code>panic=unwind</code>.</p>\n</blockquote>\n<p>It could, if the crate is aware of how it works. For example, in lccc (host), I have plans to replace the <code>rustcall</code> macro, which controls the ABI according to target, with merely <code>extern \"Rust\"</code> if the host supports the correct ABI.</p>",
        "id": 267912436,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642099472
    },
    {
        "content": "<p>Essentially <code>extern \"Rust\"</code> means \"I <strong>know</strong> this function was compiled with the same panic model as me\"</p>",
        "id": 267912480,
        "sender_full_name": "Amanieu",
        "timestamp": 1642099500
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143274\">Amanieu</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/meeting.202022-1-13/near/267912388\">said</a>:</p>\n<blockquote>\n<p>It's just <code>extern \"Rust\"</code> that is a problem since you can't know whether it is <code>nounwind</code> unless you know which <code>-C panic=XXX</code> option was used to compile it.</p>\n</blockquote>\n<p>Ignoring <code>panic=unwind</code> <code>extern \"C-unwind\"</code>, <code>extern \"Rust\"</code> can't unwind if any crate in the crate graph is <code>panic=abort</code>. The panic runtime would cause any panic to abort.</p>",
        "id": 267912519,
        "sender_full_name": "bjorn3",
        "timestamp": 1642099521
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143274\">Amanieu</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/meeting.202022-1-13/near/267912388\">said</a>:</p>\n<blockquote>\n<p>It's just <code>extern \"Rust\"</code> that is a problem since you can't know whether it is <code>nounwind</code> unless you know which <code>-C panic=XXX</code> option was used to compile it.</p>\n</blockquote>\n<p>Sounds like that <code>extern \"Rust\"</code> couldn't be used correctly in cdylib/staticlib then? Shall we just ban it?</p>",
        "id": 267912742,
        "sender_full_name": "Gary Guo",
        "timestamp": 1642099633
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/meeting.202022-1-13/near/267912436\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/meeting.202022-1-13/near/267912193\">said</a>:</p>\n<blockquote>\n<p>A cdylib should never export an <code>extern \"Rust\"</code> function. That is unsound as it allows unwinding across multiple unwind runtimes/standard libraries when using <code>panic=unwind</code>.</p>\n</blockquote>\n<p>It could, if the crate is aware of how it works. For example, in lccc (host), I have plans to replace the <code>rustcall</code> macro, which controls the ABI according to target, with merely <code>extern \"Rust\"</code> if the host supports the correct ABI.</p>\n</blockquote>\n<p>The cdylib contains one copy of the panic runtime and the standard library. The user of the cdylib contains another copy. The standard library maintains an internal panic count which isn't shared between the two standard library copies.</p>",
        "id": 267912752,
        "sender_full_name": "bjorn3",
        "timestamp": 1642099636
    },
    {
        "content": "<p>That seems like an internal implementation detail here.</p>",
        "id": 267912818,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642099672
    },
    {
        "content": "<p>Why is the entire standard library included in a dylib? Shouldn't it be dynamically linked?</p>",
        "id": 267912884,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1642099690
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303710\">Gary Guo</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/meeting.202022-1-13/near/267912742\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"143274\">Amanieu</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/meeting.202022-1-13/near/267912388\">said</a>:</p>\n<blockquote>\n<p>It's just <code>extern \"Rust\"</code> that is a problem since you can't know whether it is <code>nounwind</code> unless you know which <code>-C panic=XXX</code> option was used to compile it.</p>\n</blockquote>\n<p>Sounds like that <code>extern \"Rust\"</code> couldn't be used correctly in cdylib/staticlib then? Shall we just ban it?</p>\n</blockquote>\n<p>It can be used correctly for as long as the definition and the user are in the same crate graph. For example libcore and libstd use it for sharing some functions.</p>",
        "id": 267912903,
        "sender_full_name": "bjorn3",
        "timestamp": 1642099699
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120076\">BatmanAoD (Kyle Strand)</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/meeting.202022-1-13/near/267912884\">said</a>:</p>\n<blockquote>\n<p>Why is the entire standard library included in a dylib? Shouldn't it be dynamically linked?</p>\n</blockquote>\n<p>The standard library is only dynamically linked if you use <code>-Cprefer-dynamic</code>.</p>",
        "id": 267912953,
        "sender_full_name": "bjorn3",
        "timestamp": 1642099725
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120076\">BatmanAoD (Kyle Strand)</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/meeting.202022-1-13/near/267912884\">said</a>:</p>\n<blockquote>\n<p>Why is the entire standard library included in a dylib? Shouldn't it be dynamically linked?</p>\n</blockquote>\n<p>I think it can still be statically linked, but it would be odd if a dylib or cdylib didn't prefer dynamic linking for the stdlib.</p>",
        "id": 267912965,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642099731
    },
    {
        "content": "<blockquote>\n<p>The standard library maintains an internal panic count which isn't shared between the two standard library copies.</p>\n</blockquote>\n<p>Sounds like an issue because these different copies use the same signature for the exceptions so they are considered compatible by the unwinding runtime.</p>",
        "id": 267913030,
        "sender_full_name": "Gary Guo",
        "timestamp": 1642099773
    },
    {
        "content": "<p>For a cdylib you likely don't want to copy around libstd if you distribute it. Also I don't think there is an officially stable way to determine the filename of libstd-*.so.</p>",
        "id": 267913069,
        "sender_full_name": "bjorn3",
        "timestamp": 1642099789
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/meeting.202022-1-13/near/267913069\">said</a>:</p>\n<blockquote>\n<p>For a cdylib you likely don't want to copy around libstd if you distribute it.<br>\n</p>\n</blockquote>\n<p>Maybe a stupid question, but why not?</p>",
        "id": 267913141,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1642099808
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/meeting.202022-1-13/near/267913069\">said</a>:</p>\n<blockquote>\n<p>For a cdylib you likely don't want to copy around libstd if you distribute it. Also I don't think there is an officially stable way to determine the filename of libstd-*.so.</p>\n</blockquote>\n<p>SONAME would do this, at least on ELF platforms.</p>",
        "id": 267913173,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642099828
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/meeting.202022-1-13/near/267913173\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/meeting.202022-1-13/near/267913069\">said</a>:</p>\n<blockquote>\n<p>For a cdylib you likely don't want to copy around libstd if you distribute it. Also I don't think there is an officially stable way to determine the filename of libstd-*.so.</p>\n</blockquote>\n<p>SONAME would do this, at least on ELF platforms.</p>\n</blockquote>\n<p>Rust uses a hash in the filename instead of SONAME. It is just that I don't think we guarantee anything about the actual filename. The directory to find it in is accessible on stable though as <code>rustc --print target-libdir</code>.</p>",
        "id": 267913310,
        "sender_full_name": "bjorn3",
        "timestamp": 1642099916
    },
    {
        "content": "<p>You could include that full filename in SONAME, and expose it - the DT_NEEDED entry will use the SONAME item, rather than the file name passed to the linker. That's my plan on lccc for dynamic linking of <code>libstd</code> (although the filename for libstd would look more like <code>libstd.so.0.1</code>).</p>",
        "id": 267913648,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642100043
    },
    {
        "content": "<p>So is it correct to say that any <code>extern \"Rust\"</code> <em>exported</em> by cdylib or staticlib shouldn't be used?</p>",
        "id": 267913666,
        "sender_full_name": "Gary Guo",
        "timestamp": 1642100051
    },
    {
        "content": "<p>Yes</p>",
        "id": 267913716,
        "sender_full_name": "Amanieu",
        "timestamp": 1642100074
    },
    {
        "content": "<p>Wouldn't the same reasoning given above apply even to <code>dylib</code> crates?</p>",
        "id": 267913834,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642100135
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/meeting.202022-1-13/near/267913648\">said</a>:</p>\n<blockquote>\n<p>You could include that full filename in SONAME, and expose it - the DT_NEEDED entry will use the SONAME item, rather than the file name passed to the linker. That's my plan on lccc for dynamic linking of <code>libstd</code> (although the filename for libstd would look more like <code>libstd.so.0.1</code>).</p>\n</blockquote>\n<p>The DT_NEEDED entry already contains something like <code>libstd-7c582493123fc1dd.so</code> as that is the real filename. It is just that I don't think we guarantee that it matches <code>libstd-*.so</code> and not say <code>librust_internal_std-*.so</code>.</p>",
        "id": 267913859,
        "sender_full_name": "bjorn3",
        "timestamp": 1642100151
    },
    {
        "content": "<p>(Outside of the unwind-&gt;abort issue)</p>",
        "id": 267913861,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642100152
    },
    {
        "content": "<p>dylib crates share a single dynamically linked <a href=\"http://libstd.so\">libstd.so</a>, so that's not a problem.</p>",
        "id": 267913956,
        "sender_full_name": "Amanieu",
        "timestamp": 1642100181
    },
    {
        "content": "<p>For dylib crates rustc already ensures that the standard library (and any other crate) is only included once.</p>",
        "id": 267913958,
        "sender_full_name": "bjorn3",
        "timestamp": 1642100182
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143274\">Amanieu</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/meeting.202022-1-13/near/267913956\">said</a>:</p>\n<blockquote>\n<p>dylib crates share a single dynamically linked <a href=\"http://libstd.so\">libstd.so</a>, so that's not a problem.</p>\n</blockquote>\n<p>Dylib crates are statically linked to libstd by default too.</p>",
        "id": 267913986,
        "sender_full_name": "bjorn3",
        "timestamp": 1642100199
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/meeting.202022-1-13/near/267913958\">said</a>:</p>\n<blockquote>\n<p>For dylib crates rustc already ensures that the standard library (and any other crate) is only included once.</p>\n</blockquote>\n<p>It gives a compiler error if you try to include it from two rust dynamic libraries. Rust dynamic libraries (not cdylib) export all symbols from all crates included in the dylib.</p>",
        "id": 267914073,
        "sender_full_name": "bjorn3",
        "timestamp": 1642100243
    },
    {
        "content": "<p>This is rustc (cargo?) forcing a library to be dynamic in case of a diamond dependency, is it?</p>",
        "id": 267914116,
        "sender_full_name": "Gary Guo",
        "timestamp": 1642100269
    },
    {
        "content": "<p>Anyways, what I want to get out of this meeting is to unblock the stabilization of <code>c_unwind</code>. The only blocker is the handling of <code>extern \"Rust\"</code> functions in a mixed panic=unwind/panic=abort crate graph. Can we simply say that such a configuration is outside the scope of the RFC and just not support it?</p>",
        "id": 267914192,
        "sender_full_name": "Amanieu",
        "timestamp": 1642100295
    },
    {
        "content": "<p>In case of a diamond dependency the library has to be dynamic to avoid a compiler error. Unfortunately cargo doesn't force it to be a dynamic library currently, so you often get compiler errors when using dynamic libraries. I really hope that the dynamic linking situation of rust will eventually become better.</p>",
        "id": 267914264,
        "sender_full_name": "bjorn3",
        "timestamp": 1642100343
    },
    {
        "content": "<p>We don't have a stable way to create a mixed panic=unwind/panic=abort graph with Cargo (apart from libstd), don't we?</p>",
        "id": 267914304,
        "sender_full_name": "Gary Guo",
        "timestamp": 1642100363
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303710\">Gary Guo</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/meeting.202022-1-13/near/267914304\">said</a>:</p>\n<blockquote>\n<p>We don't have a stable way to create a mixed panic=unwind/panic=abort graph with Cargo (apart from libstd), don't we?</p>\n</blockquote>\n<p>Not from cargo I believe. You can by manually invoking rustc or using another build system.</p>",
        "id": 267914364,
        "sender_full_name": "bjorn3",
        "timestamp": 1642100392
    },
    {
        "content": "<p>IIRC direct rustc invocation isn't part of stability guarantee?</p>",
        "id": 267914540,
        "sender_full_name": "Gary Guo",
        "timestamp": 1642100434
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303710\">Gary Guo</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/meeting.202022-1-13/near/267914540\">said</a>:</p>\n<blockquote>\n<p>IIRC direct rustc invocation isn't part of stability guarantee?</p>\n</blockquote>\n<p>AFAIK it is. I surely hope so for all non-cargo users.</p>",
        "id": 267914580,
        "sender_full_name": "bjorn3",
        "timestamp": 1642100452
    },
    {
        "content": "<p>Isn't it? I'd be fairly suprised if it wasn't, especially for the parts that are explicitly exposed to cargo.</p>",
        "id": 267914610,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642100460
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143274\">Amanieu</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/meeting.202022-1-13/near/267914192\">said</a>:</p>\n<blockquote>\n<p>Anyways, what I want to get out of this meeting is to unblock the stabilization of <code>c_unwind</code>. The only blocker is the handling of <code>extern \"Rust\"</code> functions in a mixed panic=unwind/panic=abort crate graph. Can we simply say that such a configuration is outside the scope of the RFC and just not support it?</p>\n</blockquote>\n<p>The easiest solution is to make <code>extern \"C-unwind\"</code> abort for panic=unwind crates too if any crate is panic=abort. Just have the personality function check if the panic_abort or panic_unwind runtime is used.</p>",
        "id": 267914612,
        "sender_full_name": "bjorn3",
        "timestamp": 1642100461
    },
    {
        "content": "<p>I thought that the issues preventing stabilization apply to normal Rust compilation wherein at least one crate is marked <code>panic=abort</code> but not all are marked that way. That's _certainly_ a use case we don't want to break, I think.</p>",
        "id": 267914636,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1642100471
    },
    {
        "content": "<p>Note that this is only observable with foreign exceptions escaping from panic=unwind code into panic=abort code. Since foreign exceptions in Rust code are currently UB we're not breaking anything stable.</p>",
        "id": 267914665,
        "sender_full_name": "Amanieu",
        "timestamp": 1642100486
    },
    {
        "content": "<p>Rust panics will never generate an exception since the panic runtime will abort immediately.</p>",
        "id": 267914703,
        "sender_full_name": "Amanieu",
        "timestamp": 1642100502
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143274\">Amanieu</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/meeting.202022-1-13/near/267914665\">said</a>:</p>\n<blockquote>\n<p>Note that this is only observable with foreign exceptions escaping from panic=unwind code into panic=abort code. Since foreign exceptions in Rust code are currently UB we're not breaking anything stable.</p>\n</blockquote>\n<p>Yeah, but I am trying to figure out if the mixed panic=unwind/panic=abort graph is currently considered stable.</p>",
        "id": 267914811,
        "sender_full_name": "Gary Guo",
        "timestamp": 1642100535
    },
    {
        "content": "<p>Or are you suggesting that we only conditionally disallow it if \"C-unwind\" is being used?</p>",
        "id": 267914854,
        "sender_full_name": "Gary Guo",
        "timestamp": 1642100555
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303710\">Gary Guo</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/meeting.202022-1-13/near/267914854\">said</a>:</p>\n<blockquote>\n<p>Or are you suggesting that we only conditionally disallow it if \"C-unwind\" is being used?</p>\n</blockquote>\n<p>The standard library internally uses it in a couple of places, so that would still be a breaking change.</p>",
        "id": 267914948,
        "sender_full_name": "bjorn3",
        "timestamp": 1642100588
    },
    {
        "content": "<p>Well, <span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> does mention a magic escape hatch for std.</p>",
        "id": 267914987,
        "sender_full_name": "Gary Guo",
        "timestamp": 1642100609
    },
    {
        "content": "<p>Magic escape hatches sound <em>fun</em> tbh.</p>",
        "id": 267915034,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642100632
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/meeting.202022-1-13/near/267914612\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"143274\">Amanieu</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/meeting.202022-1-13/near/267914192\">said</a>:</p>\n<blockquote>\n<p>Anyways, what I want to get out of this meeting is to unblock the stabilization of <code>c_unwind</code>. The only blocker is the handling of <code>extern \"Rust\"</code> functions in a mixed panic=unwind/panic=abort crate graph. Can we simply say that such a configuration is outside the scope of the RFC and just not support it?</p>\n</blockquote>\n<p>The easiest solution is to make <code>extern \"C-unwind\"</code> abort for panic=unwind crates too if any crate is panic=abort. Just have the personality function check if the panic_abort or panic_unwind runtime is used.</p>\n</blockquote>\n<p>Do you agree <span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span>?</p>",
        "id": 267915214,
        "sender_full_name": "bjorn3",
        "timestamp": 1642100694
    },
    {
        "content": "<p>I prefer to have the personality function being agnostic to the panic runtime. (As I maintain a separate personality function and panic runtime impl myself)</p>",
        "id": 267915437,
        "sender_full_name": "Gary Guo",
        "timestamp": 1642100774
    },
    {
        "content": "<p>It only needs to be a single <code>static ALLOWS_UNWINDING_ACROSS_C_UNWIND: bool</code>.</p>",
        "id": 267915525,
        "sender_full_name": "bjorn3",
        "timestamp": 1642100822
    },
    {
        "content": "<p>Same. In case you missed it, here's my PR moving the personality functions to <code>std</code> so they are independent of the panic runtime: <a href=\"https://github.com/rust-lang/rust/pull/92845\">https://github.com/rust-lang/rust/pull/92845</a></p>",
        "id": 267915534,
        "sender_full_name": "Amanieu",
        "timestamp": 1642100827
    },
    {
        "content": "<p>I saw that PR. The personality function in std could read <code>ALLOWS_UNWINDING_ACROSS_C_UNWIND</code> from the panic runtime and abort if it is false <strong>and</strong> we are currently unwinding.</p>",
        "id": 267915677,
        "sender_full_name": "bjorn3",
        "timestamp": 1642100886
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303710\">Gary Guo</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/meeting.202022-1-13/near/267915437\">said</a>:</p>\n<blockquote>\n<p>I prefer to have the personality function being agnostic to the panic runtime. (As I maintain a separate personality function and panic runtime impl myself)</p>\n</blockquote>\n<p>Same for me. I use replacement in lccc's stdlib inside <code>libproc_macro</code>. That way, panics from proc-macros can be caught inside the host compiler.</p>",
        "id": 267915719,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642100908
    },
    {
        "content": "<p>You could make sure that the proc macro doesn't see the host <code>ALLOWS_UNWINDING_ACROSS_C_UNWIND</code> static.</p>",
        "id": 267915822,
        "sender_full_name": "bjorn3",
        "timestamp": 1642100958
    },
    {
        "content": "<p>I would hope this EH personality eventually be moved into libcore or something that <code>#![no_std]</code> binary could use directly, and having it additionally require a boolean doesn't sound good.</p>",
        "id": 267915833,
        "sender_full_name": "Gary Guo",
        "timestamp": 1642100964
    },
    {
        "content": "<p>Currently the personality function is completely independent of the panic runtime. It works purely off the DWARF metadata associated with the function.</p>",
        "id": 267915939,
        "sender_full_name": "Amanieu",
        "timestamp": 1642101005
    },
    {
        "content": "<p>Yeah, I would love to keep it this way.</p>",
        "id": 267915971,
        "sender_full_name": "Gary Guo",
        "timestamp": 1642101023
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/meeting.202022-1-13/near/267915822\">said</a>:</p>\n<blockquote>\n<p>You could make sure that the proc macro doesn't see the host <code>ALLOWS_UNWINDING_ACROSS_C_UNWIND</code> static.</p>\n</blockquote>\n<p>Well that's easy, though that reprevokes the <code>unwind=abort</code> issue, since host could be compiled with RUSTFLAGS=\"-C panic=abort\"`. Possibly something I could solve internally, though.</p>",
        "id": 267915978,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642101027
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303710\">Gary Guo</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/meeting.202022-1-13/near/267915833\">said</a>:</p>\n<blockquote>\n<p>I would hope this EH personality eventually be moved into libcore or something that <code>#![no_std]</code> binary could use directly, and having it additionally require a boolean doesn't sound good.</p>\n</blockquote>\n<p>Initiating a panic to unwind requires the panic runtime anyway.</p>",
        "id": 267916058,
        "sender_full_name": "bjorn3",
        "timestamp": 1642101079
    },
    {
        "content": "<p>We can make a (new) panic runtime no_std compatible though.</p>",
        "id": 267916113,
        "sender_full_name": "bjorn3",
        "timestamp": 1642101111
    },
    {
        "content": "<p>Not for foreign exception unwinding through Rust frames (as long as it's not caught by Rust)</p>",
        "id": 267916183,
        "sender_full_name": "Gary Guo",
        "timestamp": 1642101129
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/meeting.202022-1-13/near/267916058\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"303710\">Gary Guo</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/meeting.202022-1-13/near/267915833\">said</a>:</p>\n<blockquote>\n<p>I would hope this EH personality eventually be moved into libcore or something that <code>#![no_std]</code> binary could use directly, and having it additionally require a boolean doesn't sound good.</p>\n</blockquote>\n<p>Initiating a panic to unwind requires the panic runtime anyway.</p>\n</blockquote>\n<p>Well, it requires <em>a</em> panic runtime. Which is easy enough to write if you have libgcc/libunwind.</p>",
        "id": 267916191,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642101134
    },
    {
        "content": "<p>It requires a <em>unwind runtime</em> but not a <em>panic runtime</em></p>",
        "id": 267916227,
        "sender_full_name": "Gary Guo",
        "timestamp": 1642101154
    },
    {
        "content": "<p>The panic runtime is what determines if a panic unwinds or aborts. <code>-Cpanic=abort</code> works by switching from panic_unwind to panic_abort as panic runtime. Not emitting landingpads is just an optimization.</p>",
        "id": 267916364,
        "sender_full_name": "bjorn3",
        "timestamp": 1642101223
    },
    {
        "content": "<p>(I'd be interested to see what happens if I set up an exception frame in <code>#![no_std]</code> panic=unwind, that looks like the one specified in the lcrust abi and let it through rustc generated code... probably nothing good currently)</p>",
        "id": 267916366,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642101226
    },
    {
        "content": "<p>How about this: if a crate uses both <code>extern \"C-unwind\"</code> and <code>-C panic=unwind</code> then it cannot be included in the same crate graph as a crate compiled with <code>-C panic=abort</code>. We use a special escape hatch for <code>std</code> and the panic runtimes since know that their uses of <code>extern \"C-unwind\"</code> are only for Rust panics.</p>",
        "id": 267916376,
        "sender_full_name": "Amanieu",
        "timestamp": 1642101232
    },
    {
        "content": "<p>In other words, if a <code>panic=unwind</code> crate can receive a foreign exception then don't allow it to link with <code>panic=abort</code> crates.</p>",
        "id": 267916581,
        "sender_full_name": "Amanieu",
        "timestamp": 1642101318
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/meeting.202022-1-13/near/267916191\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/meeting.202022-1-13/near/267916058\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"303710\">Gary Guo</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/meeting.202022-1-13/near/267915833\">said</a>:</p>\n<blockquote>\n<p>I would hope this EH personality eventually be moved into libcore or something that <code>#![no_std]</code> binary could use directly, and having it additionally require a boolean doesn't sound good.</p>\n</blockquote>\n<p>Initiating a panic to unwind requires the panic runtime anyway.</p>\n</blockquote>\n<p>Well, it requires <em>a</em> panic runtime. Which is easy enough to write if you have libgcc/libunwind.</p>\n</blockquote>\n<p>We don't guarantee that the compiler uses DWARF or SEH based unwinding internally. It may just as well use <code>Result&lt;T, E&gt;</code> internally. Only the boundary presented by <code>extern \"C-unwind</code> is guaranteed to use the platform default.</p>",
        "id": 267916681,
        "sender_full_name": "bjorn3",
        "timestamp": 1642101362
    },
    {
        "content": "<p>True. And even then, I'd imagine rustc doesn't specify <em>how</em> it uses the platform default if it doesn anyways.</p>",
        "id": 267916815,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642101405
    },
    {
        "content": "<p>Even without mixing unwind types: was this ever resolved? <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/mixing.20-Clto.20and.20-Cpanic.3Dabort/near/251763021\">https://rust-lang.zulipchat.com/#narrow/stream/210922-project-ffi-unwind/topic/mixing.20-Clto.20and.20-Cpanic.3Dabort/near/251763021</a></p>",
        "id": 267916855,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1642101420
    },
    {
        "content": "<p>Sounds like std acutally just needs \"C-unwind-if-unwind\"</p>",
        "id": 267916949,
        "sender_full_name": "Gary Guo",
        "timestamp": 1642101464
    },
    {
        "content": "<p>If the platform default isn't used <code>extern \"C-unwind\"</code> has to call into a function to translate between the two. This function would logically be part of the panic runtime as it determines if it aborts or unwinds.</p>",
        "id": 267916957,
        "sender_full_name": "bjorn3",
        "timestamp": 1642101467
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120076\">BatmanAoD (Kyle Strand)</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/meeting.202022-1-13/near/267916855\">said</a>:</p>\n<blockquote>\n<p>Even without mixing unwind types: was this ever resolved? <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/mixing.20-Clto.20and.20-Cpanic.3Dabort/near/251763021\">https://rust-lang.zulipchat.com/#narrow/stream/210922-project-ffi-unwind/topic/mixing.20-Clto.20and.20-Cpanic.3Dabort/near/251763021</a></p>\n</blockquote>\n<p>Not that I know of.</p>",
        "id": 267917053,
        "sender_full_name": "bjorn3",
        "timestamp": 1642101500
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/meeting.202022-1-13/near/267916957\">said</a>:</p>\n<blockquote>\n<p>If the platform default isn't used <code>extern \"C-unwind\"</code> has to call into a function to translate between the two. This function would logically be part of the panic runtime as it determines if it aborts or unwinds.</p>\n</blockquote>\n<p>What if the platform default <em>is</em> used?</p>",
        "id": 267917076,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642101520
    },
    {
        "content": "<p>Then you could still use such a function. It would just either continue unwinding or abort.</p>",
        "id": 267917121,
        "sender_full_name": "bjorn3",
        "timestamp": 1642101543
    },
    {
        "content": "<p>Alright.</p>",
        "id": 267917162,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642101564
    },
    {
        "content": "<p>Specifically: with <code>-Clto -Cpanic=abort</code>, we need to guarantee that <code>extern \"C-unwind\"</code> functions will actually abort if a foreign exception enters, but as of that post, we didn't, because there was a <code>rustc</code> pass that added <code>nounwind</code> everywhere.</p>",
        "id": 267917165,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1642101569
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/meeting.202022-1-13/near/267917053\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120076\">BatmanAoD (Kyle Strand)</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/meeting.202022-1-13/near/267916855\">said</a>:</p>\n<blockquote>\n<p>Even without mixing unwind types: was this ever resolved? <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/mixing.20-Clto.20and.20-Cpanic.3Dabort/near/251763021\">https://rust-lang.zulipchat.com/#narrow/stream/210922-project-ffi-unwind/topic/mixing.20-Clto.20and.20-Cpanic.3Dabort/near/251763021</a></p>\n</blockquote>\n<p>Not that I know of.</p>\n</blockquote>\n<p>I changed rustc to properly mark symbols are <code>nounwind</code> where appropriate so the LLVM pass shouldn't be necessary anymore.</p>",
        "id": 267917265,
        "sender_full_name": "Amanieu",
        "timestamp": 1642101610
    },
    {
        "content": "<p><del>I don't know if it has already been suggested, but could we add an annotation for <code>extern \"C-unwind\"</code> to the llvm ir and skip <code>nounwind</code> if this annotation is present.</del></p>",
        "id": 267917274,
        "sender_full_name": "bjorn3",
        "timestamp": 1642101614
    },
    {
        "content": "<p>^ oh, do you have a link to the PR?</p>",
        "id": 267917341,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1642101649
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/pull/88759/files#diff-622328a29486b5640dd0aafa10dfc044e1129408bc0eb1d10bb52cb061685377L514\">https://github.com/rust-lang/rust/pull/88759/files#diff-622328a29486b5640dd0aafa10dfc044e1129408bc0eb1d10bb52cb061685377L514</a></p>",
        "id": 267917399,
        "sender_full_name": "Amanieu",
        "timestamp": 1642101678
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143274\">Amanieu</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/meeting.202022-1-13/near/267916376\">said</a>:</p>\n<blockquote>\n<p>How about this: if a crate uses both <code>extern \"C-unwind\"</code> and <code>-C panic=unwind</code> then it cannot be included in the same crate graph as a crate compiled with <code>-C panic=abort</code>. We use a special escape hatch for <code>std</code> and the panic runtimes since know that their uses of <code>extern \"C-unwind\"</code> are only for Rust panics.</p>\n</blockquote>\n<p>So far I think this is the best solution.</p>",
        "id": 267917591,
        "sender_full_name": "Gary Guo",
        "timestamp": 1642101763
    },
    {
        "content": "<p>Thank you!</p>",
        "id": 267917593,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1642101764
    },
    {
        "content": "<p>Related to <code>\"C-unwind\"</code> in general, but is it known whether <code>catch_unwind</code> can catch foreign exceptions? I'd think certainly it would have to if said foreign exception also runs destructors while unwinding the stack (as existing, generic code, currently relies on this to avoid inconsistencies in state caused by panics).</p>",
        "id": 267917649,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642101792
    },
    {
        "content": "<p>No, it can't</p>",
        "id": 267917661,
        "sender_full_name": "Gary Guo",
        "timestamp": 1642101803
    },
    {
        "content": "<p>Doing so would cause an abort</p>",
        "id": 267917686,
        "sender_full_name": "Gary Guo",
        "timestamp": 1642101817
    },
    {
        "content": "<p>Would it be allowed to, is a secondary question?</p>",
        "id": 267917703,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642101825
    },
    {
        "content": "<p>Yes it can, but right now it just aborts if a foreign exception is caught.</p>",
        "id": 267917709,
        "sender_full_name": "Amanieu",
        "timestamp": 1642101830
    },
    {
        "content": "<p>IE. is it guaranteed to do so, or is that a limitation of the implementation.</p>",
        "id": 267917781,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642101851
    },
    {
        "content": "<p>In my original implementation you could catch a foreign exception as a <code>Box&lt;Any&gt;</code>, but I changed it to abort instead.</p>",
        "id": 267917802,
        "sender_full_name": "Amanieu",
        "timestamp": 1642101863
    },
    {
        "content": "<p>It's relatively easy to support.</p>",
        "id": 267917827,
        "sender_full_name": "Amanieu",
        "timestamp": 1642101879
    },
    {
        "content": "<p>I think it's just that we haven't decided about what it should do.</p>",
        "id": 267917888,
        "sender_full_name": "Gary Guo",
        "timestamp": 1642101908
    },
    {
        "content": "<p>UB per the RFC, currently</p>",
        "id": 267918130,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1642102045
    },
    {
        "content": "<p>In the abi I specified for lccc, I do mention foreign exceptions. Most of it is handwavy, though it guarantees support of any exceptions that use the same unwinding mechanism, which is almost always the platform default (and the other cases, its unspecified). <br>\nCurrently, it notes the implementation of the abi <em>may</em> support it, and if so, how to expose it (it does so as an exposition-only type, which can only really be inspected as an opaque blob).</p>",
        "id": 267918147,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642102053
    },
    {
        "content": "<p>Would that be potentially useful to incorporate into the RFC?</p>",
        "id": 267918185,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642102076
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143274\">Amanieu</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/meeting.202022-1-13/near/267917265\">said</a>:</p>\n<blockquote>\n<p>I changed rustc to properly mark symbols are <code>nounwind</code> where appropriate so the LLVM pass shouldn't be necessary anymore.</p>\n</blockquote>\n<p>To be clear, it's a <code>rustc</code> pass, not an LLVM pass. So we can remove it, but we haven't yet?</p>",
        "id": 267918349,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1642102140
    },
    {
        "content": "<p>It doesn't have to be, since the RFC allows foreign exception to unwind through Rust frames or Rust exceptions to unwind through foreign frames.</p>",
        "id": 267918389,
        "sender_full_name": "Gary Guo",
        "timestamp": 1642102159
    },
    {
        "content": "<p>Whether it could be caught or not is orthogonal IMO.</p>",
        "id": 267918406,
        "sender_full_name": "Gary Guo",
        "timestamp": 1642102170
    },
    {
        "content": "<p>I think it should at least be noted, especially if foreign exceptions can cause actual stack unwinding (IE. runs destructors), because of the code I mentioned above (is that even specified itself?).</p>",
        "id": 267918635,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642102273
    },
    {
        "content": "<p>^ yes, foreign exceptions are guaranteed to run destructors (i.e. intermediate frames are not required to be \"POF\"s)</p>",
        "id": 267918760,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1642102324
    },
    {
        "content": "<p>A sudden thought, what will happen currently if a destructor panics while the stack is being unwound by a foreign exception?</p>",
        "id": 267918768,
        "sender_full_name": "Gary Guo",
        "timestamp": 1642102327
    },
    {
        "content": "<p>Panic count doesn't know about foreign exceptions.</p>",
        "id": 267918832,
        "sender_full_name": "Gary Guo",
        "timestamp": 1642102358
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303710\">Gary Guo</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/meeting.202022-1-13/near/267918768\">said</a>:</p>\n<blockquote>\n<p>A sudden thought, what will happen currently if a destructor panics while the stack is being unwound by a foreign exception?</p>\n</blockquote>\n<p>That's another question I had. In the aforementioned ABI, I make it unspecified if it immediately aborts, but guarantee it to abort if the panic/second-exception leaves the destructor.</p>",
        "id": 267918846,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642102363
    },
    {
        "content": "<p>Currently, \"fun\" happens. With <code>-Z panic-in-drop=abort</code>, it aborts because <code>drop_in_place</code> is nounwind.</p>",
        "id": 267918887,
        "sender_full_name": "Amanieu",
        "timestamp": 1642102381
    },
    {
        "content": "<p>^ that</p>",
        "id": 267918896,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1642102386
    },
    {
        "content": "<p>and from the PR  (linked above), it looks like <code>panic-in-drop=abort</code> is intended to become the default eventually?</p>",
        "id": 267918933,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1642102409
    },
    {
        "content": "<p>All right, unfortunately I need to drop</p>",
        "id": 267918959,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1642102429
    },
    {
        "content": "<p>thanks for jumping in everyone - maybe we can get syncs started up again if you're interested</p>",
        "id": 267919019,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1642102446
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120076\">BatmanAoD (Kyle Strand)</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/meeting.202022-1-13/near/267918760\">said</a>:</p>\n<blockquote>\n<p>^ yes, foreign exceptions are guaranteed to run destructors (i.e. intermediate frames are not required to be \"POF\"s)</p>\n</blockquote>\n<p>Then it probably needs to be necessary to be able to catch foreign exceptions, otherwise, exsting crates that  use <code>catch_unwind</code> can become unsound in the place of user code that uses C-unwind.</p>",
        "id": 267919024,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642102449
    },
    {
        "content": "<p>I found my old <code>catch_unwind</code> implementation that catch foreign exceptions. They are returned as a <code>Box&lt;ForeignException&gt;</code> in the panic payload, but <code>ForeignException</code> is a ZST that just indicates that an exception happened. You can't actually rethrow the foreign exception.</p>",
        "id": 267919066,
        "sender_full_name": "Amanieu",
        "timestamp": 1642102472
    },
    {
        "content": "<p>It should be pretty easy to just store the exception instead of _Unwind_DeleteException it, and only call _Unwind_DeleteException when <code>ForeignException</code> is dropped.</p>",
        "id": 267919213,
        "sender_full_name": "Gary Guo",
        "timestamp": 1642102547
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143274\">Amanieu</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/meeting.202022-1-13/near/267919066\">said</a>:</p>\n<blockquote>\n<p>I found my old <code>catch_unwind</code> implementation that catch foreign exceptions. They are returned as a <code>Box&lt;ForeignException&gt;</code> in the panic payload, but <code>ForeignException</code> is a ZST that just indicates that an exception happened. You can't actually rethrow the foreign exception.</p>\n</blockquote>\n<p>This is basically exactly what I had specified (I even gate it an explicit name, though made it <em>exposition-only</em> as mentioned above).</p>",
        "id": 267919309,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642102580
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143274\">Amanieu</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/meeting.202022-1-13/near/267918887\">said</a>:</p>\n<blockquote>\n<p>Currently, \"fun\" happens.</p>\n</blockquote>\n<p>I guess this is another blocker then.</p>",
        "id": 267919312,
        "sender_full_name": "Gary Guo",
        "timestamp": 1642102581
    },
    {
        "content": "<p>Well clearly the solution to that is to make <code>-Z panic-in-drop=abort</code> the default.</p>",
        "id": 267919467,
        "sender_full_name": "Amanieu",
        "timestamp": 1642102653
    },
    {
        "content": "<p>I (and others) have some objections to that related to scope guards.</p>",
        "id": 267919577,
        "sender_full_name": "Gary Guo",
        "timestamp": 1642102690
    },
    {
        "content": "<p>I could link to the appropriate section of the ABI spec (it's designated as WIP, but I doubt many more changes will occur unless I have significant problems when implementing it), if it would help give ideas on how to handle edge cases both  in general, and in rustc specifically.</p>",
        "id": 267919592,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642102698
    },
    {
        "content": "<p>How does C++ handle this?</p>",
        "id": 267919599,
        "sender_full_name": "Gary Guo",
        "timestamp": 1642102704
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303710\">Gary Guo</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/meeting.202022-1-13/near/267919599\">said</a>:</p>\n<blockquote>\n<p>How does C++ handle this?</p>\n</blockquote>\n<p>C++ <code>std::terminate</code>s if you exit a destructor with an exception if that destructor is called during stack unwinding.</p>",
        "id": 267919643,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642102736
    },
    {
        "content": "<p>(It specifically allows the second, third, or 10th even exception to be thrown, as long as all of them are caught before the destructor exits, though)</p>",
        "id": 267919707,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642102775
    },
    {
        "content": "<p>I mean through what mechanism does it know that the destructor is called during unwinding.</p>",
        "id": 267919787,
        "sender_full_name": "Gary Guo",
        "timestamp": 1642102803
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303710\">Gary Guo</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/meeting.202022-1-13/near/267919787\">said</a>:</p>\n<blockquote>\n<p>I mean through what mechanism does it know that the destructor is called during unwinding.</p>\n</blockquote>\n<p><del>In theory (a world with just C++ and just C++ exceptions), <code>std::uncaught_exceptions()</code>.</del> Wait, no, since you can execute a destructor normally in that case, and it gets caught.</p>",
        "id": 267919903,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642102880
    },
    {
        "content": "<p>I am specifically talking about foreign exception case though.</p>",
        "id": 267919939,
        "sender_full_name": "Gary Guo",
        "timestamp": 1642102908
    },
    {
        "content": "<p>I assume on Itanium EH, it would just inject a guard frame for the personality routine in the unwinder.</p>",
        "id": 267920045,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642102951
    },
    {
        "content": "<p>I suppose we could do the same then?</p>",
        "id": 267920093,
        "sender_full_name": "Gary Guo",
        "timestamp": 1642102987
    },
    {
        "content": "<p>Probably. It should work similarily for SEH and SJLJ, IIRC.</p>",
        "id": 267920146,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642103017
    },
    {
        "content": "<p>C++ marks the destructor as <code>nounwind</code> and adds a hidden <code>try {} catch (...)</code> around the destructor that calls <code>std::terminate</code> if an exception tries to escape the destructor. Basically the exact same thing I am doing with <code>-Z panic-in-drop=abort</code>.</p>",
        "id": 267922344,
        "sender_full_name": "Amanieu",
        "timestamp": 1642104052
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143274\">Amanieu</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/meeting.202022-1-13/near/267922344\">said</a>:</p>\n<blockquote>\n<p>C++ marks the destructor as <code>nounwind</code> and adds a hidden <code>try {} catch (...)</code> around the destructor that calls <code>std::terminate</code> if an exception tries to escape the destructor. Basically the exact same thing I am doing with <code>-Z panic-in-drop=abort</code>.</p>\n</blockquote>\n<p>it doesn't always. By default, destructors are <code>noexcept</code>, but you can explicitly write <code>~Foo() noexcept(false){ throw std::exception{\"Heh\"};}</code> and it will unwind normally (except if its called during stack unwinding).</p>",
        "id": 267926841,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642106286
    },
    {
        "content": "<p>Poking at Clang's generated code it seems that what clang does is to add a hidden <code>try {} catch (...)</code> that calls terminate around the unwinding part.</p>",
        "id": 267928019,
        "sender_full_name": "Gary Guo",
        "timestamp": 1642106898
    },
    {
        "content": "<p>GCC is again using LSDA to do that with zero overhead.</p>",
        "id": 267928042,
        "sender_full_name": "Gary Guo",
        "timestamp": 1642106912
    },
    {
        "content": "<p><a href=\"https://godbolt.org/z/vG1r6xE5o\">https://godbolt.org/z/vG1r6xE5o</a></p>",
        "id": 267928299,
        "sender_full_name": "Gary Guo",
        "timestamp": 1642107030
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/meeting.202022-1-13/near/267926841\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"143274\">Amanieu</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/meeting.202022-1-13/near/267922344\">said</a>:</p>\n<blockquote>\n<p>C++ marks the destructor as <code>nounwind</code> and adds a hidden <code>try {} catch (...)</code> around the destructor that calls <code>std::terminate</code> if an exception tries to escape the destructor. Basically the exact same thing I am doing with <code>-Z panic-in-drop=abort</code>.</p>\n</blockquote>\n<p>it doesn't always. By default, destructors are <code>noexcept</code>, but you can explicitly write <code>~Foo() noexcept(false){ throw std::exception{\"Heh\"};}</code> and it will unwind normally (except if its called during stack unwinding).</p>\n</blockquote>\n<p>Wait, really?</p>\n<p>I'm so glad to no longer be working with that language.</p>",
        "id": 269607092,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1643304450
    }
]