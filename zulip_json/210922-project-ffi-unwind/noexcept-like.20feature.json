[
    {
        "content": "<p>The points I tried to make is that a <code>#[no_unwind]</code> attribute that you can stamp on a function is a large language change</p>",
        "id": 178839028,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571824838
    },
    {
        "content": "<p>which impacts many parts of the language and the library long term</p>",
        "id": 178839050,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571824865
    },
    {
        "content": "<p>an <code>extern \"C nounwind\"</code> ABI feels much restricted in scope</p>",
        "id": 178839070,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571824883
    },
    {
        "content": "<p>it still allows many things that a <code>noexcept</code>-like feature would allow though</p>",
        "id": 178839161,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571824940
    },
    {
        "content": "<p>e.g. you can implement traits for function types with that ABI, which lets you query whether a function call might panic in an adhoc way:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">CanUnwind</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">VALUE</span>: <span class=\"kt\">bool</span> <span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">Args</span><span class=\"p\">...,</span><span class=\"w\"> </span><span class=\"n\">Ret</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">CanUnwind</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"s\">&quot;C nounwind&quot;</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"p\">(</span><span class=\"n\">Args</span><span class=\"p\">...)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Ret</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">VALUE</span>: <span class=\"kt\">bool</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kc\">false</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">Args</span><span class=\"p\">...,</span><span class=\"w\"> </span><span class=\"n\">Ret</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">CanUnwind</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"s\">&quot;C&quot;</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"p\">(</span><span class=\"n\">Args</span><span class=\"p\">...)</span>-&gt; <span class=\"nc\">Ret</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">VALUE</span>: <span class=\"kt\">bool</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kc\">true</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 178839302,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571825064
    },
    {
        "content": "<p>(or using specialization you can do better)</p>",
        "id": 178839340,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571825105
    },
    {
        "content": "<p>A <code>\"C unwind\"</code> feature also allows this, I don't think we mentioned that anywhere</p>",
        "id": 178839369,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571825138
    },
    {
        "content": "<p>An \"ABI\" string restricts the ABIs that can use such a <code>noexcept</code>-like feature, but that's essentially it.</p>",
        "id": 178839560,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571825298
    },
    {
        "content": "<p>It would be unfortunate to end up with both a <code>noexcept</code>-like feature and ABIs of the form <code>\"X\"</code> and <code>\"X nounwind/unwind\"</code> requiring user code to handle both</p>",
        "id": 178839744,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571825474
    },
    {
        "content": "<p>I would argue that we do not need the full functionality of <code>noexcept</code> in Rust. In C++, some functions need to work differently if a move constructor might throw an exception since you could end up in a situation with a partially moved value that you can't fully move back without triggering a second exception. The <code>noexcept</code> detection is used to fall back to copy constructors (i.e. <code>Clone</code> in Rust) in such cases. This is the <em>only</em> legitimate use of <code>noexcept</code> detection in C++ that I know of, and it doesn't apply to Rust because moving an object is just a memcpy and is guaranteed not to panic.</p>",
        "id": 178840144,
        "sender_full_name": "Amanieu",
        "timestamp": 1571825892
    },
    {
        "content": "<p>However in Rust I can see a use for <code>#[no_unwind]</code> for utilities such as <a href=\"https://github.com/Sgeo/take_mut\" target=\"_blank\" title=\"https://github.com/Sgeo/take_mut\"><code>take_mut</code></a> where unwinding would leave things in an unsound state.</p>",
        "id": 178840536,
        "sender_full_name": "Amanieu",
        "timestamp": 1571826250
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> another legitimate use of <code>noexcept</code> in C++ is some algorithmic optimizations</p>",
        "id": 178855479,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571838832
    },
    {
        "content": "<p>maybe that's what you meant above, but if you know that, e.g., a move constructor cannot panic, then you can just avoid doing certain work</p>",
        "id": 178855588,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571838881
    },
    {
        "content": "<p>In Rust, <code>catch_unwind(never_panics)</code> is not free (on the contrary, it is super expensive)</p>",
        "id": 178855611,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571838907
    },
    {
        "content": "<p>so an implementation of <code>catch_unwind</code> that is able to use something like <code>noexcept(never_panics())</code> could be much better, but for that, such a <code>noexcept</code> feature is not really required</p>",
        "id": 178855743,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571838970
    },
    {
        "content": "<p>(we could have something like <code>needs_drop</code>, that doesn't need to return a reliable answer, and that could be able to do more than just looking at the functions type)</p>",
        "id": 178855777,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571838999
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> </p>\n<blockquote>\n<p>However in Rust I can see a use for #[no_unwind] for utilities such as take_mut where unwinding would leave things in an unsound state.</p>\n</blockquote>\n<p>Isn't that the problem that <code>UnwindSafe</code> solved ? (I'm not sure I understood that part of Rust though)</p>",
        "id": 178855916,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571839082
    },
    {
        "content": "<p>Another legitimate use of <code>noexcept</code> is to just say \"this operation never panics and that's part of its API\". That's important when violating unsafe invariants.</p>",
        "id": 178856143,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571839213
    },
    {
        "content": "<p>e.g. </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">vec</span><span class=\"p\">.</span><span class=\"n\">set_len</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// vec invariants violated</span>\n<span class=\"c1\">// do stuff</span>\n<span class=\"n\">ptr</span>::<span class=\"n\">write</span><span class=\"p\">(...</span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">vec</span><span class=\"p\">...);</span><span class=\"w\">  </span><span class=\"c1\">// vec invariants restored</span>\n</pre></div>",
        "id": 178856182,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571839241
    },
    {
        "content": "<p>you can defend against \"do stuff\" panicking, e.g., by having some <code>DropGuard</code> on the stack that restores the <code>vec</code> invariants before letting \"do stuff\" panic escape</p>",
        "id": 178856261,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571839298
    },
    {
        "content": "<p>but you don't have to do that if \"do stuff\" does not panic, and you might prefer to simplify your code by not allowing \"do stuff\" to panic at all</p>",
        "id": 178856422,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571839388
    },
    {
        "content": "<p>with something like <code>needs_drop</code> but for panic, e.g., <code>might_panic</code>, you can just test if a user-provided <code>Fn</code> type might panic, and just abort, but you might want to lift that to a type-error, to let the user know that <code>Fn</code> types that can panic cannot be provided to that particular operation</p>",
        "id": 178856596,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571839495
    },
    {
        "content": "<p>So I think there are two major use cases:</p>\n<ul>\n<li>optimizations if some operation cannot unwind: a <code>might_panic</code>-kind of intrinsic might allow these</li>\n<li>API contracts: Some unsafe code is only sound if certain expressions do not unwind and it might make sense to turn these into type errors in some cases, and certain APIs want to guarantee that they never unwind as part of their API contract (not only in a doc comment, but also in code).</li>\n</ul>",
        "id": 178857159,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571839863
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"132920\">@gnzlbg</span> My point is, <code>noexcept</code> optimizations in C++ are almost exclusively based on move constructors, and Rust doesn't have that problem since move can never panic in Rust.</p>",
        "id": 178859802,
        "sender_full_name": "Amanieu",
        "timestamp": 1571841537
    },
    {
        "content": "<p>Is that true?</p>",
        "id": 178860037,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571841655
    },
    {
        "content": "<p>I see <code>noexcept</code> being used for optimizations that require exception safety</p>",
        "id": 178860057,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571841666
    },
    {
        "content": "<p>For example, consider <code>sort</code> in the standard library, which uses <code>merge_sort</code></p>",
        "id": 178860126,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571841705
    },
    {
        "content": "<p>The input slice is always kept in a valid state because the user comparison operations can panic</p>",
        "id": 178860162,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571841723
    },
    {
        "content": "<p>That is, the elements of the input slice are only swapped to avoid leaving holes on panic</p>",
        "id": 178860227,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571841738
    },
    {
        "content": "<p>If we would be able to tell that the user-provided operation does not panic, we could maybe do a bit better there</p>",
        "id": 178860324,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571841801
    },
    {
        "content": "<p>e.g. leaving \"holes\" in the slice while operating on it</p>",
        "id": 178860349,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571841814
    },
    {
        "content": "<p>we often deal with such things by using \"<code>DropGuard</code>\"s, that on panic, restore all broken invariants</p>",
        "id": 178860426,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571841845
    },
    {
        "content": "<p>but those <code>DropGuard</code>s are tricky to write correctly, and we have had a couple of issues with them, e.g., in the <code>Iterator</code>s of the collections..</p>",
        "id": 178860492,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571841889
    },
    {
        "content": "<p>All use cases of <code>DropGuard</code>s in <code>libstd</code> that I know about are optimizations that violate safety invariants that, in case of a panic, need to be restored</p>",
        "id": 178860644,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571841966
    },
    {
        "content": "<p>But <code>DropGuard</code> are the best way to solve this problem. They are optimized away when the compiler inlines the user callback and can see that it doesn't panic.</p>",
        "id": 178865541,
        "sender_full_name": "Amanieu",
        "timestamp": 1571844663
    },
    {
        "content": "<p>We are able to restore the structure to a safe state with <code>DropGuard</code> <em>because</em> Rust doesn't have move constructors.</p>",
        "id": 178865600,
        "sender_full_name": "Amanieu",
        "timestamp": 1571844703
    },
    {
        "content": "<p>In C++ you would need to take into account the possibility that even moving objects around can throw exceptions.</p>",
        "id": 178865696,
        "sender_full_name": "Amanieu",
        "timestamp": 1571844744
    },
    {
        "content": "<blockquote>\n<p>But <code>DropGuard</code> are the best way to solve this problem. They are optimized away when the compiler inlines the user callback and can see that it doesn't panic.</p>\n</blockquote>\n<p>If the compiler inlines the callback. With <code>noexcept</code> you don't need inlining for this to happen.</p>",
        "id": 178877204,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571852248
    },
    {
        "content": "<p>It seems the fundamental consideration here is that <code>no_except</code> is <em>strictly</em> an optimization, is <em>never</em> required for correctness, and, regardless of the final design, can be added in a fully backwards-compatible way</p>",
        "id": 178880573,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571854296
    },
    {
        "content": "<p>So my current view is: it does (probably) fall within the scope of the WG, but does not need to be resolved in order to stabilize cross-FFI-unwinding</p>",
        "id": 178880684,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571854338
    },
    {
        "content": "<p>Does the first sentence seem accurate and the second reasonable?</p>",
        "id": 178880761,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571854405
    },
    {
        "content": "<p>If so, I'm happy for continued discussion to take place here, but I would like it to be \"officially\" considered a low priority for now</p>",
        "id": 178880801,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571854438
    },
    {
        "content": "<p>(But definitely something that our first technical RFC should mention in the \"future possibilities\" section)</p>",
        "id": 178880852,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571854455
    },
    {
        "content": "<p>I think <code>nopanic fn</code> or some such should be viewed in the same light as <code>const fn</code> -- it is a restriction to the base effect <code>fn</code> has which may 1) diverge, 2) panic, and 3) cause side-effects.</p>\n<blockquote>\n<p>So I think there are two major use cases:</p>\n</blockquote>\n<p>I think there's interest in embedded to prevent panics.<br>\nFundamentally, restrictions like <code>const</code> (interpreted as \"pure\") and \"cannot panic\" also improve code quality beyond usefulness for soundness.<br>\nIt's a way to be sure that you've handled more cases, enhancing strong typing. I think this is desirable, but way out of scope for this WG.</p>",
        "id": 178901298,
        "sender_full_name": "centril",
        "timestamp": 1571868247
    },
    {
        "content": "<p>(I also think provable convergence (e.g. <code>total fn</code>) is desirable, but that's more difficult to make ergonomic)</p>",
        "id": 178901328,
        "sender_full_name": "centril",
        "timestamp": 1571868294
    },
    {
        "content": "<p>Note that what we proposed for a <code>nopanic</code> attribute is not what you described. Instead, if unwinding reaches a <code>nopanic</code>, it aborts the process instead of continuing to unwind.</p>",
        "id": 178901437,
        "sender_full_name": "Amanieu",
        "timestamp": 1571868401
    },
    {
        "content": "<p>Seems strange to me, especially when combined with a closure</p>",
        "id": 178901757,
        "sender_full_name": "centril",
        "timestamp": 1571868722
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">take</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">mut_ref</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">closure</span>: <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"n\">nopanic</span><span class=\"w\"> </span><span class=\"nb\">FnOnce</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">T</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"c1\">//~^ You cannot pass a closure that will panic; the type system will prevent it</span>\n</pre></div>",
        "id": 178901854,
        "sender_full_name": "centril",
        "timestamp": 1571868809
    },
    {
        "content": "<p>The attribute being discussed here is for optimization, not an effects system. The effects system \"can't panic\" type does sound interesting, but isn't what <code>#[no_unwind]</code> would be.</p>",
        "id": 178902042,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571868975
    },
    {
        "content": "<p>When <code>take_mut</code> is being discussed that is for soundness; not optimization.</p>\n<p>This <code>#[no_unwind]</code>... is it attached just to function definitions? function pointers? closures? what exactly?</p>",
        "id": 178902435,
        "sender_full_name": "centril",
        "timestamp": 1571869297
    },
    {
        "content": "<p>I think there's a bit of confusion here because there are actually two similar but different attributes being discussed here:<br>\n- First, an attribute that you can place on (FFI) declarations which (unsafely) tells the compiler that this function will never unwind. This is basically the LLVM <code>nounwind</code> attribute.<br>\n- Second, an attribute on a function definition which forces unwinding to abort the process if it reaches this function. Incidentally, this function can also be marked with LLVM's <code>nounwind</code> since no exceptions will ever unwind out of it (they'll abort first).</p>",
        "id": 178903123,
        "sender_full_name": "Amanieu",
        "timestamp": 1571869947
    },
    {
        "content": "<p>This seems to be <code>#[unwind(aborts)]</code>?</p>",
        "id": 178903189,
        "sender_full_name": "centril",
        "timestamp": 1571870038
    },
    {
        "content": "<p>Yes, I believe that's the main thing being discussed that we believe would be in scope for this project</p>",
        "id": 178906723,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1571873214
    },
    {
        "content": "<blockquote>\n<p>It seems the fundamental consideration here is that no_except is strictly an optimization, is never required for correctness, </p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"120076\">@Kyle Strand</span>  How do you arrive at this conclusion? The example I showed is only correct if some code cannot ever unwind, i.e., without <code>noexcept</code>, such unsafe code is unsound.</p>",
        "id": 178926841,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571901433
    },
    {
        "content": "<p>That's not an optimization, but a requirement for correctness.</p>",
        "id": 178926909,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571901492
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"126931\">@centril</span> </p>\n<blockquote>\n<p>I think there's interest in embedded to prevent panics.</p>\n</blockquote>\n<p>There are many users of dtolnay's <code>#[no_panic]</code> crate, which has a proc-macro that wraps a function, in such a way that it only compiles if it cannot panic. It does so by wrapping the function in another function, that contains a type in the stack with a destructor that's only called if the original function can panic. That destructor is implemented to call an external symbol that does not exist. So if the destructor call is optimized away because the function is proven not to panic, then your program compiles. Otherwise, your program fails to link.</p>\n<p>The existence of users that are willing to go to such hacky extends to make sure that a function cannot panic shows that there is more than interest, there is an active need.</p>",
        "id": 178927215,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571901917
    },
    {
        "content": "<blockquote>\n<p>The attribute being discussed here is for optimization, not an effects system. </p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"120076\">@Kyle Strand</span>  This is unclear to me, since <span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> also claimed that they would be good with a <code>\"C nounwind\"</code> ABI string that makes this part of the type system.</p>",
        "id": 178927395,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571902157
    },
    {
        "content": "<p>If the only goal is optimizations, then making it part of the type system would be a bad idea.</p>",
        "id": 178927465,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571902218
    },
    {
        "content": "<p>If it makes sense to make this part of the type system, then designing the feature only for optimizations and neglecting how it impacts the type system as a whole is probably a bad idea as well.</p>",
        "id": 178927489,
        "sender_full_name": "gnzlbg",
        "timestamp": 1571902261
    },
    {
        "content": "<blockquote>\n<blockquote>\n<p>It seems the fundamental consideration here is that no_except is strictly an optimization, is never required for correctness, </p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120076\">Kyle Strand</span>  How do you arrive at this conclusion? The example I showed is only correct if some code cannot ever unwind, i.e., without <code>noexcept</code>, such unsafe code is unsound.</p>\n</blockquote>\n<p>Looking back, I have to admit I'm not entirely sure what I meant by that. But if ensuring a function can't <code>panic</code> is required for correctness, you can just put a <code>catch_panic</code> at the top with an <code>abort</code> statement. So I think what I was trying to say is that there is no case in which users would be unable to write some particular functionality _without_ <code>noexcept</code> that would be enabled by <code>noexcept</code>. Is that true?</p>",
        "id": 179272812,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572294864
    },
    {
        "content": "<p>No.</p>",
        "id": 179306773,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572335167
    },
    {
        "content": "<p>If <code>catch_unwind</code> were a zero-cost abstraction, then maybe. But a <code>catch_unwind</code> is extremely expensive, and if you are targeting a constrained environment, you can't use it.</p>",
        "id": 179306836,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572335285
    },
    {
        "content": "<p><code>noexcept</code> removes the need for the <code>catch_unwind</code>, enabling that</p>",
        "id": 179306866,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572335319
    },
    {
        "content": "<p>Hm. How would it remove that need? I am imagining here that <code>noexcept</code> would have the abort-on-unwind behavior that we want for <code>extern \"C\"</code>. Why is <code>catch_unwind</code> more expensive than that would be?</p>",
        "id": 179333097,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572358941
    },
    {
        "content": "<p><code>noexcept</code> makes it a compiler error instead, removing any run-time cost</p>",
        "id": 179343628,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572364796
    },
    {
        "content": "<p><code>catch_unwind</code> is probably just implemented \"poorly\"</p>",
        "id": 179343730,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572364825
    },
    {
        "content": "<p>it's a library feature, not a language construct, and whatever LLVM-IR we generate doesn't get optimized, probably because of calls to unknown functions</p>",
        "id": 179343823,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572364884
    },
    {
        "content": "<p>We discussed two variants of <code>noexcept</code>. If it's an effect annotation, that's out of scope. If it's like C++'s feature (which <code>std::terminate</code>s when an exception is thrown), that's probably in scope.</p>",
        "id": 179344465,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572365241
    },
    {
        "content": "<p>Did you understood the code example that was shown above ?</p>",
        "id": 179344639,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572365310
    },
    {
        "content": "<p>Centril's?</p>",
        "id": 179344751,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572365382
    },
    {
        "content": "<p>All of them</p>",
        "id": 179344777,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572365395
    },
    {
        "content": "<p>(there are 3 examples I think)</p>",
        "id": 179346104,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572366161
    },
    {
        "content": "<p>The second one shows the issue</p>",
        "id": 179346113,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572366167
    },
    {
        "content": "<p>The one about temporarily violating invariants e.g. w/ <code>vec.set_len</code>?</p>",
        "id": 179347284,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572366942
    },
    {
        "content": "<p>Yep, <code>noexcept</code> makes such examples sound</p>",
        "id": 179354078,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572370920
    },
    {
        "content": "<p>As does <code>catch_unwind</code> + <code>abort</code>. If there's an implementation reason why <code>catch_unwind</code> can't be used somewhere that <code>noexcept</code> (the version that causes an <code>abort</code>) would be usable, that seems separate from the consideration of whether <code>noexcept</code> is \"required for correctness\".</p>",
        "id": 179355304,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572371631
    },
    {
        "content": "<p>_Again_, what you are proposing is for the error to be reported at run-time by aborting.</p>",
        "id": 179356361,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572372173
    },
    {
        "content": "<p>If you want to ignore that, that's ok.</p>",
        "id": 179356369,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572372180
    },
    {
        "content": "<p>I prefer code like <code>let x: u32 = 0_f32;</code> to error at compile-time due to a type error</p>",
        "id": 179356393,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572372196
    },
    {
        "content": "<p>Sure, we could also make <code>let x: u32 = 0_f32;</code> \"sound\" by aborting the program at run-time</p>",
        "id": 179356407,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572372209
    },
    {
        "content": "<p>but if I wanted a language that does that I would be using Python, and not Rust</p>",
        "id": 179356555,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572372284
    },
    {
        "content": "<p>I'm not disagreeing that a compile-time error is <em>preferable</em> or even necessarily \"proposing\" something as such. I'm just saying that there are <em>two</em> \"noexcept-like\" features discussed above, and I don't believe that the \"effects system\" one is within the scope of this project group.</p>",
        "id": 179356636,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572372327
    },
    {
        "content": "<p>I thought you were asking \"what problems does <code>noexcept</code> solve\", which is something that has been discussed above</p>",
        "id": 179356908,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572372454
    },
    {
        "content": "<p>I am also trying to respond to your comment about unsoundness. The \"effects system\" version is a way to strengthen the type system to remove some of the soundness proof-burden from the user. The \"abort on unwind\" version is a way to ensure soundness at runtime via a mechanism that users could in theory implement themselves. Neither is \"required\" for soundness, though.</p>",
        "id": 179356948,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572372476
    },
    {
        "content": "<p>You are forgetting the guarantee that <code>noexcept</code> provides <strong>for callers</strong></p>",
        "id": 179357053,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572372514
    },
    {
        "content": "<p>which is that something won't unwind, ever</p>",
        "id": 179357071,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572372523
    },
    {
        "content": "<p>this means, they don't even need to add a test to verify the behavior of the program if that something were to unwind, because it is something that, if the program compiles, is guaranteed not to happen</p>",
        "id": 179357113,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572372549
    },
    {
        "content": "<p>and that's the property of <code>noexcept</code> that the example above requires</p>",
        "id": 179357137,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572372559
    },
    {
        "content": "<p>Without a built-in effects system, callers are responsible for knowing whether function effects can cause unsoundness. That's why an effects system would be nice, but that doesn't mean it's in scope for this project group.</p>",
        "id": 179357269,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572372612
    },
    {
        "content": "<p>C++ doesn't have an effect system, but it has this feature</p>",
        "id": 179357299,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572372628
    },
    {
        "content": "<p>adding <del><code>\"C unwind\"</code></del> <code>\"C nounwind\"</code> is equivalent to adding <code>noexcept</code></p>",
        "id": 179357314,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572372635
    },
    {
        "content": "<p>not...really....</p>",
        "id": 179357316,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572372635
    },
    {
        "content": "<p>Do you mean <code>\"C nounwind\"</code>?</p>",
        "id": 179357340,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572372649
    },
    {
        "content": "<blockquote>\n<p>Do you mean \"C nounwind\"?</p>\n</blockquote>\n<p>Yes, or equivalently adding <code>\"C unwind\"</code> and making <code>\"C\"</code> <code>nounwind</code></p>",
        "id": 179357351,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572372659
    },
    {
        "content": "<p>Okay. Again, I'm not trying to debate the merits of having <code>nounwind</code> in the type system, or anything like that.</p>",
        "id": 179357425,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572372706
    },
    {
        "content": "<p>I agree that <code>\"C nounwind\"</code> and/or guaranteeing the <code>abort</code> behavior of <code>\"C\"</code> would both provide useful guarantees that aren't available in the type system today.</p>",
        "id": 179357514,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572372753
    },
    {
        "content": "<p>Adding <code>\"C unwind\"</code> makes <code>\"C\" nounwind</code> and adds <code>noexcept</code> to Rust in some way</p>",
        "id": 179357525,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572372761
    },
    {
        "content": "<p>Right</p>",
        "id": 179357539,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572372769
    },
    {
        "content": "<p>Doing that, and then also adding another <code>noexcept</code> feature, would be adding two subtly different features to do the same thing to the language</p>",
        "id": 179357561,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572372783
    },
    {
        "content": "<p>Yes, but they're semantically different in important ways, and I don't think it would be inappropriate to do so.</p>",
        "id": 179357592,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572372803
    },
    {
        "content": "<p>So it is in scope for this working group to say why two different features instead of just one.</p>",
        "id": 179357601,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572372807
    },
    {
        "content": "<p>They are identical</p>",
        "id": 179357659,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572372818
    },
    {
        "content": "<p><code>\"C unwind\" nounwind</code> == <code>\"C\"</code></p>",
        "id": 179357691,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572372843
    },
    {
        "content": "<p>Um....not really. Because the extra <code>noexcept</code> feature wouldn't fall within the scope of this group, so the burden to explain why it's non-redundant would be on whoever proposes it.</p>",
        "id": 179357698,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572372844
    },
    {
        "content": "<p>Oh, wait, you're saying that <code>\"C\"</code> and <code>\"C nounwind\"</code> would be subtly different?</p>",
        "id": 179357782,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572372872
    },
    {
        "content": "<blockquote>\n<p>Um....not really. Because the extra noexcept feature wouldn't fall within the scope of this group, so the burden to explain why it's non-redundant would be on whoever proposes it.</p>\n</blockquote>\n<p>I strongly disagree. This process would result in thousand of small incoherent features being added to the language.</p>",
        "id": 179357820,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572372900
    },
    {
        "content": "<p>I don't agree with that. <code>\"C nounwind\"</code> would just be an explicit way of writing <code>\"C\"</code>, just like <code>extern \"Rust\"</code> is merely an explicit way of specifying the default ABI.</p>",
        "id": 179357833,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572372906
    },
    {
        "content": "<p>Because it would always be somebodyelses job to see the big picture.</p>",
        "id": 179357845,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572372913
    },
    {
        "content": "<blockquote>\n<p>Oh, wait, you're saying that \"C\" and \"C nounwind\" would be subtly different?</p>\n</blockquote>\n<p>No, I precisely meant what I said.</p>",
        "id": 179357897,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572372939
    },
    {
        "content": "<p>I'm not accusing you of misspeaking; I'm trying to understand this comment:</p>\n<blockquote>\n<p><code>\"C unwind\" nounwind</code> == <code>\"C\"</code></p>\n</blockquote>",
        "id": 179357988,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572372978
    },
    {
        "content": "<p><code>nounwind extern \"C unwind\" fn foo() {}</code> would be semantically identical to <code>extern \"C\" fn foo() {}</code></p>",
        "id": 179358040,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572373019
    },
    {
        "content": "<p>therefore by adding the <code>\"C\"</code> and <code>\"C unwind\"</code> ABIs distinction to the language one is actually adding <code>nounwind</code> to the language</p>",
        "id": 179358100,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572373042
    },
    {
        "content": "<p>just with less explicit syntax, less powerful, and probably in such a way that actually making it more powerful would require a different feature that would subsume it and deprecate it</p>",
        "id": 179358187,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572373078
    },
    {
        "content": "<p>that's the opposite of \"future proofing\" a feature</p>",
        "id": 179358256,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572373095
    },
    {
        "content": "<p>When you write <code>nounwind</code> outside of an <code>extern</code> ABI specifier, is that your hypothetical syntax for what I'm calling an \"effects system\" <code>nounwind</code>, i.e., purely a compile-time guarantee, with no runtime <code>abort</code>?</p>",
        "id": 179358308,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572373142
    },
    {
        "content": "<p>If so, I agree that those are semantically identical from the perspective of the <em>caller</em>, though specifying both <code>\"C unwind\"</code> and <code>nounwind</code> seems...confused at best.</p>",
        "id": 179360333,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572374218
    },
    {
        "content": "<p>But they have very different impacts on the author of the function, of course.</p>",
        "id": 179360365,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572374238
    },
    {
        "content": "<p>And, since <code>\"C\"</code> already exists in the language, we can't introduce a \"safe-to-unwind\" ABI and stabilize the desired abort-on-<code>unwind</code> behavior for <code>\"C\"</code> without having such an \"implicit <code>nounwind</code>\". That is maybe a good argument to add to Niko's document about the default behavior of <code>\"C\"</code>, but I don't really see it as a reason not to introduce <code>\"C unwind\"</code>.</p>",
        "id": 179360571,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572374354
    },
    {
        "content": "<p>Note that we already have an equivalent of <code>noexcept</code> in (unstable) Rust: <code>#[unwind(aborts)]</code>. Literally the only difference is that it calls <code>intrinsics::trap</code> (Rust) instead of <code>std::terminate</code> (C++).</p>",
        "id": 179361554,
        "sender_full_name": "Amanieu",
        "timestamp": 1572374968
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> the other difference is that <code>#[unwind(aborts)]</code> is not part of a function type</p>",
        "id": 179411652,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572424887
    },
    {
        "content": "<p>So users can't really do any kind of type level reasoning about this</p>",
        "id": 179411658,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572424900
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120076\">@Kyle Strand</span> i agree that the situation might be confusing, which is why I think that we should at least recognize the impact of <code>\"C\"</code> vs <code>\"C unwind\"</code> at that level, and be able to talk about it in this project group and its RFCs</p>",
        "id": 179411727,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572424963
    },
    {
        "content": "<p>If you take a look at my first example here: <a href=\"#narrow/stream/210922-wg-ffi-unwind/topic/noexcept-like.20feature/near/178839302\" title=\"#narrow/stream/210922-wg-ffi-unwind/topic/noexcept-like.20feature/near/178839302\">https://rust-lang.zulipchat.com/#narrow/stream/210922-wg-ffi-unwind/topic/noexcept-like.20feature/near/178839302</a>, if we add <code>\"C unwind\"</code> and guarantee that <code>\"C\"</code> never unwinds I can use that trick to write code like this:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">NeverUnwinds</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"c1\">// manually expand this to multiple impls for different argument numbers:</span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">Ret</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Args</span><span class=\"p\">...</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">NeverUnwinds</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"s\">&quot;C&quot;</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"p\">(</span><span class=\"n\">Args</span><span class=\"p\">...)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Ret</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n\n<span class=\"cm\">/* safe */</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">duplicate_map</span><span class=\"o\">&lt;</span><span class=\"n\">F</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"kt\">i32</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">map</span>: <span class=\"nc\">F</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"> </span><span class=\"n\">F</span>: <span class=\"nb\">Fn</span><span class=\"p\">(</span><span class=\"kt\">i32</span><span class=\"p\">)</span>-&gt;<span class=\"kt\">i32</span> <span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">NeverUnwinds</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">       </span><span class=\"c1\">// safe because `map`is safe and it  never unwinds</span>\n<span class=\"w\">       </span><span class=\"c1\">// no dropgurad, no catch_unwind</span>\n<span class=\"w\">       </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">new_len</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">       </span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">reserve</span><span class=\"p\">(</span><span class=\"n\">new_len</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">       </span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">set_len</span><span class=\"p\">(</span><span class=\"n\">new_len</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">       </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"p\">...</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"p\">.</span><span class=\"n\">write</span><span class=\"p\">(...,</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"n\">ptr</span><span class=\"p\">.</span><span class=\"n\">read</span><span class=\"p\">(...))</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>that's a very poor's man <code>noexcept</code> feature, with the exact same power (except for <code>noexcept(expr)</code>), but worse ergonomics.</p>",
        "id": 179411920,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572425224
    },
    {
        "content": "<p>While we are not adding this feature to enable this use case, it turns out that \"by accident\" this is a very powerful thing that the feature enables.</p>",
        "id": 179412073,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572425441
    },
    {
        "content": "<p>I think that these super-powerful use-cases by accident are worth studying, e.g., C++ templates were not intended for meta-programming, yet here we are.</p>",
        "id": 179412098,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572425503
    },
    {
        "content": "<p>How is that more powerful than <code>map: extern \"C\" fn(i32) -&gt; i32</code>? I don't see how the <code>NeverUnwindd</code> trait could be extended in any compile-checked way to other function-like types. For instance, <code>duplicate_map</code> itself could be made to not unwind by <code>abort</code>ing if the <code>reserve</code> triggers OOM, but I don't see how to encode that in any sort of compile-checked way.</p>",
        "id": 179437858,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572446084
    },
    {
        "content": "<p>You are right, the <code>reserve</code> should be a: <code>assert!(capacity() &gt;= 2 * len())</code></p>",
        "id": 179438337,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572446356
    },
    {
        "content": "<p>Ah wait, no, not necessarily, it is ok for reserve to panic</p>",
        "id": 179438399,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572446399
    },
    {
        "content": "<p>so that is not a problem sorry</p>",
        "id": 179438442,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572446403
    },
    {
        "content": "<p>the problem is <code>map</code> panicking after the <code>x.set_len</code> has been called</p>",
        "id": 179438462,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572446420
    },
    {
        "content": "<p>that's the only thing that's required not to panic for correctness</p>",
        "id": 179438477,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572446432
    },
    {
        "content": "<blockquote>\n<p>I don't see how the NeverUnwindd trait could be extended in any compile-checked way to other function-like types.</p>\n</blockquote>\n<p>What do you mean ?</p>",
        "id": 179438504,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572446454
    },
    {
        "content": "<p>It's not unsafe for it to panic in your example, but I'm talking about giving <code>duplicate_map</code> the <code>NeverUnwind</code> trait, in which case it <em>would</em> be unsafe for it to panic</p>",
        "id": 179441776,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572448246
    },
    {
        "content": "<p>My point is that I don't see how this \"poor man's <code>noexcept</code>\" does anything except alias the <code>extern \"C\" fn</code> types</p>",
        "id": 179441896,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572448312
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120076\">@Kyle Strand</span> the way to give <code>duplicate_map</code> the trait is just make it an <code>extern \"C\"</code> function</p>",
        "id": 179444626,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572449725
    },
    {
        "content": "<p>in which case, I don't understand why you say that it would be unsafe for it to panic: if it panics, the program aborts, and the destructor of the vector is never run, but that doesn't matter because the invariant of the vector was not violated when reserve is called</p>",
        "id": 179444752,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572449790
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"cm\">/* safe */</span><span class=\"w\"> </span><span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"s\">&quot;C&quot;</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">duplicate_map_nounwind</span><span class=\"o\">&lt;</span><span class=\"n\">F</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"kt\">i32</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">map</span>: <span class=\"nc\">F</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"> </span><span class=\"n\">F</span>: <span class=\"nb\">Fn</span><span class=\"p\">(</span><span class=\"kt\">i32</span><span class=\"p\">)</span>-&gt;<span class=\"kt\">i32</span> <span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">NeverUnwinds</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">       </span><span class=\"c1\">// safe because `map`is safe and it  never unwinds</span>\n<span class=\"w\">       </span><span class=\"c1\">// no dropgurad, no catch_unwind</span>\n<span class=\"w\">       </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">new_len</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">       </span><span class=\"c1\">// this can panic, and that&#39;s ok</span>\n<span class=\"w\">       </span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">reserve</span><span class=\"p\">(</span><span class=\"n\">new_len</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">       </span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">set_len</span><span class=\"p\">(</span><span class=\"n\">new_len</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">       </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"p\">...</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"p\">.</span><span class=\"n\">write</span><span class=\"p\">(...,</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"n\">ptr</span><span class=\"p\">.</span><span class=\"n\">read</span><span class=\"p\">(...))</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 179444817,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572449826
    },
    {
        "content": "<p>This means that <code>extern \"C\"</code> is now a \"performance\" feature.</p>",
        "id": 179445025,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572449952
    },
    {
        "content": "<p>Just like people stamp <code>noexcept</code> everywhere in C++, people might want to stamp <code>extern \"C\"</code> everywhere in Rust</p>",
        "id": 179445060,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572449971
    },
    {
        "content": "<p>If the <code>NeverUnwind</code> trait can _only ever_ apply to <code>extern \"C\" fn</code>, then no, we are not accidentally introducing a new \"powerful\" feature.</p>",
        "id": 179446197,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572450566
    },
    {
        "content": "<p>If people want to modify many functions at once to <code>abort</code> instead of <code>panic</code>, the right way to do that is, of course, <code>panic = abort</code>.</p>",
        "id": 179446253,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572450594
    },
    {
        "content": "<p>Conversely, if you're just saying that people will take applications that need to have unwinding somewhere in them and optimize them by adding <code>extern \"C\"</code> elsewhere, then we're back to my statement that this is \"strictly an optimization\".</p>",
        "id": 179446752,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572450841
    },
    {
        "content": "<p>I will say that this all reminds me of something I was told by the LLVM dev I've mentioned before: \"FFI isn't a sandbox\"</p>",
        "id": 179447264,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572451106
    },
    {
        "content": "<p>The full quote:</p>\n<blockquote>\n<p>If the callee can unwind, then it can unwind. FFI isn't a sandbox, it's not supposed to change behaviour or protect the caller. At the extreme I can recognize that some mapping of types is done in some systems (strings are a common one). On Linux, exceptions are primitive and well-defined much like 32-bit integers, despite the lack of support in C[1].</p>\n<p>[1] - You can both throw and capture exceptions in C. The language doesn't define a syntax, but it doesn't need to. It doesn't define a syntax for networking or for threading either. Just include the header file and use the appropriate API.</p>\n</blockquote>",
        "id": 179447289,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572451117
    },
    {
        "content": "<p>....which would of course be an argument for allowing <code>extern \"C\"</code> to unwind by default (as <span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> suggested), and _not_ introducing <code>\"C unwind\"</code> or <code>\"C nounwind\"</code>.</p>",
        "id": 179447550,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572451252
    },
    {
        "content": "<p>My main concern there is that the claim is so Linux-specific, though it's true that SEH on Windows is also always useable even in C code.</p>",
        "id": 179447765,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572451347
    },
    {
        "content": "<blockquote>\n<p>If the NeverUnwind trait can _only ever_ apply to extern \"C\" fn, then no, we are not accidentally introducing a new \"powerful\" feature</p>\n</blockquote>\n<p>I disagree, since without <code>\"C unwind\"</code> people cannot write the <code>NeverUnwind</code> trait, but if we add <code>\"C unwind\"</code> to the language, they can.</p>\n<blockquote>\n<p>I will say that this all reminds me of something I was told by the LLVM dev I've mentioned before: \"FFI isn't a sandbox\"</p>\n</blockquote>\n<p>That quote is about FFI, while we are here talking about <code>noexcept</code> or LLVM's <code>nounwind</code> attribute.</p>",
        "id": 179510273,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572510066
    },
    {
        "content": "<p>Thinking more about how to use it, another cool way to use this feature is:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">NoUnwindCall</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Arg</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Ret</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"s\">&quot;C&quot;</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">nounwind_call</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">arg</span>: <span class=\"nc\">Self</span>::<span class=\"n\">Arg</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span>::<span class=\"n\">Ret</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">Ret</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Arg</span><span class=\"p\">...</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">NoUnwindCall</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"p\">(</span><span class=\"n\">Arg</span><span class=\"p\">...)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Ret</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Arg</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">Arg</span><span class=\"p\">...);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Ret</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Ret</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"s\">&quot;C&quot;</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">nounwind_call</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">arg</span>: <span class=\"nc\">Self</span>::<span class=\"n\">Arg</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span>::<span class=\"n\">Ret</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"bp\">self</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">...,</span><span class=\"w\"> </span><span class=\"n\">arg</span><span class=\"p\">.</span><span class=\"n\">N</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>and now you can write:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">NoUnwindCall</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(...)</span><span class=\"w\"> </span>-&gt; <span class=\"p\">...</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">...</span><span class=\"w\"> </span><span class=\"n\">Rust</span><span class=\"w\"> </span><span class=\"n\">ABI</span><span class=\"w\"> </span><span class=\"n\">function</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">.</span><span class=\"n\">nounwind_call</span><span class=\"p\">((</span><span class=\"n\">args</span><span class=\"p\">...));</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>to assert that a particular function call will not unwind. The only inconvenience is the ABI dance that this might incur.</p>",
        "id": 179520449,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572519604
    },
    {
        "content": "<blockquote>\n<p>Without <code>\"C unwind\"</code> people cannot write the <code>NeverUnwind</code> trait, but if we add <code>\"C unwind\"</code> to the language, they can.</p>\n</blockquote>\n<p>My point is that <code>NeverUnwind</code> is not particularly powerful, since there's no way to extend it to other types of functions, so it doesn't expose any abilities beyond what you'd get from using <code>extern \"C\"</code> directly. But, also, this has nothing to do with <code>\"C unwind\"</code> except insofar as the <em>already planned</em> change in behavior to make <code>extern \"C\"</code> abort-on-unwind hasn't yet been successfully stabilized because there was no way to opt out (which is what <code>unwind</code> would provide).</p>",
        "id": 179534720,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572531226
    },
    {
        "content": "<blockquote>\n<p>any abilities beyond what you'd get from using <code>extern \"C\"</code> directly...</p>\n</blockquote>\n<p>This is why I said above that <code>duplicate_map</code> could just take <code>map</code> as an <code>extern \"C\" fn</code> directly, since there's no other possible type that can implement that trait.</p>",
        "id": 179534883,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572531335
    },
    {
        "content": "<p>Re: <code>NoUnwindCall</code>, that's just the equivalent of making an <code>extern \"C\"</code> lambda, but with a more confusing syntax.</p>",
        "id": 179535048,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572531411
    },
    {
        "content": "<blockquote>\n<p>That quote is about FFI, while we are here talking about <code>noexcept</code> or LLVM's <code>nounwind</code> attribute.</p>\n</blockquote>\n<p>Right, but your \"ABI dance\" is just abusing a feature intended for FFI to create such a \"sandbox\".</p>",
        "id": 179535279,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572531557
    },
    {
        "content": "<p>I'll just repeat what I said before: <code>NeverUnwind</code> trait isn't that useful in practice because you can always use a drop guard instead, which allows you to accept any kind of callback, not just ones that never unwind. I don't think we should be basing our design decisions on a hypothetical trait which is almost never going to be used in practice.</p>",
        "id": 179535981,
        "sender_full_name": "Amanieu",
        "timestamp": 1572531975
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> DropGuards do not let you tell the optimizer that a call does not unwind</p>",
        "id": 179543879,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572536423
    },
    {
        "content": "<p>The problem NeverUnwind solves is the same problem that the <code>#[no_panic]</code> crate solves</p>",
        "id": 179543903,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572536439
    },
    {
        "content": "<p>DropGuards have nothing to do with that</p>",
        "id": 179543906,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572536443
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120076\">@Kyle Strand</span> </p>\n<blockquote>\n<p>But, also, this has nothing to do with \"C unwind\" except insofar as the already planned change in behavior to make extern \"C\" abort-on-unwind hasn't yet been successfully stabilized because there was no way to opt out (which is what unwind would provide).</p>\n</blockquote>\n<p>Right now one cannot assume that an <code>extern \"C\"</code> function never unwinds. The <code>\"C unwind\"</code> proposal  _guarantees_ that <code>extern \"C\"</code> functions never unwind.</p>",
        "id": 179543972,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572536503
    },
    {
        "content": "<p>No, those are separate. The <code>\"C unwind\"</code> proposal is partly _motivated_ by the fact that we've previously been unable to specify the already-planned never-unwind behavior.</p>",
        "id": 179544056,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572536543
    },
    {
        "content": "<p>But the <code>\"C unwind\"</code> proposal does not _introduce_ that idea.</p>",
        "id": 179544084,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572536564
    },
    {
        "content": "<p>Not in <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> RFC, which starts by saying that we insert abort-on-panic shims for <code>extern \"C\"</code> functions (that's the first thing that RFC changes in the language, and what enables <code>NeverUnwind</code> above).</p>",
        "id": 179544092,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572536568
    },
    {
        "content": "<p>A different RFC might say that <code>extern \"C\"</code> functions can unwind just fine, and do not provide any way to make a function <code>nounwind</code>, making it impossible for <code>NeverUnwind</code> to be written in Rust.</p>",
        "id": 179544296,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572536672
    },
    {
        "content": "<p>Right now both options are on the table, the <code>\"C unwind\"</code> RFC picks one of them.</p>",
        "id": 179544330,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572536695
    },
    {
        "content": "<p>...right, with a link to a <code>rust</code> issue stating that the behavior was originally introduced in Rust 1.24.</p>",
        "id": 179544379,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572536717
    },
    {
        "content": "<p>If that was really the case, allowing <code>extern \"C\"</code> to unwind would be a breaking change</p>",
        "id": 179544545,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572536786
    },
    {
        "content": "<p>I.e., that is not a change to the <em>intended</em> defined-behavior of <code>extern \"C\"</code>; it just <em>implements</em> that behavior and makes it no longer undefined.</p>",
        "id": 179544561,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572536793
    },
    {
        "content": "<p>Yes, Rust 1.24.1 has a breaking change from 1.24.0</p>",
        "id": 179544604,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572536819
    },
    {
        "content": "<p>IIUC, Rust 1.24.0 still said that unwinding from an extern \"C\" function is UB</p>",
        "id": 179544644,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572536855
    },
    {
        "content": "<p>it did not provide any guarantees</p>",
        "id": 179544662,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572536859
    },
    {
        "content": "<p>it just implemented that UB to abort</p>",
        "id": 179544672,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572536867
    },
    {
        "content": "<p><a href=\"https://blog.rust-lang.org/2018/02/15/Rust-1.24.html#other-good-stuff\" target=\"_blank\" title=\"https://blog.rust-lang.org/2018/02/15/Rust-1.24.html#other-good-stuff\">https://blog.rust-lang.org/2018/02/15/Rust-1.24.html#other-good-stuff</a></p>",
        "id": 179544715,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572536882
    },
    {
        "content": "<blockquote>\n<p>In Rust 1.24, this code will now abort instead of producing undefined behavior.</p>\n</blockquote>",
        "id": 179544749,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572536892
    },
    {
        "content": "<p>Indeed. Well then this feature is already in the language, and allowing <code>extern \"C\"</code> to unwind isn't on the table</p>",
        "id": 179544793,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572536927
    },
    {
        "content": "<p>....</p>",
        "id": 179544800,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572536932
    },
    {
        "content": "<p>the unwind behavior was <em>immediately</em> restored in 1.24.1</p>",
        "id": 179544827,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572536952
    },
    {
        "content": "<p>so... then the <code>\"C unwind\"</code> rfc introduces this feature in the language</p>",
        "id": 179544852,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572536970
    },
    {
        "content": "<p>because 1.24.0 broke actual existing code</p>",
        "id": 179544854,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572536971
    },
    {
        "content": "<p>I believe my original wording was \"permits stabilizing\" that behavior. We can restore that verbiage if it's clearer.</p>",
        "id": 179544918,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572537001
    },
    {
        "content": "<p>You are confusing me. Either this feature is in the language already or not. And if it isn't, either <code>\"C unwind\"</code> introduces it or not.</p>",
        "id": 179544989,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572537018
    },
    {
        "content": "<p>My original claim is that right now it isn't in the language, and the <code>\"C unwind\"</code> RFC introduces it.</p>",
        "id": 179545027,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572537037
    },
    {
        "content": "<p>The <em>plan</em> has been in the language for a long, long, long time. Because there's only one implementation and we don't have a formal spec, whether or not a planned feature is \"in the language\" is a bit of a hazy question, I think.</p>",
        "id": 179545075,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572537064
    },
    {
        "content": "<p>But, yes, if the \"C unwind\" RFC (in its final form, not its draft form) says something like \"we stabilize the unwind-on-abort behavior\", then yes, once the RFC spec is actually implemented, that will be a breaking change.</p>",
        "id": 179545209,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572537124
    },
    {
        "content": "<p>it's not a breaking change</p>",
        "id": 179545226,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572537135
    },
    {
        "content": "<p>right now the behavior is undefined</p>",
        "id": 179545238,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572537140
    },
    {
        "content": "<p>defining undefined behavior is not a breaking change</p>",
        "id": 179545246,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572537146
    },
    {
        "content": "<p>I disagree. Wasmer and Lucet have relied on that behavior.</p>",
        "id": 179545288,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572537168
    },
    {
        "content": "<p>They know about it, and they can upgrade to \"C unwind\" afterwards</p>",
        "id": 179545330,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572537188
    },
    {
        "content": "<p>So, changing it breaks the functionality of their previously-working code, <em>regardless</em> of whether their previously-working code was \"guaranteed\" by the Rust Reference to work.</p>",
        "id": 179545340,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572537194
    },
    {
        "content": "<p>RIght.</p>",
        "id": 179545344,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572537198
    },
    {
        "content": "<p>Because we'd be changing the behavior of <code>extern \"C\"</code> in the implementation.</p>",
        "id": 179545369,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572537216
    },
    {
        "content": "<p>I disagree, that code is already broken.</p>",
        "id": 179545488,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572537261
    },
    {
        "content": "<p>And has always been.</p>",
        "id": 179545497,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572537272
    },
    {
        "content": "<p>I'm not going to re-hash that argument here; it was pretty played out in the original thread about <code>mozjpeg</code>.</p>",
        "id": 179545515,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572537292
    },
    {
        "content": "<p>Which is why i don't know why you are bringing it up again.</p>",
        "id": 179545537,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572537307
    },
    {
        "content": "<p>The point is: the design for <code>extern \"C unwind\"</code> does not necessarily imply the behavior of <code>extern \"C\"</code>. For the last several years, the lang team has been consistent in stating that the <em>desired</em> behavior for <code>extern \"C\"</code> to have \"someday\" is abort-on-unwind.</p>",
        "id": 179545564,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572537330
    },
    {
        "content": "<p>You claim that defining undefined behavior is a breaking change. The logical consequence of that is that we cannot define undefined behavior, and therefore, we can't change <code>extern \"C\"</code> to anything (neither allow unwinding, nor disallow it).</p>",
        "id": 179545595,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572537355
    },
    {
        "content": "<p>I disagree with the claim, and the logical consequence of that is that we can define the behavior of <code>extern \"C\"</code> to whatever we want.</p>",
        "id": 179545728,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572537438
    },
    {
        "content": "<p>The main issue was that <code>#[unwind(allowed)]</code> was still unstable, which mean there was no way for people to fix their code to no longer make it UB.</p>",
        "id": 179545766,
        "sender_full_name": "Amanieu",
        "timestamp": 1572537474
    },
    {
        "content": "<p>Sure, but that's a practical issue orthogonal to whether \"defining UB to something\" is a breaking change or not.</p>",
        "id": 179545835,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572537508
    },
    {
        "content": "<p>Just because we can define the behavior of <code>extern \"C\"</code> from undefined to something else does not mean that we should do it, e.g., until a different feature is added to the language.</p>",
        "id": 179545886,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572537547
    },
    {
        "content": "<p>I think there are a couple logical leaps there, but in any case that's beside the point. All I'm trying to say is that, until an RFC saying otherwise lands, we can still decide not to stabilize <code>extern \"C\"</code>'s abort-on-unwind behavior, <em>independently</em> of introducing the <code>extern \"C unwind\"</code> feature.</p>",
        "id": 179545908,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572537557
    },
    {
        "content": "<p>Sure, we could change the <code>\"C unwind\"</code> RFC to not guarantee that <code>extern \"C\"</code> panics on abort, that prevents <code>NeverUnwinds</code> from working</p>",
        "id": 179546011,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572537606
    },
    {
        "content": "<p>Therefore, it is not true the <code>extern \"C unwind\"</code> introduces the \"noexcept\" concept; it <em>is</em> true that the <em>currently planned guarantee</em> for <code>extern \"C\"</code> would introduce the \"noexcept\" concept (though, again, I think it's much weaker than you've stated above).</p>",
        "id": 179546061,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572537644
    },
    {
        "content": "<p>I'm not sure where you are going. Do you want to remove the abort-on-panic guarantee from the <code>\"C unwind\"</code> RFC?</p>",
        "id": 179546153,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572537717
    },
    {
        "content": "<p>This is why I want to know what Centril thinks of the \"FFI is not a sandbox\" quote. The lang team has been planning (since long before I got involved with this effort) to make <code>extern \"C\"</code> abort-on-unwind, which, as you're now pointing out, creates a less-powerful <code>noexcept</code>-like feature. If the lang team thinks this is an okay thing to introduce this way, well, okay. If this is something they hadn't considered before and makes them reconsider the abort-on-unwind issue, that's also okay.</p>",
        "id": 179546238,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572537764
    },
    {
        "content": "<blockquote>\n<p>again, I think it's much weaker than you've stated above</p>\n</blockquote>\n<p>What does<code>noexcept</code> allow that <code>extern \"C\"</code> does not ?</p>",
        "id": 179546274,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572537783
    },
    {
        "content": "<p>You can apply it to <code>Fn</code>s, not just <code>fn</code>s, for one</p>",
        "id": 179546310,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572537806
    },
    {
        "content": "<p>(Or at least, I would expect it to be designed in such a way)</p>",
        "id": 179546348,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572537830
    },
    {
        "content": "<p><code>extern \"C\" fn foo&lt;F: Fn(...) -&gt; ...&gt;(f: F) -&gt; ... { f(...) }</code></p>",
        "id": 179546364,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572537840
    },
    {
        "content": "<p>You can trivially wrap <code>Fn</code> traits in <code>extern \"C\"</code> functions to apply it.</p>",
        "id": 179546424,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572537861
    },
    {
        "content": "<p>Again, that might as well be a lambda</p>",
        "id": 179546431,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572537864
    },
    {
        "content": "<p>That's what <a href=\"#narrow/stream/210922-wg-ffi-unwind/topic/noexcept-like.20feature/near/179520449\" title=\"#narrow/stream/210922-wg-ffi-unwind/topic/noexcept-like.20feature/near/179520449\">https://rust-lang.zulipchat.com/#narrow/stream/210922-wg-ffi-unwind/topic/noexcept-like.20feature/near/179520449</a> does</p>",
        "id": 179546451,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572537879
    },
    {
        "content": "<p>But, yes, it allows such wrapping</p>",
        "id": 179546456,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572537881
    },
    {
        "content": "<blockquote>\n<p>That's what <a href=\"#narrow/stream/210922-wg-ffi-unwind/topic/noexcept-like.20feature/near/179520449\" title=\"#narrow/stream/210922-wg-ffi-unwind/topic/noexcept-like.20feature/near/179520449\">https://rust-lang.zulipchat.com/#narrow/stream/210922-wg-ffi-unwind/topic/noexcept-like.20feature/near/179520449</a> does</p>\n</blockquote>\n<p>Yes, I remember, and I responded there!</p>",
        "id": 179546489,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572537908
    },
    {
        "content": "<blockquote>\n<p>Again, that might as well be a lambda</p>\n</blockquote>\n<p>Do you have a playground link? <code>extern \"C\" | ... | ...</code> is invalid syntax.</p>",
        "id": 179546554,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572537946
    },
    {
        "content": "<p>Or do you mean that the lambda can coerce to an <code>extern \"C\" fn</code> type if it captures no environment ?</p>",
        "id": 179546668,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572538001
    },
    {
        "content": "<p>(notice that the trait works for closures with an environment)</p>",
        "id": 179546722,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572538024
    },
    {
        "content": "<p>I was thinking of something else from the RFC draft, about converting different ABIs to each other:</p>\n<div class=\"codehilite\"><pre><span></span>It is\n252-not possible, for example, to cast a `extern &quot;C&quot; fn()` value into a `extern &quot;C\n253-unwind&quot; fn()` value. It is however possible to convert between ABIs by using a\n254-closure expression (which is then coerced into a standalone function):\n255-\n256-```rust\n257-fn convert(f: extern &quot;C&quot; fn()) -&gt; extern &quot;C unwind&quot; fn() {\n258:    return || f();\n259-}\n260-```\n</pre></div>",
        "id": 179546884,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572538117
    },
    {
        "content": "<p>Yes, that works, but requires the lambda to have no environment.</p>",
        "id": 179547076,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572538210
    },
    {
        "content": "<p>Obviously you'd change the signature, from <code>extern \"C\" fn -&gt; extern \"C unwind fn</code> to <code>Fn -&gt; extern \"C\" fn</code>, but it's the same idea</p>",
        "id": 179547080,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572538211
    },
    {
        "content": "<p>Fair enough.</p>",
        "id": 179547092,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572538221
    },
    {
        "content": "<p>The trait works even if the lambda captures an environment, it works for all Fn traits in general</p>",
        "id": 179547098,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572538234
    },
    {
        "content": "<p>The problem I mentioned is that both the trait and the coercion need to \"adapt\" the ABIs</p>",
        "id": 179547141,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572538265
    },
    {
        "content": "<p><code>fn convert(f: extern \"Rust\" fn()) -&gt; extern \"C unwind\" fn() { || f() }</code> needs to adapt the Rust ABI (or any other) to the <code>\"C unwind\"</code> ABI</p>",
        "id": 179547177,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572538296
    },
    {
        "content": "<p>Right...</p>",
        "id": 179547199,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572538311
    },
    {
        "content": "<p>so you end up with an ABI dance that hopefully LLVM removes, but its at least in the language</p>",
        "id": 179547259,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572538332
    },
    {
        "content": "<p>A proper <code>noexcept</code> feature removes this, but that's the only thing I can think of in which they differ.</p>",
        "id": 179547296,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572538357
    },
    {
        "content": "<p>That makes <code>extern \"C\"</code> only slightly less powerful than <code>noexcept</code> in my eyes, unless I'm missing other differences. A lot less ergonomic though.</p>",
        "id": 179547323,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572538382
    },
    {
        "content": "<p>Anyway: I don't really have an opinion on whether introducing the panic-on-abort logic in <code>extern \"C\"</code> is a great idea. Again, that's why I want the lang team to weigh in on it, since they've been planning it for a <em>long</em> time. If they're committed to it, I don't think it matters one way or the other whether it stabilizes as part of the <code>extern \"C unwind\"</code> RFC or separately.</p>",
        "id": 179547359,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572538413
    },
    {
        "content": "<p>It kind of needs to either stabilize at the same time as <code>\"C unwind\"</code> or afterwards, because otherwise Lucene breaks without an easy migration path.</p>",
        "id": 179547478,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572538474
    },
    {
        "content": "<p>Right, it's the \"or afterwards\" on which I have no opinion</p>",
        "id": 179547495,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572538492
    },
    {
        "content": "<p>It's kind of weird to add a <code>\"C unwind\"</code> ABI while reserving the right to allow <code>\"C\"</code> to unwind</p>",
        "id": 179547545,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572538541
    },
    {
        "content": "<p><span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 179547610,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572538571
    },
    {
        "content": "<p>I don't think it's that weird, because <code>\"C unwind\"</code> is more explicit and will have well-defined behavior.</p>",
        "id": 179547650,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572538600
    },
    {
        "content": "<p>If \"C\" is defined to allow unwinding, then it has defined behavior as well, and current code works correctly without changes.</p>",
        "id": 179547711,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572538674
    },
    {
        "content": "<p>....right</p>",
        "id": 179547716,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572538680
    },
    {
        "content": "<p>So I think it does make sense to do both as part of the same RFC.</p>",
        "id": 179547767,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572538691
    },
    {
        "content": "<p>that's...fine</p>",
        "id": 179547772,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572538698
    },
    {
        "content": "<p>again, I have no opinion</p>",
        "id": 179547779,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572538703
    },
    {
        "content": "<p>Otherwise its kind of a bit of a big unresolved question.</p>",
        "id": 179547787,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572538711
    },
    {
        "content": "<p>Leaving questions unresolved in the language spec but promising to resolve them eventually is very nearly the entire purpose of this group!</p>",
        "id": 179547849,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572538750
    },
    {
        "content": "<p>I think C++'s approach of letting <code>extern \"C\"</code> functions unwind is entirely reasonable. If the <code>mozjpeg</code> discussion had led to the language team agreeing with this position, and deciding to let <code>extern \"C\"</code> functions unwind and not consider them UB, then yeah, we wouldn't need <code>\"C unwind\"</code>. But that's not where we are right now.</p>",
        "id": 179548017,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572538839
    },
    {
        "content": "<p>Again, that's why I added the \"FFI is not a sandbox\" quote to Niko's HackMD doc, and why I'm saying that this is a discussion that needs to be had with the lang team.</p>",
        "id": 179548083,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572538896
    },
    {
        "content": "<p>This WG is a sub-group of the lang team, so its kind of natural to discuss these here and prepare summaries for lang team discussion</p>",
        "id": 179548366,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572539060
    },
    {
        "content": "<p>I'm not aware of anyone raising the issue that we are technically adding 99% of a <code>noexcept</code> feature to the language, just limited to the <code>\"C\"</code> abi, and less ergonomic to use, but adding the same kind of power</p>",
        "id": 179548447,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572539114
    },
    {
        "content": "<p>Okay, would you like to add that to the HackMD issue yourself?</p>",
        "id": 179548849,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572539356
    },
    {
        "content": "<p>Sure, where is it ?</p>",
        "id": 179548881,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572539377
    },
    {
        "content": "<p><a href=\"https://hackmd.io/ymsEL6OpR6OSMoFr1As1rw?view\" target=\"_blank\" title=\"https://hackmd.io/ymsEL6OpR6OSMoFr1As1rw?view\">https://hackmd.io/ymsEL6OpR6OSMoFr1As1rw?view</a></p>",
        "id": 179548902,
        "sender_full_name": "Amanieu",
        "timestamp": 1572539390
    },
    {
        "content": "<p>I'll let you know when I add it so that you can check if I presented your arguments accurately</p>",
        "id": 179548974,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572539415
    },
    {
        "content": "<p>AFAIK, the only lang team member who is somewhat active in this group who (if I remember correctly) was strongly against letting <code>extern \"C\"</code> unwind is Centril. I think he would be the one to talk to about whether he thinks this is a compelling reason to change course on the planned <code>extern \"C\"</code> behavior.</p>",
        "id": 179549020,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572539449
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"132920\">@gnzlbg</span> Don't worry about presenting my arguments accurately; just explain why <code>extern \"C\"</code> is an implicit <code>noexcept</code>, and why you think that's a concern.</p>",
        "id": 179549068,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572539485
    },
    {
        "content": "<p>I still think that's essentially the same argument being made in the section I added at the bottom, about FFI being a \"sandbox\", so feel free to add it there, or add a new section, as you see fit.</p>",
        "id": 179549096,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572539515
    },
    {
        "content": "<p>My personal feeling is ambivalent: I'll just update my code according to whatever is decided.</p>",
        "id": 179549565,
        "sender_full_name": "Amanieu",
        "timestamp": 1572539810
    },
    {
        "content": "<blockquote>\n<p>Don't worry about presenting my arguments accurately; just explain why extern \"C\" is an implicit noexcept, and why you think that's a concern.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"120076\">@Kyle Strand</span> ok I;ve done that in the last subsection, as an argument against making <code>extern \"C\"</code> never unwind by default</p>",
        "id": 179552403,
        "sender_full_name": "gnzlbg",
        "timestamp": 1572541373
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 179552650,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1572541543
    },
    {
        "content": "<p>I've finally caught up with this great. <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>\n<p><span class=\"user-mention\" data-user-id=\"120076\">@Kyle Strand</span> I see that I've been mentioned a few times. Feel free to ping me if you want my input.</p>",
        "id": 180597308,
        "sender_full_name": "centril",
        "timestamp": 1573628067
    },
    {
        "content": "<p>I've left some comments in the HackMD; so far it has enhanced my belief that <code>nounwind</code> for <code>extern \"C\"</code> is the right default</p>",
        "id": 180597314,
        "sender_full_name": "centril",
        "timestamp": 1573628096
    },
    {
        "content": "<p>Some other points:</p>\n<p>- I agree that <code>NeverUnwinds</code> adds no more expressive power than <code>extern \"C\"</code> already affords one way or the other. It is indeed an alias.</p>\n<p>- I cannot tell whether <span class=\"user-mention\" data-user-id=\"132920\">@gnzlbg</span>  is arguing for or against <code>nounwind</code> by default by discussing <code>NeverUnwinds</code>. To me, however, it would be an advantage if I can use <code>extern \"C\"</code> to encode higher order functions where I know that the passed-in function cannot unwind. The fact that there might be desirable generalizations in terms of <code>impl nopanic Fn(..)</code> does not, in my view, negate that advantage. A generalization having short-hands for the common case isn't a bad thing in language design.</p>\n<p>- Further to ^-, we should, in my view, clarify whether we allow negative reasoning wrt. <code>extern \"C\"</code> having <code>nounwind</code> being UB. I think it would be useful to allow such negative reasoning <em>in this case</em>.</p>\n<p>- The use of \"breaking change\" in this thread has been ambiguous on both <span class=\"user-mention\" data-user-id=\"132920\">@gnzlbg</span>'s and <span class=\"user-mention\" data-user-id=\"120076\">@Kyle Strand</span>'s ends. We can think of \"breaking\" in the sense of RFC 1122 or in \"breaking in practice\". In the former sense, we all agree that unwinding through <code>extern \"C\"</code> is UB. In the latter sense, despite explicit documentation in the reference to the contrary and LLVM UB, some people rely on the UB not to cause mis-compilations. It's clear to me that we are allowed to break those clients, but this WG exists because to resolve the soundness issue of <code>extern \"C\" fn foo(...) { ... }</code> we need to offer an alternative before we re-add the abort shim.</p>\n<p>- Further to ^--, we must add the abort shim for <code>extern \"C\" fn foo() { ... }</code> or remove <code>nounwind</code> in LLVM. For the purposes of soundness, this is a binary choice.</p>",
        "id": 180597940,
        "sender_full_name": "centril",
        "timestamp": 1573628666
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"126931\">@centril</span> I’m not arguing against or in favor of nounwind by default, just trying to point out that no matter which syntax we use and how we try to limit it, we probably end up adding a NeverUnwinds kind of capability to the language that doesn’t exist today. Instead of doing that „by accident“ it might be worth it to step back and consider doing that „by design“.</p>",
        "id": 180598344,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573629150
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"132920\">@gnzlbg</span> Ok, so you are neutral and would like more deliberation on this; very fair.  But what does \"by design\" entail?</p>",
        "id": 180598371,
        "sender_full_name": "centril",
        "timestamp": 1573629205
    },
    {
        "content": "<p>There was also the possibility of allowing all extern “C” functions to unwind, and figure out later how to specify that some do not unwind. That solution doesn’t add a NeverUnwinds capability to the language.</p>",
        "id": 180598382,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573629232
    },
    {
        "content": "<p>it could mean designing an effect system, but that's is comparatively hugely more complicated than a mere ABI string from the POV of the type system</p>",
        "id": 180598383,
        "sender_full_name": "centril",
        "timestamp": 1573629232
    },
    {
        "content": "<p>We already have const, async, target feature, ...</p>",
        "id": 180598430,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573629261
    },
    {
        "content": "<p>We could add another nounwind qualifier</p>",
        "id": 180598440,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573629272
    },
    {
        "content": "<p>But there are many trade offs involved</p>",
        "id": 180598444,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573629294
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"132920\">@gnzlbg</span> yes, but note that const functions cannot be polymorphic yet, and if they are, we haven't decided to add e.g. <code>arg: impl const Fn()</code> which isn't just polymorphic but \"must\" be passed-in a <code>const fn</code></p>",
        "id": 180598468,
        "sender_full_name": "centril",
        "timestamp": 1573629327
    },
    {
        "content": "<p>async higher order functions aren't a thing either</p>",
        "id": 180598479,
        "sender_full_name": "centril",
        "timestamp": 1573629346
    },
    {
        "content": "<p>These trade offs might not be worth solving right now. We could just allow all extern “C” to unwind and provide an FFI only attribute to specify that some unknown ones are known to not unwind</p>",
        "id": 180598529,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573629367
    },
    {
        "content": "<p>I agree that abstracting over effects would be useful, but I'm not the only one to convince</p>",
        "id": 180598530,
        "sender_full_name": "centril",
        "timestamp": 1573629370
    },
    {
        "content": "<p>But don’t reflect that on the ABI</p>",
        "id": 180598532,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573629375
    },
    {
        "content": "<p>Avoiding NeverUnwinds</p>",
        "id": 180598539,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573629385
    },
    {
        "content": "<p>In Rust, LLVM automatically infers nounwind anyways</p>",
        "id": 180598545,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573629405
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"132920\">@gnzlbg</span> I don't see much gain in delaying solving that; it's not like preventing <code>NeverUnwinds</code> is a useful goal (imo)</p>",
        "id": 180598550,
        "sender_full_name": "centril",
        "timestamp": 1573629422
    },
    {
        "content": "<p>So for an Exeter “C” defined in Rust this attribute isn’t necessary</p>",
        "id": 180598552,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573629422
    },
    {
        "content": "<p>and I have not been convinced that changing the defaults is the right move</p>",
        "id": 180598561,
        "sender_full_name": "centril",
        "timestamp": 1573629437
    },
    {
        "content": "<p>I think that having NeverUnwinds only work for extern C is bad</p>",
        "id": 180598564,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573629450
    },
    {
        "content": "<p>It requires juggling between the Rust and the C ABI all the time</p>",
        "id": 180598577,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573629472
    },
    {
        "content": "<p>For no reason</p>",
        "id": 180598581,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573629477
    },
    {
        "content": "<p>I agree as well it would be useful, but it is a big hack</p>",
        "id": 180598622,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573629490
    },
    {
        "content": "<p>I don't think users would be encouraged to somehow sprinkle <code>extern \"C\" fn</code> in HoFs all of a sudden</p>",
        "id": 180598635,
        "sender_full_name": "centril",
        "timestamp": 1573629516
    },
    {
        "content": "<p>A proper solution might be easier if all ABI strings would behave similarly wrt unwinding</p>",
        "id": 180598644,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573629532
    },
    {
        "content": "<p>we could also split things into <code>extern \"C\", \"unwind\"</code> and now allow <code>extern \"Rust\", \"unwind\"</code> -- that's still a cheap solution wrt. spec and compiler internals</p>",
        "id": 180598656,
        "sender_full_name": "centril",
        "timestamp": 1573629554
    },
    {
        "content": "<p>very cheap in fact</p>",
        "id": 180598659,
        "sender_full_name": "centril",
        "timestamp": 1573629566
    },
    {
        "content": "<p>Rust is unwind by default, if C is nounwind by default, we’d need both “unwind” and “nounwind”</p>",
        "id": 180598708,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573629605
    },
    {
        "content": "<p>sure</p>",
        "id": 180598716,
        "sender_full_name": "centril",
        "timestamp": 1573629617
    },
    {
        "content": "<p>not a problem imo</p>",
        "id": 180598719,
        "sender_full_name": "centril",
        "timestamp": 1573629622
    },
    {
        "content": "<p>Imagine if extern “C” functions were const fn by default</p>",
        "id": 180598721,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573629622
    },
    {
        "content": "<p>still very cheap</p>",
        "id": 180598724,
        "sender_full_name": "centril",
        "timestamp": 1573629625
    },
    {
        "content": "<p>We’d be in a bit more trouble with traits</p>",
        "id": 180598728,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573629638
    },
    {
        "content": "<p>E.g need to implement !const trait impls for extern “C”</p>",
        "id": 180598741,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573629662
    },
    {
        "content": "<p>We can also say that extern “C” functions don’t unwind by default</p>",
        "id": 180598752,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573629703
    },
    {
        "content": "<blockquote>\n<p>Imagine if extern “C” functions were const fn by default</p>\n</blockquote>\n<p>That might have made sense if <code>const fn</code> was the default and we had <code>io fn</code> for adding the effect instead of stripping away from the base effect</p>",
        "id": 180598755,
        "sender_full_name": "centril",
        "timestamp": 1573629707
    },
    {
        "content": "<p>Unknown ones</p>",
        "id": 180598756,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573629709
    },
    {
        "content": "<p>@centril but for Rust it would be different than for extern C</p>",
        "id": 180598798,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573629733
    },
    {
        "content": "<p>The point isn’t what default makes sense, but having different defaults for const depending on the ABI</p>",
        "id": 180598806,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573629757
    },
    {
        "content": "<p>I don't think there's anything inherently wrong with having different defaults</p>",
        "id": 180598813,
        "sender_full_name": "centril",
        "timestamp": 1573629775
    },
    {
        "content": "<p>I think that it is possible for extern “C” to allow unwinding</p>",
        "id": 180598815,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573629779
    },
    {
        "content": "<p>And for unknown extern “C” functions to be nounwind by default</p>",
        "id": 180598824,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573629792
    },
    {
        "content": "<p>Those aren’t incompatible choices</p>",
        "id": 180598829,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573629804
    },
    {
        "content": "<p>Possible, yes, desirable, that's debatable (I think not personally)</p>",
        "id": 180598834,
        "sender_full_name": "centril",
        "timestamp": 1573629808
    },
    {
        "content": "<p>What’s the downside ?</p>",
        "id": 180598840,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573629817
    },
    {
        "content": "<p>It’s just an optimization attribute</p>",
        "id": 180598844,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573629828
    },
    {
        "content": "<p>If someone wants to avoid it they can use an attribute</p>",
        "id": 180598888,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573629845
    },
    {
        "content": "<p>Having differences between \"unknown\" and known feels even more inconsistent so to speak</p>",
        "id": 180598904,
        "sender_full_name": "centril",
        "timestamp": 1573629871
    },
    {
        "content": "<p>as for nounwind being the default, I think the hackmd elaborates</p>",
        "id": 180598914,
        "sender_full_name": "centril",
        "timestamp": 1573629882
    },
    {
        "content": "<p>so I won't repeat those arguments</p>",
        "id": 180598922,
        "sender_full_name": "centril",
        "timestamp": 1573629892
    },
    {
        "content": "<p>It’s not a difference between known and unknown</p>",
        "id": 180598926,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573629894
    },
    {
        "content": "<p>Known functions can be nounwind as well</p>",
        "id": 180598935,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573629906
    },
    {
        "content": "<p>then I don't understand what you are saying</p>",
        "id": 180598939,
        "sender_full_name": "centril",
        "timestamp": 1573629909
    },
    {
        "content": "<p>we have 3 things: imports, exports, pointers</p>",
        "id": 180598950,
        "sender_full_name": "centril",
        "timestamp": 1573629925
    },
    {
        "content": "<p>nounwind is an optimizer attribute</p>",
        "id": 180598956,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573629927
    },
    {
        "content": "<p>well unless you allow negative reasoning, in which case you can do type based reasoning on it</p>",
        "id": 180598993,
        "sender_full_name": "centril",
        "timestamp": 1573629952
    },
    {
        "content": "<p>We can apply nounwind to declarations (imports) by default and say that if they unwind the behavior is undefined, and that you can use an attribute to allow that</p>",
        "id": 180599039,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573629981
    },
    {
        "content": "<p>The type doesn’t encode that attribute</p>",
        "id": 180599046,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573630001
    },
    {
        "content": "<p>So you can’t do any kind of type based reasoning with it</p>",
        "id": 180599049,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573630018
    },
    {
        "content": "<p>You cannot express that a function pointer does not unwind, etc</p>",
        "id": 180599056,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573630034
    },
    {
        "content": "<p>I know that we can, but it seems strictly less powerful but more costly in terms of spec &amp; compiler internals</p>",
        "id": 180599057,
        "sender_full_name": "centril",
        "timestamp": 1573630038
    },
    {
        "content": "<p>Why more costly ?</p>",
        "id": 180599061,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573630050
    },
    {
        "content": "<p>“If it’s a extern C decl, add nounwind I’d attribute not present” we already have this logic</p>",
        "id": 180599068,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573630079
    },
    {
        "content": "<p>For the #[unwinds(...)] attribute</p>",
        "id": 180599109,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573630093
    },
    {
        "content": "<p>ABI strings are an existing machinery whereas an attribute adds something <em>different</em> in the pipeline</p>",
        "id": 180599115,
        "sender_full_name": "centril",
        "timestamp": 1573630112
    },
    {
        "content": "<p>it's a new sort of category</p>",
        "id": 180599117,
        "sender_full_name": "centril",
        "timestamp": 1573630117
    },
    {
        "content": "<p>and new categories cost more</p>",
        "id": 180599119,
        "sender_full_name": "centril",
        "timestamp": 1573630122
    },
    {
        "content": "<p>We need the attribute any ways</p>",
        "id": 180599123,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573630139
    },
    {
        "content": "<p>why that?</p>",
        "id": 180599128,
        "sender_full_name": "centril",
        "timestamp": 1573630150
    },
    {
        "content": "<p>For unknown function, we can’t prove that they don’t unwind</p>",
        "id": 180599129,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573630152
    },
    {
        "content": "<p>Even for an extern “Rust”</p>",
        "id": 180599130,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573630162
    },
    {
        "content": "<p>Unless we add a more powerful mechanism, like an effect, that we can use instead</p>",
        "id": 180599135,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573630187
    },
    {
        "content": "<p>But if we ever do that we can deprecate the FFI Import-only attribute</p>",
        "id": 180599182,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573630214
    },
    {
        "content": "<p>I'm not a fan of \"can deprecate\" reasoning in language design</p>",
        "id": 180599189,
        "sender_full_name": "centril",
        "timestamp": 1573630246
    },
    {
        "content": "<p>Me neither, but adding a new powerful effect by accident feels worse</p>",
        "id": 180599198,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573630266
    },
    {
        "content": "<p>(And C++ is a cautionary example wrt. \"can deprecate\")</p>",
        "id": 180599200,
        "sender_full_name": "centril",
        "timestamp": 1573630280
    },
    {
        "content": "<p>\"by accident\" suggests we are not aware of what is enabled</p>",
        "id": 180599214,
        "sender_full_name": "centril",
        "timestamp": 1573630319
    },
    {
        "content": "<p>This discussion proves otherwise ^^</p>",
        "id": 180599254,
        "sender_full_name": "centril",
        "timestamp": 1573630325
    },
    {
        "content": "<p>I think that NeverUnwinds is so useful that we should support it without a hack</p>",
        "id": 180599255,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573630326
    },
    {
        "content": "<p>You argue that people won’t use it much, but the existence of #[ni_panic] shows otherwise</p>",
        "id": 180599266,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573630355
    },
    {
        "content": "<p>People will go long ways to hack themselves into being able to use this feature</p>",
        "id": 180599284,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573630378
    },
    {
        "content": "<p>And NeverUnwinds is much better than #[no_panic] so it would at least replace it.</p>",
        "id": 180599299,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573630404
    },
    {
        "content": "<p><a href=\"https://crates.io/crates/no-panic/reverse_dependencies\" target=\"_blank\" title=\"https://crates.io/crates/no-panic/reverse_dependencies\">https://crates.io/crates/no-panic/reverse_dependencies</a> -- I'm not convinced by 6 rev deps.</p>\n<p>For an unknown function (e.g. via a function pointer), we can <em>assume</em> it doesn't unwind (in the spec, if not in LLVM); we don't need to prove</p>",
        "id": 180599300,
        "sender_full_name": "centril",
        "timestamp": 1573630417
    },
    {
        "content": "<p>But again, there are other reasons for C to be nounwind by default as in the HackMD</p>",
        "id": 180599309,
        "sender_full_name": "centril",
        "timestamp": 1573630442
    },
    {
        "content": "<p>I'm not troubled by having a low-cost extension to the type system being an enabler; you can call it a hack, but it doesn't feel that way to me</p>",
        "id": 180599357,
        "sender_full_name": "centril",
        "timestamp": 1573630480
    },
    {
        "content": "<p>Depends on the reverse deps</p>",
        "id": 180599362,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573630485
    },
    {
        "content": "<p>I agree that it's not as general as it could be</p>",
        "id": 180599369,
        "sender_full_name": "centril",
        "timestamp": 1573630492
    },
    {
        "content": "<p>Libm is used by compiler builtins</p>",
        "id": 180599374,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573630496
    },
    {
        "content": "<p>Which means is part of the rust runtime</p>",
        "id": 180599383,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573630505
    },
    {
        "content": "<p>On WASM at least</p>",
        "id": 180599390,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573630518
    },
    {
        "content": "<p>I mean in terms of unique uses of <code>no_panic</code> -- not transitive benefits throughout the ecosystem</p>",
        "id": 180599402,
        "sender_full_name": "centril",
        "timestamp": 1573630537
    },
    {
        "content": "<p>Ah yes, i don’t know how many people directly use the crate</p>",
        "id": 180599452,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573630564
    },
    {
        "content": "<p>Just that some low level libraries used by everybody so</p>",
        "id": 180599462,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573630579
    },
    {
        "content": "<p>ryu and libm seem big indeed</p>",
        "id": 180599465,
        "sender_full_name": "centril",
        "timestamp": 1573630599
    },
    {
        "content": "<p>I think it might be worth exploring how hard would it be to provide good support for this feature</p>",
        "id": 180599488,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573630634
    },
    {
        "content": "<p>And see if that would solve the FFI case</p>",
        "id": 180599492,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573630643
    },
    {
        "content": "<p>I don’t think these crates need generics</p>",
        "id": 180599500,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573630667
    },
    {
        "content": "<p>you mean like <code>impl nounwind Fn</code>?</p>",
        "id": 180599502,
        "sender_full_name": "centril",
        "timestamp": 1573630673
    },
    {
        "content": "<p>Libm doesn’t at least</p>",
        "id": 180599503,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573630676
    },
    {
        "content": "<p>Nounwind fn foo   As a start</p>",
        "id": 180599550,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573630698
    },
    {
        "content": "<p>Being generic over it could come later</p>",
        "id": 180599555,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573630710
    },
    {
        "content": "<p>probably not a whole lot difficult to implement in the compiler, but actually agreeing to a design and bringing the community on-board would be</p>",
        "id": 180599566,
        "sender_full_name": "centril",
        "timestamp": 1573630739
    },
    {
        "content": "<p>the effects polymorphism and as a modifier on bounds should be designed as a general effects thing, which years of proofing and testing</p>",
        "id": 180599589,
        "sender_full_name": "centril",
        "timestamp": 1573630780
    },
    {
        "content": "<p>I think C++ shows that a lot of code just stamps nounwind all over the place and tries to be generic over it for little benefit. So doing better might be desirable, but can be hard.</p>",
        "id": 180599634,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573630810
    },
    {
        "content": "<p>does C++ allow genericity over noexcept?</p>",
        "id": 180599655,
        "sender_full_name": "centril",
        "timestamp": 1573630844
    },
    {
        "content": "<p>Yes</p>",
        "id": 180599658,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573630850
    },
    {
        "content": "<p>But I think the const Trait impl solution is better</p>",
        "id": 180599663,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573630864
    },
    {
        "content": "<p>can you provide an example for my edification?</p>",
        "id": 180599665,
        "sender_full_name": "centril",
        "timestamp": 1573630871
    },
    {
        "content": "<p>Let me get out of bed</p>",
        "id": 180599668,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573630884
    },
    {
        "content": "<blockquote>\n<p>But I think the const Trait impl solution is better</p>\n</blockquote>\n<p>Yea, as with most of Rust and generics (Thanks Haskell &amp; ML!)</p>",
        "id": 180599684,
        "sender_full_name": "centril",
        "timestamp": 1573630920
    },
    {
        "content": "<p>So in C++, <code>noexcept(expr)</code> is a constant expression that returns <code>true</code> if <code>expr</code> cannot unwind, and <code>false</code> otherwise. In C++, <code>noexcept(bool-expr)</code> is also a function qualifier, that sets whether a function can or cannot unwind.</p>\n<p>So this code:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"o\">&gt;</span>\n<span class=\"n\">T</span> <span class=\"n\">generic_add</span><span class=\"p\">(</span><span class=\"n\">T</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">T</span> <span class=\"n\">b</span><span class=\"p\">)</span> <span class=\"k\">noexcept</span><span class=\"p\">(</span><span class=\"k\">noexcept</span><span class=\"p\">(</span><span class=\"n\">a</span> <span class=\"o\">+</span> <span class=\"n\">b</span><span class=\"p\">))</span> <span class=\"p\">{</span> <span class=\"k\">return</span> <span class=\"n\">a</span> <span class=\"o\">+</span> <span class=\"n\">b</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n</pre></div>\n\n\n<p>is generic over <code>noexcept</code>.</p>",
        "id": 180599832,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573631046
    },
    {
        "content": "<p>Now <em>that's</em> a hack :D</p>",
        "id": 180599857,
        "sender_full_name": "centril",
        "timestamp": 1573631107
    },
    {
        "content": "<p>In Rust, instead, we'll write <code>generic_add</code> as follows:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">fn</span> <span class=\"nf\">generic_add</span><span class=\"o\">&lt;</span><span class=\"n\">T</span>: <span class=\"nc\">Add</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">a</span>: <span class=\"nc\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span>: <span class=\"nc\">T</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">T</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>and whether it is <code>nounwind</code> or not depends on the <code>Add</code> impl, e.g., for <code>Foo</code>:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">nounwind</span><span class=\"w\"> </span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">add</span><span class=\"p\">(...)</span><span class=\"w\"> </span>-&gt; <span class=\"p\">...</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 180599862,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573631117
    },
    {
        "content": "<p>sure</p>",
        "id": 180599878,
        "sender_full_name": "centril",
        "timestamp": 1573631160
    },
    {
        "content": "<p>So people won't need to stamp <code>nounwind</code> all over the place, and that problem is \"solved\"</p>",
        "id": 180599921,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573631166
    },
    {
        "content": "<p>The main problem with this approach is that its an \"all methods of the trait or nothing\"</p>",
        "id": 180599943,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573631218
    },
    {
        "content": "<p>but that's a problem we already considered acceptable for <code>const fn</code></p>",
        "id": 180599954,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573631235
    },
    {
        "content": "<p>I don't think <code>nounwind</code> changes anything here</p>",
        "id": 180599960,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573631251
    },
    {
        "content": "<p>can always generalize later</p>",
        "id": 180599961,
        "sender_full_name": "centril",
        "timestamp": 1573631255
    },
    {
        "content": "<p>I agree it doesn't</p>",
        "id": 180599970,
        "sender_full_name": "centril",
        "timestamp": 1573631267
    },
    {
        "content": "<p>So for me I kind of prefer to explore how hard would a minimal solution for this problem be, and if that solution solves the FFI issue or not.</p>",
        "id": 180600021,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573631286
    },
    {
        "content": "<p>but <code>arg: impl nounwind Add</code> and <code>arg: impl const Add</code> would be something more</p>",
        "id": 180600022,
        "sender_full_name": "centril",
        "timestamp": 1573631289
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"132920\">@gnzlbg</span> I understand your point</p>",
        "id": 180600038,
        "sender_full_name": "centril",
        "timestamp": 1573631317
    },
    {
        "content": "<p>I'm not against adding a <code>#[unwind(aborts/allowed)]</code> attribute that's only usable inside <code>extern \"C\" { imports }</code> as a temporary solution. I would prefer not to do that, but we need to balance shipping with language evolution.</p>",
        "id": 180600056,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573631342
    },
    {
        "content": "<p>Personally I think that keeping <code>\"C\"</code> as nounwind and adding <code>\"C unwind\"</code> is the most low-cost solution that has the best defaults and disrupts the ecosystem least</p>",
        "id": 180600169,
        "sender_full_name": "centril",
        "timestamp": 1573631412
    },
    {
        "content": "<p>It might also well be that doing that makes also sense even if we had an <code>impl nounwind Trait</code> feature</p>",
        "id": 180600205,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573631458
    },
    {
        "content": "<p>I don't know.</p>",
        "id": 180600214,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573631466
    },
    {
        "content": "<p>Seems like we've explored the options at least <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 180600280,
        "sender_full_name": "centril",
        "timestamp": 1573631503
    },
    {
        "content": "<p>Yes</p>",
        "id": 180600330,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573631530
    },
    {
        "content": "<p>Might be worth summarizing in a hackmd</p>",
        "id": 180600334,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573631538
    },
    {
        "content": "<p>If you think there's a new alternative worth discussing, you could add it to <a href=\"https://hackmd.io/JIsPlpIPR2yTC051m4Mliw?edit\" target=\"_blank\" title=\"https://hackmd.io/JIsPlpIPR2yTC051m4Mliw?edit\">the meaning of C hackmd</a> -- I think an \"effect system\" variation probably qualifies. I myself am pretty unconvinced right now that we need genericity over this, and I also don't have nearly as many qualms about deprecation and evolution, I suspect. =) I feel like a <code>#[unwind(never)]</code> sort of attribute might well be reasonable. The big question to me though remains how much it matters which we default to, in terms of the interaction with <code>-Cpanic=abort</code>. I don't feel that's resolved yet, it requires some measurement and impl work.</p>",
        "id": 180634396,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1573657391
    },
    {
        "content": "<p>skimming over the thread, I'm not sure I saw much \"reasoning\" that didn't appear in there, but it certainly doesn't discuss effect systems</p>",
        "id": 180634551,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1573657448
    },
    {
        "content": "<p>worth noting that using the ABI <em>also</em> doesn't permit genericity</p>",
        "id": 180634560,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1573657455
    },
    {
        "content": "<p>to clarify about deprecation: I wouldn't want to <em>plan</em> on deprecating, but I think in this case that (a) generalization is kind of \"YAGNI\", (b) this is somewhat niche. So, if we do wind up with some kind of effect system we would like to generalize, I would be ok with transitioning this feature over to a new syntax so it can use it.</p>",
        "id": 180635011,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1573657698
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> By \"you\" do you mean me or <span class=\"user-mention\" data-user-id=\"132920\">@gnzlbg</span> ? I'm personally pretty happy with <code>extern \"C unwind\"</code> and I agree that this discussion didn't add anything novel</p>",
        "id": 180643070,
        "sender_full_name": "centril",
        "timestamp": 1573661858
    },
    {
        "content": "<p>(Also agree re. \"plan on deprecating\")</p>",
        "id": 180643107,
        "sender_full_name": "centril",
        "timestamp": 1573661877
    },
    {
        "content": "<p>I meant <span class=\"user-mention\" data-user-id=\"132920\">@gnzlbg</span>, but then I got nerd-swiped and added in some discussion of generics / effects, though I didn't go so far as to add a full blown alternative, because I don't think anybody really wants that</p>",
        "id": 180643317,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1573661980
    },
    {
        "content": "<p>I definitely want an effect system, but I also think that can wait ;)</p>",
        "id": 180643447,
        "sender_full_name": "centril",
        "timestamp": 1573662031
    },
    {
        "content": "<p>Yes, I meant \"I don't think anybody wants that to be done by this group\"</p>",
        "id": 180643835,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1573662233
    },
    {
        "content": "<p>Yes, an effect system is out of scope for this group.</p>",
        "id": 180718819,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573728273
    },
    {
        "content": "<p>By adding this feature we are adding a new effect to Rust.</p>",
        "id": 180718850,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573728304
    },
    {
        "content": "<p>I'm not suggesting that we should constrain the syntax to be compatible with a future effect system, only that it might maybe be worth it to consider a syntax that does not make it too hard to do so.</p>",
        "id": 180718958,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573728365
    },
    {
        "content": "<p>I'm not sure how important this particular effect is, whether it will ever matter to be generic over it, and therefore, I don't know whether more \"general purpose\" syntax for it (as opposed to \"C unwind\") would be worth it.</p>",
        "id": 180719110,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573728509
    },
    {
        "content": "<p>What I know is that some crates are already making \"this function never unwinds\" part of their API contract via a quite hacky macro / linker approach</p>",
        "id": 180719207,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573728586
    },
    {
        "content": "<p>And some of those APIs do not use the C ABI today</p>",
        "id": 180719255,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573728615
    },
    {
        "content": "<p>I would find it a bit weird if with this feature those people would start using the C ABI instead of the Rust ABI to expres \"never unwinds\"</p>",
        "id": 180719298,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573728660
    },
    {
        "content": "<blockquote>\n<p>I'm not suggesting that we should constrain the syntax to be compatible with a future effect system, only that it might maybe be worth it to consider a syntax that does not make it too hard to do so.</p>\n</blockquote>\n<p>To add to this, we have <code>const</code> which \"removes\" an effect, <code>async</code> which adds it, attributes like <code>#[target_feature(enable)]</code> which also add effects, etc.</p>\n<p>Right now all functions can be made <code>unwinds</code>, so we could add a <code>nounwind</code> syntax to remove that effect. That becomes a bit more complicated if whether a function unwinds or not is part of its \"ABI\" string, and we have to add both <code>unwinds</code> to add the effect to ABIs that are nounwind by default, and <code>nounwind</code> to remove it (or somehow support <code>!nounwind</code> or <code>!unwinds</code> or similar).</p>",
        "id": 180719479,
        "sender_full_name": "gnzlbg",
        "timestamp": 1573728834
    }
]