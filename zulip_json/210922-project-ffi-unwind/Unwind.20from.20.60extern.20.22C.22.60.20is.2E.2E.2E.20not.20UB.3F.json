[
    {
        "content": "<p>So I noticed that <a href=\"https://doc.rust-lang.org/reference/items/functions.html?highlight=abort#extern-function-qualifier\">the reference states</a>:</p>\n<blockquote>\n<p>Functions with an ABI that differs from \"Rust\" do not support unwinding in the exact same way that Rust does. Therefore, unwinding past the end of functions with such ABIs causes the process to abort.</p>\n</blockquote>\n<p>Is this right? This is wonderful. It's exactly what I was about to write a whole long thing arguing for. When did it happen?</p>\n<hr>\n<p>Background: I'm the maintainer of <code>rusqlite</code>, and I'm finially getting around to fixing it so that it doesn't allow panics to escape <code>extern \"C\"</code> functions, even in really obnoxious edge cases (like dtor panics from <code>Box&lt;dyn Any + Send&gt;</code>, the panic <code>ThreadLocalKey::with</code> does during thread shutdown, etc...)</p>\n<p>Sadly, with basically no exceptions, all of the functions were doing it wrong <em>somewhere</em> (turns out: just don't call into the stdlib if you need to avoid panics; it's all panics). This made me feel kinda bad, but I decided to see if anybody was doing it right. In my extremely exhaustive and scientific search of \"a few popular crates which wrap C libraries and have callbacks APIs\", pretty much nobody did this right (I was going to file bugs about this, but may not need to?).</p>\n<p>This convinced me that it was untenable for <code>extern \"C\"</code> functions defined from rust default to UB, and I was writing up something along these lines, going to ask what the process would be to go about trying to make this UB well-defined (it's so hard write code that avoids that UB that it needs an extremely convincing reason to be UB), but apparently someone beat me to the punch?</p>",
        "id": 277959908,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1649203158
    },
    {
        "content": "<p>Is <code>extern \"C-unwind\"</code> already stable?</p>",
        "id": 277960200,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649203382
    },
    {
        "content": "<p>It is not.</p>",
        "id": 277961117,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1649204297
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/Unwind.20from.20.60extern.20.22C.22.60.20is.2E.2E.2E.20not.20UB.3F/near/277959908\">said</a>:</p>\n<blockquote>\n<p>So I noticed that <a href=\"https://doc.rust-lang.org/reference/items/functions.html?highlight=abort#extern-function-qualifier\">the reference states</a>:</p>\n<blockquote>\n<p>Functions with an ABI that differs from \"Rust\" do not support unwinding in the exact same way that Rust does. Therefore, unwinding past the end of functions with such ABIs causes the process to abort.</p>\n</blockquote>\n<p>Is this right? This is wonderful. It's exactly what I was about to write a whole long thing arguing for. When did it happen?</p>\n</blockquote>\n<p>That's certainly the <em>desired</em> behavior, and that's actually been the intent for years now. (If memory serves, this is even mentioned in the first edition of <em>Programming Rust</em> by Blandy/Orendorff/Tindall.)</p>\n<p>But in practice, this broke existing projects while not actually providing any correct way to handle cross-language unwinding. Hence, the formation of this project group.</p>\n<p>As <span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> mentions, though, we still haven't stabilized the change in behavior that we've specified. But you can get the behavior on nightly using the <code>c_unwind</code> feature: <a href=\"https://doc.rust-lang.org/beta/unstable-book/language-features/c-unwind.html\">https://doc.rust-lang.org/beta/unstable-book/language-features/c-unwind.html</a></p>",
        "id": 277961463,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1649204651
    },
    {
        "content": "<p>I don't need the behavior really. I'm mostly concerned about not doing UB, and even then mostly in the presence of code which is (frankly) deliberately written to be an asshole (like doing <code>std::panic::panic_any(PanicOnDrop::new())</code> from code that's run inside catch_unwind)</p>",
        "id": 277970362,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1649214404
    },
    {
        "content": "<p>the fact that it will improve in the future is good to hear.</p>",
        "id": 277970377,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1649214430
    },
    {
        "content": "<p>ah hm</p>",
        "id": 277970385,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1649214454
    },
    {
        "content": "<p>if it doesnt abort then we'll unwind over sqlite, and i doubt it's testing/fuzzing care about that case, and maybe it would very bad things. i guess i should still add a panic guard in case the Box&lt;dyn Any + Send&gt; panics in its drop</p>",
        "id": 277970434,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1649214484
    }
]