[
    {
        "content": "<p>For the purposes of this project and all of its outputs, are all kinds of abnormal exits (<code>unwind</code>, <code>longjmp</code>, \"signal handler manually fiddles with program counter and stack pointer\", \"kernel manually fiddles with program counter and stack pointer\" ...) considered an \"unwind\"? Most interesting to me is MSVC which implements longjmp as an unwind but GNU does not. Do we consider longjmp an unwind everywhere? nowhere? only on msvc?</p>",
        "id": 254832129,
        "sender_full_name": "nagisa",
        "timestamp": 1632569563
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"133224\">@Nikita Popov</span></p>",
        "id": 254832144,
        "sender_full_name": "nagisa",
        "timestamp": 1632569580
    },
    {
        "content": "<p>setjmp/longjmp is declared UB in rust when jumping over frames with destructors according to the RFC. It doesn't matter if it is internally implemented as unwinding (windows) or register restore (unix).</p>",
        "id": 254832535,
        "sender_full_name": "bjorn3",
        "timestamp": 1632569963
    },
    {
        "content": "<p>In our case of interest are the abort-on-unwind drops. Do we think it is always UB to longjmp out of drop glue?</p>",
        "id": 254832988,
        "sender_full_name": "nagisa",
        "timestamp": 1632570391
    },
    {
        "content": "<p>Relatedly, what about longjmping _into_ a frame with destructors, not over it?</p>",
        "id": 254833028,
        "sender_full_name": "nagisa",
        "timestamp": 1632570473
    },
    {
        "content": "<p>You can't longjmp into a function call. You can only go up to callees, not down to previously returned functions as the stack has been clobbered.</p>",
        "id": 254833744,
        "sender_full_name": "bjorn3",
        "timestamp": 1632571165
    },
    {
        "content": "<p>I don't think jumping into a function call is happening in what I'm asking about? More specifically I'm talking about a case like </p>\n<div class=\"codehilite\"><pre><span></span><code>struct LongJmp; impl Drop for LongJmp { fn drop(&amp;self) { longjmp() } }\n\nfn has_destructors() {\n     setjmp();\n     drop(LongJmp); // jumps out of drop into a frame with destructors (but not over)\n}\n</code></pre></div>\n<p>if that makes sense?</p>",
        "id": 254836514,
        "sender_full_name": "nagisa",
        "timestamp": 1632573625
    },
    {
        "content": "<p>or whatever equivalents.</p>",
        "id": 254836521,
        "sender_full_name": "nagisa",
        "timestamp": 1632573637
    },
    {
        "content": "<p>I see. Not sure.</p>",
        "id": 254836940,
        "sender_full_name": "bjorn3",
        "timestamp": 1632574052
    },
    {
        "content": "<p>In C++ that's not undefined behaviour, only jumping over. I'd assume the same for Rust, tbh.</p>",
        "id": 254837405,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632574492
    },
    {
        "content": "<p>Although it would require rust exposing setjmp, since it's not a function and you can't grab it with FFI.</p>",
        "id": 254837462,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632574561
    },
    {
        "content": "<p>(And if you tried to do a wrapper function, it would have to be of the form of a with_setjmp that takes a closure, since once you've returned from a function, it's UB to longjmp back into it)</p>",
        "id": 254837702,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632574781
    },
    {
        "content": "<p>Does C++ still allow unwinding from their destructors? Or are they nounwind?</p>",
        "id": 254839917,
        "sender_full_name": "nagisa",
        "timestamp": 1632576622
    },
    {
        "content": "<p>And if it doesn't why does that work on msvc then?</p>",
        "id": 254839963,
        "sender_full_name": "nagisa",
        "timestamp": 1632576669
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123586\">nagisa</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/Is.20.60unwind.60.20any.20kind.20of.20abnormal.20exit.3F/near/254839917\">said</a>:</p>\n<blockquote>\n<p>Does C++ still allow unwinding from their destructors? Or are they nounwind?</p>\n</blockquote>\n<p>C++ doesn't treat unwinds from longjmp the same as exceptions, but yes to both. However, most destructors are <code>noexcept</code> (which terminates if they exit via an exception), and exiting a destructor called as a result of stack unwinding via an exception also terminates.</p>",
        "id": 254840343,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632576985
    },
    {
        "content": "<p><a href=\"http://eel.is/c++draft/csetjmp.syn#2\">http://eel.is/c++draft/csetjmp.syn#2</a></p>\n<blockquote>\n<p>The function signature longjmp(jmp_­buf jbuf, int val) has more restricted behavior in this document. A setjmp/longjmp call pair has undefined behavior if replacing the setjmp and longjmp by catch and throw would invoke any non-trivial destructors for any objects with automatic storage duration. A call to setjmp or longjmp has undefined behavior if invoked in a suspension context of a coroutine ([expr.await]).</p>\n</blockquote>",
        "id": 254840529,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632577155
    },
    {
        "content": "<p>Nothing about <code>longjmp</code>ing out of destructors, so it falls back to the definition in C.</p>",
        "id": 254840689,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632577253
    },
    {
        "content": "<p>Hm, this still doesn't directly say if in C++ setjmp/longjmp are considered to be a form of unwinding (though if I had to hazard a guess, unwinding is an implementation detail in the eyes of the C++ standard and not something that needs to be specified? there's only two references to unwinding and neither a specification of what it is.</p>",
        "id": 254840987,
        "sender_full_name": "nagisa",
        "timestamp": 1632577501
    },
    {
        "content": "<p>Here's another example</p>\n<div class=\"codehilite\"><pre><span></span><code>struct LongJmp; impl Drop for LongJmp { fn drop(&amp;self) { longjmp() } }\nstruct Boom; impl Drop for Boom { fn drop(&amp;self) { abort() } }\n\nfn has_destructors() {\n     setjmp();\n     let boom = Boom;\n     let guard = LongJmp;\n     // cleanups here jumps out of drop into a frame with destructors (but not over)\n}\n</code></pre></div>\n<p>As per C++ specification this is UB because replacing the jumps with throw/catch would invoke a destructor for <code>Boom</code>, I believe.</p>",
        "id": 254841263,
        "sender_full_name": "nagisa",
        "timestamp": 1632577725
    },
    {
        "content": "<p>This is something our POF-based definition doesn't capture.</p>",
        "id": 254841413,
        "sender_full_name": "nagisa",
        "timestamp": 1632577863
    },
    {
        "content": "<p>and for <code>-Zpanic-in-drop=abort</code> even the first example UB would be UB as per Rust definition AFAICT, for implementing abort-on-panic involves adding an equivalent of <code>catch_unwind</code>, making drop glue be a non-POF as per <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/2945-c-unwind-abi.md#plain-old-frames\">https://github.com/rust-lang/rfcs/blob/master/text/2945-c-unwind-abi.md#plain-old-frames</a></p>",
        "id": 254841573,
        "sender_full_name": "nagisa",
        "timestamp": 1632578008
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/Is.20.60unwind.60.20any.20kind.20of.20abnormal.20exit.3F/near/254840343\">said</a>:</p>\n<blockquote>\n<p>a destructor called as a result of stack unwinding via an exception also terminates.</p>\n</blockquote>\n<p>Isn't that like double-panic in Rust? This is reasonable and understandable behaviour.</p>",
        "id": 254841703,
        "sender_full_name": "nagisa",
        "timestamp": 1632578134
    },
    {
        "content": "<p><code>-Zpanic-in-drop=abort</code> restricts that kind of behaviour to any panic in drop/destructor being an abort (or <code>std::terminate()</code> in C++ parlance), even if not currently unwinding</p>",
        "id": 254841780,
        "sender_full_name": "nagisa",
        "timestamp": 1632578174
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123586\">nagisa</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/Is.20.60unwind.60.20any.20kind.20of.20abnormal.20exit.3F/near/254841413\">said</a>:</p>\n<blockquote>\n<p>This is something our POF-based definition doesn't capture.</p>\n</blockquote>\n<p>And we cannot really use the C++-like definition either because of <code>-Cpanic=abort</code>…</p>",
        "id": 254842264,
        "sender_full_name": "nagisa",
        "timestamp": 1632578578
    },
    {
        "content": "<p>So that everyone has a bit of context, here's the blog post announcing that this project group would be exploring <code>longjmp</code>: <a href=\"https://blog.rust-lang.org/inside-rust/2021/01/26/ffi-unwind-longjmp.html\">https://blog.rust-lang.org/inside-rust/2021/01/26/ffi-unwind-longjmp.html</a></p>\n<p><span class=\"user-mention silent\" data-user-id=\"123586\">nagisa</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/Is.20.60unwind.60.20any.20kind.20of.20abnormal.20exit.3F/near/254832129\">said</a>:</p>\n<blockquote>\n<p>For the purposes of this project and all of its outputs, are all kinds of abnormal exits... considered an \"unwind\"? ... Do we consider longjmp an unwind everywhere? nowhere? only on msvc?</p>\n</blockquote>\n<p>No, and nowhere. We did, however, <a href=\"https://github.com/rust-lang/project-ffi-unwind/pull/34\">broaden our charter</a> to bring <code>longjmp</code> into our purview. Currently, all interactions between <code>longjmp</code> and Rust frames should be considered undefined, because they have not been specified in any way, but as <span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span> noted, RFC-2945 only makes <code>longjmp</code> over non-POF frames (which generally means frames with destructors) explicitly (and permanently) undefined.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"123586\">nagisa</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/Is.20.60unwind.60.20any.20kind.20of.20abnormal.20exit.3F/near/254832988\">said</a>:</p>\n<blockquote>\n<p>In our case of interest are the abort-on-unwind drops. Do we think it is always UB to longjmp out of drop glue?</p>\n</blockquote>\n<p>I'm not sure what you mean here; <code>abort</code> will never call <code>drop</code>, abort-on-unwind should never trigger a <code>longjmp</code> even if you call <code>longjmp</code> in a <code>drop</code> function. But yes, I do expect that <code>longjmp</code> out of a <code>drop</code> function would be UB in the non-<code>abort</code> case.</p>\n<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> I'm not sure that <code>longjmp</code> inside a destructor would be well-defined in C++ either, actually. The fact that <code>throw</code>ing from a destructor causes the runtime to terminate doesn't seem to me to imply that the behavior of <code>longjmp</code> in the same context would \"fall back to\" that of the ISO C; I don't believe there's any such rule for interpreting the standard, since C++ has different semantics from C in quite a few places.</p>\n<p>I've heard of several people in fact using <code>longjmp</code> in Rust; that's a large part of the motivation for exploring how to make that well-defined. I would assume that some kind of closure is indeed how <code>longjmp</code> is being invoked, but I haven't looked at actual code examples.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"123586\">nagisa</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/Is.20.60unwind.60.20any.20kind.20of.20abnormal.20exit.3F/near/254841413\">said</a>:</p>\n<blockquote>\n<p>This is something our POF-based definition doesn't capture.</p>\n</blockquote>\n<p>Anything not captured by the POF definition should be treated with extreme caution. As I said above, even a simple <code>longjmp</code> over POFs is still technically UB in Rust simply because there's no specification for it yet. Additionally, per the above blogpost, we are leaning toward restricting <code>longjmp</code> further by introducing a new annotation required to make the behavior well defined.</p>",
        "id": 254860427,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1632594893
    },
    {
        "content": "<blockquote>\n<p>The fact that throwing from a destructor causes the runtime to terminate doesn't seem to me to imply that the behavior of longjmp in the same context would \"fall back to\" that of the ISO C; I don't believe there's any such rule for interpreting the standard, since C++ has different semantics from C in quite a few places.</p>\n</blockquote>\n<p>Functions defined by the C standard have the behaviour specified by cross-reference to ISO 9899:2018 (for ISO 14882:2020 and latest draft of the C++ standard), so except where the behaviour is altered by the C++ standard, it has the behaviour specified in the normative cross-reference.</p>",
        "id": 254861300,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632595774
    },
    {
        "content": "<p>Side note: it's not throwing from a destructor that causes termination - it's specifically throwing during stack unwinding. <br>\nThis code will throw an exception, for example, rather than terminate:</p>\n<div class=\"codehilite\" data-code-language=\"C++\"><pre><span></span><code><span class=\"kt\">void</span><span class=\"w\"> </span><span class=\"nf\">foo</span><span class=\"p\">(){</span><span class=\"w\"></span>\n<span class=\"w\">     </span><span class=\"k\">struct</span> <span class=\"nc\">S</span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">~</span><span class=\"n\">S</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"k\">noexcept</span><span class=\"p\">(</span><span class=\"nb\">false</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"c1\">// required as C++ specifies that destructors without an exception specification use the same one as the implicitly-declared version</span>\n<span class=\"w\">        </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">             </span><span class=\"k\">throw</span><span class=\"w\"> </span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">exception</span><span class=\"p\">{</span><span class=\"s\">\"Destroyed S\"</span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\">    </span><span class=\"c1\">// Exception is thrown here and unwinds the stack if caught. No std::terminate call, no undefined behaviour</span>\n</code></pre></div>\n<p>Same as how rust let's you panic!() from a drop impl, but only panicking during another panic aborts (although that's earlier than C++ - since it happens immediately at the second panic, rather than when unwinding out of the destructor).</p>",
        "id": 254861508,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632595934
    },
    {
        "content": "<p>But C has no rules about what happens \"during unwinding\", so this behavior isn't defined there either.</p>",
        "id": 254861742,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1632596159
    },
    {
        "content": "<p>It's not even clear to me what the expected behavior would be.</p>",
        "id": 254861810,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1632596201
    },
    {
        "content": "<p>E.g. would unwinding stop at the <code>setjmp</code> or continue up the stack?</p>",
        "id": 254861831,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1632596229
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120076\">BatmanAoD (Kyle Strand)</span> <a href=\"#narrow/stream/210922-project-ffi-unwind/topic/Is.20.60unwind.60.20any.20kind.20of.20abnormal.20exit.3F/near/254860427\">said</a>:</p>\n<blockquote>\n<p>...<br>\nI'm not sure what you mean here; <code>abort</code> will never call <code>drop</code>, abort-on-unwind should never trigger a <code>longjmp</code> even if you call <code>longjmp</code> in a <code>drop</code> function. But yes, I do expect that <code>longjmp</code> out of a <code>drop</code> function would be UB in the non-<code>abort</code> case.<br>\n...</p>\n</blockquote>\n<p>I mean <code>-Zpanic-in-drop=abort</code> here, sorry if I wasn't clear. Basically the expected behaviour with that flag enabled is that unwinding from a drop gets converted to an abort, regardless of what the program-wide <code>-Cpanic</code> setting is. Was wondering what is the behaviour we'd like to prescribe here for <code>longjmp</code>, but since we want to <em>never</em> consider longjmp to be an unwind, that question is moot.</p>",
        "id": 254867058,
        "sender_full_name": "nagisa",
        "timestamp": 1632600767
    },
    {
        "content": "<p>Well, unfortunately, we can't really prescribe a behavior other than \"undefined\" in a lot of <code>longjmp</code> cases, since a <code>longjmp</code> can occur pretty much anywhere. That's one major reason for wanting an annotation to limit where well-defined <code>longjmp</code> can happen, and leaving it UB everywhere else.</p>",
        "id": 254868751,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1632602412
    },
    {
        "content": "<p>Yeah, thats fine. I was more worried about us having some definition here ^^ No definition is actually easier to work with today ^^</p>",
        "id": 254869988,
        "sender_full_name": "nagisa",
        "timestamp": 1632603565
    },
    {
        "content": "<p>So as I understand this, even if <code>longjmp</code> was permitted to touch Rust, since it can't go anywhere too exciting and has to use a normal entry point, it would basically be semantically equivalent to emitting a <code>call</code> opcode, just with an arbitrary selection of actual opcodes?</p>",
        "id": 254879485,
        "sender_full_name": "Jubilee",
        "timestamp": 1632612969
    },
    {
        "content": "<p>I'm not sure I understand the question, possibly because I know hardly anything about the LLVM language and opcodes. What do you mean by \"a normal entry point\"? If the question is whether <code>longjmp</code> can be thought of as unwinding without landing pads, that's probably entirely true on Windows (where <code>forced_unwind</code> actually does just skip landing pads), and I don't see any immediate problems with that mental model for other OSes.</p>",
        "id": 254974879,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1632702560
    },
    {
        "content": "<p>The sense of \"entry point\" I meant is that it has to go to a block that would have already been \"semantically addressable\" within Rust. Like the start of a function is the canonical place you can \"address\", but yes, also initiating an unwinding procedure via <code>panic!</code>, or other join-points in control flow that you can reach via loops and breaks... in other words it can't do \"jump into a random point in Rust control flow and thus potentially skip over meaningful steps\", it would have to go to one of the existing join-points.</p>",
        "id": 256485093,
        "sender_full_name": "Jubilee",
        "timestamp": 1633554527
    },
    {
        "content": "<p>I feel like I'm treading into dangerous waters attempting to answer this, but yes, I would expect that to be a standard limitation on <code>longjmp</code> regardless of the caller's language. <code>setjmp</code> must be called first, and <code>longjmp</code> can only go back to where <code>setjmp</code> was called.</p>",
        "id": 256489283,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1633556461
    },
    {
        "content": "<p>Cool cool. I will not take your words as gospel but rather am just trying to begin to form an intuition.</p>",
        "id": 256496267,
        "sender_full_name": "Jubilee",
        "timestamp": 1633560289
    }
]