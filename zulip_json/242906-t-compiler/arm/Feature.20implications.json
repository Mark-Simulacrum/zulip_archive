[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120518\">@Eric Huss</span>  <span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span> Regarding <a href=\"https://github.com/rust-lang/reference/pull/1184\">#1184</a>:<br>\nThanks for <a href=\"https://github.com/rust-lang/rust/pull/91608#issuecomment-1076821903\">tagging</a> <span class=\"user-mention\" data-user-id=\"382356\">@Adam Gemmell</span>, but in case you were waiting for a response, note that he's on leave until next week.<br>\nIn the interest of clarity, and making sure that we all have the same understanding, I want to make clear that the feature implications in <a href=\"https://github.com/rust-lang/reference/pull/1184/files#diff-11f03f772eabdb1a762b90f1ce58afd34c7938b20beae226e451da44d4fcd73a\">the table that #1184 updates</a> are just those that LLVM applies itself. That means, for example, that \"dotprod\" doesn't imply \"neon\", even though architecturally it doesn't make sense without it. (I can invoke at least the old version of Clang I have to hand with <code>-march=armv8-a+nosimd+dotprod</code>, for example.)</p>\n<p>The LLVM implication behaviour is also duplicated in <a href=\"https://github.com/rust-lang/stdarch/blob/master/crates/std_detect/src/detect/os/linux/aarch64.rs#L206\">std_detect</a>. Note that <a href=\"https://github.com/rust-lang/stdarch/blob/master/crates/std_detect/src/detect/os/linux/aarch64.rs#L217\">std_detect itself does still expose \"fp\"</a>. My instinct is that that's correct at that level, but you <a href=\"https://github.com/rust-lang/rust/pull/91608/files#diff-36d95266eaed8a01edd4caaf54210bd5e3ae8a22b72fb49067e562557c3a3c3e\">removed a test for it</a> so perhaps I've misunderstood the intention.</p>",
        "id": 276460339,
        "sender_full_name": "Jacob Bramley",
        "timestamp": 1648120383
    },
    {
        "content": "<p>Eh, I just viewed the line in the test as irrelevant (...and was perhaps overenthusiastically stomping out instances of \"fp\" after having the PR bounce on missing a few). I drafted a PR for removing +fp from std_detect proper but I am not sure if I should actually open it for yeah, basically that reason: it's technically still valid to query the OS for.</p>\n<p>Noted re: the implications being LLVM's. I think we should probably bring most of that hierarchical logic into Rust on our side.</p>",
        "id": 276507116,
        "sender_full_name": "Jubilee",
        "timestamp": 1648141181
    },
    {
        "content": "<p>The problem, and the reason that we (really Adam) didn't do that, is that LLVM's inferences are incomplete. My thinking was that bringing that logic into Rust, with the objective of matching LLVM, would mean that we'd have to then stay in sync with LLVM updates. The next intuitive thought is to complete those inferences in Rust, so that we decouple this from LLVM's policy. However, that's harder than it sounds.</p>\n<p>I'm not aware of an official (architectural) feature inference graph, at least not all in once place, and even if someone extracts it from the architecture reference manual, we have to cope with the OS hiding features that it doesn't want to support. We could probably do _obvious_ cases, like making <code>dotprod</code> imply <code>neon</code> (since it uses NEON registers and generally _looks_ like NEON instructions) but they're open to interpretation, which makes them hard to validate. They're also an ongoing maintenance burden, as the features are quite fine-grained.</p>",
        "id": 276611207,
        "sender_full_name": "Jacob Bramley",
        "timestamp": 1648211357
    },
    {
        "content": "<p>I suppose the question is, how far do you think we should go with feature inference in Rust, and how valuable is it to have that in the front end?</p>\n<p>I must admit that I just thought that since no-one else does it (much), Rust probably doesn't need to either, but some level of inference could be really nice from a user perspective.</p>",
        "id": 276611248,
        "sender_full_name": "Jacob Bramley",
        "timestamp": 1648211384
    },
    {
        "content": "<p>Hmm. And LLVM does not have as strict a stability process.<br>\nWe might want to strike the entire implications column until we have an actually worked story for that.</p>",
        "id": 276653026,
        "sender_full_name": "Jubilee",
        "timestamp": 1648229314
    },
    {
        "content": "<blockquote>\n<p>I'm not aware of an official (architectural) feature inference graph, at least not all in once place, and even if someone extracts it from the architecture reference manual, we have to cope with the OS hiding features that it doesn't want to support.</p>\n</blockquote>\n<p>Yes, I asserted we should link Neon and FP and call them one feature mostly because they have a \"static dependency\" via being controlled by the same hardware in AArch64 mode (and thus they are the same feature level), and in the Arm docs:</p>\n<blockquote>\n<p>This field must have the same value as the AdvSIMD field.<br>\nThis field must have the same value as the FP field.</p>\n</blockquote>",
        "id": 276679355,
        "sender_full_name": "Jubilee",
        "timestamp": 1648242677
    },
    {
        "content": "<p>Though FP16 doesn't have a way to express support for it that doesn't also include FP and ASIMD, so we can keep \"+fp16 is +neon\".</p>",
        "id": 276679442,
        "sender_full_name": "Jubilee",
        "timestamp": 1648242726
    },
    {
        "content": "<p>Looking at the way the registers ought to work...<br>\nJSCVT mandates Neon also (and is mandated by Neon + v8.3).<br>\nFCMA mandates Neon (and is mandated by Neon + v8.3).<br>\nSo jsconv and fcma actually should imply each other, if we're permitted to reason by versioning.<br>\nSHA3 mandates SHA2 mandates SHA1.</p>",
        "id": 276681287,
        "sender_full_name": "Jubilee",
        "timestamp": 1648244026
    },
    {
        "content": "<p>Looks like FHM does in fact require FP16:</p>\n<blockquote>\n<p>If SVE or FEAT_FHM is implemented, FEAT_FP16 is implemented. From Armv8.4, if<br>\nFEAT_FHM is not implemented, FEAT_FP16 is not implemented.</p>\n</blockquote>",
        "id": 276742496,
        "sender_full_name": "Jubilee",
        "timestamp": 1648324089
    },
    {
        "content": "<p>Yeah, after reviewing the std_detect code more closely, I believe that while we shouldn't consider it a core functionality of Rust, for the sake of completeness, if the OS exposes an answer to \"is FP on or not?\", even if the answer <strong>has</strong> to be the same as the answer to Neon (and FP16, if that's on), then it's fine to ask.</p>\n<p>Looks like SVE should imply FEAT_FCMA as well, not just FEAT_FP16.</p>",
        "id": 276743063,
        "sender_full_name": "Jubilee",
        "timestamp": 1648324839
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/242906-t-compiler.2Farm/topic/Feature.20implications/near/276679442\">said</a>:</p>\n<blockquote>\n<p>Though FP16 doesn't have a way to express support for it that doesn't also include FP and ASIMD, so we can keep \"+fp16 is +neon\".</p>\n</blockquote>\n<p>Right, well in the hardware it's a different value for the FP and NEON ID registers, so they're bound in exactly the same way as base FP and NEON. So architecturally, neon16 -&gt; neon, fp16 -&gt; fp and neon == fp (where \"-&gt;\" means \"implies). From our perspective, with neon and fp merged, fp16 -&gt; neon.</p>",
        "id": 276882992,
        "sender_full_name": "Jacob Bramley",
        "timestamp": 1648478456
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/242906-t-compiler.2Farm/topic/Feature.20implications/near/276681287\">said</a>:</p>\n<blockquote>\n<p>Looking at the way the registers ought to work...<br>\nJSCVT mandates Neon also (and is mandated by Neon + v8.3).<br>\nFCMA mandates Neon (and is mandated by Neon + v8.3).<br>\nSo jsconv and fcma actually should imply each other, if we're permitted to reason by versioning.<br>\nSHA3 mandates SHA2 mandates SHA1.</p>\n</blockquote>\n<p>That's more tricky... From the <a href=\"https://developer.arm.com/documentation/ddi0487/latest\">Arm ARM</a>:</p>\n<blockquote>\n<p>An Armv8.x compliant implementation can include any arbitrary subset of the architectural features of Armv8.(x+1), subject only to those constraints that require that certain features be implemented together.</p>\n</blockquote>\n<p>In addition, there exist features that can be implemented earlier than one hop. Making inferences through Armv8.x releases is technically possible, but probably quite unwise! Not to mention that the OS may hide FCMA, but expose JSCVT (for some reason).</p>\n<p>On the other hand, SHA3 -&gt; SHA2 -&gt; SHA1 is probably reasonable, and therein lies the problem: it's tempting, and easy to make inferences in simple cases, but very difficult to do it in general.</p>",
        "id": 276884431,
        "sender_full_name": "Jacob Bramley",
        "timestamp": 1648479006
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/242906-t-compiler.2Farm/topic/Feature.20implications/near/276743063\">said</a>:</p>\n<blockquote>\n<p>Looks like SVE should imply FEAT_FCMA as well, not just FEAT_FP16.</p>\n</blockquote>\n<p><code>FEAT_FCMA</code> is mandatory in Armv8.3, and adds some NEON (not scalable-vector) instructions.<br>\n<code>FEAT_SVE</code> is optional in Armv8.2, and includes instructions like <code>fcadd</code> for SVE use, but these aren't dependent on <code>FEAT_FCMA</code>.<br>\nIf I understand it correctly, an Armv8.2 implementation can have <code>FEAT_SVE</code>, NEON, but no <code>FEAT_FCMA</code>, so the <code>fcadd</code> mnemonic is only available under SVE. I don't think there's any inference relationship between the two features.</p>",
        "id": 276885718,
        "sender_full_name": "Jacob Bramley",
        "timestamp": 1648479496
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"399135\">Jacob Bramley</span> <a href=\"#narrow/stream/242906-t-compiler.2Farm/topic/Feature.20implications/near/276884431\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/242906-t-compiler.2Farm/topic/Feature.20implications/near/276681287\">said</a>:</p>\n<blockquote>\n<p>So jsconv and fcma actually should imply each other, if we're permitted to reason by versioning.</p>\n</blockquote>\n<p>That's more tricky... From the <a href=\"https://developer.arm.com/documentation/ddi0487/latest\">Arm ARM</a>:</p>\n<blockquote>\n<p>An Armv8.x compliant implementation can include any arbitrary subset of the architectural features of Armv8.(x+1), subject only to those constraints that require that certain features be implemented together.<br>\n</p>\n</blockquote>\n</blockquote>\n<p>aha.</p>",
        "id": 276926029,
        "sender_full_name": "Jubilee",
        "timestamp": 1648498693
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"399135\">Jacob Bramley</span> <a href=\"#narrow/stream/242906-t-compiler.2Farm/topic/Feature.20implications/near/276885718\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/242906-t-compiler.2Farm/topic/Feature.20implications/near/276743063\">said</a>:</p>\n<blockquote>\n<p>Looks like SVE should imply FEAT_FCMA as well, not just FEAT_FP16.</p>\n</blockquote>\n<p><code>FEAT_FCMA</code> is mandatory in Armv8.3, and adds some NEON (not scalable-vector) instructions.<br>\n<code>FEAT_SVE</code> is optional in Armv8.2, and includes instructions like <code>fcadd</code> for SVE use, but these aren't dependent on <code>FEAT_FCMA</code>.<br>\nIf I understand it correctly, an Armv8.2 implementation can have <code>FEAT_SVE</code>, NEON, but no <code>FEAT_FCMA</code>, so the <code>fcadd</code> mnemonic is only available under SVE. I don't think there's any inference relationship between the two features.</p>\n</blockquote>\n<p><code>FEAT_FCMA</code> is mandated by SVE, actually.</p>",
        "id": 276926165,
        "sender_full_name": "Jubilee",
        "timestamp": 1648498770
    },
    {
        "content": "<p>\"<code>FEAT_SVE</code> requires implementation of <code>FEAT_FP16</code> and <code>FEAT_FCMA</code>.\"</p>",
        "id": 276926353,
        "sender_full_name": "Jubilee",
        "timestamp": 1648498866
    },
    {
        "content": "<blockquote>\n<p>On the other hand, SHA3 -&gt; SHA2 -&gt; SHA1 is probably reasonable, and therein lies the problem: it's tempting, and easy to make inferences in simple cases, but very difficult to do it in general.</p>\n</blockquote>\n<p>Yeah the SHA flow is actually specified as part of the way those features are expressed in the registers and manual.</p>",
        "id": 276926471,
        "sender_full_name": "Jubilee",
        "timestamp": 1648498934
    },
    {
        "content": "<p>So alright, no ability to reason via JSCVT &lt;-&gt; FCMA.</p>",
        "id": 276926702,
        "sender_full_name": "Jubilee",
        "timestamp": 1648499074
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/242906-t-compiler.2Farm/topic/Feature.20implications/near/276926353\">said</a>:</p>\n<blockquote>\n<p>\"<code>FEAT_SVE</code> requires implementation of <code>FEAT_FP16</code> and <code>FEAT_FCMA</code>.\"</p>\n</blockquote>\n<p>Ooh, there might be an inconsistency there. This statement (under ID_AA64ISAR1_EL1) seems incorrect: \"In Armv8.0, Armv8.1, and Armv8.2, the only permitted value is 0b0000.\"<br>\nI can't find the text you quoted but I can find words to the same effect in the <a href=\"https://developer.arm.com/documentation/ddi0584/ba/?lang=en\">SVE supplement</a>.</p>",
        "id": 276969359,
        "sender_full_name": "Jacob Bramley",
        "timestamp": 1648540348
    },
    {
        "content": "<p>I think the point is that there's a set of obvious inferences we can make, and a set of obviously-questionable ones, but we probably need at least a heuristic for deciding whether or not to accept an inference that lies in the gap.<br>\n(This is for <code>target_features</code>; the runtime detection shouldn't do any inference by default, though it might be a useful API helper.)</p>",
        "id": 277388560,
        "sender_full_name": "Jacob Bramley",
        "timestamp": 1648804032
    },
    {
        "content": "<p>Yeah, runtime can just look at the right value.</p>",
        "id": 277443115,
        "sender_full_name": "Jubilee",
        "timestamp": 1648830138
    },
    {
        "content": "<p>Especially since at least some platforms, as I understand it, just let you read the right registers, like you were privileged (catching your thread on the illegal privileged instruction use and then doing the actual read in privileged space, ofc).</p>",
        "id": 277443254,
        "sender_full_name": "Jubilee",
        "timestamp": 1648830196
    }
]