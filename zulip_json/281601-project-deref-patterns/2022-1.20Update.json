[
    {
        "content": "<p>Hey <span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> have you had a chance to look at this?  i'd be happy to help poke around at the code if you have any questions!</p>",
        "id": 269298973,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1643134367
    },
    {
        "content": "<p>If you don't have time for it, that's totally okay, too.</p>",
        "id": 269299042,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1643134403
    },
    {
        "content": "<p>Oh, I completely forgot. I'll get that opened up right now.</p>",
        "id": 269300421,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643134944
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> Sweet! I'm so excited for this :)</p>",
        "id": 269306656,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1643137363
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> checking in again to see if there's anything I can help with!</p>",
        "id": 271332529,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1644434313
    },
    {
        "content": "<p>Sorry. Ended up getting busy with lccc's frontend <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span>. I keep forgetting.</p>",
        "id": 271339817,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644437172
    },
    {
        "content": "<p>No worries! I did some poking around myself. and it looks like this is the relevant bit of code that exists today: <a href=\"https://github.com/rust-lang/rust/blob/master/compiler/rustc_typeck/src/check/pat.rs#L340\">https://github.com/rust-lang/rust/blob/master/compiler/rustc_typeck/src/check/pat.rs#L340</a></p>",
        "id": 271363236,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1644449247
    },
    {
        "content": "<p>It's currently set to strip specifically references, but we also want it to be able to strip types which implement <code>Deref</code>/<code>DerefMut</code>/<code>Box</code> (since <code>Box</code> is fancy/<code>DerefMove</code>)</p>",
        "id": 271363359,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1644449332
    },
    {
        "content": "<p>For dereferencing, there's some handy code in <code>autoderef.rs:overloaded_deref_ty</code> that I wonder if we could re-use.</p>",
        "id": 271363453,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1644449395
    },
    {
        "content": "<p>One thing that isn't totally clear to me is what the easiest way to calculate the resulting binding mode is. For example, if the resulting patterns bind a <code>mut ref</code> rather than a <code>ref</code>, we need to <code>.deref()</code> rather than <code>.deref_mut()</code>. However, this would both make the code more complex and mean that the actual code that runs at runtime would depend (<code>deref</code> vs <code>deref_mut</code>) on whether there was a <code>ref</code> vs a <code>mut ref</code> underneath, which doesn't feel great to me. Maybe I should get over it, but it feels clumsy.</p>\n<p>An alternative, for now, could be to require that there is already an existing  non-by-value binding mode, then we can just use <code>Deref</code> if the binding mode is <code>BindByReference(hir::Mutability::Not)</code>, and <code>DerefMut</code> if the binding mode is <code>BindByReference(hir::Mutability::Mut)</code>. One side-effect of this would be that types which only implement <code>Deref</code> and not <code>DerefMut</code> wouldn't be able to be matched under a mutable binding mode, which is pretty surprising. Another option would be to fall back to <code>Deref</code> and shift the binding mode to <code>BindByReference(hir::Mutability::Not)</code>, but this would mean that adding a <code>DerefMut</code> impl to a type could break code by changing it to shift to a different binding mode, making <code>DerefMut</code> a kind of \"fundamental\" trait.</p>\n<p>TBH none of these options feel super great to me :)</p>",
        "id": 271364381,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1644449947
    },
    {
        "content": "<p>There's a sort of sense to requiring the binding mode switch, though, which is that if you want to bind by-reference, you start with a reference, and if you want to bind by-mut, you start with a mutable reference. It isn't perfect by any means since you can't easily have different subpatterns with different binding modes, but that's already an issue with the existing binding modes setup.</p>",
        "id": 271364650,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1644450135
    },
    {
        "content": "<p>It seems like for many of the initial use-cases, a Deref-only support may suffice -- e.g., matching on String fields doesn't really benefit at all from DerefMut. Similarly a lot of the matches on Box I've seen don't actually want to mutate.</p>",
        "id": 271364805,
        "sender_full_name": "simulacrum",
        "timestamp": 1644450251
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> <code>Box</code> is sort of an interesting special-case because we know that it implements <code>Deref + DerefMut + DerefMove</code> and that it's impls of those are \"pure\", so we don't really care about people doing weird side-effect-y things in the impls, and thus don't have to be concerned with about deciding which impl to call.</p>",
        "id": 271365416,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1644450624
    },
    {
        "content": "<p>But yeah, I think what I'm suggesting is initially you'd just have to write something like <code>match &amp;my_thing_in_box { ThingInBox { ... } }</code> rather than being able to do <code>match my_thing_in_box { ThingInBox { ... } }</code> and have the compiler \"figure out\" that you wanted a move vs. ref vs. ref mut</p>",
        "id": 271365518,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1644450708
    },
    {
        "content": "<p>Also somewhat annoying is that the existing <code>AdjustMode</code> calculation no longer works, as it would naively tell us to Peel off all ADTs that implement Deref, when you could easily have a pattern that matched one of them.</p>",
        "id": 271370655,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1644453519
    },
    {
        "content": "<p>Or, for example, how the existing code doesn't peel off any references when matching against a reference-typed literal pattern, such as a string or byte-slice literals. We <em>definitely</em> need to do stripping of Derefs in that case, as that's exactly what's needed to make <code>match &amp;my_string { \"some_string\" =&gt; { ... }}</code> work (aside: that's a case where it's particularly annoying that you need the initial <code>&amp;</code>...)</p>",
        "id": 271372600,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1644454954
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"127859\">Taylor Cramer</span> <a href=\"#narrow/stream/281601-project-deref-patterns/topic/2022-1.20Update/near/271365416\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <code>Box</code> is sort of an interesting special-case because we know that it implements <code>Deref + DerefMut + DerefMove</code> and that it's impls of those are \"pure\", so we don't really care about people doing weird side-effect-y things in the impls, and thus don't have to be concerned with about deciding which impl to call.</p>\n</blockquote>\n<p>Note that all of the applicable types in the MVP will be. An explicit idea was that the implementation could be clever about which Deref functions it's calling, when, and how many times. It's currently limited to a subset of standard library types.</p>",
        "id": 271383100,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644465068
    },
    {
        "content": "<blockquote>\n<p>It's currently limited to a subset of standard library types</p>\n</blockquote>\n<p>TBH I had completely forgotten this was scoped that way</p>",
        "id": 271480973,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1644520883
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> is there a doc on this somewhere, or is this just collected from past conversations? I looked at <a href=\"https://github.com/rust-lang/project-deref-patterns\">the project group repo</a> but couldn't find details. <code>Box</code> is straightforward, but I think the issues I'm talking about all exist for Vec, String, Rc, and Arc, since none of them currently provide a by-move deref operator, but at least <code>Vec</code> and <code>String</code> could, theoretically.</p>",
        "id": 271481452,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1644521088
    },
    {
        "content": "<p>and <code>Rc</code> and <code>Arc</code> you could imagine having by-move semantics which would work if their contents are copy types</p>",
        "id": 271481516,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1644521114
    },
    {
        "content": "<p>that is <code>match Rc::new(MyStruct(5)) { MyStruct(x) =&gt; { ... } }</code> what is the type of <code>x</code>?</p>",
        "id": 271481593,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1644521150
    },
    {
        "content": "<p>I can see arguments for it either being <code>i32</code> or <code>&amp;i32</code> (based on whether you think <code>Rc</code> should behave similar to <code>Box</code> or whether it should behave similar to <code>&amp;</code>)</p>",
        "id": 271481697,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1644521186
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"127859\">Taylor Cramer</span> <a href=\"#narrow/stream/281601-project-deref-patterns/topic/2022-1.20Update/near/271481452\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> is there a doc on this somewhere, or is this just collected from past conversations? I looked at <a href=\"https://github.com/rust-lang/project-deref-patterns\">the project group repo</a> but couldn't find details. <code>Box</code> is straightforward, but I think the issues I'm talking about all exist for Vec, String, Rc, and Arc, since none of them currently provide a by-move deref operator, but at least <code>Vec</code> and <code>String</code> could, theoretically.</p>\n</blockquote>\n<p>It's kinda all over the place. Really the best source is the lang-team conversations (88 and 77 IIRC), and the hackmd linked in 77.</p>",
        "id": 271481868,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644521266
    },
    {
        "content": "<p>For <code>Vec</code>, I'd imagine the behavior we'd <em>want</em>, but would not be trivial to implement, would be for it to behave like <code>Box&lt;[T]&gt;</code>, which would mean that you could do <code>match vec![\"foo\".to_string()] { [x] =&gt; { ... } _ =&gt; { ... }</code> and have <code>x</code> be a <code>String</code>, not an <code>&amp;String</code>.</p>",
        "id": 271481982,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1644521301
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> Got it. I remember having those discussions, but didn't remember what we'd concluded :)</p>",
        "id": 271482023,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1644521321
    },
    {
        "content": "<p>I'd assume that it would act like normal match ergonomics - doesn't add a reference to the binding by default.</p>",
        "id": 271482171,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644521384
    },
    {
        "content": "<p>(But you can't move out of it unless it's <code>Copy</code> or possibly <code>Box</code>)</p>",
        "id": 271482215,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644521401
    },
    {
        "content": "<p>But <code>&amp;</code> does add a reference to the binding by default in normal match ergonomics!</p>",
        "id": 271482349,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1644521441
    },
    {
        "content": "<p>Oh, does it?</p>",
        "id": 271482373,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644521452
    },
    {
        "content": "<p>For some reason I thought it didn't.</p>",
        "id": 271482404,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644521468
    },
    {
        "content": "<p>sure, <code>match &amp;MyStruct(5) { MyStruct(x) =&gt; { ... } }</code> &lt;- <code>x</code> here has type <code>&amp;i32</code>, not <code>i32</code></p>",
        "id": 271482429,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1644521487
    },
    {
        "content": "<p>Ah yeah, then I'd expect the same thing here.</p>",
        "id": 271482478,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644521514
    },
    {
        "content": "<p>The same thing where? For <code>Rc</code>? certainly not for <code>Box</code></p>",
        "id": 271482555,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1644521529
    },
    {
        "content": "<p>Hmm...</p>",
        "id": 271482603,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644521553
    },
    {
        "content": "<p>That is, you want <code>match Box::new(MyStruct(5)) { MyStruct(x) =&gt; { ... } }</code> &lt;- <code>x</code> here should most definitely be <code>i32</code>, not <code>&amp;i32</code></p>",
        "id": 271482637,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1644521571
    },
    {
        "content": "<p>because we're aiming to make explicit <code>box</code> patterns obsolete.</p>",
        "id": 271482678,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1644521588
    },
    {
        "content": "<p>Oh, I think this actually got talked about.</p>",
        "id": 271482729,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644521616
    },
    {
        "content": "<p>I think we want <code>Vec</code> and <code>String</code> to act the same way since they own their contents, but I don't know what I'd expect for <code>Rc</code> and <code>Arc</code></p>",
        "id": 271482761,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1644521638
    },
    {
        "content": "<p>It should be ill-formed to deref through a value, until DerefMove is more of a thing.</p>",
        "id": 271482827,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644521659
    },
    {
        "content": "<p>(Except maybe Box)</p>",
        "id": 271482852,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644521671
    },
    {
        "content": "<p>And I'd like to avoid making stdlib types even <em>more</em> magic.</p>",
        "id": 271482931,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644521722
    },
    {
        "content": "<p>Yeah, so that was my proposal above: that for now, we error if dereferencing through a non-<code>Box/&amp;/&amp;mut</code> if we don't already have a by-reference binding mode set.</p>",
        "id": 271482933,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1644521723
    },
    {
        "content": "<p>So then you'd need to do (at least for now) <code>match &amp;some_string { \"...\" =&gt; ... }</code> rather than <code>match some_string { \"....\" =&gt; ... }</code></p>",
        "id": 271483003,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1644521756
    },
    {
        "content": "<p>If it's a <code>&amp;String</code> or <code>&amp;Rc</code>, it seems clear that you can just make it <code>&amp;str</code></p>",
        "id": 271483053,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644521765
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"127859\">Taylor Cramer</span> <a href=\"#narrow/stream/281601-project-deref-patterns/topic/2022-1.20Update/near/271483003\">said</a>:</p>\n<blockquote>\n<p>So then you'd need to do (at least for now) <code>match &amp;some_string { \"...\" =&gt; ... }</code> rather than <code>match some_string { \"....\" =&gt; ... }</code></p>\n</blockquote>\n<p>Yeah. And then save <code>match some_string</code> for the future.</p>",
        "id": 271483081,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644521783
    },
    {
        "content": "<p>Agreed, <code>&amp;String</code>/<code>&amp;Rc</code> are pretty clear, but <code>String</code> and <code>Rc</code> are not</p>",
        "id": 271483097,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1644521792
    },
    {
        "content": "<p><code>String</code> has its own weirdness aside from that because the literal form is an <code>&amp;str</code>, not a <code>str</code>, so naiively deref-ing until you get a matching type won't work.</p>",
        "id": 271483362,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1644521910
    },
    {
        "content": "<p>I imagine that's just going to require some special-casing.</p>",
        "id": 271483389,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1644521927
    },
    {
        "content": "<p>Couldn't that just be done by making string-literal patterns generally <code>str</code> and letting match ergonomics pick up the existing cases?</p>",
        "id": 271483463,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644521975
    },
    {
        "content": "<p>Hm, I don't think so, because then things like <code>match \"...\" { x @ \" ...\" =&gt; { ...</code> would result in <code>x</code> having the type <code>str</code></p>",
        "id": 271483634,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1644522055
    },
    {
        "content": "<p>well, actually, I guess it wouldn't, because <code>x</code>'s type would still be determined by the scrutinee there, not by the pattern</p>",
        "id": 271483853,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1644522149
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> thanks for the discussion! This is interesting-- I'm excited to see what we can do here :)</p>",
        "id": 271484123,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1644522299
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"127859\">Taylor Cramer</span> <a href=\"#narrow/stream/281601-project-deref-patterns/topic/2022-1.20Update/near/271482933\">said</a>:</p>\n<blockquote>\n<p>Yeah, so that was my proposal above: that for now, we error if dereferencing through a non-<code>Box/&amp;/&amp;mut</code> if we don't already have a by-reference binding mode set.</p>\n</blockquote>\n<p>What does \"already have a by-reference binding mode set\" mean though? I would expect <code>match Box::new(MyStruct(5)) { MyStruct(ref x) =&gt; ... }</code> to work even though the binding mode is set \"later\"</p>",
        "id": 271508353,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1644534603
    },
    {
        "content": "<p>I think that <em>requiring</em> match ergonomics style matching is a bad idea because it is more limited in some areas</p>",
        "id": 271508380,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1644534631
    },
    {
        "content": "<p>Hi all,</p>\n<p>I would love to get involved and see how I could help. I think this feature would be an amazing addition to rust.</p>\n<p>Would it be possible to have a kind of \"path\" based pure de-referencing system, so it wouldn't involve arbitrary code execution?</p>\n<p>Eg</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nb\">Box</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"n\">pointer</span>: <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">deref</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"c1\">// OR</span>\n<span class=\"k\">struct</span> <span class=\"nb\">Box</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">pointer</span>: <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">pattern</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"c1\">// OR (this involves no new keywords) &amp; fully backwards compatible</span>\n<span class=\"k\">struct</span> <span class=\"nb\">Box</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">pointer</span>: <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"c1\">// and then...</span>\n\n<span class=\"k\">enum</span> <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">A</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">B</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">item</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Box</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">Foo</span>::<span class=\"n\">A</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">a_box</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">Foo</span>::<span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.,</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">Foo</span>::<span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Can anyone foresee any issues with this kind of syntax? I'd love to see if something like this would be possible. It should remove the arbitrary code execution issue</p>",
        "id": 271793566,
        "sender_full_name": "Albert Marashi",
        "timestamp": 1644825603
    },
    {
        "content": "<p>It might have the added benefit of making match syntax much more ergonomic and simpler for new rust developers, avoiding additional sigils inside of match statements</p>",
        "id": 271793870,
        "sender_full_name": "Albert Marashi",
        "timestamp": 1644825864
    },
    {
        "content": "<p>If it's viable, it would solve the following issues</p>\n<ul>\n<li>no need for new keyword</li>\n<li>fully backwards compatible </li>\n<li>it's sound &amp; can be checked statically for exhaustiveness</li>\n<li>it would support safely defining user-defined match extensions</li>\n<li>no additional sigil required</li>\n<li>no need for \"deref\" keyword</li>\n<li><code>for match</code> syntax could probably be nested (eg: <code>Pin&lt;Box&lt;str&gt;&gt;</code>)</li>\n</ul>",
        "id": 271797053,
        "sender_full_name": "Albert Marashi",
        "timestamp": 1644828130
    },
    {
        "content": "<p>How would you handle <code>Vec&lt;T&gt;</code> which has separate pointer and length fields?</p>",
        "id": 271798164,
        "sender_full_name": "bjorn3",
        "timestamp": 1644828820
    },
    {
        "content": "<p>Good point, possibly some syntax like <code>as [..len]</code> eg:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">buf</span>: <span class=\"nc\">RawVec</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"o\">..</span><span class=\"n\">len</span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">len</span>: <span class=\"kt\">usize</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">struct</span> <span class=\"nc\">RawVec</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">ptr</span>: <span class=\"nc\">Unique</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">cap</span>: <span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p><span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span></p>",
        "id": 271798973,
        "sender_full_name": "Albert Marashi",
        "timestamp": 1644829254
    },
    {
        "content": "<p>Since we probably want deref patterns to probably avoid execution of arbitrary user code, I think this solution would probably solve many of those kinds of issues. Things such as collections anything that references a <code>*mut</code> or <code>*const</code>  would probably need to be <code>unsafe</code> and would \"panic\" or be undefined behavior if there was a null pointer, or over-defining the range of a collection</p>",
        "id": 271800156,
        "sender_full_name": "Albert Marashi",
        "timestamp": 1644829914
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nb\">String</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">vec</span>: <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">str</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"kt\">str</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>it could potentially be possible to define more than one target of dereferences  for strings too using an \"or\" syntax</p>",
        "id": 271801181,
        "sender_full_name": "Albert Marashi",
        "timestamp": 1644830439
    },
    {
        "content": "<p>I think it helps, but adding new syntax has a high cost in complexity and I fear pattern matching is not common enough or dangerous enough to justify it. The null-solution here is just that we either limit deref patterns to well-known types, or we trust the user not to do anything stupid in their Deref impls (note that they can't do anything unsafe, only unexpected), neither of which seems like too bad a situation</p>",
        "id": 271801351,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644830525
    },
    {
        "content": "<p>I'm not sure how they implemented the <code>box</code> pattern, but I think it would not be significantly more complex than so.</p>\n<p>I see where you're coming from, but based on writing language parsers and executors, I feel like this might not be a significant change and seems like it could solve most of the deref patterns needed for most container &amp; collection types (eg: <code>Box</code>, <code>String</code>, <code>Arc</code>, <code>Vec</code>, <code>Pin</code>)</p>\n<p>It would be worth attempting a simpler version of this that supports types such as <code>Box</code>, <code>Pin</code>, <code>Arc</code> eg:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nb\">Box</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">ptr</span>: <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 271802211,
        "sender_full_name": "Albert Marashi",
        "timestamp": 1644831070
    },
    {
        "content": "<p>Someone suggested something like \"Place\"s <a href=\"https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/struct.Place.html\">https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/struct.Place.html</a> could be used from the MIR</p>",
        "id": 271802277,
        "sender_full_name": "Albert Marashi",
        "timestamp": 1644831107
    },
    {
        "content": "<p>Patterns are supposed to act as units of code with no expressions, I'd argue it would become significantly more complex if we were to start executing arbitrary expressions from <code>Deref</code> <code>impl</code>s . We have things like match guards for these more complex cases.</p>\n<p>For the above proposal, I believe it would solve a large percentage of the needs that most people that have wanted from deref patterns. On top of this, it seems like it would safely support user-defined <code>for match</code> syntax</p>",
        "id": 271803715,
        "sender_full_name": "Albert Marashi",
        "timestamp": 1644832061
    },
    {
        "content": "<p>To echo Nick's point, syntax <em>in the struct definition especially</em> is extra-complicated.  Is this worth breaking basically all the proc macros that could be applied to the type?  Probably not.</p>\n<p>Doing this somehow in a trait impl (and/or an attribute, perhaps) seems far more likely.  But really, the specifics of syntax (like <code>for match</code> or <code>in match</code> or whatever) are the least important part of a proposal.</p>",
        "id": 271806135,
        "sender_full_name": "scottmcm",
        "timestamp": 1644833461
    },
    {
        "content": "<p>Ah, I see</p>",
        "id": 271812089,
        "sender_full_name": "Albert Marashi",
        "timestamp": 1644836925
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/281601-project-deref-patterns/topic/2022-1.20Update/near/271806135\">said</a>:</p>\n<blockquote>\n<p>To echo Nick's point, syntax <em>in the struct definition especially</em> is extra-complicated.  Is this worth breaking basically all the proc macros that could be applied to the type?  Probably not.</p>\n<p>Doing this somehow in a trait impl (and/or an attribute, perhaps) seems far more likely.  But really, the specifics of syntax (like <code>for match</code> or <code>in match</code> or whatever) are the least important part of a proposal.</p>\n</blockquote>\n<p>I see doing it for user-defined code as a trait impl as a certainty:  You can have pure dereference without a pointer. Heck a ZST can functionally have a pure deref.<br>\nThe question is what implementing that trait would entail: What promises are you unsafely guaranteeing, on penalty of UB or potential UB.<br>\nThe current answer for the question is that it's being deferred (and only standard library types are considered at this time), though I think it's reasonable to continue having that discussion concurrently to the MVP impl.</p>",
        "id": 271814635,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644838662
    },
    {
        "content": "<p>Another option is having a distinct trait for \"my deref has no side effects\".</p>",
        "id": 271915619,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644889409
    },
    {
        "content": "<p>Rather than assuming no current type has such a deref impl.</p>",
        "id": 271915667,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644889443
    },
    {
        "content": "<p>This would probably be a significant change, but creating a new item type specifically for telling the compiler what should happen in match patterns.</p>\n<p>It's somewhat concerning to allow user-code to execute arbitrary code inside of match patterns. I think of a pattern as a \"stateless\" comparison. But then again, it's up to the developer to safely do this and avoid undefined behavior.</p>\n<p>My idea would be more limited in terms of what's possible with dereferencing, but I think it should be limited tbh, and be able to be statically checked for exhaustiveness</p>",
        "id": 271929169,
        "sender_full_name": "Albert",
        "timestamp": 1644903033
    },
    {
        "content": "<p>It would be a pain to debug UB when you expected the compiler to check for all invariants</p>",
        "id": 271929179,
        "sender_full_name": "Albert",
        "timestamp": 1644903063
    },
    {
        "content": "<p>It could trip new users</p>",
        "id": 271929266,
        "sender_full_name": "Albert",
        "timestamp": 1644903153
    },
    {
        "content": "<p>UB is absolutely not enabled by any of this</p>",
        "id": 271930489,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1644904609
    },
    {
        "content": "<p>and as already mentioned, all derefs supported in the initial implementation are pure</p>",
        "id": 271930502,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1644904640
    },
    {
        "content": "<p>In the future this may either be extended to (1) non-pure deref and live with the side effects or (2) pure deref via a trait, but even with (1) UB is not on the table, it is at worst a panic</p>",
        "id": 271930565,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1644904702
    },
    {
        "content": "<p>IMO, deref should always be 'morally' pure if not technically pure ('morally' in the same way that clone should not mutate the thing being cloned, but updating a reference count is ok), and anyone who does otherwise in their deref impl is begging for trouble. Thus it is not worth a new trait, but is worth more explicit docs</p>",
        "id": 271957098,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644922779
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256841\">@Nick Cameron</span> It \"should\", but it's not an unsafe trait, so I don't think we can count on that to prevent incorrect or unexpected behavior.</p>",
        "id": 271992571,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644939969
    },
    {
        "content": "<p>(The trait I'm suggesting wouldn't have a separate method, it would just indicate that your existing <code>Deref</code> impl had that property.)</p>",
        "id": 271992723,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644940045
    },
    {
        "content": "<p>The general idea for user-defined extensions was a <code>DerefPure</code> trait, which, imo <em>should</em> be an unsafe marker-only trait, and it should be on penalty of UB to violate.<br>\nOtherwise, the implementation would have to insert <code>_ =&gt; unreachable!()</code> arms when deref patterns are used.</p>",
        "id": 271992763,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644940067
    },
    {
        "content": "<p>Exactly.</p>",
        "id": 271992843,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644940088
    },
    {
        "content": "<p>(And if it can't look into the Deref impl, those arms will basically have to stick arround)</p>",
        "id": 271992849,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644940092
    },
    {
        "content": "<p>I don't see why it should be unsafe? There is no way to cause memory safety errors or UB, only to cause unexpected behaviour (i.e., logic errors). AIUI, we only use unsafe for memory safety, soundness etc, not to prevent foot guns</p>",
        "id": 271993152,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644940224
    },
    {
        "content": "<p>It's being used to assert exhaustiveness.</p>",
        "id": 271993278,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644940266
    },
    {
        "content": "<p>What exactly happens when you match a pattern, that's considered exhaustive statically, but doesn't end up being at compile time, and you miss all the arms</p>",
        "id": 271993368,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644940302
    },
    {
        "content": "<blockquote>\n<p>Otherwise, the implementation would have to insert _ =&gt; unreachable!() arms when deref patterns are used.</p>\n</blockquote>\n<p>The compiler could just insert this implicitly if it sees a custom deref. I think that is morally equivalent to integer bounds checks</p>",
        "id": 271993497,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644940334
    },
    {
        "content": "<p>That changes how it could be implemented.</p>",
        "id": 271993661,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644940396
    },
    {
        "content": "<p>How?</p>",
        "id": 271993698,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644940412
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">enum</span> <span class=\"nc\">Foo</span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">A</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">B</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">C</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"nc\">Foo</span><span class=\"p\">){</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">         </span><span class=\"n\">Foo</span>::<span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"cm\">/*a*/</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">         </span><span class=\"n\">Foo</span>::<span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"cm\">/*b*/</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">         </span><span class=\"n\">Foo</span>::<span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"cm\">/*c*/</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Can be implemented as a jump table.<br>\nIdeally, deref patterns would allow the same.</p>",
        "id": 271993915,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644940485
    },
    {
        "content": "<p>(IE, if <code>x</code> was &amp;Rc&lt;Foo&gt;` instead)</p>",
        "id": 271994027,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644940530
    },
    {
        "content": "<p>Deref may also be expensive to call, so the ability to remove Deref calls is something that I think is paramount for optimization.</p>",
        "id": 271994098,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644940562
    },
    {
        "content": "<p>Deref really shouldn't be expensive to call, that seems like another mistake by the implementer (like impurity). IMO, we should rely on deref being inlined and LLVM optimising away redundant calls, relying on a pure annotation in the form of an unsafe trait feels like a situation-specific hack around not having a general purity effect</p>",
        "id": 271994583,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644940718
    },
    {
        "content": "<p>We can't always do that, though. <br>\nMany cases of <code>Deref</code> use will originate from outside the crate. If that's not generic, then no inlining without <code>#[inline]</code>.</p>",
        "id": 271994922,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644940818
    },
    {
        "content": "<p>Not being unsafe means the compiler can't collapse it into a single Deref, followed by a jump table, because it could have different behaviour from derefing in each arm.</p>",
        "id": 271995062,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644940865
    },
    {
        "content": "<p>LTO could help, I think?</p>",
        "id": 271995148,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644940903
    },
    {
        "content": "<p>LTO always can help. That doesn't mean we should rely on it here.</p>",
        "id": 271995194,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644940921
    },
    {
        "content": "<p>IMO I think it is a mistake to pursue this last drop of performance at the expense of increased complexity and potential unsafety. With no extra traits and no unsafety (and the accompanying potential for errors) you get an implementation which is pretty close to optimal in all cases and optimal in many cases (esp with LTO).</p>",
        "id": 271995590,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644941051
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/281601-project-deref-patterns/topic/2022-1.20Update/near/271993497\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>Otherwise, the implementation would have to insert _ =&gt; unreachable!() arms when deref patterns are used.</p>\n</blockquote>\n<p>The compiler could just insert this implicitly if it sees a custom deref. I think that is morally equivalent to integer bounds checks</p>\n</blockquote>\n<p>But it shouldn't have to, given that most Deref impls are well-behaved.</p>",
        "id": 271995616,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644941063
    },
    {
        "content": "<p>It has to do this pessimistically, but 95% of the time, it's redundant, but just can't see it.</p>",
        "id": 271995721,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644941102
    },
    {
        "content": "<p>I don't think this is just an issue of performance. Inserting <code>_ =&gt; unreachable!()</code> means inserting a panic, which means the panic machinery.</p>",
        "id": 271995756,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644941113
    },
    {
        "content": "<p>A program might otherwise not <em>need</em> the panic machinery, or the format machinery.</p>",
        "id": 271995777,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644941126
    },
    {
        "content": "<p>That to.</p>",
        "id": 271995793,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644941136
    },
    {
        "content": "<p>(e.g. WebAssembly trying to optimize for size)</p>",
        "id": 271995818,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644941146
    },
    {
        "content": "<p>It also means that unsafe code may now has to deal with the possibility of a match panicking.</p>",
        "id": 271995988,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644941193
    },
    {
        "content": "<p>A program which does no arithmetic and no array indexing but absolutely must use deref patterns seems like a pretty niche use case :-)</p>",
        "id": 271996007,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644941201
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/281601-project-deref-patterns/topic/2022-1.20Update/near/271996007\">said</a>:</p>\n<blockquote>\n<p>A program which does no arithmetic and no array indexing but absolutely must use deref patterns seems like a pretty niche use case :-)</p>\n</blockquote>\n<p><code>-C overflow-checks=n</code> for the first.</p>",
        "id": 271996047,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644941222
    },
    {
        "content": "<p>Also, deref patterns can be used to avoid the bounds checks for indexing, especially of vectors.</p>",
        "id": 271996252,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644941299
    },
    {
        "content": "<p>Also, the compiler is pretty good at eliminating bounds checks, and people who use iterators don't get bounds checks.</p>",
        "id": 271997239,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644941651
    },
    {
        "content": "<p>So, to step back, let me go over why I don't like the DerefPure trait: it's one more trait for people to implement, but moreover what happens if it is not implemented? Either we silently have a sub-optimal path for deref patterns and there is no notification that the impl is missing, or there is an error and so users don't get to use deref patterns until their libraries upgrade. It feels bad to assert a property (one that affects soundness in fact) non-locally - it seems too easy to change the deref impl and forget to delete the DerefPure impl. Also, it doesn't scale - we'd need a DerefMutPure and perhaps someday a DerefMovePure traits too.</p>",
        "id": 271997427,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644941724
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256841\">@Nick Cameron</span> I think one marker trait could opt in for all deref traits.</p>",
        "id": 271997957,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644941928
    },
    {
        "content": "<p>Yeah, <code>DerefPure</code> would imply purity of <code>DerefMut</code> and <code>DerefMove</code> (in the future), as well as consistency.</p>",
        "id": 271998032,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644941965
    },
    {
        "content": "<p>If it's not implemented, then Deref patterns would be unavailable for the type, yes.</p>",
        "id": 271998239,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644942040
    },
    {
        "content": "<p>This implies a generic Deref type that want's to use deref patterns would also need to bound on <code>DerefPure</code>.</p>",
        "id": 271998372,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644942087
    },
    {
        "content": "<p>An alternative is that non-pure Deref types would not be treated as having exhaustive patterns, so the user, not the compiler, would have to insert a wildcard pattern and handle it as they would.</p>",
        "id": 271998864,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644942306
    },
    {
        "content": "<p>So, I would propose that we implement the more ergonomic, safer version first and if while it is unstable we have evidence that it prevents the compiler optimising where it is important to optimise (and not to workaround), then we can add the more performant version. Otherwise, this feels like the language design equivalent of premature optimisation.</p>",
        "id": 271998914,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644942329
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/281601-project-deref-patterns/topic/2022-1.20Update/near/271998864\">said</a>:</p>\n<blockquote>\n<p>An alternative is that non-pure Deref types would not be treated as having exhaustive patterns, so the user, not the compiler, would have to insert a wildcard pattern and handle it as they would.</p>\n</blockquote>\n<p>I prefer this to the trait, but I would still rather it were implicit unless we can show that that causes actual real-life problems</p>",
        "id": 271999042,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644942378
    },
    {
        "content": "<p>I don't want to add implicit panics. TBH, that seems like far more of a footgun then any kind of unsafe trait, that most Deref impls satisfy anyways.</p>",
        "id": 271999133,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644942422
    },
    {
        "content": "<p>Implicit panics are everywhere in Rust already - literally every single function can implicitly panic if it wants to. I'd want to see evidence that adding such implicit panics actually causes problems for users</p>",
        "id": 271999531,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644942581
    },
    {
        "content": "<p>I'd love to come up with some code that this is a problem, though I can't think of anything specific at this time.</p>\n<p>I would note that all other cases of implicit panics from primitive operations, there are opt outs:<br>\n<code>.wrapping_*</code>, <code>.get</code>, <code>.get_unchecked</code>.</p>",
        "id": 272001705,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644943507
    },
    {
        "content": "<p>I've seen write-ups of size optimization for WebAssembly that specifically talk about avoiding the format machinery.</p>",
        "id": 272002841,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644943965
    },
    {
        "content": "<p>(Note that to give credit, I don't think that the implicit <code>_ =&gt; unreachable!()</code> would actually be <code>_ =&gt; unreachable!()</code>, but something like <code>_ =&gt; unreachable_deref_pattern()</code>  which wouldn't involve the format machinery)</p>",
        "id": 272003019,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644944036
    },
    {
        "content": "<p>There would be a workaround here too which is just to do what we do today rather than use deref</p>",
        "id": 272003114,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644944058
    },
    {
        "content": "<p>Patterns</p>",
        "id": 272003201,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644944086
    },
    {
        "content": "<p>Which can be significantly worse, ergonomics wise.</p>",
        "id": 272003238,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644944100
    },
    {
        "content": "<p>I actually have some code that would really love to use deref patterns. Right now it's panic heavy, but in the future, I want to replace all panics with proper diagnostics.</p>",
        "id": 272003309,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644944131
    },
    {
        "content": "<p><a href=\"https://github.com/LightningCreations/lccc/blob/main/xir/src/parser.rs#L22\">https://github.com/LightningCreations/lccc/blob/main/xir/src/parser.rs#L22</a></p>\n<p>I'd love to replace the <code>Token::Ident(id) if id==\"function\"</code> with <code>Token::Ident(\"function\")</code>, likewise for other keywords, which is heavilly used here. And also in the rust parser in the same project.</p>",
        "id": 272003625,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644944251
    },
    {
        "content": "<p>I'd love to see performance comparisons between a deref pattern impl with implicit _ =&gt; panic!() and without that for that kind of application</p>",
        "id": 272005737,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644944989
    },
    {
        "content": "<p>The issue with panics is that it's technically unsound: <a href=\"https://github.com/LightningCreations/lccc/issues/6\">https://github.com/LightningCreations/lccc/issues/6</a></p>",
        "id": 272005875,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644945029
    },
    {
        "content": "<p>(Not that it's stopping me, but I'd like to clean up issue 6 at some point)</p>",
        "id": 272005976,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644945072
    },
    {
        "content": "<p>It's very hard to do that, if I can't reason about where the compiler might be inserting panics.</p>",
        "id": 272006093,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644945119
    },
    {
        "content": "<p>In particular, I don't want \"write panic-free code\" to include \"carefully avoid using deref patterns\".</p>",
        "id": 272011946,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644947418
    },
    {
        "content": "<p>(As one of many many possible reasons: carefully avoiding potential panics inside a locked region, to avoid dealing with lock poisoning.)</p>",
        "id": 272012003,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644947449
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/281601-project-deref-patterns/topic/2022-1.20Update/near/271994098\">said</a>:</p>\n<blockquote>\n<p>Deref may also be expensive to call, so the ability to remove Deref calls is something that I think is paramount for optimization.</p>\n</blockquote>\n<p>I agree with this</p>",
        "id": 272012024,
        "sender_full_name": "Albert",
        "timestamp": 1644947460
    },
    {
        "content": "<p>Also, having the ability to optimize over Deref impls means it may be possible to optimize string comparisons to happen in a multi-way fashion. For instance, if you're comparing against a hundred fixed short strings, it might make sense to read the first 8 bytes of the string out into a register and optimize like a fast \"numeric\" switch.</p>",
        "id": 272012254,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644947557
    },
    {
        "content": "<p>That doesn't work as well if we semantically require that Deref must be called a hundred times.</p>",
        "id": 272012298,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644947574
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"478671\">Albert</span> <a href=\"#narrow/stream/281601-project-deref-patterns/topic/2022-1.20Update/near/271802211\">said</a>:</p>\n<blockquote>\n<p>I'm not sure how they implemented the <code>box</code> pattern, but I think it would not be significantly more complex than so.</p>\n<p>I see where you're coming from, but based on writing language parsers and executors, I feel like this might not be a significant change and seems like it could solve most of the deref patterns needed for most container &amp; collection types (eg: <code>Box</code>, <code>String</code>, <code>Arc</code>, <code>Vec</code>, <code>Pin</code>)</p>\n<p>It would be worth attempting a simpler version of this that supports types such as <code>Box</code>, <code>Pin</code>, <code>Arc</code> eg:</p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">Pin</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">data</span>: <span class=\"nc\">T</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>That's why I thought a solution like this, where everything can be checked statically, no <code>Deref</code> required, and it should be able to support user-defined cases and cover most of the deref patterns people are asking for</p>",
        "id": 272012393,
        "sender_full_name": "Albert",
        "timestamp": 1644947628
    },
    {
        "content": "<p>since these would cover 90% of use-cases. If people need some more complex <code>Deref</code> code, then they can just use match guards / additional matches</p>",
        "id": 272012565,
        "sender_full_name": "Albert",
        "timestamp": 1644947701
    },
    {
        "content": "<p>It should be much more performant, since it would be doing some simple offsets to the bytes in structs, and they could be nested too... eg:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">Data</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">data</span>:  <span class=\"nc\">Inner</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">struct</span> <span class=\"nc\">Inner</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">ptr</span>: <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 272012884,
        "sender_full_name": "Albert",
        "timestamp": 1644947855
    },
    {
        "content": "<p>my pseudo-code for the ops would be something like:</p>\n<ul>\n<li>pattern type is inferred based on first <code>match</code> pattern (variant of <code>T</code>)</li>\n<li>the variable being matched is a <code>Data&lt;T&gt;</code></li>\n<li>the ast contains a map of the possible things that <code>Data&lt;T&gt;</code> can map to, eg: <code>T -&gt; data: Inner&lt;T&gt;</code></li>\n<li>we look for T, get the offset &amp; <code>sizeof</code> the particular field, since <code>Inner&lt;T&gt;</code> is embedded in the struct, we read the <code>ptr</code> which is an <code>unsafe</code> for the deref pattern</li>\n<li>let location = data.address + offset_to_t as T</li>\n</ul>",
        "id": 272015206,
        "sender_full_name": "Albert",
        "timestamp": 1644948786
    },
    {
        "content": "<blockquote>\n<p>In particular, I don't want \"write panic-free code\" to include \"carefully avoid using deref patterns\".</p>\n</blockquote>\n<p>Could you explain why? It seems easier to spot than a panic buried deep down some call chain of functions</p>",
        "id": 272015231,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644948800
    },
    {
        "content": "<p>It's harder to spot through superficial code inspection and/or grep.</p>",
        "id": 272015454,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644948892
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"478671\">Albert</span> <a href=\"#narrow/stream/281601-project-deref-patterns/topic/2022-1.20Update/near/272012024\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/281601-project-deref-patterns/topic/2022-1.20Update/near/271994098\">said</a>:</p>\n<blockquote>\n<p>Deref may also be expensive to call, so the ability to remove Deref calls is something that I think is paramount for optimization.</p>\n</blockquote>\n<p>I agree with this</p>\n</blockquote>\n<p>Do you have examples of expense deref impls? (I am morbidly curious)</p>",
        "id": 272015502,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644948912
    },
    {
        "content": "<p><code>Lazy</code></p>",
        "id": 272015634,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644948978
    },
    {
        "content": "<p>a function itself has overhead, unless it's inlined</p>",
        "id": 272015661,
        "sender_full_name": "Albert",
        "timestamp": 1644948990
    },
    {
        "content": "<p>The inner type produced from a <code>lazy_static!</code></p>",
        "id": 272015670,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644948996
    },
    {
        "content": "<p>I'm not all that fussed, but I really want to be able to use deref patterns with <code>Box&lt;str&gt;</code>, <code>String</code>, and possibly things like <code>Vec</code>s would be amazing. I don't particularly plan on implementing it on my own types, but I can see where it would be useful sometimes</p>",
        "id": 272015918,
        "sender_full_name": "Albert",
        "timestamp": 1644949093
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/281601-project-deref-patterns/topic/2022-1.20Update/near/272015454\">said</a>:</p>\n<blockquote>\n<p>It's harder to spot through superficial code inspection and/or grep.</p>\n</blockquote>\n<p>I don't understand this (though I think I am just generally sceptical of the idea of writing panic-free code). AIUI, you see a function call <code>foo()</code> and you have no idea if it might panic or not, but you see a match and you have a pretty good idea if it might panic if there is a smart pointer in the thing being matched. Of course you might not know the type, but that is probably because it is coming from a function, which might panic</p>",
        "id": 272015989,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644949129
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"478671\">Albert</span> <a href=\"#narrow/stream/281601-project-deref-patterns/topic/2022-1.20Update/near/272015918\">said</a>:</p>\n<blockquote>\n<p>I'm not all that fussed, but I really want to be able to use deref patterns with <code>Box&lt;str&gt;</code>, <code>String</code>, and possibly things like <code>Vec</code>s would be amazing. I don't particularly plan on implementing it on my own types, but I can see where it would be useful sometimes</p>\n</blockquote>\n<p>I have some user-defined types I'd like to implement.</p>",
        "id": 272016043,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644949155
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/281601-project-deref-patterns/topic/2022-1.20Update/near/272016043\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"478671\">Albert</span> <a href=\"#narrow/stream/281601-project-deref-patterns/topic/2022-1.20Update/near/272015918\">said</a>:</p>\n<blockquote>\n<p>I'm not all that fussed, but I really want to be able to use deref patterns with <code>Box&lt;str&gt;</code>, <code>String</code>, and possibly things like <code>Vec</code>s would be amazing. I don't particularly plan on implementing it on my own types, but I can see where it would be useful sometimes</p>\n</blockquote>\n<p>I have some user-defined types I'd like to implement.</p>\n</blockquote>\n<p>How complex would your derefs typically be if they were functions? Is it just returning some pointers or borrows of certain things, or are they doing more complex operations?</p>",
        "id": 272016208,
        "sender_full_name": "Albert",
        "timestamp": 1644949223
    },
    {
        "content": "<p>Out of curiosity</p>",
        "id": 272016218,
        "sender_full_name": "Albert",
        "timestamp": 1644949228
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/281601-project-deref-patterns/topic/2022-1.20Update/near/272015634\">said</a>:</p>\n<blockquote>\n<p><code>Lazy</code></p>\n</blockquote>\n<p>This is a great example!</p>",
        "id": 272016522,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644949366
    },
    {
        "content": "<p>I think it's a good example of a not-pure-but-morally-pure-enough-for-deref-patterns deref too</p>",
        "id": 272016641,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644949429
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"478671\">Albert</span> <a href=\"#narrow/stream/281601-project-deref-patterns/topic/2022-1.20Update/near/272016208\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/281601-project-deref-patterns/topic/2022-1.20Update/near/272016043\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"478671\">Albert</span> <a href=\"#narrow/stream/281601-project-deref-patterns/topic/2022-1.20Update/near/272015918\">said</a>:</p>\n<blockquote>\n<p>I'm not all that fussed, but I really want to be able to use deref patterns with <code>Box&lt;str&gt;</code>, <code>String</code>, and possibly things like <code>Vec</code>s would be amazing. I don't particularly plan on implementing it on my own types, but I can see where it would be useful sometimes</p>\n</blockquote>\n<p>I have some user-defined types I'd like to implement.</p>\n</blockquote>\n<p>How complex would your derefs typically be if they were functions? Is it just returning some pointers or borrows of certain things, or are they doing more complex operations?</p>\n</blockquote>\n<p>Currently, many of them are just reimplementations of standard library types. xlang_abi (in lccc) has it's own allocator, it's own <code>Box</code>, it's own <code>Vec</code>, it's own <code>String</code>, etc. <br>\nOne type involves a pointer subtraction +from_raw_parts+from_utf8_unchecked (<code>StringView</code>, which derefs into <code>&amp;str</code>, and is an abi-safe version of the latter), and two types involve from_raw_parts{,_mut} (<code>Span</code> and <code>SpanMut</code>, which are respectively <code>&amp;[T}</code> and <code>&amp;mut [T]</code>)</p>",
        "id": 272016665,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644949437
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/281601-project-deref-patterns/topic/2022-1.20Update/near/272016641\">said</a>:</p>\n<blockquote>\n<p>I think it's a good example of a not-pure-but-morally-pure-enough-for-deref-patterns deref too</p>\n</blockquote>\n<p>Yeah, the MVP will likely exclude <code>Lazy</code>/<code>SyncLazy</code>, but I'm fairly certain most definitions of <code>DerefPure</code> could permit it.</p>",
        "id": 272016911,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644949541
    },
    {
        "content": "<p>That would be quite useful for the OS i'm working on</p>",
        "id": 272017014,
        "sender_full_name": "Albert",
        "timestamp": 1644949573
    },
    {
        "content": "<p>I've needed deref patterns hundreds of times, especially when I'm writing ASTs and tests for parsers and such</p>",
        "id": 272017070,
        "sender_full_name": "Albert",
        "timestamp": 1644949597
    },
    {
        "content": "<p>It'd literally cut out like 50% of my code I think</p>",
        "id": 272017097,
        "sender_full_name": "Albert",
        "timestamp": 1644949607
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"478671\">Albert</span> <a href=\"#narrow/stream/281601-project-deref-patterns/topic/2022-1.20Update/near/272017070\">said</a>:</p>\n<blockquote>\n<p>I've needed deref patterns hundreds of times, especially when I'm writing ASTs and tests for parsers and such</p>\n</blockquote>\n<p>Yeah, parsers are one of my major use cases. I'd love deref patterns for writing lccc (although I probably won't see them for a long time because MSRV 1.54 - need bootstrap via mrustc or gcc-rs, and the latter isn't functional enough).</p>",
        "id": 272017333,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644949704
    },
    {
        "content": "<p>Anything I can do to help move this forward? Happy to get my hands dirty in the compiler but I will need guidance</p>",
        "id": 272642889,
        "sender_full_name": "Albert",
        "timestamp": 1645421126
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"478671\">Albert</span> <a href=\"#narrow/stream/281601-project-deref-patterns/topic/2022-1.20Update/near/272642889\">said</a>:</p>\n<blockquote>\n<p>Anything I can do to help move this forward? Happy to get my hands dirty in the compiler but I will need guidance</p>\n</blockquote>\n<p>I'm really not the right person to give advice, sorry for barging in (I've literally discovered this project group an hour ago), but I hope this can help nonetheless, I just couldn't ignore your motivation <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span><br>\nThis looks like a big endeavor for a first contribution though, so if you want to help, I'd suggest to at least get comfortable with the overall structure of the compiler. The <a href=\"https://rustc-dev-guide.rust-lang.org/overview.html\">dev guide</a> is probably a good place to start.</p>\n<p>The first thing that'll need to be done is adding a new <code>#![feature(deref_patterns)]</code> gate, see the relevant <a href=\"https://rustc-dev-guide.rust-lang.org/feature-gates.html#adding-a-feature-gate\">rustc-dev-guide chapter</a>.</p>\n<p>All subsequent work will need to ensure that behavior is unchanged when the feature gate is unset. You can check whether a feature is set through <a href=\"https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TyCtxt.html#method.features\"><code>TyCtxt::features</code></a>, where <code>TyCtxt</code> is passed through most of the compiler and often named <code>tcx</code>.</p>\n<p>My understanding is that the first implementation will be the \"no syntax\" option, otherwise implementation work in the parser will be needed, as well as modifications in the AST and HIR to pass down the additional information to the later compilation steps.</p>\n<p>Since there is no syntax, detecting deref patterns will take place in type checking and type inference. The goal is to make the type checker understand that it can unify the scrutinee type and the pattern type through dereferences. I don't know more than that, type checking is just magic to me <span aria-label=\"sparkles\" class=\"emoji emoji-2728\" role=\"img\" title=\"sparkles\">:sparkles:</span></p>\n<p>Based on that information, any deref pattern should be made explicit in the THIR. Relevant code is in <a href=\"https://github.com/rust-lang/rust/blob/master/compiler/rustc_mir_build/src/thir/pattern/mod.rs#L45\"><code>rustc_mir_build::thir::pattern</code></a>. Introducing a <a href=\"https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/thir/enum.PatKind.html#variant.Deref\"><code>PatKind::Deref</code></a> (which currently represents <code>&amp;</code> and <code>box</code> patterns) might be enough.</p>\n<p>The last thing should be lowering to MIR. In the best case, this is close enough to <code>box</code> patterns that there is little to change <span aria-label=\"fingers crossed\" class=\"emoji emoji-1f91e\" role=\"img\" title=\"fingers crossed\">:fingers_crossed:</span></p>",
        "id": 273265852,
        "sender_full_name": "Léo Lanteri Thauvin",
        "timestamp": 1645813388
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"478671\">Albert</span> <a href=\"#narrow/stream/281601-project-deref-patterns/topic/2022-1.20Update/near/272642889\">said</a>:</p>\n<blockquote>\n<p>Anything I can do to help move this forward? Happy to get my hands dirty in the compiler but I will need guidance</p>\n</blockquote>\n<p>Sorry I keep getting busy with other projects ( One of them was a DR for inline asm which got superpriority because of the urgency - it basically got in on the buzzer - as well as work on lccc). I don't know if I've linked it before, but the work is currently in my fork of rust-lang/rust, <a href=\"https://github.com/chorman0773/rust\">https://github.com/chorman0773/rust</a>, in the deref-patterns branch (LMK if you want to be added, I can certainly do that). <br>\nIt already has the feature added, but the rest needs to be done.<br>\nWhen I'm done what I'm currently working on (which is redoing a modr/m emitter so lccc can support reading from/writing to memory addresses, so heh) I should be able to do some work from my side. Hopefully later today (Not going to make any specific promises this time though because its ModR/M).</p>",
        "id": 273270115,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645815498
    },
    {
        "content": "<p>(I'm currently looking at the typeck side of things)</p>",
        "id": 275646703,
        "sender_full_name": "Léo Lanteri Thauvin",
        "timestamp": 1647521512
    },
    {
        "content": "<p>Hey, I just read through a bit, I've missed the last few months of development ^^</p>",
        "id": 277913116,
        "sender_full_name": "Nadrieril",
        "timestamp": 1649178985
    },
    {
        "content": "<p>I'm thinking that if we really want an MVP, piggy-backing on top of box-patterns sounds much better to me. Both because there's almost no risk of breaking existing code and because most of what's needed is already in place throughout the compiler</p>",
        "id": 277913249,
        "sender_full_name": "Nadrieril",
        "timestamp": 1649179050
    },
    {
        "content": "<p>I expect the no-syntax option to run into subtle inference breakage</p>",
        "id": 277913491,
        "sender_full_name": "Nadrieril",
        "timestamp": 1649179141
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"245339\">Nadrieril</span> <a href=\"#narrow/stream/281601-project-deref-patterns/topic/2022-1.20Update/near/277913249\">said</a>:</p>\n<blockquote>\n<p>I'm thinking that if we really want an MVP, piggy-backing on top of box-patterns sounds much better to me. Both because there's almost no risk of breaking existing code and because most of what's needed is already in place throughout the compiler</p>\n</blockquote>\n<p>by which I mean, literally reuse the <code>box foo</code> syntax but have it work for Rc, String etc too</p>",
        "id": 277913565,
        "sender_full_name": "Nadrieril",
        "timestamp": 1649179185
    },
    {
        "content": "<p>Happy to do the pattern exhaustiveness part since I know that part of rustc</p>",
        "id": 277914002,
        "sender_full_name": "Nadrieril",
        "timestamp": 1649179350
    },
    {
        "content": "<p>It kinda doesn't make a whole lot of sense though</p>",
        "id": 278668474,
        "sender_full_name": "Albert",
        "timestamp": 1649755912
    },
    {
        "content": "<p>I really just wanna see this come out soon though. It's a really important feature</p>",
        "id": 278668560,
        "sender_full_name": "Albert",
        "timestamp": 1649755948
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/281601-project-deref-patterns/topic/2022-1.20Update/near/273270115\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"478671\">Albert</span> <a href=\"#narrow/stream/281601-project-deref-patterns/topic/2022-1.20Update/near/272642889\">said</a>:</p>\n<blockquote>\n<p>Anything I can do to help move this forward? Happy to get my hands dirty in the compiler but I will need guidance</p>\n</blockquote>\n<p>Sorry I keep getting busy with other projects ( One of them was a DR for inline asm which got superpriority because of the urgency - it basically got in on the buzzer - as well as work on lccc). I don't know if I've linked it before, but the work is currently in my fork of rust-lang/rust, <a href=\"https://github.com/chorman0773/rust\">https://github.com/chorman0773/rust</a>, in the deref-patterns branch (LMK if you want to be added, I can certainly do that). <br>\nIt already has the feature added, but the rest needs to be done.<br>\nWhen I'm done what I'm currently working on (which is redoing a modr/m emitter so lccc can support reading from/writing to memory addresses, so heh) I should be able to do some work from my side. Hopefully later today (Not going to make any specific promises this time though because its ModR/M).</p>\n</blockquote>\n<p>How are things going with this?</p>\n<p>Happy to allocate some time to this but I will need some mentoring &amp; direction.</p>",
        "id": 278673273,
        "sender_full_name": "Albert",
        "timestamp": 1649758922
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"478671\">Albert</span> <a href=\"#narrow/stream/281601-project-deref-patterns/topic/2022-1.20Update/near/278668474\">said</a>:</p>\n<blockquote>\n<p>It kinda doesn't make a whole lot of sense though</p>\n</blockquote>\n<p>yeah, I meant only as an MVP so we get some sort of implementation out there</p>",
        "id": 278693484,
        "sender_full_name": "Nadrieril",
        "timestamp": 1649770635
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"478671\">Albert</span> <a href=\"#narrow/stream/281601-project-deref-patterns/topic/2022-1.20Update/near/278673273\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/281601-project-deref-patterns/topic/2022-1.20Update/near/273270115\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"478671\">Albert</span> <a href=\"#narrow/stream/281601-project-deref-patterns/topic/2022-1.20Update/near/272642889\">said</a>:</p>\n<blockquote>\n<p>Anything I can do to help move this forward? Happy to get my hands dirty in the compiler but I will need guidance</p>\n</blockquote>\n<p>Sorry I keep getting busy with other projects ( One of them was a DR for inline asm which got superpriority because of the urgency - it basically got in on the buzzer - as well as work on lccc). I don't know if I've linked it before, but the work is currently in my fork of rust-lang/rust, <a href=\"https://github.com/chorman0773/rust\">https://github.com/chorman0773/rust</a>, in the deref-patterns branch (LMK if you want to be added, I can certainly do that). <br>\nIt already has the feature added, but the rest needs to be done.<br>\nWhen I'm done what I'm currently working on (which is redoing a modr/m emitter so lccc can support reading from/writing to memory addresses, so heh) I should be able to do some work from my side. Hopefully later today (Not going to make any specific promises this time though because its ModR/M).</p>\n</blockquote>\n<p>How are things going with this?</p>\n<p>Happy to allocate some time to this but I will need some mentoring &amp; direction.</p>\n</blockquote>\n<p>I've still been rather busy, and I expect to remain that way at least until the end of april, as I have my exams coming up.<br>\nAfter that, though, I'm done uni until september so I should have time to work on this. <br>\nI'm still prioritizing backend work on lccc, though. We've made some fairly quick advances, and we might have an MVP of it by the end of the year.</p>",
        "id": 278715395,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649779908
    }
]