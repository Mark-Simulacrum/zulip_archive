[
    {
        "content": "<p>I would like to start the discussion on the syntax for Deref patterns.<br>\nSo there has been a few different syntaxes proposed, which can be divided into:</p>\n<ul>\n<li>No Syntax</li>\n<li>Using a sigil</li>\n<li>And Using a keyword.</li>\n</ul>\n<p>The last option, using a keyword, would likely require reserving a keyword in a future edition (though using <code>k#</code> syntax or <code>r#$</code> syntax would be an option in earlier editions), unless we reused the existing <code>box</code> keyword from <code>box_syntax</code>. </p>\n<p>Potential sigils that have been considered are a new <code>*</code> sigil, or reusing the <code>&amp;</code> sigil. The no syntax option would be nice for ergnomics, but it cannot be applicable in all cases (like with match ergonomics), so there should still be some syntax.</p>",
        "id": 235263175,
        "sender_full_name": "Connor Horman",
        "timestamp": 1618873547
    },
    {
        "content": "<p>this seems like a good topic to explore, yes</p>",
        "id": 235398850,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1618945967
    },
    {
        "content": "<p>One consideration: we may eventually want to permit moves out from behind the smart pointer</p>",
        "id": 235398943,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1618946018
    },
    {
        "content": "<p>the <code>box</code> keyword was something we intended to use at one time for this</p>",
        "id": 235398980,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1618946036
    },
    {
        "content": "<p>but I think that it would be very confusing to folks when used on something other than <code>Box</code></p>",
        "id": 235399050,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1618946053
    },
    {
        "content": "<p>I have been thinking a bit about the syntax. From Esteban's internals thread, there was a  desire to use a single keyword/sigil whatever, as opposed to using the smart pointer name (e.g, Rc for deref'ing Rc, etc). Following this line of thought, I think we want to treat all deref patterns as 'pointer-like' as opposed to 'type-like' where we do need to name the type (structs, enums). Therefore, I would like to propose that we extend the use of <code>&amp;</code> in patterns to match a 'pointer' rather than just specifically a borrowed reference. A further analogy is the <code>*</code> operator in expressions, which we use to deref any pointer, not just raw pointers.</p>",
        "id": 244990548,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1625539532
    },
    {
        "content": "<p>IMO, to be correct we must only consider deref patterns where the matched expression is borrowed, e.g., where <code>x: Rc&lt;Foo&gt;</code>, <code>match x</code> would only permit structural matches on <code>Rc</code>, but <code>match &amp;x</code> would permit deref patterns (this makes sense to me because the signature of <code>deref</code> takes <code>&amp;self</code>), this leaves space later to support <code>DerefMove</code></p>",
        "id": 244990710,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1625539731
    },
    {
        "content": "<p>Example: </p>\n<div class=\"codehilite\"><pre><span></span><code>fn proposed(a: Rc&lt;Foo&gt;) {\n    match &amp;a { // : &amp;Rc&lt;Foo&gt;\n        &amp;Foo::Bar =&gt; println!(&quot;bar&quot;),\n        &amp;x =&gt; {} // x: Rc&lt;Foo&gt;\n    }\n}\n</code></pre></div>",
        "id": 244990792,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1625539822
    },
    {
        "content": "<p>Note that the &amp; in the first pattern matches &amp; <em>and</em> causes a deref</p>",
        "id": 244990813,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1625539862
    },
    {
        "content": "<p>In the second pattern, we don't apply the deref rules because we don't need to.</p>",
        "id": 244990891,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1625539952
    },
    {
        "content": "<p>Now, consider the match ergonomics rules, I would apply those here as well. Therefore the <code>&amp;</code> is optional in many contexts, so we get:</p>\n<div class=\"codehilite\"><pre><span></span><code>fn proposed(a: Rc&lt;Foo&gt;) {\n    match &amp;a { // : &amp;Rc&lt;Foo&gt;\n        Foo::Bar =&gt; println!(&quot;bar&quot;),\n        x =&gt; {} // x: &amp;Rc&lt;Foo&gt;\n    }\n}\n</code></pre></div>\n<p>Note that the type of <code>x</code> depends on how it is used (binding mode), but it is not really important because in most contexts, <code>&amp;Rc&lt;Foo&gt;</code> coerces to <code>&amp;Foo</code>.</p>",
        "id": 244990974,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1625540103
    },
    {
        "content": "<p>This syntax gives us the desirable syntax for strings, but is not quite the same as the 'no sigil' option</p>",
        "id": 244991026,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1625540164
    },
    {
        "content": "<p>The downside of this approach is that we can't use it on nested pointers, e.g., <code>Option&lt;Rc&lt;Foo&gt;&gt;</code>, however, in this case we can use <code>as_ref</code> to convert to <code>Option&lt;&amp;Rc&lt;Foo&gt;&gt;</code>, and when matching that we could use a pattern like <code>Some(&amp;Foo::Bar)</code>. I'm not sure if this is a good thing or a bad thing</p>",
        "id": 244991399,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1625540712
    },
    {
        "content": "<p>Note that this syntax does not subsume <code>box</code> patterns, and I think that is a feature, not a bug since box patterns (and * for Box) are a special case more similar to DerefMove than Deref</p>",
        "id": 244991554,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1625540922
    },
    {
        "content": "<p>So, the problem with using &amp; is that it affects existing code.</p>",
        "id": 245019623,
        "sender_full_name": "Connor Horman",
        "timestamp": 1625567105
    },
    {
        "content": "<p>Or.. Hm.</p>",
        "id": 245019804,
        "sender_full_name": "Connor Horman",
        "timestamp": 1625567251
    },
    {
        "content": "<p>I think it may not under this suggestion, but it matches deref patterns less than may be desired. There are a few cases that &amp;impl Deref&lt;Target=T&gt; doesn't coerce to &amp;T, the main one being generic contexts. Whether this is a problem since x can be explicitly be deref-borrowed, I do not know.</p>",
        "id": 245020060,
        "sender_full_name": "Connor Horman",
        "timestamp": 1625567426
    },
    {
        "content": "<blockquote>\n<p>Note that this syntax does not subsume <code>box</code> patterns, and I think that is a feature, not a bug since box patterns (and * for Box) are a special case more similar to DerefMove than Deref</p>\n</blockquote>\n<p>I don't necessarily see why the syntax used couldn't cause DerefMove for Box or other types in the future. Perhaps not immediately, but my intention is that deref patterns completely replace the totally magic box patterns eventually.</p>",
        "id": 245020350,
        "sender_full_name": "Connor Horman",
        "timestamp": 1625567612
    },
    {
        "content": "<blockquote>\n<p>&amp;impl Deref&lt;Target=T&gt; doesn't coerce to &amp;T</p>\n</blockquote>\n<p>could you expand on the generic case please? AIUI the signature of deref is &amp;Self -&gt; &amp;Self::Target, so that would always align with matching the reference version</p>",
        "id": 245107442,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1625611268
    },
    {
        "content": "<blockquote>\n<p>I don't necessarily see why the syntax used couldn't cause DerefMove for Box or other types in the future. Perhaps not immediately, but my intention is that deref patterns completely replace the totally magic box patterns eventually.</p>\n</blockquote>\n<p>My assumption is that deref patterns for the borrowed and moved cases should have different syntax, otherwise we would need some magic to guess which to apply and I think that would always be unsatisfactory. We do tend to make borrowing distinct from moving in our syntax (consider <br>\nthe match ergonomics rules as an example, we don't do any <em>additional</em> implicit borrowing, we only apply the rules if the type of the expression being matched is already borrowed. Likewise with implicit deref coercions).</p>",
        "id": 245107746,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1625611507
    },
    {
        "content": "<p>So, I agree that  deref patterns should replace box patterns in the long term, but I don't believe they should until we have DerefMove, and this proposal leaves room for that to happen in the future because it only applies to borrowed values in the short term</p>",
        "id": 245107868,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1625611603
    },
    {
        "content": "<p>It might look like:</p>\n<div class=\"codehilite\"><pre><span></span><code>fn not_proposed_yet(a: Box&lt;bool&gt;) {\n    match a {\n        &amp;true =&gt; println!(&quot;t&quot;),  // &amp; cannot be elided because a is not borrowed.\n        &amp;false =&gt; println!(&quot;f&quot;),\n    }\n}\n</code></pre></div>\n<p>In this case we use the (implicit for Box) DerefMove impl, and in the <code>match &amp;a</code> case we use the Deref impl</p>",
        "id": 245108162,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1625611845
    },
    {
        "content": "<p>My feeling is that we shouldn't worry too much about this up front, that is, we likely want \"no syntax\" similarly to match ergonomics, and there's a lot to be said for that being a big win already, even before we get into stabilization. I think lang discussions (a few months ago now) also moved towards this</p>",
        "id": 245108235,
        "sender_full_name": "simulacrum",
        "timestamp": 1625611914
    },
    {
        "content": "<p>But an explicit syntax is definitely also desired, I think, so figuring that out makes sense - it just doesn't seem like the top concern at this juncture from my understanding.</p>",
        "id": 245108338,
        "sender_full_name": "simulacrum",
        "timestamp": 1625611980
    },
    {
        "content": "<p>I think my proposal is pretty much the 'no syntax' proposal, but the question is precisely how that works (and how we support the borrowed vs moving versions of deref in the long term feels important to me)</p>",
        "id": 245108472,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1625612058
    },
    {
        "content": "<blockquote>\n<p>it just doesn't seem like the top concern at this juncture from my understanding.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span>  What do you think are the major concerns? From reading the comments in various places and the design doc, it seems to me that the syntax and exhaustiveness checking are the open questions.</p>",
        "id": 245108557,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1625612162
    },
    {
        "content": "<p>My impression is that there is essentially broad agreement on a limited subset for initial stabilization where exhaustiveness isn't a concern, and potentially even no need for an explicit syntax - e.g., \"foo\" matching for String.</p>",
        "id": 245109142,
        "sender_full_name": "simulacrum",
        "timestamp": 1625612558
    },
    {
        "content": "<p>I think the open questions are around the exact behavior on capture (e.g., marching on String with a @ \"foo\", does that give you a: String, a: &amp;str, or a: &amp;String?)</p>",
        "id": 245109219,
        "sender_full_name": "simulacrum",
        "timestamp": 1625612617
    },
    {
        "content": "<blockquote>\n<p>initial stabilization</p>\n</blockquote>\n<p>presumably we'd want an RFC and an unstable implementation first?</p>",
        "id": 245109600,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1625612868
    },
    {
        "content": "<blockquote>\n<p>I think the open questions are around the exact behavior on capture (e.g., marching on String with a @ \"foo\", does that give you a: String, a: &amp;str, or a: &amp;String?)</p>\n</blockquote>\n<p>I'll start a new thread ...</p>",
        "id": 245109671,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1625612908
    },
    {
        "content": "<p>I think the current trajectory in lang discussions <a href=\"https://github.com/rust-lang/lang-team/blob/master/design-meeting-minutes/2021-06-30-lang-team-projects.md\">https://github.com/rust-lang/lang-team/blob/master/design-meeting-minutes/2021-06-30-lang-team-projects.md</a> (though not formally accepted) is that stuff can land as unstable in rustc for experimentation with just a project group in existence. But yeah, before we get to stabilization we'd want an RFC - it just doesn't need to cover all the possible feature area</p>",
        "id": 245110789,
        "sender_full_name": "simulacrum",
        "timestamp": 1625613893
    },
    {
        "content": "<p><span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span> cool!</p>",
        "id": 245111608,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1625614696
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> is there a concrete proposal for any of the alternative syntaxes? I've seen a few examples in the design doc, but not a detailed proposal</p>",
        "id": 245247571,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1625694944
    },
    {
        "content": "<p>ping <span class=\"user-mention\" data-user-id=\"119031\">@Esteban Küber</span> any thoughts on the &amp;/no sigil proposal above? Or about the syntax in general (more recent thoughts than the internals thread)</p>",
        "id": 245248233,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1625695289
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/281601-project-deref-patterns/topic/Deref.20Patterns.20Syntax/near/245247571\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> is there a concrete proposal for any of the alternative syntaxes? I've seen a few examples in the design doc, but not a detailed proposal</p>\n</blockquote>\n<p>Wdym concrete proposals? The design doc lists all of the currently and previously discussed syntax for deref patterns. It has examples of each of the syntaxes being used.</p>",
        "id": 245251822,
        "sender_full_name": "Connor Horman",
        "timestamp": 1625697895
    },
    {
        "content": "<p>I guess discussion of pros and cons, people's preferences, analysis of edge cases or open questions. I'm basically trying to figure out how to move forward on choosing a syntax to implement</p>",
        "id": 245260119,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1625704325
    },
    {
        "content": "<p>One possibility would be to start out only supporting built-in types and only dereferencing to literals. That much doesn't need syntax.</p>",
        "id": 245278259,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625727647
    },
    {
        "content": "<p>True, but I think in that case we'd want to think a bit about the next step in parallel with implementation, because I don't think we'd learn much from the implementation about the general case (although of  course these things are always full of surprises :-) )</p>",
        "id": 245283439,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1625731432
    },
    {
        "content": "<p>So thinking about the proposal to start implementing an absolutely minimal version, I think there is still the question of whether we require the matched expression to be borrowed, e.g.,</p>\n<div class=\"codehilite\"><pre><span></span><code>fn question(a: String, b: &amp;String) {\n    // match 1\n    match a {\n        &quot;hello&quot; =&gt; {}\n        _ =&gt; {}\n    }\n    // match 2\n    match &amp;a {\n        &quot;hello&quot; =&gt; {}\n        _ =&gt; {}\n    }\n    // match 3\n    match b {\n        &quot;hello&quot; =&gt; {}\n        _ =&gt; {}\n    }\n}\n</code></pre></div>\n<p>Match 2 and 3 have the same types but different shapes (potentially important, but I don't think it should be). In all matches the pattern has type &amp;'static str.</p>\n<p>In my proposal above, match 1 would not be allowed, but matches 2 and 3 would. I think the 'pure' no sigil proposal would allow match 1 too. The reason I don't think it should is that we would have to implicitly borrow <code>a</code> to have the right type for the deref function, and because in the future where DerefMove exists, I would like to apply DerefMove in the case of match 1 and Deref in the cases of 2 and 3.</p>",
        "id": 245368733,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1625776603
    },
    {
        "content": "<blockquote>\n<p>The reason I don't think it should is that we would have to implicitly borrow <code>a</code> to have the right type for the deref function,</p>\n</blockquote>\n<p>But match has always allowed the scrutinee to be a place expression, and won't move it out unless the match arm contains a by-move variable binding. For that reason I would expect match 1 to <em>not</em> use DerefMove because it doesn't have any by-move bindings, and indeed you can implement equivalent functionality without having to move <code>a</code> into the match.</p>",
        "id": 245380301,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625783623
    },
    {
        "content": "<p>this case is also weird because string literals have reference type \"built in\"- it might be easier to work out the rules relative to something like <code>Vec&lt;u8&gt;</code> or <code>Box&lt;i32&gt;</code> first?</p>",
        "id": 245381554,
        "sender_full_name": "rpjohnst",
        "timestamp": 1625784574
    },
    {
        "content": "<p>I think that in the simplest, no match ergonomics mode, you should be able to use the <code>*</code> sigil to transform a pattern of type <code>T</code> to <code>U</code> where <code>T: Deref&lt;Target=U&gt;</code> (working from the outside in, i.e. if we need <code>*pat: T</code> then it suffices that <code>pat: U</code>). Whether this calls Deref or DerefMut or DerefMove is determined later by whether the binding at the end is by-move/ref/mut. So for example:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">proposal</span><span class=\"p\">(</span><span class=\"n\">a</span>: <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span>: <span class=\"nb\">Box</span><span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"k\">ref</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"c1\">// p: &amp;[u8], a is not moved</span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">*</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"c1\">// p: [u8], unsized local error</span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">*</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"c1\">// x: u8, a is not moved</span>\n<span class=\"w\">        </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"k\">ref</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"c1\">// a: &amp;mut u8, b is mutably borrowed</span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">*</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"c1\">// a: u8, b would normally be moved but not in this case because u8 is copy</span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 245382765,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625785565
    },
    {
        "content": "<p>Regarding string weirdness, I think the easiest solution is to be able to use <code>\"xyz\"</code> as a pattern of type either <code>&amp;str</code> or <code>str</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">proposal2</span><span class=\"p\">(</span><span class=\"n\">a</span>: <span class=\"nb\">String</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"k\">ref</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"c1\">// p: &amp;str, a is not moved</span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">*</span><span class=\"s\">\"foo\"</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"c1\">// matching \"foo\" against a pattern place of type str</span>\n<span class=\"w\">        </span><span class=\"k\">ref</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">@</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"s\">\"bar\"</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"c1\">// x: &amp;String</span>\n<span class=\"w\">        </span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"k\">ref</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">@</span><span class=\"w\"> </span><span class=\"s\">\"bar\"</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"c1\">// x: &amp;str</span>\n<span class=\"w\">        </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">@</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"s\">\"bar\"</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"c1\">// x: String, moves a</span>\n<span class=\"w\">         </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"o\">&amp;*</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"s\">\"foo\"</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"c1\">// matching \"foo\" against a pattern place of type &amp;str</span>\n<span class=\"w\">        </span><span class=\"o\">&amp;</span><span class=\"s\">\"bar\"</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"c1\">// matching \"bar\" against a pattern place of type str</span>\n<span class=\"w\">         </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 245383295,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625785977
    },
    {
        "content": "<blockquote>\n<p>this case is also weird because string literals have reference type \"built in\"- it might be easier to work out the rules relative to something like Vec&lt;u8&gt; or Box&lt;i32&gt; first?</p>\n</blockquote>\n<p>Box is also weird because it has implicit/built-in move deref semantics as well as the explicit deref with borrowing semantics. Maybe Rc&lt;i32&gt; is the least weird place to start? (or Vec, though maybe the details of slice patterns will complicate that)</p>",
        "id": 245385391,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1625787753
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> using <code>*</code> as the sigil seems wrong to me - sigils in patterns usually deconstruct what they would construct in expressions, whereas here, the sigil would be doing  roughly the same a it does in expression context. I.e., it is going 'the wrong way round'.</p>",
        "id": 245385870,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1625788280
    },
    {
        "content": "<p>I think you can find/replace <code>&amp;</code> for <code>*</code> in the example if you want to use another sigil</p>",
        "id": 245385957,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625788339
    },
    {
        "content": "<p>I am familiar with this reasoning about expression mirroring construction, but you don't use <code>&amp;</code> to build a <code>String</code>, so I have found the analogue somewhat confusing in this context</p>",
        "id": 245386008,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625788419
    },
    {
        "content": "<p>I normally associate use of <code>*</code> with calls to deref, so it more naturally springs to mind</p>",
        "id": 245386112,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625788492
    },
    {
        "content": "<p>Yeah, I think that using &amp; is a stretch, the intuition for me is that &amp; represents a 'pointer' in pattern context, not just a reference</p>",
        "id": 245386120,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1625788498
    },
    {
        "content": "<p>and it's also conveniently unused in pattern grammar</p>",
        "id": 245386139,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625788522
    },
    {
        "content": "<p>I do like that it tends to produce patterns that look like <code>&amp;****(ref a)</code> which are familiar from expression context</p>",
        "id": 245386218,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625788600
    },
    {
        "content": "<p>The synbtax which most conforms to current syntax, IMO, is to use the pointer name, i.e., use String to deref a String, Box to deref a Box, etc. (possibly with some other sigil or keyword to avoid ambiguity with structural matching), but there was a lot of pushback against that on the old internals thread. If we're using one sigil/keyword for all pointer-like things, then I think &amp; makes sense</p>",
        "id": 245386222,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1625788605
    },
    {
        "content": "<blockquote>\n<p>Mario Carneiro: I do like that it tends to produce patterns that look like &amp;****(ref a) which are familiar from expression context</p>\n</blockquote>\n<p>IMO this violates the principal that things which look similar should be similar and things which look different should be different. Because in that pattern, &amp; and * are doing basically the same thing</p>",
        "id": 245386327,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1625788725
    },
    {
        "content": "<p>Is it? <code>Deref</code> coercion does not change from one pointer type to another, it changes one place type to another. <code>&amp;</code> dereferences pointers</p>",
        "id": 245386358,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625788768
    },
    {
        "content": "<p>That is, <code>*</code> is being used to go from <code>String</code> to <code>str</code></p>",
        "id": 245386428,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625788807
    },
    {
        "content": "<p>there aren't any references directly involved, so I don't see how <code>&amp;</code> can be made to fit</p>",
        "id": 245386475,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625788860
    },
    {
        "content": "<p>If you pattern match directly on a type <code>a: T</code> with a bunch of derefs on it, you get a pattern like <code>***(ref p)</code> without the initial <code>&amp;</code>. You would only have that if you matched on <code>a: &amp;T</code></p>",
        "id": 245386621,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625788982
    },
    {
        "content": "<p>Hmm, that makes sense if you read * as an operator in the pattern (like ref) rather than as constructor (using some hand wavey terminology here)</p>",
        "id": 245386845,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1625789189
    },
    {
        "content": "<p>Well, I don't have any strong feelings about it. Other sigils work too, and I'm mainly interested in pinning down how the nuts and bolts of the matching itself work, to assist with the implementation side</p>",
        "id": 245386941,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625789315
    },
    {
        "content": "<p>It feels a bit weird that the deref method gives a &amp;U and we are dereferencing that implicitly, but would require the &amp; if the original type is borrowed. I see the reasoning in that we're treatingit as a place, but it sill seems odd to me, maybe I should just sit with it for a while :-)</p>",
        "id": 245386958,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1625789348
    },
    {
        "content": "<p>It's because we aren't actually calling deref; we actually don't know whether we'll be calling deref or deref_mut when we do typechecking. It's the same with regular deref coercion</p>",
        "id": 245387033,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625789445
    },
    {
        "content": "<p>I haven't treated how match ergonomics interacts with this, or whether there should be additional match ergonomics extensions specifically for deref patterns. It would be cool to be able to insert derefs to fix type errors but I don't know how feasible that is (and it might also be tough to specify)</p>",
        "id": 245387135,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625789567
    },
    {
        "content": "<p>Note: Reguardless of the syntax, an attempt to produce a by-value binding should be ill-formed except for Box (until we have DerefMove)</p>",
        "id": 245387625,
        "sender_full_name": "Connor Horman",
        "timestamp": 1625790170
    },
    {
        "content": "<p>Still assuming <code>*</code> as sigil: Match ergonomics (\"default binding modes\") are triggered when you use a struct pattern like <code>Some(x): &amp;Option&lt;T&gt;</code> (using <code>pat: T</code> to mean that <code>pat</code> is being typechecked with expected type <code>T</code>), which leads to <code>x: T [ref]</code>, where <code>[ref]</code> means that <code>x</code> will be changed to a ref binding even if the user doesn't write <code>ref x</code>.</p>\n<p>Let's say that we have a goal <code>*pat: T</code>. We check that <code>T</code> has a deref to <code>U</code>. If it supports Deref but not DerefMut, we do <code>pat: U [ref]</code>, if it has DerefMut then we do <code>pat: U [ref mut]</code>, and if it has DerefMove (aka it is <code>Box&lt;U&gt;</code>) then we just check <code>pat: U</code>. Examples:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">match_ergonomics</span><span class=\"p\">(</span><span class=\"n\">a</span>: <span class=\"nb\">String</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span>: <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"nb\">String</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">c</span>: <span class=\"nb\">Box</span><span class=\"o\">&lt;</span><span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"nb\">String</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">d</span>: <span class=\"kp\">&amp;</span><span class=\"nb\">String</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">*</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"c1\">// a: &amp;mut str</span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">*</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"c1\">// b: &amp;mut [String]</span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">*</span><span class=\"p\">[</span><span class=\"n\">b</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"c1\">// b: &amp;mut String</span>\n<span class=\"w\">        </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">*</span><span class=\"p\">[</span><span class=\"o\">*</span><span class=\"n\">b</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"s\">\"foo\"</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"c1\">// b: &amp;mut str</span>\n<span class=\"w\">        </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"k\">ref</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"c1\">// b: &amp;[String]</span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">*</span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"s\">\"foo\"</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"c1\">// star is required for deref coercion, but does not move c</span>\n<span class=\"w\">        </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"c1\">// x: &amp;String because we deref'd &amp;String and ref-bound the result</span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">**</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"c1\">// x: &amp;str</span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>I'm not sure I totally like the consequences here, and in particular it would be nice to have <code>x: &amp;str</code> in the second to last example, but <code>&amp;T</code> itself implements deref (to <code>T</code>, of course), so even though we are using a different sigil it doesn't help here to determine that we want to deref <code>T</code> and not <code>&amp;T</code></p>",
        "id": 245388290,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625790960
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/281601-project-deref-patterns/topic/Deref.20Patterns.20Syntax/near/245386958\">said</a>:</p>\n<blockquote>\n<p>It feels a bit weird that the deref method gives a &amp;U and we are dereferencing that implicitly, but would require the &amp; if the original type is borrowed. I see the reasoning in that we're treatingit as a place, but it sill seems odd to me, maybe I should just sit with it for a while :-)</p>\n</blockquote>\n<p>another case of the \"treating it as a place\" idea is the reasoning that led to <code>&amp;foo[i..j]</code> requiring that \"extra\" <code>&amp;</code>. at the time there were arguments for bare <code>foo[i..j]</code> (and also <code>foo[i]</code> for consistency, iirc?) to have reference-to-slice type, but in the end what won out was consistency with <code>foo[i]</code> being a place.</p>\n<p>IOW it doesn't matter what the <code>deref</code> method (or the <code>index</code>) method returns, because the user isn't concerned with calling that method- they're using the <code>*</code>/<code>[i]</code>/deref-pattern syntax which operates on places, and the method only returns a reference because Rust doesn't have C++-style reference types for places.</p>",
        "id": 245389559,
        "sender_full_name": "rpjohnst",
        "timestamp": 1625792315
    },
    {
        "content": "<p>though OTOH, Rust is already in kind of a weird place with Deref- in one sense it's the overloaded <code>*</code> operator and types that implement it are just \"other pointer types\" alongside <code>&amp;T</code>, but in another sense things like deref coercion and binding modes mean that types like <code>String</code> or <code>Vec</code> get treated as both \"fancy <code>&amp;str</code>/<code>&amp;[T]</code>\" and as \"owned\" things, so things are fuzzy depending on context (e.g. for some <code>fn f(s: &amp;str)</code> and <code>string: String</code> you typically call it with <code>f(&amp;string)</code> -- which looks like a double indirection even though IIUC it desugars to <code>&amp;*string</code>! -- rather than <code>f(string)</code> -- a consistent number of levels of indirection -- like you would if <code>string: &amp;str</code>)</p>",
        "id": 245389850,
        "sender_full_name": "rpjohnst",
        "timestamp": 1625792623
    },
    {
        "content": "<blockquote>\n<p>you typically call it with <code>f(&amp;string)</code> -- which looks like a double indirection even though IIUC it desugars to <code>&amp;*string</code>!</p>\n</blockquote>\n<p>Well, strictly speaking, it (eventually) desugars some more to <code>f(Deref::deref(&amp;string))</code>, which does actually contain a double indirection - the call to <code>deref</code> is taking a <code>&amp;String</code></p>",
        "id": 245390927,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625794004
    },
    {
        "content": "<p>but I guess that probably optimizes away</p>",
        "id": 245390956,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625794027
    },
    {
        "content": "<blockquote>\n<p>though OTOH, Rust is already in kind of a weird place with Deref ...</p>\n</blockquote>\n<p>I think this weirdness comes from conflating the deref coercion rules with applying Deref::deref. Looking somewhere without potential for coercion, * strictly converts &amp;T to &amp;&lt;T as Deref&gt;::Target. Taking into account the coercion rules, the intuition is that we can implicitly convert between different forms of borrowed data, but not from owned to borrowed (or vice versa). The rules for receivers are even more flexible though.</p>",
        "id": 245394288,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1625798338
    },
    {
        "content": "<blockquote>\n<p>It's because we aren't actually calling deref; we actually don't know whether we'll be calling deref or deref_mut when we do typechecking. It's the same with regular deref coercion</p>\n</blockquote>\n<p>I don't understand this. When doing deref coercion, we don't call deref, but we do follow the signature, e.g., we convert <code>&amp;String</code> to <code>&amp;str</code>. Coercion can also do other conversions, such as &amp;&amp; to &amp; which are not given by a Deref impl.</p>",
        "id": 245394587,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1625798766
    },
    {
        "content": "<blockquote>\n<p>But match has always allowed the scrutinee to be a place expression, and won't move it out unless the match arm contains a by-move variable binding. For that reason I would expect match 1 to not use DerefMove because it doesn't have any by-move bindings, and indeed you can implement equivalent functionality without having to move a into the match.</p>\n</blockquote>\n<p>I'm still trying to understand this properly. AIUI, if a: String, then in match a, a is not a place expression, it's a value expression. We don't necessarily move out of a though, only if the pattern value moves it. So in a branch b =&gt; {} we would move, but in ref b =&gt; {} we'd borrow. In either case, a pattern for b must have String type.</p>",
        "id": 245395129,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1625799570
    },
    {
        "content": "<p>So, extending this to deref patterns. I'll use <code>*</code> (though I'm still not a fan) and assume that DerefMove exists, though I'm not sure it makes sense for String</p>",
        "id": 245395461,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1625799890
    },
    {
        "content": "<p>The question is should *\"foo\" be a valid pattern for a branch of match a (delaying variables for a minute)</p>",
        "id": 245395536,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1625799963
    },
    {
        "content": "<p>I guess one could argue that since a.deref() would give &amp;str, then it should. OTOH, Deref::deref(a) would be a type error. <code>*a</code> is OK, but requires <code>&amp;*a</code> in most contexts because str is unsized.</p>",
        "id": 245395721,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1625800202
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/281601-project-deref-patterns/topic/Deref.20Patterns.20Syntax/near/245394587\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>It's because we aren't actually calling deref; we actually don't know whether we'll be calling deref or deref_mut when we do typechecking. It's the same with regular deref coercion</p>\n</blockquote>\n<p>I don't understand this. When doing deref coercion, we don't call deref, but we do follow the signature, e.g., we convert <code>&amp;String</code> to <code>&amp;str</code>. Coercion can also do other conversions, such as &amp;&amp; to &amp; which are not given by a Deref impl.</p>\n</blockquote>\n<p>Oops, I realize I've been using the wrong word. I am talking about the use of <code>*x</code> when <code>x</code> is not a reference type, for example <code>&amp;*x</code> where <code>x: Rc&lt;u8&gt;</code>. This doesn't call deref so much as construct a place with the target type described by the deref impl; the later use of <code>&amp;</code> or <code>&amp;mut</code> is what determines whether this is eventually desugared to a call to deref or deref_mut. I will call this using the star operator for want of a better name.</p>\n<p>Deref coercions are actually talking about how <code>&amp;T</code> \"decays\" to <code>&amp;U</code> without any syntax when typechecking demands it. In this case we could write the equivalent using the star operator as <code>&amp;**x</code>, and no fancy type mismatch repairs are needed to make this work. The examples I have given thus far haven't been using this at all, but one could potentially use the same method to remove some of the stars from the <code>match_ergonomics()</code> example.</p>",
        "id": 245395842,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625800331
    },
    {
        "content": "<p>So here we get to an interesting intersection with the syntax: if we use <code>*</code>, then I think it makes sense to accept match a, since the behaviour matches that of the * operator (mapping to *Deref::deref(&amp;a))</p>",
        "id": 245395850,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1625800354
    },
    {
        "content": "<p>But with <code>&amp;</code> it maybe doesn't make sense because that suggests the more regular coercion site rules which don't allow the implicit borrowing</p>",
        "id": 245395868,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1625800402
    },
    {
        "content": "<blockquote>\n<p>I am talking about the use of <em>x when x is not a reference type, for example &amp;</em>x where x: Rc&lt;u8&gt;. This doesn't call deref so much as construct a place with the target type described by the deref impl; the later use of &amp; or &amp;mut is what determines whether this is eventually desugared to a call to deref or deref_mut. I will call this using the star operator for want of a better name.</p>\n</blockquote>\n<p>I don't think that is quite accurate: see <a href=\"https://doc.rust-lang.org/stable/reference/expressions/operator-expr.html#the-dereference-operator\">https://doc.rust-lang.org/stable/reference/expressions/operator-expr.html#the-dereference-operator</a>, \"On non-pointer types *x is equivalent to *std::ops::Deref::deref(&amp;x) in an immutable place expression context and *std::ops::DerefMut::deref_mut(&amp;mut x) in a mutable place expression context.\"</p>",
        "id": 245395948,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1625800510
    },
    {
        "content": "<blockquote>\n<p>When doing deref coercion, we don't call deref, but we do follow the signature</p>\n</blockquote>\n<p>To clarify this, it should read \"When type checking a deref coercion, the compiler doesn't call deref, but it does follow the signature. deref <em>is</em> called at runtime\"</p>",
        "id": 245396104,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1625800713
    },
    {
        "content": "<blockquote>\n<p>I'm still trying to understand this properly. AIUI, if a: String, then in match a, a is not a place expression, it's a value expression. We don't necessarily move out of a though, only if the pattern value moves it.</p>\n</blockquote>\n<p>If it was a value expression, then we would always move out of it. For example if you have <code>a;</code> alone on a line then that would count as a use of <code>a</code> and we wouldn't be able to use it afterwards. The only reason <code>match a { _ =&gt; {} }</code> doesn't move <code>a</code> out is because it's an lvalue expression. Similarly, if <code>x: &amp;[String, 1000000]</code> then <code>match *x { _ =&gt; {} }</code> doesn't copy a million strings on the stack.</p>\n<blockquote>\n<p>The question is should *\"foo\" be a valid pattern for a branch of match a (delaying variables for a minute)</p>\n</blockquote>\n<p>Today that would cause a type error since <code>\"foo\"</code> has type <code>&amp;'static str</code>. This is a problem because we can't add more sigils to make that pattern have type <code>&amp;str</code>; it is at best a pattern of type <code>str</code> with default ref binding mode. That's why my suggestion is to just let string literals be used at type <code>str</code> too, although you still have to ref-bind them if you do something like <code>a @ \"foo\"</code>. The default binding mode trick should avoid having to say <code>ref a</code> explicitly in almost all cases though.</p>",
        "id": 245396331,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625801075
    },
    {
        "content": "<blockquote>\n<p>AIUI, if a: String, then in match a, a is not a place expression</p>\n</blockquote>\n<p>Whoops, I was being silly and misread the reference, of course a is  a place expression</p>",
        "id": 245396435,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1625801224
    },
    {
        "content": "<p>The issues with string literals not working at type <code>str</code> means that there isn't a pattern you can write in this match today to make it work:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"s\">\"foo\"</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"c1\">// note, we are matching on something of type str</span>\n<span class=\"w\">        </span><span class=\"s\">\"foo\"</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"c1\">// type error</span>\n<span class=\"w\">        </span><span class=\"o\">*</span><span class=\"s\">\"foo\"</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"c1\">// that's not a thing</span>\n<span class=\"w\">        </span><span class=\"k\">ref</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"fm\">matches!</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"foo\"</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"c1\">// okay fine</span>\n<span class=\"w\">        </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 245396720,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625801562
    },
    {
        "content": "<blockquote>\n<p>That's why my suggestion is to just let string literals be used at type str too, although you still have to ref-bind them if you do something like a @ \"foo\". The default binding mode trick should avoid having to say ref a explicitly in almost all cases though.</p>\n</blockquote>\n<p>I agree with this. My question is if we must make the borrow explicit in the scrutinee. And I think that comes down to the syntax, if we use <code>*</code> I think that it is OK, and the pattern should have type str, which we could allow literals to match. If using &amp; then I think we should require a borrowed type</p>",
        "id": 245396752,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1625801618
    },
    {
        "content": "<p>oh right, do we want people to have to write <code>&amp;mut &amp;mut &amp;mut (ref mut a)</code>? That is really icky</p>",
        "id": 245396809,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625801673
    },
    {
        "content": "<p>To match what?</p>",
        "id": 245396867,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1625801738
    },
    {
        "content": "<p>If we are using <code>&amp;</code> as the sigil then it seems like it implies that it is a shared reference. You can't use <code>&amp;x</code> to match on <code>&amp;mut Option&lt;T&gt;</code> after all</p>",
        "id": 245396923,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625801777
    },
    {
        "content": "<blockquote>\n<p>You can't use &amp;x to match on &amp;mut Option&lt;T&gt; after all</p>\n</blockquote>\n<p>IMO, this is a mistake and we could fix it as part of this work.</p>",
        "id": 245396959,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1625801830
    },
    {
        "content": "<p>and even if we say that you have to use <code>&amp;mut</code> for DerefMut patterns, what about DerefMove? <code>box</code> makes a comeback</p>",
        "id": 245397042,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625801916
    },
    {
        "content": "<p>Using <code>&amp;</code> as the sigil has the mental model that <code>&amp;</code> matches any pointer-like thing in a pattern</p>",
        "id": 245397051,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1625801926
    },
    {
        "content": "<p>I'm pretty okay with that. My main worry is about potential for ambiguity with other things that <code>&amp;</code> does in a pattern meaning that it doesn't do what you want and you don't have alternate syntax for the right thing</p>",
        "id": 245397098,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625801996
    },
    {
        "content": "<blockquote>\n<p>what about DerefMove? </p>\n</blockquote>\n<p>DerefMove would be used if the scrutinee has non-reference type and the pattern variable binds by move</p>",
        "id": 245397210,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1625802102
    },
    {
        "content": "<p>I meant under the assumption that different sigils are used for the different borrowing modes because pattern constructors mirror expr constructors</p>",
        "id": 245397301,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625802206
    },
    {
        "content": "<blockquote>\n<p>My main worry is about potential for ambiguity with other things that &amp; does in a pattern meaning that it doesn't do what you want and you don't have alternate syntax for the right thing</p>\n</blockquote>\n<p>Yeah, so I've thought about this a bit, but I'm pretty sure I haven't exhaustively covered the cases. The simple case is say an enum Foo with a Bar variant which also implements Deref, say to str.</p>\n<p>So assuming f: &amp;Foo, the following should be valid:</p>\n<div class=\"codehilite\"><pre><span></span><code>match f {\n    &amp;&quot;hello&quot; =&gt; {}\n    &amp;Foo::Bar =&gt; {}\n    _ =&gt; {}\n}\n</code></pre></div>\n<p>That seems OK ish since it is not ambiguous if taking types into account. If Foo derefs to itself, and you match &amp;Foo::Bar, then the compiler could either call deref or not, but it seems obvious that you wouldn't.</p>",
        "id": 245397493,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1625802417
    },
    {
        "content": "<blockquote>\n<p>I meant under the assumption that different sigils are used for the different borrowing modes because pattern constructors mirror expr constructors</p>\n</blockquote>\n<p>Right, I'm not a fan of that assumption because IMO the logical conclusion is that we should use something like *Rc and *Box and *String, etc, which is unergonomic and boilerplatey</p>",
        "id": 245397573,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1625802531
    },
    {
        "content": "<blockquote>\n<p>That seems OK ish since it is not ambiguous if taking types into account. If Foo derefs to itself, and you match &amp;Foo::Bar, then the compiler could either call deref or not, but it seems obvious that you wouldn't.</p>\n</blockquote>\n<p>To formalize this a bit, to make automatic deref coercions work (i.e. no syntax implicit deref), the rule would be something like: if the goal is <code>pat: T</code> and the pattern fails to typecheck at type <code>T</code>, then try <code>pat: U</code> instead (where, as ever, <code>T: Deref&lt;Target=U&gt;</code>). I'm not sure exactly how this works for deref coercions in expression position, failing to typecheck seems like a really problematic guard condition so there is probably something more constrained, but whatever they use there could also be used here</p>",
        "id": 245399052,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625803888
    },
    {
        "content": "<p>With that rule, you could remove most of the stars in the previous examples. In particular, <code>match (x: String) { \"foo\" =&gt; ... }</code> works, which makes me happy</p>",
        "id": 245399172,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625804021
    },
    {
        "content": "<blockquote>\n<p>If Foo derefs to itself</p>\n</blockquote>\n<p><span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"o\">&lt;</span><span class=\"n\">T</span>: <span class=\"nc\">Deref</span><span class=\"o\">&lt;</span><span class=\"n\">Target</span><span class=\"o\">=</span><span class=\"n\">T</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"nc\">T</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"kp\">&amp;</span><span class=\"kt\">u8</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">x</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// reached the recursion limit while auto-dereferencing `T`</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 245399335,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625804192
    },
    {
        "content": "<p>Are there any types that deref to themselves? It seems like you would often stumble into recursion limits like this. I'm going to say that this is evidence that you don't have to worry about that situation</p>",
        "id": 245399412,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625804302
    },
    {
        "content": "<blockquote>\n<p>I'm not sure exactly how this works for deref coercions in expression position, failing to typecheck seems like a really problematic guard condition so there is probably something more constrained</p>\n</blockquote>\n<p>I believe it is not quite failure to type check. Anywhere that coercion is allowed, there is always a known 'target' type, and the compiler attempts to unify the target type and the expression type. If that fails it will apply possible coercions and try to unify again. So it's failure to unify two types, rather than failing to type check an expression.</p>",
        "id": 245399463,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1625804372
    },
    {
        "content": "<blockquote>\n<p>Are there any types that deref to themselves?</p>\n</blockquote>\n<p>Not that I'm aware of</p>",
        "id": 245399532,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1625804419
    },
    {
        "content": "<p>I wonder if we could consider no-sigil syntax deref patterns as an extension of the match ergonomics rules? I.e., MER lets you match &amp;Foo as a Foo, then apply the binding mode rules. What if we simply extend that to letting you match T as a U if &lt;T as Deref&gt;::Target =U (plus treat string lits as str or &amp;str)? I think that is flexible and succinct. I wonder if it would look too magic?</p>",
        "id": 245400113,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1625805213
    },
    {
        "content": "<p>The binding mode would require the specific Deref trait, and would error if one wasn't present</p>",
        "id": 245400201,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1625805309
    },
    {
        "content": "<p>It feels like a much bigger change, and people will complain that match is getting even more magic, but honestly it feels in the right spirit - marking pointers in patterns is just boilerplate and we try hard elsewhere to eliminate the <code>&amp;**</code> kinds of type tetris programming</p>",
        "id": 245400411,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1625805562
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/281601-project-deref-patterns/topic/Deref.20Patterns.20Syntax/near/245394288\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>though OTOH, Rust is already in kind of a weird place with Deref ...</p>\n</blockquote>\n<p>I think this weirdness comes from conflating the deref coercion rules with applying Deref::deref. Looking somewhere without potential for coercion, * strictly converts &amp;T to &amp;&lt;T as Deref&gt;::Target.</p>\n</blockquote>\n<p>I don't believe this is the case, at least not syntactically- * doesn't operate on &amp;Ts but on Ts, and it converts to &lt;T as Deref&gt;::Target without the extra &amp;. <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=1cd347bd0f0516ab98d63fa71c60a4bf\">For example</a> given <code>s: String</code>, <code>*s: str</code>.</p>",
        "id": 245474202,
        "sender_full_name": "rpjohnst",
        "timestamp": 1625852568
    },
    {
        "content": "<p>or am i misreading your comment? i guess it works if you put the * inside the &amp;, so <code>&amp;s</code> + <code>*</code> = <code>&amp;*s</code> which is of type <code>&amp;str</code></p>",
        "id": 245474442,
        "sender_full_name": "rpjohnst",
        "timestamp": 1625852695
    },
    {
        "content": "<p>...skimming the rest of this, i do agree that no-sigil should match the default binding rules stuff! if you have an Rc&lt;Foo&gt; and you match it with a Foo pattern then it should behave the same as if you had a &amp;Foo, and implicitly deref + switch to ref mode for inner bindings</p>",
        "id": 245474909,
        "sender_full_name": "rpjohnst",
        "timestamp": 1625852811
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"117495\">rpjohnst</span> <a href=\"#narrow/stream/281601-project-deref-patterns/topic/Deref.20Patterns.20Syntax/near/245474909\">said</a>:</p>\n<blockquote>\n<p>...skimming the rest of this, i do agree that no-sigil should match the default binding rules stuff! if you have an Rc&lt;Foo&gt; and you match it with a Foo pattern then it should behave the same as if you had a &amp;Foo, and implicitly deref + switch to ref mode for inner bindings</p>\n</blockquote>\n<p>Hmm, seems ambiguous to me: should matching <code>Vec&lt;String&gt;</code> against <code>[a, b]</code> match as <code>a: &amp;String</code>, <code>a: &amp;mut String</code>, or, when <code>Vec&lt;T&gt;: DerefMove</code>, match as <code>a: String</code>?</p>",
        "id": 245482082,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1625856353
    },
    {
        "content": "<p>I think deciding the default <code>ref</code>/<code>ref mut</code> binding mode should only be done from actual references, having it change if <code>MyType</code> decides it now wants to also implement <code>DerefMut</code> seems like a bad idea.</p>",
        "id": 245482320,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1625856482
    },
    {
        "content": "<p>I'm not sure I would go that far, though this does seem to be hitting the same \"owned\"/Deref weirdness as before. I guess to be consistent with coercions in expressions (at the expense of no longer being consistent with references themselves) then it should match as <code>a: String</code>, and then use <code>ref</code>/<code>ref mut</code> mode if you are matching on a <code>&amp;Vec</code> or <code>&amp;mut Vec</code>.</p>\n<p>However, unlike expressions, you can't just insert a &amp; or &amp;mut to guide the coercion...</p>",
        "id": 245482958,
        "sender_full_name": "rpjohnst",
        "timestamp": 1625856808
    },
    {
        "content": "<blockquote>\n<p>I don't believe this is the case, at least not syntactically- * doesn't operate on &amp;Ts but on Ts, and it converts to &lt;T as Deref&gt;::Target without the extra &amp;. For example given s: String, *s: str.</p>\n</blockquote>\n<p>Yeah I think my explanation was terrible and at least a little wrong. <code>*x</code> expands to <code>*Deref::deref(&amp;x)</code> if <code>x</code> isn't a reference.</p>",
        "id": 245499550,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1625865021
    },
    {
        "content": "<blockquote>\n<p>Hmm, seems ambiguous to me: should matching Vec&lt;String&gt; against [a, b] match as a: &amp;String, a: &amp;mut String, or, when Vec&lt;T&gt;: DerefMove, match as a: String?</p>\n</blockquote>\n<p>I think this would follow the same rules as the match ergonomics binding modes, i.e., it depends on the structure of the type and how the matched variables are used</p>",
        "id": 245499908,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1625865127
    },
    {
        "content": "<p>One issue with the scheme I <a href=\"#narrow/stream/281601-project-deref-patterns/topic/Deref.20Patterns.20Syntax/near/245388290\">mentioned</a> earlier for determining the binding mode through a deref is that it means that matching vectors uses ref mut binding mode, so you get this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">vec</span>: <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"nb\">String</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">[</span><span class=\"n\">a</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"c1\">// a: &amp;mut String</span>\n<span class=\"w\">    </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>This is okay I guess, it makes sense from the signature of the deref impl, but importantly it is future incompatible with adding DerefMove to <code>Vec&lt;T&gt;</code>, since then <code>a</code> would get type <code>a: String</code> and any code that assumes it's a reference would break (and the match would also start consuming the vec which could also break subsequent uses). I would like this to only happen when there has been some positive indication that a DerefMut/DerefMove impl will not be added later.</p>",
        "id": 245509935,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625868263
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/281601-project-deref-patterns/topic/Deref.20Patterns.20Syntax/near/245499908\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>Hmm, seems ambiguous to me: should matching Vec&lt;String&gt; against [a, b] match as a: &amp;String, a: &amp;mut String, or, when Vec&lt;T&gt;: DerefMove, match as a: String?</p>\n</blockquote>\n<p>I think this would follow the same rules as the match ergonomics binding modes, i.e., it depends on the structure of the type and how the matched variables are used</p>\n</blockquote>\n<p>sounds good as long as the matching doesn't decide which mode to use based on if types implement <code>DerefMut</code> or <code>DerefMove</code>. erroring after deciding which mode to use due to a missing impl is fine, just don't change type deduction based on a type deciding to also impl <code>DerefMut</code> or <code>DerefMove</code></p>",
        "id": 245510460,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1625868453
    },
    {
        "content": "<p>I think now that use of the deref operator in a pattern, implicitly or explicitly, should <em>not</em> change the default binding mode. Instead you just get an error if you try to move through a Deref/DerefMut or ref-mut bind through a Deref. That will produce much saner errors, and give people the tools to do something about the binding mode change. You will still get default ref binding mode if you match on a reference, so the same trick as today will work in the presence of deref patterns.</p>",
        "id": 245511091,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625868693
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">vec</span>: <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"nb\">String</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"o\">*</span><span class=\"p\">[</span><span class=\"n\">a</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"c1\">// a: String, move error</span>\n<span class=\"w\">  </span><span class=\"o\">*</span><span class=\"p\">[</span><span class=\"k\">ref</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"c1\">// a: &amp;String, okay</span>\n<span class=\"w\">  </span><span class=\"p\">[</span><span class=\"n\">a</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"c1\">// a: String, move error</span>\n<span class=\"w\">  </span><span class=\"p\">[</span><span class=\"o\">*</span><span class=\"n\">a</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"c1\">// a: str, unsized local</span>\n<span class=\"w\">  </span><span class=\"p\">[</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"k\">ref</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">)]</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"c1\">// a: &amp;str, okay</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">match</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">vecref</span>: <span class=\"kp\">&amp;</span><span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"nb\">String</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"o\">&amp;*</span><span class=\"p\">[</span><span class=\"n\">a</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"c1\">// a: String, move error</span>\n<span class=\"w\">  </span><span class=\"o\">&amp;</span><span class=\"p\">[</span><span class=\"n\">a</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"c1\">// a: String, move error</span>\n<span class=\"w\">  </span><span class=\"p\">[</span><span class=\"n\">a</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"c1\">// a: &amp;String, okay</span>\n<span class=\"w\">  </span><span class=\"p\">[</span><span class=\"o\">*</span><span class=\"n\">a</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"c1\">// a: &amp;str, okay</span>\n<span class=\"w\">  </span><span class=\"p\">[</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"k\">ref</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">)]</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"c1\">// a: &amp;str, same thing</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 245511348,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625868788
    },
    {
        "content": "<p>Note that using <code>*pat</code> on the <code>&amp;Vec&lt;String&gt;</code> will check <code>pat</code> at <code>Vec&lt;String&gt;</code> without a binding mode change, which is exactly what <code>&amp;pat</code> would do in the same context, so this does give some evidence that maybe we don't need two operators for this and can reuse <code>&amp;</code> for deref</p>",
        "id": 245512308,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625869124
    }
]