[
    {
        "content": "<p>I would like to start the discussion about supported stdlib types for deref patterns.<br>\nThis needs two lists, a list of requirements for stdlib types to satisfy, and a list of standard library types that do satisfy these requirements.</p>\n<p>For the first list, in order to be sound, the deref implementation (and deref_mut) needs to be idempotent. Does it also need to be completely pure (IE., no calls to user-provided code whatsoever), or can we accept a single initial non-pure operation. If the former is the case, then this will disqualify <code>Lazy</code> and <code>SyncLazy</code> from deref patterns, as they are designed to call a user-provided function they first time they are dereferenced. Also, what exactly does idempotent mean, and what operations would reset it?</p>",
        "id": 229667642,
        "sender_full_name": "Connor Horman",
        "timestamp": 1615386163
    },
    {
        "content": "<p>For the second list, it may be reasonable to accept most of the types in the Standard Library that <code>Deref</code>s. The definate exception would be <code>Pin</code>, which can and should participate only if it's type parameter is a participating type. Other possible exceptions are <code>Lazy</code> and <code>SyncLazy</code> due to the fact that they may be initially impure, <code>Cow</code> and <code>AssertUnwindSafe</code>, since these can also be destructured (which is another interesting question), and <code>VaList</code>, which I would argue is useless for DerefPatterns, since you can't really structurally-match <code>VaListImpl</code>. <br>\nFor the record, the current exhaustive (I believe, please let me know if I'm missing any) list of potential candidates (from <a href=\"https://doc.rust-lang.org/nightly/std/ops/trait.Deref.html#implementors\">https://doc.rust-lang.org/nightly/std/ops/trait.Deref.html#implementors</a>), can be categorized as follows:</p>\n<ul>\n<li>Language Reference Types:<code>&amp;T</code> and <code>&amp;mut T</code>.</li>\n<li>Smart Pointer Types: <code>Box&lt;T&gt;</code>, <code>Arc&lt;T&gt;</code>, <code>Rc&lt;T&gt;</code></li>\n<li>Growable Slice Collections: <code>Vec&lt;T&gt;</code>, <code>String</code>, <code>CString</code>, <code>OsString</code>, and <code>PathBuf</code></li>\n<li>Smart Reference Guards: <code>Ref&lt;T&gt;</code>, <code>RefMut&lt;T&gt;</code>, <code>MutexGuard&lt;T&gt;</code>, <code>RwLockReadGuard&lt;T&gt;</code>, <code>RwLockWriteGuard&lt;T&gt;</code></li>\n<li>Pin: <code>Pin&lt;P&gt;</code>, if <code>P</code> is a candidate.</li>\n<li>Newtype Wrappers: <code>ManuallyDrop&lt;T&gt;</code>, <code>AssertUnwindSafe&lt;T&gt;</code> (but see note about <code>AssertUnwindSafe&lt;T&gt;</code>)</li>\n<li>Lazy Initialization Wrapers: <code>Lazy&lt;T,F&gt;</code>, <code>SyncLazy&lt;T,F&gt;</code></li>\n<li>Misc: <code>IOSlice</code>, <code>IOSliceMut</code>, <code>VaList</code>, <code>Cow&lt;B&gt;</code>, <code>PeekMut</code></li>\n</ul>",
        "id": 229669095,
        "sender_full_name": "Connor Horman",
        "timestamp": 1615386607
    },
    {
        "content": "<p>In my opinion, the minimum I would want would be the Smart Pointer Types, <code>String</code>, and <code>Pin&lt;P&gt;</code> of such a type and of <code>&amp;T</code> and <code>&amp;mut T</code>. <br>\nThe language reference types can probably be excluded until support for user-defined types is being considered (since presumably they would fall under reference patterns), though if we use a different syntax for deref patterns, it could be reasonable to allow them (it would also keep implementation options open, and not require the implementation to special-special case <code>Pin&lt;&amp;T&gt;</code> or <code>Pin&lt;&amp;mut T&gt;</code> for these).</p>",
        "id": 229670051,
        "sender_full_name": "Connor Horman",
        "timestamp": 1615386887
    },
    {
        "content": "<p>I thought that <code>Lazy</code> and <code>SyncLazy</code> aren't eligible since they can panic, and not <code>Cow</code> since it can clone</p>",
        "id": 229673236,
        "sender_full_name": "oliver",
        "timestamp": 1615387895
    },
    {
        "content": "<p>Match arms can already panic in the if-guard</p>",
        "id": 229673473,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1615387980
    },
    {
        "content": "<p>I don't see what Cow being clonable has to do with it, it doesn't clone in the Deref impl</p>",
        "id": 229673579,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1615388006
    },
    {
        "content": "<p>if it's a user-defined clone function</p>",
        "id": 229673618,
        "sender_full_name": "oliver",
        "timestamp": 1615388030
    },
    {
        "content": "<p>oh I see that Cow can qualify for deref patterns, provided a DerefMut impl is not added</p>",
        "id": 229673889,
        "sender_full_name": "oliver",
        "timestamp": 1615388114
    },
    {
        "content": "<p><a href=\"https://hackmd.io/GBTt4ptjTh219SBhDCPO4A#Possible-solutions\">https://hackmd.io/GBTt4ptjTh219SBhDCPO4A#Possible-solutions</a></p>",
        "id": 229673920,
        "sender_full_name": "oliver",
        "timestamp": 1615388124
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281739\">oliver</span> <a href=\"#narrow/stream/281601-project-deref-patterns/topic/Deref.20Patterns.2C.20.20stdlib.20type.20list/near/229673236\">said</a>:</p>\n<blockquote>\n<p>I thought that <code>Lazy</code> and <code>SyncLazy</code> aren't eligible since they can panic, and not <code>Cow</code> since it can clone</p>\n</blockquote>\n<p>The potential issue with <code>Lazy</code> and <code>SyncLazy</code> is the fact they are impure the first time they are deferenced. </p>\n<p>The issue with <code>Cow</code> is the fact it can also be destructured, and if we supported it, we'd have to decide how to deal with mixing both deref and structural matches.</p>",
        "id": 229687978,
        "sender_full_name": "Connor Horman",
        "timestamp": 1615391973
    },
    {
        "content": "<p>(The issue with <code>Cow</code> is also shared with <code>AssertUnwindSafe</code>)</p>",
        "id": 229688047,
        "sender_full_name": "Connor Horman",
        "timestamp": 1615391996
    },
    {
        "content": "<blockquote>\n<p>The potential issue with Lazy and SyncLazy is the fact they are impure the first time they are deferenced.</p>\n</blockquote>\n<p>Is there a concrete example of how this could go wrong? The idempotency here seems pretty solid. Furthermore, assuming Lazy makes it into std, there would be no need to generalize this sort of \"you can be impure once\" exception to user-defined smart pointers, at least not at first. (I understand the desire to not let std \"cheat\" by doing things that user code can't do, but there's plenty of precedence (<code>TrustedFoo</code> traits), and furthermore Lazy seems like the only idempotent pointer of this kind that anybody would ever want to make?)</p>",
        "id": 229708111,
        "sender_full_name": "bstrie",
        "timestamp": 1615397531
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256342\">bstrie</span> <a href=\"#narrow/stream/281601-project-deref-patterns/topic/Deref.20Patterns.2C.20.20stdlib.20type.20list/near/229708111\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>The potential issue with Lazy and SyncLazy is the fact they are impure the first time they are deferenced.</p>\n</blockquote>\n<p>Is there a concrete example of how this could go wrong? The idempotency here seems pretty solid. Furthermore, assuming Lazy makes it into std, there would be no need to generalize this sort of \"you can be impure once\" exception to user-defined smart pointers, at least not at first. (I understand the desire to not let std \"cheat\" by doing things that user code can't do, but there's plenty of precedence (<code>TrustedFoo</code> traits), and furthermore Lazy seems like the only idempotent pointer of this kind that anybody would ever want to make?)</p>\n</blockquote>\n<p>One of the reasons that only stdlib types are being persued is because lang-team doesn't necessarily want to introduce impure operations in pattern matching, yet &lt;<a href=\"https://github.com/rust-lang/lang-team/pull/78#issuecomment-780631891\">https://github.com/rust-lang/lang-team/pull/78#issuecomment-780631891</a>&gt;.<br>\nPerhaps it is reasonable to special case <code>Lazy</code> and <code>SyncLazy</code>, but it also may not be; if we want an answer to that, we'd need to ask T-lang, probably at a design meeting in the future.</p>",
        "id": 229713105,
        "sender_full_name": "Connor Horman",
        "timestamp": 1615399291
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> I was in the meeting that summary came from. I think for both that meeting and that summary, we weren't thinking about types like <code>Lazy</code>, so we were equating \"not pure\" with \"potentially not idempotent\". A type like <code>Lazy</code> that runs user code <em>once</em> but then never again, and provides idempotence atop that, seems potentially reasonable.</p>",
        "id": 229730032,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615405460
    },
    {
        "content": "<p>It's possible that some members of the team may object to code running at pattern-match time for other reasons, but I'm not aware of those reasons.</p>",
        "id": 229730182,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615405528
    },
    {
        "content": "<p>Yeah, it's possible that \"stable\" would be a better word than \"pure\", like how it's used in <a href=\"http://kimundi.github.io/owning-ref-rs/owning_ref/trait.CloneStableAddress.html\">http://kimundi.github.io/owning-ref-rs/owning_ref/trait.CloneStableAddress.html</a></p>",
        "id": 229740780,
        "sender_full_name": "scottmcm",
        "timestamp": 1615409067
    },
    {
        "content": "<p>The one thing that comes to mind for purity is if idempotency is still observable</p>",
        "id": 229740865,
        "sender_full_name": "scottmcm",
        "timestamp": 1615409105
    },
    {
        "content": "<p>Like whether <code>{ A(x) if foo(x) =&gt; ..., A(deref x) =&gt; ... }</code> is allowed to potentially call deref even if the foo predicate is true.</p>",
        "id": 229741101,
        "sender_full_name": "scottmcm",
        "timestamp": 1615409185
    },
    {
        "content": "<p>(But I haven't thought through whether that'd be concerning, nor whether it'd be an implementation concern.)</p>",
        "id": 229741196,
        "sender_full_name": "scottmcm",
        "timestamp": 1615409229
    },
    {
        "content": "<p>I thought match arms were guaranteed to be tried in order? Since the difference is observable due to if-guards?</p>",
        "id": 229744982,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1615410528
    },
    {
        "content": "<p>Only the <code>if</code> bits need to be in order, though -- it could load all the discriminants and such eagerly today, then do the guard predicates.</p>\n<p>(I don't know if the implementation actually takes advantage of that flexibility, though)</p>",
        "id": 229760217,
        "sender_full_name": "scottmcm",
        "timestamp": 1615415926
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/281601-project-deref-patterns/topic/Deref.20Patterns.2C.20.20stdlib.20type.20list/near/229730032\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> I was in the meeting that summary came from. I think for both that meeting and that summary, we weren't thinking about types like <code>Lazy</code>, so we were equating \"not pure\" with \"potentially not idempotent\". A type like <code>Lazy</code> that runs user code <em>once</em> but then never again, and provides idempotence atop that, seems potentially reasonable.</p>\n</blockquote>\n<p>Makes sense. So then it wouldn't have an issue from a T-lang perspective? <br>\nI still wouldn't necessarily put it on the \"No issues at all\" list, because even being initially impure could cause issues, and limit certain optimizations.</p>",
        "id": 229760270,
        "sender_full_name": "Connor Horman",
        "timestamp": 1615415961
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/281601-project-deref-patterns/topic/Deref.20Patterns.2C.20.20stdlib.20type.20list/near/229760217\">said</a>:</p>\n<blockquote>\n<p>Only the <code>if</code> bits need to be in order, though -- it could load all the discriminants and such eagerly today, then do the guard predicates.</p>\n<p>(I don't know if the implementation actually takes advantage of that flexibility, though)</p>\n</blockquote>\n<p>It could. Another optimization that's been comtemplated was reducing the number of deref calls (in theory, you could reduce it to merely 0 or 1 deref calls, and some number of deref_mut calls).</p>",
        "id": 229761492,
        "sender_full_name": "Connor Horman",
        "timestamp": 1615416558
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> We'd appreciate an assessment of potential practical issues; I'm just suggesting that we're not against it on principle.</p>",
        "id": 229794959,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615439242
    },
    {
        "content": "<p>I would also add that I think it would be completely reasonable to pick 1-2 \"easy\" types, document the restrictions required for the initial design (and ideally how they're compatible with extensions, but this mostly is just to make sure we're not boxing ourselves in unintentionally) - I don't think the initial rfc needs to specify an exhaustive list, though having a set of criteria that can be applied to an arbitrary type may be useful.</p>\n<p>For example, I might exclude those types that have user defined code completely for now, and just restrict ourselves to Arc/Rc/Box/String, for example, which all feel much simpler to design a system for over, for example, Lazy.</p>",
        "id": 229840018,
        "sender_full_name": "simulacrum",
        "timestamp": 1615465679
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/281601-project-deref-patterns/topic/Deref.20Patterns.2C.20.20stdlib.20type.20list/near/229794959\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> We'd appreciate an assessment of potential practical issues; I'm just suggesting that we're not against it on principle.</p>\n</blockquote>\n<p>Indeed. And if the project does end up considering it's viability, presumably we'd have an assesment to present, regardless of whether or not it is proposed to be included or not.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/281601-project-deref-patterns/topic/Deref.20Patterns.2C.20.20stdlib.20type.20list/near/229840018\">said</a>:</p>\n<blockquote>\n<p>I would also add that I think it would be completely reasonable to pick 1-2 \"easy\" types, document the restrictions required for the initial design (and ideally how they're compatible with extensions, but this mostly is just to make sure we're not boxing ourselves in unintentionally) - I don't think the initial rfc needs to specify an exhaustive list, though having a set of criteria that can be applied to an arbitrary type may be useful.</p>\n<p>For example, I might exclude those types that have user defined code completely for now, and just restrict ourselves to Arc/Rc/Box/String, for example, which all feel much simpler to design a system for over, for example, Lazy.</p>\n</blockquote>\n<p>That is an option, and a potentially reasonable one. And even if we don't necessarily limit it to that extent, the project could potentially even avoid consideration of <code>Lazy</code> at this time on the basis of it being unstable (dependant on any known timelines for it's stablization).</p>",
        "id": 230036511,
        "sender_full_name": "Connor Horman",
        "timestamp": 1615559039
    },
    {
        "content": "<p>In any case, it may be a good idea to decide whether we want to set the types first, then work out the requirements; set the requirements, then work out viable types; or some combination (such as deciding on a set of \"must support\" types, working out requirements that don't exclude those, then deciding the rest of the types).</p>",
        "id": 230036940,
        "sender_full_name": "Connor Horman",
        "timestamp": 1615559180
    },
    {
        "content": "<p>For the unstable version, why not just support the widest conveniently-supportable set of types? For example everything with a deref impl. This whitelist approach makes sense for the stable version but for unstable it seems like having the feature implemented so people can play with it is more important than restricting it where we aren't sure about what we want the semantics to be</p>",
        "id": 230045086,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615562105
    },
    {
        "content": "<p>(If on the other hand for some reason it's easier to support a small list of types rather than all types satisfying some trait or set of constraints, then a whitelist would make sense since it's just an MVP anyway)</p>",
        "id": 230045541,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615562252
    },
    {
        "content": "<p>If you are referring to all types with a deref impl in the standard library, that might be a good way forward. Evaluate the requirements in the wild rather than through theoretical analysis.<br>\nIf you are referring to all types period, then T-lang has expressed that they do <em>not</em> want to persue that at this time with this project (see relevant discussion on the charter pr, &lt;<a href=\"https://github.com/rust-lang/lang-team/pull/78\">https://github.com/rust-lang/lang-team/pull/78</a>&gt;). <br>\nOne of the primary issues is that, if deref patterns are treated as exhaustive, then an impure deref impl can be unsound, as you can write a safe implementation of <code>Deref</code> that returns a different value each time, and that misses the match arms.</p>",
        "id": 230073476,
        "sender_full_name": "Connor Horman",
        "timestamp": 1615572429
    },
    {
        "content": "<p>Well I doubt such a thing would be accepted by the compiler anyway, because it has to be desugared somehow</p>",
        "id": 230074217,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615572775
    },
    {
        "content": "<p>At the implementation level, it is now a question of whether the desugaring attempts to deduplicate deref calls or not.</p>\n<ol>\n<li>If we do deduplicate deref calls, then it has a chance to support exhaustive matching without any regard for idempotence of deref, although that might make it easier to explain to folks for the stable version.</li>\n<li>If not, then there is the question of what to do with the leftover matches; if you use an <code>unreachable_unchecked</code> there then yes that is a soundness concern, for user types but also for things like <code>Arc</code>, where we are now relying on a very particular property about the deref call and its interaction with other code that is not represented in any <code>unsafe</code> block.</li>\n<li>If you use a <code>panic!(\"match failed\")</code>, then it should be memory safe, and this is probably the easiest thing to implement, although people will definitely want control over what happens in this branch eventually.</li>\n</ol>",
        "id": 230075683,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615573470
    },
    {
        "content": "<p>From <a href=\"https://github.com/rust-lang/lang-team/pull/78#issuecomment-780631891\">https://github.com/rust-lang/lang-team/pull/78#issuecomment-780631891</a> it looks like the idea is to do (2), with the soundness issue being resolved by the whitelist, or possibly <code>DerefPure</code>. Although it looks like <code>DerefPure</code> is being deferred, I think that it makes the design of <code>DerefPure</code> somewhat easy: <code>DerefPure</code> is an unsafe marker trait whose safety condition is \"everything needed for the implementation of (2) to be sound\", which boils down to some kind of idempotence.</p>",
        "id": 230076855,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615573988
    },
    {
        "content": "<p>Wrt. (1), that is something I'd like to enable, but not necessarily required for exhaustiveness as it's impossible to totally deduplicate it, see this code</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ManuallyDrop</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"p\">.</span><span class=\"n\">is_none</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">&amp;</span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>That requires 2 deref calls, (three if you count the if guard).</p>\n<p>I'd also argue that deref patterns aren't really syntax sugar over an existing construct; they could be closely approximated with, but not actually desugared to, if let guards. <br>\nOtherwise, you are right, DerefPure would need to restrict implementors to what makes (2) sound, and possibly more to allow the freedom to deduplicate deref calls. However, as this project is not pursuing  DerefPure, this is somewhat moot (though partially relevant to constructing a set of rules for stdlib types.</p>",
        "id": 230237550,
        "sender_full_name": "Connor Horman",
        "timestamp": 1615727461
    },
    {
        "content": "<blockquote>\n<p>In my opinion, the minimum I would want would be the Smart Pointer Types, String, and Pin&lt;P&gt; of such a type and of &amp;T and &amp;mut T.</p>\n</blockquote>\n<p>IMO <code>Vec&lt;T&gt;</code> to <code>[T]</code> is also one of the very important ones.</p>",
        "id": 230418133,
        "sender_full_name": "Dirkjan Ochtman",
        "timestamp": 1615842266
    },
    {
        "content": "<p>Ah, right, slice patterns work, don't they?</p>",
        "id": 230419515,
        "sender_full_name": "Connor Horman",
        "timestamp": 1615842803
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/281601-project-deref-patterns/topic/Deref.20Patterns.2C.20.20stdlib.20type.20list/near/230237550\">said</a>:</p>\n<blockquote>\n<p>Wrt. (1), that is something I'd like to enable, but not necessarily required for exhaustiveness as it's impossible to totally deduplicate it, see this code</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ManuallyDrop</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"p\">.</span><span class=\"n\">is_none</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">&amp;</span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>That requires 2 deref calls, (three if you count the if guard).</p>\n<p>I'd also argue that deref patterns aren't really syntax sugar over an existing construct; they could be closely approximated with, but not actually desugared to, if let guards. <br>\nOtherwise, you are right, DerefPure would need to restrict implementors to what makes (2) sound, and possibly more to allow the freedom to deduplicate deref calls. However, as this project is not pursuing  DerefPure, this is somewhat moot (though partially relevant to constructing a set of rules for stdlib types.</p>\n</blockquote>\n<p>Why would this need more than one deref_mut call?</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ManuallyDrop</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">deref_mut</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"p\">.</span><span class=\"n\">is_none</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;*</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 230503503,
        "sender_full_name": "Plecra",
        "timestamp": 1615897888
    },
    {
        "content": "<p>This confused me in the tracking document too </p>\n<blockquote>\n<p>this case could be implemented as a single deref_mut, then reborrowing. However, this would not work in a case like this:</p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">deref</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">@</span><span class=\"mi\">0</span><span class=\"o\">..</span><span class=\"mi\">3</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.,</span><span class=\"w\"> </span><span class=\"c1\">// (1)</span>\n<span class=\"w\">    </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">deref</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">@</span><span class=\"mi\">4</span><span class=\"o\">..</span><span class=\"mi\">7</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.,</span><span class=\"w\"> </span><span class=\"c1\">// (2)</span>\n<span class=\"w\">    </span><span class=\"n\">v</span><span class=\"o\">@&amp;</span><span class=\"nb\">None</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.,</span><span class=\"w\"> </span><span class=\"c1\">// (3)</span>\n<span class=\"w\">    </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">deref</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">@</span><span class=\"mi\">8</span><span class=\"o\">..</span><span class=\"mi\">11</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.,</span><span class=\"w\"> </span><span class=\"c1\">// (4)</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Why wouldn't this just be </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"p\">.</span><span class=\"n\">deref_mut</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">@</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">..=</span><span class=\"mi\">3</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{},</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">@</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">..=</span><span class=\"mi\">7</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{},</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">@</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{},</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">@</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"o\">..=</span><span class=\"mi\">11</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{},</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">_</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"c1\">// the original code wasn't exhaustive</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 230504349,
        "sender_full_name": "Plecra",
        "timestamp": 1615898296
    },
    {
        "content": "<p>It seems to me like deref deduplication is easily the best option as long as its viable, so I'm probably missing something important...</p>",
        "id": 230504874,
        "sender_full_name": "Plecra",
        "timestamp": 1615898577
    },
    {
        "content": "<p>This playground demonstrates how I'd expect the examples I've seen so far to work: <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=2f5218def15c680a87d5513121befaf7\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=2f5218def15c680a87d5513121befaf7</a></p>\n<p>They're all simple desugarings to existing Rust code that's already exhaustive</p>",
        "id": 230509143,
        "sender_full_name": "Plecra",
        "timestamp": 1615900437
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"263805\">Plecra</span> <a href=\"#narrow/stream/281601-project-deref-patterns/topic/Deref.20Patterns.2C.20.20stdlib.20type.20list/near/230504349\">said</a>:</p>\n<blockquote>\n<p>This confused me in the tracking document too </p>\n<blockquote>\n<p>this case could be implemented as a single deref_mut, then reborrowing. However, this would not work in a case like this:</p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">deref</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">@</span><span class=\"mi\">0</span><span class=\"o\">..</span><span class=\"mi\">3</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.,</span><span class=\"w\"> </span><span class=\"c1\">// (1)</span>\n<span class=\"w\">    </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">deref</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">@</span><span class=\"mi\">4</span><span class=\"o\">..</span><span class=\"mi\">7</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.,</span><span class=\"w\"> </span><span class=\"c1\">// (2)</span>\n<span class=\"w\">    </span><span class=\"n\">v</span><span class=\"o\">@&amp;</span><span class=\"nb\">None</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.,</span><span class=\"w\"> </span><span class=\"c1\">// (3)</span>\n<span class=\"w\">    </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">deref</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">@</span><span class=\"mi\">8</span><span class=\"o\">..</span><span class=\"mi\">11</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.,</span><span class=\"w\"> </span><span class=\"c1\">// (4)</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Why wouldn't this just be </p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"p\">.</span><span class=\"n\">deref_mut</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">@</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">..=</span><span class=\"mi\">3</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{},</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">@</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">..=</span><span class=\"mi\">7</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{},</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">@</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{},</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">@</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"o\">..=</span><span class=\"mi\">11</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{},</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">_</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"c1\">// the original code wasn't exhaustive</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>The deref type is inside the <code>Option</code> (this can be shown easily by the fact that the <code>deref</code> is indicated inside of <code>Some</code>). <br>\nThe reason why the <code>deref_mut</code> can't be preemptively used and kept arround for the remaining match arms, is because <code>v@None</code> requires matching the option, thus borrowing it. <br>\nThis has a number of issues, but primarily, if <code>deref_mut</code> returns an interior pointer (such as the implementation for <code>ManuallyDrop</code> or <code>AssertUnwindSafe</code>), according to Stacked Borrows, the Shared borrow of the Option would invalidate the mutable borrow of that interior pointer (and any pointers derived therefrom). While Stacked Borrows is not normative at this time, my preference would be that Deref Patterns not undermine it. Your desguaring would be correct if the <code>Option</code> was inside the Deref Type (IE. <code>Box&lt;Option&gt;</code> rather than <code>Option&lt;Box&gt;</code>).</p>",
        "id": 230512238,
        "sender_full_name": "Connor Horman",
        "timestamp": 1615901674
    },
    {
        "content": "<p>Haha, yea I did stumble a bit with grokking that example - the example I gave in the playground with the types the right way around looked like this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">core</span>::<span class=\"n\">mem</span>::<span class=\"n\">ManuallyDrop</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"k\">match</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">ptr</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"p\">.</span><span class=\"n\">deref_mut</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">@</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"o\">..=</span><span class=\"mi\">3</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;*</span><span class=\"n\">v</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">@</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"mi\">4</span><span class=\"o\">..=</span><span class=\"mi\">7</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">@</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"mi\">8</span><span class=\"o\">..=</span><span class=\"mi\">11</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;*</span><span class=\"n\">v</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">},</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">@</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;*</span><span class=\"n\">v</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 230512827,
        "sender_full_name": "Plecra",
        "timestamp": 1615901919
    },
    {
        "content": "<p>(which again, compiles now)</p>",
        "id": 230512841,
        "sender_full_name": "Plecra",
        "timestamp": 1615901926
    },
    {
        "content": "<p>And this does logically reorder the match, which I've been thinking through the consequences of</p>",
        "id": 230512924,
        "sender_full_name": "Plecra",
        "timestamp": 1615901966
    },
    {
        "content": "<p>The issue is that you've now changed the order of the match arms (which matters if the arm has an if guard).</p>",
        "id": 230512931,
        "sender_full_name": "Connor Horman",
        "timestamp": 1615901972
    },
    {
        "content": "<p>Would you mind giving an example of when it would change the behaviour of a guard?</p>",
        "id": 230513061,
        "sender_full_name": "Plecra",
        "timestamp": 1615902007
    },
    {
        "content": "<p>I've been trying to come up with one and my minds blank :P</p>",
        "id": 230513099,
        "sender_full_name": "Plecra",
        "timestamp": 1615902019
    },
    {
        "content": "<p>afaict, the branches that this would \"reorder\" would be unreachable anyway</p>",
        "id": 230513220,
        "sender_full_name": "Plecra",
        "timestamp": 1615902072
    },
    {
        "content": "<p><code>if</code> guards can have side effects. This particular example wouldn't work, but it's trivial to come up with a case for something like Cow, which can both the dereferenced and destructured.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">check_and_print</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"n\">y</span>: <span class=\"kt\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">bool</span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{}\"</span><span class=\"p\">,</span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Cow</span>::<span class=\"n\">Owned</span><span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"k\">match</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">@</span><span class=\"w\"> </span><span class=\"n\">deref</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">..</span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{} in [0,5)\"</span><span class=\"p\">,</span><span class=\"n\">x</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Cow</span>::<span class=\"n\">Owned</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">check_and_print</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"Owned {}&lt;5\"</span><span class=\"p\">,</span><span class=\"n\">x</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">deref</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">check_and_print</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"mi\">7</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{} in [5,10)\"</span><span class=\"p\">,</span><span class=\"n\">x</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"Something else\"</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 230513772,
        "sender_full_name": "Connor Horman",
        "timestamp": 1615902292
    },
    {
        "content": "<p>You can't reorder any of those patterns without potentially changing either the side effects in the if guards, or the outcome of the match.</p>",
        "id": 230514050,
        "sender_full_name": "Connor Horman",
        "timestamp": 1615902385
    },
    {
        "content": "<p>(Though actually, you can't <code>deref_mut</code> <code>Cow</code>, but the same argument applies in inverse, since the <code>Cow::Owned</code> pattern mutably borrows <code>x</code> and thus reborrows the entire <code>Cow</code> as mutable, potentially invalidating the <code>deref</code> calls).</p>",
        "id": 230514464,
        "sender_full_name": "Connor Horman",
        "timestamp": 1615902542
    },
    {
        "content": "<p>So does that mean this only applies to enums that we want to destructure and deref in the same match?</p>",
        "id": 230515300,
        "sender_full_name": "Plecra",
        "timestamp": 1615902892
    },
    {
        "content": "<p>hm.. no I don't think so</p>",
        "id": 230515699,
        "sender_full_name": "Plecra",
        "timestamp": 1615903040
    },
    {
        "content": "<p>this affects all simpler situations where you want to call a method on the pointer type too</p>",
        "id": 230515762,
        "sender_full_name": "Plecra",
        "timestamp": 1615903072
    },
    {
        "content": "<p>Thanks :) That really helps</p>",
        "id": 230515825,
        "sender_full_name": "Plecra",
        "timestamp": 1615903087
    },
    {
        "content": "<p>Indeed, as well as cases where you could dereference two embedded things. <code>Result&lt;impl Deref,impl Deref&gt;</code> comes to mind.</p>",
        "id": 230515929,
        "sender_full_name": "Connor Horman",
        "timestamp": 1615903133
    },
    {
        "content": "<p>I wonder if it'd be worth permitting cases where rustc can implement it with a single <code>deref_mut</code> so as to make the common AST matching cases simple</p>",
        "id": 230516302,
        "sender_full_name": "Plecra",
        "timestamp": 1615903260
    },
    {
        "content": "<p>It'd also be great to have a \"realistic\" example of when this limitation with multiple dereferences would actually apply for the motivation section of the RFC</p>",
        "id": 230516440,
        "sender_full_name": "Plecra",
        "timestamp": 1615903320
    },
    {
        "content": "<p>That seems incredibly limiting, though I can't come up with any specific examples that would be used in the real world.</p>\n<p>In any case, the \"single <code>deref_mut</code>\" restriction shouldn't even be necessary, as (with the exception of <code>Lazy</code> and <code>SyncLazy</code>, which are idempotent), all of the types under consideration for this project are known to have only completely pure (no side effects) deref and deref_mut implementations, so the compiler can insert and remove as many as it wants without changing the behaviour (and while maintaining the exhaustiveness rule).</p>",
        "id": 230517704,
        "sender_full_name": "Connor Horman",
        "timestamp": 1615903735
    },
    {
        "content": "<p>for sure! and I do think it falls under future considerations, but it'd be nice to leave the door open to a safe API for user-defined derefs</p>",
        "id": 230518105,
        "sender_full_name": "Plecra",
        "timestamp": 1615903871
    },
    {
        "content": "<p>and this seems like a pretty widely-useful subset that could be used safely</p>",
        "id": 230518149,
        "sender_full_name": "Plecra",
        "timestamp": 1615903891
    },
    {
        "content": "<p>Indeed, and that may be an additional route to persue for user-defined derefs (though by \"single <code>deref_mut</code> call\" I assume you are also including cases that can be implemented using a single <code>deref</code> call), though this project is not doing so, as mentioned.</p>",
        "id": 230518374,
        "sender_full_name": "Connor Horman",
        "timestamp": 1615903964
    },
    {
        "content": "<p>^^ thanks for your time</p>",
        "id": 230518426,
        "sender_full_name": "Plecra",
        "timestamp": 1615903986
    },
    {
        "content": "<p>Alright, so we should consider a plan.<br>\nI think that we should start with a reduced set, probably, <code>Box</code>, <code>Rc, </code>Arc<code>, </code>String<code>, </code>Vec<code>, and </code>Pin`s of them, and then implement that behind a feature gate (once we have syntax resolved, or at least a decent idea of how we'd do the syntax). <br>\nDoes this seem like a reasonable plan for now?</p>",
        "id": 231109112,
        "sender_full_name": "Connor Horman",
        "timestamp": 1616201003
    }
]