[
    {
        "content": "<p>We make a distinction between MacroDefs and ModuleDefs and I don't think I ever asked or found out about the reasoning behind this. Isn't a macro technically just a module definition? Or is this due to macros not necessarily being considered a proper item in scope where it is defined?<br>\n(And I think I recall a comment somewhere questioning this differentiation as well in the source but I don't remember where)</p>",
        "id": 261003210,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1636557025
    },
    {
        "content": "<p>Good question. I don't know :D  I think ModuleDef <em>should</em> contain MacroDef as one of the variants. </p>\n<p>I think this stems from macro call/macro def confustion.</p>",
        "id": 261003717,
        "sender_full_name": "matklad",
        "timestamp": 1636557271
    },
    {
        "content": "<p>At least originally, we treated <code>macro_rules! foo {}</code> as a macro call (a call to macro named <code>macro_rules</code>). And it is indeed an invariant that modules should not contain macro calls. </p>\n<p>For somethin like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"fm\">macro_rules!</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">enum</span> <span class=\"nc\">E</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">mod</span> <span class=\"nn\">m</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">struct</span> <span class=\"nc\">S</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">foo</span><span class=\"o\">!</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p><code>m</code> should contain <code>E</code> and <code>S</code> as children, but it shouldnt' know about <code>foo!()</code>, as macro calls are fully expanded at this level of semantics.</p>",
        "id": 261004016,
        "sender_full_name": "matklad",
        "timestamp": 1636557393
    },
    {
        "content": "<p>But now macros can be proper items, and they can be proper partsof the scope, so I think we should fix it. That is, we shouldn't add <code>foo!();</code> as a \"child\" of module, but <code>macro_rules! foo</code> should be a child of the parent one. z</p>",
        "id": 261004161,
        "sender_full_name": "matklad",
        "timestamp": 1636557461
    },
    {
        "content": "<p>I see, will consider exploring this then as getting rid of that differentiation should make some things simpler I feel like.</p>",
        "id": 261004405,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1636557586
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[derive(Debug, Default, PartialEq, Eq)]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">ItemScope</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">_c</span>: <span class=\"nc\">Count</span><span class=\"o\">&lt;</span><span class=\"bp\">Self</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"sd\">/// Defs visible in this scope. This includes `declarations`, but also</span>\n<span class=\"w\">    </span><span class=\"sd\">/// imports.</span>\n<span class=\"w\">    </span><span class=\"n\">types</span>: <span class=\"nc\">FxHashMap</span><span class=\"o\">&lt;</span><span class=\"n\">Name</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">ModuleDefId</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Visibility</span><span class=\"p\">)</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">values</span>: <span class=\"nc\">FxHashMap</span><span class=\"o\">&lt;</span><span class=\"n\">Name</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">ModuleDefId</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Visibility</span><span class=\"p\">)</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">macros</span>: <span class=\"nc\">FxHashMap</span><span class=\"o\">&lt;</span><span class=\"n\">Name</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">MacroDefId</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Visibility</span><span class=\"p\">)</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n</code></pre></div>\n<p>I think here at some point we also tried to have strong types between value/type/macro namespaces</p>",
        "id": 261004506,
        "sender_full_name": "matklad",
        "timestamp": 1636557614
    },
    {
        "content": "<p>Such that we can say things like \"modules are never values\", but we def dropped the ball on values/types at least</p>",
        "id": 261004597,
        "sender_full_name": "matklad",
        "timestamp": 1636557648
    },
    {
        "content": "<p>Yeah, and </p>\n<div class=\"codehilite\"><pre><span></span><code>#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\npub struct PerNs {\n    pub types: Option&lt;(ModuleDefId, Visibility)&gt;,\n    pub values: Option&lt;(ModuleDefId, Visibility)&gt;,\n    pub macros: Option&lt;(MacroDefId, Visibility)&gt;,\n}\n</code></pre></div>\n<p>probably needs fixing as well</p>",
        "id": 261004672,
        "sender_full_name": "matklad",
        "timestamp": 1636557674
    },
    {
        "content": "<p>Would we gain anything from discerning values types and macros over one single <code>ModuleDef</code> type even? <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 261005303,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1636557902
    },
    {
        "content": "<p>well, having the fact that everything in the macro namespace is a macro baked into the types makes sense, for types/values it's less valuable since they have so much overlap anyway</p>",
        "id": 261005315,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1636557908
    },
    {
        "content": "<p>I mean we could technically have both, <code>ModuleDef</code> to rule them all, then <code>MacroDef</code>, <code>TypeDef</code> and <code>ValueDef</code> where the latter two hold variants only for the things applicable. If desired</p>",
        "id": 261005590,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1636558010
    },
    {
        "content": "<p>I think we have those already at least in hir_ty: <code>TyDefId</code> and <code>ValueTyDefId</code></p>",
        "id": 261005825,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1636558108
    },
    {
        "content": "<p><code>MacroDef</code> not being part of <code>ModuleDef </code>tends to be annoying for some IDE features usually, <code>doc_links.rs</code> for example has some stuff that only cares about module items as a whole and then requires the use of<code> Either</code> to handle that nicely, ex: <a href=\"https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ide/src/doc_links.rs#L499-L527\">https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ide/src/doc_links.rs#L499-L527</a></p>",
        "id": 261005880,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1636558130
    },
    {
        "content": "<p>Yeah, i feel there are intersecting things here:</p>\n<ul>\n<li>there are items defined in a module</li>\n<li>and there are scope entries, which bind to a specific namespace</li>\n</ul>",
        "id": 261005882,
        "sender_full_name": "matklad",
        "timestamp": 1636558131
    },
    {
        "content": "<p>hm ok they're not exactly the same</p>",
        "id": 261005890,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1636558134
    },
    {
        "content": "<p>we need enum subset types <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 261006009,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1636558197
    },
    {
        "content": "<p>I do feel that <code>hir::ModuleDef</code> should probably include macros, not so suher about <code>hir_def</code>.</p>",
        "id": 261006099,
        "sender_full_name": "matklad",
        "timestamp": 1636558229
    },
    {
        "content": "<p>yeah, let's rewrite the thing in OCaml!</p>",
        "id": 261006133,
        "sender_full_name": "matklad",
        "timestamp": 1636558245
    },
    {
        "content": "<p>Back to the roots</p>",
        "id": 261006155,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1636558257
    },
    {
        "content": "<p>but maybe a bunch of enums with <code>Into</code> implementations between them is actually good enough</p>",
        "id": 261006378,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1636558352
    },
    {
        "content": "<p>OTOH, I feel that IDE functionality maybe wants to work with <code>Definition</code> more? Like, if you want to handle macros and structs, than maybe you want to handle fields as well?</p>",
        "id": 261006476,
        "sender_full_name": "matklad",
        "timestamp": 1636558398
    },
    {
        "content": "<p>In my example at least, probably ye</p>",
        "id": 261006699,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1636558484
    },
    {
        "content": "<p><span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> yeah, maybe <code>ModuleDef</code>, for IDE, is a somewhat arbitrary grouping to begin with? Ie, maybe we should just inline it here: </p>\n<p><a href=\"https://github.com/rust-analyzer/rust-analyzer/blob/04f03a360ab8fef3d9c0ff84de2d39b8a196c717/crates/ide_db/src/defs.rs#L21-L27\">https://github.com/rust-analyzer/rust-analyzer/blob/04f03a360ab8fef3d9c0ff84de2d39b8a196c717/crates/ide_db/src/defs.rs#L21-L27</a></p>",
        "id": 261006799,
        "sender_full_name": "matklad",
        "timestamp": 1636558518
    },
    {
        "content": "<p>I think it already does, but then splits up how it works on them before it calls into the linked code</p>",
        "id": 261006802,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1636558518
    },
    {
        "content": "<p>yeah I actually feel we should usually inline those grouping enums and not nest them anyway</p>",
        "id": 261006943,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1636558567
    },
    {
        "content": "<p>yeah, <code>get_symbol_filename</code> definitelly should work with Definiton and not with ModuleDef</p>",
        "id": 261006956,
        "sender_full_name": "matklad",
        "timestamp": 1636558572
    },
    {
        "content": "<p>it <em>should</em> work for fields</p>",
        "id": 261006972,
        "sender_full_name": "matklad",
        "timestamp": 1636558579
    },
    {
        "content": "<p>Ah right, <code>MacroDefId</code> doesn't track the module where it comes from, only the crate as it is defined in <code>hir_expand</code> where modules don't exist, that makes this a bit more tricky to move it into <code>ModuleDefId</code></p>",
        "id": 261161359,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1636651156
    },
    {
        "content": "<p>So I've been working on bringing <code>MacroDef{Id}</code> into <code>ModuleDef{Id}</code>, for which we need to first resolve the problem that we currently don't remember the module a macro is defined is. This can be easily fixed by adding a side table to the crate def map, but this of course fails to work for when a macro is defined in a block and since a <code>MacroDefId</code> has no access to anything other than crate id this approach falls down here. Now I was wondering if it would make sense to add a <code>MacroDefData</code> or something similar like we have for a other items and add a query for it to the <code>DefDatabase</code>. If we were to do this we could also save a macro's name inside this with the benefit that we no longer have to parse the source file of a macro to fetch its name. For macro 2.0 we can also then save the visibility which we don't do yet(I think?).</p>",
        "id": 261268543,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1636731056
    },
    {
        "content": "<p>hmm yeah, that seems useful</p>",
        "id": 261274549,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1636733594
    },
    {
        "content": "<p>Gonna be tricking dealing with the <code>ItemTree</code> and <code>MacroDefId </code>though, since we can't use the interning things we do for all the other item  types. So we have to save the ItemTreeIdx somewhere(as the ItemTree can be queried through the ast pointers in <code>MacroDefId</code>).<br>\nWill give that another look tomorrow.</p>",
        "id": 261276230,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1636734332
    },
    {
        "content": "<p>I just realized this won' work either, since module ids and the like don't exist for the item tree hmm</p>",
        "id": 261420889,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1636900697
    }
]