[
    {
        "content": "<p>Hi, I trying to get mutability of syntax tree right, which I'd like to use to implement automated refactoring in a big private project. Could you please review this snippet, and check if I am not missing something? It's the refactoring that automatically sorts items in the file according to our conventions:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">overwrite</span><span class=\"p\">(</span><span class=\"n\">ctx</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">LintCtx</span><span class=\"o\">&lt;'</span><span class=\"nb\">_</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// FIXME: make this lint work in files with macro definitions</span>\n<span class=\"w\">    </span><span class=\"c1\">// It needs special handling, we can't simply reorder them,</span>\n<span class=\"w\">    </span><span class=\"c1\">// because macro definitions are oder-dependent</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">has_macro_rules</span><span class=\"p\">(</span><span class=\"n\">ctx</span><span class=\"p\">.</span><span class=\"n\">file_ast</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">return</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">file</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ctx</span><span class=\"p\">.</span><span class=\"n\">file_ast</span><span class=\"p\">.</span><span class=\"n\">clone</span><span class=\"p\">();</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">items_sorted</span>: <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">_</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">file</span><span class=\"p\">.</span><span class=\"n\">items</span><span class=\"p\">().</span><span class=\"n\">collect</span><span class=\"p\">();</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"c1\">// Stable sorting is important! We don't want to reorder items with</span>\n<span class=\"w\">    </span><span class=\"c1\">// the same priority relatively to how they are already ordered!</span>\n<span class=\"w\">    </span><span class=\"n\">items_sorted</span><span class=\"p\">.</span><span class=\"n\">sort_by_key</span><span class=\"p\">(</span><span class=\"n\">item_priority</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"c1\">// Collect here is required because here we use internal mutability</span>\n<span class=\"w\">    </span><span class=\"c1\">// and we would iterate over the same collection we modify</span>\n<span class=\"w\">    </span><span class=\"cp\">#[allow(clippy::needless_collect)]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">items</span>: <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">_</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">file</span><span class=\"p\">.</span><span class=\"n\">items</span><span class=\"p\">().</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">it</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">ctx</span><span class=\"p\">.</span><span class=\"n\">make_mut</span><span class=\"p\">(</span><span class=\"n\">it</span><span class=\"p\">)).</span><span class=\"n\">collect</span><span class=\"p\">();</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"n\">items</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">.</span><span class=\"n\">into_iter</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">.</span><span class=\"n\">zip</span><span class=\"p\">(</span><span class=\"n\">items_sorted</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">.</span><span class=\"n\">for_each</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"p\">(</span><span class=\"n\">old</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">new</span><span class=\"p\">)</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">ted</span>::<span class=\"n\">replace</span><span class=\"p\">(</span><span class=\"n\">old</span><span class=\"p\">.</span><span class=\"n\">syntax</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">new</span><span class=\"p\">.</span><span class=\"n\">clone_for_update</span><span class=\"p\">().</span><span class=\"n\">syntax</span><span class=\"p\">()));</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>It looks too contrived to me...<br>\nThe <code>LintCtx</code> is based on <code>TreeMutator</code> in assists</p>",
        "id": 271748191,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1644761819
    },
    {
        "content": "<p>I think this is fine</p>",
        "id": 271748355,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1644762030
    },
    {
        "content": "<p>Though you probably don't have to collect the <code>items</code> local(not that it matters)</p>",
        "id": 271748410,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1644762062
    },
    {
        "content": "<p>This is basically what we do in our sorting assists as well like <a href=\"https://github.com/rust-analyzer/rust-analyzer/blob/7a17fb9c43b2cd0a8a2ff3d93b9d436fa28153d6/crates/ide_assists/src/handlers/reorder_fields.rs\">reorder_fields</a> for example</p>",
        "id": 271748488,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1644762155
    },
    {
        "content": "<p>Oh, thanks for the pointer! IIRC if that <code>collect()</code> is removed I get some weird behavior, because <code>file_ast</code> itself is getting modified in the process of iteration I guess, so it's direct <code>items()</code> iterator is going thru a collection that is itself mutated...</p>",
        "id": 271748668,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1644762436
    },
    {
        "content": "<p>Other thing is a refactoring that inserts a space for comments after their sigil. Eg. <code>//foo -&gt; // foo</code>, <code>//!bar -&gt; //! bar</code>. I haven't found a way to mutate the tokens directly, but I left this code 6 months ago. Maybe RA API changed since then and it could be simplified?</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">fix</span><span class=\"p\">(</span><span class=\"n\">ctx</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">LintCtx</span><span class=\"o\">&lt;'</span><span class=\"nb\">_</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">file</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ctx</span><span class=\"p\">.</span><span class=\"n\">make_mut</span><span class=\"p\">(</span><span class=\"n\">ctx</span><span class=\"p\">.</span><span class=\"n\">file_ast</span><span class=\"p\">.</span><span class=\"n\">clone</span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">descendants</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">file</span><span class=\"p\">.</span><span class=\"n\">syntax</span><span class=\"p\">().</span><span class=\"n\">descendants</span><span class=\"p\">();</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">descendants</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">replacements</span>: <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">_</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">bad_comments</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">node</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">.</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">comment</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">comment_text</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">comment</span><span class=\"p\">.</span><span class=\"n\">text</span><span class=\"p\">().</span><span class=\"n\">to_owned</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"n\">comment_text</span><span class=\"p\">.</span><span class=\"n\">insert</span><span class=\"p\">(</span><span class=\"n\">sigil_end</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">comment</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"sc\">' '</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"w\">                </span><span class=\"c1\">// Based on impl in `ra_syntax::ast::make::tokens` module</span>\n<span class=\"w\">                </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">new_comment</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ast</span>::<span class=\"n\">SourceFile</span>::<span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">comment_text</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"p\">.</span><span class=\"n\">ok</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"p\">.</span><span class=\"n\">unwrap</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"p\">.</span><span class=\"n\">syntax</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"p\">.</span><span class=\"n\">clone_for_update</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"p\">.</span><span class=\"n\">first_child_or_token</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"p\">.</span><span class=\"n\">unwrap</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"p\">.</span><span class=\"n\">into_token</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"p\">.</span><span class=\"n\">unwrap</span><span class=\"p\">();</span><span class=\"w\"></span>\n\n<span class=\"w\">                </span><span class=\"p\">(</span><span class=\"n\">comment</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">new_comment</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">})</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">.</span><span class=\"n\">collect</span><span class=\"p\">();</span><span class=\"w\"></span>\n\n<span class=\"w\">        </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">old_comment</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">new_comment</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">replacements</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">idx</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">old_comment</span><span class=\"p\">.</span><span class=\"n\">syntax</span><span class=\"p\">().</span><span class=\"n\">index</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">node</span><span class=\"p\">.</span><span class=\"n\">splice_children</span><span class=\"p\">(</span><span class=\"n\">idx</span><span class=\"o\">..</span><span class=\"n\">idx</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"fm\">vec!</span><span class=\"p\">[</span><span class=\"n\">new_comment</span><span class=\"p\">.</span><span class=\"n\">into</span><span class=\"p\">()]);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 271748856,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1644762728
    },
    {
        "content": "<p>ah right, I thought <code>file_ast</code> is an immutable node</p>",
        "id": 271748857,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1644762729
    },
    {
        "content": "<p>No mutating a tokens text isn't exposed to my knowledge so reconstructing a token with the next text is the way to go</p>",
        "id": 271748877,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1644762801
    },
    {
        "content": "<p>Okay, thanks =)</p>",
        "id": 271748947,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1644762882
    }
]