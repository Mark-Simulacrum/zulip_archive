[
    {
        "content": "<p>I recommend everyone to spend 50 minutes watching this talk: <a href=\"https://www.youtube.com/watch?v=Gdx6by6tcvw\" target=\"_blank\" title=\"https://www.youtube.com/watch?v=Gdx6by6tcvw\">https://www.youtube.com/watch?v=Gdx6by6tcvw</a>.</p>\n<p>It describes the Stripe's type checker for ruby. In particular, it describes the <em>ideal</em> incremental compiler pipeline:</p>\n<ul>\n<li>per-file indexing</li>\n<li>global symbol table</li>\n<li>per function inference</li>\n</ul>\n<p>It's very instructive to reflect on how this is different from rust-analyzer's architecture.</p>\n<p>There are two differences:</p>\n<ul>\n<li>rust is much easier, because we don't have to have a <strong>global</strong> symbol table, we need only per-crate symbol table.</li>\n<li>rust is much harder, because, due to macro expansion, the second phase, which is the \"design bottleneck\" is much more complicated and slow :(</li>\n</ul>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"Gdx6by6tcvw\" href=\"https://www.youtube.com/watch?v=Gdx6by6tcvw\" target=\"_blank\" title=\"https://www.youtube.com/watch?v=Gdx6by6tcvw\"><img src=\"https://i.ytimg.com/vi/Gdx6by6tcvw/default.jpg\"></a></div>",
        "id": 187201831,
        "sender_full_name": "matklad",
        "timestamp": 1580643179
    },
    {
        "content": "<p>there's also a recent blogpost about it <a href=\"https://blog.nelhage.com/post/why-sorbet-is-fast/\" target=\"_blank\" title=\"https://blog.nelhage.com/post/why-sorbet-is-fast/\">https://blog.nelhage.com/post/why-sorbet-is-fast/</a> (part of an ongoing series on Sorbet)</p>",
        "id": 187313540,
        "sender_full_name": "lqd",
        "timestamp": 1580769963
    }
]