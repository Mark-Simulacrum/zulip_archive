[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"153740\">@Igor Matuszewski</span> <span class=\"user-mention\" data-user-id=\"216201\">@Edwin Cheng</span> you are both interested in MBE. I wonder if we should shcedule a sync-up time to talk through the high-level design?</p>",
        "id": 162934609,
        "sender_full_name": "matklad",
        "timestamp": 1554833049
    },
    {
        "content": "<p>Sure, im in GMT + 8</p>",
        "id": 162937270,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1554834757
    },
    {
        "content": "<p>Let's try to schedule some time. I am unfortunately pretty busy this week, only Thursday will work for me: <a href=\"https://doodle.com/poll/z9ka63mz3xcy9wzr\" target=\"_blank\" title=\"https://doodle.com/poll/z9ka63mz3xcy9wzr\">https://doodle.com/poll/z9ka63mz3xcy9wzr</a></p>",
        "id": 162937709,
        "sender_full_name": "matklad",
        "timestamp": 1554835048
    },
    {
        "content": "<p>Done ! I did not know there is this kind of app for scheduling <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span></p>",
        "id": 162939117,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1554835861
    },
    {
        "content": "<p>Done!</p>",
        "id": 162949159,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1554843297
    },
    {
        "content": "<p>Good, added to the calendar: <a href=\"https://calendar.google.com/calendar/embed?src=6u5rrtce6lrtv07pfi3damgjus%40group.calendar.google.com\" target=\"_blank\" title=\"https://calendar.google.com/calendar/embed?src=6u5rrtce6lrtv07pfi3damgjus%40group.calendar.google.com\">https://calendar.google.com/calendar/embed?src=6u5rrtce6lrtv07pfi3damgjus%40group.calendar.google.com</a></p>",
        "id": 162949643,
        "sender_full_name": "matklad",
        "timestamp": 1554843634
    },
    {
        "content": "<p><span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span></p>",
        "id": 163082699,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1554973496
    },
    {
        "content": "<p><span aria-label=\"hi\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"hi\">:hi:</span></p>",
        "id": 163082733,
        "sender_full_name": "matklad",
        "timestamp": 1554973530
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"216201\">@Edwin Cheng</span> are you around?</p>",
        "id": 163082738,
        "sender_full_name": "matklad",
        "timestamp": 1554973538
    },
    {
        "content": "<p><span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span>üèª</p>",
        "id": 163082899,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1554973666
    },
    {
        "content": "<p>So, the rough agenda for the meeting:</p>\n<ul>\n<li>discuss high-level constraints/goals around macro exapnsion</li>\n<li>discuss what is currently implmenting</li>\n<li>figure out the next steps</li>\n</ul>",
        "id": 163082911,
        "sender_full_name": "matklad",
        "timestamp": 1554973679
    },
    {
        "content": "<p>I must confess that I don't really know deeply how macros work inside <code>rustc</code>. Reading rustc's code will be a major part of work here :)</p>",
        "id": 163083005,
        "sender_full_name": "matklad",
        "timestamp": 1554973740
    },
    {
        "content": "<p>I'll have a question regarding a high-level goal</p>",
        "id": 163083014,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1554973744
    },
    {
        "content": "<p>Sure!</p>",
        "id": 163083019,
        "sender_full_name": "matklad",
        "timestamp": 1554973750
    },
    {
        "content": "<p>do we mean for it to be a part of the \"librarification\" goal? e.g. do we want it to be as pure as possible?</p>",
        "id": 163083038,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1554973779
    },
    {
        "content": "<p>I'm not sure how much existing MBE infra relies on rustc internals like interning and so on but I imagine a very long-term goal would be to create a nice abstract library that rustc can also use? or would we have to rely too much on the parser and whatnot?</p>",
        "id": 163083131,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1554973836
    },
    {
        "content": "<p>Good one! I think we shouldn't target it for librarification explicitly: librariifing nameres and expansion itself at the same time is more capacity than we have</p>",
        "id": 163083142,
        "sender_full_name": "matklad",
        "timestamp": 1554973841
    },
    {
        "content": "<p>okay, makes sense</p>",
        "id": 163083172,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1554973872
    },
    {
        "content": "<p>And i have another question</p>",
        "id": 163083180,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1554973882
    },
    {
        "content": "<p>That is, I feel we should make progress on chalk/nameres/lexer first, and then librarify</p>",
        "id": 163083182,
        "sender_full_name": "matklad",
        "timestamp": 1554973885
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"216201\">@Edwin Cheng</span> go ahead</p>",
        "id": 163083187,
        "sender_full_name": "matklad",
        "timestamp": 1554973894
    },
    {
        "content": "<p>Sure we referenced how rustc works?</p>",
        "id": 163083193,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1554973903
    },
    {
        "content": "<p>like should we follow what rustc does 1-1?</p>",
        "id": 163083256,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1554973939
    },
    {
        "content": "<p>Yes</p>",
        "id": 163083260,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1554973945
    },
    {
        "content": "<p>I'd say probably not</p>",
        "id": 163083266,
        "sender_full_name": "matklad",
        "timestamp": 1554973956
    },
    {
        "content": "<p>I'd like to see how far we can go, using the purest possible interface, etc</p>",
        "id": 163083276,
        "sender_full_name": "matklad",
        "timestamp": 1554973976
    },
    {
        "content": "<p>at least initially.</p>",
        "id": 163083287,
        "sender_full_name": "matklad",
        "timestamp": 1554973984
    },
    {
        "content": "<p>Okay</p>",
        "id": 163083296,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1554973995
    },
    {
        "content": "<p>Closing all the gaps should be done as a part of future librarification</p>",
        "id": 163083298,
        "sender_full_name": "matklad",
        "timestamp": 1554974000
    },
    {
        "content": "<p>On the highest level, what we need is a proof of concept that large-scale macro expansion works in IDEs</p>",
        "id": 163083323,
        "sender_full_name": "matklad",
        "timestamp": 1554974030
    },
    {
        "content": "<p>So we should support common macros with a relatively efficient impl</p>",
        "id": 163083375,
        "sender_full_name": "matklad",
        "timestamp": 1554974050
    },
    {
        "content": "<p>Make sense</p>",
        "id": 163083387,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1554974074
    },
    {
        "content": "<p>another high level question - I didn't delve deep into untying the nameres/expansion  but I assume these are still highly interconnected</p>",
        "id": 163083401,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1554974097
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"153740\">@Igor Matuszewski</span> the running hypothesis is that they are not really</p>",
        "id": 163083434,
        "sender_full_name": "matklad",
        "timestamp": 1554974126
    },
    {
        "content": "<p>Like, nameres could have a callback expand_macro(MacroId) -&gt; SetOfNames</p>",
        "id": 163083443,
        "sender_full_name": "matklad",
        "timestamp": 1554974143
    },
    {
        "content": "<p>That is, it doesn't care about actual token trees which are produced, only about the names</p>",
        "id": 163083499,
        "sender_full_name": "matklad",
        "timestamp": 1554974166
    },
    {
        "content": "<p>hm, that actually makes sense</p>",
        "id": 163083522,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1554974188
    },
    {
        "content": "<p>The hygiene bit is somewhat in the middle between the two though</p>",
        "id": 163083550,
        "sender_full_name": "matklad",
        "timestamp": 1554974227
    },
    {
        "content": "<p>what was the case where we had feared it needs to go back and forth?</p>",
        "id": 163083556,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1554974233
    },
    {
        "content": "<p>About not being incremental enough? Or whcih case?</p>",
        "id": 163083567,
        "sender_full_name": "matklad",
        "timestamp": 1554974256
    },
    {
        "content": "<p>when one expansion expands to a glob use and then another expansion uses a (now) shadowed identifier? can</p>",
        "id": 163083568,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1554974258
    },
    {
        "content": "<p>can't remember</p>",
        "id": 163083569,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1554974261
    },
    {
        "content": "<p>Ah, time-travel</p>",
        "id": 163083578,
        "sender_full_name": "matklad",
        "timestamp": 1554974279
    },
    {
        "content": "<p>Yeah, the <code>SetOfNames</code> should also include set of (glob) imports, but this seems like a strictly name-res concern</p>",
        "id": 163083658,
        "sender_full_name": "matklad",
        "timestamp": 1554974313
    },
    {
        "content": "<p>I can't remember the details now :( sorry about that</p>",
        "id": 163083664,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1554974320
    },
    {
        "content": "<p>okay so I imagine we try to go as far as we can using the purest possible interface and don't think about nameres right now, correct?</p>",
        "id": 163083703,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1554974365
    },
    {
        "content": "<p>Correct!</p>",
        "id": 163083714,
        "sender_full_name": "matklad",
        "timestamp": 1554974374
    },
    {
        "content": "<p>Purity of interface is one of my personal high-level design goals here</p>",
        "id": 163083729,
        "sender_full_name": "matklad",
        "timestamp": 1554974397
    },
    {
        "content": "<p>let me describe what I've came up with so-far</p>",
        "id": 163083789,
        "sender_full_name": "matklad",
        "timestamp": 1554974410
    },
    {
        "content": "<p>first, we have mbe and proc macros. I think it would be cool if both used exactly the same interface. Basically, making macro_rules a special-cased proc macro</p>",
        "id": 163083818,
        "sender_full_name": "matklad",
        "timestamp": 1554974445
    },
    {
        "content": "<p>The interface is the ra_tt crate</p>",
        "id": 163083829,
        "sender_full_name": "matklad",
        "timestamp": 1554974462
    },
    {
        "content": "<p>It defines a <code>TokenTree</code>  structure, which is more or less copy-pased from proc_macro2</p>",
        "id": 163083858,
        "sender_full_name": "matklad",
        "timestamp": 1554974492
    },
    {
        "content": "<p>crucially, <code>ra_tt</code> does not depend on any other compiler crate</p>",
        "id": 163083934,
        "sender_full_name": "matklad",
        "timestamp": 1554974524
    },
    {
        "content": "<p>Another bit that is has is that its tokens have identifies (each identifier as an u32 associated with it)</p>",
        "id": 163083954,
        "sender_full_name": "matklad",
        "timestamp": 1554974559
    },
    {
        "content": "<p>I \"hope\" that TokenIds should be enough to associated arbitrary information (hygiene &amp; spans) with tokens</p>",
        "id": 163083973,
        "sender_full_name": "matklad",
        "timestamp": 1554974586
    },
    {
        "content": "<p>That is all for the \"pure interface\" bit</p>",
        "id": 163083998,
        "sender_full_name": "matklad",
        "timestamp": 1554974639
    },
    {
        "content": "<p>That is, macros consume and produce TokenTrees. The question is, how do we integrate thouse back in the AST?</p>",
        "id": 163084068,
        "sender_full_name": "matklad",
        "timestamp": 1554974681
    },
    {
        "content": "<p>Specifically, we need to convert from AST to tokens, from tokens to AST, and we need to preserve hygiene and span information along the way</p>",
        "id": 163084108,
        "sender_full_name": "matklad",
        "timestamp": 1554974709
    },
    {
        "content": "<p>so each token has an associated u32 with it, which can hold info like hygiene and spans, right?</p>",
        "id": 163084122,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1554974735
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"153740\">@Igor Matuszewski</span> right</p>",
        "id": 163084126,
        "sender_full_name": "matklad",
        "timestamp": 1554974745
    },
    {
        "content": "<p>(to  reiterate)</p>",
        "id": 163084130,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1554974747
    },
    {
        "content": "<p>basically, you'll have a <code>hygiene: FxHasMap&lt;u32, ExpansionId&gt;</code></p>",
        "id": 163084185,
        "sender_full_name": "matklad",
        "timestamp": 1554974767
    },
    {
        "content": "<p>that is, a hash-map on the side</p>",
        "id": 163084189,
        "sender_full_name": "matklad",
        "timestamp": 1554974774
    },
    {
        "content": "<p>so we explicitly convert AST to tokens for a macro call?</p>",
        "id": 163084200,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1554974804
    },
    {
        "content": "<p>since we have the concrete syntax tree (full-fidelity?) I imagine transforming this to tokens shouldn't be hard</p>",
        "id": 163084218,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1554974832
    },
    {
        "content": "<p>yes <a href=\"https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_mbe/src/syntax_bridge.rs#L18\" target=\"_blank\" title=\"https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_mbe/src/syntax_bridge.rs#L18\">https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_mbe/src/syntax_bridge.rs#L18</a></p>",
        "id": 163084219,
        "sender_full_name": "matklad",
        "timestamp": 1554974833
    },
    {
        "content": "<p>Yes we already have this</p>",
        "id": 163084282,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1554974883
    },
    {
        "content": "<p>Specifically, we walk the tree, prodce tokens (assigning incrementing <em>local</em> ids) and also produce a <code>TokenMap</code> which should help with managing spans, but which is not actually used :(</p>",
        "id": 163084298,
        "sender_full_name": "matklad",
        "timestamp": 1554974899
    },
    {
        "content": "<p>and what is <code>tt::TokenId</code> specifically?</p>",
        "id": 163084337,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1554974949
    },
    {
        "content": "<p>The bit about local ids is important: for each macro call, the id of the first token will be zero. This helps with incrementality, b/c the token tree is the same regardless of the position of the macro_call</p>",
        "id": 163084339,
        "sender_full_name": "matklad",
        "timestamp": 1554974951
    },
    {
        "content": "<p><code>pub struct TokenId(pub u32);</code></p>",
        "id": 163084345,
        "sender_full_name": "matklad",
        "timestamp": 1554974961
    },
    {
        "content": "<p>and that's the u32 that's used as the key for hygiene info?</p>",
        "id": 163084354,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1554974975
    },
    {
        "content": "<p>yes</p>",
        "id": 163084380,
        "sender_full_name": "matklad",
        "timestamp": 1554975003
    },
    {
        "content": "<p>and also as a key in the <code>TokenId -&gt; TextRange</code> map</p>",
        "id": 163084433,
        "sender_full_name": "matklad",
        "timestamp": 1554975016
    },
    {
        "content": "<p>ah, alrighty</p>",
        "id": 163084437,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1554975030
    },
    {
        "content": "<p>Yeah, so, we get an TokenTree. We then run macro black-box, which gives us another token-tree, but with the same (identify-wise) tokens</p>",
        "id": 163084480,
        "sender_full_name": "matklad",
        "timestamp": 1554975095
    },
    {
        "content": "<p>Which we feed back into the parser in token_tree_to_ast_item_list, and get the SyntaxTree back</p>",
        "id": 163084541,
        "sender_full_name": "matklad",
        "timestamp": 1554975143
    },
    {
        "content": "<p>which is kinda fun, because SyntaxTree is full-fidelity, but with token-trees we don't have whitespace, so the tree is missing all ws nodes</p>",
        "id": 163084566,
        "sender_full_name": "matklad",
        "timestamp": 1554975181
    },
    {
        "content": "<p>there's another question of \"parsability\" of the resulting token trees</p>",
        "id": 163084597,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1554975230
    },
    {
        "content": "<p>ANd this is what I am not entirely sure: converting tt to <strong>Abstract</strong> syntax tree directly seems more resonable, but we don't have an AST layer between CST and HIR, and introducing one just for macros seems and overkill</p>",
        "id": 163084652,
        "sender_full_name": "matklad",
        "timestamp": 1554975246
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"153740\">@Igor Matuszewski</span> what question exactly?</p>",
        "id": 163084660,
        "sender_full_name": "matklad",
        "timestamp": 1554975258
    },
    {
        "content": "<p>there are some cases in rustc macros IIRC where we produce a <code>$crate</code> quasi-keyword  which is special-cased in rustc but isn't directly parseable</p>",
        "id": 163084671,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1554975273
    },
    {
        "content": "<p>I think Vadim has worked on that to push back on it</p>",
        "id": 163084676,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1554975284
    },
    {
        "content": "<p>Oh, yeah... But, we totally can have <code>$crate</code> identifier in the syntax tree</p>",
        "id": 163084697,
        "sender_full_name": "matklad",
        "timestamp": 1554975312
    },
    {
        "content": "<p>but I assume we should always have expansion that, when \"pretty-printed\" should be easily parseable as regular Rust, right?</p>",
        "id": 163084698,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1554975316
    },
    {
        "content": "<p>Not really I fear.</p>",
        "id": 163084717,
        "sender_full_name": "matklad",
        "timestamp": 1554975339
    },
    {
        "content": "<p>$crate is the first reason</p>",
        "id": 163084720,
        "sender_full_name": "matklad",
        "timestamp": 1554975346
    },
    {
        "content": "<p>the second reason is precedence</p>",
        "id": 163084726,
        "sender_full_name": "matklad",
        "timestamp": 1554975352
    },
    {
        "content": "<p>Do we need the span about the interpolated item in final token tree ?</p>",
        "id": 163084738,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1554975356
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"153740\">@Igor Matuszewski</span> basically the tree for <code>$expr * 2</code> could expand to <code>1 + 1 * 2</code>, where the tree would be right, but pretty-pritnging would be wrong</p>",
        "id": 163084817,
        "sender_full_name": "matklad",
        "timestamp": 1554975402
    },
    {
        "content": "<p>shouldn't pretty-printing factor in the precedence and insert disambiguating braces?</p>",
        "id": 163084844,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1554975432
    },
    {
        "content": "<p>so <code>(1 + 1) * 2</code></p>",
        "id": 163084860,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1554975453
    },
    {
        "content": "<p>(hope I'm not missing something obvious here)</p>",
        "id": 163084865,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1554975461
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"216201\">@Edwin Cheng</span> yeah,  we need to correlate source spans with target spans, so that features like <code>goto definition</code> work correctly</p>",
        "id": 163084869,
        "sender_full_name": "matklad",
        "timestamp": 1554975469
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>macro_rules! s {\n    ($i:ident) =&gt; { struct $i; }\n}\n\ns!(Foo);\n\nfn foo(_: Foo) {\n\n}\n</pre></div>",
        "id": 163084940,
        "sender_full_name": "matklad",
        "timestamp": 1554975513
    },
    {
        "content": "<p>You can try this code in rust-analyzer today</p>",
        "id": 163084943,
        "sender_full_name": "matklad",
        "timestamp": 1554975520
    },
    {
        "content": "<p>goto definition for <code>_: Foo</code> works</p>",
        "id": 163084951,
        "sender_full_name": "matklad",
        "timestamp": 1554975532
    },
    {
        "content": "<p>And it even goes to the offset of <code>Foo</code> in <code>struct Foo</code></p>",
        "id": 163084969,
        "sender_full_name": "matklad",
        "timestamp": 1554975552
    },
    {
        "content": "<p><strong>But</strong>, it does so in the wrong file :D</p>",
        "id": 163084973,
        "sender_full_name": "matklad",
        "timestamp": 1554975564
    },
    {
        "content": "<p>So, you end up on <code>_r</code> in <code>macro_rules</code></p>",
        "id": 163084982,
        "sender_full_name": "matklad",
        "timestamp": 1554975581
    },
    {
        "content": "<p>Coming back to the \"easily parseable\" bit, that'd allow us to bypass the \"AST\" if we can always produce a valid CST</p>",
        "id": 163085044,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1554975616
    },
    {
        "content": "<p>threading this span-remapping logic all the way to the IDE is actually one task that I feel we should do right now</p>",
        "id": 163085045,
        "sender_full_name": "matklad",
        "timestamp": 1554975619
    },
    {
        "content": "<p>which also would be good, in case you'd want to syntax highlight the macro-expanded code</p>",
        "id": 163085052,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1554975638
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"153740\">@Igor Matuszewski</span> yeah, I think using CST would work</p>",
        "id": 163085053,
        "sender_full_name": "matklad",
        "timestamp": 1554975646
    },
    {
        "content": "<p>It's jsut that it contains \"unnceseccary\" bits</p>",
        "id": 163085057,
        "sender_full_name": "matklad",
        "timestamp": 1554975661
    },
    {
        "content": "<p>but yeah, I also think it'll be convenient for ide features like highlighting</p>",
        "id": 163085075,
        "sender_full_name": "matklad",
        "timestamp": 1554975678
    },
    {
        "content": "<p>I guess this is a good overview of what we got right now, so perhaps we shoudl proced to discussing action items?</p>",
        "id": 163085098,
        "sender_full_name": "matklad",
        "timestamp": 1554975722
    },
    {
        "content": "<p>sure!</p>",
        "id": 163085135,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1554975730
    },
    {
        "content": "<p>sure!</p>",
        "id": 163085147,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1554975755
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"216201\">@Edwin Cheng</span> do you have any questions/comments? I think that you are now more familiar with exisitng  infram than me :)</p>",
        "id": 163085150,
        "sender_full_name": "matklad",
        "timestamp": 1554975761
    },
    {
        "content": "<p>For the design part i don't have any comments</p>",
        "id": 163085171,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1554975791
    },
    {
        "content": "<p>Good!</p>",
        "id": 163085177,
        "sender_full_name": "matklad",
        "timestamp": 1554975797
    },
    {
        "content": "<p>So, I think there are two areas:</p>",
        "id": 163085185,
        "sender_full_name": "matklad",
        "timestamp": 1554975817
    },
    {
        "content": "<p>But i face some problems, should i talk right now, or later?</p>",
        "id": 163085187,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1554975819
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"216201\">@Edwin Cheng</span> right now is a good point probably</p>",
        "id": 163085196,
        "sender_full_name": "matklad",
        "timestamp": 1554975841
    },
    {
        "content": "<p>We discussed the single char punct problem before.</p>",
        "id": 163085255,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1554975881
    },
    {
        "content": "<p>Currently our parser expect composed token, e.g \"DOTDOTDOT\" ,,</p>",
        "id": 163085300,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1554975935
    },
    {
        "content": "<p>right! (<span class=\"user-mention\" data-user-id=\"153740\">@Igor Matuszewski</span> in the TokenTree, we represent <code>&lt;&lt;</code> as two <code>&lt;</code> tokens which are <code>Joint</code>, like syn, and that is slightly different from what we do in the parser)</p>",
        "id": 163085304,
        "sender_full_name": "matklad",
        "timestamp": 1554975942
    },
    {
        "content": "<p>But it make all stuffs became very complicated.</p>",
        "id": 163085374,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1554975985
    },
    {
        "content": "<p>Hm, perhaps we need to change the <code>TokenSource</code> interface to say</p>\n<div class=\"codehilite\"><pre><span></span>fn is_at_composed_token(tt: TokenKind)\n</pre></div>\n\n\n<p>?</p>",
        "id": 163085386,
        "sender_full_name": "matklad",
        "timestamp": 1554975998
    },
    {
        "content": "<p>That way, we don't have to write <code>current2</code> or <code>current3</code> in the parser</p>",
        "id": 163085397,
        "sender_full_name": "matklad",
        "timestamp": 1554976012
    },
    {
        "content": "<p>instead, the token source would take care of this</p>",
        "id": 163085415,
        "sender_full_name": "matklad",
        "timestamp": 1554976026
    },
    {
        "content": "<p>Or should we change the parser such that it only expect what single char punct?</p>",
        "id": 163085439,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1554976056
    },
    {
        "content": "<p>I guess <code>Is_composed_token</code> is a better apporahc</p>",
        "id": 163085457,
        "sender_full_name": "matklad",
        "timestamp": 1554976077
    },
    {
        "content": "<p>than, we can change <code>TokenSource</code> to be an Iterator-like thing, instead of a slice-like thing</p>",
        "id": 163085512,
        "sender_full_name": "matklad",
        "timestamp": 1554976099
    },
    {
        "content": "<p>and that should remove the need tor token-tree flattening</p>",
        "id": 163085532,
        "sender_full_name": "matklad",
        "timestamp": 1554976123
    },
    {
        "content": "<p>Will it affect proc-macro?</p>",
        "id": 163085539,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1554976135
    },
    {
        "content": "<p>I don't think so?</p>",
        "id": 163085553,
        "sender_full_name": "matklad",
        "timestamp": 1554976145
    },
    {
        "content": "<p>Another question, why we do not have a tokenstream ?</p>",
        "id": 163085578,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1554976182
    },
    {
        "content": "<p>tokenstream would be the \"iterator-like\" approach, right?</p>",
        "id": 163085670,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1554976211
    },
    {
        "content": "<p>THis is actually a good action item:</p>\n<p>Trying something like this:</p>\n<div class=\"codehilite\"><pre><span></span>trait TOkenSOuece {\n   fn current(&amp;self) -&gt; SyntaxKind;\n   fn is_at_composite(&amp;self, kind: SyntaxKind);\n   fn bump(&amp;mut self);\n   fn bump_composite(&amp;mut sekf, SyntaxKind);\n}\n</pre></div>",
        "id": 163085677,
        "sender_full_name": "matklad",
        "timestamp": 1554976233
    },
    {
        "content": "<p>SO, proc-macro has both a token tree and a token stream, where \"stream\" is the tree, but without delimiters. <span class=\"user-mention silent\" data-user-id=\"123856\">Vadim Petrochenkov</span>  in some issue written that this is not orthogonal, and that ideally only token tree should be enough</p>",
        "id": 163085775,
        "sender_full_name": "matklad",
        "timestamp": 1554976331
    },
    {
        "content": "<p>argh, can't find the comment right now</p>",
        "id": 163085844,
        "sender_full_name": "matklad",
        "timestamp": 1554976415
    },
    {
        "content": "<p>but the bottom like is that</p>\n<ul>\n<li>we should probably switch parser to the iterator-like interface for tokens</li>\n<li>we should try to avoid introducing TokenStream to the <code>ra_tt</code></li>\n</ul>",
        "id": 163085912,
        "sender_full_name": "matklad",
        "timestamp": 1554976462
    },
    {
        "content": "<p>I like the new trait, but how it solve the flatten problem of TokenSource &lt;-&gt; TokenTree ?</p>",
        "id": 163085923,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1554976479
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"216201\">@Edwin Cheng</span> currently TokenSource wraps an <code>[TtToken]</code>, because we need to handle arbitrary <code>pos</code>. In the new interface, you always ask questions about the current pos, so you could use the cursor directly</p>",
        "id": 163085979,
        "sender_full_name": "matklad",
        "timestamp": 1554976551
    },
    {
        "content": "<p>(<span class=\"user-mention\" data-user-id=\"153740\">@Igor Matuszewski</span> , if you are lost, we are talking about this interface to the parser <a href=\"https://github.com/rust-analyzer/rust-analyzer/blob/e6e2571bdf780d304c792d4317bbaf1d6f5d7a0a/crates/ra_parser/src/lib.rs#L32-L39\" target=\"_blank\" title=\"https://github.com/rust-analyzer/rust-analyzer/blob/e6e2571bdf780d304c792d4317bbaf1d6f5d7a0a/crates/ra_parser/src/lib.rs#L32-L39\">https://github.com/rust-analyzer/rust-analyzer/blob/e6e2571bdf780d304c792d4317bbaf1d6f5d7a0a/crates/ra_parser/src/lib.rs#L32-L39</a>, which is random-access, while it should be iterator-ish)</p>",
        "id": 163086045,
        "sender_full_name": "matklad",
        "timestamp": 1554976606
    },
    {
        "content": "<p>But do the token source only needs the top level TtToken of a TokenTree ?</p>",
        "id": 163086071,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1554976644
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"216201\">@Edwin Cheng</span> sort-of.  when <code>bump</code> method would go over <code>(</code>, the token source will dive one lever deeper, by pushing a parent subtree tot he stack</p>",
        "id": 163086139,
        "sender_full_name": "matklad",
        "timestamp": 1554976696
    },
    {
        "content": "<p>when we bump over <code>)</code>, the subtree is popped, and we are back to traversing the original TokenTree</p>",
        "id": 163086149,
        "sender_full_name": "matklad",
        "timestamp": 1554976718
    },
    {
        "content": "<p>Ok, so we are almost out of time, let's try to summarize action-items we have</p>",
        "id": 163086176,
        "sender_full_name": "matklad",
        "timestamp": 1554976759
    },
    {
        "content": "<p>So how about token-source look ahead ?</p>",
        "id": 163086177,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1554976770
    },
    {
        "content": "<p>I mean your parser maybe needs to look ahead some tokens ? So would we need to go backward of the cursor?</p>",
        "id": 163086247,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1554976827
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"216201\">@Edwin Cheng</span> we need a constant amount of lookaheard and we don't need to look inside <code>(</code>, so that should be doable with iterato interface</p>\n<ul>\n<li>threading span-infromation such that goto definition example from above works.</li>\n</ul>",
        "id": 163086249,
        "sender_full_name": "matklad",
        "timestamp": 1554976835
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"153740\">@Igor Matuszewski</span> would you be interested in tacking spans? That should make you touch almost every part of the analyser :D</p>",
        "id": 163086277,
        "sender_full_name": "matklad",
        "timestamp": 1554976876
    },
    {
        "content": "<p>Yeah, sounds good!</p>",
        "id": 163086303,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1554976905
    },
    {
        "content": "<p>it'd be good to get into the nitty-gritty now ;)</p>",
        "id": 163086310,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1554976919
    },
    {
        "content": "<ul>\n<li>trying out the new Iterator-based interface for token-source (I think <span class=\"user-mention\" data-user-id=\"216201\">@Edwin Cheng</span> you are basically deep in this already :) )</li>\n</ul>",
        "id": 163086360,
        "sender_full_name": "matklad",
        "timestamp": 1554976927
    },
    {
        "content": "<ul>\n<li>actually making the mbe code handle more cases</li>\n</ul>",
        "id": 163086375,
        "sender_full_name": "matklad",
        "timestamp": 1554976957
    },
    {
        "content": "<p>note that 1 and 2 are sort-of ground-work for 3</p>",
        "id": 163086386,
        "sender_full_name": "matklad",
        "timestamp": 1554976970
    },
    {
        "content": "<p>I actually expect that someone just throws away the expander I hacked together, and replaces it with something proper :)</p>",
        "id": 163086414,
        "sender_full_name": "matklad",
        "timestamp": 1554976996
    },
    {
        "content": "<p>And <strong>that</strong> would require reading rustc very closely</p>",
        "id": 163086431,
        "sender_full_name": "matklad",
        "timestamp": 1554977020
    },
    {
        "content": "<p>Should we wrap up the meeting then? (I do have some more time, so we can discuss some specific questions as well)</p>",
        "id": 163086512,
        "sender_full_name": "matklad",
        "timestamp": 1554977056
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133169\">@matklad</span> yesterday i just read a lot of rustc mbe code...:(</p>",
        "id": 163086513,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1554977058
    },
    {
        "content": "<p>I understand that <code>:(</code> smiley :D</p>",
        "id": 163086518,
        "sender_full_name": "matklad",
        "timestamp": 1554977073
    },
    {
        "content": "<p>I do have some more time too, but its up to you</p>",
        "id": 163086622,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1554977176
    },
    {
        "content": "<p>I'll also write meeting notes for this meetings</p>",
        "id": 163086634,
        "sender_full_name": "matklad",
        "timestamp": 1554977190
    },
    {
        "content": "<p>I think it'd be good to wrap up now</p>",
        "id": 163086652,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1554977224
    },
    {
        "content": "<p>and come back and sync later as we go, if that makes sense</p>",
        "id": 163086666,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1554977241
    },
    {
        "content": "<p>yeah. Let me preemptifly create streams for span-mapping and iterator token source</p>",
        "id": 163086680,
        "sender_full_name": "matklad",
        "timestamp": 1554977271
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133169\">@matklad</span> where will be the meeting notes?</p>",
        "id": 163086681,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1554977274
    },
    {
        "content": "<p>in the compiler-team repo I guess?</p>",
        "id": 163086736,
        "sender_full_name": "matklad",
        "timestamp": 1554977291
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133169\">@matklad</span> okay! let me know if you need some help with that</p>",
        "id": 163086998,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1554977582
    },
    {
        "content": "<p>also, random cc <span class=\"user-mention\" data-user-id=\"124069\">@Alexander Regueiro</span>: I saw that wg-macros thing, so it might be interested to you to see what happens with macros in RLS-2.0. Sorry for not thinking about cc-ing <em>before</em> the meeting :)</p>",
        "id": 163088663,
        "sender_full_name": "matklad",
        "timestamp": 1554979291
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"153740\">@Igor Matuszewski</span> here's that time-traveling problem thread: <a href=\"https://github.com/rust-lang/rust/pull/53778\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/pull/53778\">https://github.com/rust-lang/rust/pull/53778</a></p>",
        "id": 163088858,
        "sender_full_name": "matklad",
        "timestamp": 1554979533
    },
    {
        "content": "<p>No worries. I think the plan is to keep developing macros in the current compiler alongside this effort (especially eager expansion), but it would be good to stay abreast of that. What's the timeline like, do you have an idea? <span class=\"user-mention\" data-user-id=\"133169\">@matklad</span></p>",
        "id": 163111299,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1554997280
    },
    {
        "content": "<p>I hope that we'll have more-or-less working subset of mbe withing months, but any further plans are unclear</p>",
        "id": 163111742,
        "sender_full_name": "matklad",
        "timestamp": 1554997554
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133169\">@matklad</span>  Do you have any idea how we handle $crate token in mbe expansion ?</p>",
        "id": 163794633,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1555750533
    },
    {
        "content": "<p>I would think that just creating a <code>$crate</code> identifier would work?</p>",
        "id": 163804503,
        "sender_full_name": "matklad",
        "timestamp": 1555768671
    },
    {
        "content": "<p>so, when we expand code, and see <code>$</code> <code>crate</code> token trees, we produce a single <code>ident</code> token with <code>$crate</code> as text</p>",
        "id": 163804554,
        "sender_full_name": "matklad",
        "timestamp": 1555768727
    },
    {
        "content": "<p>Sure, thats what i think too.  OTOH, i did manage to fix the stackoverflow bug, but i found that I don‚Äôt want to enable the <code>tt</code> matcher, it is because:</p>\n<p>1. There are still some bugs in mbe which fail to expand. I will try to fix first.<br>\n2. The real problem is, i found that it make the whole startup time very slow. (At least in my ancient pc), i think it related to winapi, which brings tons of structs in (previously it is def behind macro)</p>",
        "id": 163807342,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1555773565
    },
    {
        "content": "<p>yeah, I expect properly supporting macros will make perf significantly worse....</p>\n<p>It might be a good idea to profile this stuff to check if its macro-expansion whihc is slow, or if it is the name resolution (which is now exercised much harder). <a href=\"https://github.com/AtheMathmo/cpuprofiler\" target=\"_blank\" title=\"https://github.com/AtheMathmo/cpuprofiler\">https://github.com/AtheMathmo/cpuprofiler</a> is a useful tool for profiling</p>",
        "id": 163807425,
        "sender_full_name": "matklad",
        "timestamp": 1555773712
    },
    {
        "content": "<blockquote>\n<p><a href=\"https://github.com/AtheMathmo/cpuprofiler\" target=\"_blank\" title=\"https://github.com/AtheMathmo/cpuprofiler\">https://github.com/AtheMathmo/cpuprofiler</a> is a useful tool for profiling</p>\n</blockquote>\n<p>It does not support Windows <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span> <br>\nAnyway, i would find some tools to profile it first.<br>\nBut my first priority is making no macro expanding errors in name resolution first. Personally i prefer a bunch of small PRs and will submit it one by one.</p>",
        "id": 163809098,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1555776543
    },
    {
        "content": "<p>what kinda of test is a smoke test ? and where would it belong</p>",
        "id": 163865599,
        "sender_full_name": "L.apz",
        "timestamp": 1555877406
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"121360\">@L.apz</span>  smoke test is the most simple test that executes given functionlity</p>",
        "id": 163867653,
        "sender_full_name": "matklad",
        "timestamp": 1555881036
    },
    {
        "content": "<p>for macros, I'd add it to type-inference tests</p>",
        "id": 163867657,
        "sender_full_name": "matklad",
        "timestamp": 1555881050
    },
    {
        "content": "<p>something like this</p>\n<div class=\"codehilite\"><pre><span></span>macro_rules! expr {\n    ($e:expr) =&gt; { $e }\n}\n\nstruct S;\nfn foo() {\n    let x = expr!(S);\n}\n</pre></div>\n\n\n<p>and check that type of <code>x</code> is <code>S</code></p>",
        "id": 163867671,
        "sender_full_name": "matklad",
        "timestamp": 1555881111
    },
    {
        "content": "<p>ah, the issue with panic b/c of local syntax ptr is fun...</p>",
        "id": 163867782,
        "sender_full_name": "matklad",
        "timestamp": 1555881255
    },
    {
        "content": "<p>where exactly do you get the panic? I wonder if we can fix it without refactoring all the tests</p>",
        "id": 163867855,
        "sender_full_name": "matklad",
        "timestamp": 1555881384
    },
    {
        "content": "<p>I get the error when I tried to add a test within the type inference tests. The painc is caused when we iterate the types that type inference returns specifically this line : <a href=\"https://github.com/rust-analyzer/rust-analyzer/blob/bbc5c1d24e1a641b134f634516828301e8cfc320/crates/ra_hir/src/ty/tests.rs#L2538\" target=\"_blank\" title=\"https://github.com/rust-analyzer/rust-analyzer/blob/bbc5c1d24e1a641b134f634516828301e8cfc320/crates/ra_hir/src/ty/tests.rs#L2538\">https://github.com/rust-analyzer/rust-analyzer/blob/bbc5c1d24e1a641b134f634516828301e8cfc320/crates/ra_hir/src/ty/tests.rs#L2538</a></p>",
        "id": 163869461,
        "sender_full_name": "L.apz",
        "timestamp": 1555883955
    },
    {
        "content": "<p>Hm, so, one fix here is to remove macro-generated exprs from SourceMap....</p>\n<p>Not sure what's the best way to do that</p>",
        "id": 163869651,
        "sender_full_name": "matklad",
        "timestamp": 1555884251
    },
    {
        "content": "<p>and also not sure what's the proper way to handle this long-term :)</p>",
        "id": 163869655,
        "sender_full_name": "matklad",
        "timestamp": 1555884269
    },
    {
        "content": "<p>So, and absolute quick fix would be to add a <code>bool</code> flag <code>is_in_macro</code> to Expr collector, which causes us to skip source-map if it is enabled</p>",
        "id": 163869684,
        "sender_full_name": "matklad",
        "timestamp": 1555884337
    },
    {
        "content": "<p>long-term, I guess we need to replace local ptrs in source map with global ones?</p>",
        "id": 163869686,
        "sender_full_name": "matklad",
        "timestamp": 1555884353
    },
    {
        "content": "<p>Thanks for the pointers. I'll look at it tomorrow.</p>",
        "id": 163870178,
        "sender_full_name": "L.apz",
        "timestamp": 1555885213
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"121360\">@L.apz</span> For issue 1187, i wrote an unit test :</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"cp\">#[test]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">test_vec</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">rules</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">create_rules</span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">r</span><span class=\"err\">#</span><span class=\"s\">&quot;</span>\n<span class=\"s\">         macro_rules! vec {</span>\n<span class=\"s\">            ($($item:expr),*) =&gt; {</span>\n<span class=\"s\">                {</span>\n<span class=\"s\">                    let mut v = Vec::new();</span>\n<span class=\"s\">                    $(</span>\n<span class=\"s\">                        v.push($item);</span>\n<span class=\"s\">                    )*</span>\n<span class=\"s\">                    v</span>\n<span class=\"s\">                }</span>\n<span class=\"s\">            };</span>\n<span class=\"s\">}</span>\n<span class=\"s\">&quot;</span><span class=\"err\">#</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">assert_expansion</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">rules</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">r#&quot;vec!();&quot;#</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">r#&quot;{let mut v = Vec :: new () ;  v}&quot;#</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">assert_expansion</span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"o\">&amp;</span><span class=\"n\">rules</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"s\">r#&quot;vec![1u32,2]&quot;#</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"s\">r#&quot;{let mut v = Vec :: new () ; v . push (1u32) ; v . push (2) ; v}&quot;#</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"w\">        </span><span class=\"n\">assert_eq</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">expand_to_stmts</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">rules</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">r#&quot;vec![1u32,2]&quot;#</span><span class=\"p\">).</span><span class=\"n\">syntax</span><span class=\"p\">().</span><span class=\"n\">debug_dump</span><span class=\"p\">().</span><span class=\"n\">trim</span><span class=\"p\">(),</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">r</span><span class=\"err\">#</span><span class=\"s\">&quot;MACRO_STMTS@[0; 45)</span>\n<span class=\"s\">  EXPR_STMT@[0; 45)</span>\n<span class=\"s\">    BLOCK_EXPR@[0; 45)</span>\n<span class=\"s\">      BLOCK@[0; 45)</span>\n<span class=\"s\">        L_CURLY@[0; 1) &quot;</span><span class=\"p\">{</span><span class=\"s\">&quot;</span>\n<span class=\"s\">        LET_STMT@[1; 20)</span>\n<span class=\"s\">          LET_KW@[1; 4) &quot;</span><span class=\"kd\">let</span><span class=\"s\">&quot;</span>\n<span class=\"s\">          BIND_PAT@[4; 8)</span>\n<span class=\"s\">            MUT_KW@[4; 7) &quot;</span><span class=\"k\">mut</span><span class=\"s\">&quot;</span>\n<span class=\"s\">            NAME@[7; 8)</span>\n<span class=\"s\">              IDENT@[7; 8) &quot;</span><span class=\"n\">v</span><span class=\"s\">&quot;</span>\n<span class=\"s\">          EQ@[8; 9) &quot;</span><span class=\"o\">=</span><span class=\"s\">&quot;</span>\n<span class=\"s\">          CALL_EXPR@[9; 19)</span>\n<span class=\"s\">            PATH_EXPR@[9; 17)</span>\n<span class=\"s\">              PATH@[9; 17)</span>\n<span class=\"s\">                PATH@[9; 12)</span>\n<span class=\"s\">                  PATH_SEGMENT@[9; 12)</span>\n<span class=\"s\">                    NAME_REF@[9; 12)</span>\n<span class=\"s\">                      IDENT@[9; 12) &quot;</span><span class=\"nb\">Vec</span><span class=\"s\">&quot;</span>\n<span class=\"s\">                COLONCOLON@[12; 14) &quot;</span>::<span class=\"s\">&quot;</span>\n<span class=\"s\">                PATH_SEGMENT@[14; 17)</span>\n<span class=\"s\">                  NAME_REF@[14; 17)</span>\n<span class=\"s\">                    IDENT@[14; 17) &quot;</span><span class=\"n\">new</span><span class=\"s\">&quot;</span>\n<span class=\"s\">            ARG_LIST@[17; 19)</span>\n<span class=\"s\">              L_PAREN@[17; 18) &quot;</span><span class=\"p\">(</span><span class=\"s\">&quot;</span>\n<span class=\"s\">              R_PAREN@[18; 19) &quot;</span><span class=\"p\">)</span><span class=\"s\">&quot;</span>\n<span class=\"s\">          SEMI@[19; 20) &quot;</span><span class=\"p\">;</span><span class=\"s\">&quot;</span>\n<span class=\"s\">        EXPR_STMT@[20; 33)</span>\n<span class=\"s\">          METHOD_CALL_EXPR@[20; 32)</span>\n<span class=\"s\">            PATH_EXPR@[20; 21)</span>\n<span class=\"s\">              PATH@[20; 21)</span>\n<span class=\"s\">                PATH_SEGMENT@[20; 21)</span>\n<span class=\"s\">                  NAME_REF@[20; 21)</span>\n<span class=\"s\">                    IDENT@[20; 21) &quot;</span><span class=\"n\">v</span><span class=\"s\">&quot;</span>\n<span class=\"s\">            DOT@[21; 22) &quot;</span><span class=\"p\">.</span><span class=\"s\">&quot;</span>\n<span class=\"s\">            NAME_REF@[22; 26)</span>\n<span class=\"s\">              IDENT@[22; 26) &quot;</span><span class=\"n\">push</span><span class=\"s\">&quot;</span>\n<span class=\"s\">            ARG_LIST@[26; 32)</span>\n<span class=\"s\">              L_PAREN@[26; 27) &quot;</span><span class=\"p\">(</span><span class=\"s\">&quot;</span>\n<span class=\"s\">              LITERAL@[27; 31)</span>\n<span class=\"s\">                INT_NUMBER@[27; 31) &quot;</span><span class=\"mi\">1</span><span class=\"k\">u32</span><span class=\"s\">&quot;</span>\n<span class=\"s\">              R_PAREN@[31; 32) &quot;</span><span class=\"p\">)</span><span class=\"s\">&quot;</span>\n<span class=\"s\">          SEMI@[32; 33) &quot;</span><span class=\"p\">;</span><span class=\"s\">&quot;</span>\n<span class=\"s\">        EXPR_STMT@[33; 43)</span>\n<span class=\"s\">          METHOD_CALL_EXPR@[33; 42)</span>\n<span class=\"s\">            PATH_EXPR@[33; 34)</span>\n<span class=\"s\">              PATH@[33; 34)</span>\n<span class=\"s\">                PATH_SEGMENT@[33; 34)</span>\n<span class=\"s\">                  NAME_REF@[33; 34)</span>\n<span class=\"s\">                    IDENT@[33; 34) &quot;</span><span class=\"n\">v</span><span class=\"s\">&quot;</span>\n<span class=\"s\">            DOT@[34; 35) &quot;</span><span class=\"p\">.</span><span class=\"s\">&quot;</span>\n<span class=\"s\">            NAME_REF@[35; 39)</span>\n<span class=\"s\">              IDENT@[35; 39) &quot;</span><span class=\"n\">push</span><span class=\"s\">&quot;</span>\n<span class=\"s\">            ARG_LIST@[39; 42)</span>\n<span class=\"s\">              L_PAREN@[39; 40) &quot;</span><span class=\"p\">(</span><span class=\"s\">&quot;</span>\n<span class=\"s\">              LITERAL@[40; 41)</span>\n<span class=\"s\">                INT_NUMBER@[40; 41) &quot;</span><span class=\"mi\">2</span><span class=\"s\">&quot;</span>\n<span class=\"s\">              R_PAREN@[41; 42) &quot;</span><span class=\"p\">)</span><span class=\"s\">&quot;</span>\n<span class=\"s\">          SEMI@[42; 43) &quot;</span><span class=\"p\">;</span><span class=\"s\">&quot;</span>\n<span class=\"s\">        PATH_EXPR@[43; 44)</span>\n<span class=\"s\">          PATH@[43; 44)</span>\n<span class=\"s\">            PATH_SEGMENT@[43; 44)</span>\n<span class=\"s\">              NAME_REF@[43; 44)</span>\n<span class=\"s\">                IDENT@[43; 44) &quot;</span><span class=\"n\">v</span><span class=\"s\">&quot;</span>\n<span class=\"s\">        R_CURLY@[44; 45) &quot;</span><span class=\"p\">}</span><span class=\"s\">&quot;&quot;</span><span class=\"err\">#</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 163895726,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1555928578
    },
    {
        "content": "<p>And its pass, so..... I would want to know how do  you expand your macro ? Maybe related to be used an incorrect <code>token_tree_to_xx</code> ?</p>",
        "id": 163895820,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1555928723
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"216201\">@Edwin Cheng</span>   The method is used was <code>mbe::token_tree_to_expr</code>.The error  also only shows up when you debug the extension and check the debug output  otherwise it works fine.</p>",
        "id": 163897242,
        "sender_full_name": "L.apz",
        "timestamp": 1555931210
    },
    {
        "content": "<p>I just tried <code>mbe::token_tree_to_expr</code> one, and it works too. Seem like if it is a parsing error, it should be appeared in other places. Let see if it appear again and i will fix it. :)</p>",
        "id": 163899875,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1555935215
    },
    {
        "content": "<p>I have a stupid question:</p>\n<p>in <a href=\"https://github.com/rust-lang/rust/blob/5d20ff4d2718c820632b38c1e49d4de648a9810b/src/libcore/internal_macros.rs#L81\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/5d20ff4d2718c820632b38c1e49d4de648a9810b/src/libcore/internal_macros.rs#L81\">https://github.com/rust-lang/rust/blob/5d20ff4d2718c820632b38c1e49d4de648a9810b/src/libcore/internal_macros.rs#L81</a><br>\nIt defined a mbe :</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">macro_rules</span><span class=\"o\">!</span><span class=\"w\"> </span><span class=\"n\">impl_fn_for_zst</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"cp\">$(</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"cp\">$(</span><span class=\"w\"> </span><span class=\"cp\">#[$attr: meta]</span><span class=\"w\"> </span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">struct</span> <span class=\"cp\">$Name</span>: <span class=\"nc\">ident</span><span class=\"w\"> </span><span class=\"k\">impl</span><span class=\"cp\">$(</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"cp\">$(</span><span class=\"w\"> </span><span class=\"cp\">$lifetime</span><span class=\"w\"> </span>: <span class=\"nc\">lifetime</span><span class=\"w\"> </span><span class=\"p\">),</span><span class=\"o\">+&gt;</span><span class=\"w\"> </span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"w\"> </span><span class=\"nb\">Fn</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"o\">|</span><span class=\"cp\">$(</span><span class=\"w\"> </span><span class=\"cp\">$arg</span>: <span class=\"nc\">ident</span>: <span class=\"cp\">$ArgTy</span>: <span class=\"nc\">ty</span><span class=\"w\"> </span><span class=\"p\">),</span><span class=\"o\">*|</span><span class=\"w\"> </span>-&gt; <span class=\"cp\">$ReturnTy</span>: <span class=\"nc\">ty</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"cp\">$body</span>: <span class=\"nc\">block</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">)</span><span class=\"o\">+</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">       </span><span class=\"p\">....</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>and in <a href=\"https://github.com/rust-lang/rust/blob/316a391dcb7d66dc25f1f9a4ec9d368ef7615005/src/libcore/str/mod.rs#L4114\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/316a391dcb7d66dc25f1f9a4ec9d368ef7615005/src/libcore/str/mod.rs#L4114\">https://github.com/rust-lang/rust/blob/316a391dcb7d66dc25f1f9a4ec9d368ef7615005/src/libcore/str/mod.rs#L4114</a><br>\nIt invoke this macro by:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">impl_fn_for_zst</span><span class=\"o\">!</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"cp\">#[derive(Clone)]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">struct</span> <span class=\"nc\">CharEscapeDebugContinue</span><span class=\"w\"> </span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"nb\">Fn</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">c</span>: <span class=\"nc\">char</span><span class=\"o\">|</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">char</span>::<span class=\"n\">EscapeDebug</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">c</span><span class=\"p\">.</span><span class=\"n\">escape_debug_ext</span><span class=\"p\">(</span><span class=\"kc\">false</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">};</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"cp\">#[derive(Clone)]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">struct</span> <span class=\"nc\">CharEscapeUnicode</span><span class=\"w\"> </span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"nb\">Fn</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">c</span>: <span class=\"nc\">char</span><span class=\"o\">|</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">char</span>::<span class=\"n\">EscapeUnicode</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">c</span><span class=\"p\">.</span><span class=\"n\">escape_unicode</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"cp\">#[derive(Clone)]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">struct</span> <span class=\"nc\">CharEscapeDefault</span><span class=\"w\"> </span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"nb\">Fn</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">c</span>: <span class=\"nc\">char</span><span class=\"o\">|</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">char</span>::<span class=\"n\">EscapeDefault</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">c</span><span class=\"p\">.</span><span class=\"n\">escape_default</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>A part of macro rules is <code> |$( $arg: ident: $ArgTy: ty ),*| -&gt; $ReturnTy: ty</code> and it try to match <code>|c: char| -&gt; char::EscapeUnicode</code>,<br>\nbut noted that the comma have to be presented in the macro invocation, but it is missing here. <br>\nDo i miss missing something here???</p>",
        "id": 164001487,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1556034227
    },
    {
        "content": "<p><code>*</code> is a special repetition syntax in mbe</p>",
        "id": 164001576,
        "sender_full_name": "matklad",
        "timestamp": 1556034283
    },
    {
        "content": "<p><code>$(foo),*</code> means <em>separated</em> by <code>,</code>,  so, trailing comma is forbidden</p>",
        "id": 164001615,
        "sender_full_name": "matklad",
        "timestamp": 1556034311
    },
    {
        "content": "<p><code>$(foo,)*</code> is <em>terminated</em> by <code>,</code>, ie, trailing comma is required</p>",
        "id": 164001634,
        "sender_full_name": "matklad",
        "timestamp": 1556034334
    },
    {
        "content": "<p><code>$(foo),*,?</code> I think is more or less \"separated by <code>,</code>, with an optional trailing comma\"</p>",
        "id": 164001696,
        "sender_full_name": "matklad",
        "timestamp": 1556034364
    },
    {
        "content": "<p>though, iiuc, the last one can parse a comma by itself</p>",
        "id": 164001715,
        "sender_full_name": "matklad",
        "timestamp": 1556034378
    },
    {
        "content": "<p>So it is optional ?? Do you have any document/ material i can read about that?</p>",
        "id": 164001823,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1556034479
    },
    {
        "content": "<p>The <em>trailing</em> one is optional,</p>",
        "id": 164001883,
        "sender_full_name": "matklad",
        "timestamp": 1556034499
    },
    {
        "content": "<p>I guess the docs are <a href=\"https://doc.rust-lang.org/reference/macros-by-example.html\" target=\"_blank\" title=\"https://doc.rust-lang.org/reference/macros-by-example.html\">https://doc.rust-lang.org/reference/macros-by-example.html</a></p>",
        "id": 164002042,
        "sender_full_name": "matklad",
        "timestamp": 1556034626
    },
    {
        "content": "<p><a href=\"https://danielkeep.github.io/tlborm/book/README.html\" target=\"_blank\" title=\"https://danielkeep.github.io/tlborm/book/README.html\">https://danielkeep.github.io/tlborm/book/README.html</a> used to be a good resource, but it hasn't keep up with language changes</p>",
        "id": 164002069,
        "sender_full_name": "matklad",
        "timestamp": 1556034648
    },
    {
        "content": "<p>I did read both actually, but no one mention the seperator itself in pattern is optional. :(</p>",
        "id": 164002437,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1556034900
    },
    {
        "content": "<p>there's a bit about this here: <a href=\"https://danielkeep.github.io/tlborm/book/pat-trailing-separators.html\" target=\"_blank\" title=\"https://danielkeep.github.io/tlborm/book/pat-trailing-separators.html\">https://danielkeep.github.io/tlborm/book/pat-trailing-separators.html</a></p>",
        "id": 164002634,
        "sender_full_name": "matklad",
        "timestamp": 1556035009
    },
    {
        "content": "<p>Seem to be i am missing that part. Thanks alot.</p>",
        "id": 164002770,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1556035084
    },
    {
        "content": "<p>\"Note that this cannot be used in all contexts. If the compiler rejects this, you will likely need to use multiple arms and/or incremental matching\" :(</p>",
        "id": 164002811,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1556035123
    },
    {
        "content": "<p>Yeah, I personally see <code>,*</code> thing as one of the (lesser) warts of the existing macro systems. Everywhere else we are careful to allow trailing separators, but in macros they are forbidden!</p>\n<p>It used to be the case that most stdlib macros forbade trailing <code>,</code> :D</p>",
        "id": 164002942,
        "sender_full_name": "matklad",
        "timestamp": 1556035203
    },
    {
        "content": "<p>But actually , the link you sent me is actually talking about the question i mention. Thats why in the link they needs to use <code>($($exprs:expr),* $(,)*) =&gt; {...};</code> to overcome that.</p>",
        "id": 164003015,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1556035239
    },
    {
        "content": "<p>So back to origin, WHY it is optional ? I still don't get it</p>",
        "id": 164003203,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1556035364
    },
    {
        "content": "<p>It is not really optional</p>",
        "id": 164003458,
        "sender_full_name": "matklad",
        "timestamp": 1556035535
    },
    {
        "content": "<p>let me give you a couple of examples</p>",
        "id": 164003463,
        "sender_full_name": "matklad",
        "timestamp": 1556035541
    },
    {
        "content": "<p>let's say we have pattern <code>$(a),*</code></p>",
        "id": 164003481,
        "sender_full_name": "matklad",
        "timestamp": 1556035553
    },
    {
        "content": "<p>here are some cases where it matches succesfully</p>",
        "id": 164003534,
        "sender_full_name": "matklad",
        "timestamp": 1556035564
    },
    {
        "content": "<p>1. <code> </code><br>\n2. <code>a</code><br>\n3. <code>a, a</code><br>\n4. <code>a, a, a</code></p>",
        "id": 164003556,
        "sender_full_name": "matklad",
        "timestamp": 1556035582
    },
    {
        "content": "<p>And here are some <strong>failed</strong> cases</p>",
        "id": 164003594,
        "sender_full_name": "matklad",
        "timestamp": 1556035609
    },
    {
        "content": "<p>1. <code>a, </code> // tariling separator<br>\n2. <code>,</code>   // only separator<br>\n3. <code>a a</code> // no separator</p>",
        "id": 164003628,
        "sender_full_name": "matklad",
        "timestamp": 1556035639
    },
    {
        "content": "<p>does this make sense?</p>",
        "id": 164003638,
        "sender_full_name": "matklad",
        "timestamp": 1556035645
    },
    {
        "content": "<p>So what you mean is, the  kleene operator is applied on the comma, not the whole pattern, right ?</p>",
        "id": 164003759,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1556035713
    },
    {
        "content": "<p>no, it is applied to <em>both</em> pattern and comma</p>",
        "id": 164003906,
        "sender_full_name": "matklad",
        "timestamp": 1556035812
    },
    {
        "content": "<p><code>$(a),*</code> means matching <code>a $(,a)*</code> or matching empty</p>",
        "id": 164003938,
        "sender_full_name": "kennytm",
        "timestamp": 1556035843
    },
    {
        "content": "<p>the important thing is the diffrence between <code>$(a,)*</code> and <code>$(a),*</code></p>",
        "id": 164003945,
        "sender_full_name": "matklad",
        "timestamp": 1556035856
    },
    {
        "content": "<p>Okay, i seem to get it, but why the book mentions <code>$($exprs:expr),* $(,)*) =&gt; {...};</code> ??</p>",
        "id": 164004272,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1556036068
    },
    {
        "content": "<p>or, read it this way,</p>\n<ul>\n<li><code>$($stuff)¬ß*</code> means matching Zero Or More <code>$stuff</code>, and between every <code>$stuff</code> there must be a <code>¬ß</code></li>\n<li><code>$($stuff)*</code> means matching Zero Or More <code>$stuff</code>, and between every <code>$stuff</code> there must be (nothing)</li>\n<li><code>$($stuff)¬ß+</code> means matching One Or More <code>$stuff</code>, and between every <code>$stuff</code> there must be a <code>¬ß</code></li>\n<li><code>$($stuff)+</code> means matching One Or More <code>$stuff</code>, and between every <code>$stuff</code> there must be (nothing)</li>\n<li><code>$($stuff)?</code> means matching Zero Or One <code>$stuff</code>.</li>\n</ul>",
        "id": 164004276,
        "sender_full_name": "kennytm",
        "timestamp": 1556036069
    },
    {
        "content": "<p>so <code>$($exprs:expr),*</code> means matching Zero Or More expressions, with a <code>,</code> between each expression</p>",
        "id": 164004335,
        "sender_full_name": "kennytm",
        "timestamp": 1556036126
    },
    {
        "content": "<p>but this can't match the trailing comma in</p>\n<div class=\"codehilite\"><pre><span></span>1,2,3,4,\n//     ^\n</pre></div>",
        "id": 164004357,
        "sender_full_name": "kennytm",
        "timestamp": 1556036159
    },
    {
        "content": "<p>so a <code>$(,)*</code> is added after <code>$($exprs:expr),*</code> to match that trailing comma as well (should be written as <code>$(,)?</code> nowadays but it's a relatively new feature).</p>",
        "id": 164004495,
        "sender_full_name": "kennytm",
        "timestamp": 1556036231
    },
    {
        "content": "<p>Oh i see, that's because it is allowed for the trailing comma .. I just misunderstand that in the opposite way .. I thought it is because it allow no trailing comma.</p>",
        "id": 164004518,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1556036255
    },
    {
        "content": "<p>Thank you so much you guys , <span aria-label=\"heart\" class=\"emoji emoji-2764\" role=\"img\" title=\"heart\">:heart:</span></p>",
        "id": 164004661,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1556036343
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133169\">@matklad</span>  I'm looking at adding goto for macros but I keep on a getting some type inference errors</p>\n<div class=\"codehilite\"><pre><span></span>no method named `parse` found for type `&amp;db::RootDatabase` in the current scope\n</pre></div>\n\n\n<p>Do you know what causes this or have any idea on something that I'm missing</p>",
        "id": 164024743,
        "sender_full_name": "L.apz",
        "timestamp": 1556049703
    },
    {
        "content": "<p>sigh....</p>\n<p>That's a rustc bug with incremental compilation, <code>rm target/debug/.incremental -rf</code> should fix it</p>",
        "id": 164024829,
        "sender_full_name": "matklad",
        "timestamp": 1556049752
    },
    {
        "content": "<p>temporarly :)</p>",
        "id": 164024836,
        "sender_full_name": "matklad",
        "timestamp": 1556049756
    },
    {
        "content": "<p>thanks</p>",
        "id": 164024894,
        "sender_full_name": "L.apz",
        "timestamp": 1556049802
    },
    {
        "content": "<p>I usually encounter this in<code>ra_ide_api</code> so you only need to delete that one</p>",
        "id": 164027508,
        "sender_full_name": "Jeremy Kolb",
        "timestamp": 1556051858
    },
    {
        "content": "<p>Just want to share with you gus, while i add tests to mbe by dogfooding all macro in <code>ra</code>, i found these two \"amazing\" macros:</p>\n<ul>\n<li><a href=\"https://github.com/retep998/winapi-rs/blob/a7ef2bca086aae76cf6c4ce4c2552988ed9798ad/src/um/d3d11sdklayers.rs#L163\" target=\"_blank\" title=\"https://github.com/retep998/winapi-rs/blob/a7ef2bca086aae76cf6c4ce4c2552988ed9798ad/src/um/d3d11sdklayers.rs#L163\">https://github.com/retep998/winapi-rs/blob/a7ef2bca086aae76cf6c4ce4c2552988ed9798ad/src/um/d3d11sdklayers.rs#L163</a></li>\n<li><a href=\"https://github.com/retep998/winapi-rs/blob/a7ef2bca086aae76cf6c4ce4c2552988ed9798ad/src/um/d3d12sdklayers.rs#L169\" target=\"_blank\" title=\"https://github.com/retep998/winapi-rs/blob/a7ef2bca086aae76cf6c4ce4c2552988ed9798ad/src/um/d3d12sdklayers.rs#L169\">https://github.com/retep998/winapi-rs/blob/a7ef2bca086aae76cf6c4ce4c2552988ed9798ad/src/um/d3d12sdklayers.rs#L169</a></li>\n</ul>\n<p>I don't know how to handle these cases, should we just ignore it or still parse it ?</p>",
        "id": 164142673,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1556166906
    },
    {
        "content": "<p>Oh, hellow winapi, my old friend! (<a href=\"https://github.com/intellij-rust/intellij-rust/blob/53b67c89eae86969bf244683aa5b5ccb2639d6b0/src/test/kotlin/org/rustSlowTests/CargoProjectResolveTest.kt#L216\" target=\"_blank\" title=\"https://github.com/intellij-rust/intellij-rust/blob/53b67c89eae86969bf244683aa5b5ccb2639d6b0/src/test/kotlin/org/rustSlowTests/CargoProjectResolveTest.kt#L216\">https://github.com/intellij-rust/intellij-rust/blob/53b67c89eae86969bf244683aa5b5ccb2639d6b0/src/test/kotlin/org/rustSlowTests/CargoProjectResolveTest.kt#L216</a>)</p>",
        "id": 164145851,
        "sender_full_name": "matklad",
        "timestamp": 1556171942
    },
    {
        "content": "<p>Long term, we definitely should just expand them</p>",
        "id": 164145866,
        "sender_full_name": "matklad",
        "timestamp": 1556171998
    },
    {
        "content": "<p>Medium term, it‚Äôs okay if we fail to expand them, as long as the analyzer doesn‚Äôt hang</p>",
        "id": 164145938,
        "sender_full_name": "matklad",
        "timestamp": 1556172063
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133169\">@matklad</span>  I have another mbe design problem want to discuss :</p>",
        "id": 164190729,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1556213040
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 164190778,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1556213046
    },
    {
        "content": "<p>## Problems</p>\n<p>Who do will handle multiple <code>punct</code> in mbe ?</p>\n<p>### Lexer</p>\n<p>Currently our lexer produces 2 kinds of Punct :</p>\n<ul>\n<li>\n<p>Single character punct (type I)<br>\n    * <code>;,(){}[]&lt;&gt;@#~?$&amp;|+*/^%-</code><br>\n    * <code>.:=!-</code></p>\n</li>\n<li>\n<p>Multiple characters punct (type II) <br>\n    * <code>..</code> <code>...</code> <code>::</code> <code>==</code> <code>=&gt;</code> <code>!=</code> <code>-&gt;</code></p>\n</li>\n<li>\n<p>But it <strong>DO NOT</strong> produces followings <strong>multiple characters punct</strong>: (type III)<br>\n    * <code>&lt;=</code> <code>&gt;=</code> <code>+=</code> <code>-=</code> <code>|=</code> <code>&amp;=</code> <code>^=</code> <code>/=</code> <code>*=</code> <code>%=</code> <code>&amp;&amp;</code> <code>||</code> <code>&lt;&lt;</code> <code>&gt;&gt;</code> <code>&lt;&lt;=</code> <code>&gt;&gt;=</code></p>\n</li>\n</ul>\n<p>### How current mbe macro invocation works</p>\n<p>1. When parser see a macro call, it will parse all its argument by <code>ast::token_tree</code>, which basically just use what lexer produced to make a tree. All whitespace information are preserved in this phase and only <strong>type I</strong> and <strong>type II</strong> punct will show up in <code>ast::token_tree</code>.<br>\n2. When <code>hir</code> expands a macro, it calls <code>mbe::ast_to_token_tree</code> to convert it to a <code>tt::TokenTree</code>. Although <code>tt::TokenTree</code> only store <strong>type I</strong> punct, while we extract <strong>type II</strong> punct to <strong>type I</strong> , we will store <code>is_joint_next</code> to preserve the whitespace information. But, this method cannot preverse white space information of <strong>type III</strong> . We have to look ahead to see if whether we need whitespace:</p>\n<div class=\"codehilite\"><pre><span></span>// Handle type II white space\nfor char in token.text().chars() {\n    if let Some(char) = prev {\n        token_trees.push(\n            tt::Leaf::from(tt::Punct { char, spacing: tt::Spacing::Joint })\n                .into(),\n        );\n    }\n    prev = Some(char)\n}\n// Handle type III white space\nif let Some(char) = prev {\n    let spacing = match child_iter.peek() {\n        Some(SyntaxElement::Token(token)) =&gt; {\n            if token.kind().is_punct() {\n                tt::Spacing::Joint\n            } else {\n                tt::Spacing::Alone\n            }\n        }\n        _ =&gt; tt::Spacing::Alone,\n    };\n\n    token_trees.push(tt::Leaf::from(tt::Punct { char, spacing }).into());\n}\n</pre></div>\n\n\n<p>3. While mbe match rule matchers, (e.g. <code>$path:path</code>), it will call <code>parse_xxx</code> from <code>ra_syntax</code> crate as a blackbox parser, So that's why the <code>type III</code> white space information above will be needed.<br>\n4. After macro expansion is finished, a <code>tt::Subtree</code> will be returned. And hir will call <code>mbe::token_tree_to_xxx</code> to convert it back to <code>SyntaxNode</code> tree. And <strong>all whitespace information will be lost</strong> while conversion. There are two cases:<br>\na. <code>tt::TokenTree</code> contains no other macro calls. That's fine as we do not need these information any more. (in mbe point of view)<br>\nb. <code>tt::TokenTree</code> contains other macro calls. <code>hir</code> will try to exapnd it again. (Goto step 1). However, all whitespace information are lost, so we have a trouble. </p>\n<p>Imagine following case:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">macro_rules</span><span class=\"o\">!</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">bar</span><span class=\"o\">!</span><span class=\"p\">[</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">problem</span>: ::<span class=\"n\">other_crate</span>::<span class=\"k\">type</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"n\">macro_rules</span><span class=\"o\">!</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">((</span><span class=\"cp\">$tt</span>:<span class=\"nc\">tt</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// Something..</span>\n<span class=\"w\">        </span><span class=\"p\">......</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>Note that after <code>bar</code> macro expansion, the <code>SyntaxNode</code> of this line:<br>\n<code>problem: ::other_crate::type</code><br>\nis <code>[IDENT, COLON, COLONCOLON, ...]</code>. </p>\n<p>However, when we try to expand <code>bar</code> using algorithm in step 2,  the <code>tt::TokenTree</code> will become:<br>\n<code> [IDENT, COLON(joint_to_next=true),COLON(joint_to_next=true), COLON(joint_to_next=true)] </code><br>\n And it is simply wrong.</p>",
        "id": 164191166,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1556213367
    },
    {
        "content": "<p>I think completely loosing whitespace info should be ok for macro expansion</p>",
        "id": 164191541,
        "sender_full_name": "matklad",
        "timestamp": 1556213604
    },
    {
        "content": "<p>However, the fact that the lexer produces both joint and non-joint tokens is not</p>",
        "id": 164191564,
        "sender_full_name": "matklad",
        "timestamp": 1556213625
    },
    {
        "content": "<p>I think we should fix the lexer to always produce single-character tokesn</p>",
        "id": 164191580,
        "sender_full_name": "matklad",
        "timestamp": 1556213641
    },
    {
        "content": "<p>But the last example still cannot resolve, right ?<br>\neven the lexer is  only produce single char token, the <code>SyntaxNode </code>will be <code>[IDENT, COLON, COLON COLON]</code>...</p>",
        "id": 164191873,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1556213827
    },
    {
        "content": "<p>Hm, riiight....</p>",
        "id": 164192167,
        "sender_full_name": "matklad",
        "timestamp": 1556214009
    },
    {
        "content": "<p>The brute-force solution would be to insert whitespace when we go from tt to ast</p>",
        "id": 164192259,
        "sender_full_name": "matklad",
        "timestamp": 1556214114
    },
    {
        "content": "<p>Like, initially, for foo, we have syntax tree from ws typed by the user</p>",
        "id": 164192321,
        "sender_full_name": "matklad",
        "timestamp": 1556214131
    },
    {
        "content": "<p>when we cook tt out of it, we get <code>:, join_to_next=false</code></p>",
        "id": 164192343,
        "sender_full_name": "matklad",
        "timestamp": 1556214153
    },
    {
        "content": "<p>whn we then expand foo, we preserve this token and get join_to_next=false in the expantion</p>",
        "id": 164192383,
        "sender_full_name": "matklad",
        "timestamp": 1556214180
    },
    {
        "content": "<p>which is ok</p>",
        "id": 164192388,
        "sender_full_name": "matklad",
        "timestamp": 1556214183
    },
    {
        "content": "<p>what is not ok is that, when we try to parse that token tree as an item list, we render it into a tree without a space (whihc is what you are saying)</p>",
        "id": 164192441,
        "sender_full_name": "matklad",
        "timestamp": 1556214220
    },
    {
        "content": "<p>I think we can tweak that last step to insert a dummy space in that case?</p>",
        "id": 164192456,
        "sender_full_name": "matklad",
        "timestamp": 1556214234
    },
    {
        "content": "<p>that is, we don't need to preserve vs exactly as the user typed them</p>",
        "id": 164192522,
        "sender_full_name": "matklad",
        "timestamp": 1556214248
    },
    {
        "content": "<p>we just need <em>some</em> spacing which maintains jointness</p>",
        "id": 164192551,
        "sender_full_name": "matklad",
        "timestamp": 1556214274
    },
    {
        "content": "<p>Yes we can :  </p>\n<div class=\"codehilite\"><pre><span></span>impl&lt;&#39;a, Q: Querier&gt; TreeSink for TtTreeSink&lt;&#39;a, Q&gt; {\n    fn token(&amp;mut self, kind: SyntaxKind, n_tokens: u8) {\n        if kind == L_DOLLAR || kind == R_DOLLAR {\n            self.token_pos += n_tokens as usize;\n            return;\n        }\n\n        for _ in 0..n_tokens {\n            self.buf += &amp;self.src_querier.token(self.token_pos).1;\n            self.token_pos += 1;\n        }\n        self.text_pos += TextUnit::of_str(&amp;self.buf);\n        let text = SmolStr::new(self.buf.as_str());\n        self.buf.clear();\n        self.inner.token(kind, text);\n\n        // Add a white space to token\n        let (last_kind, _, last_joint_to_next ) = self.src_querier.token(self.token_pos-n_tokens as usize);\n        if !last_joint_to_next &amp;&amp; last_kind.is_punct() {\n            let (cur_kind, _, _ ) = self.src_querier.token(self.token_pos);\n            if cur_kind.is_punct() {\n                self.inner.token(WHITESPACE, &quot; &quot;.into());\n            }\n        }\n    }\n</pre></div>",
        "id": 164192658,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1556214347
    },
    {
        "content": "<p>It is the code we transform <code>tt</code> to syntax node by <code>SyntaxNodeBuilder</code></p>",
        "id": 164192740,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1556214386
    },
    {
        "content": "<p>However, as you said, we should start from making the lexer only product single char. Let me push a PR for the bugs fixes i did in last few days first. And make the lexer PR afterward.</p>",
        "id": 164194022,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1556215242
    },
    {
        "content": "<p>I also wonder what we shoud do first:</p>\n<ul>\n<li>refactoring to produce decomposed tokens</li>\n<li>refactoring to make <code>TokenSource</code> and iterator, instead of a random-access sequecne</li>\n</ul>",
        "id": 164194213,
        "sender_full_name": "matklad",
        "timestamp": 1556215347
    },
    {
        "content": "<p>I have a theory that the first one would be easier if we do the second one first</p>",
        "id": 164194248,
        "sender_full_name": "matklad",
        "timestamp": 1556215369
    },
    {
        "content": "<p>The first one is quite straight forward. But the second one we still need to think about the design. The iterator will need to be able <code>peek(3)</code>, and i still need to travesal a tree by index. Hm....</p>",
        "id": 164194792,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1556215692
    },
    {
        "content": "<p>yeah, I haven't looked closely at that code for a while, so I trust your judgment here!</p>",
        "id": 164194890,
        "sender_full_name": "matklad",
        "timestamp": 1556215766
    },
    {
        "content": "<p>Just found that it is a valid macro: </p>\n<div class=\"codehilite\"><pre><span></span>macro_rules! foo {\n    ($a:ident, $b:ident, $c:tt) =&gt; {\n\n        macro_rules! bar {\n            ($bi:ident) =&gt; {\n                fn $bi() -&gt; u8 {$c}\n            }\n        }\n\n        bar!($a);\n        fn $b() -&gt; u8 {$c}\n    }\n}\n\nfoo!(x,y, 1);\n\nfn main() {\n    println!(&quot;{}&quot;, x() + y());\n}\n</pre></div>",
        "id": 164427237,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1556517394
    },
    {
        "content": "<p>oh yeah, macros can totally declare macros</p>",
        "id": 164434768,
        "sender_full_name": "matklad",
        "timestamp": 1556527310
    },
    {
        "content": "<p>Finally I fixed all dogfooding bugs in mbe, except <code>doc comment</code> =&gt;  $meta . <br>\nHere is the log of errror : <a href=\"https://gist.github.com/edwin0cheng/3f3f17bba11b8c262bf375895379a60e\" target=\"_blank\" title=\"https://gist.github.com/edwin0cheng/3f3f17bba11b8c262bf375895379a60e\">https://gist.github.com/edwin0cheng/3f3f17bba11b8c262bf375895379a60e</a></p>\n<p>Just curious,   how would we handle <code>DocComment</code> ?</p>\n<ul>\n<li>Do lexer produce a DOC_COMMENT SyntaxKind ?</li>\n<li>How kind of <code>tt::TokenTree</code> should it be ?</li>\n</ul>",
        "id": 164446835,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1556540564
    },
    {
        "content": "<p>I think we should deshugar doc comments to <code>#[doc = \"...\"]</code> attributes when we convert syntax tree to tt</p>",
        "id": 164450357,
        "sender_full_name": "matklad",
        "timestamp": 1556543308
    },
    {
        "content": "<p>conversely, when we parse tt as syntax tree, there would be no doc comments, only attributes</p>",
        "id": 164450397,
        "sender_full_name": "matklad",
        "timestamp": 1556543336
    },
    {
        "content": "<p>This is a solution I have never not thought of... nice</p>",
        "id": 164451576,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1556544251
    },
    {
        "content": "<p>that is basically what rustc's parser is doig</p>",
        "id": 164451830,
        "sender_full_name": "matklad",
        "timestamp": 1556544452
    },
    {
        "content": "<p>Do anyone know a crate /regex to escape a double quote string and unescape a double quote string but leave other escape char intact? <br>\ne.g. <code>I said: \"she said\\\" I said \\\" \"\\n</code> &lt;-&gt; <code>I said: \\\"she said\\\\\\\" I said \\\\\\\" \\\"\\n</code></p>",
        "id": 164852432,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1556949865
    },
    {
        "content": "<p>Perhaps <a href=\"https://doc.rust-lang.org/std/primitive.str.html#method.escape_default\" target=\"_blank\" title=\"https://doc.rust-lang.org/std/primitive.str.html#method.escape_default\">https://doc.rust-lang.org/std/primitive.str.html#method.escape_default</a> culd help?</p>",
        "id": 164856569,
        "sender_full_name": "matklad",
        "timestamp": 1556957447
    },
    {
        "content": "<p>That one will escape all things, including <code>\\n</code> etc.. i was thinking whether we only want to escape double quotes in doc comment de sugaring.</p>",
        "id": 164856997,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1556958285
    },
    {
        "content": "<p>Hm, I think we need to escape all things?</p>",
        "id": 164857114,
        "sender_full_name": "matklad",
        "timestamp": 1556958506
    },
    {
        "content": "<p>Like, doc comments are not guranteeed to be valid literals</p>",
        "id": 164857117,
        "sender_full_name": "matklad",
        "timestamp": 1556958524
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>/// invalid escape: \\u{zzzzz}\nfn foo()\n</pre></div>",
        "id": 164857129,
        "sender_full_name": "matklad",
        "timestamp": 1556958547
    },
    {
        "content": "<p>Good pointÔºÅ</p>",
        "id": 164857337,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1556958954
    },
    {
        "content": "<p>I am hacking on salsa now a bit, and I am pleasantly surprised by how far our support for macros has gone!</p>",
        "id": 164927762,
        "sender_full_name": "matklad",
        "timestamp": 1557076188
    },
    {
        "content": "<p><a href=\"https://youtu.be/akdZefuvBAQ\" target=\"_blank\" title=\"https://youtu.be/akdZefuvBAQ\">https://youtu.be/akdZefuvBAQ</a></p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"akdZefuvBAQ\" href=\"https://youtu.be/akdZefuvBAQ\" target=\"_blank\" title=\"https://youtu.be/akdZefuvBAQ\"><img src=\"https://i.ytimg.com/vi/akdZefuvBAQ/default.jpg\"></a></div>",
        "id": 164927763,
        "sender_full_name": "matklad",
        "timestamp": 1557076189
    },
    {
        "content": "<p>I blindly goto definition of a field, and it seems to find one inside a real-world syn-macro! (the text range is wrong, but that shouldn't be terribly hard to fix)</p>",
        "id": 164927810,
        "sender_full_name": "matklad",
        "timestamp": 1557076226
    },
    {
        "content": "<p>and goto definition works for macros by example...</p>",
        "id": 164927811,
        "sender_full_name": "matklad",
        "timestamp": 1557076237
    },
    {
        "content": "<p>wow!</p>",
        "id": 164927812,
        "sender_full_name": "matklad",
        "timestamp": 1557076239
    },
    {
        "content": "<p>really, working with syn is <strong>so</strong> much more pleasant now</p>",
        "id": 164930131,
        "sender_full_name": "matklad",
        "timestamp": 1557080311
    },
    {
        "content": "<p>Hey, finally i would start implement the new iterator approach of the <code>TokenSource</code> trait. (But i will be vacation this week, but let discuss an issues i don't know how to solve first. )<br>\nOne of the goals of the new api is to simplify tree traversal of subtree (The current <code>SubtreeSource</code> and <code>SubtreeWalker</code>). For <code>bump</code>, we can just push the current level and move to deeper subtree. The hard part is how do we handle <code>lookahead</code>.</p>\n<p>The trivial solution is we just look-ahead current level  tokens, which is how <code>rustc</code> works. And It should work even multiple byte punct and deeper subtree. If we find that it is a subtree, we just return the delimiter. It is because normally the usage of lookahead is finding what structure is next to current token. On the other hand, this method is very efficient as we only need to do <code>subtree.token_trees[n] </code>.</p>\n<p>However, this solution won't work in current implementation of ra  because of the <code>DOLLAR</code>tokens. <br>\nImagine the following codes:</p>\n<div class=\"codehilite\"><pre><span></span>foo $               $\n     1 + $     $ + 1\n          a + b\n</pre></div>\n\n\n<p>Let say the current token is <code>foo</code>, if we want to <code>lookahead(3)</code>, we have to walk the tree step by step. (check it is a subtree, go next level, and again). And it violates the goal to simplify the tree traversal of <code>subtree</code> algorithm.  </p>\n<p><span class=\"user-mention\" data-user-id=\"133169\">@matklad</span> Do you have any idea about this problem?</p>",
        "id": 164999878,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1557162755
    },
    {
        "content": "<p>Hm, interesting!</p>",
        "id": 164999951,
        "sender_full_name": "matklad",
        "timestamp": 1557162822
    },
    {
        "content": "<p>One thing we should do is to take a look at how <code>syn</code> handles parsing</p>",
        "id": 164999968,
        "sender_full_name": "matklad",
        "timestamp": 1557162840
    },
    {
        "content": "<p>our token-tree is very much a mirror of proc_macro2 tt</p>",
        "id": 165000021,
        "sender_full_name": "matklad",
        "timestamp": 1557162855
    },
    {
        "content": "<p>and syn does have some nice API for bounded lookahead</p>",
        "id": 165000032,
        "sender_full_name": "matklad",
        "timestamp": 1557162866
    },
    {
        "content": "<p>I think we need to bound lookahead by some amount</p>",
        "id": 165000061,
        "sender_full_name": "matklad",
        "timestamp": 1557162890
    },
    {
        "content": "<p>that is, get rid of general lookahead(n: usize)</p>",
        "id": 165000069,
        "sender_full_name": "matklad",
        "timestamp": 1557162900
    },
    {
        "content": "<p>and have separate lookahead1, lookahead2, lookahead3</p>",
        "id": 165000098,
        "sender_full_name": "matklad",
        "timestamp": 1557162916
    },
    {
        "content": "<p>We indeed shouldn't descent into trees with non-empty delimiters in lookahead</p>",
        "id": 165000112,
        "sender_full_name": "matklad",
        "timestamp": 1557162934
    },
    {
        "content": "<p>but for dollars it seems like we should do this?</p>",
        "id": 165000128,
        "sender_full_name": "matklad",
        "timestamp": 1557162948
    },
    {
        "content": "<p>and that means that yeah, lookahdead for dollars will need to go deeper</p>",
        "id": 165000189,
        "sender_full_name": "matklad",
        "timestamp": 1557162971
    },
    {
        "content": "<p>Then let me study how proc_macro2 tt works in this week first :)</p>",
        "id": 165000358,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1557163094
    },
    {
        "content": "<p>Yeah, I feel like i might need to take a closer look at syn as well</p>",
        "id": 165000399,
        "sender_full_name": "matklad",
        "timestamp": 1557163141
    },
    {
        "content": "<p>the API is just awesome</p>",
        "id": 165000413,
        "sender_full_name": "matklad",
        "timestamp": 1557163148
    },
    {
        "content": "<blockquote>\n<p>The API is just awesome</p>\n</blockquote>\n<p>Yes, and <code>quote</code> too. Sometimes while workings on ra_mbe, i wish i could use <code>quote!</code> to build a tt::subtree :)</p>",
        "id": 165000696,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1557163369
    },
    {
        "content": "<p>And FYI, i added macro expansion support in my wasm toy : <a href=\"https://web-ra-syntax-node.herokuapp.com/\" target=\"_blank\" title=\"https://web-ra-syntax-node.herokuapp.com/\">https://web-ra-syntax-node.herokuapp.com/</a></p>",
        "id": 165000870,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1557163485
    },
    {
        "content": "<p>Hm, why don't we add it to rust-analyzer proper?</p>",
        "id": 165001082,
        "sender_full_name": "matklad",
        "timestamp": 1557163619
    },
    {
        "content": "<p>I mean we can totally have \"expand macro\" action/intention</p>",
        "id": 165001109,
        "sender_full_name": "matklad",
        "timestamp": 1557163632
    },
    {
        "content": "<p>Is is possible to create another buffer (like Show SyntaxNode) and display the expanded selected macro invocation?</p>",
        "id": 165001402,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1557163809
    },
    {
        "content": "<p>We do this for \"show syntax tree\" command</p>",
        "id": 165001444,
        "sender_full_name": "matklad",
        "timestamp": 1557163844
    },
    {
        "content": "<p>So it is possible. Okay, let me add this to my TODO list :)</p>",
        "id": 165001628,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1557163961
    },
    {
        "content": "<blockquote>\n<p>And FYI, i added macro expansion support in my wasm toy : <a href=\"https://web-ra-syntax-node.herokuapp.com/\" target=\"_blank\" title=\"https://web-ra-syntax-node.herokuapp.com/\">https://web-ra-syntax-node.herokuapp.com/</a></p>\n</blockquote>\n<p>Oh that is neat!</p>",
        "id": 165001865,
        "sender_full_name": "Jeremy Kolb",
        "timestamp": 1557164146
    },
    {
        "content": "<p>Here is my study about how <code>syn</code> crate handle the tree-traversal problem:</p>\n<ul>\n<li>It just ignore Delimiter::None. <a href=\"https://github.com/dtolnay/syn/blob/b9cd1bbcf457b036d11f713abcb7b7fdfa09d3cb/src/buffer.rs#L210\" target=\"_blank\" title=\"https://github.com/dtolnay/syn/blob/b9cd1bbcf457b036d11f713abcb7b7fdfa09d3cb/src/buffer.rs#L210\">code</a></li>\n<li>The \"meat\" of the <code>TokenStream</code> is <a href=\"https://github.com/dtolnay/syn/blob/b9cd1bbcf457b036d11f713abcb7b7fdfa09d3cb/src/buffer.rs#L25-L46\" target=\"_blank\" title=\"https://github.com/dtolnay/syn/blob/b9cd1bbcf457b036d11f713abcb7b7fdfa09d3cb/src/buffer.rs#L25-L46\"><code>TokenBuffer</code></a> which can create a cheaply copyable cursor and can handle tree-traversal and look-ahead cheaply. However, the whole original <code>TokenTree</code> has to be converted to <code>TokenBuffer</code> first. I don't know whether we want to do it. </li>\n<li>It is a very rough idea:  how about we store the TokenStream in salsa instead of TokenTree ? What i mean is, instead of <code>ast_to_token_tree</code>in <code>syntax_bridge.rs</code>, we use <code>ast_to_token_stream</code>, and replace all <code>TokenTree</code> in macro related code to <code>hir</code> to use<code>TokenStream</code>.</li>\n</ul>",
        "id": 166140882,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1558412073
    },
    {
        "content": "<p>Hm, TokenStream is basically a TokenTree::Subtree with delimeters = None?</p>",
        "id": 166148725,
        "sender_full_name": "matklad",
        "timestamp": 1558423686
    },
    {
        "content": "<p>There's a feeling that <code>TokenStream</code> is a historical accident, which is not really required: <a href=\"https://github.com/rust-lang/rust/pull/49597#issuecomment-378409251\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/pull/49597#issuecomment-378409251\">https://github.com/rust-lang/rust/pull/49597#issuecomment-378409251</a></p>",
        "id": 166148751,
        "sender_full_name": "matklad",
        "timestamp": 1558423748
    },
    {
        "content": "<blockquote>\n<p>Hm, TokenStream is basically a TokenTree::Subtree with delimeters = None?</p>\n</blockquote>\n<p>I mean the proc_macro2 TokenStream, which you can think of a stream of tokens.</p>",
        "id": 166149250,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1558424357
    },
    {
        "content": "<p>Or we can name it as <code>TokenBuffer</code></p>",
        "id": 166149336,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1558424462
    },
    {
        "content": "<p>Yeah, this is what I am talking about</p>",
        "id": 166149483,
        "sender_full_name": "matklad",
        "timestamp": 1558424626
    },
    {
        "content": "<p>TokenStream is <em>just</em> a Vec of tokens, or Group without delimiters: <a href=\"https://github.com/alexcrichton/proc-macro2/blob/373fab08aefccdd76afa29798def239b67783881/src/fallback.rs#L19-L21\" target=\"_blank\" title=\"https://github.com/alexcrichton/proc-macro2/blob/373fab08aefccdd76afa29798def239b67783881/src/fallback.rs#L19-L21\">https://github.com/alexcrichton/proc-macro2/blob/373fab08aefccdd76afa29798def239b67783881/src/fallback.rs#L19-L21</a></p>",
        "id": 166149517,
        "sender_full_name": "matklad",
        "timestamp": 1558424642
    },
    {
        "content": "<p>so, it's not an essential type for the API</p>",
        "id": 166149544,
        "sender_full_name": "matklad",
        "timestamp": 1558424671
    },
    {
        "content": "<p>Sorry, it is my fault to express my idea not very well (My English is not good).   What i really mean is, we use <a href=\"https://github.com/dtolnay/syn/blob/6533607f91686545cb034d2838beea338d9d0742/src/buffer.rs#L41\" target=\"_blank\" title=\"https://github.com/dtolnay/syn/blob/6533607f91686545cb034d2838beea338d9d0742/src/buffer.rs#L41\"><code>TokenBuffer</code></a> to replace the <code>tt:TokenTree</code> stored in <code>hir</code> and named it as <code>TokenStream</code>. Although it is not an essential type for the API, but it allow us to prevent the conversion back and forth.  </p>\n<p>The original reason we have <code>SubtreeWalker</code> , is to prevent the whole tree conversion but i start to believe we should do the conversion anyway.</p>",
        "id": 166150669,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1558425844
    },
    {
        "content": "<p>Ah, yeah, that seems resonable!</p>",
        "id": 166151356,
        "sender_full_name": "matklad",
        "timestamp": 1558426409
    },
    {
        "content": "<p>Though, my understanding is that TokenBuffer uses unsafe heavily, for performance</p>",
        "id": 166151376,
        "sender_full_name": "matklad",
        "timestamp": 1558426436
    },
    {
        "content": "<p>I wonder if we should start with slower, but safe impl instead?</p>",
        "id": 166151432,
        "sender_full_name": "matklad",
        "timestamp": 1558426454
    },
    {
        "content": "<p>That is, can we replicate API of <code>TokenBuffer</code> in safe code?</p>",
        "id": 166151446,
        "sender_full_name": "matklad",
        "timestamp": 1558426476
    },
    {
        "content": "<p>I don't know  :) , but maybe i will try to make some prototype first.</p>\n<p>OTOH, what is your opinion about the priorities of following things about macros ?<br>\n1. Improve name resolutions of mbe, mainly introduce proper macro scopes for local macros (support macro_use)<br>\n2. Proper handling different kinds of macro invocations (stmts, expr, pat)<br>\n3. NavigationTarget api <br>\n4. <code>TokenSource</code> api improvement<br>\n5. Start hacking proc-macro</p>",
        "id": 166157624,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1558432266
    },
    {
        "content": "<p>I would like the following priority:</p>\n<ul>\n<li>refactoring, simplifying and future-proofing existing infrastructrue: long-term maintainence is always a good goal!</li>\n<li>making goto defeinition use the correct ranges (I feel this could be the first step towards supporting hygiene)</li>\n<li>making hygiene proof-of-concept</li>\n<li>making proc-macro proof-of-concept</li>\n<li>improving \"language coverage\" (ie. expand more macros, resolve more names, etc)</li>\n</ul>",
        "id": 166158186,
        "sender_full_name": "matklad",
        "timestamp": 1558432795
    },
    {
        "content": "<p>Okay :)</p>",
        "id": 166159795,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1558434310
    },
    {
        "content": "<p>To give a broader picture, the current goal of RLS-2.0 is to see what things are possible and not to make a perfect IDE. Experimenting with stuff like hygiene is better aligned with this goal than just making everything correct 100% :-)</p>",
        "id": 166159946,
        "sender_full_name": "matklad",
        "timestamp": 1558434463
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"sd\">/// `TokenSource` abstracts the source of the tokens parser operates one.</span>\n<span class=\"sd\">///</span>\n<span class=\"sd\">/// Hopefully this will allow us to treat text and token trees in the same way!</span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">TokenSource</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Cursor</span>: <span class=\"nc\">TokenCursor</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">current</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">TokenCursor</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"sd\">/// Lookahead 1 token</span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">Lookahead1</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">TokenCursor</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"sd\">/// Lookahead 2 tokens</span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">Lookahead2</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">TokenCursor</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"sd\">/// Lookahead 3 tokens</span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">Lookahead3</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">TokenCursor</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"sd\">/// bump cursor to next token</span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">bump</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"sd\">/// `TokenCursor` abstracts the cursor of `TokenSource` operates one.</span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">TokenCursor</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"sd\">/// What is the current token?</span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">token_kind</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">SyntaxKind</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"sd\">/// Is the current token joined to the next one (`&gt; &gt;` vs `&gt;&gt;`).</span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">is_token_joint_to_next</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">bool</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"sd\">/// Is the current token a specified keyword?</span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">is_keyword</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">kw</span>: <span class=\"kp\">&amp;</span><span class=\"kt\">str</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">bool</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>Do you think this new interface reasonable ? <span class=\"user-mention\" data-user-id=\"133169\">@matklad</span> <br>\nI remember you said you want to use <code>is_composite</code> instead of <code>is_token_joint_to_next</code>. However, it will push back the responsibility of recognizing composite tokens to <code>mbe</code> and text stream. I don't know whether it is good approach.</p>",
        "id": 166377386,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1558629191
    },
    {
        "content": "<p>Seems good to me!</p>",
        "id": 166377717,
        "sender_full_name": "matklad",
        "timestamp": 1558629419
    },
    {
        "content": "<p><code>TokenCursor</code> might be named better, it's not really a courrsor, because it doesn't move. Perhaps just <code>Token</code>?</p>",
        "id": 166377755,
        "sender_full_name": "matklad",
        "timestamp": 1558629456
    },
    {
        "content": "<p>I think <code>TokenCursor</code> might contain references, so it should be paramterized over a lifetime</p>",
        "id": 166377821,
        "sender_full_name": "matklad",
        "timestamp": 1558629483
    },
    {
        "content": "<p>Yeah, <code>Token</code> is much better name and that should be paramteriaed too. <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 166378058,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1558629683
    },
    {
        "content": "<p>maybe <code>is_token_joined_to_next</code>?</p>",
        "id": 166385831,
        "sender_full_name": "Jeremy Kolb",
        "timestamp": 1558635433
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"203366\">@Jeremy Kolb</span> Sure</p>",
        "id": 166469710,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1558716569
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133169\">@matklad</span> Do you think i should change the <code>Parser</code> to use <code>lookahead_1</code> instead of <code>nth</code> too ?</p>",
        "id": 166469829,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1558716649
    },
    {
        "content": "<p>Actually, I think it's better to just live nth, but panic if n is too large</p>",
        "id": 166469875,
        "sender_full_name": "matklad",
        "timestamp": 1558716692
    },
    {
        "content": "<p>Okay, and i faced another problem to change the TokenSource interface. The associated item of new TokenSource trait make every parser code to have to include the generic type argument. For example:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">fn</span> <span class=\"nf\">lhs</span><span class=\"p\">(</span><span class=\"n\">p</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">Parser</span><span class=\"p\">)</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>became:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">fn</span> <span class=\"nf\">lhs</span><span class=\"o\">&lt;</span><span class=\"n\">TT</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"w\"> </span><span class=\"n\">p</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">Parser</span><span class=\"o\">&lt;</span><span class=\"n\">TT</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span>: <span class=\"nc\">Token</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>I think i will be change it back to return (At least temp):</p>\n<div class=\"codehilite\"><pre><span></span>struct Token {\n  token_kind : SyntaxKind,\n  is_token_jointed_to_next: bool,\n}\n</pre></div>",
        "id": 166470332,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1558717060
    },
    {
        "content": "<p>yeah, it seems like we want concrete type there!</p>",
        "id": 166471358,
        "sender_full_name": "matklad",
        "timestamp": 1558717855
    },
    {
        "content": "<p>I want to work on the following item: </p>\n<blockquote>\n<p>making goto defeinition use the correct ranges (I feel this could be the first step towards supporting hygiene)</p>\n</blockquote>\n<p>If i understand correctly, we should start from refactoring \"NavTarget\" from the following comment in github, right ?</p>\n<blockquote>\n<p>review NavigationTarget and other stuff in display to make sure it doesn't try to do semantic analysis (this is not really macro-related)</p>\n</blockquote>\n<p>But i am a little bit  lost, what do you mean about semantic analysis ? Would you mind to guide me what should i start with ?</p>",
        "id": 167105559,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1559452218
    },
    {
        "content": "<p>sure, let me take a look...</p>",
        "id": 167113889,
        "sender_full_name": "matklad",
        "timestamp": 1559467346
    },
    {
        "content": "<p>The problem are <code>node,</code> <code>docs</code> and <code>description</code> methods</p>",
        "id": 167113957,
        "sender_full_name": "matklad",
        "timestamp": 1559467467
    },
    {
        "content": "<p>NavTarget intended to be a simple POD type to communicate with LSP, so it shouldn't really have any semantic meaning</p>",
        "id": 167113969,
        "sender_full_name": "matklad",
        "timestamp": 1559467512
    },
    {
        "content": "<p>The problem with these three methods is that they take <code>&amp;self</code>, <code>db</code> and do some computation</p>",
        "id": 167113970,
        "sender_full_name": "matklad",
        "timestamp": 1559467540
    },
    {
        "content": "<p>But they can't really relibly to extract doc strings, etc</p>",
        "id": 167114018,
        "sender_full_name": "matklad",
        "timestamp": 1559467587
    },
    {
        "content": "<p>what we should do is to add <code>docs</code> and <code>descripiton</code> as <strong>fields</strong> to NavTarget, and fill them in during construction, when we have much better understand what is the hir entity we construct a nav target for</p>",
        "id": 167114032,
        "sender_full_name": "matklad",
        "timestamp": 1559467644
    },
    {
        "content": "<p>And the reason is why this is related to macros is that <code>NavTarget::node</code> simply doesn't work if there are macros: it purposefully knows only range in the original file,  it can't featch the node from macro expansion</p>",
        "id": 167114166,
        "sender_full_name": "matklad",
        "timestamp": 1559467869
    },
    {
        "content": "<p>As <a href=\"https://github.com/rust-analyzer/rust-analyzer/pull/1388\" target=\"_blank\" title=\"https://github.com/rust-analyzer/rust-analyzer/pull/1388\">#1388</a> is landed, what is the next step ? Remove <code>HirId::as_original_file</code> ?</p>",
        "id": 167821747,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1560233003
    },
    {
        "content": "<p>I think that would be the last step</p>",
        "id": 167828733,
        "sender_full_name": "matklad",
        "timestamp": 1560240716
    },
    {
        "content": "<p>first, we need to provide an alternative, and only then remove the old way (migrating <strong>all</strong> ide_api to it, not only goto def)</p>",
        "id": 167828801,
        "sender_full_name": "matklad",
        "timestamp": 1560240753
    },
    {
        "content": "<p>Let's talk through what needs to be done here!</p>",
        "id": 167828810,
        "sender_full_name": "matklad",
        "timestamp": 1560240768
    },
    {
        "content": "<p>Let's say we invoke <code>goto_defeinition</code> and get a <code>Def</code> back, here: <a href=\"https://github.com/rust-analyzer/rust-analyzer/blob/3f5f9f0560fa662e770b607f05ec4881e4d011c5/crates/ra_ide_api/src/goto_definition.rs#L66\" target=\"_blank\" title=\"https://github.com/rust-analyzer/rust-analyzer/blob/3f5f9f0560fa662e770b607f05ec4881e4d011c5/crates/ra_ide_api/src/goto_definition.rs#L66\">https://github.com/rust-analyzer/rust-analyzer/blob/3f5f9f0560fa662e770b607f05ec4881e4d011c5/crates/ra_ide_api/src/goto_definition.rs#L66</a></p>",
        "id": 167829007,
        "sender_full_name": "matklad",
        "timestamp": 1560240956
    },
    {
        "content": "<p>That <code>Def</code> might originate in macro expansion, so we can't literally naviagate to it. Rather, we should navigate to the defining macro</p>",
        "id": 167829081,
        "sender_full_name": "matklad",
        "timestamp": 1560240996
    },
    {
        "content": "<p>That means the trick is setting <code>full_range</code>, <code>focus_range</code> and <code>file_id</code> correctly: <a href=\"https://github.com/rust-analyzer/rust-analyzer/blob/3f5f9f0560fa662e770b607f05ec4881e4d011c5/crates/ra_ide_api/src/display/navigation_target.rs#L23-L24\" target=\"_blank\" title=\"https://github.com/rust-analyzer/rust-analyzer/blob/3f5f9f0560fa662e770b607f05ec4881e4d011c5/crates/ra_ide_api/src/display/navigation_target.rs#L23-L24\">https://github.com/rust-analyzer/rust-analyzer/blob/3f5f9f0560fa662e770b607f05ec4881e4d011c5/crates/ra_ide_api/src/display/navigation_target.rs#L23-L24</a></p>",
        "id": 167829139,
        "sender_full_name": "matklad",
        "timestamp": 1560241059
    },
    {
        "content": "<p>The behavior we want here is that we should try to set ranges correctly, falling back to the range of the whole macro invocation if that fails</p>",
        "id": 167829474,
        "sender_full_name": "matklad",
        "timestamp": 1560241367
    },
    {
        "content": "<p>let me give an example</p>",
        "id": 167829479,
        "sender_full_name": "matklad",
        "timestamp": 1560241373
    },
    {
        "content": "<p>Let's say, we have</p>\n<div class=\"codehilite\"><pre><span></span>macro_rules! define_fn {\n   ($name:ident) =&gt; (fn $name() {})\n}\n\ndefine_fn!(\n    foo\n)\n\nfn main() {\n   foo() // &lt;- user presses goto definition here\n}\n</pre></div>",
        "id": 167829521,
        "sender_full_name": "matklad",
        "timestamp": 1560241435
    },
    {
        "content": "<p>In this case, we should arrive at</p>\n<div class=\"codehilite\"><pre><span></span>define_fn!(\n    &lt;*&gt;foo&lt;*&gt; // &lt;- this range\n)\n</pre></div>",
        "id": 167829578,
        "sender_full_name": "matklad",
        "timestamp": 1560241458
    },
    {
        "content": "<p>However, for </p>\n<div class=\"codehilite\"><pre><span></span>macro_rules! define_fn {\n   ($name:ident) =&gt; (fn $name() {})\n}\n\ndefine_fn!();\n\nfn main() {\n   foo()\n}\n</pre></div>\n\n\n<p>we should navigate to the whole of <code>define_fn!()</code>, because the identifier is created inside the macro</p>",
        "id": 167830673,
        "sender_full_name": "matklad",
        "timestamp": 1560242549
    },
    {
        "content": "<p>So the first step should be add a test for that, and implement <code>fn HirFileId::original_file_and_range(&amp;self, db: &amp;RootDatabase, range: TextRange) -&gt; (HirFileId, TextRange)</code>, right ?</p>",
        "id": 167830804,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1560242719
    },
    {
        "content": "<p>I think the logic for this should be as follows.</p>\n<p>When we expand a macro, we remember a mapping of ranges from macro expansion to a macro call (Vec&lt;(TextRange, TextRange)&gt;)</p>",
        "id": 167830805,
        "sender_full_name": "matklad",
        "timestamp": 1560242719
    },
    {
        "content": "<p>yeah, starting with a test is a good idea! Integration test in ra_ide_api would be best</p>",
        "id": 167830830,
        "sender_full_name": "matklad",
        "timestamp": 1560242750
    },
    {
        "content": "<p>as for API I am not exactly sure what we need it</p>",
        "id": 167830886,
        "sender_full_name": "matklad",
        "timestamp": 1560242771
    },
    {
        "content": "<p><code>original_file_and_range</code> is maybe ok as a high-level API, but I'd also like to think about how low-level API should work</p>",
        "id": 167830914,
        "sender_full_name": "matklad",
        "timestamp": 1560242810
    },
    {
        "content": "<p>Sure</p>",
        "id": 167830962,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1560242847
    },
    {
        "content": "<blockquote>\n<p>When we expand a macro, we remember a mapping of ranges from macro expansion to a macro call (Vec&lt;(TextRange, TextRange)&gt;)</p>\n</blockquote>\n<p>What is the relationship of it  with TokenId ?</p>",
        "id": 167830982,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1560242876
    },
    {
        "content": "<p>I think we need <code>HirFileId::parent_expansion() -&gt; Option&lt;(HirFileId, ExpansionInfo)&gt;</code>, as one-step expansion, will be better</p>",
        "id": 167831300,
        "sender_full_name": "matklad",
        "timestamp": 1560243211
    },
    {
        "content": "<p>the <code>ExpansionInfo</code> will have methods to map ranges in both directions</p>",
        "id": 167831308,
        "sender_full_name": "matklad",
        "timestamp": 1560243232
    },
    {
        "content": "<blockquote>\n<p>What is the relationship of it with TokenId ?</p>\n</blockquote>\n<p>So, <code>TokenId</code>s should be a way implement the mapping yeah</p>",
        "id": 167831368,
        "sender_full_name": "matklad",
        "timestamp": 1560243266
    },
    {
        "content": "<p>when we expand macro, we get a sort of <code>&amp;Token -&gt; &amp;Token</code> map, and we need to somehow reconstruct the ranges map our of that info</p>",
        "id": 167831383,
        "sender_full_name": "matklad",
        "timestamp": 1560243300
    },
    {
        "content": "<p>Seem like we already have the TextRange mapping ?<br>\n<a href=\"https://github.com/rust-analyzer/rust-analyzer/blob/b79e6294a68fd41f0a3dbd9eb907dfe99646d77e/crates/ra_mbe/src/syntax_bridge.rs#L12\" target=\"_blank\" title=\"https://github.com/rust-analyzer/rust-analyzer/blob/b79e6294a68fd41f0a3dbd9eb907dfe99646d77e/crates/ra_mbe/src/syntax_bridge.rs#L12\">https://github.com/rust-analyzer/rust-analyzer/blob/b79e6294a68fd41f0a3dbd9eb907dfe99646d77e/crates/ra_mbe/src/syntax_bridge.rs#L12</a></p>",
        "id": 167831405,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1560243325
    },
    {
        "content": "<p>It might be the case that we don't need to reconstruct the actual Vec&lt;TextRange, TextRange&gt; mapping</p>",
        "id": 167831409,
        "sender_full_name": "matklad",
        "timestamp": 1560243335
    },
    {
        "content": "<p>Yeah, <code>TokenMap</code> is a bit of that infra</p>",
        "id": 167831416,
        "sender_full_name": "matklad",
        "timestamp": 1560243359
    },
    {
        "content": "<p>but it never was finished :-)</p>",
        "id": 167831461,
        "sender_full_name": "matklad",
        "timestamp": 1560243372
    },
    {
        "content": "<p>How about that: Let me combined all information here, and <strong>TRY</strong> to make an implementation to pass that test I mentioned before, and then discuss it in that PR ?</p>",
        "id": 167831521,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1560243467
    },
    {
        "content": "<p>SGTM!</p>",
        "id": 167831578,
        "sender_full_name": "matklad",
        "timestamp": 1560243489
    },
    {
        "content": "<p>Hm, now that I think about it, we <em>used</em> to have this working some time ago</p>",
        "id": 167831591,
        "sender_full_name": "matklad",
        "timestamp": 1560243515
    },
    {
        "content": "<p>but then I've removed it, when we went to a proper macro expansion... Let me dig out some old codes...</p>",
        "id": 167831598,
        "sender_full_name": "matklad",
        "timestamp": 1560243538
    },
    {
        "content": "<p><a href=\"https://github.com/rust-analyzer/rust-analyzer/commit/5299a35e3dc484ea2e7d42cfeed89aee806425d3\" target=\"_blank\" title=\"https://github.com/rust-analyzer/rust-analyzer/commit/5299a35e3dc484ea2e7d42cfeed89aee806425d3\">https://github.com/rust-analyzer/rust-analyzer/commit/5299a35e3dc484ea2e7d42cfeed89aee806425d3</a></p>",
        "id": 167832212,
        "sender_full_name": "matklad",
        "timestamp": 1560244129
    },
    {
        "content": "<p>so this is a bit from that old implementation</p>",
        "id": 167832216,
        "sender_full_name": "matklad",
        "timestamp": 1560244137
    },
    {
        "content": "<p>it handles extend selection</p>",
        "id": 167832221,
        "sender_full_name": "matklad",
        "timestamp": 1560244142
    },
    {
        "content": "<p>and is probably the most interesting case for macro expanstion</p>",
        "id": 167832242,
        "sender_full_name": "matklad",
        "timestamp": 1560244155
    },
    {
        "content": "<p>it first takes original ranges, transforms it into a range inside the macro, runs expand selection in the macro, and maps the resulting range back</p>",
        "id": 167832310,
        "sender_full_name": "matklad",
        "timestamp": 1560244205
    },
    {
        "content": "<p>so, that's why you need bidirectional mapping</p>",
        "id": 167832318,
        "sender_full_name": "matklad",
        "timestamp": 1560244213
    },
    {
        "content": "<p>Um.. interesting. So we need something like this which replace TokenMap ? <br>\n<a href=\"https://github.com/rust-analyzer/rust-analyzer/blob/792899587647f5aa0293c2588173677682187c0a/crates/ra_analysis/src/macros.rs#L44\" target=\"_blank\" title=\"https://github.com/rust-analyzer/rust-analyzer/blob/792899587647f5aa0293c2588173677682187c0a/crates/ra_analysis/src/macros.rs#L44\">https://github.com/rust-analyzer/rust-analyzer/blob/792899587647f5aa0293c2588173677682187c0a/crates/ra_analysis/src/macros.rs#L44</a></p>",
        "id": 167832824,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1560244681
    },
    {
        "content": "<p>Or extend TokenMap.</p>",
        "id": 167832879,
        "sender_full_name": "Edwin Cheng",
        "timestamp": 1560244701
    },
    {
        "content": "<p>yeah, i think we need to extend token map. Or maybe build a ranges map from token map</p>",
        "id": 167833353,
        "sender_full_name": "matklad",
        "timestamp": 1560245106
    }
]