[
    {
        "content": "<p>I'm working on <a href=\"https://github.com/rust-analyzer/rust-analyzer/issues/11582\">https://github.com/rust-analyzer/rust-analyzer/issues/11582</a>, and I'm looking at <a href=\"https://github.com/rust-analyzer/rust-analyzer/blob/6bf6f4ff1dd8d342c061708041810c64fe983ab8/crates/hir_def/src/body/lower.rs#L485\">https://github.com/rust-analyzer/rust-analyzer/blob/6bf6f4ff1dd8d342c061708041810c64fe983ab8/crates/hir_def/src/body/lower.rs#L485</a></p>\n<div class=\"codehilite\"><pre><span></span><code> ast::Expr::Literal(e) =&gt; self.alloc_expr(Expr::Literal(e.kind().into()), syntax_ptr),\n</code></pre></div>\n<p>I wonder why do we use <code>e.kind()</code> here, or what's the reason behind converting an <code>ast::Literal</code> to <code>LiteralKind</code>? Will it be better to directly convert <code>ast::Literal</code> to <code>hir_def::expr::Expr::Literal</code>? </p>\n<p>We lose the \"literal value\" information by using <code>LiteralKind</code> intermediate, thereby causing the problem in <a href=\"https://github.com/rust-lang/rust/issues/11582\">#11582</a> - an empty string is used in <code>hir_def::expr:Expr::Literal</code> instead of the string \"literal value\".</p>",
        "id": 274071894,
        "sender_full_name": "tysg",
        "timestamp": 1646361642
    },
    {
        "content": "<blockquote>\n<p>We lose the \"literal value\" information by using LiteralKind intermediate, </p>\n</blockquote>\n<p>Not really, here's how literal kind is defined</p>",
        "id": 274403030,
        "sender_full_name": "matklad",
        "timestamp": 1646665199
    },
    {
        "content": "<p><a href=\"/user_uploads/4715/GuEIZ670lkw2ld-nKBpmU3y5/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/4715/GuEIZ670lkw2ld-nKBpmU3y5/image.png\" title=\"image.png\"><img src=\"/user_uploads/4715/GuEIZ670lkw2ld-nKBpmU3y5/image.png\"></a></div>",
        "id": 274403140,
        "sender_full_name": "matklad",
        "timestamp": 1646665219
    },
    {
        "content": "<p>It carries the underlying typed ast node (like ast::String)</p>",
        "id": 274403209,
        "sender_full_name": "matklad",
        "timestamp": 1646665239
    },
    {
        "content": "<p>well, we do looose value for char and byte, but that's the bug in <code>ast::LiteralKind</code></p>",
        "id": 274403255,
        "sender_full_name": "matklad",
        "timestamp": 1646665261
    },
    {
        "content": "<p>Thanks for the response! Do you think itâ€™s better, in this case, to skip the intermediate LiteralKind conversion?</p>",
        "id": 274408829,
        "sender_full_name": "tysg",
        "timestamp": 1646667538
    },
    {
        "content": "<p>I don't think so -- you'd have to re-do the \"downcasting\" logic yourself than. <code>.kind</code> is exactly there to do the first, light pass of analysis to figure out what kind of literal that is</p>",
        "id": 274409544,
        "sender_full_name": "matklad",
        "timestamp": 1646667887
    }
]