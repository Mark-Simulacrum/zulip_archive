[
    {
        "content": "<p>I think this is a bug. I don't get automatic <code>///</code> when I type enter after an empty line in the middle of the comment.<br>\n<a href=\"/user_uploads/4715/bKlLRoahFp1tYB30Jo1gE1my/bug.gif\" target=\"_blank\" title=\"bug.gif\">bug.gif</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/4715/bKlLRoahFp1tYB30Jo1gE1my/bug.gif\" target=\"_blank\" title=\"bug.gif\"><img src=\"/user_uploads/4715/bKlLRoahFp1tYB30Jo1gE1my/bug.gif\"></a></div>",
        "id": 188583663,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1582145213
    },
    {
        "content": "<p>You need to move the cursor to the right.</p>",
        "id": 188584700,
        "sender_full_name": "Laurențiu",
        "timestamp": 1582145947
    },
    {
        "content": "<p>It works after <code>/// </code>, but not after <code>///</code></p>",
        "id": 188584752,
        "sender_full_name": "Laurențiu",
        "timestamp": 1582145990
    },
    {
        "content": "<p><a href=\"https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/typing.rs#L49-L52\" target=\"_blank\" title=\"https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/typing.rs#L49-L52\">https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/typing.rs#L49-L52</a> this check seems suspicious</p>",
        "id": 188585154,
        "sender_full_name": "Laurențiu",
        "timestamp": 1582146267
    },
    {
        "content": "<p>The one above it, actually</p>",
        "id": 188616057,
        "sender_full_name": "Laurențiu",
        "timestamp": 1582184413
    },
    {
        "content": "<p>Yeah, I wonder why we add +1 there...</p>",
        "id": 188620233,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1582189479
    },
    {
        "content": "<p>PR is called <a href=\"https://github.com/rust-analyzer/rust-analyzer/pull/2350/files\" target=\"_blank\" title=\"https://github.com/rust-analyzer/rust-analyzer/pull/2350/files\">Don't continue line comments</a>, <span class=\"user-mention\" data-user-id=\"133169\">@matklad</span>  maybe you can tell?</p>",
        "id": 188620358,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1582189564
    },
    {
        "content": "<p>Well, the prefix is <code>///</code>, so the condition looks all right to me because it's using <code>&lt;</code></p>",
        "id": 188620386,
        "sender_full_name": "Laurențiu",
        "timestamp": 1582189594
    },
    {
        "content": "<p>I tried to remove the <code>+ 1</code> and it works, but inserts an extra space on the next line</p>",
        "id": 188620408,
        "sender_full_name": "Laurențiu",
        "timestamp": 1582189614
    },
    {
        "content": "<p>(which is normal, but annoying)</p>",
        "id": 188620419,
        "sender_full_name": "Laurențiu",
        "timestamp": 1582189633
    },
    {
        "content": "<p>The code below adds the prefix and a space, so I guess we should only add the space if the part to the right of the cursor doesn't start with a space</p>",
        "id": 188620535,
        "sender_full_name": "Laurențiu",
        "timestamp": 1582189735
    },
    {
        "content": "<p>I don't think this is annoying. Writing comments without putting spaces after <code>///</code> is generally a bad practice</p>",
        "id": 188620561,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1582189767
    },
    {
        "content": "<p>That's not what I meant. If I press enter here: <code>///&lt;|&gt; hello</code>, the added line will say <code>/// &lt;|&gt; hello</code> because it copies over the text to the right of the cursor but also adds the space. It should say <code>/// &lt;|&gt; hello</code> or <code>///&lt;|&gt; hello</code>. This is after removing that <code> + TextUnit::from(1)</code>, of course.</p>",
        "id": 188620669,
        "sender_full_name": "Laurențiu",
        "timestamp": 1582189843
    },
    {
        "content": "<p>An annoyance that I see is that on_enter bails when you don't have that space after <code>///</code> which is not rare when you have <code>\"files.trimTrailingWhitespace\": true,</code></p>",
        "id": 188620679,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1582189855
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"203546\">Laurențiu Nicola</span> <a href=\"#narrow/stream/185405-t-compiler.2Fwg-rls-2.2E0/topic/Enhanced.20typing/near/188620669\" title=\"#narrow/stream/185405-t-compiler.2Fwg-rls-2.2E0/topic/Enhanced.20typing/near/188620669\">said</a>:</p>\n<blockquote>\n<p>That's not what I meant. If I press enter here: <code>///&lt;|&gt; hello</code>, the added line will say <code>/// &lt;|&gt; hello</code> because it copies over the text to the right of the cursor but also adds the space. It should say <code>/// &lt;|&gt; hello</code> or <code>///&lt;|&gt; hello</code>.</p>\n</blockquote>\n<p>Hmm, that is controversial</p>",
        "id": 188620782,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1582189934
    },
    {
        "content": "<p>Actually typescript on_enter does the same</p>",
        "id": 188620872,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1582190030
    },
    {
        "content": "<p>When you press enter in doc comment it does unconditionally add that space</p>",
        "id": 188620925,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1582190049
    },
    {
        "content": "<p>TypeScript has block comments? <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 188620928,
        "sender_full_name": "Laurențiu",
        "timestamp": 1582190053
    },
    {
        "content": "<p>Yes, it does. Well, I guess we can remove that <code> + TextUnit::from(1)</code>, even though I'm not sure why.</p>",
        "id": 188620949,
        "sender_full_name": "Laurențiu",
        "timestamp": 1582190076
    },
    {
        "content": "<p>They are not in ECMAScript standard. It is a pervasive convention to write </p>\n<div class=\"codehilite\"><pre><span></span>/**\n *\n */\n</pre></div>",
        "id": 188620969,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1582190096
    },
    {
        "content": "<p>And I do like this style of comments more, Rust even supports it...</p>",
        "id": 188621021,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1582190147
    },
    {
        "content": "<p>Ah, actually I think it's correct to remove it. Sorry, bit tired. <code>offset &lt; start + len</code> means that the cursor is inside the prefix. They'll be equal when the cursor is on <code>///&lt;|&gt;</code></p>",
        "id": 188621171,
        "sender_full_name": "Laurențiu",
        "timestamp": 1582190269
    },
    {
        "content": "<p>Sure, tho let's get an approval from the author of this function anyway</p>",
        "id": 188621321,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1582190384
    },
    {
        "content": "<p>Also, one more flaw that I have noticed is that auto comment insertion doesn't work with multi-cursors:</p>",
        "id": 188687230,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1582238786
    },
    {
        "content": "<p><a href=\"/user_uploads/4715/iDBP7GGfp88X2ecu3gRppyp9/multi-cursor-enter.gif\" target=\"_blank\" title=\"multi-cursor-enter.gif\">multi-cursor-enter.gif</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/4715/iDBP7GGfp88X2ecu3gRppyp9/multi-cursor-enter.gif\" target=\"_blank\" title=\"multi-cursor-enter.gif\"><img src=\"/user_uploads/4715/iDBP7GGfp88X2ecu3gRppyp9/multi-cursor-enter.gif\"></a></div>",
        "id": 188687377,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1582238889
    },
    {
        "content": "<p>This is how it works in TS for comparison:<br>\n<a href=\"/user_uploads/4715/5Ztw6VNXxhiQbTNoKRzpyhD3/multi-cursor-enter-ts.gif\" target=\"_blank\" title=\"multi-cursor-enter-ts.gif\">multi-cursor-enter-ts.gif</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/4715/5Ztw6VNXxhiQbTNoKRzpyhD3/multi-cursor-enter-ts.gif\" target=\"_blank\" title=\"multi-cursor-enter-ts.gif\"><img src=\"/user_uploads/4715/5Ztw6VNXxhiQbTNoKRzpyhD3/multi-cursor-enter-ts.gif\"></a></div>",
        "id": 188687510,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1582239015
    },
    {
        "content": "<p>I'll try to look at TypeScript implementation and see what we can do here</p>",
        "id": 188687926,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1582239396
    },
    {
        "content": "<p>Because enhanced typing has aggregated quite some controversy already...</p>",
        "id": 188687946,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1582239418
    },
    {
        "content": "<p><a href=\"https://github.com/microsoft/vscode/blob/c93155b6439be83358a54df520cb508c814f1d9a/extensions/typescript-language-features/src/features/languageConfiguration.ts#L15-L52\" target=\"_blank\" title=\"https://github.com/microsoft/vscode/blob/c93155b6439be83358a54df520cb508c814f1d9a/extensions/typescript-language-features/src/features/languageConfiguration.ts#L15-L52\">This is</a> where they do it</p>",
        "id": 188688995,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1582240272
    },
    {
        "content": "<p>This happens not on lsp side...</p>",
        "id": 188689016,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1582240302
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133169\">@matklad</span> , should we do the same on our TypeScript extension? Since I heard LSP doesn't support pushing edits anyway... Otherwise users have a lot of problems with our custom on_enter implementation (<a href=\"https://github.com/rust-analyzer/rust-analyzer/issues/3253\" target=\"_blank\" title=\"https://github.com/rust-analyzer/rust-analyzer/issues/3253\">one</a>, <a href=\"https://github.com/rust-analyzer/rust-analyzer/issues/3013\" target=\"_blank\" title=\"https://github.com/rust-analyzer/rust-analyzer/issues/3013\">two</a>)...</p>",
        "id": 188689305,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1582240541
    },
    {
        "content": "<p>That's quite nifty</p>",
        "id": 188690185,
        "sender_full_name": "Laurențiu",
        "timestamp": 1582241294
    },
    {
        "content": "<p>We shall not use regular expressions for parsing Rust.</p>",
        "id": 188690192,
        "sender_full_name": "matklad",
        "timestamp": 1582241303
    },
    {
        "content": "<p>It arguably won't work in raw strings, but it's not so bad otherwise</p>",
        "id": 188690227,
        "sender_full_name": "Laurențiu",
        "timestamp": 1582241357
    },
    {
        "content": "<p>That is the API provided by VSCode, if you don't want native Regexp, we can implement our own since this is just an interface (but I wouldn''t)... Anyway this is not about parsing, just brainless text manipulations...</p>",
        "id": 188690698,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1582241826
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133169\">@matklad</span> , RLS <a href=\"https://github.com/rust-lang/rls-vscode/blob/ffe36f31b7a7105c6127f44e407dd828f94d1709/src/extension.ts#L500-L541\" target=\"_blank\" title=\"https://github.com/rust-lang/rls-vscode/blob/ffe36f31b7a7105c6127f44e407dd828f94d1709/src/extension.ts#L500-L541\">does the same thing</a>...</p>",
        "id": 188691199,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1582242282
    },
    {
        "content": "<p>I do strongly believe that using regular expressions in any capacity for analyzing a programming language is a step back. if we can't user the proper technology (incremental parser), we should push for removing the blockers for using the proper technology, and not implement a workaround. </p>\n<p>That's a tad too idealistic, and I agree that, to derive the most value to the most users <strong>now</strong> we should just go with what's default for VS Code (and, for example, completely ignore syntax highlighting until it is stabilized). I don't want to do that partially just because it goes against my personal value, and paritally becaues I think pushing for the right thing will lead to the more value overall.</p>",
        "id": 188691648,
        "sender_full_name": "matklad",
        "timestamp": 1582242710
    },
    {
        "content": "<p>Like, that's literary the original story behind rust-analyzer:</p>\n<p>I've implemented the \"Run this test\" in RLS. I had to use regular expression, because I didn't have access to the parser. As I had  a half-written Rust parser for libsyntax2 at that moment, I've decided that it would be  a good use of my time to push that parser to 80% ready state and to add an LSP on top of it¸just so that I can have one-shortcut test running functionality, based on a real parser:</p>\n<p><a href=\"https://github.com/rust-analyzer/rust-analyzer/commit/57518153147ad53639f16cc940d219dc582c550a\" target=\"_blank\" title=\"https://github.com/rust-analyzer/rust-analyzer/commit/57518153147ad53639f16cc940d219dc582c550a\">https://github.com/rust-analyzer/rust-analyzer/commit/57518153147ad53639f16cc940d219dc582c550a</a></p>",
        "id": 188691900,
        "sender_full_name": "matklad",
        "timestamp": 1582242918
    },
    {
        "content": "<p>Hm, I think the relevant commit is <a href=\"https://github.com/rust-analyzer/rust-analyzer/commit/36bd28633baf6015b767e9e70d2d53185271db50\" target=\"_blank\" title=\"https://github.com/rust-analyzer/rust-analyzer/commit/36bd28633baf6015b767e9e70d2d53185271db50\">https://github.com/rust-analyzer/rust-analyzer/commit/36bd28633baf6015b767e9e70d2d53185271db50</a></p>\n<p>Don't remember how they came along actually. Just re-learned that ruts-analyzer actually started as a native plugin for NodeJS, and not as a language server</p>",
        "id": 188692371,
        "sender_full_name": "matklad",
        "timestamp": 1582243309
    },
    {
        "content": "<p>What is libsyntax2?</p>",
        "id": 188692840,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1582243799
    },
    {
        "content": "<p>Anyway, I won't go against anybody's personal value (except when it gets to semicolons)...</p>",
        "id": 188692909,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1582243839
    },
    {
        "content": "<p>Another option would be to listen for OnDidChangeTextDocument event, but this is emitted when the change is already applied... I'll try to see what we can do with this once I have time... Also note that multicursor support should be added, but later after we fix current issues</p>",
        "id": 188693762,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1582244705
    },
    {
        "content": "<p>I am genuinely stuck. We cannot implemented onEnter through OnDidChangeTextDocument event, since it is emitted when the document already contains the inserted newline character, moreover VSCode automatically prepends some whitespace for auto indentation which doesn't help at all...</p>",
        "id": 188908757,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1582534431
    },
    {
        "content": "<p>Moreover it is async, so that the user may outtype our server in theory</p>",
        "id": 188908804,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1582534477
    },
    {
        "content": "<p>I looked over the native vscode source that deals with those regexps and they do it using private access to DOM, since extension host has no direct access to it</p>",
        "id": 188908910,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1582534610
    },
    {
        "content": "<p>Another way to fix this would be to stay using the keybinding approach (or overriding the \"default:type\" command) and adding workarounds for each reported bug in isolation</p>",
        "id": 188909252,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1582535021
    },
    {
        "content": "<p>(By the way, even our current approach uses async code so that the onEnter handler is not reentrant in theory, which may cause data races)</p>",
        "id": 188909437,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1582535186
    },
    {
        "content": "<p>My \"vote\" would go towards the regex solution. It's less elegant, but is better integrated with the editor, and should work fine most of the time (e.g. even if you're typing a doc comment in a raw string, maybe you actually want the comment to be automatically extended). We're not parsing the full language, only recognizing comments. We already have a bunch of heuristics for other things. And, uh, you <a href=\"https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/5233151#5233151\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/5233151#5233151\">can</a> parse HTML with regexes <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span>.</p>",
        "id": 188910939,
        "sender_full_name": "Laurențiu",
        "timestamp": 1582536642
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133169\">@matklad</span> , what if we copy the regexeps setup from the RLS source, keep our <code>on_enter</code> implementation in <code>typing.rs</code> handler for better times and create an issue at VSCode to request a better support for our use case?<br>\nThis way we fix the bugs and even get the feature of multiple cursors and support for star-like block comments, i.e.:</p>\n<div class=\"codehilite\"><pre><span></span>/**\n *\n */\n</pre></div>\n\n\n<p>which do not work with our impl now...<br>\nI am very sorry to ask you this once again, though I am not standing for this...</p>",
        "id": 188914506,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1582540163
    },
    {
        "content": "<p>I'd rather not add regexes .</p>",
        "id": 188914914,
        "sender_full_name": "matklad",
        "timestamp": 1582540566
    },
    {
        "content": "<p>More generally, all language specific language should be implemented on the server side.</p>",
        "id": 188917322,
        "sender_full_name": "matklad",
        "timestamp": 1582543127
    },
    {
        "content": "<p>Yeah, this is in ideal world, real world is complicated...</p>",
        "id": 188918083,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1582544003
    },
    {
        "content": "<p>Custom LSP request?</p>",
        "id": 188922231,
        "sender_full_name": "Jeremy Kolb",
        "timestamp": 1582548617
    },
    {
        "content": "<p>though i think we have that for on enter</p>",
        "id": 188922257,
        "sender_full_name": "Jeremy Kolb",
        "timestamp": 1582548651
    },
    {
        "content": "<p>is it really impossible to handle this asynchronously? wouldn't it be possible to insert whatever RA returns even if the user has typed a few more characters since then?</p>",
        "id": 188924554,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1582550319
    },
    {
        "content": "<p>it seems to me that that + doing nothing on error would alleviate most problems</p>",
        "id": 188924589,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1582550347
    },
    {
        "content": "<p>I think VS extensions run asynchronously, but I'm not sure if they can do edits like this. The issue is that you need to handle conflict resolution with later edits from the user.</p>",
        "id": 188924637,
        "sender_full_name": "Laurențiu",
        "timestamp": 1582550388
    },
    {
        "content": "<p>(+ some timeout, say 100ms, after which it doesn't really make sense to still insert it)</p>",
        "id": 188924645,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1582550394
    },
    {
        "content": "<blockquote>\n<p>The issue is that you need to handle conflict resolution with later edits from the user.</p>\n</blockquote>\n<p>I know, what I'm saying is that maybe that's not really too hard in this specific case?</p>",
        "id": 188924699,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1582550405
    },
    {
        "content": "<p>Maybe \"don't do anything if the user typed something\", but can we even detect it?</p>",
        "id": 188924807,
        "sender_full_name": "Laurențiu",
        "timestamp": 1582550468
    },
    {
        "content": "<p>maybe keeping track of the cursor position where the newline was inserted, and replacing that afterwards? Of course checking that it's still a newline at that time</p>",
        "id": 188925003,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1582550584
    },
    {
        "content": "<p>I doubt users will be able to type anything that actually conflicts if we respond reasonably fast; usually they will type a few more letters after the newline</p>",
        "id": 188925049,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1582550641
    },
    {
        "content": "<p>I'm also worried about the response time when the system is busy, It's annoying enough that my mouse cursor lags when I'm compiling something, but to be fair that's a Gnome thing, and <code>rust-analyzer</code>'s enhanced typing is relatively snappy even in those circumstances.</p>",
        "id": 188925138,
        "sender_full_name": "Laurențiu",
        "timestamp": 1582550697
    },
    {
        "content": "<p>of course we could also just put a hard timeout of 16ms on the request, if it really has to be sychronous</p>",
        "id": 188925143,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1582550703
    },
    {
        "content": "<p>I think the <em>idea</em> is that it'll always be very fast. It'll certainly be pretty useless if it's not, so we can just skip it in those situations. But if we do it synchronously, the typing would still be slowed down by our timeout</p>",
        "id": 188925275,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1582550765
    },
    {
        "content": "<p>Agreed. Ideally it's going to be fast, but that's sometimes outside of our control.</p>",
        "id": 188925338,
        "sender_full_name": "Laurențiu",
        "timestamp": 1582550808
    },
    {
        "content": "<p>I can't find it, but there's an older issue about <code>onEnter</code> where somebody linked a related Code issue about extensions slowing down typing like this.</p>",
        "id": 188925758,
        "sender_full_name": "Laurențiu",
        "timestamp": 1582551107
    },
    {
        "content": "<p><a href=\"https://github.com/rust-analyzer/rust-analyzer/issues/2331#issuecomment-556993009\" target=\"_blank\" title=\"https://github.com/rust-analyzer/rust-analyzer/issues/2331#issuecomment-556993009\">https://github.com/rust-analyzer/rust-analyzer/issues/2331#issuecomment-556993009</a></p>",
        "id": 188925833,
        "sender_full_name": "Laurențiu",
        "timestamp": 1582551140
    },
    {
        "content": "<p>That's pretty bad, if true</p>",
        "id": 188925916,
        "sender_full_name": "Laurențiu",
        "timestamp": 1582551225
    },
    {
        "content": "<blockquote>\n<p>is it really impossible to handle this asynchronously? </p>\n</blockquote>\n<p>In theory, you can do very cool stuff here with operational transofmation, where server-generated edits race with user-initiated ones. In practice, I've just fixed two <strong>huge</strong> bugs with this feature, where we've blocked onEnter altogether if there were server errors, and that should alleviate most of the problems I think</p>",
        "id": 188926113,
        "sender_full_name": "matklad",
        "timestamp": 1582551401
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133169\">@matklad</span> what do you think about DanTup's comment?</p>",
        "id": 188926153,
        "sender_full_name": "Laurențiu",
        "timestamp": 1582551446
    },
    {
        "content": "<blockquote>\n<p>that also means that any other extensions that have code handlers firing from that key press</p>\n</blockquote>\n<p>Not only that, but I imagine it could be any handler running in a different extension</p>",
        "id": 188926284,
        "sender_full_name": "Laurențiu",
        "timestamp": 1582551575
    },
    {
        "content": "<p>Could our new infra with <code>onEnter</code> keypress alleviate this issue?</p>",
        "id": 188926424,
        "sender_full_name": "matklad",
        "timestamp": 1582551684
    },
    {
        "content": "<p>Ultimately, I think this is an editor issue. VS Code simply does not have a proper architecture for synchroneous semantic things, like join/split lines, indentation-aware caret placement, etc. Ideally, it should be handled by either allowing truly synchronous actions, or by using OT-style async edit.</p>",
        "id": 188926767,
        "sender_full_name": "matklad",
        "timestamp": 1582551806
    },
    {
        "content": "<p>For the time being, I am not too worried about that: as long as we do the right thing on the server, we should be able to catch up with whatever editor advencement happen</p>",
        "id": 188926830,
        "sender_full_name": "matklad",
        "timestamp": 1582551848
    },
    {
        "content": "<p>Do you mean <a href=\"https://github.com/rust-lang/rust/issues/3289\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/3289\">#3289</a>?</p>",
        "id": 188926831,
        "sender_full_name": "Laurențiu",
        "timestamp": 1582551848
    },
    {
        "content": "<p>I don't think so. After all, when there's no <code>onEnter</code> handler installed, Code can do its regex thing synchronously. If even a single extension sets one up, the editor will have to wait after the extension host to process everything. I wouldn't expect things to improve soon.</p>",
        "id": 188927019,
        "sender_full_name": "Laurențiu",
        "timestamp": 1582552018
    },
    {
        "content": "<p>VSCode does place indentation even without our onenter</p>",
        "id": 188927359,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1582552284
    },
    {
        "content": "<p>It just doesn't place comment prefixes automatically</p>",
        "id": 188927379,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1582552309
    },
    {
        "content": "<p>Also I do have a problem on startup, it's mostly perceivable in debug build. Some time before the bootstrap is finished my enter key presses don't put newlines and after some lag time they appear all at once</p>",
        "id": 188927503,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1582552412
    },
    {
        "content": "<p>Yeah, I've seen that (in release builds)</p>",
        "id": 188927577,
        "sender_full_name": "Laurențiu",
        "timestamp": 1582552458
    },
    {
        "content": "<blockquote>\n<p>VSCode does place indentation even without our onenter</p>\n</blockquote>\n<p>It does it wrong</p>",
        "id": 188927613,
        "sender_full_name": "matklad",
        "timestamp": 1582552502
    },
    {
        "content": "<p>I agree this is an editor issue. VSCode decided to use process per extension approach and as less synchronicity as possible in order to keep the editor responsive disregarding bad designed extensions</p>",
        "id": 188927644,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1582552538
    },
    {
        "content": "<blockquote>\n<p>We measured the time taken for an ordinary (non-overridden) execution of the type command (which was roughly 20ms on my machine), vs. then calling 'default: type' command, which was always roughly 10x slower. Even though I am not familiar with the extensions API, this is puzzling, since these two calls should be doing exactly the same thing, yet calling executeCommand('default: type', ...) results in a much slower execution time of the default type command.</p>\n</blockquote>",
        "id": 188927829,
        "sender_full_name": "Laurențiu",
        "timestamp": 1582552682
    },
    {
        "content": "<p>Ugh. From <a href=\"https://github.com/microsoft/vscode/issues/65876\" target=\"_blank\" title=\"https://github.com/microsoft/vscode/issues/65876\">https://github.com/microsoft/vscode/issues/65876</a>, which is worth a read.</p>",
        "id": 188927869,
        "sender_full_name": "Laurențiu",
        "timestamp": 1582552683
    },
    {
        "content": "<p>Yeah, people do like to override the onInput handler <a href=\"https://github.com/microsoft/vscode/issues/65876\" target=\"_blank\" title=\"https://github.com/microsoft/vscode/issues/65876\">https://github.com/microsoft/vscode/issues/65876</a></p>",
        "id": 188928049,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1582552837
    },
    {
        "content": "<p>Tried setting this condition for on_enter keybinding:</p>\n<div class=\"codehilite\"><pre><span></span>&quot;when&quot;: &quot;editorLangId == rust &amp;&amp; !suggestWidgetVisible &amp;&amp; (!vim.active || vim.mode == &#39;Insert&#39;)&quot;\n</pre></div>\n\n\n<p>But Vscode either doesn't support parentheses here or has a bug, since when I run the extension the condition get's transformed into an invalid expression:<br>\n<a href=\"/user_uploads/4715/tIEiqSsGS7O1OBMIozVlpyK5/image.png\" target=\"_blank\" title=\"image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/4715/tIEiqSsGS7O1OBMIozVlpyK5/image.png\" target=\"_blank\" title=\"image.png\"><img src=\"/user_uploads/4715/tIEiqSsGS7O1OBMIozVlpyK5/image.png\"></a></div>",
        "id": 189053132,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1582659668
    },
    {
        "content": "<p>Created an issue at vscode repo regrading that: <a href=\"https://github.com/microsoft/vscode/issues/91473\" target=\"_blank\" title=\"https://github.com/microsoft/vscode/issues/91473\">https://github.com/microsoft/vscode/issues/91473</a></p>",
        "id": 189056444,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1582661622
    },
    {
        "content": "<p>So.. <code>editorLangId == rust &amp;&amp; !suggestWidgetVisible &amp;&amp; !vim.active || editorLangId == rust &amp;&amp; !suggestWidgetVisible &amp;&amp; vim.mode == 'Insert'</code>?</p>",
        "id": 189058434,
        "sender_full_name": "Laurențiu",
        "timestamp": 1582662925
    },
    {
        "content": "<p>Yeah also thought about that, I guess this is the only possible workaround...</p>",
        "id": 189059804,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1582663821
    },
    {
        "content": "<p>But does it work?</p>",
        "id": 189059854,
        "sender_full_name": "Laurențiu",
        "timestamp": 1582663863
    },
    {
        "content": "<p>Gonna try now</p>",
        "id": 189059859,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1582663875
    },
    {
        "content": "<p>Yes it does. Though I am not 100% sure it will fix all vscode-vim issues. One user <a href=\"https://github.com/rust-analyzer/rust-analyzer/issues/3013#issuecomment-586989889\" target=\"_blank\" title=\"https://github.com/rust-analyzer/rust-analyzer/issues/3013#issuecomment-586989889\">warned us</a> that vim extension provides text searching in insert mode which should also not trigger the newline...</p>",
        "id": 189060225,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1582664110
    },
    {
        "content": "<p>But I am a 0% vim user so won't bother that much...</p>",
        "id": 189060475,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1582664283
    },
    {
        "content": "<p>Ugh, how do I edit that condition? I tried to right-click and choose \"Change When Expression\", I can type (well, paste) it, but it doesn't seem to get committed on Enter</p>",
        "id": 189061005,
        "sender_full_name": "Laurențiu",
        "timestamp": 1582664675
    },
    {
        "content": "<p>Try this <a href=\"/user_uploads/4715/FKh9yTqPXnEbjy5OSfPgTiBC/image.png\" target=\"_blank\" title=\"image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/4715/FKh9yTqPXnEbjy5OSfPgTiBC/image.png\" target=\"_blank\" title=\"image.png\"><img src=\"/user_uploads/4715/FKh9yTqPXnEbjy5OSfPgTiBC/image.png\"></a></div>",
        "id": 189061080,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1582664742
    },
    {
        "content": "<p>What's <code>-rust-analyzer.onEnter</code>?</p>",
        "id": 189061249,
        "sender_full_name": "Laurențiu",
        "timestamp": 1582664855
    },
    {
        "content": "<p><a href=\"/user_uploads/4715/u4BeRaPopTG1AArHBskjb1W-/image.png\" target=\"_blank\" title=\"image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/4715/u4BeRaPopTG1AArHBskjb1W-/image.png\" target=\"_blank\" title=\"image.png\"><img src=\"/user_uploads/4715/u4BeRaPopTG1AArHBskjb1W-/image.png\"></a></div>",
        "id": 189061310,
        "sender_full_name": "Laurențiu",
        "timestamp": 1582664883
    },
    {
        "content": "<p>Not sure what happened <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 189061326,
        "sender_full_name": "Laurențiu",
        "timestamp": 1582664895
    },
    {
        "content": "<p>That's weird. I suppose that minus prefix for the command name disables the keybinding</p>",
        "id": 189061454,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1582664995
    },
    {
        "content": "<p>I have only one onEnter in my <strong>Default</strong> keybindnigs file (note that there are two of them: default an user-defined).</p>",
        "id": 189061595,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1582665087
    },
    {
        "content": "<p>Yeah, that's from my user-defined one</p>",
        "id": 189062850,
        "sender_full_name": "Laurențiu",
        "timestamp": 1582665857
    },
    {
        "content": "<p>I wanted to add <code>editorTextFocus</code> to that condition, but it doesn't seem to do much for the search case</p>",
        "id": 189062879,
        "sender_full_name": "Laurențiu",
        "timestamp": 1582665900
    },
    {
        "content": "<p>Also, this is very frustrating. I'm a mediocre Vim user, but the things I do in Vim don't work with this extension.</p>",
        "id": 189063036,
        "sender_full_name": "Laurențiu",
        "timestamp": 1582666026
    },
    {
        "content": "<p>I already created a <a href=\"https://github.com/rust-analyzer/rust-analyzer/pull/3308\" target=\"_blank\" title=\"https://github.com/rust-analyzer/rust-analyzer/pull/3308\">PR</a>, or doesn't it actually work with the search mode?</p>",
        "id": 189063066,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1582666048
    },
    {
        "content": "<p>In the search mode. Have you tried it?</p>",
        "id": 189063139,
        "sender_full_name": "Laurențiu",
        "timestamp": 1582666089
    },
    {
        "content": "<p>I barely managed to get to the insert mode from the normal mode, are you kiddin?</p>",
        "id": 189063220,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1582666153
    },
    {
        "content": "<p>lol</p>",
        "id": 189063250,
        "sender_full_name": "Laurențiu",
        "timestamp": 1582666186
    },
    {
        "content": "<p>Press <code>/</code>, then type the text to search</p>",
        "id": 189063261,
        "sender_full_name": "Laurențiu",
        "timestamp": 1582666199
    },
    {
        "content": "<p>So this is why I couldn't write a comment...</p>",
        "id": 189063384,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1582666298
    },
    {
        "content": "<p>Hmm, when I type kyrillic  letters in normal mode it doesn't enter the insert mode...</p>",
        "id": 189063496,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1582666401
    },
    {
        "content": "<p>But you can enter the search input only from normal mode, right? So it does work in this case...</p>",
        "id": 189063578,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1582666457
    },
    {
        "content": "<p>lol again</p>",
        "id": 189063601,
        "sender_full_name": "Laurențiu",
        "timestamp": 1582666479
    },
    {
        "content": "<p>You need to press <code>i</code> to go from normal to insert mode, then ESC to get back to normal mode</p>",
        "id": 189063618,
        "sender_full_name": "Laurențiu",
        "timestamp": 1582666499
    },
    {
        "content": "<p><code>/</code> for search only works in normal mode</p>",
        "id": 189063628,
        "sender_full_name": "Laurențiu",
        "timestamp": 1582666505
    },
    {
        "content": "<p>Lol, when I type <code>/</code> character it types the character, but then deletes it and the latency is pretty noticeable (especially when you hold the key for some time)<br>\n<a href=\"/user_uploads/4715/n23tlYtv5g9GkmwgX31HC8Sl/vim-bizzare.gif\" target=\"_blank\" title=\"vim-bizzare.gif\">vim-bizzare.gif</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/4715/n23tlYtv5g9GkmwgX31HC8Sl/vim-bizzare.gif\" target=\"_blank\" title=\"vim-bizzare.gif\"><img src=\"/user_uploads/4715/n23tlYtv5g9GkmwgX31HC8Sl/vim-bizzare.gif\"></a></div>",
        "id": 189063779,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1582666607
    },
    {
        "content": "<p>What? Does it go from normal to insert mode automatically?</p>",
        "id": 189063816,
        "sender_full_name": "Laurențiu",
        "timestamp": 1582666628
    },
    {
        "content": "<p>Yeah</p>",
        "id": 189063847,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1582666649
    },
    {
        "content": "<p>Try.. restarting Code? Or dunno. It's <code>i</code> on an US English keyboard, but I don't even know if you have that key...</p>",
        "id": 189063854,
        "sender_full_name": "Laurențiu",
        "timestamp": 1582666654
    },
    {
        "content": "<p>Maybe try changing your keyboard layout</p>",
        "id": 189063885,
        "sender_full_name": "Laurențiu",
        "timestamp": 1582666680
    },
    {
        "content": "<p>Of course it does!</p>",
        "id": 189063997,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1582666749
    },
    {
        "content": "<p><a href=\"/user_uploads/4715/j2dAteFSCjm4svmI_Sr5BmSH/IMG_20200225_233818.jpg\" target=\"_blank\" title=\"IMG_20200225_233818.jpg\">IMG_20200225_233818.jpg</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/4715/j2dAteFSCjm4svmI_Sr5BmSH/IMG_20200225_233818.jpg\" target=\"_blank\" title=\"IMG_20200225_233818.jpg\"><img src=\"/user_uploads/4715/j2dAteFSCjm4svmI_Sr5BmSH/IMG_20200225_233818.jpg\"></a></div>",
        "id": 189063999,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1582666749
    },
    {
        "content": "<p>That's... honestly better than the non-QWERTY layouts I've had to use.</p>",
        "id": 189064147,
        "sender_full_name": "Laurențiu",
        "timestamp": 1582666857
    },
    {
        "content": "<p>Anyway, I believe my amendment does work, since you can trigger the search only from the normal mode, right?</p>",
        "id": 189064922,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1582667385
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133169\">@matklad</span> can't we use <a href=\"https://code.visualstudio.com/api/language-extensions/programmatic-language-features#incrementally-format-code-as-the-user-types\" target=\"_blank\" title=\"https://code.visualstudio.com/api/language-extensions/programmatic-language-features#incrementally-format-code-as-the-user-types\">formatting on-type feature</a> to implement the on-enter functionality?</p>",
        "id": 189349444,
        "sender_full_name": "std::Veetaha",
        "timestamp": 1582922934
    },
    {
        "content": "<p>Last time I checked, no</p>",
        "id": 189349936,
        "sender_full_name": "matklad",
        "timestamp": 1582923227
    },
    {
        "content": "<p>Opened <a href=\"https://github.com/rust-analyzer/rust-analyzer/pull/6037\">https://github.com/rust-analyzer/rust-analyzer/pull/6037</a> to make it easier to re-enable this feature</p>",
        "id": 210572325,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1600461354
    }
]