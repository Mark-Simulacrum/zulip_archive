[
    {
        "content": "<p>Hey everyone, I had a look at <a href=\"https://github.com/rust-analyzer/rust-analyzer/issues/9591\">https://github.com/rust-analyzer/rust-analyzer/issues/9591</a> and would like to work on it. While thinking about the process I have a couple of doubts I want to get clarified:</p>\n<ul>\n<li>How will the assist get invoked? Issue mentions selection, but I have no idea if its possible, most other assists seem to use cursor position as the reference. If it possible, is there some guide? If not, where do we invoke it from(maybe from the struct/func def)?</li>\n<li>On what node types can we invoke it? struct and function?</li>\n<li>Lets say we are doing it for a struct, as mentioned in issue, will it mean taking all impl blocks of that struct(even from different files)?</li>\n</ul>",
        "id": 245946848,
        "sender_full_name": "Fenil Jain",
        "timestamp": 1626261876
    },
    {
        "content": "<p>\"Extract type alias\" uses the current selection</p>",
        "id": 245946994,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1626261983
    },
    {
        "content": "<p>the new assist should work on any collection of items, I think</p>",
        "id": 245947044,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1626262020
    },
    {
        "content": "<p>Hey, what could be the best way to rename a given struct/function/enum, etc. over all instances, I was trying to do it with to_def finding refs, and then trying to replace, but it seems to be a lot of work, I guessed I will confirm once.</p>",
        "id": 247849291,
        "sender_full_name": "Fenil Jain",
        "timestamp": 1627809148
    },
    {
        "content": "<p>Yes, going with <code>to_def</code> and then finding references seems like the correct approach for this</p>",
        "id": 247851234,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1627812199
    },
    {
        "content": "<p>Hey, what could be the best way to resolving imports in this case. I would have to move/retain/duplicate imports according to the content selected for extraction in new module, so there could be references I would have to shift to new module, or keep in both, new module and container module. Any reference I could be guided to?</p>",
        "id": 248592159,
        "sender_full_name": "Fenil Jain",
        "timestamp": 1628244610
    },
    {
        "content": "<p>Hmm, you probably want to do usage searches of all the items in your selection</p>",
        "id": 248594993,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1628246045
    },
    {
        "content": "<p>So basically you want to go through all NameRefs in your selection, turn them to hir nodes via <code>NameRefClass::classify</code>, then do <a href=\"https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ide_db/src/search.rs#L307\">usage searches</a> on them with the file as a scope, that way you can check if you find imports in the current file, as well as whether this name ref is used outside of your selection</p>",
        "id": 248595147,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1628246172
    },
    {
        "content": "<p>Limiting the search to your file cna be done with <a href=\"https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ide_db/src/search.rs#L334-L336\">https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ide_db/src/search.rs#L334-L336</a></p>",
        "id": 248595167,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1628246193
    },
    {
        "content": "<p>Similar thing can be applied to <code>Name</code>s since you would move those definitions you want to know what paths to fix up</p>",
        "id": 248595189,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1628246218
    },
    {
        "content": "<p>I have trying to implement what you said, there are some problems I am facing, this is one of my test-cases:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">                </span><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">collections</span>::<span class=\"n\">HashMap</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">                </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">PublicStruct</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"n\">field</span>: <span class=\"nc\">PrivateStruct</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">                </span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">PublicStruct</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">new</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                        </span><span class=\"bp\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">field</span>: <span class=\"nc\">PrivateStruct</span>::<span class=\"n\">new</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">                </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_s</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">PrivateStruct</span>::<span class=\"n\">new</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">                </span><span class=\"cp\">$</span><span class=\"mi\">0</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"k\">struct</span> <span class=\"nc\">PrivateStruct</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"n\">inner</span>: <span class=\"nc\">HashMap</span><span class=\"o\">&lt;</span><span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">                </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">PrivateStruct1</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">inner</span>: <span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">                </span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">PrivateStruct</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"k\">fn</span> <span class=\"nf\">new</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                         </span><span class=\"n\">PrivateStruct</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">inner</span>: <span class=\"nc\">HashMap</span>::<span class=\"n\">new</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">                </span><span class=\"k\">fn</span> <span class=\"nf\">bar</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">i32</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"mi\">2</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"cp\">$</span><span class=\"mi\">0</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>In this I want to detect and use HashMap, but it neither passes in Name::classify or NameRef::classify</p>\n<p>Is there something I am doing wrong? Or there is some other way I should approach this?</p>",
        "id": 248835009,
        "sender_full_name": "Fenil Jain",
        "timestamp": 1628510294
    },
    {
        "content": "<p>Sorry for the ping, <span class=\"user-mention\" data-user-id=\"300586\">@Lukas Wirth</span> any idea about this?</p>",
        "id": 249024569,
        "sender_full_name": "Fenil Jain",
        "timestamp": 1628623673
    },
    {
        "content": "<p>Oh sorry I missed this, and don't worry, pinging me is fine</p>",
        "id": 249025143,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1628623905
    },
    {
        "content": "<p>test's do not have the std/core sources so HashMap doesn't exist in the test fixture here</p>",
        "id": 249025256,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1628623937
    },
    {
        "content": "<p>so instead you could just add a </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">mod</span> <span class=\"nn\">std</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">mod</span> <span class=\"nn\">collections</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">HashMap</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 249025355,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1628623980
    },
    {
        "content": "<p>Hey, so I have been looking at other import related code, I am still not 100% sure, what is the best way to get the complete use statement from a path/path segment. So after extracting path / path-segment from above method. I can surely remove them, but then I would also need to get the complete usetree till there(more precisely each path till given search path) so that I can place it in the new module. Is this the right way to approach this, or there could be something else?</p>",
        "id": 249220722,
        "sender_full_name": "Fenil Jain",
        "timestamp": 1628766412
    },
    {
        "content": "<p>So basically you got a path segment in a use tree, and you want to reconstruct the actual path the segment is part of right?</p>",
        "id": 249224346,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1628769087
    },
    {
        "content": "<p>as in</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">foo</span>::<span class=\"p\">{</span><span class=\"n\">bar</span>::<span class=\"p\">{</span><span class=\"n\">Baz</span><span class=\"p\">}};</span><span class=\"w\"></span>\n</code></pre></div>\n<p>You want to extract the path <code>foo::bar::Baz</code> for <code>Baz</code>?</p>",
        "id": 249224393,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1628769122
    },
    {
        "content": "<p>Yeah that's right, I also wanted to confirm if that's the right way, or I can do something else too....when I had a look at auto_import resolve they formed the ModPath and then called mod_path_to_ast to get this tree easily.</p>",
        "id": 249225053,
        "sender_full_name": "Fenil Jain",
        "timestamp": 1628769529
    },
    {
        "content": "<p>Reconstructing the imports by walking the use tree up seems fine to me.</p>",
        "id": 249225707,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1628769942
    },
    {
        "content": "<p>But you can also try using <code>Module::find_use_path_prefixed</code> since you have the items you want to import</p>",
        "id": 249225774,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1628769967
    },
    {
        "content": "<p>Interestingly find_use_path_prefixed gives self::&lt;Type&gt;, most probably because it is already imported in the current module, and as the new module will be made after this(along with all other changes), there is no way to scope it to new module.</p>",
        "id": 249230575,
        "sender_full_name": "Fenil Jain",
        "timestamp": 1628772988
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 249234320,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1628774871
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 249234383,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1628774892
    },
    {
        "content": "<p>Oh wait now I see what you mean</p>",
        "id": 249234428,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1628774920
    },
    {
        "content": "<p>Ye, that might make this not work then</p>",
        "id": 249234445,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1628774934
    },
    {
        "content": "<p>Hey, I got the import path from path keyword and now I was trying to remove that import for one of the usecases, so I found the range to remove and called builder.delete() but I get this: \" assertion failed: check_disjoint(indels) \", any idea about it?</p>",
        "id": 249360210,
        "sender_full_name": "Fenil Jain",
        "timestamp": 1628861353
    },
    {
        "content": "<p>that means the edits you are creating are overlapping</p>",
        "id": 249365573,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1628864188
    },
    {
        "content": "<p>basically you are trying to remove/replace a certain part of the source twice which isn't valid</p>",
        "id": 249365671,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1628864249
    },
    {
        "content": "<p>Hey, is there a way to change ast in place, to explain better, till now I have been changing visibility, resolving references and imports, without extracting the actual module. Now as I am trying to extract a new module, I got the the blockexpr as its body, but now instead of changing it in real code, I have to change this ast::BlockExpr, is this the right way to do it? If yes, how to do it?</p>",
        "id": 249452774,
        "sender_full_name": "Fenil Jain",
        "timestamp": 1628936294
    },
    {
        "content": "<p>take a look at the <code>ted</code> module and hows its being used</p>",
        "id": 249452984,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1628936635
    },
    {
        "content": "<p>basically you can <code>clone_for_update</code> a node which gives you back a node you can modify</p>",
        "id": 249453022,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1628936647
    },
    {
        "content": "<p>Take a look at the <code>inline_call</code> assist which uses this to replace things inside the function body that is being inlined</p>",
        "id": 249453110,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1628936815
    },
    {
        "content": "<p>i think thats closest to what yo uwant right now</p>",
        "id": 249453111,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1628936823
    },
    {
        "content": "<p>I'll have a look, thnx :)</p>",
        "id": 249453160,
        "sender_full_name": "Fenil Jain",
        "timestamp": 1628936895
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>the trait bound `syntax::ast::Visibility: Element` is not satisfied\nthe trait `Element` is not implemented for `syntax::ast::Visibility`\n</code></pre></div>\n<p>I wanted to change visibility for nodes, I checked other visibility assists too, I dont think they had any use of ted.</p>",
        "id": 249453946,
        "sender_full_name": "Fenil Jain",
        "timestamp": 1628938302
    },
    {
        "content": "<p>only a few assists use <code>ted</code> currently as its a new api that got introduced a few months ago</p>",
        "id": 249454791,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1628939597
    },
    {
        "content": "<p>when using ted you usually have to call <code>syntax()</code> on the nodes you wanna replace as it works on <code>SyntaxNode</code>/<code>SyntaxToken</code> and not on the strictly typed syntax nodes</p>",
        "id": 249454849,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1628939650
    },
    {
        "content": "<p>Oh got it, my bad...</p>",
        "id": 249457638,
        "sender_full_name": "Fenil Jain",
        "timestamp": 1628944148
    },
    {
        "content": "<p>Not your fault, I dont think we have that part documented too well yet, not sure</p>",
        "id": 249457879,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1628944516
    },
    {
        "content": "<p>Hey, I tried to get things work with ted, I looked around at another code and all, but couldnt figure out why there's no error but at the same time no update too.....I feel like I am doing some silly mistake, not sure.....if possible could u have a look here:</p>\n<p>This is processing the ast::Struct part:<br>\n<a href=\"https://github.com/feniljain/rust-analyzer/blob/a0c9662b7ee512c1a3ac0da53602c8c4c2f5e3fb/crates/ide_assists/src/handlers/extract_module.rs#L160-L188\">https://github.com/feniljain/rust-analyzer/blob/a0c9662b7ee512c1a3ac0da53602c8c4c2f5e3fb/crates/ide_assists/src/handlers/extract_module.rs#L160-L188</a></p>\n<p>And I am updating this visibility using ted over here:<br>\n<a href=\"https://github.com/feniljain/rust-analyzer/blob/extract_module/crates/ide_assists/src/handlers/extract_module.rs#L601-L608\">https://github.com/feniljain/rust-analyzer/blob/extract_module/crates/ide_assists/src/handlers/extract_module.rs#L601-L608</a></p>",
        "id": 249561097,
        "sender_full_name": "Fenil Jain",
        "timestamp": 1629102156
    },
    {
        "content": "<p>Do you mean with <code>no update</code> that <code>println!(\"{:?}\", node_kw.text());</code> isnt printing anything different?</p>",
        "id": 249569223,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1629108051
    },
    {
        "content": "<p>you are only printing the keywords text there, so that wont include the visibility mod</p>",
        "id": 249569255,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1629108071
    },
    {
        "content": "<p>Nope I meant they should show up when running test...</p>",
        "id": 249569438,
        "sender_full_name": "Fenil Jain",
        "timestamp": 1629108164
    },
    {
        "content": "<p>Oh, you are <code>clone_for_update</code>ing the nodes you are modifying each instead of the top node if I see this correctly</p>",
        "id": 249569892,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1629108436
    },
    {
        "content": "<p>you want to <code>clone_for_update</code> the body <code>ast::BlockExpr</code> once, and then modify that/its children nodes</p>",
        "id": 249569937,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1629108475
    },
    {
        "content": "<p>if you <code>clone_for_update</code> the children you wont modify the block expr, just the freshly cloned children which you are discarding again</p>",
        "id": 249570011,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1629108508
    },
    {
        "content": "<p>yeah I tried that too, but ig last time I tried I did something wrong, so this time I resolved the imports firsts, then I took the body_stmts and converted it to body, and cloned it for update, then I sent a reference to that body and now I am using that. I get this error in the process:</p>\n<p>thread 'handlers::extract_module::tests::test_extract_module' panicked at 'called <code>Option::unwrap()</code> on a <code>None</code> value', /home/feniljain/.cargo/registry/src/github.com-1ecc6299db9ec823/rowan-0.13.0-pre.7/src/cursor.rs:1226:64</p>\n<p>It's not very helpful, do u have any idea about this?</p>",
        "id": 249581509,
        "sender_full_name": "Fenil Jain",
        "timestamp": 1629116838
    },
    {
        "content": "<p>That panic indicates that you are iterating(or going through its children in some form) a node while mutating it which is a no go</p>",
        "id": 249581818,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1629117019
    },
    {
        "content": "<p>You can circumvent that problem by first fetching all nodes and their replacements and collecting those pairs into a vec, then do the actual replacement last by going through the vec</p>",
        "id": 249581900,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1629117079
    },
    {
        "content": "<p>most assist that run into that problem do it that way</p>",
        "id": 249581913,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1629117088
    },
    {
        "content": "<p><code>cargo clippy -- -A clippy::all -W clippy::needless_collect</code> will show you those XD</p>",
        "id": 249582385,
        "sender_full_name": "Laurențiu",
        "timestamp": 1629117388
    },
    {
        "content": "<p>That worries me that those might get \"fixed\" by accident then <span aria-label=\"grimacing\" class=\"emoji emoji-1f62c\" role=\"img\" title=\"grimacing\">:grimacing:</span></p>",
        "id": 249583121,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1629117824
    },
    {
        "content": "<p>Let's say I clone the node which has to be operated upon, would the update still reflect?</p>",
        "id": 249732941,
        "sender_full_name": "Fenil Jain",
        "timestamp": 1629213028
    },
    {
        "content": "<p>Yes basically, if you <code>clone_for_update</code> a node then modifications on its children will be reflected in this original node</p>",
        "id": 249733259,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1629213179
    },
    {
        "content": "<p>So <code>clone</code>-ing a node that has been <code>clone_for_update</code>d will still be linked to this mutable clone just fine</p>",
        "id": 249733328,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1629213215
    },
    {
        "content": "<p>I meant cloning it before clone_for_update</p>",
        "id": 249733429,
        "sender_full_name": "Fenil Jain",
        "timestamp": 1629213258
    },
    {
        "content": "<p>if you clone a node and then do <code>clone_for_update</code> then only the clone will reflect the changes</p>",
        "id": 249733492,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1629213296
    },
    {
        "content": "<p>the original will still be an immutable version</p>",
        "id": 249733516,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1629213304
    },
    {
        "content": "<p>Umm...okay maybe help me through this, so you said, you can collect the nodes you want to operate on and then do ted modifications on them right? That means taking references <code>&amp;SyntaxNode</code> in a vec and then <code>clone_for_update</code> the <code>BlockExpr</code>, after this go over the vec and apply the ted operation right?</p>",
        "id": 249734322,
        "sender_full_name": "Fenil Jain",
        "timestamp": 1629213686
    },
    {
        "content": "<p>You want to <code>clone_for_update</code> the node you wanna modify first, then collect the children and their replacements of that node, after collecting them all you <em>then</em> want to apply the replacements via <code>ted</code></p>",
        "id": 249735650,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1629214247
    },
    {
        "content": "<p><a href=\"https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ide_assists/src/handlers/convert_bool_then.rs#L37-L106\">https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ide_assists/src/handlers/convert_bool_then.rs#L37-L106</a></p>",
        "id": 249735751,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1629214291
    },
    {
        "content": "<p>See that assist for an example</p>",
        "id": 249735778,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1629214304
    },
    {
        "content": "<p>It first <code>clone_for_update</code>s the expression(<code>closure_body</code>), then iterates over it collecting the replacement pairs and after doing so it applies them all.</p>",
        "id": 249735919,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1629214344
    },
    {
        "content": "<p>Yup got it, I understood it wrong first time, thnx a lot <span aria-label=\"raised hands\" class=\"emoji emoji-1f64c\" role=\"img\" title=\"raised hands\">:raised_hands:</span></p>",
        "id": 249740051,
        "sender_full_name": "Fenil Jain",
        "timestamp": 1629216125
    },
    {
        "content": "<p><a href=\"https://github.com/rust-analyzer/rust-analyzer/pull/9939\">https://github.com/rust-analyzer/rust-analyzer/pull/9939</a></p>",
        "id": 249773208,
        "sender_full_name": "Fenil Jain",
        "timestamp": 1629231396
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"300586\">@Lukas Wirth</span>  In PR comments you were suggesting me to use ItemList instead of BlockExpr right?</p>",
        "id": 249833463,
        "sender_full_name": "Fenil Jain",
        "timestamp": 1629284478
    },
    {
        "content": "<p>Either that or you keep the items in a vec instead, something similar to how its done in extract_function <br>\n<a href=\"https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ide_assists/src/handlers/extract_function.rs#L283-L287\">https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ide_assists/src/handlers/extract_function.rs#L283-L287</a><br>\n<a href=\"https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ide_assists/src/handlers/extract_function.rs#L145-L169\">https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ide_assists/src/handlers/extract_function.rs#L145-L169</a></p>",
        "id": 249833601,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1629284574
    },
    {
        "content": "<p>where BlockExpr would be ItemList for you</p>",
        "id": 249833618,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1629284591
    },
    {
        "content": "<p>and a Statement/Expression is an Item for you</p>",
        "id": 249833650,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1629284627
    },
    {
        "content": "<p>Hey, sorry I had to go on a hiatus due to personal reasons, I started to work on this again, I have made all the changes suggested on PR, while completing that process I noticed a few import related issues, I am currently trying to fix them, and in one of the tests I am trying to get usages of a trait-bound in new module, with its definition in main module, does usages not consider its trait definition, coz I am not able to get it in .usages()</p>",
        "id": 252131132,
        "sender_full_name": "Fenil Jain",
        "timestamp": 1630908805
    },
    {
        "content": "<p>Hey <span class=\"user-mention\" data-user-id=\"300586\">@Lukas Wirth</span> as you are back now, maybe any ideas on this?</p>",
        "id": 253400702,
        "sender_full_name": "Fenil Jain",
        "timestamp": 1631706909
    },
    {
        "content": "<p>Will take a look, gotta refresh my memory of this first</p>",
        "id": 253401843,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1631707422
    },
    {
        "content": "<p>Ah I see, usages only gives you back the, well, usages of something</p>",
        "id": 253404721,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1631708892
    },
    {
        "content": "<p>to get the definition source</p>",
        "id": 253404729,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1631708896
    },
    {
        "content": "<p>you need to go through the the HasSource trait, one moment</p>",
        "id": 253404756,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1631708909
    },
    {
        "content": "<p>This here, <a href=\"https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/hir/src/has_source.rs#L17-L20\">https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/hir/src/has_source.rs#L17-L20</a></p>",
        "id": 253404801,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1631708938
    },
    {
        "content": "<p>so if you got a definition <code>def</code>, you can get its usages via <code>def.usages().all()</code> while getting the source ast via <code>def.source()</code></p>",
        "id": 253404903,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1631708996
    },
    {
        "content": "<p>Oh I see, I assumed that part wrong, cool got it.</p>",
        "id": 253407570,
        "sender_full_name": "Fenil Jain",
        "timestamp": 1631710337
    },
    {
        "content": "<p>Okay so the Definition does not have HasSource trait implement upon, to give some context on what I am doing, this is a part of import resolve, I go over each name and nameref in selected region(new module), then I find usages to understand if it's references exist outside and inside module, and then act upon imports individually, like adding a super import or reconstructing import  from use stmt. What could be the best approach in this situation?</p>",
        "id": 253456153,
        "sender_full_name": "Fenil Jain",
        "timestamp": 1631727398
    },
    {
        "content": "<p>So you want to figure out in what module a definition lives in?</p>",
        "id": 253457095,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1631727742
    },
    {
        "content": "<p>Yeah, but while analyzing it would still have not changed to new module so we will always get the same parent module.</p>",
        "id": 253460373,
        "sender_full_name": "Fenil Jain",
        "timestamp": 1631728886
    },
    {
        "content": "<p>I don't think I follow, but don't you know where you are moving the things?</p>",
        "id": 253461171,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1631729194
    },
    {
        "content": "<p>Basically, you know that every definition you extract will move location into this new module, so that means you have to adjust all paths pointing to the item by inserting the module into the paths</p>",
        "id": 253461320,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1631729251
    },
    {
        "content": "<p>Or am I missing something here</p>",
        "id": 253461332,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1631729256
    },
    {
        "content": "<p>Hmmm...shall I just force-push on the PR? Most tests are failing due to indentation issue nothing more, I can then explain better maybe, with direct code extracts and tests itself......</p>",
        "id": 253463753,
        "sender_full_name": "Fenil Jain",
        "timestamp": 1631730251
    },
    {
        "content": "<p>sure</p>",
        "id": 253465352,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1631730898
    },
    {
        "content": "<p>This is the test which I need to pass: <a href=\"https://github.com/rust-analyzer/rust-analyzer/blob/b3f174df1d03878fec8fb9af35bbc04ab2caaa04/crates/ide_assists/src/handlers/extract_module.rs#L1266-L1312\">https://github.com/rust-analyzer/rust-analyzer/blob/b3f174df1d03878fec8fb9af35bbc04ab2caaa04/crates/ide_assists/src/handlers/extract_module.rs#L1266-L1312</a></p>\n<p>Over here I will explain the problem, so inside selection it checks all name and namerefs for import resolution, it reaches JustATrait now I need to find its usages + source to check if it exists inside and outside module, the explanation for it is here: <a href=\"https://github.com/rust-analyzer/rust-analyzer/blob/b3f174df1d03878fec8fb9af35bbc04ab2caaa04/crates/ide_assists/src/handlers/extract_module.rs#L1266-L1312\">https://github.com/rust-analyzer/rust-analyzer/blob/b3f174df1d03878fec8fb9af35bbc04ab2caaa04/crates/ide_assists/src/handlers/extract_module.rs#L1266-L1312</a></p>\n<p>Now in this function: <a href=\"https://github.com/rust-analyzer/rust-analyzer/blob/b3f174df1d03878fec8fb9af35bbc04ab2caaa04/crates/ide_assists/src/handlers/extract_module.rs#L488\">https://github.com/rust-analyzer/rust-analyzer/blob/b3f174df1d03878fec8fb9af35bbc04ab2caaa04/crates/ide_assists/src/handlers/extract_module.rs#L488</a>,  I get definitions and then I do usage search on them, I want to perform source search too, which currently isnt possible.....</p>",
        "id": 253470090,
        "sender_full_name": "Fenil Jain",
        "timestamp": 1631732721
    },
    {
        "content": "<p>I don't understand what a source search is supposed to be, you can get the definition via the <code>HasSource</code> trait, which yes isnt implemented on definition, but on the things inside the definition enum</p>",
        "id": 253498804,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1631745497
    },
    {
        "content": "<p>So if I see this right the problem you are having right now is figuring out the difference between a defs module and the module your extracting in right now? For the def you can just fetch it by calling <code>module</code> on it, for the other one you wanna do <code>sema.scope(node).module()</code> where node is some node of the things you are extracting</p>",
        "id": 253499278,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1631745741
    },
    {
        "content": "<p>Similarly if the modules do not differ, then you can fetch the source of the definition and check its text range, if its inside the selection then you are extracting the definition into the new module, if not then you aren't</p>",
        "id": 253499764,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1631745997
    },
    {
        "content": "<p>I have pushed the code with all the mentioned changes, I have added testcases, and different comments too. Do let me know if there are any changes you find suitable.</p>",
        "id": 255194176,
        "sender_full_name": "Fenil Jain",
        "timestamp": 1632825066
    },
    {
        "content": "<p>Hey <span class=\"user-mention\" data-user-id=\"300586\">@Lukas Wirth</span>, I just saw you self-assigned the issue, I wanted to know if you already began working on it? Coz I have refactored considerable amount, and would like to know if I could push that?</p>",
        "id": 255940809,
        "sender_full_name": "Fenil Jain",
        "timestamp": 1633256059
    },
    {
        "content": "<p>Feel free to push it, I did work a bit on it to familiarize myself with the idea of what the assist has to do but that is not connected to your PR directly</p>",
        "id": 255940860,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1633256138
    },
    {
        "content": "<p>Nice, please allow me to do it by the end of day, I am in middle of refactoring something in that.</p>",
        "id": 255941138,
        "sender_full_name": "Fenil Jain",
        "timestamp": 1633256443
    },
    {
        "content": "<p>Take your time</p>",
        "id": 255941602,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1633256914
    },
    {
        "content": "<p>I had a small doubt while applying the changes mentioned here:</p>\n<p><a href=\"https://github.com/rust-analyzer/rust-analyzer/pull/9939#discussion_r726108882\">https://github.com/rust-analyzer/rust-analyzer/pull/9939#discussion_r726108882</a></p>\n<p>So<code> field_list()</code> isnt a common method among ADT members and I wanted a simple reusable piece for ADT and that's why I used descendants to lower into the ast in search of <code>RecordFields</code>, should I just change it for all cases like, using <code>field_list()</code> and <code>record_field_list()</code> for respective members or it's okay to continue with <code>descendants()</code>?</p>",
        "id": 257154329,
        "sender_full_name": "Fenil Jain",
        "timestamp": 1634019043
    },
    {
        "content": "<p>I'd say swap to the field list functions, note that currently your code only handles <code>RecordFields</code> and not <code>TupleFields</code> which it should anyways. You can just pass them around in an <code>Either&lt;ast::RecordField, ast::TupleField&gt;</code> or cast them back to <code>SyntaxNode</code> if that makes things simpler.</p>",
        "id": 257156951,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1634021287
    },
    {
        "content": "<p>Hey, I pushed the changes, but I think as I was amending the og commit every time till now and now I made new commits and pushed it, the commits between this duration got included too, I tried to cherry pick these commits in a new branch and force-push to the existing one, so that I could have the commits I made, only in the PR, but It stated: \"everything up to date\" during that, and now I am confused what can I possibly do it fix it, any ideas regarding same?</p>",
        "id": 257176681,
        "sender_full_name": "Fenil Jain",
        "timestamp": 1634032358
    },
    {
        "content": "<p>Uh-oh</p>",
        "id": 257177377,
        "sender_full_name": "Laurențiu",
        "timestamp": 1634032738
    },
    {
        "content": "<p><a href=\"https://github.com/rust-analyzer/rust-analyzer/pull/9939/commits/7453346345008015c379f14e3cd139a6b9b650c2\">https://github.com/rust-analyzer/rust-analyzer/pull/9939/commits/7453346345008015c379f14e3cd139a6b9b650c2</a> does this contain everything you want?</p>",
        "id": 257177413,
        "sender_full_name": "Laurențiu",
        "timestamp": 1634032751
    },
    {
        "content": "<p>Nope there's other commits too which I pushed after resolving the reviews given</p>",
        "id": 257177591,
        "sender_full_name": "Fenil Jain",
        "timestamp": 1634032819
    },
    {
        "content": "<p><a href=\"https://github.com/rust-analyzer/rust-analyzer/pull/9939/commits/8f0edf73fd572c7a91f9f1bae0438b8f92e62d3d\">https://github.com/rust-analyzer/rust-analyzer/pull/9939/commits/8f0edf73fd572c7a91f9f1bae0438b8f92e62d3d</a></p>\n<p><a href=\"https://github.com/rust-analyzer/rust-analyzer/pull/9939/commits/436a5a4be2ad544342fbcc73c52d94b5d9bf9efc\">https://github.com/rust-analyzer/rust-analyzer/pull/9939/commits/436a5a4be2ad544342fbcc73c52d94b5d9bf9efc</a></p>\n<p>These are the ones containing final fixes</p>",
        "id": 257177666,
        "sender_full_name": "Fenil Jain",
        "timestamp": 1634032855
    },
    {
        "content": "<p>You can either look for the old version in <code>git reflog</code>, <code>git reset --hard</code> to it, then start again</p>",
        "id": 257178027,
        "sender_full_name": "Laurențiu",
        "timestamp": 1634033060
    },
    {
        "content": "<p>Or make a new branch from our <code>master</code> and cherry-pick the three commits (if it's only three of them)</p>",
        "id": 257178053,
        "sender_full_name": "Laurențiu",
        "timestamp": 1634033076
    },
    {
        "content": "<p>I'd do the latter if I was sure there are only three, something like:</p>\n<div class=\"codehilite\"><pre><span></span><code>git remote add upstream https://github.com/rust-analyzer/rust-analyzer # if you don&#39;t have it already\ngit fetch upstream\ngit checkout -b extract-module-2\ngit reset --hard upstream/master\ngit cherry-pick 7453346345008015c379f14e3cd139a6b9b650c2 8f0edf73fd572c7a91f9f1bae0438b8f92e62d3d 436a5a4be2ad544342fbcc73c52d94b5d9bf9efc # check that they&#39;re in chronological order\n</code></pre></div>",
        "id": 257178088,
        "sender_full_name": "Laurențiu",
        "timestamp": 1634033094
    },
    {
        "content": "<p>(Not tested)</p>",
        "id": 257178432,
        "sender_full_name": "Laurențiu",
        "timestamp": 1634033267
    },
    {
        "content": "<p>Yeah I did the same but when I tried to push it stated: \"everything up to date\"</p>",
        "id": 257178932,
        "sender_full_name": "Fenil Jain",
        "timestamp": 1634033516
    },
    {
        "content": "<p>Try clearing the branch to master, force push the cleared version, then cherry pick the commits over and force push again</p>",
        "id": 257179108,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1634033626
    },
    {
        "content": "<p>A bit odd that you get an <code>everything up to date</code> there tbh <span aria-label=\"confused\" class=\"emoji emoji-1f615\" role=\"img\" title=\"confused\">:confused:</span></p>",
        "id": 257179162,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1634033643
    },
    {
        "content": "<p>Okay when I try git push origin +extract_module with current branch synced up with master, it still says <code>everything up to date</code></p>\n<p><a href=\"/user_uploads/4715/9cZ9FynOMxKgb8F_buZ6w05I/RustAnalyzer.png\">RustAnalyzer.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/4715/9cZ9FynOMxKgb8F_buZ6w05I/RustAnalyzer.png\" title=\"RustAnalyzer.png\"><img src=\"/user_uploads/4715/9cZ9FynOMxKgb8F_buZ6w05I/RustAnalyzer.png\"></a></div>",
        "id": 257184627,
        "sender_full_name": "Fenil Jain",
        "timestamp": 1634036852
    },
    {
        "content": "<p>You're pushing the old branch</p>",
        "id": 257184797,
        "sender_full_name": "Laurențiu",
        "timestamp": 1634036942
    },
    {
        "content": "<p><code>git push -u origin extract_module_2</code></p>",
        "id": 257184813,
        "sender_full_name": "Laurențiu",
        "timestamp": 1634036953
    },
    {
        "content": "<p>Also, what's <code>+</code> there?</p>",
        "id": 257184823,
        "sender_full_name": "Laurențiu",
        "timestamp": 1634036962
    },
    {
        "content": "<p>Thats for only force pushing a particular branch</p>\n<p>So I am force pushing to extract_module from extract_module_fix branch</p>",
        "id": 257184858,
        "sender_full_name": "Fenil Jain",
        "timestamp": 1634036990
    },
    {
        "content": "<p>TIL</p>",
        "id": 257185034,
        "sender_full_name": "Laurențiu",
        "timestamp": 1634037079
    },
    {
        "content": "<p>Try <code>git push -u origin extract_module_2</code>. I can never remember if that's the local or remote branch name</p>",
        "id": 257185292,
        "sender_full_name": "Laurențiu",
        "timestamp": 1634037215
    },
    {
        "content": "<p>I have reopened it and I think now it is proper</p>",
        "id": 257202864,
        "sender_full_name": "Fenil Jain",
        "timestamp": 1634045487
    },
    {
        "content": "<p>Yeah, it looks fine</p>",
        "id": 257209232,
        "sender_full_name": "Laurențiu",
        "timestamp": 1634047896
    },
    {
        "content": "<p>Thnx a lot for all the help <span aria-label=\"peace sign\" class=\"emoji emoji-270c\" role=\"img\" title=\"peace sign\">:peace_sign:</span></p>",
        "id": 258689003,
        "sender_full_name": "Fenil Jain",
        "timestamp": 1634896736
    }
]