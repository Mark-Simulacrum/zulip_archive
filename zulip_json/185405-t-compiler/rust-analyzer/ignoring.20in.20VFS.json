[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"204303\">@vipentti</span> you've recently tweaked ignoring logic in the VFS, would you be interested in making it more generic?</p>\n<p>Specifically, I think VFS can accept paris of <code>(PathBuf, Box&lt;dyn Fn(&amp;RelativePath)&gt;)</code> as source roots (i.e, source root + exclusion pattern), and use that instead of hardcoded logic.</p>\n<p>I think it makes sense to say that the filtering function is only called for <strong>files</strong> and change the implementation inside VFS such that <code>if path.is_dir()</code> is an implementation detail. We probaly want to use a <code>struct</code> with good names instead of a pair as well.</p>\n<p>With that interface in place, we can move hard-coded logic about <code>.rs</code> and <code>ndoe_modules</code> out of the VFS and into <code>ra_lsp_server</code>.</p>",
        "id": 160205505,
        "sender_full_name": "matklad",
        "timestamp": 1551971171
    },
    {
        "content": "<p>Sounds good, Yeah I was thinking about that too. That way <code>ra_vfs</code> could be used in a more generic way and not just with rust files</p>",
        "id": 160205599,
        "sender_full_name": "vipentti",
        "timestamp": 1551971241
    },
    {
        "content": "<p>yeah... We really should have done this when extracting VFS to a separate repo. Now we have to coordinate updates to both repos, or use the <code>[patch]</code> section of Cargo.toml</p>",
        "id": 160206119,
        "sender_full_name": "matklad",
        "timestamp": 1551971594
    },
    {
        "content": "<p>Yeah, that's unfortunate but hopefully should not be too bad to do now</p>",
        "id": 160206499,
        "sender_full_name": "vipentti",
        "timestamp": 1551971860
    },
    {
        "content": "<p>The reason for the <code>(PathBuf, Box&lt;dyn Fn(&amp;RelativePath)&gt;)</code> is so that we can have different exclusions for different paths ? like ignoring <code>test|benchmark|example</code> from external crates</p>",
        "id": 160209789,
        "sender_full_name": "vipentti",
        "timestamp": 1551974213
    },
    {
        "content": "<p>Yeah</p>",
        "id": 160210144,
        "sender_full_name": "matklad",
        "timestamp": 1551974439
    },
    {
        "content": "<p>I imagine long-term users should be able to override exclusion manually as well</p>",
        "id": 160210209,
        "sender_full_name": "matklad",
        "timestamp": 1551974469
    },
    {
        "content": "<p>Should the exclusion happen in <code>Roots</code> still ? e.g. should the callback be passed and stored together with the <code>RootData</code> ?</p>",
        "id": 160281348,
        "sender_full_name": "vipentti",
        "timestamp": 1552043768
    },
    {
        "content": "<p>Currently the VFS is provided with a list of root directories right ? and then the individual files are read and the folders watched in <code>io.rs</code> ?</p>",
        "id": 160282900,
        "sender_full_name": "vipentti",
        "timestamp": 1552045672
    },
    {
        "content": "<p>Yeah, the callback should be stored as a part of <code>RootData</code></p>",
        "id": 160284598,
        "sender_full_name": "matklad",
        "timestamp": 1552047882
    },
    {
        "content": "<blockquote>\n<p>Currently the VFS is provided with a list of root directories right ? and then the individual files are read and the folders watched in <a href=\"http://io.rs\" target=\"_blank\" title=\"http://io.rs\">io.rs</a> ?</p>\n</blockquote>\n<p>Yeap</p>",
        "id": 160284605,
        "sender_full_name": "matklad",
        "timestamp": 1552047897
    },
    {
        "content": "<p>Specifically, <code>roots</code> is what answers the question \"to which root does this path belong\"</p>",
        "id": 160284625,
        "sender_full_name": "matklad",
        "timestamp": 1552047920
    },
    {
        "content": "<p>and <code>io</code> is the thing which actually reads the contents of files from disk</p>",
        "id": 160284635,
        "sender_full_name": "matklad",
        "timestamp": 1552047935
    },
    {
        "content": "<p>I guess since the current method of filtering files works, there should not be performance concerns regarding filtering ? I mean currently you could technically attempt to load files from node_modules but then the files would be ignored based in <code>is_excluded</code></p>",
        "id": 160286855,
        "sender_full_name": "vipentti",
        "timestamp": 1552050191
    },
    {
        "content": "<p>it's important to avoid scanning the node_modules folder though</p>",
        "id": 160286975,
        "sender_full_name": "matklad",
        "timestamp": 1552050308
    },
    {
        "content": "<p>Yeah, I imagine being able to exclude whole directories from scanning would be useful in general</p>",
        "id": 160287254,
        "sender_full_name": "vipentti",
        "timestamp": 1552050590
    },
    {
        "content": "<p>What do you think about instead of returning <code>bool</code> from the callback, we'll return some enum with two variants e.g.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">enum</span> <span class=\"nc\">MatchResult</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"sd\">/// Keep the file</span>\n<span class=\"w\">    </span><span class=\"n\">Keep</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"sd\">/// Exclude the file</span>\n<span class=\"w\">    </span><span class=\"n\">Exclude</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>Naming tbd but that way they callback can be used to exclude files by default or to keep files by default, I find <code>bool</code> to be ambiguous in this case.</p>",
        "id": 160289205,
        "sender_full_name": "vipentti",
        "timestamp": 1552052079
    },
    {
        "content": "<p>excellent idea!</p>",
        "id": 160290252,
        "sender_full_name": "matklad",
        "timestamp": 1552052947
    },
    {
        "content": "<p><code>enum Inclusion { Include, Exclude }</code></p>",
        "id": 160290261,
        "sender_full_name": "matklad",
        "timestamp": 1552052957
    },
    {
        "content": "<p>hmm, still not quite sure what to do regarding folders, I mean it doesn't make sense to start watching folders that will be ignored, meaning if you add <code>a/{nested|node_modules}</code> as root but you want to ignore <code>node_modules</code> it would make sense to only watch <code>a/nested</code> and skip further processing of content in <code>node_modules</code> ?</p>",
        "id": 160290539,
        "sender_full_name": "vipentti",
        "timestamp": 1552053153
    },
    {
        "content": "<p>yeah, I guess my original intention \"make exclusion care only about files\" was wrong</p>",
        "id": 160290610,
        "sender_full_name": "matklad",
        "timestamp": 1552053240
    },
    {
        "content": "<p>we do need to care about folders somehow</p>",
        "id": 160290664,
        "sender_full_name": "matklad",
        "timestamp": 1552053259
    },
    {
        "content": "<p>Can we say that a path to folder must include trailing <code>/</code> to distinguish two cases without making a syscall?</p>",
        "id": 160290701,
        "sender_full_name": "matklad",
        "timestamp": 1552053305
    },
    {
        "content": "<p>Alternatively, we can make something like <code>{ IncludeIfFile, IncludeIfDir, Exclude }</code></p>",
        "id": 160290729,
        "sender_full_name": "matklad",
        "timestamp": 1552053337
    },
    {
        "content": "<p>hmm I wonder if we could run some folder_based filtering already in the initial <code>Roots</code> creation, meaning if you have a root <code>a/node_modules</code> and it matches an ignore, we'll not process it further and drop it from the roots</p>",
        "id": 160290852,
        "sender_full_name": "vipentti",
        "timestamp": 1552053420
    },
    {
        "content": "<p>Although I guess we'd still need to do some further filtreing in <code>io</code> since that one walks the directory tree ?</p>",
        "id": 160291159,
        "sender_full_name": "vipentti",
        "timestamp": 1552053610
    },
    {
        "content": "<p>I think filtering during creating is isomorphic to filtering during initial scan</p>",
        "id": 160291246,
        "sender_full_name": "matklad",
        "timestamp": 1552053669
    },
    {
        "content": "<p>True, though during initial scan you'll recursively go down the roots</p>",
        "id": 160291634,
        "sender_full_name": "vipentti",
        "timestamp": 1552053927
    },
    {
        "content": "<p>yeah, it's more correct to say that we do strictly more work during initial scan anyway</p>",
        "id": 160291730,
        "sender_full_name": "matklad",
        "timestamp": 1552053980
    },
    {
        "content": "<p>hmm actually it might not be a problem, if the <code>roots</code> don't contain the <code>a/node_modules</code> exclude_callback will only be called once when the WalkDir happens to attempt reading it, and then the exclusion should only occur once without further processing of the folders / files inside <code>node_modules</code></p>",
        "id": 160292214,
        "sender_full_name": "vipentti",
        "timestamp": 1552054318
    },
    {
        "content": "<blockquote>\n<p>Can we say that a path to folder must include trailing <code>/</code> to distinguish two cases without making a syscall?</p>\n</blockquote>\n<p>hmm I'm not sure, I think we'd need <code>WalkDir</code> to return paths with a trailing slash ?</p>",
        "id": 160294132,
        "sender_full_name": "vipentti",
        "timestamp": 1552055549
    },
    {
        "content": "<p>I have been working on this and experimented with various tweaks to the API. Currently the callback is called in <code>Roots::contains</code> where previously <code>is_excluded</code> and <code>rel_path</code> were called with some additional parameters.</p>\n<p>An example of a callback:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">fn</span> <span class=\"nf\">include_rust_files</span><span class=\"p\">(</span><span class=\"n\">path</span>: <span class=\"nc\">RootRelativePath</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Inclusion</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">IGNORED_FOLDERS</span>: <span class=\"kp\">&amp;</span><span class=\"p\">[</span><span class=\"o\">&amp;</span><span class=\"kt\">str</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"p\">[</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"s\">&quot;node_modules&quot;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"s\">&quot;.git&quot;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">];</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">is_ignored</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">path</span><span class=\"p\">.</span><span class=\"n\">components</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">.</span><span class=\"n\">any</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">c</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">IGNORED_FOLDERS</span><span class=\"p\">.</span><span class=\"n\">contains</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">c</span><span class=\"p\">.</span><span class=\"n\">as_str</span><span class=\"p\">()))</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">is_ignored</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">Inclusion</span>::<span class=\"n\">Exclude</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"c1\">// Allow rust files</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"s\">&quot;rs&quot;</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">path</span><span class=\"p\">.</span><span class=\"n\">extension</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">Inclusion</span>::<span class=\"n\">IncludeIfFile</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"c1\">// TODO: This should be the default unless otherwise specified</span>\n<span class=\"w\">    </span><span class=\"c1\">// because if you exclude here, then you won&#39;t get the nested</span>\n<span class=\"w\">    </span><span class=\"c1\">// files under the root processed, even if they are not directly ignored</span>\n<span class=\"w\">    </span><span class=\"n\">Inclusion</span>::<span class=\"n\">IncludeIfDir</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p><code>RootRelativePath</code> is a container struct to allow access to the various parts of the path.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"sd\">/// RootRelativePath identifies a file or a folder inside the root</span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">RootRelativePath</span><span class=\"o\">&lt;</span><span class=\"na\">&#39;a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"sd\">/// The root path</span>\n<span class=\"w\">    </span><span class=\"n\">root</span>: <span class=\"kp\">&amp;</span><span class=\"na\">&#39;a</span><span class=\"w\"> </span><span class=\"n\">Path</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"sd\">/// The full path to the file / folder, includes the root</span>\n<span class=\"w\">    </span><span class=\"n\">full</span>: <span class=\"kp\">&amp;</span><span class=\"na\">&#39;a</span><span class=\"w\"> </span><span class=\"n\">Path</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"sd\">/// Relative path to root, e.g. full_path without the root as prefix</span>\n<span class=\"w\">    </span><span class=\"n\">relative</span>: <span class=\"kp\">&amp;</span><span class=\"na\">&#39;a</span><span class=\"w\"> </span><span class=\"n\">RelativePath</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>One issue I have is that the callbacks return value is important in ways that may not be obvious, basically if you by default return <code>Inclusion::Exclude</code>, nested folders under the particular root will not be processed (if they were not roots themselves).</p>\n<p>So if you have a folder structure like</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"s\">&quot;a/nested&quot;</span><span class=\"w\"></span>\n<span class=\"s\">&quot;a/other&quot;</span><span class=\"w\"></span>\n<span class=\"s\">&quot;a/.git&quot;</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>And the <code>a</code> is used as a root, if you return <code>Inclusion::Exclude</code> from the callback, all files under the <code>nested</code>, <code>other</code> folders will not be processed even if you did not explicitly ignore them.</p>",
        "id": 160572664,
        "sender_full_name": "vipentti",
        "timestamp": 1552399494
    },
    {
        "content": "<p>Perhaps we could use a trait with two methods instead:</p>\n<div class=\"codehilite\"><pre><span></span>trait Filter {\n    fn contains_path() -&gt; bool;\n    fn contains_file() -&gt; bool;\n}\n</pre></div>\n\n\n<p>?</p>",
        "id": 160572988,
        "sender_full_name": "matklad",
        "timestamp": 1552399689
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>/// The full path to the file / folder, includes the root\n</pre></div>\n\n\n<p>I hope we could avoid exposing <code>Path/PathBuf</code> in the API, b/c they are OS-dependent</p>",
        "id": 160573051,
        "sender_full_name": "matklad",
        "timestamp": 1552399747
    },
    {
        "content": "<p>Yeah currently they are private but used to perform checks</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"na\">&#39;a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">RootRelativePath</span><span class=\"o\">&lt;</span><span class=\"na\">&#39;a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"sd\">/// Returns whether the `full_path` exists on disk and is pointing at a regular file.</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">is_file</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">bool</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">full</span><span class=\"p\">.</span><span class=\"n\">is_file</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"sd\">/// Returns whether the `full_path` exists on disk and is pointing at a directory.</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">is_dir</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">bool</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">full</span><span class=\"p\">.</span><span class=\"n\">is_dir</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 160573224,
        "sender_full_name": "vipentti",
        "timestamp": 1552399868
    },
    {
        "content": "<blockquote>\n<p>Perhaps we could use a trait with two methods instead:</p>\n<p>trait Filter {<br>\n    fn contains_path() -&gt; bool;<br>\n    fn contains_file() -&gt; bool;<br>\n}</p>\n</blockquote>\n<p>Use the trait instead of a function callback ?</p>",
        "id": 160573432,
        "sender_full_name": "vipentti",
        "timestamp": 1552400028
    },
    {
        "content": "<p>Yeah</p>",
        "id": 160574194,
        "sender_full_name": "matklad",
        "timestamp": 1552400531
    },
    {
        "content": "<p>That might work, I'll experiment a bit</p>",
        "id": 160574291,
        "sender_full_name": "vipentti",
        "timestamp": 1552400641
    },
    {
        "content": "<p>An interesting \"problem\" came up,  if <code>Vfs::add_file_overlay</code> is called for a file, and the file does not exist, we can't properly filter it using file filtering, since when we are filtering, we can't really know if path points to a file or a directory, if it doesn't actually exist on disk yet. So</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">vfs</span><span class=\"p\">.</span><span class=\"n\">add_file_overlay</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">dir</span><span class=\"p\">.</span><span class=\"n\">path</span><span class=\"p\">().</span><span class=\"n\">join</span><span class=\"p\">(</span><span class=\"s\">&quot;a/LICENSE2&quot;</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"s\">&quot;text&quot;</span><span class=\"p\">.</span><span class=\"n\">to_string</span><span class=\"p\">());</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>Would be filtered as it was a directory</p>",
        "id": 160882652,
        "sender_full_name": "vipentti",
        "timestamp": 1552662036
    },
    {
        "content": "<p>hm, if you call <code>add_file</code>, the contract is that it is a file</p>",
        "id": 160913940,
        "sender_full_name": "matklad",
        "timestamp": 1552684231
    },
    {
        "content": "<p>we don't need to care about the state of the file system at all I think?</p>",
        "id": 160913958,
        "sender_full_name": "matklad",
        "timestamp": 1552684248
    },
    {
        "content": "<p>Had some time to work on this again, I think I'm getting somewhere now. Basically we can avoid doing any extra IO when doing the filtering. By adding a new crate-specific enum for FileType, which is then used as an additional parameter to <code>Roots::find(&amp;self, path: &amp;Path, expected: FileType)</code> and <code>Roots::contains(&amp;self, root: VfsRoot, path: &amp;Path, expected: FileType)</code>. Basically <code>Vfs</code> is always expecting a <code>File</code> and <code>io</code> then provides the argument based on the actual type in the filesystem. This way we can run the correct <code>Filter</code> function based on the expectation.</p>\n<p>This means that when one of the <code>_file_overlay</code> functions is called, we won't add them to the VFS unless they pass filtering, even if they don't actually exist in the filesystem yet.</p>\n<p><em>NOTE</em> The <code>FileType</code> enum is purely for convenience.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">pub</span><span class=\"p\">(</span><span class=\"k\">crate</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">enum</span> <span class=\"nc\">FileType</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">File</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Dir</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>Example of a filter:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">struct</span> <span class=\"nc\">IncludeRustFiles</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">IncludeRustFiles</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">include_folder</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">folder_path</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">RelativePath</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">bool</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">IGNORED_FOLDERS</span>: <span class=\"kp\">&amp;</span><span class=\"p\">[</span><span class=\"o\">&amp;</span><span class=\"kt\">str</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"p\">[</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"s\">&quot;node_modules&quot;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"s\">&quot;.git&quot;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">];</span><span class=\"w\"></span>\n\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">is_ignored</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">folder_path</span><span class=\"p\">.</span><span class=\"n\">components</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">.</span><span class=\"n\">any</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">c</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">IGNORED_FOLDERS</span><span class=\"p\">.</span><span class=\"n\">contains</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">c</span><span class=\"p\">.</span><span class=\"n\">as_str</span><span class=\"p\">()))</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">        </span><span class=\"o\">!</span><span class=\"n\">is_ignored</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">include_file</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">file_path</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">RelativePath</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">bool</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">file_path</span><span class=\"p\">.</span><span class=\"n\">extension</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"s\">&quot;rs&quot;</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 161037082,
        "sender_full_name": "vipentti",
        "timestamp": 1552894803
    },
    {
        "content": "<p>Looks reasonable, I don't see any problems with this approach!</p>",
        "id": 161039198,
        "sender_full_name": "matklad",
        "timestamp": 1552897758
    },
    {
        "content": "<p>I'm not sure what is the appropriate bound for the <code>Filter</code> when creating a <code>RootEntry</code>.</p>\n<p>Currently <code>Filter</code> and <code>RootEntry</code> look like</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Filter</span>: <span class=\"nb\">Send</span> <span class=\"o\">+</span><span class=\"w\"> </span><span class=\"nb\">Sync</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">include_folder</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">folder_path</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">RelativePath</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">bool</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">include_file</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">file_path</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">RelativePath</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">bool</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"cp\">#[derive(Clone)]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">RootEntry</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">path</span>: <span class=\"nc\">PathBuf</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">filter</span>: <span class=\"nc\">Arc</span><span class=\"o\">&lt;</span><span class=\"n\">dyn</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">RootEntry</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">new</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">path</span>: <span class=\"nc\">PathBuf</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">filter</span>: <span class=\"nc\">T</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">T</span>: <span class=\"nc\">Filter</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"nb\">&#39;static</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">RootEntry</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">path</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">filter</span>: <span class=\"nc\">Arc</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">filter</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>This means that each <code>RootEntry::new</code> will create a new <code>Arc</code>. But I'm not sure adding a function that takes an <code>Arc&lt;dyn Filter&gt;</code> is appropriate?</p>",
        "id": 161042762,
        "sender_full_name": "vipentti",
        "timestamp": 1552901959
    },
    {
        "content": "<p><code>Send + Sync</code> bounds on <code>Filter</code> sounds right to me.</p>\n<p>API-wise, we should accept an <code>Box&lt;dyn Filter&gt;</code> and convert it to <code>Arc&lt;dyn Filter&gt;</code> internally (via <code>Into</code>). Though, I am not sure if we need <code>Arc</code> at all here: I think <code>Root</code> could store just <code>Box</code>, iirc, we already put roots inside arcs?</p>",
        "id": 161042934,
        "sender_full_name": "matklad",
        "timestamp": 1552902176
    },
    {
        "content": "<p>Roots are inside arcs but the way <code>Roots</code> is currently initialized, we <code>clone</code> the entry</p>",
        "id": 161043030,
        "sender_full_name": "vipentti",
        "timestamp": 1552902251
    },
    {
        "content": "<p>Although I suppose the clone could be avoided by restructuring the <code>Roots::new</code> a bit</p>",
        "id": 161043101,
        "sender_full_name": "vipentti",
        "timestamp": 1552902359
    },
    {
        "content": "<p>Now the <code>RootEntry</code> contains <code>Box&lt;dyn Filter&gt;</code> with no extra <code>Arc</code> or cloning happening. Is there a reason to accept only <code>Box&lt;dyn Filter&gt;</code> vs adding a trait bound ?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">RootEntry</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"n\">path</span>: <span class=\"nc\">PathBuf</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">filter</span>: <span class=\"nb\">Box</span><span class=\"o\">&lt;</span><span class=\"n\">dyn</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">RootEntry</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">path</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">filter</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">new_alt</span><span class=\"p\">(</span><span class=\"n\">path</span>: <span class=\"nc\">PathBuf</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">filter</span>: <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"nb\">&#39;static</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">RootEntry</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">path</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">filter</span>: <span class=\"nb\">Box</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">filter</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 161055820,
        "sender_full_name": "vipentti",
        "timestamp": 1552914830
    },
    {
        "content": "<p>PR Up in <a href=\"https://github.com/rust-analyzer/ra_vfs/pull/4\" target=\"_blank\" title=\"https://github.com/rust-analyzer/ra_vfs/pull/4\">https://github.com/rust-analyzer/ra_vfs/pull/4</a></p>",
        "id": 161061481,
        "sender_full_name": "vipentti",
        "timestamp": 1552919103
    },
    {
        "content": "<p>I was thinking about filtering examples etc from external crates, the best place to do this is probably <code>ra_project_model</code> ? Instead of <code>ProjectWorkspace::to_roots</code> returning a <code>Vec&lt;PathBuf&gt;</code>, we could return <code>Vec&lt;ra_vfs::RootEntry&gt;</code> where the filter has knowledge on if its an external crate or a member of the current project. This would mean adding <code>ra_vfs</code> dependency to <code>ra_project_model</code> though</p>",
        "id": 161139296,
        "sender_full_name": "vipentti",
        "timestamp": 1552992742
    },
    {
        "content": "<p>argh........</p>\n<p>I've just remembered the reason why I wanted to stick with <code>Fn(&amp;RelativePathBuf)</code> interafact for filtering, instead of introducing a nominal trait</p>",
        "id": 161176263,
        "sender_full_name": "matklad",
        "timestamp": 1553019279
    },
    {
        "content": "<p>:)</p>\n<p>I think it would be nice to avoid depndency on vfs though. Can project module supply something which could be converted to ra_vfs::RootEntry easily by a third crate?</p>",
        "id": 161176334,
        "sender_full_name": "matklad",
        "timestamp": 1553019353
    },
    {
        "content": "<p>Hmm should be doable</p>",
        "id": 161176454,
        "sender_full_name": "vipentti",
        "timestamp": 1553019434
    },
    {
        "content": "<blockquote>\n<p>argh........</p>\n<p>I've just remembered the reason why I wanted to stick with <code>Fn(&amp;RelativePathBuf)</code> interafact for filtering, instead of introducing a nominal trait</p>\n</blockquote>\n<p>what's the reason ?</p>",
        "id": 161176552,
        "sender_full_name": "vipentti",
        "timestamp": 1553019512
    },
    {
        "content": "<p>to not depend on <code>vfs</code> :)</p>",
        "id": 161176778,
        "sender_full_name": "matklad",
        "timestamp": 1553019677
    },
    {
        "content": "<p>If the type is non-nominal (like a tuple of <code>Fn</code>s or something), two crates can agree on it without depending on each other.</p>",
        "id": 161176830,
        "sender_full_name": "matklad",
        "timestamp": 1553019716
    },
    {
        "content": "<p>Ah, yes of course</p>",
        "id": 161176907,
        "sender_full_name": "vipentti",
        "timestamp": 1553019754
    },
    {
        "content": "<p>I think the <code>ra_project_mode</code> can return just some tuple for example with  <code>(PathBuf, is_member)</code> that can then be used outside of it</p>",
        "id": 161176969,
        "sender_full_name": "vipentti",
        "timestamp": 1553019807
    },
    {
        "content": "<p>yeah, something like that should work</p>",
        "id": 161177055,
        "sender_full_name": "matklad",
        "timestamp": 1553019850
    },
    {
        "content": "<p>I'd still like to combine the Filter somewhere, since both <code>ra_batch</code> and the lsp server are using the roots</p>",
        "id": 161177096,
        "sender_full_name": "vipentti",
        "timestamp": 1553019887
    },
    {
        "content": "<p>hmm, do we have more common functionality that could be shared between crates ? I was thinking about creating a simple crate <code>vfs_filter</code> or <code>ra_filter</code> or some such that would depend on <code>Vfs</code> and then both <code>ra_lsp_server</code> and <code>ra_batch</code> could depend on it. The new crate would contain the filters and such.<br>\nBut if we have more common functionality, maybe creating <code>ra_common</code> could be useful ?</p>",
        "id": 161221372,
        "sender_full_name": "vipentti",
        "timestamp": 1553065918
    },
    {
        "content": "<p>My gut feeling is that we don't actually want to share anything between these filters. It might turn out not to be true, we'll see, but, at this point, I think it's easier to keep the <em>logic</em> inside project_model, and provide a thin vfs glue twice, in ra_batch and ra_lsp_server</p>",
        "id": 161221949,
        "sender_full_name": "matklad",
        "timestamp": 1553066643
    },
    {
        "content": "<p>Actually that sounds reasonable, so <code>project_model</code> returns something that allows us to tell if a root is part of the current workspace or not, then both <code>ra_lsp_server</code> and <code>ra_batch</code> implement their own Filters, which initially can be similar but may end up being different ?</p>",
        "id": 161222090,
        "sender_full_name": "vipentti",
        "timestamp": 1553066833
    },
    {
        "content": "<p>Updated the pr <a href=\"https://github.com/rust-analyzer/rust-analyzer/pull/997\" target=\"_blank\" title=\"https://github.com/rust-analyzer/rust-analyzer/pull/997\">https://github.com/rust-analyzer/rust-analyzer/pull/997</a></p>",
        "id": 161230790,
        "sender_full_name": "vipentti",
        "timestamp": 1553075972
    }
]