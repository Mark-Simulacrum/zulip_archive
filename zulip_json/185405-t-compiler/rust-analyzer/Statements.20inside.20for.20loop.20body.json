[
    {
        "content": "<p>Hi, I'm working on enhancing a rust-analyzer code assist, and running into a problem with statements. How come that upon analyzing the following code, for_expr.loop_body().statements() (where for_expr is a ForExpr) retrieves only the <code>let</code> statement and not the <code>if</code> one?</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">*=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>(btw not sure if it is the right streams for this kind of question)</p>",
        "id": 269414662,
        "sender_full_name": "AppCoder1234",
        "timestamp": 1643205534
    },
    {
        "content": "<p>the simple answer is that the loop body is a block expression, and the <code>if</code> expression in there is the trailing expression of the block. If you were to add a semicolon after that closing brace of the <code>if</code> it would get included in the statements.</p>",
        "id": 269415368,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1643205767
    },
    {
        "content": "<p>So you need to iterate the bodies statements <em>and</em> check the tail expression of the body to get everything here</p>",
        "id": 269415427,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1643205793
    },
    {
        "content": "<p>thx!</p>",
        "id": 269415691,
        "sender_full_name": "AppCoder1234",
        "timestamp": 1643205882
    },
    {
        "content": "<p>Same topic but not really the same question, I am now looking to extract the pattern (Pat) from the for loop, and if it is an IdentPat (the only case I am covering here), to remove any mut token and then to put it somewhere in the refactored code. I can't find how to remove a mut token from a (Ident)Pat (I can see if there is one, but can't remove it), how would I do that? (There's <a href=\"http://remove_mut.rs\">remove_mut.rs</a> which does that but in a way I can't reproduce easily in my specific case)</p>",
        "id": 269426079,
        "sender_full_name": "AppCoder1234",
        "timestamp": 1643209730
    },
    {
        "content": "<p>what you can do is <code>clone_for_update()</code> the pattern node, then fetch the mut token of that clone and do <code>mut_tok.syntax().detach()</code> iirc, though that will leave you with an extra whitespace in the node</p>",
        "id": 269426812,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1643210013
    },
    {
        "content": "<p>The simplest way would most likely be to just reconstruct the <code>IdentPat</code> without the mut token</p>",
        "id": 269426880,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1643210042
    },
    {
        "content": "<p>that is change <a href=\"https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/syntax/src/ast/make.rs#L448-L459\">https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/syntax/src/ast/make.rs#L448-L459</a> so that it supports the inner pattern by changing its current signature and impl to</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">ident_pat</span><span class=\"p\">(</span><span class=\"n\">ref_</span>: <span class=\"kt\">bool</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">mut_</span>: <span class=\"kt\">bool</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">name</span>: <span class=\"nc\">ast</span>::<span class=\"n\">Name</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">inner</span>: <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">ast</span>::<span class=\"n\">Pat</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">ast</span>::<span class=\"n\">IdentPat</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">String</span>::<span class=\"n\">from</span><span class=\"p\">(</span><span class=\"s\">\"fn f(\"</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">ref_</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">s</span><span class=\"p\">.</span><span class=\"n\">push_str</span><span class=\"p\">(</span><span class=\"s\">\"ref \"</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">mut_</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">s</span><span class=\"p\">.</span><span class=\"n\">push_str</span><span class=\"p\">(</span><span class=\"s\">\"mut \"</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">format_to</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"{}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">inner</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">inner</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">format_to</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"{}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">inner</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">s</span><span class=\"p\">.</span><span class=\"n\">push_str</span><span class=\"p\">(</span><span class=\"s\">\": ())\"</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">ast_from_text</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">s</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 269427221,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1643210169
    },
    {
        "content": "<p>then you should be able to just take your current ident pat apart, and reconstruct it with that function always passing <code>false</code> for <code>mut_</code></p>",
        "id": 269427302,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1643210206
    },
    {
        "content": "<p>Will that eat the comments, though?</p>",
        "id": 269427405,
        "sender_full_name": "Lauren»õiu",
        "timestamp": 1643210251
    },
    {
        "content": "<p>it would(also any attributes that may appear there), thats a general downside of the reconstruction stuff(while the mutable api retains them)</p>",
        "id": 269429452,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1643211017
    },
    {
        "content": "<p>Hmm I don't understand the thing about adding an inner argument to ident_pat<br>\nIs there no way to just get the name from an IdentPat? That way I could <code>make::ident_pat(false,false,name)</code> (not sure I even need to keep ref too, I need this pattern in a .filter() closure)</p>",
        "id": 269430676,
        "sender_full_name": "AppCoder1234",
        "timestamp": 1643211484
    },
    {
        "content": "<p>That would work but not if you have a pattern like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">@</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">baz</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 269430789,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1643211526
    },
    {
        "content": "<p>Otherwise I'll just go for cloning and updating, regardless of the extraneous whitespace (or is it a way to remove that whitespace too?)</p>",
        "id": 269430796,
        "sender_full_name": "AppCoder1234",
        "timestamp": 1643211528
    },
    {
        "content": "<p>What does this code do ? I don't know about the @ pattern</p>",
        "id": 269430869,
        "sender_full_name": "AppCoder1234",
        "timestamp": 1643211563
    },
    {
        "content": "<p>My current test against which I'm compiling is this: <br>\nTransform</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">..</span><span class=\"mi\">10</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">           </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{}\"</span><span class=\"p\">,</span><span class=\"n\">i</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>into this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"o\">..</span><span class=\"mi\">10</span><span class=\"p\">).</span><span class=\"n\">filter</span><span class=\"p\">(</span><span class=\"o\">|&amp;</span><span class=\"n\">i</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"p\">).</span><span class=\"n\">for_each</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">i</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{}\"</span><span class=\"p\">,</span><span class=\"n\">i</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">});</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 269431058,
        "sender_full_name": "AppCoder1234",
        "timestamp": 1643211631
    },
    {
        "content": "<p>Actually, you should be able to do something like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">ws</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">mut_token</span><span class=\"p\">.</span><span class=\"n\">syntax</span><span class=\"p\">().</span><span class=\"n\">next_token</span><span class=\"p\">().</span><span class=\"n\">filter</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">it</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">it</span><span class=\"p\">.</span><span class=\"n\">kind</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"n\">WHITESPACE</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">ws</span><span class=\"p\">.</span><span class=\"n\">detach</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"n\">mut_token</span><span class=\"p\">.</span><span class=\"n\">syntax</span><span class=\"p\">().</span><span class=\"n\">detach</span><span class=\"p\">();</span><span class=\"w\"></span>\n</code></pre></div>\n<p>which should get rid of extra whitespace following the mut token(this is with the <code>clone_for_update</code> version)</p>",
        "id": 269431105,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1643211650
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"474550\">AppCoder1234</span> <a href=\"#narrow/stream/185405-t-compiler.2Frust-analyzer/topic/Statements.20inside.20for.20loop.20body/near/269430869\">ÎßêÌï®</a>:</p>\n<blockquote>\n<p>What does this code do ? I don't know about the @ pattern</p>\n</blockquote>\n<p>@ allows you to bind a matched pattern to an identifier, a better example is</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">@</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">_</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">some_optional_value</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">     </span><span class=\"c1\">// this branch only gets taken if `some_optional_value` is `Some`, `foo` has the value of `some_optional_value`  though, not the inner part of the Option</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>(I wonder if there is a even a good resource on the @ operator, when I learned rust it wasnt really well explained in the book, in fact it only had one small paragraph I think <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span>)</p>",
        "id": 269431299,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1643211733
    },
    {
        "content": "<p>Oh I see, well it won't ease my refactoring code ^^. I'll guess I'll save that for later, through is there really a case where this (@ patterns) would be useful inside for loops?</p>",
        "id": 269431731,
        "sender_full_name": "AppCoder1234",
        "timestamp": 1643211889
    },
    {
        "content": "<p>very rarely if at all I imagine, people tend to not use <code>@</code> that much in general from what I've seen, though with nested or-patterns it is more useful now.<br>\nNote that if you go with the <code>clone_for_update</code> thing you automatically support the <code>@</code> construct since you modify the original node</p>",
        "id": 269432030,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1643212010
    },
    {
        "content": "<p>An aside: if interested the rust book part explaining @ patterns -&gt; <a href=\"https://doc.rust-lang.org/stable/book/ch18-03-pattern-syntax.html#-bindings\">ch18-03-pattern-syntax.html#-bindings</a></p>",
        "id": 269432766,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1643212242
    },
    {
        "content": "<p>Can I get the (optional) mut token from any kind of Pat? It seems like I can get it only forPatIdent ones, but somehow I  thought you implied I could get it from any Pat. Did I miss something?<br>\nBtw I find it hard to understand what the other variants of Pat stand for (except for Ident and Wildcard), for example would your @ pattern be classified as a IdentPat ?</p>",
        "id": 269436105,
        "sender_full_name": "AppCoder1234",
        "timestamp": 1643213234
    },
    {
        "content": "<p>No, only <code>IdentPat</code> uses the <code>mut</code> token, as it is the only pattern that introduces new locals. @ pattern is part of <code>IdentPat</code> yes</p>",
        "id": 269436283,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1643213288
    },
    {
        "content": "<p>You can take a look at the ungrammar file(which we generate our AST from) <a href=\"https://github.com/rust-analyzer/ungrammar/blob/master/rust.ungram#L578-L660\">https://github.com/rust-analyzer/ungrammar/blob/master/rust.ungram#L578-L660</a><br>\nThat should help you understand what the variants stand for</p>",
        "id": 269436353,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1643213323
    },
    {
        "content": "<p>So it means I couldn't handle cases like (a,b) right? Or I would have to recursively check for mut inside there parenthesized patterns to remove it too</p>",
        "id": 269436414,
        "sender_full_name": "AppCoder1234",
        "timestamp": 1643213344
    },
    {
        "content": "<p>The top of the file describes the ungrammar format itself: <a href=\"https://github.com/rust-analyzer/ungrammar/blob/master/rust.ungram#L1-L17\">https://github.com/rust-analyzer/ungrammar/blob/master/rust.ungram#L1-L17</a></p>",
        "id": 269436420,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1643213346
    },
    {
        "content": "<p>Yes if you want to touch nested <code>IdentPat</code>s you would have to recurse the node fully</p>",
        "id": 269436516,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1643213376
    },
    {
        "content": "<p>We should have a visitor function for that already though one sec</p>",
        "id": 269436678,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1643213420
    },
    {
        "content": "<p><a href=\"https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ide_db/src/helpers/node_ext.rs#L145-L169\">https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ide_db/src/helpers/node_ext.rs#L145-L169</a></p>",
        "id": 269436760,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1643213451
    },
    {
        "content": "<p>What's quite hard when implementing code assists is to thing about every code there could exist ^^</p>",
        "id": 269436800,
        "sender_full_name": "AppCoder1234",
        "timestamp": 1643213464
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"300586\">Lukas Wirth</span> <a href=\"#narrow/stream/185405-t-compiler.2Frust-analyzer/topic/Statements.20inside.20for.20loop.20body/near/269436760\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ide_db/src/helpers/node_ext.rs#L145-L169\">https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ide_db/src/helpers/node_ext.rs#L145-L169</a></p>\n</blockquote>\n<p>Is there a mutable one?</p>",
        "id": 269436936,
        "sender_full_name": "AppCoder1234",
        "timestamp": 1643213521
    },
    {
        "content": "<p>So what yo ucould do is <code>clone_for_update</code> the pattern node, then walk it with that function, record all the tokens you want to remove in a vec, then iterate the vec and call detach on all the tokens in there.</p>\n<p>The reason for the vec is that if you were to detach while walking the tree you'd ruin the indices, either removing things you dont want to remove or panic.</p>",
        "id": 269437016,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1643213539
    },
    {
        "content": "<p>(so basically avoiding the problem of iterating and modifying a collection at the same time, which rust itself protects you against usually, the mutable tree api unfortunately does not)</p>",
        "id": 269437101,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1643213577
    },
    {
        "content": "<p>Okay I'll do it that way then thanks</p>",
        "id": 269437134,
        "sender_full_name": "AppCoder1234",
        "timestamp": 1643213598
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"474550\">AppCoder1234</span> <a href=\"#narrow/stream/185405-t-compiler.2Frust-analyzer/topic/Statements.20inside.20for.20loop.20body/near/269436800\">ÎßêÌï®</a>:</p>\n<blockquote>\n<p>What's quite hard when implementing code assists is to thing about every code there could exist ^^</p>\n</blockquote>\n<p>Ye depending on the assist there is a lot to keep in mind unfortunately</p>",
        "id": 269437242,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1643213644
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"300586\">Lukas Wirth</span> <a href=\"#narrow/stream/185405-t-compiler.2Frust-analyzer/topic/Statements.20inside.20for.20loop.20body/near/269437016\">said</a>:</p>\n<blockquote>\n<p>So what yo ucould do is <code>clone_for_update</code> the pattern node, then walk it with that function, record all the tokens you want to remove in a vec, then iterate the vec and call detach on all the tokens in there.</p>\n<p>The reason for the vec is that if you were to detach while walking the tree you'd ruin the indices, either removing things you dont want to remove or panic.</p>\n</blockquote>\n<p>I'm trying to implement what you advised me to do. I cloned the pattern, walked through it with walk_pat to detect and pushed mutable tokens into a Vec&lt;SyntaxToken&lt;RustLanguage&gt;&gt;  for them to be removed later. Unfortunately it is not doing anything (mut tokens are still there in my cloned-for-update pattern after I seemingly <code>detach</code>ed them while iterating my vec). I think I'm missing something because I've got the impression that I could be removing these mut tokens directly in the closure since the borrow checker is not complaining against it. So it seems like I don't work on references when walking through the Pattern Tree but likely on clones. What can I do to modify (remove) the mut tokens directly? And by the way, what do SyntaxToken truly stand for (I've been looking on <a href=\"http://docs.rs\">docs.rs</a> but it doesn't give me much info), ie what is the difference btw having a SyntaxToken and a &amp;SyntaxToken?</p>",
        "id": 272127280,
        "sender_full_name": "AppCoder1234",
        "timestamp": 1645023788
    },
    {
        "content": "<p>Iterating and detaching at the same time won't be caught at compile time as our syntax trees use interior mutability. So it is likely that you will either panic or not see all changes properly if you iterate and modify at the same time.<br>\nThere isnt really a difference between SyntaxToken and &amp;SyntaxToken, SyntaxToken is just a ref counted pointer to the actual token-data.</p>",
        "id": 272129637,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1645024897
    },
    {
        "content": "<p>In very rough pseudo-code all you wanna do should basically be:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">cloned_node</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">node</span><span class=\"p\">.</span><span class=\"n\">clone_for_update</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"c1\">// iter cloned_node for mut tokens to remove</span>\n<span class=\"c1\">// remove the tokens via detach</span>\n<span class=\"c1\">// cloned_node should now no longer have the mut tokens</span>\n</code></pre></div>\n<p>important part being to basically not use the original node for anything at this point as the non-<code>clone_for_update</code> node won't be changed from this.<br>\nTo debug this behaviour you could first check if detaching a single token works at all.</p>",
        "id": 272129965,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1645025052
    },
    {
        "content": "<p>My bad, it's working as intended, I just somehow got the filter closure and for_each closure mixed up and turned out wondering why mut weren't removed from my for_each closure <span aria-label=\"face palm\" class=\"emoji emoji-1f926\" role=\"img\" title=\"face palm\">:face_palm:</span></p>",
        "id": 272131143,
        "sender_full_name": "AppCoder1234",
        "timestamp": 1645025576
    }
]