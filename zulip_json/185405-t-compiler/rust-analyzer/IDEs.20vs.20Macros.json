[
    {
        "content": "<p>Published a new technical post on ra blog: <a href=\"https://github.com/rust-analyzer/rust-analyzer.github.io/pull/161\">https://github.com/rust-analyzer/rust-analyzer.github.io/pull/161</a></p>",
        "id": 262246290,
        "sender_full_name": "matklad",
        "timestamp": 1637509181
    },
    {
        "content": "<p>Hey, <span class=\"user-mention\" data-user-id=\"133169\">@matklad</span>— <span class=\"user-mention silent\" data-user-id=\"203546\">Laurențiu</span> linked me to this blog post <a href=\"#narrow/stream/131828-t-compiler/topic/The.20state.20of.20proc.20macros/near/262299716\">after a macro-related discussion from a couple weeks ago</a> over in <a class=\"stream\" data-stream-id=\"131828\" href=\"/#narrow/stream/131828-t-compiler\">#t-compiler</a>. I’ll spare you all the details, as that thread is huge, but the tl;dr is that I am fairly inexperienced with Rust, but I have extensive experience with macro technology, mostly in the context of Racket, and I’ve been trying to figure out if there’s some way I could assist in some cross-pollination between the two communities.</p>\n<p>I don’t really feel like I know enough about Rust yet to say anything all that meaningful, but the blog post you wrote is both interesting and helpful. Some of the problems you describe are, I think, challenges where some of the technology developed for Racket could translate more-or-less directly, such as in helping IDE tools map the structure of expanded code back onto the source program. Racket’s IDE tools rely on some assistance from the macroexpander, which annotates the program with information about its provenance (e.g. what code came from what macros, which bindings were synthesized from other ones, which bindings were inspected by a macro, etc.) as the program is expanded, and IDE tools can use that information to reconstruct an understanding of code fragments in the source.</p>\n<p>Some of the other problems you describe are more unique to Rust, though, which I think is an interesting challenge at the very least. :) In particular, Racket forbids mutually-recursive modules outright (that sort of recursive structure must be achieved via a secondary feature to explicitly opt into recursive linking), and files are compilation units. Trying to imagine how to make macros efficient in a world with such massive compilation units is tricky. But it’s one I find interesting, so if there’s anything you’d suggest I take a look at, I’d appreciate it!</p>",
        "id": 262464835,
        "sender_full_name": "Alexis King",
        "timestamp": 1637678693
    },
    {
        "content": "<p>I'll catch up thoroughly later, but just want to drop a note saying that the original cause of the post was macro discussion in the dart community: <a href=\"https://github.com/dart-lang/language/issues/1482#issuecomment-974840732\">https://github.com/dart-lang/language/issues/1482#issuecomment-974840732</a>. I'd guess that's even more interesting place for ideas cross-polination, as they still haven't stabilized anything, and can still fix things easiliy</p>",
        "id": 262465583,
        "sender_full_name": "matklad",
        "timestamp": 1637679005
    },
    {
        "content": "<p>Yeah, no rush obviously, and thanks for the link—I’ll read through the thread. Though, I’ll admit that my first reaction is that I find Rust a much more interesting language than Dart, so I’m a bit more motivated to figure out how to contribute to Rust than I am to contribute to Dart :)</p>",
        "id": 262466080,
        "sender_full_name": "Alexis King",
        "timestamp": 1637679257
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"456123\">@Alexis King</span> finally got back to this. I guess my first question would be how do I learn what semantic IDE features Dr Racket has in the first place? I know it can: </p>\n<ul>\n<li>track usages/definitions of symbols (the arrows you get when hovering names)</li>\n<li>rename symbols with checking for complex (via right click menu)</li>\n<li>find unused imports and remove them (remove unused requires)</li>\n</ul>\n<p>Can it do some \"larger than a single name\" code transformations?  Stuff like the following:</p>\n<ul>\n<li>if I have a common subexpression repeated, is there some shortcut which pulls it into a <code>let/defile</code>? </li>\n<li>switching between alternative ways to write something (eg, an action to negate <code>if</code>'s condition and flip branches)</li>\n<li>fixits for errors (eg, suggesting to define an undefined symbols)</li>\n</ul>\n<p>Here's how some of those things work in RA:</p>\n<p><a href=\"/user_uploads/4715/0_N9FlLW1RAF-3qn4FyLrPof/ide-stuff.gif\">ide-stuff.gif</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/4715/0_N9FlLW1RAF-3qn4FyLrPof/ide-stuff.gif\" title=\"ide-stuff.gif\"><img src=\"/user_uploads/4715/0_N9FlLW1RAF-3qn4FyLrPof/ide-stuff.gif\"></a></div>",
        "id": 262871472,
        "sender_full_name": "matklad",
        "timestamp": 1638017318
    },
    {
        "content": "<blockquote>\n<p>Trying to imagine how to make macros efficient in a world with such massive compilation units is tricky. But it’s one I find interesting, so if there’s anything you’d suggest I take a look at, I’d appreciate it!</p>\n</blockquote>\n<p>Yeah, that's sadly not something clearly visible in the current state of the codebase.  Luckily, there's this very specific (old) commit <a href=\"https://github.com/rust-analyzer/rust-analyzer/pull/1055\">https://github.com/rust-analyzer/rust-analyzer/pull/1055</a> where we solved the problem (using <span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> 's insight).  You can see the test that's un-ignored in the PR, and that's sort of the reason for salsa and all other stuff</p>",
        "id": 262872190,
        "sender_full_name": "matklad",
        "timestamp": 1638018295
    },
    {
        "content": "<p>In general, I think the situation is as follows -- we use <code>salsa</code>, a generic incremental computation engine to write most of ra (I don't think salsa is directly influenced by build-systems a-la carte paper, but what we do there is essentially what's described in that paper).</p>\n<p>The core idea there is early cutoff. When you edit the file, and you type inside the function, you don't introduce any top-level names. So, in theory, you can re-use global nameres results. The way it works in salsa is (roughly), that on typing you mark the file dirty, re-analyze it, and compute the set of top-level names there. If the set of names is the same as the last time, you don't propagate dirtiness outward, cutting invalidation off early.</p>",
        "id": 262872426,
        "sender_full_name": "matklad",
        "timestamp": 1638018629
    },
    {
        "content": "<p>THe snag with macros though is that you don't know  whether \"you are typing inside the function\". FWIW, changing</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[tokio::main]</span><span class=\"w\"></span>\n<span class=\"k\">async</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>to </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[tokio::main]</span><span class=\"w\"></span>\n<span class=\"k\">async</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"mi\">2</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p><em>could</em> introduce new names in the scope. <em>Just</em> re-expanding this macro invocation is a bit tricky -- <code>tokio::main</code> uses name-resolution machinery, and re-resolving that name using old name resolution might be wrong. So, when we memoize macro expansion results, we key it not only by the actual macro invocation, but also by the definition of macro we resolved that invocation to. That way, we don't have to re-resolve <code>tokio::main</code>, as we have macro def as a part of key in salsa.</p>",
        "id": 262872594,
        "sender_full_name": "matklad",
        "timestamp": 1638018899
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133169\">@matklad</span> <a href=\"#narrow/stream/185405-t-compiler.2Frust-analyzer/topic/IDEs.20vs.20Macros/near/262871472\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"456123\">Alexis King</span> finally got back to this. I guess my first question would be how do I learn what semantic IDE features Dr Racket has in the first place? […] Can it do some \"larger than a single name\" code transformations?</p>\n</blockquote>\n<p>All good questions. The answer, currently, is “mostly no,” but that isn’t really a fundamental limitation of the techniques so much as it is a function of the limited engineering effort that has been spent implementing more sophisticated refactorings. In fact, I happen to know a PhD student at Northwestern who is currently working on doing more elaborate things, but it <em>is</em> ultimately research software, so most of the effort ends up getting spent on figuring out how to do the hardest things first rather than implementing the theoretically low-hanging fruit (that nevertheless would take a nontrivial amount of engineering effort).</p>\n<p>Really, the key ideas behind DrRacket’s approach can be summarized as three principles:</p>\n<ol>\n<li>\n<p>In a macro-enabled language, it’s simply impossible for tooling to bake in support for every language construct, since new language constructs can effectively be added by libraries. Therefore, some support must exist in the expander to communicate enough information to tooling to allow it to accommodate extensions.</p>\n</li>\n<li>\n<p>Much of this information can be tracked <em>automatically</em> by logic in either the macro system itself or various helper libraries. For example, in Racket, information like “where did this code originate from?”, “did this bit of code come from the source program or from a macro?”, and “what sequence of macros generated this expansion?” is made available by the expander itself. Other information, such as “which bindings did this macro inspect to inform its expansion?” are not tracked in the expander <em>per se</em>, but the expander provides a mechanism for macros to annotate their expansion with that information, and the standard macro library forms and functions (which in Rust would include things like <code>macro_rules!</code> and <code>syn</code>) automatically attach that information by default.</p>\n</li>\n<li>\n<p>Finally, some information is difficult to collect completely automatically because it requires knowledge about the intent of a macro that is only known to the macro author. Therefore, some additional annotations can optionally be provided by the author of a macro to cooperate even better with IDE tooling. Since this information is basically just arbitrary metadata, DrRacket and other tools just define their own protocols of what metadata keys they look for, and macros (and macro libraries) make best-effort attempts to provide as much of that information as possible. It is, to some degree, an organic process.</p>\n</li>\n</ol>\n<p>All told, this works pretty well, especially because common macro “design patterns” invariably become codified in libraries designed to assist macro implementation, and those libraries can attach the relevant information automatically, so most users don’t ever think about any of this, and things mostly just work. It does, however, obviously mean that implementors of both IDE tools and macro libraries have to (a) cooperate to track and consume the necessary information and (b) sometimes do some work to improve the implementation of especially complex macros to cooperate better with tooling. But in my experience, everyone’s goals for things like this are pretty well-aligned, because usually the burden on macro implementors is pretty minimal, and obviously authors of complex macros are happy to see improved tooling support for their libraries.</p>",
        "id": 262896288,
        "sender_full_name": "Alexis King",
        "timestamp": 1638052143
    },
    {
        "content": "<p>How do macros typically deal with being invoked on an incomplete input, like you may find in an IDE? Does <code>syntax/parse</code> etc. have error recovery built in so that not every macro has to deal with that?</p>",
        "id": 262897383,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1638053961
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"211727\">Jonas Schievink  [he/him]</span> <a href=\"#narrow/stream/185405-t-compiler.2Frust-analyzer/topic/IDEs.20vs.20Macros/near/262897383\">said</a>:</p>\n<blockquote>\n<p>How do macros typically deal with being invoked on an incomplete input, like you may find in an IDE? Does <code>syntax/parse</code> etc. have error recovery built in so that not every macro has to deal with that?</p>\n</blockquote>\n<p>In Racket, the answer is mostly “they don’t”… though it’s worth noting that Racket is a fairly different environment in the sense that (a) <em>everything</em> in the language is implemented as a macro (including extremely basic things like <code>let</code>, <code>define</code>, and <code>lambda</code>), and (b) procedural macros that can do completely arbitrary things are the standard mechanism that everything else is built on top of and that the system was originally designed around. Better error recovery is something that I think everyone in the Racket community would like to have, and it seems entirely possible to support, but it isn’t something that anyone has actively pursued as far as I’m aware.</p>\n<p>I think there are various approaches one could take to error recovery that wouldn’t require new research (“just” engineering), all with different tradeoffs. Many of the most appealing ones would probably exploit the fact that most Rust macros are macros-by-example, which makes it relatively straightforward to build error recovery into the macro parser itself (since you don’t need to expand the macro to know which subforms are expressions/types/etc.), but those could be scaled to proc macros as well by allowing macros to return a <code>Result</code>, where the <code>Err</code> side contains the same information a failed MBE would provide.</p>",
        "id": 262899122,
        "sender_full_name": "Alexis King",
        "timestamp": 1638056657
    },
    {
        "content": "<p>In DrRacket, most of the available tools do currently rely upon “background expansion” completing successfully, which mostly means the program must expand without errors. Technically, there is a protocol for macros to report information to DrRacket even if they fail to expand, and Typed Racket uses that to allow DrRacket’s tools to operate on a program with type errors, for example. But that mechanism is not used by most macros, as far as I’m aware.</p>",
        "id": 262899203,
        "sender_full_name": "Alexis King",
        "timestamp": 1638056809
    },
    {
        "content": "<p>Ah, I see. rust-analyzer does currently perform recovery for MBE, but not for procedural macros. Thanks!</p>",
        "id": 262899219,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1638056851
    },
    {
        "content": "<p>Yes, that makes sense. One other thing I guess I haven’t mentioned so far is DrRacket’s “macro stepper,” which, as with everything I’ve described so far, is not really implemented in DrRacket—the information is all provided by the expander itself, and DrRacket just consumes it and presents it in a UI. As its name implies, the macro stepper allows programmers to step through macro expansion, one transformation at a time, and interactively inspect the structure of intermediate states, much like a traditional single-step debugger.</p>\n<p>The macro stepper is implemented by a sort of structured logging system built into the expander: when enabled, the expander will emit events at various points in the expansion process, such as “applying a macro transformer” or “registering a new binding”. The payloads of those events contain enough information that the UI in DrRacket can integrate them to present a step-by-step rendering of the program as it expands, and because this process happens imperatively as the program is expanded, it works fine even if a macro fails: the stream of events just ends when the first unrecoverable error occurs.</p>",
        "id": 262899484,
        "sender_full_name": "Alexis King",
        "timestamp": 1638057328
    },
    {
        "content": "<p>In theory, some of that information could probably be used to provide some of the information provided by background expansion even on a program that does not expand successfully, but nothing like that is implemented currently—the macro stepper is a separate function altogether. Consuming only the information produced by a fully-expanded program tends to be appealing, because some of that information may change as the program is expanded (since Racket macros can do lots of things, including, in theory, go down “tentative” expansion paths before backing out and trying something else, though I don’t think any macro actually does anything that extreme), and generally you can only fully trust the final expansion result. But a lot of that is, again, because the Racket macro system is so general, whereas the Rust macro system is far more restricted, so a lot of those pitfalls don’t exist.</p>",
        "id": 262899600,
        "sender_full_name": "Alexis King",
        "timestamp": 1638057553
    }
]