[
    {
        "content": "<p>Looks like our <code>text</code> size is about 16 MB on Linux, that seems a bit excessive. Out of curiosity, I commented out the assists and it dropped by 1.15 MB.</p>",
        "id": 258078947,
        "sender_full_name": "Laurențiu",
        "timestamp": 1634582680
    },
    {
        "content": "<p>Fun fact: Windows 3.11 was around 10-15 MB (all of it, not just the code, of course).</p>",
        "id": 258079555,
        "sender_full_name": "Laurențiu",
        "timestamp": 1634582910
    },
    {
        "content": "<p>Dropped <em>by</em>, not dropped <em>to</em>, right? That is, without asists is 13.45?</p>",
        "id": 258152075,
        "sender_full_name": "matklad",
        "timestamp": 1634627924
    },
    {
        "content": "<p>Yeah, it's not like we can do miracles here :D</p>",
        "id": 258152349,
        "sender_full_name": "Laurențiu",
        "timestamp": 1634628050
    },
    {
        "content": "<p>I wouldn't be surprised if we have a couple of more things like <a href=\"https://github.com/rust-lang/rust/issues/88438\">https://github.com/rust-lang/rust/issues/88438</a>. </p>\n<p>I guess, what would be fun is to get LLVM IR after linking (can we get that with LTO?) and analyze the size of functions</p>",
        "id": 258152703,
        "sender_full_name": "matklad",
        "timestamp": 1634628244
    },
    {
        "content": "<p>We can also at the binary size, but I'm not sure it's actionable. For example <code>maybe_collect_expr</code> is 52 KB which seems huge, but it's not like making it smaller would help with anything.</p>",
        "id": 258163982,
        "sender_full_name": "Laurențiu",
        "timestamp": 1634634818
    },
    {
        "content": "<p>also <a href=\"https://prog21.dadgum.com/116.html\">https://prog21.dadgum.com/116.html</a></p>",
        "id": 258174130,
        "sender_full_name": "matklad",
        "timestamp": 1634640541
    },
    {
        "content": "<p>I also tried <code>-Oz</code> (it's 10.5 MB but 2x slower) and <code>-Os</code> (11.5 MB but 1.5x slower). No easy wins there either.</p>",
        "id": 258175355,
        "sender_full_name": "Laurențiu",
        "timestamp": 1634641213
    },
    {
        "content": "<p>But yeah, 1 MB for the assists seems like a lot</p>",
        "id": 258175433,
        "sender_full_name": "Laurențiu",
        "timestamp": 1634641245
    },
    {
        "content": "<p>Fun thing I noticed: a PGO, non-LTO  RA is 1 MB smaller and 23% faster than a plain one</p>",
        "id": 264411283,
        "sender_full_name": "Laurențiu",
        "timestamp": 1639121760
    },
    {
        "content": "<p>23%, wew that's quite something</p>",
        "id": 264432530,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1639135068
    },
    {
        "content": "<p>Yeah, I think we enable LTO on CI and I gave <a href=\"https://github.com/facebookincubator/BOLT/\">https://github.com/facebookincubator/BOLT/</a> a try a while back</p>",
        "id": 264432707,
        "sender_full_name": "Laurențiu",
        "timestamp": 1639135194
    },
    {
        "content": "<p>phoronix had some benchmarking article about bolt recently <a href=\"https://www.phoronix.com/scan.php?page=news_item&amp;px=BOLT-Inches-To-LLVM\">https://www.phoronix.com/scan.php?page=news_item&amp;px=BOLT-Inches-To-LLVM</a><br>\nlto + pgo + bolt seems to be not so bad :)</p>",
        "id": 264551328,
        "sender_full_name": "matthiaskrgr",
        "timestamp": 1639213341
    },
    {
        "content": "<p>I know, only it's not clear to me in which order LTO, PGO and BOLT should be applied. And I can't run it in sampling mode because I don't have an Intel CPU.</p>",
        "id": 264554651,
        "sender_full_name": "Laurențiu",
        "timestamp": 1639218288
    },
    {
        "content": "<p>I think lto + pgo work together and then you use bolt on top...? I not studied bolt yet though</p>",
        "id": 264555750,
        "sender_full_name": "matthiaskrgr",
        "timestamp": 1639219991
    },
    {
        "content": "<p>If you do LTO and PGO, you have to enable LTO for the profile generation phase of PGO in addition to the creation of the final executable. Otherwise PGO won't be able to generate a profile for the LTOed functions and thus will likely ignore a large part of the profile. As for PGO sampling mode  I'm not sure if rustc even supports it in the first place.</p>",
        "id": 264561257,
        "sender_full_name": "bjorn3",
        "timestamp": 1639227224
    },
    {
        "content": "<p>No, I meant the BOLT sampling mode. It uses LBR, which is Intel-only</p>",
        "id": 264561525,
        "sender_full_name": "Laurențiu",
        "timestamp": 1639227556
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>-rwxr-xr-x 2 grayshade grayshade 1.4G Dec 31 12:28 target/release/rust-analyzer\n</code></pre></div>\n<p>Woah.</p>",
        "id": 266495267,
        "sender_full_name": "Laurențiu",
        "timestamp": 1640946590
    },
    {
        "content": "<p>(That's <code>debug = 2</code>)</p>",
        "id": 266495269,
        "sender_full_name": "Laurențiu",
        "timestamp": 1640946599
    },
    {
        "content": "<p>And 335 MB with <code>debug = 1</code>.  There's a comment in <code>xtask/src/dist.rs</code> saying something about 43 MB. I guess that's no longer up to date.</p>",
        "id": 266495427,
        "sender_full_name": "Laurențiu",
        "timestamp": 1640946786
    },
    {
        "content": "<p>did you see <code>cargo-bloat</code> btw? :)</p>\n<div class=\"codehilite\"><pre><span></span><code>    Analyzing target/release/rust-analyzer\n\n File  .text     Size Crate\n 5.1%  12.8%   2.0MiB rust_analyzer\n 4.8%  12.0%   1.8MiB hir_ty\n 3.5%   8.7%   1.3MiB hir_def\n 2.6%   6.6%   1.0MiB ide_assists\n 2.5%   6.3% 990.1KiB std\n 2.1%   5.2% 817.5KiB ide_db\n 2.0%   4.9% 772.2KiB ide\n 1.9%   4.7% 735.8KiB proc_macro_srv\n 1.4%   3.4% 530.5KiB salsa\n 1.1%   2.9% 445.9KiB hir\n 1.1%   2.7% 423.8KiB ide_completion\n 0.9%   2.2% 344.8KiB project_model\n 0.9%   2.1% 331.9KiB serde_json\n 0.8%   2.0% 315.4KiB hir_expand\n 0.7%   1.7% 264.3KiB syntax\n 0.7%   1.7% 259.2KiB ide_ssr\n 0.5%   1.3% 197.3KiB hashbrown\n 0.5%   1.2% 191.3KiB flycheck\n 0.4%   1.1% 165.9KiB regex_syntax\n 0.4%   1.1% 165.5KiB ide_diagnostics\n 5.4%  13.3%   2.0MiB And 91 more crates. Use -n N to show more.\n40.2% 100.0%  15.3MiB .text section size, the file size is 38.0MiB\n\nNote: numbers above are a result of guesswork. They are not 100% correct and never will be.\n</code></pre></div>",
        "id": 266500430,
        "sender_full_name": "matthiaskrgr",
        "timestamp": 1640952868
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code> File  .text    Size          Crate Name\n 0.1%   0.2% 30.9KiB         hir_ty hir_ty::infer::expr::&lt;impl hir_ty::infer::InferenceContext&gt;::infer_expr_inner\n 0.1%   0.2% 27.9KiB        hir_def hir_def::body::lower::ExprCollector::maybe_collect_expr\n 0.1%   0.1% 21.2KiB         ide_db ide_db::apply_change::&lt;impl ide_db::RootDatabase&gt;::per_query_memory_usage\n 0.1%   0.1% 20.7KiB    chalk_solve &lt;chalk_solve::rust_ir::AssociatedTyDatum&lt;I&gt; as chalk_solve::clauses::program_clauses::ToProgramClauses&lt;I&gt;&gt;::to_program_clauses::{{closure}}\n 0.1%   0.1% 20.6KiB        hir_def hir_def::nameres::collector::ModCollector::collect\n 0.1%   0.1% 20.1KiB        hir_def hir_def::nameres::path_resolution::&lt;impl hir_def::nameres::DefMap&gt;::resolve_path_fp_with_macro_single\n 0.1%   0.1% 20.0KiB proc_macro_srv &lt;proc_macro_srv::abis::abi_1_58::proc_macro::bridge::server::Dispatcher&lt;proc_macro_srv::abis::abi_1_58::proc_macro::bridge::server::MarkedTypes&lt;S&gt;&gt; as proc_macro_srv::abis::abi_1_58::proc_macro::bridge::server::DispatcherTrait&gt;::dispatch\n 0.1%   0.1% 20.0KiB            std addr2line::ResDwarf&lt;R&gt;::parse\n 0.1%   0.1% 19.8KiB         notify notify::inotify::EventLoop::event_loop_thread\n 0.1%   0.1% 19.7KiB  rust_analyzer rust_analyzer::main_loop::&lt;impl rust_analyzer::global_state::GlobalState&gt;::handle_event\n 0.1%   0.1% 19.5KiB            mbe mbe::expander::matcher::match_loop\n 0.0%   0.1% 19.3KiB proc_macro_srv &lt;proc_macro_srv::abis::abi_1_56::proc_macro::bridge::server::Dispatcher&lt;proc_macro_srv::abis::abi_1_56::proc_macro::bridge::server::MarkedTypes&lt;S&gt;&gt; as proc_macro_srv::abis::abi_1_56::proc_macro::bridge::server::DispatcherTrait&gt;::dispatch\n 0.0%   0.1% 18.2KiB proc_macro_srv &lt;proc_macro_srv::abis::abi_1_55::proc_macro::bridge::server::Dispatcher&lt;proc_macro_srv::abis::abi_1_55::proc_macro::bridge::server::MarkedTypes&lt;S&gt;&gt; as proc_macro_srv::abis::abi_1_55::proc_macro::bridge::server::DispatcherTrait&gt;::dispatch\n 0.0%   0.1% 18.1KiB pulldown_cmark pulldown_cmark::parse::Parser::handle_inline_pass1\n 0.0%   0.1% 18.0KiB proc_macro_srv &lt;proc_macro_srv::abis::abi_1_47::proc_macro::bridge::server::Dispatcher&lt;proc_macro_srv::abis::abi_1_47::proc_macro::bridge::server::MarkedTypes&lt;S&gt;&gt; as proc_macro_srv::abis::abi_1_47::proc_macro::bridge::server::DispatcherTrait&gt;::dispatch\n 0.0%   0.1% 17.8KiB            std std::backtrace_rs::symbolize::gimli::resolve::{{closure}}\n 0.0%   0.1% 16.6KiB  rust_analyzer rust_analyzer::config::field_props\n 0.0%   0.1% 16.2KiB pulldown_cmark pulldown_cmark::parse::Parser::new_with_broken_link_callback\n 0.0%   0.1% 16.2KiB        hir_def hir_def::nameres::collector::collect_defs\n 0.0%   0.1% 15.8KiB  project_model project_model::workspace::ProjectWorkspace::to_crate_graph\n38.3%  95.4% 14.6MiB                And 42372 smaller methods. Use -n N to show more.\n</code></pre></div>",
        "id": 266500452,
        "sender_full_name": "matthiaskrgr",
        "timestamp": 1640952914
    },
    {
        "content": "<p>Yeah, this is strictly about debug symbols. Though 23.8 MB of <code>text</code> is nothing to sneer at.</p>",
        "id": 266501241,
        "sender_full_name": "Laurențiu",
        "timestamp": 1640954092
    },
    {
        "content": "<p>I wonder what that <code>text</code> is.... Would be cool to have <code>cargo llvm-lines flamegraph</code>!</p>",
        "id": 266620892,
        "sender_full_name": "matklad",
        "timestamp": 1641140018
    },
    {
        "content": "<p>Or if <code>cargo bloat</code> could group across monomorphizations</p>",
        "id": 266621049,
        "sender_full_name": "Laurențiu",
        "timestamp": 1641140172
    },
    {
        "content": "<p><a href=\"https://github.com/dtolnay/cargo-llvm-lines/issues/25\">https://github.com/dtolnay/cargo-llvm-lines/issues/25</a></p>",
        "id": 266621324,
        "sender_full_name": "matklad",
        "timestamp": 1641140562
    },
    {
        "content": "<p>I wonder if there's some way to get that with <code>lto=full</code>?</p>",
        "id": 266621327,
        "sender_full_name": "matklad",
        "timestamp": 1641140581
    },
    {
        "content": "<p>And <a href=\"https://github.com/RazrFalcon/cargo-bloat/issues/19\">https://github.com/RazrFalcon/cargo-bloat/issues/19</a></p>",
        "id": 266621415,
        "sender_full_name": "Laurențiu",
        "timestamp": 1641140709
    },
    {
        "content": "<p>Summon <span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span> :0) </p>\n<p>Question: </p>\n<p>The way <code>cargo llvm-lines</code> works is by passing <code>--emit=llvm-ir</code> to <code>cargo rustc</code>, which gives llvm output for the leaf crate which is being compiled. I would love to get that rather for all the crates together. </p>\n<p>My understanding is that <code>lto=full</code> does do that internally somehow -- with <code>lto=full</code>, <code>rlib</code>s embedded llvm bitcode, and than at the final linking step the linker/compiler combines them all togethre into a single giant CU. Is there some magic flag somewhere which I can pass to the LLVM linker, which would instruct it to emit humongous file with LLVM IR for the whole of the final artifact, rather than compile that down to machine code?</p>",
        "id": 266621709,
        "sender_full_name": "matklad",
        "timestamp": 1641141095
    },
    {
        "content": "<blockquote>\n<p>My understanding is that lto=full does do that internally somehow -- with lto=full, rlibs embedded llvm bitcode, and than at the final linking step the linker/compiler combines them all togethre into a single giant CU.</p>\n</blockquote>\n<p>Correct.</p>\n<blockquote>\n<p>Is there some magic flag somewhere which I can pass to the LLVM linker, which would instruct it to emit humongous file with LLVM IR for the whole of the final artifact, rather than compile that down to machine code?</p>\n</blockquote>\n<p>Doesn't <code>--emit=llvm-ir</code> output the post LTO llvm ir when compiling the final executable?</p>",
        "id": 266624294,
        "sender_full_name": "bjorn3",
        "timestamp": 1641144669
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133169\">@matklad</span></p>",
        "id": 266624304,
        "sender_full_name": "bjorn3",
        "timestamp": 1641144688
    },
    {
        "content": "<p>Wow, it seems that indeed just works, many thanks! </p>\n<div class=\"codehilite\"><pre><span></span><code>$ CARGO_PROFILE_RELEASE_LTO=fat cargo llvm-lines -p rust-analyzer --bin rust-analyzer --release | head -n 100\n</code></pre></div>",
        "id": 266628308,
        "sender_full_name": "matklad",
        "timestamp": 1641150391
    }
]