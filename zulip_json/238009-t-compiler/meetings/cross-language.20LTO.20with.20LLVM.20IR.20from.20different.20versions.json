[
    {
        "content": "<p><a href=\"https://www.llvm.org/docs/DeveloperPolicy.html#ir-backwards-compatibility\">https://www.llvm.org/docs/DeveloperPolicy.html#ir-backwards-compatibility</a></p>",
        "id": 257549575,
        "sender_full_name": "tm",
        "timestamp": 1634223517
    },
    {
        "content": "<blockquote>\n<p>The current LLVM version supports loading any bitcode since version 3.0.<br>\nAfter each X.Y release, compatibility.ll must be copied to compatibility-X.Y.ll. The corresponding bitcode file should be assembled using the X.Y build and committed as compatibility-X.Y.ll.bc.<br>\nNewer releases can ignore features from older releases, but they cannot miscompile them. For example, if nsw is ever replaced with something else, dropping it would be a valid way to upgrade the IR.</p>\n</blockquote>\n<p>this doesn't seem to match \"up to and including UB\"</p>",
        "id": 257549693,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1634223571
    },
    {
        "content": "<p>There's also a plugin to LLVM involved so if the LLVM version the plugin was compiled with doesn't match the version of LLVM it's loaded into at runtime ... <span aria-label=\"boom\" class=\"emoji emoji-1f4a5\" role=\"img\" title=\"boom\">:boom:</span></p>",
        "id": 257550068,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1634223695
    },
    {
        "content": "<p>so let me see if I understand how cross-lang LTO works correctly:</p>\n<ol>\n<li>when rustc emits .o files, it's actually emitting LLVM bitcode</li>\n<li>when clang emits .o files, it's also emitting bitcode</li>\n<li>when clang links all the .o files, it does a bunch of optimization passes, then emits an ELF file</li>\n</ol>",
        "id": 257550381,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1634223806
    },
    {
        "content": "<p>so it shouldn't matter what LLVM version rustc is using for the <em>plugin</em>, right? since we're not dynamically loading the plugin to rustc, only into clang</p>",
        "id": 257550482,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1634223842
    },
    {
        "content": "<p>cc <span class=\"user-group-mention\" data-user-group-id=\"1176\">@WG-llvm</span>, does that match your understanding? a few people said in the meeting that only the exact version of LLVM that rustc uses was supported, but that doesn't seem to match LLVM's own docs ...</p>",
        "id": 257550806,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1634223970
    },
    {
        "content": "<p>Hmm. I think it your linker plugin is newer than the bitcode emitted by rustc, you <em>should</em> be ok. If it's older though, we could generate new bitcode and then who knows what the plugin will do?</p>",
        "id": 257551019,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1634224045
    },
    {
        "content": "<p>it will always be newer, that bit's not a problem</p>",
        "id": 257551050,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1634224058
    },
    {
        "content": "<p>I mean, how do you know that?</p>",
        "id": 257551098,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1634224075
    },
    {
        "content": "<p>we run tip of tree for LLVM</p>",
        "id": 257551163,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1634224086
    },
    {
        "content": "<p>Oh</p>",
        "id": 257551183,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1634224093
    },
    {
        "content": "<p>(well, \"whatever v8 decides to download\", but it always downloads tip of tree)</p>",
        "id": 257551204,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1634224099
    },
    {
        "content": "<p>Sure, I meant in the general case</p>",
        "id": 257551207,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1634224099
    },
    {
        "content": "<p>If you're using Debian Stable and got lld from the distro, you're probably not running same or newer than rustc <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 257551275,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1634224127
    },
    {
        "content": "<p>So is the advice “link with the same or newer clang” rather than “versions must match” safe?</p>",
        "id": 257551288,
        "sender_full_name": "Vitali Lovich",
        "timestamp": 1634224132
    },
    {
        "content": "<p>My advice would be \"use the same version\". Beyond that, it seems like it would probably work if you have a newer clang.</p>",
        "id": 257551438,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1634224186
    },
    {
        "content": "<p>I feel like a newer clang might (for example) more eagerly optimize and end up causing UB for rustc generated bitcode targeting an older LLVM because it assumes the lack of an attribute implies a guarantee (e.g., a situation inverse to the mustprogress attribute). Maybe that never happens, though.</p>",
        "id": 257551454,
        "sender_full_name": "simulacrum",
        "timestamp": 1634224191
    },
    {
        "content": "<p>Yeah, that’s the kind of thing I was thinking of. Does LLVM generate those attributes themselves when generating bitcode or are those always user annotations?</p>",
        "id": 257551668,
        "sender_full_name": "Vitali Lovich",
        "timestamp": 1634224263
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"450867\">@Vitali Lovich</span> I'm not sure what you mean by generating bitcode - you need a compiler frontend to generate bitcode. Do you mean \"are the attributes added during optimization passes\"?</p>",
        "id": 257551797,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1634224306
    },
    {
        "content": "<p>\"use the exact same version\" is the only combination I'm aware of actually being used in production. I believe Mozilla builds FF with xlang LTO but they literally use exactly the same build of LLVM for both clang and rustc. Anything beyond that is probably not getting much (if any) testing.</p>",
        "id": 257551932,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1634224354
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/238009-t-compiler.2Fmeetings/topic/cross-language.20LTO.20with.20LLVM.20IR.20from.20different.20versions/near/257551454\">said</a>:</p>\n<blockquote>\n<p>I feel like a newer clang might (for example) more eagerly optimize and end up causing UB for rustc generated bitcode targeting an older LLVM because it assumes the lack of an attribute implies a guarantee (e.g., a situation inverse to the mustprogress attribute). Maybe that never happens, though.</p>\n</blockquote>\n<p>that's not what their docs say, though ...</p>\n<blockquote>\n<p>Newer releases can ignore features from older releases, but they cannot miscompile them. For example, if nsw is ever replaced with something else, dropping it would be a valid way to upgrade the IR.</p>\n</blockquote>",
        "id": 257551943,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1634224360
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232545\">Joshua Nelson</span> <a href=\"#narrow/stream/238009-t-compiler.2Fmeetings/topic/cross-language.20LTO.20with.20LLVM.20IR.20from.20different.20versions/near/257551797\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"450867\">Vitali Lovich</span> I'm not sure what you mean by generating bitcode - you need a compiler frontend to generate bitcode. Do you mean \"are the attributes added during optimization passes\"?</p>\n</blockquote>\n<p>I mean are they added by any part of the compilation pipeline (whether LLVM by itself or the frontend talking to LLVM) or are they user annotations. Technically you can also write LLVM IR by hand too. That’s how their test suite works :)</p>",
        "id": 257552248,
        "sender_full_name": "Vitali Lovich",
        "timestamp": 1634224476
    },
    {
        "content": "<p>I'm confused what \"user annotations\" means in this context.</p>",
        "id": 257552434,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1634224541
    },
    {
        "content": "<p>I think \"ignore features\" sounds good in practice, but I think I'm describing a little different situation? In the sense that the newer LLVM has gained a new optimization that Rust code is incompatible with and adds an attribute to disable it. rustc hasn't updated to emit that attribute yet, though.</p>\n<p>Maybe any such optimizations would always be gated on the presence of an attribute (or the upgrade path these docs talk about would automatically add it), I don't know.</p>\n<p>I think the \"same version\" ask is probably the best path though :)</p>",
        "id": 257552520,
        "sender_full_name": "simulacrum",
        "timestamp": 1634224562
    },
    {
        "content": "<blockquote>\n<p>I think \"ignore features\" sounds good in practice, but I think I'm describing a little different situation? In the sense that the newer LLVM has gained a new optimization that Rust code is incompatible with and adds an attribute to disable it. rustc hasn't updated to emit that attribute yet, though.</p>\n</blockquote>\n<p>ok, yes, I see. Sounds like a good question for the LLVM mailing list.</p>",
        "id": 257552724,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1634224641
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232545\">Joshua Nelson</span> <a href=\"#narrow/stream/238009-t-compiler.2Fmeetings/topic/cross-language.20LTO.20with.20LLVM.20IR.20from.20different.20versions/near/257550806\">said</a>:</p>\n<blockquote>\n<p>cc <span class=\"user-group-mention silent\" data-user-group-id=\"1176\">WG-llvm</span>, does that match your understanding? a few people said in the meeting that only the exact version of LLVM that rustc uses was supported, but that doesn't seem to match LLVM's own docs ...</p>\n</blockquote>\n<p>The reason this is typically said is because rustc is most likely going to have a more recent LLVM than the system LLVM/clang/etc.</p>",
        "id": 257558554,
        "sender_full_name": "nagisa",
        "timestamp": 1634226794
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"123586\">@nagisa</span> so it <em>is</em> supported if rustc has a less recent version?</p>",
        "id": 257564206,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1634228953
    },
    {
        "content": "<p>I'm not sure I'm comfortable claiming any particular compatibility other than \"sufficiently compatible when LLVM version matches\".</p>",
        "id": 257565946,
        "sender_full_name": "nagisa",
        "timestamp": 1634229613
    },
    {
        "content": "<p>Primarily because it is possible to sandwich toolchains together into a layered pastry.</p>",
        "id": 257566109,
        "sender_full_name": "nagisa",
        "timestamp": 1634229689
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/238009-t-compiler.2Fmeetings/topic/cross-language.20LTO.20with.20LLVM.20IR.20from.20different.20versions/near/257552520\">said</a>:</p>\n<blockquote>\n<p>I think \"ignore features\" sounds good in practice, but I think I'm describing a little different situation? In the sense that the newer LLVM has gained a new optimization that Rust code is incompatible with and adds an attribute to disable it. rustc hasn't updated to emit that attribute yet, though.</p>\n</blockquote>\n<p>Not quite the case you're describing, but if you take bitcode generated by LLVM 12 and run it through LLVM 13, you may get miscompiles of logical and/or. LLVM 12 will incorrectly optimize logical and/or but also avoid other optimizations because it knows it does this wrong. LLVM 13 on the other hand will exploit the fact that the incorrect optimization no longer exists.</p>",
        "id": 257566725,
        "sender_full_name": "Nikita Popov",
        "timestamp": 1634229935
    },
    {
        "content": "<p>I think in the past it was also more fraught because we had a tendency to take LLVM trunk snapshots, but for a while now we've been waiting until release branches to pull in the next version.</p>",
        "id": 257570606,
        "sender_full_name": "cuviper",
        "timestamp": 1634231316
    }
]