[
    {
        "content": "<p>A new proposal has been announced: <a href=\"https://github.com/rust-lang/lang-team/issues/38\">#38</a>. It will be announced at the next meeting to try and draw attention to it, but usually MCPs are not discussed during triage meetings. If you think this would benefit from discussion amongst the team, consider proposing a design meeting.</p>",
        "id": 205022620,
        "sender_full_name": "triagebot",
        "timestamp": 1595713058
    },
    {
        "content": "<p>Original discussion: <a href=\"#narrow/stream/219381-t-libs/topic/Elevated.20priviliges.20for.20.23.5Btest_util.5D\">https://rust-lang.zulipchat.com/#narrow/stream/219381-t-libs/topic/Elevated.20priviliges.20for.20.23.5Btest_util.5D</a></p>",
        "id": 205025556,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595718151
    },
    {
        "content": "<p>How does this interact with the test-only-visibility proposal that was mentioned here at some point?</p>",
        "id": 205027625,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1595721769
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"211727\">@Jonas Schievink</span> I can't find the proposal you're talking about in either <a href=\"https://github.com/rust-lang/lang-team/issues?q=is%3Aissue+is%3Aopen+test\">https://github.com/rust-lang/lang-team/issues?q=is%3Aissue+is%3Aopen+test</a> or searching zulip. Do you have a link?</p>",
        "id": 205028360,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595723219
    },
    {
        "content": "<p>Hmm, no. Maybe it was somewhere else.</p>",
        "id": 205028574,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1595723563
    },
    {
        "content": "<p>I don't think it's been formally proposed, but test visibility is roughly <code>pub(if cfg!(test))</code>. If the <code>cfg!</code> is <code>pub(if true)</code>, the item is <code>pub</code>. If the <code>cfg!</code> is <code>pub(if false)</code>, the item is <code>pub(self)</code> (as if <code>pub</code> had not been written).</p>",
        "id": 205032618,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1595731725
    },
    {
        "content": "<p>Various syntaxes have been floated, from the obvious <code>pub(test)</code> which is ambiguous (with <code>pub (test)</code>, as parametized visibility must start with a keyword) to <code>pub(#[cfg(..)] in path)</code> which would be a more general way to conditionally raise the visibility.</p>",
        "id": 205032757,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1595731931
    },
    {
        "content": "<p>Personally I think allowing <code>pub(if $macro_call)</code> which would expands to a new allowed <code>pub(if $bool_lit)</code> is enough; more complicated cases would just end up being an intelligible micro language better served by just using the currently stable workaround of defining the thing twice with the correct visibility under a <code>#[cfg]</code>.</p>",
        "id": 205032830,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1595732049
    },
    {
        "content": "<p>That sounds fine to me <span aria-label=\"thumbs up\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"thumbs up\">:thumbs_up:</span></p>",
        "id": 205033554,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595733558
    },
    {
        "content": "<p>You get all the benefit of this proposal but it's more flexible and requires only a small change to the language</p>",
        "id": 205033559,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595733584
    },
    {
        "content": "<p>Plus less bikeshedding hopefully</p>",
        "id": 205033598,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595733605
    },
    {
        "content": "<p>Personally I would support <code>pub(#[cfg])</code> just because it's very self-evident what that does</p>",
        "id": 205033620,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595733687
    },
    {
        "content": "<p>That proposal sounds even better to me. As you said, it covers a wider range of use cases. E.g. your proposed <code>pub(#[cfg])</code> would also cover integration tests.</p>",
        "id": 205043793,
        "sender_full_name": "Wodann",
        "timestamp": 1595755062
    },
    {
        "content": "<p><code>pub(#[cfg])</code> for visibility is only syntactically viable if we say we never will support attributes on the types in a tuple</p>",
        "id": 205070995,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1595804532
    },
    {
        "content": "<p>The reason <code>pub(visibility)</code> is required to start with a keyword is so that <code>struct Tuple ( pub ( &gt;|&lt;</code> can know whether you've just opened a parenthesized type or a <code>pub(restrict)</code> in fixed lookahead</p>",
        "id": 205071060,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1595804677
    },
    {
        "content": "<p>Wouldn't the parser be able to detect both <code>struct Tuple ( pub ( &gt;|&lt;</code> and <code>struct Tuple ( pub ( #[ &gt;|&lt;</code>? I'd prefer a design that scales to all <code>pub</code> use cases, as it would be counterintuitive if the pattern works for some but not all <code>pub( ... )</code></p>",
        "id": 205766598,
        "sender_full_name": "Wodann",
        "timestamp": 1596440206
    },
    {
        "content": "<p>As I said, it's viable (without unbounded lookahead or backtracking) if and only if we commit to never having attributes inside tuple types</p>",
        "id": 205821399,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1596474965
    },
    {
        "content": "<p>E.g. should <code>(#[cfg(x86)] u32, #[cfg(x64)] u64, usize)</code> ever be a valid type?</p>",
        "id": 205821501,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1596475022
    },
    {
        "content": "<p><a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=ef508d28fc3e51abb611b6046c3ac41c\">It is valid as a named Tuple type</a></p>",
        "id": 205821712,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1596475137
    },
    {
        "content": "<p>As a different argument, with <code>pub(#[cfg(X)] in path)</code>, what's the visibility when the cfg is false? Simple removal would suggest <code>pub()</code> (illegal form) or <code>pub</code> (globally public).</p>\n<p>That really doesn't seem a useful interpretation; you typically want \"elevate visibility if\" not \"elevate visibility if not\", and if the point of <code>#[cfg]</code> forms is flexibility, it's still falling back to globally visible, so it's not flexible enough.</p>\n<p>If you say to well, use <code>cfg_if!</code> so you have an explicit fallback, what do you say <code>cfg_if!</code> should even expand to? We don't have <code>pub(restrict, restrict)</code> forms, and what would that even mean? The repetition and multiple restrictions is required for a multiple-choice <code>#[cfg]</code> solution, even if it only ever expands to one actual restriction, because we can't know that until after expanding the cfgs, so the language has to support multiple restrictions at the same time.</p>\n<p>It's also fairly simple to set up a proc-macro to create a set of <code>#[cfg]</code>d exports forwarding to a single impl, so my argument is that the simple <code>pub(if $bool_or_macro_bool)</code> is more than enough.</p>",
        "id": 205823051,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1596475865
    },
    {
        "content": "<blockquote>\n<p>fairly simple to set up a proc-macro</p>\n</blockquote>\n<p>Here's a proof-of-concept I threw together: <a href=\"https://github.com/CAD97/cfg-pub\">https://github.com/CAD97/cfg-pub</a></p>",
        "id": 205846010,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1596487885
    },
    {
        "content": "<p>It doesn't do anything clever like forwarding to a single impl that's always present, it just copy-pastes the item with the different attributes and visibility, to make it simpler.</p>",
        "id": 205846088,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1596487927
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"132829\">Christopher Durham</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/MCP.3A.20Elevated.20privileges.20for.20.23.5Btest_util.5D.20lang-team.2338/near/205821501\">said</a>:</p>\n<blockquote>\n<p>E.g. should <code>(#[cfg(x86)] u32, #[cfg(x64)] u64, usize)</code> ever be a valid type?</p>\n</blockquote>\n<p>I didn't know that was possible. In that case, you can make a field <code>pub</code> for tests-only within a crate <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=e62793f7a1c1a52ced289e2a7e947339\">already</a>.</p>",
        "id": 206002489,
        "sender_full_name": "Wodann",
        "timestamp": 1596618992
    },
    {
        "content": "<p>I agree with all of the caveats that you've brought forth. In the end the goal would be to expose some (tuple) struct fields only for tests. The approach that I had in mind when creating this MCP was:</p>\n<blockquote>\n<p>As a test writer I want to have access to non-pub fields (or methods) in a function that cannot have the <code>#[test]</code> attribute.</p>\n</blockquote>\n<p>An alternative could however also be:</p>\n<blockquote>\n<p>Specifically for tests, I expose these non-pub fields (or methods).</p>\n</blockquote>\n<p>I am not sure which approach is more desirable for writing clear and concise code, nor whether it is even possible to have an out-of-crate integration test access a <code>#[cfg(test)] pub field</code>. I'll do some more investigation for that.</p>",
        "id": 206003140,
        "sender_full_name": "Wodann",
        "timestamp": 1596619586
    },
    {
        "content": "<p>a compiler flag for just blanket \"this is testing mode, ignore visibility, trust me i know what I'm doing\" without a specific configuration anywhere seems fine in the scheme of things.</p>\n<p>Presumably it would only work for types within the same crate, but actually there's no reason it couldn't just work for all types everywhere. Obviously if the user uses such a flag they've jumped well outside of normal semver/safety/sanity.</p>",
        "id": 206021873,
        "sender_full_name": "Lokathor",
        "timestamp": 1596634247
    },
    {
        "content": "<p>All types everywhere seems like overkill</p>",
        "id": 206022376,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1596634517
    },
    {
        "content": "<p>The use case for this in <a href=\"http://docs.rs\">docs.rs</a> is that we want to benchmark private functions</p>",
        "id": 206022391,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1596634531
    },
    {
        "content": "<p>But we don't need access to anything private in our dependencies</p>",
        "id": 206022406,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1596634545
    },
    {
        "content": "<p>I don't personally use workspaces, but some people seem to be in love with having a sprawling crate graph. For that situation, it seems easily possible that you'd want a test to inspect the internals of \"another crate\" (but still your overall project).</p>",
        "id": 206023853,
        "sender_full_name": "Lokathor",
        "timestamp": 1596635367
    },
    {
        "content": "<p>As far as I know, <a href=\"https://doc.rust-lang.org/rust-by-example/testing/integration_testing.html\">integration tests</a> are also \"outside\" of the crate - even though they are actually part of the crate's project structure.</p>",
        "id": 206025405,
        "sender_full_name": "Wodann",
        "timestamp": 1596636173
    }
]