[
    {
        "content": "<p>A new proposal has been announced: <a href=\"https://github.com/rust-lang/lang-team/issues/135\">Attribute to reverse field destruction order in the drop glue #135</a>. It will be announced at the next meeting to try and draw attention to it, but usually MCPs are not discussed during triage meetings. If you think this would benefit from discussion amongst the team, consider proposing a design meeting.</p>",
        "id": 266976398,
        "sender_full_name": "triagebot",
        "timestamp": 1641409435
    },
    {
        "content": "<p>Bikeshedding: I almost never think about struct drop order, and I usually forget if it's first-to-last or last-to-first (I suspect this is true for most users as well). I initially read <code>reverse_drop</code> as 'do the opposite of the standard drop order' (which means the same thing as 'drop with the fields reversed).</p>\n<p>I think it would be useful to make the attribute name be less ambiguous for someone who doesn't know the 'standard' drop order. Maybe something like <code>#[drop_fields_reversed]</code> or <code>#[drop_from_end]</code>?</p>",
        "id": 266978282,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641410348
    },
    {
        "content": "<p>Also, are there any other use-cases besides C++ interop? I think that C++ interop could be a sufficient motivation, but I'm wondering if it's the only one</p>",
        "id": 266978457,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641410431
    },
    {
        "content": "<p><span class=\"user-group-mention\" data-user-group-id=\"1977\">@T-lang</span>: Proposal <a href=\"https://github.com/rust-lang/lang-team/issues/135#issuecomment-1006017093\">#135</a> has been seconded, and will be approved in 10 days if no objections are raised.</p>",
        "id": 266979796,
        "sender_full_name": "triagebot",
        "timestamp": 1641411109
    },
    {
        "content": "<p>Given that <code>ManuallyDrop</code> is specifically for customizing the drop order in the first place, it seems quite weird to also add additional attributes IMO.</p>",
        "id": 266984159,
        "sender_full_name": "nagisa",
        "timestamp": 1641413193
    },
    {
        "content": "<p>I guess to expand: to me the use-case description reads a lot like what code generation would encounter (i.e. these structs aren't written by developers) and in those instances I have a hard time seeing how generating manuallydrop would be an issue.</p>",
        "id": 266985416,
        "sender_full_name": "nagisa",
        "timestamp": 1641413822
    },
    {
        "content": "<p>It interferes with use of the field itself, for one</p>",
        "id": 266988421,
        "sender_full_name": "Lokathor",
        "timestamp": 1641415375
    },
    {
        "content": "<p>I don't necessarily disagree, but I don't think the <code>ManuallyDrop</code> impedes use of the contained value all that significantly, given its implementations of Deref and DerefMut. The few things that come to mind are constructing the type containing ManuallyDrop, moving a field out of the type (need to unwrap the manuallydrop), and copying a field (in which case presence of ManuallyDrop makes little sense).</p>\n<p>More importantly though, the MCP itself does not appear to provide any motivation of the sort.</p>",
        "id": 266991428,
        "sender_full_name": "nagisa",
        "timestamp": 1641416951
    },
    {
        "content": "<p>Apologies for the delayed response, I wasn't expecting so much discussion so quickly. Really happy to see it! :)</p>\n<p><span class=\"user-mention silent\" data-user-id=\"123586\">nagisa</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Attribute.20to.20reverse.20field.20destruction.20order.20.E2.80.A6.20lang-team.23135/near/266991428\">said</a>:</p>\n<blockquote>\n<p>copying a field (in which case presence of ManuallyDrop makes little sense).</p>\n</blockquote>\n<p>I think copying is fine, it auto-implements Copy and Clone. <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=cb00f7966760d6b57c185abe59e2ccec\">example</a></p>\n<blockquote>\n<p>More importantly though, the MCP itself does not appear to provide any motivation of the sort.</p>\n</blockquote>\n<p>Yes, it's only alluded to in the last section (\"The important part is that it doesn't complicate the user-visible interface.\"), not directly explained. Should I add commentary on this to the proposal or is it supposed to be immutable?</p>\n<p>Construction is a big drag: a C++ programmer who used to write <code>Foo { .x=x, .y=x}</code> must now write <code>Foo {x: ManuallyDrop::new(x), y: ManuallyDrop::new(y)}</code>, for reasons that they don't really care about as a user. And there is no way in the language to avoid this. FFI is forced to be verbose in a way we'd never find acceptable for non-FFI code. My opinion: this is worth fixing, to make it easy to move code back and forth between C++ and Rust.</p>\n<p>(Subtle nit-picky issue nobody else is likely to bring up: <code>ManuallyDrop</code> itself is somewhat iffy, as it does not guarantee that it is <a href=\"https://doc.rust-lang.org/std/pin/index.html#projections-and-structural-pinning\">structurally pinned</a>. Thus, when handling self-referential C++ types, in order to project the pins, we probably need to write a new <code>ManuallyDrop</code>-like type which guarantees it is structurally pinned, as <code>ManuallyDrop</code> makes no such guarantee. That, or we should change <code>ManuallyDrop</code> to document that pin projection is safe on it, and even to implement pin projection. We should probably do that anyway, since otherwise there's no way to do pin projection on a union of a type with a destructor -- they can't use a <code>ManuallyDrop</code>-like type, but are hardwired to only allow <code>ManuallyDrop</code> itself.)</p>\n<p><span class=\"user-mention silent\" data-user-id=\"123586\">nagisa</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Attribute.20to.20reverse.20field.20destruction.20order.20.E2.80.A6.20lang-team.23135/near/266984159\">said</a>:</p>\n<blockquote>\n<p>Given that <code>ManuallyDrop</code> is specifically for customizing the drop order in the first place, it seems quite weird to also add additional attributes IMO.</p>\n</blockquote>\n<p>Perhaps the proposal should note that <code>ManuallyDrop</code> itself <a href=\"https://doc.rust-lang.org/std/mem/struct.ManuallyDrop.html#manuallydrop-and-drop-order\">discourages this use case</a> (emphasis added):</p>\n<blockquote>\n<p>Rust has a well-defined drop order of values. <strong>To make sure that fields or locals are dropped in a specific order, reorder the declarations such that the implicit drop order is the correct one.</strong></p>\n<p>It is possible to use <code>ManuallyDrop</code> to control the drop order, but this requires unsafe code and is hard to do correctly in the presence of unwinding.</p>\n</blockquote>\n<p>Though given that we're hopefully generating the code, this is a different situation than what it had in mind.</p>",
        "id": 267008811,
        "sender_full_name": "Devin Jeanpierre",
        "timestamp": 1641426736
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125294\">Aaron Hill</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Attribute.20to.20reverse.20field.20destruction.20order.20.E2.80.A6.20lang-team.23135/near/266978282\">said</a>:</p>\n<blockquote>\n<p>I think it would be useful to make the attribute name be less ambiguous for someone who doesn't know the 'standard' drop order. Maybe something like <code>#[drop_fields_reversed]</code> or <code>#[drop_from_end]</code></p>\n</blockquote>\n<p>I quite like <code>#[drop_from_end]</code> FWIW.  I agree it's nice that it doesn't assume knowledge of the existing order or anything: it's clear without any additional context.</p>",
        "id": 267008982,
        "sender_full_name": "Devin Jeanpierre",
        "timestamp": 1641426865
    },
    {
        "content": "<p>I think this is an overly-specific feature. I'd rather see a more general version, something like a <code>manually_drop</code> attribute which means that all <br>\nfields are implicitly manually dropped and then it is the responsibility of the author to drop them in the destructor.</p>",
        "id": 267038129,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1641459491
    },
    {
        "content": "<p>I'd also like to step back a bit on C++ interop as a motivator for language features. There seem to be multiple attempts at C++ interop going on at the moment and if we add every language feature for every approach we'll have a massive mess. I'd prefer to see some more high level planning and a vision for how the whole thing might work in the long run and then assess the merits of the language features required as a whole</p>",
        "id": 267038311,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1641459622
    },
    {
        "content": "<p>(note that I do thing C++ interop is a worthy motivator for adding language features, I just worry that the current approach is too ad hoc)</p>",
        "id": 267038364,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1641459661
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Attribute.20to.20reverse.20field.20destruction.20order.20.E2.80.A6.20lang-team.23135/near/267038129\">said</a>:</p>\n<blockquote>\n<p>I think this is an overly-specific feature. I'd rather see a more general version, something like a <code>manually_drop</code> attribute which means that all <br>\nfields are implicitly manually dropped and then it is the responsibility of the author to drop them in the destructor.</p>\n</blockquote>\n<p>Ooh, OK. I had my head stuck around \"overriding the drop glue\", but I think this works out better. So you'd be more supportive of something like this?</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[manually_drop]</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">S</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">x</span>: <span class=\"nc\">T1</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">y</span>: <span class=\"nc\">T2</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"nb\">Drop</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">fn</span> <span class=\"nf\">drop</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"n\">std</span>::<span class=\"n\">ptr</span>::<span class=\"n\">drop_in_place</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"n\">std</span>::<span class=\"n\">ptr</span>::<span class=\"n\">drop_in_place</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">y</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>The reason I didn't like this approach was only that I couldn't think of a variation that didn't require a ton of work, but this looks relatively simple, general, and solves a lot of problems at once. (In particular, it doesn't have the downsides of the alternative that I listed in the proposal.)</p>\n<p>If this sounds better to you as well, I'd be very happy to switch to suggesting this, instead of the ad-hoc <code>#[reverse_drop]</code> or <code>#[drop_from_end]</code> type of attribute.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Attribute.20to.20reverse.20field.20destruction.20order.20.E2.80.A6.20lang-team.23135/near/267038311\">said</a>:</p>\n<blockquote>\n<p>There seem to be multiple attempts at C++ interop going on at the moment and if we add every language feature for every approach we'll have a massive mess.</p>\n</blockquote>\n<p>+1 to avoiding a mess.</p>\n<p>FWIW, I don't think there is <em>any</em> version of C++ interop that can avoid this problem: if you run the C++ destructors in Rust, then you _need_ to be able to run the field destructors in the correct order (if there is no user-defined destructor), or not at all (if it does have a user-defined destructor, which you invoke from Rust). So I do not believe anything like this will cause such a mess -- at worst, some versions of C++ interop will not use it, because they do not run C++ destructors from Rust.</p>\n<p><code>#[reverse_drop]</code> allows you to run them in the correct order, but doesn't solve \"don't run them at all\", which still requires <code>ManuallyDrop</code>. So the best we could say about <code>#[reverse_drop]</code> is that it could be designed in a way that allows automated migration to a better approach later. But if we have a better approach now, which solves all the problems at once, then we should do that.</p>",
        "id": 267073962,
        "sender_full_name": "Devin Jeanpierre",
        "timestamp": 1641483290
    },
    {
        "content": "<p>BTW, <a href=\"https://lang-team.rust-lang.org/initiatives/process/stages/proposal.html\">the docs</a> say that there should be regular updates posted to the github issue. I suppose that's my job, so I'll post an update later today (in ~10h).</p>",
        "id": 267074454,
        "sender_full_name": "Devin Jeanpierre",
        "timestamp": 1641483536
    },
    {
        "content": "<p>I would much prefer that, but I only speak for myself :-)</p>",
        "id": 267081154,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1641486507
    },
    {
        "content": "<p>me too :)   In addition to summarizing the discussion here, I'll also make a revision to the proposal tonight, based on the feedback, and summarize the changes (I guess in a second reply or in final section)</p>",
        "id": 267085684,
        "sender_full_name": "Devin Jeanpierre",
        "timestamp": 1641488590
    },
    {
        "content": "<p>this would also allow converting <code>ManuallyDrop</code> to a pure library type, no lang item needed:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[manually_drop]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">ManuallyDrop</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"c1\">// no Drop impl</span>\n</code></pre></div>",
        "id": 267086719,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641489035
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"229517\">@Jacob Lifshay</span> it still needs special language support because of its special-casing in <code>union</code> -- in theory perhaps any <code>#[manually_drop]</code> struct could be usable in a union, but I don't think that really makes sense.</p>",
        "id": 267087050,
        "sender_full_name": "Devin Jeanpierre",
        "timestamp": 1641489203
    },
    {
        "content": "<p>still a neat simplification though</p>",
        "id": 267087178,
        "sender_full_name": "Devin Jeanpierre",
        "timestamp": 1641489260
    },
    {
        "content": "<p>wait, I suppose any <code>#[manually_drop]</code> without a <code>Drop</code> impl would be usable in a <code>union</code>? That <em>does</em> make a lot of sense, and e.g. resolves my worry above about <code>ManuallyDrop</code> not being structurally pinned</p>",
        "id": 267087356,
        "sender_full_name": "Devin Jeanpierre",
        "timestamp": 1641489355
    },
    {
        "content": "<p>I <em>really</em> like this idea now :)</p>",
        "id": 267087423,
        "sender_full_name": "Devin Jeanpierre",
        "timestamp": 1641489374
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Attribute.20to.20reverse.20field.20destruction.20order.20.E2.80.A6.20lang-team.23135/near/267038129\">said</a>:</p>\n<blockquote>\n<p>I think this is an overly-specific feature. I'd rather see a more general version, something like a <code>manually_drop</code> attribute which means that all <br>\nfields are implicitly manually dropped and then it is the responsibility of the author to drop them in the destructor.</p>\n</blockquote>\n<p>I like this as well, although I'm quite tempted to feature some sugar with it: have a \"with owned fields\" drop impl:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">bikeshed_syntax</span><span class=\"o\">!</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">bar</span>: <span class=\"nc\">Bar</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">baz</span>: <span class=\"nc\">Baz</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"cp\">#[manual]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"nb\">Drop</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">fn</span> <span class=\"nf\">drop</span><span class=\"p\">(</span><span class=\"n\">bar</span>: <span class=\"nc\">Bar</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">baz</span>: <span class=\"nc\">Baz</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"nb\">drop</span><span class=\"p\">(</span><span class=\"n\">baz</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">forget</span><span class=\"p\">(</span><span class=\"n\">bar</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>With it, no <code>unsafe</code> needed!</p>\n<p>The only issue is pinning, and for that, I'll just rehearse, an <code>n+1</code>-th time, how convenient having <code>&amp;own</code> / <code>&amp;move</code> references would be:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">drop</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">bar</span>: <span class=\"nc\">Pin</span><span class=\"o\">&lt;&amp;</span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"n\">Bar</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">baz</span>: <span class=\"nc\">Pin</span><span class=\"o\">&lt;&amp;</span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"n\">Baz</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">)</span><span class=\"w\"></span>\n</code></pre></div>\n<p>(we'd just have the problem of <code>forget</code>ting one of those, but I think that that's an unavoidable problem when coupling structural <code>pin</code>ning with manual drops)</p>",
        "id": 267103116,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1641497355
    },
    {
        "content": "<p>I substantially updated the doc, and included a quick summary of the discussion so far.</p>",
        "id": 267129995,
        "sender_full_name": "Devin Jeanpierre",
        "timestamp": 1641512006
    },
    {
        "content": "<p>Could a regular old procedural macro applied to a type wrap each field in manually drop and implement Drop In the order required? That is, this doesn’t need to be a language thing at all?</p>\n<p>This ignores all the other discussion y’all have, just addressing the “this is a pain to write out”</p>",
        "id": 267301870,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1641656812
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116155\">Jake Goulding</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Attribute.20to.20reverse.20field.20destruction.20order.20.E2.80.A6.20lang-team.23135/near/267301870\">said</a>:</p>\n<blockquote>\n<p>Could a regular old procedural macro applied to a type wrap each field in manually drop and implement Drop In the order required? That is, this doesn’t need to be a language thing at all?</p>\n<p>This ignores all the other discussion y’all have, just addressing the “this is a pain to write out”</p>\n</blockquote>\n<p>The issue is that then you can't go and implement <code>Drop</code> yourself, so you'd have to go and wrap the type in one extra nesting level to add custom drop behaviour on top of reversing destruction order.<br>\nThis also has the other effects of <code>impl Drop</code>, such as baring destructuring.</p>",
        "id": 267303825,
        "sender_full_name": "Connor Horman",
        "timestamp": 1641659651
    },
    {
        "content": "<p>Does the original proposal allow destructuring?</p>",
        "id": 267313841,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1641673599
    },
    {
        "content": "<p>Having Drop and allowing destructuring would be way more interesting to me than anything</p>",
        "id": 267313859,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1641673645
    },
    {
        "content": "<p>I imagine <em>implicit</em> drop glue with a custom order could still allow destructuring</p>",
        "id": 267314977,
        "sender_full_name": "cuviper",
        "timestamp": 1641675321
    },
    {
        "content": "<p>although if you care that much about the order, you might also not want to allow things to \"escape\" that way</p>",
        "id": 267314991,
        "sender_full_name": "cuviper",
        "timestamp": 1641675341
    },
    {
        "content": "<p>A few semantic questions that arise in context of the <code>#[manually_drop]</code> variant of the proposal:</p>\n<ul>\n<li>When a field of <code>#[manually_drop]</code> struct is being assigned to, is the existing value of the field dropped or not?</li>\n<li>Should <code>#[manually_drop]</code> allow to partially moving out the fields? It if allows to move them out, are remaining fields dropped or not?</li>\n</ul>",
        "id": 267353012,
        "sender_full_name": "tm",
        "timestamp": 1641727270
    },
    {
        "content": "<p>For 2. any type with a Drop impl doesn't allow moving out of fields already. <code>#[manually_drop]</code> isn't very useful without a Drop impl.</p>",
        "id": 267353700,
        "sender_full_name": "bjorn3",
        "timestamp": 1641728353
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"352985\">tm</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Attribute.20to.20reverse.20field.20destruction.20order.20.E2.80.A6.20lang-team.23135/near/267353012\">said</a>:</p>\n<blockquote>\n<p>A few semantic questions that arise in context of the <code>#[manually_drop]</code> variant of the proposal:</p>\n<ul>\n<li>When a field of <code>#[manually_drop]</code> struct is being assigned to, is the existing value of the field dropped or not?</li>\n</ul>\n</blockquote>\n<p>I would say yes, assigning to a field should drop the old value, just like semantically happens in assignment operators in C++ (they are usually implemented as a destruction &amp; copy/move, or by calling the subfields' assignment operators). if you want to not drop the old value, use <code>ptr::write</code> or <code>forget(replace(&amp;mut s.field, ...))</code>.</p>",
        "id": 267368844,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641750271
    },
    {
        "content": "<p>I think the question is whether assigning to a <code>#[manually_drop]</code> field is <code>*field = foo;</code> or <code>field = ManuallyDrop::new(foo);</code>. IMO, it should be ill-formed to do <code>field = foo;</code> to save that question, and require the user be explicit.</p>",
        "id": 267369949,
        "sender_full_name": "Connor Horman",
        "timestamp": 1641751736
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116155\">Jake Goulding</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Attribute.20to.20reverse.20field.20destruction.20order.20.E2.80.A6.20lang-team.23135/near/267313841\">said</a>:</p>\n<blockquote>\n<p>Does the original proposal allow destructuring?</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"116155\">@Jake Goulding</span> in the original proposal, destructuring would have been allowed in either alternative. In the current draft, the main proposal allows you to override field drop order using a <code>Drop</code> impl, which does mean destructuring will no longer be allowed. That's unfortunate, but not unfortunate enough for me to want to complicate the proposal even further.</p>\n<p>(One could imagine e.g. an attribute that allows destructuring even for things that impl <code>Drop</code>. This would not be specific to this proposal. Alternatively, it might be a different trait entirely.)</p>",
        "id": 267501378,
        "sender_full_name": "Devin Jeanpierre",
        "timestamp": 1641849490
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Attribute.20to.20reverse.20field.20destruction.20order.20.E2.80.A6.20lang-team.23135/near/267369949\">said</a>:</p>\n<blockquote>\n<p>I think the question is whether assigning to a <code>#[manually_drop]</code> field is <code>*field = foo;</code> or <code>field = ManuallyDrop::new(foo);</code>. IMO, it should be ill-formed to do <code>field = foo;</code> to save that question, and require the user be explicit.</p>\n</blockquote>\n<p>I don't think this will work out so well. Given the following struct:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"nc\">X</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>\n<p>The two lines are equivalent:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">foo</span><span class=\"p\">.</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>\n<p>If we forbade assigning fields for some structs, we would also have to forbid assignment in general, because they're the same thing.</p>\n<p>Also, anyway, <code>ManuallyDrop</code> allows assignment and doesn't drop. This would be the same.</p>\n<p>Unfortunately, this raises a good point that a lot of the ergonomics issues of <code>ManuallyDrop</code> are still there: you need to manually drop before assigning the field....</p>",
        "id": 267502344,
        "sender_full_name": "Devin Jeanpierre",
        "timestamp": 1641849940
    },
    {
        "content": "<p>We could make it drop fields as <span class=\"user-mention\" data-user-id=\"229517\">@Jacob Lifshay</span> suggests, but then it isn't quite the same as <code>ManuallyDrop</code>, and <code>ManuallyDrop</code> can't just be a simple <code>#[manually_drop]</code> struct.</p>\n<p>In fact, my preference would be to do it this way, since otherwise, from an interop POV, there's not a lot of point to this. But we lose the simplification / relationship with <code>ManuallyDrop</code>.</p>",
        "id": 267502798,
        "sender_full_name": "Devin Jeanpierre",
        "timestamp": 1641850128
    },
    {
        "content": "<p>(This was a great question, thank you <span class=\"user-mention\" data-user-id=\"352985\">@tm</span> !)</p>",
        "id": 267502930,
        "sender_full_name": "Devin Jeanpierre",
        "timestamp": 1641850191
    },
    {
        "content": "<blockquote>\n<p>Should #[manually_drop] allow to partially moving out the fields? It if allows to move them out, are remaining fields dropped or not?</p>\n</blockquote>\n<p>I think it should not allow it: if we don't drop the omitted fields, it's a guaranteed leak. If we do, then it's not dropping manually, and the fields would be dropped in an incorrect order / double-dropped / etc.</p>\n<p>(If we do allow it, then it should implicitly drop fields so that it's actually useful for somebody. If the field drop order  is a problem, users can impl <code>Drop</code> to prevent destructuring.)</p>",
        "id": 267503377,
        "sender_full_name": "Devin Jeanpierre",
        "timestamp": 1641850345
    },
    {
        "content": "<p>(Hoping nobody saw my posts before I edited them -- I was originally a lot less bullish on biting the bullet and letting field assignment implicitly drop. Was worried it wouldn't be consistent with <code>ManuallyDrop</code>. Specifically: it is consistent with <code>ManuallyDrop</code> being a simple <code>#[manually_drop]</code> type, but it is <em>not</em> the same behavior as a <code>ManuallyDrop</code> field: <code>#[manually_drop] struct Foo(pub T)</code> behaves different from <code>struct Foo(ManuallyDrop&lt;T&gt;)</code>. On reflection... good! The ergonomics of <code>ManuallyDrop</code> were precisely the problem -- it's awful to require users to drop_in_place a field before assigning it, etc.)</p>",
        "id": 267504291,
        "sender_full_name": "Devin Jeanpierre",
        "timestamp": 1641850767
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116155\">Jake Goulding</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Attribute.20to.20reverse.20field.20destruction.20order.20.E2.80.A6.20lang-team.23135/near/267301870\">said</a>:</p>\n<blockquote>\n<p>Could a regular old procedural macro applied to a type wrap each field in manually drop and implement Drop In the order required? That is, this doesn’t need to be a language thing at all?</p>\n<p>This ignores all the other discussion y’all have, just addressing the “this is a pain to write out”</p>\n</blockquote>\n<p>I'm more concerned about users than the implementation. let's suppose the implementation  is automatically generated, by proc macro or whatever else.</p>\n<p>Then let's compare \"normal Rust struct\" to \"Rust struct that overrides field destruction order\":</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// before</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"C++\"><pre><span></span><code><span class=\"c1\">// C++ for comparison:</span>\n<span class=\"k\">auto</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{.</span><span class=\"n\">x</span><span class=\"o\">=</span><span class=\"n\">x</span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// after:</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"nc\">ManuallyDrop</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)};</span><span class=\"w\"></span>\n<span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"nb\">drop</span><span class=\"p\">();</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ManuallyDrop</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n<p>The position I take is: this API is something we would consider unacceptable for regular Rust code. But we are <em>forced</em> to have this API for FFI code. And I think we should find it unacceptable even when it's for FFI, and find some way to make FFI simple.</p>\n<p>(I will add these two specific operations to the proposal.)</p>",
        "id": 267505532,
        "sender_full_name": "Devin Jeanpierre",
        "timestamp": 1641851211
    },
    {
        "content": "<p>Minor update to <a href=\"https://github.com/rust-lang/lang-team/issues/135\">the proposal</a>: </p>\n<p>1) (addressing <span class=\"user-mention\" data-user-id=\"352985\">@tm</span>'s questions) specify that field assignment still drops the field (and partial destructuring should be forbidden)<br>\n2) (addressing <span class=\"user-mention\" data-user-id=\"116155\">@Jake Goulding</span>'s additional question) show why this is so important in the \"What's so bad about ManuallyDrop?\" section.</p>",
        "id": 267506939,
        "sender_full_name": "Devin Jeanpierre",
        "timestamp": 1641851945
    },
    {
        "content": "<blockquote>\n<p>But with ManuallyDrop, it becomes:</p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"n\">x</span>: <span class=\"nc\">ManuallyDrop</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)};</span><span class=\"w\"></span>\n<span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"n\">foo</span><span class=\"p\">.</span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"nb\">drop</span><span class=\"p\">();}</span><span class=\"w\"></span>\n<span class=\"n\">foo</span><span class=\"p\">.</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ManuallyDrop</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Couldn't that be <code>*foo.x = y;</code>?</p>",
        "id": 267533181,
        "sender_full_name": "scottmcm",
        "timestamp": 1641872297
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Attribute.20to.20reverse.20field.20destruction.20order.20.E2.80.A6.20lang-team.23135/near/267533181\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>But with ManuallyDrop, it becomes:</p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"n\">x</span>: <span class=\"nc\">ManuallyDrop</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)};</span><span class=\"w\"></span>\n<span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"n\">foo</span><span class=\"p\">.</span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"nb\">drop</span><span class=\"p\">();}</span><span class=\"w\"></span>\n<span class=\"n\">foo</span><span class=\"p\">.</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ManuallyDrop</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Couldn't that be <code>*foo.x = y;</code>?</p>\n</blockquote>\n<p>In place of the <code>drop</code>+assignment? Yes, that's identical (Thanks to ManuallyDrop being <code>DerefMut</code>)</p>",
        "id": 267535131,
        "sender_full_name": "Connor Horman",
        "timestamp": 1641874896
    },
    {
        "content": "<p>So I agree that the unsafe-drop+constructor is unacceptably bad, but the \"you just need a <code>*</code>\" might be fine.</p>",
        "id": 267535835,
        "sender_full_name": "scottmcm",
        "timestamp": 1641875919
    },
    {
        "content": "<p>Oof :)</p>\n<p>Yes, then the ergonomics issue with ManuallyDrop is just the derefs and the occasional ManuallyDrop::new.</p>",
        "id": 267579267,
        "sender_full_name": "Devin Jeanpierre",
        "timestamp": 1641907202
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"440241\">Devin Jeanpierre</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Attribute.20to.20reverse.20field.20destruction.20order.20.E2.80.A6.20lang-team.23135/near/267502344\">said</a>:</p>\n<blockquote>\n<p>Given the following struct:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"nc\">X</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>\n<p>The two lines are equivalent:</p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">foo</span><span class=\"p\">.</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I don't get exactly what you meant by that / AFAIS, there is a difference: <code>foo.x = x;</code> does not run <code>foo</code>'s drop glue, but runs <code>foo.x</code>'s. Whereas <code>foo = Foo { x };</code> is the inverse: it won't run <code>foo.x</code>'s drop glue, but runs <code>foo</code>'s.</p>\n<p>Given a lack of <code>impl Drop for Foo</code>, <em>or such an impl but with an empty body</em>, then <code>foo</code>'s drop glue happens to be the same as <code>x</code>'s.</p>\n<p>But in the case of a <code>#[manually_drop] struct Foo</code>, the <code>foo.x = x;</code> assignment could be considered ambiguous (although I personally lean towards simply dropping <code>x</code>).</p>\n<p>Related to that,  I still think that having:</p>\n<p><span class=\"user-mention silent\" data-user-id=\"232018\">Daniel Henry-Mantilla</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Attribute.20to.20reverse.20field.20destruction.20order.20.E2.80.A6.20lang-team.23135/near/267103116\">said</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">bikeshed_syntax</span><span class=\"o\">!</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">bar</span>: <span class=\"nc\">Bar</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">baz</span>: <span class=\"nc\">Baz</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"cp\">#[manual]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"nb\">Drop</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">fn</span> <span class=\"nf\">drop</span><span class=\"p\">(</span><span class=\"n\">bar</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">own</span><span class=\"w\"> </span><span class=\"n\">Bar</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">baz</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">own</span><span class=\"w\"> </span><span class=\"n\">Baz</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"nb\">drop</span><span class=\"p\">(</span><span class=\"n\">baz</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">forget</span><span class=\"p\">(</span><span class=\"n\">bar</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>would be the clearest way forward:</p>\n<ul>\n<li>No destructuring because of the <code>Drop</code> impl;</li>\n<li><code>foo.x = …</code> assignments would drop the field as usual, whereas <code>foo = Foo { x };</code> would use the \"manual drop\", much like it does today anyways (potentially not dropping <code>x</code> if the impl so does; if such a difference were to matter, then it suffices not to make <code>x</code> a public field).</li>\n</ul>\n<p>In other words, the only difference lies <em>in the capabilities of the \"manual drop\" body</em> (everything else would be the same as a non-\"manual drop\" struct): with my proposal, such body would have owned (by value, or <code>&amp;own</code>ing ref) access to the fields, thus being able to non-<code>unsafely</code> <code>forget</code> or <code>drop</code> each.</p>\n<hr>\n<p>Back to the topic at hand, I think it makes sense to currently settle for the less ambitious <code>#[reverse_field_order_drop]</code> attribute, but still want to insist about the elegance of opting into <code>&amp;own</code>ed fields given to the <code>Drop</code> impl body <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 267609710,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1641919571
    },
    {
        "content": "<p>For the attribute: I think it'd actually be nice to have an attribute where its presence is a hint that you <em>care</em> about the order, even if the one you want is the default.</p>\n<p>So that would mean to me that this would be a <code>#[drop_order(forward)]</code> vs <code>#[drop_order(backward)]</code>.  (And I can't imagine anything else that would make sense, but I guess it would also offer more.  I guess <code>#[manually_drop]</code> is in some ways <code>#[drop_order(do_not_drop_fields)]</code>?)</p>",
        "id": 267622980,
        "sender_full_name": "scottmcm",
        "timestamp": 1641924881
    },
    {
        "content": "<p>zulip ate my draft reply and im very upset with it rn <br>\n<span class=\"user-mention silent\" data-user-id=\"232018\">Daniel Henry-Mantilla</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Attribute.20to.20reverse.20field.20destruction.20order.20.E2.80.A6.20lang-team.23135/near/267609710\">said</a>:</p>\n<blockquote>\n<p>I don't get exactly what you meant by that / AFAIS, there is a difference: <code>foo.x = x;</code> does not run <code>foo</code>'s drop glue, but runs <code>foo.x</code>'s. Whereas <code>foo = Foo { x };</code> is the inverse: it won't run <code>foo.x</code>'s drop glue, but runs <code>foo</code>'s.</p>\n</blockquote>\n<p>The example was a poor one from an earlier draft, sorry.</p>\n<p>The point ought to be that there's only one correct decision anyway: if <code>foo.x = y</code> does not drop <code>foo.x</code>, then the proposal is worthless, as it would be even less ergonomic than <code>ManuallyDrop</code>.</p>\n<blockquote>\n<p>[<code>fn drop(bar: &amp;own Bar, baz: &amp;own Baz)</code>] would be the clearest way forward:</p>\n</blockquote>\n<p>This relies on at least one feature that doesn't already exist (<code>&amp;own</code>), maybe two (a trait with type-dependent argument counts and types, unless this is syntactic sugar from a proc macro). If we removed those two features, it would become essentially identical to <code>#[manually_drop]</code>, and the only ergonomic improvements are that the implementation doesn't need <code>unsafe</code> blocks and will warn if you neglect to <code>drop</code> (or explicitly <code>forget</code>) a field.</p>\n<p>I would honestly expect the implementation to be automatically generated, either by a proc macro or a bindings generator, so these aren't critical to me. It's probably really easy to automatically migrate from one proposal to the other btw.</p>\n<p>The disadvantage of this proposal is that there is no <code>&amp;mut self</code>: you cannot define this alongside a traditional <code>Drop</code> impl. So I would argue it should not be <code>Drop::drop</code>, but a new trait or a new method on the <code>Drop</code> trait. </p>\n<blockquote>\n<p>Back to the topic at hand, I think it makes sense to currently settle for the less ambitious <code>#[reverse_field_order_drop]</code> attribute, but still want to insist about the elegance of opting into <code>&amp;own</code>ed fields given to the <code>Drop</code> impl body <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>\n</blockquote>\n<p>I'm absolutely 100% on board with this, assuming \"less ambitious, can be replaced later with a more complete solution\" is an acceptable outcome.</p>\n<p>FWIW there's only one subtle catch: the type must behave as if it had a <code>Drop</code> impl (dropck, no destructuring, etc.). This makes automatic migration straightforward, since all the alternatives seem to involve defining a <code>Drop</code> trait: you'd just add the manual drops to (an existing or new) <code>Drop</code> impl.</p>\n<p>(Except for the <code>fn drop(&amp;own field)</code> proposal -- if that's what we went with, then the <code>#[reverse_field_order_drop]</code> + a <code>Drop</code> impl would be impossible to migrate. So if that's on the table, we would need <code>#[reverse_field_order_drop]</code> to prohibit a user-defined <code>Drop</code> / implicitly define an empty <code>Drop</code> impl.)</p>",
        "id": 267651220,
        "sender_full_name": "Devin Jeanpierre",
        "timestamp": 1641938092
    },
    {
        "content": "<p>Potentially off-topic comment: I'd love to eventually have a way to destructure in <code>Drop</code> and thus take full control over how the individual fields are consumed.  <code>let Foo { a, b, c } = self; drop(a); drop(c); drop(b);</code> would be cool, if impractical right now.</p>",
        "id": 267652073,
        "sender_full_name": "scottmcm",
        "timestamp": 1641938502
    },
    {
        "content": "<p>This also makes me think of some mental experiments I've been pondering around &lt;<a href=\"https://github.com/rust-lang/rust/issues/79914\">https://github.com/rust-lang/rust/issues/79914</a>&gt; and how it would be nice to be able to \"forget in place\" a <code>T</code> parameter into a <code>&amp;mut ManuallyDrop&lt;T&gt;</code> or similar.</p>",
        "id": 267652281,
        "sender_full_name": "scottmcm",
        "timestamp": 1641938614
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Attribute.20to.20reverse.20field.20destruction.20order.20.E2.80.A6.20lang-team.23135/near/267652073\">said</a>:</p>\n<blockquote>\n<p>Potentially off-topic comment: I'd love to eventually have a way to destructure in <code>Drop</code> and thus take full control over how the individual fields are consumed.  <code>let Foo { a, b, c } = self; drop(a); drop(c); drop(b);</code> would be cool, if impractical right now.</p>\n</blockquote>\n<p>Something like that was in the first draft of the proposal -- a <code>Drop</code>-like trait which took <code>self</code> by value. Unfortunately, doesn't work for all of C++ interop, or anything else where you have a pinned <code>self</code> you want to clean up at destruction-time: you need <code>&amp;own</code> or similar for that, or else you need to just deal with <code>&amp;mut</code> and suppress field destruction (how the proposal currently works).</p>",
        "id": 267652634,
        "sender_full_name": "Devin Jeanpierre",
        "timestamp": 1641938763
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"440241\">@Devin Jeanpierre</span> Did you already check the \"drafts\" link near the edit field, to see if it was there? Zulip eats messages for me sometimes as well, but they're generally left in \"drafts\".</p>",
        "id": 267653472,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1641939112
    },
    {
        "content": "<p>I noticed that after the fact when I accidentally drafted my second reply &gt;_&lt;. (It highlighted the <code>drafts</code> tab when I did it)</p>",
        "id": 267654680,
        "sender_full_name": "Devin Jeanpierre",
        "timestamp": 1641939617
    },
    {
        "content": "<p>From github comments: <a href=\"https://github.com/rust-lang/rfcs/issues/744\">https://github.com/rust-lang/rfcs/issues/744</a> was a pre-1.0 RFC to have locals-like reversed drop order.</p>\n<p><a href=\"https://github.com/rust-lang/rfcs/blob/master/text/1857-stabilize-drop-order.md\">https://github.com/rust-lang/rfcs/blob/master/text/1857-stabilize-drop-order.md</a> is the RFC that rejected this change.</p>",
        "id": 267655317,
        "sender_full_name": "Devin Jeanpierre",
        "timestamp": 1641939926
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Attribute.20to.20reverse.20field.20destruction.20order.20.E2.80.A6.20lang-team.23135/near/267622980\">said</a>:</p>\n<blockquote>\n<p>And I can't imagine anything else that would make sense</p>\n</blockquote>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[drop_order(explicit)]</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"cp\">#[drop_order(1)]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">a</span>: <span class=\"nb\">String</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"cp\">#[drop_order(0)]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">b</span>: <span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"cp\">#[drop_order(2)]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">c</span>: <span class=\"nc\">TemporaryFile</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 267657440,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1641941130
    },
    {
        "content": "<p>Oh, interesting, Jake.  Definitely not P0, but seems plausible.</p>",
        "id": 267657624,
        "sender_full_name": "scottmcm",
        "timestamp": 1641941242
    },
    {
        "content": "<p>Especially with the temporary file / directory. That's my personal use for caring about drop order. I create a temporary directory, write some stuff in there, spin up a server in there, then want to make sure that the server exits/is killed before the directory is deleted.</p>",
        "id": 267660535,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1641942801
    },
    {
        "content": "<p>On a mostly aesthetic basis, this seems like too many attributes. IMO, we should attributes for opting in or out of the common case (obviously there are other uses and exceptions, but for this sort of thing) and once on opts out of the common case flow, they should use code. For a more practical reason, I could imagine that folk might want to drop the internals of fields in a specific order relative to other fields, or the drop order might change dynamically, or a struct might always leak a field, in which cases you need an escape hatch from this anyway</p>",
        "id": 267704569,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1641982306
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Attribute.20to.20reverse.20field.20destruction.20order.20.E2.80.A6.20lang-team.23135/near/267622980\">said</a>:</p>\n<blockquote>\n<p>So that would mean to me that this would be a <code>#[drop_order(forward)]</code> vs <code>#[drop_order(backward)]</code>. </p>\n</blockquote>\n<p>Oh yes, <code>#[drop_order(forward)]</code>, when relied on, seems great! I've found code bases that relied on that [implicitly], and I've always found it super brittle (when no <code>#[repr(C)]</code> or other ordering-sensitive things).</p>\n<p>This thus reminds me of the use case for such things:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[drop_order(forward)]</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">SelfRef</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">reference</span>: <span class=\"nc\">PrintOnDrop</span><span class=\"o\">&lt;&amp;'</span><span class=\"nb\">static</span><span class=\"w\"> </span><span class=\"kt\">str</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"c1\">// in practice it points to `referee`.</span>\n<span class=\"w\">    </span><span class=\"n\">referee</span>: <span class=\"nb\">String</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>I remember that with such a snippet, another option was to define <em>some</em> relative-ordering between field drops:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">SelfRef</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">referee</span>: <span class=\"nb\">String</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"cp\">#[dropped_before(.referee)]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">reference</span>: <span class=\"nc\">PrintOnDrop</span><span class=\"o\">&lt;&amp;'</span><span class=\"nb\">static</span><span class=\"w\"> </span><span class=\"kt\">str</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>The latter, with generated code such as C++ bindings ones, could also cover the reverse order:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[repr(C)]</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">a</span>: <span class=\"nc\">A</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"cp\">#[dropped_before(.a)]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">b</span>: <span class=\"nc\">B</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"cp\">#[dropped_before(.b)]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">c</span>: <span class=\"nc\">C</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>EDIT: Zulip output made me just see <span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span>'s comment, so I had missed the others; this new proposal of mine resembles <span class=\"user-mention\" data-user-id=\"116155\">@Jake Goulding</span>'s a lot, although I think mine is a bit more lightweight? (one <code>#[dropped_before(.temp_dir)] server_instance: …</code> attribute).</p>",
        "id": 267729795,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1641996957
    },
    {
        "content": "<p>I'd note something I probably should have prior, but if the type has a non-trivial C++ destructor, you do need slightly more than just fixing drop order, as most C++ abis will treat the type differently.</p>",
        "id": 267730342,
        "sender_full_name": "Connor Horman",
        "timestamp": 1641997219
    },
    {
        "content": "<p>Because the destructor becomes <code>virtual</code>?</p>",
        "id": 267730402,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1641997247
    },
    {
        "content": "<p>No (unless you explicitly make it <code>virtual</code>), but the ABI will treat it as non-trivial for the purposes of calls, which causes it to be passed as a pointer/returned in a pointer even if the size would make it otherwise passed/returned in a register.</p>",
        "id": 267730571,
        "sender_full_name": "Connor Horman",
        "timestamp": 1641997320
    },
    {
        "content": "<p>I think that may be useful to point out, though I don't think this is the proposal to make the necessary changes to solve that issue.</p>",
        "id": 267730865,
        "sender_full_name": "Connor Horman",
        "timestamp": 1641997428
    },
    {
        "content": "<p>In Rust parlance, some C++ structs (the \"trivial ones\") could end up featuring a <code>#[repr(transparent)]</code>-ish ABI, but with a destructor they get a <code>#[repr(C)]</code> ABI?<br>\nIt does seem a very interesting point if C++ classes don't necessarily get a <code>#[repr(C)]</code> ABI <span aria-label=\"warning\" class=\"emoji emoji-26a0\" role=\"img\" title=\"warning\">:warning:</span></p>",
        "id": 267730988,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1641997466
    },
    {
        "content": "<blockquote>\n<p>Oh yes, <code>#[drop_order(forward)]</code>, when relied on, seems great! I've found code bases that relied on that, and I've always found it super brittle (when no <code>#[repr(C)]</code> or other ordering-sensitive things).</p>\n</blockquote>\n<p>Can you expand on why it’s brittle? The drop order of structs is defined to be in order. Drop order forward would effectively be a no-op, serving as explicit documentation.</p>",
        "id": 267730992,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1641997469
    },
    {
        "content": "<p>To clarify: \"that relied on that [<em>implicitly</em>]\", hence why I like it being explicit</p>",
        "id": 267731097,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1641997513
    },
    {
        "content": "<p>Every time I’ve relied on the struct’s Drop order, I’ve added a comment. To me that accomplished the same goal.</p>",
        "id": 267731291,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1641997592
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232018\">Daniel Henry-Mantilla</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Attribute.20to.20reverse.20field.20destruction.20order.20.E2.80.A6.20lang-team.23135/near/267730988\">said</a>:</p>\n<blockquote>\n<p>In Rust parlance, some C++ structs (the \"trivial ones\") could end up featuring a <code>#[repr(transparent)]</code>-ish ABI, but with a destructor they get a <code>#[repr(C)]</code> ABI?<br>\nIt does seem a very interesting point if C++ classes don't necessarily get a <code>#[repr(C)]</code> ABI <span aria-label=\"warning\" class=\"emoji emoji-26a0\" role=\"img\" title=\"warning\">:warning:</span></p>\n</blockquote>\n<p>It's different from <code>#[repr(C)]</code>. From Sys-V x86_64, in parameter/return value classification:</p>\n<blockquote>\n<p>If a C++ object has either a non-trivial copy constructor or a non-trivial<br>\ndestructor 11, it is passed by invisible reference (the object is replaced in the<br>\nparameter list by a pointer that has class INTEGER).</p>\n</blockquote>\n<p>And from the Itanium C++ ABI:</p>\n<blockquote>\n<p><em>non-trivial for the purposes of calls</em><br>\nThis definition, as applied to class types, is intended to be the complement of the definition in [class.temporary]p3 of types for which an extra temporary is allowed when passing or returning a type. A type which is trivial for the purposes of the ABI will be passed and returned according to the rules of the base C ABI, e.g. in registers; often this has the effect of performing a trivial copy of the type.</p>\n</blockquote>",
        "id": 267731519,
        "sender_full_name": "Connor Horman",
        "timestamp": 1641997687
    },
    {
        "content": "<p>I see the attribute as a (glorified but also) standardized comment <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 267731526,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1641997689
    },
    {
        "content": "<blockquote>\n<p>IMO, we should attributes for opting in or out of the common case (obviously there are other uses and exceptions, but for this sort of thing) and once on opts out of the common case flow, they should use code.</p>\n</blockquote>\n<p>I agree. My problem is that implementing Drop also means that I no longer can destructure. That’s the angle I’d love to see addressed.</p>",
        "id": 267731564,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1641997704
    },
    {
        "content": "<p>In rust parlance, the default is <code>#[repr(C)]</code> (modulo layout rules, but most abis use <code>#[repr(C)]</code> for classes with just fields anyways, even if it's not <em>standard-layout</em>), but if you have a non-trivial destructor (or non-trivial copy/move constructor) it becomes something like <code>#[repr(nontrivial)]</code> that is always passed in memory.</p>",
        "id": 267731751,
        "sender_full_name": "Connor Horman",
        "timestamp": 1641997796
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Attribute.20to.20reverse.20field.20destruction.20order.20.E2.80.A6.20lang-team.23135/near/267730342\">said</a>:</p>\n<blockquote>\n<p>I'd note something I probably should have prior, but if the type has a non-trivial C++ destructor, you do need slightly more than just fixing drop order, as most C++ abis will treat the type differently.</p>\n</blockquote>\n<p>Yep. I've been working on a couple of solutions to this:</p>\n<p>1) Different ABIs in wrapped functions, and with <code>Pin</code> everywhere. (We need <code>Pin</code> anyway for any non-<code>final</code> type, actually), using something like moveit.</p>\n<p>2) Make as many types trivially relocatable as possible. See e.g. <a href=\"https://reviews.llvm.org/D114732\">https://reviews.llvm.org/D114732</a>, which I'm going to ping after holiday break. (Reception is good from what I can tell.) This would add a decent performance advantage to trivial-abi types, encouraging more people to use the language extension to mark them as trivial-abi, and compatible with Rust semantics totally.</p>",
        "id": 267782469,
        "sender_full_name": "Devin Jeanpierre",
        "timestamp": 1642019794
    },
    {
        "content": "<p>Regardless of what we do, the destructor ordering issue persists</p>",
        "id": 267782548,
        "sender_full_name": "Devin Jeanpierre",
        "timestamp": 1642019830
    },
    {
        "content": "<p>I really want C++/Rust interop to be smooth, and that means changing both C++ and Rust. That LLVM proposal above will hopefully eventually feed into the standards proposal (which already exists), and we might see something like it in say C++26 -- and earlier, for Clang. Similarly, I hope for some part of my proposal in this thread to make it into rust, and eventually into stable.</p>\n<p>The way things are right now, there are unresolvable impedance mismatches that produce inefficient, unsound, or difficult to use bindings -- my goal here is to make the bindings as efficient and sound as the underlying C++, and no more difficult to use. That's going to require changes to both rust and C++, but I really think it's doable!</p>",
        "id": 267783525,
        "sender_full_name": "Devin Jeanpierre",
        "timestamp": 1642020296
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116155\">Jake Goulding</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Attribute.20to.20reverse.20field.20destruction.20order.20.E2.80.A6.20lang-team.23135/near/267731564\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>IMO, we should attributes for opting in or out of the common case (obviously there are other uses and exceptions, but for this sort of thing) and once on opts out of the common case flow, they should use code.</p>\n</blockquote>\n<p>I agree. My problem is that implementing Drop also means that I no longer can destructure. That’s the angle I’d love to see addressed.</p>\n</blockquote>\n<p>In this proposal, or a different proposal?</p>",
        "id": 267784118,
        "sender_full_name": "Devin Jeanpierre",
        "timestamp": 1642020590
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232018\">Daniel Henry-Mantilla</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Attribute.20to.20reverse.20field.20destruction.20order.20.E2.80.A6.20lang-team.23135/near/267730988\">said</a>:</p>\n<blockquote>\n<p>In Rust parlance, some C++ structs (the \"trivial ones\") could end up featuring a <code>#[repr(transparent)]</code>-ish ABI, but with a destructor they get a <code>#[repr(C)]</code> ABI?<br>\nIt does seem a very interesting point if C++ classes don't necessarily get a <code>#[repr(C)]</code> ABI <span aria-label=\"warning\" class=\"emoji emoji-26a0\" role=\"img\" title=\"warning\">:warning:</span></p>\n</blockquote>\n<p>C++ classes don't always get the same layout as a similar-looking C struct, but an interop tool will understand the ABI-specific layout. It will always be equivalent to <em>a</em> repr(C) struct, and any Sufficiently Advanced C++ interop tool can determine what struct that would be.</p>\n<p>(The biggest failure point I'm aware of, btw, is potentially-overlapping subobjects (i.e. base classes and <code>[[no_unique_address]]</code> member variables). Those map very nontrivially to repr(C) structs, because the padding can be reused. So potentially-overlapping subobjects need to get unpacked into their constituent fields, etc.)</p>",
        "id": 267784422,
        "sender_full_name": "Devin Jeanpierre",
        "timestamp": 1642020739
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Attribute.20to.20reverse.20field.20destruction.20order.20.E2.80.A6.20lang-team.23135/near/267622980\">said</a>:</p>\n<blockquote>\n<p>For the attribute: I think it'd actually be nice to have an attribute where its presence is a hint that you <em>care</em> about the order, even if the one you want is the default.</p>\n<p>So that would mean to me that this would be a <code>#[drop_order(forward)]</code> vs <code>#[drop_order(backward)]</code>.  (And I can't imagine anything else that would make sense, but I guess it would also offer more.  I guess <code>#[manually_drop]</code> is in some ways <code>#[drop_order(do_not_drop_fields)]</code>?)</p>\n</blockquote>\n<p>I think there's also a \"don't care\" possibility where you don't even need the normal forward semantics, instead giving the compiler free reign. For example, it might look nicer for the optimizer if things were dropped in the true memory order, after the layout is decided.</p>",
        "id": 267802120,
        "sender_full_name": "cuviper",
        "timestamp": 1642029919
    },
    {
        "content": "<p>(<em>Rewrites <code>#[drop_order(dont_care)]</code> to <code>#[drop_order(backward)]</code> internally</em>)</p>",
        "id": 267802480,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642030108
    },
    {
        "content": "<p>heh, or fuzz it as <code>#[drop_order(random)]</code></p>",
        "id": 267802555,
        "sender_full_name": "cuviper",
        "timestamp": 1642030154
    },
    {
        "content": "<p>(Side note, I kinda hate that it drops in forward field order by default, because it makes my job harder)</p>",
        "id": 267802679,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642030222
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Attribute.20to.20reverse.20field.20destruction.20order.20.E2.80.A6.20lang-team.23135/near/267622980\">said</a>:</p>\n<blockquote>\n<p>For the attribute: I think it'd actually be nice to have an attribute where its presence is a hint that you <em>care</em> about the order, even if the one you want is the default.</p>\n<p>So that would mean to me that this would be a <code>#[drop_order(forward)]</code> vs <code>#[drop_order(backward)]</code>.  (And I can't imagine anything else that would make sense, but I guess it would also offer more.  I guess <code>#[manually_drop]</code> is in some ways <code>#[drop_order(do_not_drop_fields)]</code>?)</p>\n</blockquote>\n<p><code>#[drop_order(just_dont_alright)]</code></p>",
        "id": 267803766,
        "sender_full_name": "inquisitivecrystal",
        "timestamp": 1642030888
    },
    {
        "content": "<p>Is the hypothetical <code>#[drop_order(dont_care)]</code> compelling enough that it makes sense to rewrite the second alternative <code>#[drop_from_end]</code> to a <code>#[drop_order(backward)]</code>, even if today there's no other drop order than <code>backward</code> and <code>forward</code>? I think so, but want to double check before I edit the proposal.</p>\n<p>P.S. is <code>backward</code> really clear enough, or should it be <code>from_end</code> and <code>from_start</code>?</p>\n<p>P.P.S. great discussion, thank you!</p>",
        "id": 267805343,
        "sender_full_name": "Devin Jeanpierre",
        "timestamp": 1642031850
    },
    {
        "content": "<p>from_start / from_end is much better than forward/backward</p>",
        "id": 267978383,
        "sender_full_name": "Lokathor",
        "timestamp": 1642143864
    },
    {
        "content": "<p>I've updated the proposal to use <code>drop_order(from_end)</code> instead of <code>drop_from_end</code>, and to contain abbreviated notes of the discussions here.</p>",
        "id": 268447210,
        "sender_full_name": "Devin Jeanpierre",
        "timestamp": 1642535989
    },
    {
        "content": "<p>Offline discussion: I talked with <span class=\"user-mention\" data-user-id=\"218683\">@Alice Ryhl</span> a bit about structural pinning and ManuallyDrop. Conclusion: ManuallyDrop <em>can't</em> be (safely) structurally pinned, because of the drop guarantee. But conversely, it doesn't have to matter if it's structurally pinned, because if you don't expose it, then you can do what you like -- for example, you can unsafely pin-project it if it's a private struct variable, because this can't conflict with anyone who assumes you don't do that: nobody else accesses it, it's private. So e.g. for unions, instead of exposing a raw union in C++ interop, you can (and in fact, should) expose a wrapper newtype with accessor methods.</p>\n<p>So I'm going to delete discussion of this in the proposal: it's not an unresolvable problem after all, since the only safety issues happen if you make it public, which you don't have to do.</p>",
        "id": 268736708,
        "sender_full_name": "Devin Jeanpierre",
        "timestamp": 1642703412
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Attribute.20to.20reverse.20field.20destruction.20order.20.E2.80.A6.20lang-team.23135/near/267978383\">said</a>:</p>\n<blockquote>\n<p>from_start / from_end is much better than forward/backward</p>\n</blockquote>\n<p>other bikeshed colors: from_first / from_last</p>",
        "id": 274255385,
        "sender_full_name": "RalfJ",
        "timestamp": 1646501566
    }
]