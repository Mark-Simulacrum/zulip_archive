[
    {
        "content": "<p>A new proposal has been announced: <a href=\"https://github.com/rust-lang/lang-team/issues/143\">allow construction of non-exhaustive structs when using functional update syntax #143</a>. It will be announced at the next meeting to try and draw attention to it, but usually MCPs are not discussed during triage meetings. If you think this would benefit from discussion amongst the team, consider proposing a design meeting.</p>",
        "id": 270606821,
        "sender_full_name": "triagebot",
        "timestamp": 1643917637
    },
    {
        "content": "<p><span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span> for allowing this, as long as all the fields are public. There's an ongoing discussion about whether this kind of thing should be allowed with fields that <em>aren't</em> public, and I personally think it should not be.</p>",
        "id": 270607329,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643917834
    },
    {
        "content": "<p>Also, this would naturally fit into the proposals to allow <code>..</code> instead of <code>..Default::default()</code>.</p>",
        "id": 270607373,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643917850
    },
    {
        "content": "<p>This breaks if you add a private field, which is one of the things that is currently allowed with <code>non_exhaustive</code>, so I don't think this is an obvious yes.</p>",
        "id": 270607511,
        "sender_full_name": "scottmcm",
        "timestamp": 1643917914
    },
    {
        "content": "<p>Maybe it'd make sense to have some kind of \"constrained non exhaustive\"?  Like FRU would work with <code>#[non_exhaustive(pub)]</code> or something.</p>",
        "id": 270607644,
        "sender_full_name": "scottmcm",
        "timestamp": 1643917955
    },
    {
        "content": "<p>Good point.</p>",
        "id": 270607826,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643918030
    },
    {
        "content": "<p>Basically, it'd be a shame if accepting this meant that everyone has to go back to adding private unit fields to their structs to allow more private fields in future, since that's what <code>non_exhaustive</code> meant people could stop doing.</p>",
        "id": 270607934,
        "sender_full_name": "scottmcm",
        "timestamp": 1643918063
    },
    {
        "content": "<p>Yeah, I withdraw my initial <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span>, this needs more thought.</p>",
        "id": 270607968,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643918083
    },
    {
        "content": "<p>The \"construct with <code>..</code>\" thread mentioned a bunch of other kinds of constrained non-exhaustive too.  Like maybe <code>#[non_exhaustive(defaults)]</code> would be the \"I promise to only add new fields with defaults\" marker, so you can construct such a thing with <code>..</code>.</p>",
        "id": 270608197,
        "sender_full_name": "scottmcm",
        "timestamp": 1643918164
    },
    {
        "content": "<p>non_exhaustive + a Default impl already basically promises to only add fields with a \"sort of default\" later, right?</p>",
        "id": 270608273,
        "sender_full_name": "simulacrum",
        "timestamp": 1643918194
    },
    {
        "content": "<p>/me really wants Esteban's default fields RFC from &lt;<a href=\"https://internals.rust-lang.org/t/pre-pre-rfc-syntactic-sugar-for-default-default/13234/75?u=scottmcm\">https://internals.rust-lang.org/t/pre-pre-rfc-syntactic-sugar-for-default-default/13234/75?u=scottmcm</a>&gt;</p>",
        "id": 270608424,
        "sender_full_name": "scottmcm",
        "timestamp": 1643918266
    },
    {
        "content": "<p>Yeah, I want that RFC too.</p>",
        "id": 270608509,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643918283
    },
    {
        "content": "<blockquote>\n<p>This would allow construction outside the defining<br>\ncrate and require no code changes when common modifications are made such as<br>\nadding a new field with a default value.</p>\n</blockquote>\n<p>FWIW, it seems like this particular motivation is supported relatively OK by 'just' not using the struct declaration syntax, instead updating the fields after calling Default::default() -- is there a big downside to that I'm not spotting immediately?</p>",
        "id": 270608518,
        "sender_full_name": "simulacrum",
        "timestamp": 1643918287
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/allow.20construction.20of.20non-exhaustive.20structs.20.E2.80.A6.20lang-team.23143/near/270608273\">said</a>:</p>\n<blockquote>\n<p>non_exhaustive + a Default impl already basically promises to only add fields with a \"sort of default\" later, right?</p>\n</blockquote>\n<p>If you actually impl <code>Default</code>, yes; if you have individual field defaults, no.</p>",
        "id": 270608576,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643918309
    },
    {
        "content": "<p>One aspect of the above-linked proposal from internals is to allow having defaults for some but not all fields, and then allow construction with <code>..</code> as long as all the fields <em>without</em> defaults have initializers.</p>",
        "id": 270608635,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643918342
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/allow.20construction.20of.20non-exhaustive.20structs.20.E2.80.A6.20lang-team.23143/near/270608518\">said</a>:</p>\n<blockquote>\n<p>FWIW, it seems like this particular motivation is supported relatively OK by 'just' not using the struct declaration syntax, instead updating the fields after calling Default::default() -- is there a big downside to that I'm not spotting immediately?</p>\n</blockquote>\n<p>It actually works quite well.  Here's a macro for it that makes it really convenient, too: &lt;<a href=\"https://internals.rust-lang.org/t/short-enum-variant-syntax-in-some-cases/13113/9?u=scottmcm\">https://internals.rust-lang.org/t/short-enum-variant-syntax-in-some-cases/13113/9?u=scottmcm</a>&gt;</p>",
        "id": 270608658,
        "sender_full_name": "scottmcm",
        "timestamp": 1643918351
    },
    {
        "content": "<p>Which then raises the question of how that interacts with <code>non_exhaustive</code>.</p>",
        "id": 270608660,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643918352
    },
    {
        "content": "<p>Sure, that's no longer syntactic sugar then.</p>",
        "id": 270608669,
        "sender_full_name": "simulacrum",
        "timestamp": 1643918356
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> I mean, it's syntactic sugar, it's just syntactic sugar for something different.</p>",
        "id": 270608712,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643918375
    },
    {
        "content": "<p>TBH, I think <code>#[non_exhaustive]</code> for structs as it is is useless as-is, just because you can't construct it at all from a foreign crate. I don't think I've ever meant \"I might add private fields to this struct\" when I've wanted <code>#[non_exhaustive]</code>. Having this proposal would make that easier.</p>",
        "id": 270608738,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643918387
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> You can construct it if you have a constructor. You just can't construct it from fields.</p>",
        "id": 270608921,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643918429
    },
    {
        "content": "<p>Which makes it feel more like an \"object\" and less like \"plain old data\".</p>",
        "id": 270608944,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643918439
    },
    {
        "content": "<p>And that seems fine.</p>",
        "id": 270608949,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643918442
    },
    {
        "content": "<p>Yeah, that's what I meant.</p>",
        "id": 270608954,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643918445
    },
    {
        "content": "<p>And once you <em>have</em> one, you can modify it. You just can't build one from scratch without a constructor.</p>",
        "id": 270608989,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643918463
    },
    {
        "content": "<p>It seems like <code>non_exhaustive</code> is ambiguous, because it doesn't nail down what potential added fields might satisfy.</p>",
        "id": 270609077,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643918506
    },
    {
        "content": "<p>I <em>do</em> really want a way to make things like options structs without needing to go to all the effort of a builder API, but I think something with <code>..</code> as in esteban's pre-RFC is the way forward there.</p>\n<p>Unfortunately what FRU does is not what most people expect it to do.</p>",
        "id": 270609182,
        "sender_full_name": "scottmcm",
        "timestamp": 1643918545
    },
    {
        "content": "<p>Right now, that ambiguity isn't an issue. Adding <code>..</code> and field defaults makes it an issue, because then it matters whether 1) newly added fields have a default, and 2) newly added fields are public or private.</p>",
        "id": 270609186,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643918547
    },
    {
        "content": "<p>I've had types like <a href=\"https://docs.rs/install-dirs/latest/install_dirs/dirs/struct.InstallDirs.html\">https://docs.rs/install-dirs/latest/install_dirs/dirs/struct.InstallDirs.html</a>, where it would be nice sugar to have <code>let dirs = InstallDirs{ /*override some directories*/, ..InstallDirs::defaults()};</code>.</p>",
        "id": 270609234,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643918564
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> I think <em>that</em> could be fine with private fields, as long as <code>defaults()</code> initializes all of them, because then you can only change the public fields with that syntax.</p>",
        "id": 270609336,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643918620
    },
    {
        "content": "<p>It's the <code>{ field: initexpr, .. }</code> syntax for constructing \"from scratch\" that needs to worry about private fields.</p>",
        "id": 270609395,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643918642
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/allow.20construction.20of.20non-exhaustive.20structs.20.E2.80.A6.20lang-team.23143/near/270609234\">said</a>:</p>\n<blockquote>\n<p>types like <a href=\"https://docs.rs/install-dirs/latest/install_dirs/dirs/struct.InstallDirs.html\">https://docs.rs/install-dirs/latest/install_dirs/dirs/struct.InstallDirs.html</a></p>\n</blockquote>\n<p>If that were to implement <code>Default</code> (weird that it has a <code>defaults</code> constructor but not the trait) then that could be just</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">dirs</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">!</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">libdir</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.,</span><span class=\"w\"></span>\n<span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>\n<p>with no new language features.</p>",
        "id": 270609512,
        "sender_full_name": "scottmcm",
        "timestamp": 1643918697
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/allow.20construction.20of.20non-exhaustive.20structs.20.E2.80.A6.20lang-team.23143/near/270609336\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> I think <em>that</em> could be fine with private fields, as long as <code>defaults()</code> initializes all of them, because then you can only change the public fields with that syntax.</p>\n</blockquote>\n<p>Perhaps, though currently that is <em>not</em> the case.</p>",
        "id": 270609551,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643918712
    },
    {
        "content": "<p>I think this is coming back to the whole \"maybe we should just change FRU to work how people expect\", thing.</p>",
        "id": 270609653,
        "sender_full_name": "scottmcm",
        "timestamp": 1643918760
    },
    {
        "content": "<p>Now that we have editions to make that possible.</p>",
        "id": 270609707,
        "sender_full_name": "scottmcm",
        "timestamp": 1643918775
    },
    {
        "content": "<p>Because if we make it work like that <code>s!</code> macro I linked, then it'd work fine with private fields and thus with <code>non_exhaustive</code> just fine.</p>",
        "id": 270609755,
        "sender_full_name": "scottmcm",
        "timestamp": 1643918808
    },
    {
        "content": "<p>(It has a <code>defaults</code> method, rather than <code>Default::default()</code> because I wouldn't necessarily call <code>defaults()</code> the \"one true, sane, default\", and the really isn't another one. It's just \"initialize everything to the default prefix, with all directories where they normally are, according to the GNU standards\")</p>",
        "id": 270610027,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643918918
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/allow.20construction.20of.20non-exhaustive.20structs.20.E2.80.A6.20lang-team.23143/near/270609653\">said</a>:</p>\n<blockquote>\n<p>I think this is coming back to the whole \"maybe we should just change FRU to work how people expect\", thing.</p>\n</blockquote>\n<p>Actually, that seems like a really good starting point, and I wonder if part of the issue is \"how I expect FRU to work\".</p>",
        "id": 270610257,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643919034
    },
    {
        "content": "<p>So, I expect (though I know it may not currently work this way) our current FRU like <code>S { field: value, ..base }</code> to mostly desugar to:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_struct</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">base</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">_struct</span><span class=\"p\">.</span><span class=\"n\">field</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">_struct</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>except that I don't expect it to actually copy across <code>field</code> and then drop the old value, so it's closer to only assigning the subset of fields that aren't overridden:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">field</span>: <span class=\"nc\">value</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">otherfield</span>: <span class=\"nc\">base</span><span class=\"p\">.</span><span class=\"n\">otherfield</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">anotherfield</span>: <span class=\"nc\">base</span><span class=\"p\">.</span><span class=\"n\">anotherfield</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>but despite the second desugaring from a \"don't copy then drop <code>field</code>\" point of view, I don't actually expect that to fail if <code>otherfield</code> or <code>anotherfield</code> is private because <em>logically</em> it <em>could</em> behave like the previous version and we just don't want the extra <code>Drop</code> on <code>field</code> (which is public).</p>",
        "id": 270610517,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643919147
    },
    {
        "content": "<p>But for the proposed <em>new</em> FRU, like <code>S { field: value, .. }</code>, I expect it to desugar to:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">field</span>: <span class=\"nc\">value</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">otherfield</span>: <span class=\"nc\">default_from_definition</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">anotherfield</span>: <span class=\"nc\">default_from_definition</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 270610639,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643919217
    },
    {
        "content": "<p><em>including</em> the implication that if <code>otherfield</code> and <code>anotherfield</code> are private, that should fail to compile.</p>",
        "id": 270610658,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643919228
    },
    {
        "content": "<p>I'm not arguing that that should be the universal interpretation, but that's how I expect FRU to work, and that's roughly the expectation I have in mind when I argue that <code>..</code> shouldn't cover private fields.</p>",
        "id": 270611013,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643919370
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/allow.20construction.20of.20non-exhaustive.20structs.20.E2.80.A6.20lang-team.23143/near/270610639\">said</a>:</p>\n<blockquote>\n<p>But for the proposed <em>new</em> FRU, like <code>S { field: value, .. }</code>, I expect it to desugar to:</p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">field</span>: <span class=\"nc\">value</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">otherfield</span>: <span class=\"nc\">default_from_definition</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">anotherfield</span>: <span class=\"nc\">default_from_definition</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>So basically I wouldn't even call that FRU.</p>\n<p>And the \"though I know it may not currently work this way\" is exactly what I mean by \"we should just change FRU\".  Because it's not at all the desugar you wrote.</p>",
        "id": 270611018,
        "sender_full_name": "scottmcm",
        "timestamp": 1643919375
    },
    {
        "content": "<p>Yeah, fair, that's not so much FRU as initialization-with-defaults.</p>",
        "id": 270611057,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643919401
    },
    {
        "content": "<p>Summary: if you're modifying an existing base structure I think it's fine to semantically just copy across private fields <em>because</em> you could just as easily copy the whole struct and then overwrite public fields, and you had to have <em>gotten</em> the base struct from something that properly initialized those private fields. If you're creating a new structure without a base, I don't think that should work with private fields, because the struct might <em>want</em> you to only be able to use a constructor function and not make a struct as raw data without running a constructor.</p>",
        "id": 270611184,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643919475
    },
    {
        "content": "<p>Does that distinction make sense (leaving aside the question of whether people agree with it)?</p>",
        "id": 270611266,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643919500
    },
    {
        "content": "<p>Well, the problem with private fields is <code>Vec { ..otherVec }</code>, which if allowed in the current desugar would blow up horribly.</p>",
        "id": 270611354,
        "sender_full_name": "scottmcm",
        "timestamp": 1643919543
    },
    {
        "content": "<p>Because the current one doesn't move the original thing, even when it's non-Copy.</p>",
        "id": 270611423,
        "sender_full_name": "scottmcm",
        "timestamp": 1643919588
    },
    {
        "content": "<p><code>Foo { a: b, ..other }</code> is <code>Foo { a: b, every: other.every, field: other.field }</code>, though I think that usually doesn't make sense.</p>",
        "id": 270611810,
        "sender_full_name": "scottmcm",
        "timestamp": 1643919747
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/allow.20construction.20of.20non-exhaustive.20structs.20.E2.80.A6.20lang-team.23143/near/270611354\">said</a>:</p>\n<blockquote>\n<p>Well, the problem with private fields is <code>Vec { ..otherVec }</code>, which if allowed in the current desugar would blow up horribly.</p>\n</blockquote>\n<p>...right, raw pointers are a thing, and so are references with internal mutability.</p>",
        "id": 270613430,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643920409
    },
    {
        "content": "<p>Yeah, that's a <em>very</em> good argument for caution about private fields.</p>",
        "id": 270613450,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643920425
    },
    {
        "content": "<p>I was thinking primarily about \"what if the private fields are in an inconsistent state\", rather than \"what if the private fields can't simply be copied across\", and the latter would be a critical failure too.</p>",
        "id": 270613560,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643920463
    },
    {
        "content": "<p>So, another option would be to just have all forms of either FRU or init-with-<code>..</code> desugar to field-by-field initialization, and have that fail with private fields exactly as it would if you named the private field.</p>",
        "id": 270613693,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643920519
    },
    {
        "content": "<p>And <em>if</em> we want to allow <code>..</code> with private fields it could be opt-in.</p>",
        "id": 270613715,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643920531
    },
    {
        "content": "<p>If we allow it at all.</p>",
        "id": 270613738,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643920540
    },
    {
        "content": "<p>My intention was to make it nicer to do things you are already able to do:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">foo</span>: <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Default</span>::<span class=\"n\">default</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">foo</span><span class=\"p\">.</span><span class=\"n\">opt1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kc\">true</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">foo</span><span class=\"w\"></span>\n<span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Already works to construct a non-exhaustive type. This would just allow you to do it with struct syntax directly. I am not proposing that we allow any new behavior, but maybe that wasn't clear.</p>",
        "id": 270614761,
        "sender_full_name": "Jack Moffitt",
        "timestamp": 1643920999
    },
    {
        "content": "<p>I think this circles back to <code>#[non_exhaustive]</code> again, that there should be an opt-in mechanism for <code>#[non_exhausitve]</code> specifically. TBH, I think mixed field visibility is kinda weird and has limited use cases (part of the reason I've never wanted that use of <code>#[non_exhaustive]</code>). <br>\nI've never used it myself (except when what I've really wanted is privacy hygine), and I don't think I've seen it used, either in Rust, or even in C++. The only cases I've used it were in Java, where there is specific benefit to making some fields <code>protected</code> for superclasses. We should definately get <code>#[non_exhaustive(pub)]</code> and perhaps that becoming default in an edition may be something to consider.</p>",
        "id": 270615021,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643921128
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/allow.20construction.20of.20non-exhaustive.20structs.20.E2.80.A6.20lang-team.23143/near/270607934\">said</a>:</p>\n<blockquote>\n<p>Basically, it'd be a shame if accepting this meant that everyone has to go back to adding private unit fields to their structs to allow more private fields in future, since that's what <code>non_exhaustive</code> meant people could stop doing.</p>\n</blockquote>\n<p>I'm not quite following what would break here. Presumably you're adding new private fields with defaults or the other methods of construction set those fields. This breaks only in the case that doing things like <code>let mut foo = Foo::default(); foo.pub_field = something;</code> would also break.</p>",
        "id": 270615675,
        "sender_full_name": "Jack Moffitt",
        "timestamp": 1643921487
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/allow.20construction.20of.20non-exhaustive.20structs.20.E2.80.A6.20lang-team.23143/near/270607934\">said</a>:</p>\n<blockquote>\n<p>Basically, it'd be a shame if accepting this meant that everyone has to go back to adding private unit fields to their structs to allow more private fields in future, since that's what <code>non_exhaustive</code> meant people could stop doing.</p>\n</blockquote>\n<p>I think people <em>still</em> do this. I almost always do struct <code>#[non_exhaustive]</code> manually, to be explicit about whether I mean \"I can add other <code>pub</code> fields later\" or \"I can add other fields, at any visibility, later\". The <code>clippy::manual_nonexhaustive</code> lint only applies for enums for what I can presume to be this reason.</p>",
        "id": 270620965,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643923922
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"235180\">Jack Moffitt</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/allow.20construction.20of.20non-exhaustive.20structs.20.E2.80.A6.20lang-team.23143/near/270615675\">said</a>:</p>\n<blockquote>\n<p>This breaks only in the case that doing things like <code>let mut foo = Foo::default(); foo.pub_field = something;</code> would also break.</p>\n</blockquote>\n<p>That's not what FRU <em>does</em>, though.  (That's what ≈everyone <em>thinks</em> it does, but not the actual desugaring.)</p>\n<p>If that <em>were</em> how FRU actually desugared, then I'd have no problem with allowing this change.  Indeed, I wish that were how it worked and thus that this were allowed.</p>",
        "id": 270621304,
        "sender_full_name": "scottmcm",
        "timestamp": 1643924074
    },
    {
        "content": "<p>maybe we should change how FRU is desugared then...</p>",
        "id": 270631868,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643929341
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"229517\">Jacob Lifshay</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/allow.20construction.20of.20non-exhaustive.20structs.20.E2.80.A6.20lang-team.23143/near/270631868\">said</a>:</p>\n<blockquote>\n<p>maybe we should change how FRU is desugared then...</p>\n</blockquote>\n<p><a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/allow.20construction.20of.20non-exhaustive.20structs.20.E2.80.A6.20lang-team.23143/near/270609653\">I agree</a> <span aria-label=\"blush\" class=\"emoji emoji-1f60a\" role=\"img\" title=\"blush\">:blush:</span></p>\n<p><a href=\"https://internals.rust-lang.org/t/allow-fru-syntax-on-non-exhaustive-structs/12800/4?u=scottmcm\">https://internals.rust-lang.org/t/allow-fru-syntax-on-non-exhaustive-structs/12800/4?u=scottmcm</a><br>\n<a href=\"https://internals.rust-lang.org/t/pre-rfc-relaxed-non-exhaustive-structs/11977/15?u=scottmcm\">https://internals.rust-lang.org/t/pre-rfc-relaxed-non-exhaustive-structs/11977/15?u=scottmcm</a><br>\n<a href=\"https://internals.rust-lang.org/t/proto-rfc-expanded-functional-record-update/3077/2?u=scottmcm\">https://internals.rust-lang.org/t/proto-rfc-expanded-functional-record-update/3077/2?u=scottmcm</a></p>",
        "id": 270634066,
        "sender_full_name": "scottmcm",
        "timestamp": 1643930410
    },
    {
        "content": "<p>yeah, this is a real problem for -sys crates sometimes — i'd love to mark structs as non-exhaustive, because there are some patterns C libraries use which allow abi-compatibly adding new fields to the end of structs (keeping a field for either the size or version or something). it feels like if it has a default impl, and is non_exhaustive, that'd work great for a lot of cases, but it doesnt</p>",
        "id": 270665770,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1643947975
    },
    {
        "content": "<p>(To Niko's request, I've made a summary post of my thoughts on the github item: <a href=\"https://github.com/rust-lang/lang-team/issues/143#issuecomment-1029638652\">https://github.com/rust-lang/lang-team/issues/143#issuecomment-1029638652</a> )</p>",
        "id": 270669197,
        "sender_full_name": "scottmcm",
        "timestamp": 1643951581
    },
    {
        "content": "<blockquote>\n<p>Note that just using the different desugar for <code>non_exhaustive</code> types would make <em>removing</em> the attribute a breaking change, which I don't think it currently is, so I think I'm negative on that.</p>\n</blockquote>\n<p>Is that breakage only in the case of <code>Drop</code> impls?</p>\n<p>i.e. in <code>Struct { f: f, ..rest }</code> with <code>Struct</code> being <code>non_exhaustive</code>, desugaring to <code>{let mut tmp=rest; tmp.f=f; tmp}</code> would drop <code>rest.f</code> but not drop any instance of type <code>Struct</code>, whereas then the <code>non_exhaustive</code> might be removed causing it to revert to the current desugaring, which <strong>moves</strong> some fields of <code>rest</code>, which breaks if <code>Struct</code> has a <code>Drop</code> impl because we can't destructure / partial move such a struct.</p>\n<p>If so, is it fine if we allow FRU on <code>non_exhaustive</code> <strong>only with no Drop impl</strong>, via the <code>let mut tmp</code> desugaring? The concern about removing <code>non_exhaustive</code> being a breaking change wouldn't apply then right? Of course adding a <code>Drop</code> impl would then be a breaking change, but adding a <code>Drop</code> impl is always a breaking change already anyway.</p>",
        "id": 270671064,
        "sender_full_name": "David Tolnay",
        "timestamp": 1643953701
    },
    {
        "content": "<p>Ooh, keying on <code>Drop</code> is interesting!  Doing the \"move out of the fields\" is particularly-sketchy for things with <code>Drop</code> (both because partial moves aren't allowed for Drop types at all, and because copying Copy fields is that much more error-prone, like that <code>Vec</code> example), so something related to that sounds like it could work.</p>",
        "id": 270672383,
        "sender_full_name": "scottmcm",
        "timestamp": 1643955151
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119235\">David Tolnay</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/allow.20construction.20of.20non-exhaustive.20structs.20.E2.80.A6.20lang-team.23143/near/270671064\">said</a>:</p>\n<blockquote>\n<p>which breaks if <code>Struct</code> has a <code>Drop</code> impl because we can't destructure / partial move such a struct.</p>\n</blockquote>\n<p>Oh, wait, I think this argument doesn't quite work.</p>\n<p>You <em>can</em> still FRU something with <code>Drop</code> so long as its fields are copy:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[derive(Debug)]</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">MyVec</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">len</span>: <span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">cap</span>: <span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"nb\">Drop</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">MyVec</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">drop</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"Look at me I have a Drop impl\"</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MyVec</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">len</span>: <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">cap</span>: <span class=\"mi\">10</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MyVec</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">len</span>: <span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">dbg!</span><span class=\"p\">((</span><span class=\"s\">\"still alive:\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p><a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=6fb4a5e45650390a8839abcf5b3f6862\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=6fb4a5e45650390a8839abcf5b3f6862</a></p>",
        "id": 270672608,
        "sender_full_name": "scottmcm",
        "timestamp": 1643955413
    },
    {
        "content": "<p>(Things like this that keep using the base value after FRUing from it are a big part of why changing the desugaring is a breaking change, IIRC.)</p>",
        "id": 270672638,
        "sender_full_name": "scottmcm",
        "timestamp": 1643955478
    },
    {
        "content": "<p>Isn't that fine? The counterproposal was keying on Drop <em>and</em> non_exhaustive, not only Drop. If exhaustive then current desugaring. If non_exhaustive and no Drop, then <code>let mut tmp</code> desugaring. If non_exhaustive and Drop then fail.</p>",
        "id": 270672785,
        "sender_full_name": "David Tolnay",
        "timestamp": 1643955618
    },
    {
        "content": "<p>with the salient concern being what happens when a non_exhaustive attribute is removed, which we want not to be a breaking change.</p>\n<p>In that situation something with no Drop impl will revert from <code>let mut tmp</code> desugaring to current desugaring.</p>",
        "id": 270672993,
        "sender_full_name": "David Tolnay",
        "timestamp": 1643955871
    },
    {
        "content": "<p>for example a <code>{let mut tmp = rest; tmp.f=f; tmp}</code> would turn into <code>Struct { f: f, other: rest.other }</code>, in which we know <code>Struct</code> has no <code>Drop</code> impl</p>",
        "id": 270673120,
        "sender_full_name": "David Tolnay",
        "timestamp": 1643956002
    },
    {
        "content": "<p>an observation: that change causes <code>rest.f</code> to live longer than it did before, which might mean it holds on to some borrows longer than before, which might cause borrow errors. Thus we might need an additional restriction that the fields which are <strong>named</strong> in the FRU are all 'static when the type is non_exhaustive.</p>",
        "id": 270673202,
        "sender_full_name": "David Tolnay",
        "timestamp": 1643956098
    },
    {
        "content": "<p>Alternatively, we can restrict that <code>rest</code> must be a temporary when your type is non_exhaustive. Thus <code>rest.f</code> would drop at the same place in both desugarings.</p>\n<p>This is great for <code>Struct { f: f, ..Default::default() }</code></p>",
        "id": 270673530,
        "sender_full_name": "David Tolnay",
        "timestamp": 1643956496
    },
    {
        "content": "<p>Hmm, does that mean that FRU with <code>..{ EXPR }</code> always works with either desugar?  That might also be an interesting way to do an edition change...</p>",
        "id": 270677858,
        "sender_full_name": "scottmcm",
        "timestamp": 1643961004
    },
    {
        "content": "<p>Another interesting thing, imho, is the <code>.also</code> pattern from Kotlin, featured in <a href=\"https://docs.rs/tap\">https://docs.rs/tap</a> (I'd personally switch the short/long naming <em>w.r.t.</em> the ref/mut adaptors, since I've found the mut case to be way more frequent than the non-mut case):</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Struct</span>::<span class=\"n\">default</span><span class=\"p\">().</span><span class=\"n\">tap</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">s</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">s</span><span class=\"p\">.</span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">s</span><span class=\"p\">.</span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Bar</span>::<span class=\"n\">special</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"p\">});</span><span class=\"w\"></span>\n</code></pre></div>\n<ul>\n<li><a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=3b72e9acbda22f32ee84344021d55fcf\">Demo</a></li>\n</ul>\n<p>And from there postfix macros <em>could</em> alleviate the syntax even more.</p>",
        "id": 270739140,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1643992399
    },
    {
        "content": "<p>Wait, if we're using macros we don't even need postfix macros.</p>\n<p>We can just use exactly the same structure as \"real\" FRU, like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">yay</span><span class=\"p\">(</span><span class=\"n\">f</span>: <span class=\"nc\">Foo</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">fru</span><span class=\"o\">!</span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">a</span>: <span class=\"mi\">100</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">\"hello\"</span><span class=\"p\">.</span><span class=\"n\">to_owned</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">fru</span><span class=\"o\">!</span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"n\">Foo</span>::<span class=\"n\">default</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Here's the macro:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"fm\">macro_rules!</span><span class=\"w\"> </span><span class=\"n\">__expand_field</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"w\"> </span><span class=\"cp\">$b</span>: <span class=\"nc\">ident</span><span class=\"w\"> </span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"cp\">$f</span>:<span class=\"nc\">ident</span><span class=\"w\"> </span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"cp\">$b</span><span class=\"p\">.</span><span class=\"cp\">$f</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"cp\">$f</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}};</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"w\"> </span><span class=\"cp\">$b</span>: <span class=\"nc\">ident</span><span class=\"w\"> </span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"cp\">$f</span>:<span class=\"nc\">ident</span><span class=\"w\"> </span>: <span class=\"cp\">$e</span>:<span class=\"nc\">expr</span><span class=\"w\"> </span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"cp\">$b</span><span class=\"p\">.</span><span class=\"cp\">$f</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"cp\">$e</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}};</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"fm\">macro_rules!</span><span class=\"w\"> </span><span class=\"n\">fru</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"cp\">$(</span><span class=\"w\"> </span><span class=\"cp\">$f</span>:<span class=\"nc\">ident</span><span class=\"w\"> </span><span class=\"cp\">$(</span><span class=\"w\"> </span>: <span class=\"cp\">$e</span>:<span class=\"nc\">expr</span><span class=\"w\">  </span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"w\"> </span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">..</span><span class=\"w\"> </span><span class=\"cp\">$b</span>:<span class=\"nc\">expr</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">tmp</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"cp\">$b</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"cp\">$(</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">__expand_field</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">tmp</span><span class=\"w\"> </span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"cp\">$f</span><span class=\"w\"> </span><span class=\"cp\">$(</span><span class=\"w\"> </span>: <span class=\"cp\">$e</span><span class=\"w\"> </span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"w\"> </span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">tmp</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>&lt;<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=9da163d96521efea3b1e8a7eb9e188c4\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=9da163d96521efea3b1e8a7eb9e188c4</a>&gt;</p>",
        "id": 270781222,
        "sender_full_name": "scottmcm",
        "timestamp": 1644013372
    },
    {
        "content": "<p>Yeah that's a very nifty macro; I was mainly thinking about the possibility to nudge the type inference when inlined into some generic function, the advantage of <code>.tap()</code> is that it's receiver would be a good old <code>Struct::default()</code>; although for your macro type ascription would help quite a bit in that regard:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">fru</span><span class=\"o\">!</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">a</span>: <span class=\"mi\">100</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"p\">}</span>: <span class=\"nc\">Foo</span><span class=\"w\"></span>\n</code></pre></div>\n<p>I suspect that with a nicer name it can indeed be quite catchy <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span></p>",
        "id": 270789578,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1644019240
    },
    {
        "content": "<p>Note the examples, though -- the macro didn't really need any type ascription because it gets it from the base object.</p>",
        "id": 270795558,
        "sender_full_name": "scottmcm",
        "timestamp": 1644024577
    },
    {
        "content": "<p>There's already a macro for the assignment-based FRU, though it doesn't use FRU syntax: <a href=\"https://docs.rs/assign/latest/assign/\">https://docs.rs/assign/latest/assign/</a></p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">field_a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"fm\">todo!</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">my_struct</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">assign</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">Struct</span>::<span class=\"n\">default</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">field_a</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">field_b</span>: <span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">});</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 271285415,
        "sender_full_name": "jplatte",
        "timestamp": 1644416868
    }
]