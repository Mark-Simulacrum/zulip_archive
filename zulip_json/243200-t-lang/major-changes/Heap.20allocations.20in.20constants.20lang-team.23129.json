[
    {
        "content": "<p>A new proposal has been announced: <a href=\"https://github.com/rust-lang/lang-team/issues/129\">Heap allocations in constants #129</a>. It will be announced at the next meeting to try and draw attention to it, but usually MCPs are not discussed during triage meetings. If you think this would benefit from discussion amongst the team, consider proposing a design meeting.</p>",
        "id": 263245222,
        "sender_full_name": "triagebot",
        "timestamp": 1638335301
    },
    {
        "content": "<blockquote>\n<p>We need to forbid constants where the final value is a non-empty buffer, because we might try to deallocate static memory if used</p>\n</blockquote>\n<p>There's a much simpler way to handle this: keep them behind a reference.</p>",
        "id": 263248582,
        "sender_full_name": "Lokathor",
        "timestamp": 1638338972
    },
    {
        "content": "<p>I think the later part of the post is trying to say that, but it's really unclear.</p>",
        "id": 263248633,
        "sender_full_name": "Lokathor",
        "timestamp": 1638339014
    },
    {
        "content": "<p>Ah, I see, it's example C way at the bottom</p>",
        "id": 263248660,
        "sender_full_name": "Lokathor",
        "timestamp": 1638339069
    },
    {
        "content": "<p>Notable Prior art: C++20 allows using <code>std::allocator</code> and paired <code>new</code>/<code>delete</code> expressions in constant expressions, but makes it invalid entirely to leak it to runtime at all.</p>",
        "id": 263298758,
        "sender_full_name": "Connor Horman",
        "timestamp": 1638369161
    },
    {
        "content": "<p>The way I see most of these <code>const</code>&amp;heap-related issues, is that instancing a <code>const</code> may be implemented as a bitwise copy of some precomputed / cached value the compiler has. So:</p>\n<ul>\n<li>any instance of a <code>Copy</code>(+ <code>Send</code>) type is a valid <code>const</code></li>\n<li>for other types, only some instances may be valid to copy, such as <code>String::new()</code>, <code>None</code>, <em>etc.</em></li>\n</ul>\n<p>So this hints at there being some <code>unsafe trait</code> to express this property:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">ConstCopyableInstance</span><span class=\"w\"> </span><span class=\"cm\">/* or `ConstSafeInstance`, if you want */</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">safe_to_const_bitcopy</span><span class=\"p\">(</span><span class=\"n\">_</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">Self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">bool</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">ConstCopyableInstance</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"nb\">String</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">safe_to_const_bitcopy</span><span class=\"p\">(</span><span class=\"n\">s</span>: <span class=\"kp\">&amp;</span><span class=\"nb\">String</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">bool</span> <span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"p\">.</span><span class=\"n\">capacity</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">ConstCopyableInstance</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">safe_to_const_bitcopy</span><span class=\"p\">(</span><span class=\"n\">it</span>: <span class=\"kp\">&amp;</span><span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">bool</span> <span class=\"p\">{</span><span class=\"w\"> </span><span class=\"fm\">matches!</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">it</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<ul>\n<li>\n<p>And since <code>&amp;T : Copy</code>, for instance, with <code>String::leak()</code> we'd have access to things like <code>const S: &amp;str = String::from(\"Hello, World!\").leak();</code></p>\n</li>\n<li>\n<p>The question of thread-safety is more subtle, however; but at first glance requiring that a <code>Const</code> be <code>Send</code> seems to be enough? Not sure though.</p>\n</li>\n</ul>\n<p>The <code>const</code>  interpreter could then call that function for non-<code>Copy</code> stuff to decide whether the resulting <code>const</code> is safe to bitcopy; else it triggers a <code>const_err</code>.</p>",
        "id": 263299173,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1638369337
    },
    {
        "content": "<p>I don't necessarily want user-defined code (even const code) to dictate whether an expression is, in fact, a constant expression.</p>",
        "id": 263299688,
        "sender_full_name": "Connor Horman",
        "timestamp": 1638369524
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232018\">@Daniel Henry-Mantilla</span> While I agree with the idea that <code>#[const_heap]</code> could be replaced by the CTFE evaluating a function to determine whether something can be the final value of a constant, I don't think the <code>Copy</code> trait should be used since it is a safe trait. Any downstream user can define <code>Evil(String)</code> and manually implement <code>Copy</code> on that newtype which would allow it to be type of a constant. Then any use of that constant could result in deallocating the static memory</p>",
        "id": 263333493,
        "sender_full_name": "fee1-dead",
        "timestamp": 1638382642
    },
    {
        "content": "<p><code>Copy</code> is not really a safe trait. it can only be implemented if all fields are copy. if a type uses <code>unsafe</code> code is it its responsibility to only impl <code>Copy</code> if the type indeed is duplicable.</p>",
        "id": 263339738,
        "sender_full_name": "RalfJ",
        "timestamp": 1638385159
    },
    {
        "content": "<blockquote>\n<p>We need auto marker traits </p>\n</blockquote>\n<p>That is a very strong claim (\"need\") -- there are other possibilities here. One suggestion that was mentioned before is to treat the CTFE heap allocator as a separate allocator. so CTFE-allocated string would have type <code>String&lt;CtfeAlloc&gt;</code>, assuming we have allocator-generic strings.<br>\nThis is, I think, the \"most principled\" solution -- allocators seem like exactly the right match for this problem. However, to achieve \"serde during CTFE\" this would require making serde allocator-generic...</p>",
        "id": 263340218,
        "sender_full_name": "RalfJ",
        "timestamp": 1638385304
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span>  I was wondering about allocators as well; since indeed if it were to be an \"anon lifetime\"-bound allocator (I was imagining a magic / lang-provided <code>const fn with_alloc(constructor: impl ~const FnOnce(&amp;'_ CtfeAlloc) -&gt; R) -&gt; R</code>) then we would have that guarantee that no allocation escapes a <code>const</code> body. But that means that we wouldn't be able to have leaked <code>&amp;String</code>s either, so it would end up being a quite restrictive approach, right? (on top of having to write the <code>const fn</code>s as generic over an <code>&lt;A : ~const Allocator&gt;</code>).</p>\n<p><span class=\"user-mention\" data-user-id=\"361356\">@fee1-dead</span> <span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> thanks for the feedback; I'm not super-convinced myself that <code>const</code>-inhabitance and <code>Copy</code> ought to be <em>that</em> intertwined, but at first glance it does look like there seems to be <em>some</em> potential there. But there may be too many caveats once we dig deeper (has there been a talk of bitwise copy and \"<code>const</code> safety\"?) Anyways, I did not want to derail the conversation regarding the original MCP, so I'll \"see myself out\" with these <code>Copy</code> / <code>is_safe_to_copy</code> ramblings <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span></p>",
        "id": 263343891,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1638386710
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"361356\">fee1-dead</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Heap.20allocations.20in.20constants.20lang-team.23129/near/263333493\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"232018\">Daniel Henry-Mantilla</span> While I agree with the idea that <code>#[const_heap]</code> could be replaced by the CTFE evaluating a function to determine whether something can be the final value of a constant, I don't think the <code>Copy</code> trait should be used since it is a safe trait. Any downstream user can define <code>Evil(String)</code> and manually implement <code>Copy</code> on that newtype which would allow it to be type of a constant. Then any use of that constant could result in deallocating the static memory</p>\n</blockquote>\n<p>Actually, Copy is magic in rust. You cannot implement <code>Copy</code> for a type that also implements <code>Drop</code>, or that has at least one field that does not implement the <code>Copy</code> trait, or has a variant with such a field. The implementation of Copy for the Evil newtype would be ill-formed under these rules.</p>",
        "id": 263346613,
        "sender_full_name": "Connor Horman",
        "timestamp": 1638387693
    },
    {
        "content": "<blockquote>\n<p>I was wondering about allocators as well; since indeed if it were to be an \"anon lifetime\"-bound allocator (I was imagining a magic / lang-provided const fn with_alloc(constructor: impl ~const FnOnce(&amp;'_ CtfeAlloc) -&gt; R) -&gt; R) then we would have that guarantee that no allocation escapes a const body.</p>\n</blockquote>\n<p>Escaping is fine though. I was imagining a magic global type <code>CtfeAlloc</code> and associated value that can only be used at const time. A Box allocated at const-time then looks like <code>const FOO: Box&lt;T, CtfeAlloc&gt;</code>, and the runtime behavior of <code>CtfeAlloc::dealloc</code> is a NOP, thus this is safe. well, except for aliasing model concerns...</p>",
        "id": 263386429,
        "sender_full_name": "RalfJ",
        "timestamp": 1638412428
    },
    {
        "content": "<p>so i think one problem here is that, as far as i know, currently you can't (or can't easily) clone a value from one allocator using another, because clone returns Self and so even any allocator agnostic type would be bound to the same allocator.</p>",
        "id": 263399434,
        "sender_full_name": "Lokathor",
        "timestamp": 1638428044
    },
    {
        "content": "<p>in other words, what are you doing with that ctfe vec that you even care about it being a vec and not an array or a slice? if you can't even clone the const vec value to get your own version of the vec that's really limited use.</p>",
        "id": 263399509,
        "sender_full_name": "Lokathor",
        "timestamp": 1638428143
    },
    {
        "content": "<p>so an alternative allocator is a simple fix in one sense, but would maybe just bring to light that current rust is actually bad at allocators.</p>",
        "id": 263399596,
        "sender_full_name": "Lokathor",
        "timestamp": 1638428237
    },
    {
        "content": "<p>Having a separate allocator might be the easiest, since we already have <code>const_alloc</code> as an intrinsic. But as <span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> said, you still have to make existing libraries generic. I would rather prefer a solution that \"just works\" instead of forcing people to change their libraries to be able to use in compile time.</p>\n<p>Also note that you could use <code>clone_from_slice</code> to clone <code>&amp;Vec&lt;T, CtfeAlloc&gt;</code> to <code>Vec&lt;T, Global&gt;</code> (or just use <code>From&lt;&amp;[T]&gt; for Vec&lt;T, Global&gt;</code>)</p>",
        "id": 263406900,
        "sender_full_name": "fee1-dead",
        "timestamp": 1638434701
    },
    {
        "content": "<p>A real world example: when sending http requests, it is desirable to parse the URL string at compile time, and use it at runtime. But the <code>url</code> crate wants to own the URL string, instead of referencing it. (<a href=\"https://docs.rs/url/latest/src/url/lib.rs.html#166-188\">link</a>)</p>\n<p>They could add a generic parameter for the allocator, and to avoid semver hazards they would need to add another function named <code>const_parse</code> which to me is pretty uncomfortable. The current proposal would work and only requires making the parsing work under CTFE.</p>",
        "id": 263408088,
        "sender_full_name": "fee1-dead",
        "timestamp": 1638435381
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Heap.20allocations.20in.20constants.20lang-team.23129/near/263386429\">said</a>:</p>\n<blockquote>\n<p>the runtime behavior of <code>CtfeAlloc::dealloc</code> is a NOP, thus this is safe. well, except for aliasing model concerns...</p>\n</blockquote>\n<p>The aliasing concerns were why I quickly abandoned the idea of an escaping allocator <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span></p>",
        "id": 263416126,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1638440146
    },
    {
        "content": "<blockquote>\n<p>This is, I think, the \"most principled\" solution -- allocators seem like exactly the right match for this problem. However, to achieve \"serde during CTFE\" this would require making serde allocator-generic...</p>\n</blockquote>\n<p>I think this is a more general issue with the Allocator API rather than an issue specific to const-heap — it often impractical or impossible (for object-safe traits) to parameterize things over the allocator generically. Unfortunately, the usual solution to \"can't use generics here\" (dynamic dispatch) is... very hard to use in the current allocator API[^1].</p>\n<p>That said, dynamic allocator dispatch is more of a \"if we had already solved this, we could reuse that here\" rather than a \"this is the best/only solution to this problem\"...</p>\n<hr>\n<p>[^1]: It's hard to use dynamic dispatch because while <code>Allocator</code> is object safe, use of trait objects requires an allocator (or borrowing). For example, consider storing it in a smart pointer (say <code>Arc</code>): you end up with something like <code>String&lt;Arc&lt;dyn Allocator, ButWhatGoesHere&gt;&gt;</code>...</p>\n<p>It ends up being a mess (and one you hit basically immediately if you try to do this, so I think not many people have), especially when you realize that even the choice of <code>Arc</code>/<code>Rc</code>/<code>Box</code>/<code>&amp;'static</code>/... ends up going some amount of the way to defeating the point of the type erasure to begin with.</p>\n<p>It's similar to the problem that lead to RawWakerVtable , but seems harder along several axes (including the fact that \"make it always dynamic\" is clearly not viable, unlike with wakers)... Sadly, the allocator-wg is completely stalled, to the point where I don't even bother filing issues when I hit them.</p>",
        "id": 263538450,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1638510341
    }
]