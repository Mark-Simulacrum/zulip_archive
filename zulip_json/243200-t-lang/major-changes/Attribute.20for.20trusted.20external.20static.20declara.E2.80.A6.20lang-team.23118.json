[
    {
        "content": "<p>A new proposal has been announced: <a href=\"https://github.com/rust-lang/lang-team/issues/118\">Attribute for trusted external static declarations #118</a>. It will be announced at the next meeting to try and draw attention to it, but usually MCPs are not discussed during triage meetings. If you think this would benefit from discussion amongst the team, consider proposing a design meeting.</p>",
        "id": 255993093,
        "sender_full_name": "triagebot",
        "timestamp": 1633309435
    },
    {
        "content": "<p>FWIW I feel like an attribute here feels pretty \"unfortunate\"</p>",
        "id": 256070500,
        "sender_full_name": "simulacrum",
        "timestamp": 1633358675
    },
    {
        "content": "<p>otoh, the default being unsafe feels not entirely wrong (and not having the default be unsafe feels easy to cause accidents with)</p>",
        "id": 256070605,
        "sender_full_name": "simulacrum",
        "timestamp": 1633358724
    },
    {
        "content": "<p>I think it would be relatively reasonable to change the default in the future on the basis of whether the type of the external static is <code>Send</code> and <code>Sync</code>.</p>",
        "id": 256071813,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1633359189
    },
    {
        "content": "<p>But that might be disruptive without an edition boundary. So we could also add an attribute to enable that behavior, and then make that attribute unnecessary in a future edition.</p>",
        "id": 256071966,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1633359246
    },
    {
        "content": "<p>Yeah, that seems potentially reasonable. Ideally, I think, we'd have a better listing of the requirements for adding such a tag -- in principle, <em>non-mut</em> extern statics feel pretty likely to either be sound to access always or never sound to access. For <code>static mut</code> that feels less true, but then it would likely still be unsafe.</p>",
        "id": 256072342,
        "sender_full_name": "simulacrum",
        "timestamp": 1633359373
    },
    {
        "content": "<p>A non-mut static could easily be sound but unsafe, if it has external synchronization separately.</p>",
        "id": 256079393,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1633361904
    },
    {
        "content": "<p>That seems to be false, or the reference is wrong:</p>\n<blockquote>\n<p>Extern statics can be either immutable or mutable just like statics outside of external blocks. An immutable static must be initialized before any Rust code is executed. It is not enough for the static to be initialized before Rust code reads from it.</p>\n</blockquote>",
        "id": 256079850,
        "sender_full_name": "simulacrum",
        "timestamp": 1633362062
    },
    {
        "content": "<p>I would expect the type to need to be UnsafeCell-like if it has external synchronization</p>",
        "id": 256079916,
        "sender_full_name": "simulacrum",
        "timestamp": 1633362089
    },
    {
        "content": "<p>That seems questionable to me. I'm wondering where that requirement arose from? It seems perfectly reasonable to initialize it before Rust reads it. Or, for that matter, for Rust code to initialize it by writing before reading.</p>",
        "id": 256080167,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1633362177
    },
    {
        "content": "<p>I'm confused why you would expect a non-mut static to permit writing to it -- I don't think we do it today, but I would expect us to treat it as readonly data (e.g., arbitrarily caching it's value)</p>",
        "id": 256080281,
        "sender_full_name": "simulacrum",
        "timestamp": 1633362226
    },
    {
        "content": "<p>IOW, I expect an extern static and a regular static to be equivalent here</p>",
        "id": 256080412,
        "sender_full_name": "simulacrum",
        "timestamp": 1633362268
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/pull/67630#issuecomment-569154116\">https://github.com/rust-lang/rust/pull/67630#issuecomment-569154116</a></p>",
        "id": 256080592,
        "sender_full_name": "simulacrum",
        "timestamp": 1633362352
    },
    {
        "content": "<p>the non-mut static can permit reads if it uses UnsafeCell internally (atomic values are the common case here).</p>",
        "id": 256081005,
        "sender_full_name": "Lokathor",
        "timestamp": 1633362506
    },
    {
        "content": "<p>sure, yeah, that's basically \"mut internally\", I don't think there's dispute there -- it sounds like Josh is saying that should be permitted <em>without</em> an UnsafeCell though.</p>",
        "id": 256081230,
        "sender_full_name": "simulacrum",
        "timestamp": 1633362597
    },
    {
        "content": "<p><strong>without</strong> UnsafeCell would break Rust's rules, and particularly it would make extern static able to do something that not-extern static can't, which I don't think is a good idea.</p>",
        "id": 256081507,
        "sender_full_name": "Lokathor",
        "timestamp": 1633362695
    },
    {
        "content": "<p>I'm not suggesting writing without an UnsafeCell, no.</p>",
        "id": 256082830,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1633363196
    },
    {
        "content": "<p>(Well, an UnsafeCell or an equivalent by calling an extern C function.)</p>",
        "id": 256083011,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1633363235
    },
    {
        "content": "<p>I don't understand what you mean by \"an equivalent\"</p>",
        "id": 256083101,
        "sender_full_name": "simulacrum",
        "timestamp": 1633363268
    },
    {
        "content": "<p>the static literally needs to be declared on the Rust side with UnsafeCell in the type, right? There's no workaround for that</p>",
        "id": 256083144,
        "sender_full_name": "simulacrum",
        "timestamp": 1633363287
    },
    {
        "content": "<p>same as how you can't do:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">f</span>: <span class=\"kp\">&amp;</span><span class=\"kt\">u32</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"n\">some_c_func</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">f</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// c magically changed it</span>\n</code></pre></div>",
        "id": 256083209,
        "sender_full_name": "simulacrum",
        "timestamp": 1633363316
    },
    {
        "content": "<p>Yeah, all externals (code or variables) must <em>behave</em> as if they're following Rust's rules for Rust to safely interact with them. Even if technically they have powers beyond that.</p>",
        "id": 256084321,
        "sender_full_name": "Lokathor",
        "timestamp": 1633363689
    },
    {
        "content": "<p>To be clear, this is only about extern <code>static</code>, not <code>static mut</code>? And part of the things one is certifying by adding that attribute is \"this static is truly immutable (or there is an UnsafeCell)\"?</p>",
        "id": 256140532,
        "sender_full_name": "RalfJ",
        "timestamp": 1633384994
    },
    {
        "content": "<p>This is not directly related to this attribute, but to <code>extern static</code> so it might be worth bringing up -- is it a common issue that people think <code>extern \"C\" { pub static FOO: T }</code> (assume no UnsafeCell) is immutable from Rust but okay to mutate from other languages? I am a big fan of immutable-by-default for things entirely under Rust control, but in the case of <code>extern</code> this means <em>assuming</em> that the outside world is immutable which does not seem like a safe default.</p>",
        "id": 256140955,
        "sender_full_name": "RalfJ",
        "timestamp": 1633385209
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Attribute.20for.20trusted.20external.20static.20declara.E2.80.A6.20lang-team.23118/near/256070500\">said</a>:</p>\n<blockquote>\n<p>FWIW I feel like an attribute here feels pretty \"unfortunate\"</p>\n</blockquote>\n<p>yeah... the existing \"unsafe attributes\" are basically accidents I would say; not sure how I feel about extending that set -- with an attribute that doesnt even have \"unsafe\" in its name, even. Would <code>unsafe extern \"C\" { static FOO: T }</code> make sense, or <code>extern \"C\" { unsafe static FOO: T }</code>?</p>",
        "id": 256141259,
        "sender_full_name": "RalfJ",
        "timestamp": 1633385368
    },
    {
        "content": "<p>I feel like unsafe extern feels similar to unsafe impl trait which seems good, but unsafe static is unfortunate - too similar to unsafe fn, which has opposite effect</p>",
        "id": 256142179,
        "sender_full_name": "simulacrum",
        "timestamp": 1633385820
    },
    {
        "content": "<p>My impression is that we currently already assume these statics are \"truly immutable\" regardless of this attribute, but there seems to be some disagreement on this point with Josh</p>",
        "id": 256142304,
        "sender_full_name": "simulacrum",
        "timestamp": 1633385890
    },
    {
        "content": "<p>I think if you have a Sync opaque type on the Rust side, it's not unreasonable for it to have interior mutability on the C side.</p>",
        "id": 256148744,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1633389410
    },
    {
        "content": "<p>I'm not sure where the concept of non-mut (either by <code>mut</code> or <code>UnsafeCell</code>) statics that point to mutable memory comes from. It is not all that uncommon for a target to have distinct memories/address spaces/etc for static (ROM!) and mutable (RAM!) memory. And there's no reason whatsoever why the linker/backend/etc couldn't derive the necessary location to use based on how mutable extern static declaration is.</p>",
        "id": 256148766,
        "sender_full_name": "nagisa",
        "timestamp": 1633389425
    },
    {
        "content": "<p>that said its 2am here and I still am super confused about what's been said in this thread despite having read through it like 3 times over, so I'll just try to not forget to look at this with a fresh head tomorrow.</p>",
        "id": 256149026,
        "sender_full_name": "nagisa",
        "timestamp": 1633389630
    },
    {
        "content": "<p>What do you mean by a \"Sync opaque type\", Josh?</p>",
        "id": 256149472,
        "sender_full_name": "simulacrum",
        "timestamp": 1633389950
    },
    {
        "content": "<p><code>unsafe extern \"C\" { /* stuff */ }</code> seems like a good way to improve the situation without a new attribute and maintain clarity.</p>",
        "id": 256149904,
        "sender_full_name": "Lokathor",
        "timestamp": 1633390174
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Attribute.20for.20trusted.20external.20static.20declara.E2.80.A6.20lang-team.23118/near/256149472\">said</a>:</p>\n<blockquote>\n<p>What do you mean by a \"Sync opaque type\", Josh?</p>\n</blockquote>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"s\">\"C\"</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">static</span><span class=\"w\"> </span><span class=\"n\">THE_THING</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"nb\">static</span> <span class=\"nc\">TheType</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>where <code>TheType</code> is an <code>extern type</code> or similar, and is <code>Sync</code>.</p>",
        "id": 256174406,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1633407084
    },
    {
        "content": "<p>Something roughly along those lines.</p>",
        "id": 256174426,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1633407104
    },
    {
        "content": "<p>(Or, in theory, just <code>static THE_THING: TheType;</code>, if we have some way of doing that without TheType being sized, or if TheType is sized but contains a pointer for interior mutability.)</p>",
        "id": 256174515,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1633407160
    },
    {
        "content": "<p>If i understand you, i think the correct way to model that would still be to do it with UnsafeCell&lt;TheType&gt;, or &amp;'static UnsafeCell or whatever other variant.</p>\n<p>Basically \"if it's going to interior mutate it has to have UnsafeCell\" is the rule in rust.</p>\n<p>so it's easiest to understand for everyone if we just say that declarations of foreign things should also include an UnsafeCell layer if they're going to be doing interior mutation. and you can put a transparent wrapper over the UnsafeCell if that is appropriate, but there's still the UnsafeCell in there.</p>",
        "id": 256187665,
        "sender_full_name": "Lokathor",
        "timestamp": 1633417449
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> I dont see how that could possibly work if Rust is allowed to assume that data behind shared refs is immutable (except for UnsafeCell)</p>",
        "id": 256314474,
        "sender_full_name": "RalfJ",
        "timestamp": 1633465973
    },
    {
        "content": "<p>If the type is a fully opaque handle, what would that assumption mean?</p>",
        "id": 256314918,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1633466164
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Attribute.20for.20trusted.20external.20static.20declara.E2.80.A6.20lang-team.23118/near/256070605\">said</a>:</p>\n<blockquote>\n<p>otoh, the default being unsafe feels not entirely wrong (and not having the default be unsafe feels easy to cause accidents with)</p>\n</blockquote>\n<p>Do you mean the default being that <em>referencing the static is unsafe</em> feels \"not entirely wrong\"?</p>",
        "id": 256480289,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1633552719
    },
    {
        "content": "<p>It seems to me like the default ought to be that declaring is unsafe but referencing is safe</p>",
        "id": 256480309,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1633552731
    },
    {
        "content": "<p>Because if the type is wrong, then all uses are definitely wrong</p>",
        "id": 256480337,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1633552750
    },
    {
        "content": "<p>And if the declaration is <em>correct</em> (ie., this fits the semantics of a Rust <code>static</code>), then uses are <em>safe</em></p>",
        "id": 256480391,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1633552776
    },
    {
        "content": "<p>in other words, if you have a <code>static</code> and you mutate it from multiple threads or something</p>",
        "id": 256480421,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1633552790
    },
    {
        "content": "<p>the problem was declaring it a <code>static</code> (and not a <code>static mut</code>) in the first place, no?</p>",
        "id": 256480435,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1633552801
    },
    {
        "content": "<p>I think the ability to have unsafe-only immutable statics is useful. Particularily for MMIO. For some reason, rust assumes it can read an &amp;T, even if that <code>T</code> is <code>UnsafeCell&lt;U&gt;</code>. If someone could safely take a reference to</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">extern</span><span class=\"s\">\"C\"</span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">static</span><span class=\"w\"> </span><span class=\"n\">_FaultCode</span>: <span class=\"nc\">UnsafeCell</span><span class=\"o\">&lt;</span><span class=\"kt\">u16</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>That seems potentially problematic.</p>",
        "id": 256483378,
        "sender_full_name": "Connor Horman",
        "timestamp": 1633553845
    },
    {
        "content": "<p>(I have something similar to this in my SNES-Dev rust support library, which will hopefully become relevant at some point in the not-hugely-far future)</p>",
        "id": 256483693,
        "sender_full_name": "Connor Horman",
        "timestamp": 1633553978
    },
    {
        "content": "<p>You should not use references or statics with MMIO in the first place.</p>",
        "id": 256508032,
        "sender_full_name": "Lokathor",
        "timestamp": 1633568515
    },
    {
        "content": "<p>I believe the problem there lies around our semantics with <code>UnsafeCell</code> -- either we should not expect to be able to dereference such a thing, or we should have a new type.</p>",
        "id": 256559700,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1633605095
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Attribute.20for.20trusted.20external.20static.20declara.E2.80.A6.20lang-team.23118/near/256508032\">said</a>:</p>\n<blockquote>\n<p>You should not use references or statics with MMIO in the first place.</p>\n</blockquote>\n<p>I want to use statics as I refuse to ever hardcode an address, and cast that to a raw pointer. Magic Addresses are, imo, stupid.</p>",
        "id": 256561893,
        "sender_full_name": "Connor Horman",
        "timestamp": 1633606301
    },
    {
        "content": "<p>(I also have some symbols that can float in the address space, so hardcoding addresses is entirely impossible)</p>",
        "id": 256562184,
        "sender_full_name": "Connor Horman",
        "timestamp": 1633606460
    },
    {
        "content": "<p>Uhh... Interesting.</p>\n<p>I guess what I'll say is that I'm a GBA programmer in Rust, which lead me to make the <code>voladdress</code> crate, which the <code>volatile</code> crate is updating to be more like. So I've got some experience with MMIO, but not on all possible devices. I totally might be missing some context that applies to your situation with the SNES. That said, my experience has been that Rust already allows for the creation of safe and easy to use abstractions over MMIO operations. Those abstractions simply do not involve direct references to MMIO locations.</p>\n<p>You say that you don't want to hardcode an address, that you want to use a static instead. Except that a static <em>has</em> a hardcoded address, just one given by the linker instead of by a line in source code. So using a static already seems to go against what you want to do. If you use a static UnsafeCell you still end up with a raw pointer that you have to use, and the pointer's address value is magical value that was assigned by the linker.</p>",
        "id": 256583322,
        "sender_full_name": "Lokathor",
        "timestamp": 1633615723
    },
    {
        "content": "<blockquote>\n<p>You say that you don't want to hardcode an address, that you want to use a static instead. Except that a static has a hardcoded address, just one given by the linker instead of by a line in source code. So using a static already seems to go against what you want to do. If you use a static UnsafeCell you still end up with a raw pointer that you have to use, and the pointer's address value is magical value that was assigned by the linker.</p>\n</blockquote>\n<p>In the linker, I sort of have to, but I have more flexibility. That being said, my general issue is specifically hardcoding addresses that are then used to invent pointers. It also gives me flexibility. With certain extended mapping techniques, as I said, some of the symbols I can reference don't have a fixed address, and this allows the linker to pick the best location for those symbols, based on where it needs to layout out other sections and, (with more advanced optimization techniques) based on accesses (So common uses of the symbols can be put in the same bank as the symbol). The <code>_FaultCode</code> symbol is actually one of these addresses - it's controlled by the cartridge, but has special handling.</p>",
        "id": 256593389,
        "sender_full_name": "Connor Horman",
        "timestamp": 1633619185
    },
    {
        "content": "<p>FWIW, with <code>#[feature(linkage)]</code>, one can already write the following:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[apply(my_extern!)]</span><span class=\"w\"></span>\n<span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"s\">\"volatile\"</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">static</span><span class=\"w\"> </span><span class=\"n\">X</span>: <span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"w\"> </span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">X</span><span class=\"p\">.</span><span class=\"n\">read</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">X</span><span class=\"p\">.</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"mi\">42</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">X</span><span class=\"p\">.</span><span class=\"n\">read</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">X</span><span class=\"p\">.</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<ul>\n<li><a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=release&amp;edition=2018&amp;gist=fdd8782fb96cd8f0b1413ecd24806828\">Playground</a> (I've inlined a very basic (not even no-null!) polyfill of a <code>VolAddress</code> there; assume it's rather something like <span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span>'s in there)</li>\n</ul>\n<p>which yields:</p>\n<div class=\"codehilite\" data-code-language=\"GAS\"><pre><span></span><code><span class=\"nl\">main:</span> <span class=\"c1\"># @playground::main</span>\n    <span class=\"nf\">movq</span>    <span class=\"no\">X@GOTPCREL</span><span class=\"p\">(</span><span class=\"nv\">%rip</span><span class=\"p\">),</span> <span class=\"nv\">%rax</span>\n    <span class=\"nf\">movb</span>    <span class=\"p\">(</span><span class=\"nv\">%rax</span><span class=\"p\">),</span> <span class=\"nv\">%cl</span>\n    <span class=\"nf\">movb</span>    <span class=\"no\">$42</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"nv\">%rax</span><span class=\"p\">)</span>\n    <span class=\"nf\">movb</span>    <span class=\"p\">(</span><span class=\"nv\">%rax</span><span class=\"p\">),</span> <span class=\"nv\">%cl</span>\n    <span class=\"nf\">movb</span>    <span class=\"no\">$0</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"nv\">%rax</span><span class=\"p\">)</span>\n    <span class=\"nf\">retq</span>\n</code></pre></div>",
        "id": 256601054,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1633621786
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Attribute.20for.20trusted.20external.20static.20declara.E2.80.A6.20lang-team.23118/near/256314918\">said</a>:</p>\n<blockquote>\n<p>If the type is a fully opaque handle, what would that assumption mean?</p>\n</blockquote>\n<p>not sure what a 'fully opaque handle' is in technical terms, but it would still mean all the memory the reference points to (as determined by the size of the pointee) must not be mutated between any two accesses of a shared reference.</p>",
        "id": 256674933,
        "sender_full_name": "RalfJ",
        "timestamp": 1633656052
    },
    {
        "content": "<p>What would go wrong, in practice, if there were interior mutability that Rust didn't know about?</p>\n<p>Also, does that apply if the object itself is just a pointer, and what gets mutated is what it points to?</p>",
        "id": 256677955,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1633658733
    },
    {
        "content": "<p>(or, for that matter, if it isn't sized and the layout of the object it references isn't known to Rust)</p>",
        "id": 256678044,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1633658801
    },
    {
        "content": "<p>Cross language LTO, for example, could mean that Rust's application of attributes indicating immutability, for example, could carry into C/C++ and cause UB there, I suppose. I think we've seen this with function arguments in ffi.</p>\n<p>I wouldn't expect this to carry through a raw pointer</p>",
        "id": 256678437,
        "sender_full_name": "simulacrum",
        "timestamp": 1633659164
    },
    {
        "content": "<blockquote>\n<p>What would go wrong, in practice, if there were interior mutability that Rust didn't know about?</p>\n</blockquote>\n<p>Rust is allowed to optimize code like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">val1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"n\">foo</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">val2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>to make the last line <code>let val2 = val1</code>. Not sure if such code can arise here though.</p>\n<blockquote>\n<p>does that apply if the object itself is just a pointer, and what gets mutated is what it points to?</p>\n</blockquote>\n<p>in my current proposals, aliasing guarantees are 'shallow', so an <code>&amp;T</code> just means the <code>T</code> cannot be mutated, but it doesnt matter what <code>T</code> points to. One can imagine other proposals, but if <code>T</code> is a raw ptr type then aliasing guarantees definitely stop.<br>\nbut that just means that <code>extern static FOO: *mut T</code> is okay to be a ptr to mutable memory, but <code>FOO</code> itself remains readonly.</p>\n<blockquote>\n<p>(or, for that matter, if it isn't sized and the layout of the object it references isn't known to Rust)</p>\n</blockquote>\n<p>that makes it hard to come up with concrete counterexamples, but I also dont think we should say in the spec that the Rust aliasing guarantees have some weird interaction with whether a type is sized or not. That would be a very surprising interactions of language features that have no right of interacting in any way, IMO.</p>",
        "id": 257301662,
        "sender_full_name": "RalfJ",
        "timestamp": 1634092819
    },
    {
        "content": "<p>and on that last point, I also dont think <code>static FOO: T</code> and <code>extern static FOO: T</code> should behave any different in terms of aliasing guarantees -- again, that would be an interaction of language features that ought to be orthogonal. And I assume there is widespread consensus that the former is read-only except for interior mutability.</p>",
        "id": 257301754,
        "sender_full_name": "RalfJ",
        "timestamp": 1634092917
    },
    {
        "content": "<p>RFC Draft, I'll make the full PR for it some time later if there's no major problems: <a href=\"https://hackmd.io/@Lokathor/Sk-RXL_PK\">https://hackmd.io/@Lokathor/Sk-RXL_PK</a></p>",
        "id": 260852870,
        "sender_full_name": "Lokathor",
        "timestamp": 1636488236
    },
    {
        "content": "<p>I think it would be useful to include at least some discussion of the guarantees needed for unsafe access</p>",
        "id": 260853679,
        "sender_full_name": "simulacrum",
        "timestamp": 1636488608
    },
    {
        "content": "<p>In particular, I'm not clear if:</p>\n<blockquote>\n<p>If the linked data does not match the type you declared then there’s no possible safe way to use that declaration, and the entire program needs to be recompiled with a correct definition.</p>\n</blockquote>\n<p>is actually true (in the sense of being sufficient). The current reference at least gestures in the direction that your program is simply UB if this occurs (in-program access or not).</p>\n<blockquote>\n<p>An immutable static must be initialized before any Rust code is executed. It is not enough for the static to be initialized before Rust code reads from it.</p>\n</blockquote>\n<p>I don't think it would be a breaking change -- if this is true -- to just treat extern statics as safe, right? (Just new unsafe code unused lints).</p>",
        "id": 260853808,
        "sender_full_name": "simulacrum",
        "timestamp": 1636488691
    },
    {
        "content": "<p>I think this was the major question raised in the discussion so far as part of the MCP.</p>",
        "id": 260853905,
        "sender_full_name": "simulacrum",
        "timestamp": 1636488733
    },
    {
        "content": "<p>To your second question:</p>\n<ul>\n<li>If you access an extern using the wrong definition then the program is UB (excepting some edge cases where you access say a u16 instead of the full u32 or something, which we probably don't need to worry about).</li>\n<li>If you declare an extern wrong and then <em>don't use it at all</em>, the program is likely not actually UB.</li>\n</ul>",
        "id": 260854313,
        "sender_full_name": "Lokathor",
        "timestamp": 1636488952
    },
    {
        "content": "<p>Actually, I suppose we might say that the access is UB, which if the access is only conditional in some way makes the program only conditionally UB.</p>",
        "id": 260854480,
        "sender_full_name": "Lokathor",
        "timestamp": 1636489031
    },
    {
        "content": "<p>IMO the reference today implies otherwise -- right? That is, \"An immutable static must be initialized before any Rust code is executed. It is not enough for the static to be initialized before Rust code reads from it.\" implies to me that <em>just declaring</em> an immutable static which is modified by C (with no uses in Rust) is UB.</p>",
        "id": 260854529,
        "sender_full_name": "simulacrum",
        "timestamp": 1636489055
    },
    {
        "content": "<p>Which might be observable through - for example - cross-lang LTO or some such.</p>",
        "id": 260854558,
        "sender_full_name": "simulacrum",
        "timestamp": 1636489072
    },
    {
        "content": "<p>e.g., Box has this language:</p>\n<blockquote>\n<p>Important. At least at present, you should avoid using <code>Box&lt;T&gt;</code> types for functions that are defined in C but invoked from Rust. In those cases, you should directly mirror the C types as closely as possible. Using types like <code>Box&lt;T&gt;</code> where the C definition is just using <code>T*</code> can lead to undefined behavior, as described in <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/198\">rust-lang/unsafe-code-guidelines#198</a>.</p>\n</blockquote>",
        "id": 260854766,
        "sender_full_name": "simulacrum",
        "timestamp": 1636489158
    },
    {
        "content": "<p>which is sort of similar in spirit</p>",
        "id": 260854787,
        "sender_full_name": "simulacrum",
        "timestamp": 1636489168
    },
    {
        "content": "<p>Sure, but that's if you access it.</p>\n<p>If you declare the invalid extern and <em>never</em> access it then I can't imagine how the declaration alone could possibly affect the program's validity. The same as you can declare an extern fn to something that doesn't exist, and there's no link error if you end up not using that function call.</p>",
        "id": 260854799,
        "sender_full_name": "Lokathor",
        "timestamp": 1636489173
    },
    {
        "content": "<p>Because the mere declaration (with e.g. cross-lang LTO) can cause C code to now have UB, if you get the declaration wrong</p>",
        "id": 260854853,
        "sender_full_name": "simulacrum",
        "timestamp": 1636489202
    },
    {
        "content": "<p>So I'm not actually sure access on the Rust side is presently required.</p>",
        "id": 260854946,
        "sender_full_name": "simulacrum",
        "timestamp": 1636489229
    },
    {
        "content": "<p>I don't think I know how cross-lang LTO could have an effect.</p>\n<p>Are you saying the compiler would see the C code accessing its FOO and then see the Rust definition of FOO and replace the C definition with the rust definition?</p>",
        "id": 260855177,
        "sender_full_name": "Lokathor",
        "timestamp": 1636489326
    },
    {
        "content": "<p>Well, more like, add the attributes</p>",
        "id": 260855230,
        "sender_full_name": "simulacrum",
        "timestamp": 1636489349
    },
    {
        "content": "<p>but sure, yeah</p>",
        "id": 260855270,
        "sender_full_name": "simulacrum",
        "timestamp": 1636489368
    },
    {
        "content": "<p>If the mere declaration of an inaccurate static can cause UB, then we can just stop requiring the unsafe blocks right now.</p>",
        "id": 260855293,
        "sender_full_name": "Lokathor",
        "timestamp": 1636489377
    },
    {
        "content": "<p>And that might be the case, for all I know, i'm no compiler expert here</p>",
        "id": 260855324,
        "sender_full_name": "Lokathor",
        "timestamp": 1636489388
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/198\">https://github.com/rust-lang/unsafe-code-guidelines/issues/198</a> is basically the non-static version of this that doesn't even require FFI or LTO</p>",
        "id": 260855374,
        "sender_full_name": "simulacrum",
        "timestamp": 1636489417
    },
    {
        "content": "<p>(but I think it applies equally here)</p>",
        "id": 260855520,
        "sender_full_name": "simulacrum",
        "timestamp": 1636489474
    },
    {
        "content": "<p>basically, I think we probably can make a reasonable argument for just dropping unsafe blocks, and it seems the <em>better</em> argument to make, IMO</p>",
        "id": 260855657,
        "sender_full_name": "simulacrum",
        "timestamp": 1636489545
    },
    {
        "content": "<p>Well, if gnzlbg is correct (and they usually are), then extern blocks themselves are <em>already</em> unsafe, we just didn't understand/document that to be the case.</p>",
        "id": 260855658,
        "sender_full_name": "Lokathor",
        "timestamp": 1636489547
    },
    {
        "content": "<p>so i would agree with you, just drop the unsafe block requirement for extern statics</p>",
        "id": 260855797,
        "sender_full_name": "Lokathor",
        "timestamp": 1636489609
    },
    {
        "content": "<p>and further, we'd probably want some stronger language in the reference about how closely extern blocks need to match the literal C definition</p>",
        "id": 260855831,
        "sender_full_name": "Lokathor",
        "timestamp": 1636489633
    },
    {
        "content": "<p>(because I myself also use 'richer types' in my extern C declarations, and if that's bad, then big whoops)</p>",
        "id": 260855928,
        "sender_full_name": "Lokathor",
        "timestamp": 1636489682
    },
    {
        "content": "<p>Right.</p>",
        "id": 260855998,
        "sender_full_name": "simulacrum",
        "timestamp": 1636489700
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Attribute.20for.20trusted.20external.20static.20declara.E2.80.A6.20lang-team.23118/near/260854799\">said</a>:</p>\n<blockquote>\n<p>Sure, but that's if you access it.</p>\n<p>If you declare the invalid extern and <em>never</em> access it then I can't imagine how the declaration alone could possibly affect the program's validity. The same as you can declare an extern fn to something that doesn't exist, and there's no link error if you end up not using that function call.</p>\n</blockquote>\n<p>the compiler is allowed to insert loads from unused shared references in the program. it is not a stretch to say that it can also insert loads from other unused shared places, such as statics.</p>",
        "id": 260886637,
        "sender_full_name": "RalfJ",
        "timestamp": 1636506375
    },
    {
        "content": "<p>so for example, the compiler might be allowed to hoist the access out of the loop:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">while</span><span class=\"w\"> </span><span class=\"n\">something</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">EXTERN_STATIC</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>now if <code>something()</code> happens to return <code>false</code>, loop hoisting introduces a read where there was none.<br>\ntherefore even unused statics must follow Rust's aliasing discipline.</p>",
        "id": 260886734,
        "sender_full_name": "RalfJ",
        "timestamp": 1636506460
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Attribute.20for.20trusted.20external.20static.20declara.E2.80.A6.20lang-team.23118/near/260855657\">said</a>:</p>\n<blockquote>\n<p>basically, I think we probably can make a reasonable argument for just dropping unsafe blocks, and it seems the <em>better</em> argument to make, IMO</p>\n</blockquote>\n<p>uh... that doesn't seem like a good idea to me, it makes the unsafe way too implicit.<br>\nI would support something like <code>unsafe extern \"C\"</code> blocks. but the functions imported there should IMO still be unsafe to call, making a promise at the <em>declaration site</em> about <em>all use sites</em> seems way too non-local. during code review a new use of such a function could easily be introduced and there is no local indication that careful checking is required.<br>\nthe same argument also applies to statics, of course, which is why I am somewhat wary of this entire proposal.</p>",
        "id": 260886896,
        "sender_full_name": "RalfJ",
        "timestamp": 1636506587
    },
    {
        "content": "<p>I think it's the case for functions because C functions at least typically <em>are</em> unsafe to call</p>",
        "id": 260888183,
        "sender_full_name": "simulacrum",
        "timestamp": 1636507726
    },
    {
        "content": "<p>But immutable statics presumably are not really unsafe to access</p>",
        "id": 260888205,
        "sender_full_name": "simulacrum",
        "timestamp": 1636507748
    },
    {
        "content": "<p>Since, like, they have to be immutable anyway, and then they're either ok or not is basically how my thinking goes - there's nothing extra at each use site</p>",
        "id": 260888241,
        "sender_full_name": "simulacrum",
        "timestamp": 1636507795
    },
    {
        "content": "<p>(I would be happy to be shown to be wrong, but this is my current understanding)</p>",
        "id": 260888323,
        "sender_full_name": "simulacrum",
        "timestamp": 1636507844
    },
    {
        "content": "<p>If, as a separate extension of this idea, an FFI function were to be unsafely declared then the function would still itself have to be marked unsafe or not based on what it does. winapi::GetProcAddress handles pointers and is unsafe, but libm::sqrt just uses an f32 and so is safe. This is actually already in the rfc draft as a future extension.</p>\n<p>however i do not want to discuss the FFI calls part that much until <strong>after</strong> the statics part is resolved.</p>",
        "id": 260998878,
        "sender_full_name": "Lokathor",
        "timestamp": 1636555302
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Attribute.20for.20trusted.20external.20static.20declara.E2.80.A6.20lang-team.23118/near/260998878\">said</a>:</p>\n<blockquote>\n<p>If, as a separate extension of this idea, an FFI function were to be unsafely declared then the function would still itself have to be marked unsafe or not based on what it does. winapi::GetProcAddress handles pointers and is unsafe, but libm::sqrt just uses an f32 and so is safe. This is actually already in the rfc draft as a future extension.</p>\n<p>however i do not want to discuss the FFI calls part that much until <strong>after</strong> the statics part is resolved.</p>\n</blockquote>\n<p>Indeed. I've written so many safety comments like</p>\n<div class=\"codehilite\"><pre><span></span><code>// SAFETY: *relevant standard here* does not prescribe any undefined behaviour for *function*\n</code></pre></div>\n<p>I'd ideally to not have to copy that text to a bunch of ffi calls, ideally</p>",
        "id": 261001124,
        "sender_full_name": "Connor Horman",
        "timestamp": 1636556164
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Attribute.20for.20trusted.20external.20static.20declara.E2.80.A6.20lang-team.23118/near/260998878\">said</a>:</p>\n<blockquote>\n<p>If, as a separate extension of this idea, an FFI function were to be unsafely declared then the function would still itself have to be marked unsafe or not based on what it does. winapi::GetProcAddress handles pointers and is unsafe, but libm::sqrt just uses an f32 and so is safe. This is actually already in the rfc draft as a future extension.</p>\n<p>however i do not want to discuss the FFI calls part that much until <strong>after</strong> the statics part is resolved.</p>\n</blockquote>\n<p>What would be the right place to discuss this? I have some thoughts on it</p>",
        "id": 261004635,
        "sender_full_name": "Jake",
        "timestamp": 1636557661
    },
    {
        "content": "<p>uh, a new thread in the general t-lang stream, i guess?</p>",
        "id": 261005513,
        "sender_full_name": "Lokathor",
        "timestamp": 1636557972
    },
    {
        "content": "<p>To be honest, the current situation feels very weird to me. I strongly agree with Ralf and whoever said that it seems that either all accesses to a static are correct or none of them are (sidenote: what does this mean if there are no accesses, even in dead code?). Is this the problem that this RFC is looking to solve? If so, I'd definitely like to see some alternatives, and will start by suggesting this:</p>\n<ol>\n<li>Make accesses to immutable extern statics (by that I mean extern statics that are neither <code>static mut</code> nor <code>UnsafeCell</code>) safe</li>\n<li>Make the declaration of such statics <code>unsafe_code</code></li>\n<li>Adjust whatever documentation is needed to make the last part clear to everyone.</li>\n</ol>\n<p>Of course, the second item would be a breaking change; there's a number of mediating factors for that though: a) I don't expect there to be many crates that deny <code>unsafe_code</code> but also declare an extern static (maybe I'm wrong about this, please let me know) b) this could be justified as a soundness fix, and c) its probably possible to do 2 across an edition boundary (with an appropriate warning now) if we want to avoid breaking code that might be technically unsound but is probably not actually causing UB</p>",
        "id": 261016143,
        "sender_full_name": "Jake",
        "timestamp": 1636562236
    },
    {
        "content": "<p>Another way of looking at this is that it seems that if we do add the attribute, the guarantees around it are basically \"you're not required to add this attribute, but it is actually correct to add it in all code that is not already UB\" which I'm not a huge fan of</p>",
        "id": 261017032,
        "sender_full_name": "Jake",
        "timestamp": 1636562625
    },
    {
        "content": "<p>Even if we end up deciding to not do anything like this because the guarantees that this implies are not the ones we want (this seems to be what Josh was saying) then I still think we should avoid making a change like the one proposed here until we've actually decided what the desired guarantees are</p>",
        "id": 261021611,
        "sender_full_name": "Jake",
        "timestamp": 1636564387
    },
    {
        "content": "<blockquote>\n<p>is this the problem that the RFC is looking to solve?</p>\n</blockquote>\n<p>yes.</p>",
        "id": 261029516,
        "sender_full_name": "Lokathor",
        "timestamp": 1636567509
    },
    {
        "content": "<p>and the new attribute is a way to slowly move the world into what you list as option 2.</p>",
        "id": 261029611,
        "sender_full_name": "Lokathor",
        "timestamp": 1636567556
    },
    {
        "content": "<p>I would prefer to not have an attribute and move to having it be the assumed default in a future edition, which is covered in the Future Possibilities portion of the draft.</p>",
        "id": 261029925,
        "sender_full_name": "Lokathor",
        "timestamp": 1636567652
    },
    {
        "content": "<p>if you haven't read all the way through the draft rfc, please do so.</p>",
        "id": 261030080,
        "sender_full_name": "Lokathor",
        "timestamp": 1636567704
    },
    {
        "content": "<p>I realize I was unclear. The list I gave was supposed to be a \"do all of\" type thing, not \"do some of.\" I'll edit to clarify in just a second.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Attribute.20for.20trusted.20external.20static.20declara.E2.80.A6.20lang-team.23118/near/261029611\">said</a>:</p>\n<blockquote>\n<p>and the new attribute is a way to slowly move the world into what you list as option 2.</p>\n</blockquote>\n<p>The discussion above (at least the version of things that Ralf proposed) seems to indicate that we are in that world already though. In particular, the second point is supposed to be a change for the <code>unsafe_code</code> lints to match the existing semantics of the language, not an actual change to the language. In other words, I am interpreting things as: The current situation is that declaring the type of an extern static to be non-mutable when it actually is is <em>already UB in Rust today</em>, and my suggestion is to fix a number of things to align more closely with that reality. If this is not the case (as it indeed may not be), then I don't think it makes much sense to have such an attribute if the actual semantics of extern statics (as related to mutability) are not yet clear.</p>",
        "id": 261032266,
        "sender_full_name": "Jake",
        "timestamp": 1636568454
    },
    {
        "content": "<p>It is most likely already the case that an incorrect declaration can cause UB, and thus it should be <code>unsafe</code> to even make the declaration, yes.</p>\n<p>If so, we could accept the situation and update the docs and lang.</p>\n<p>Alternately we could try to make sure that LLVM and all other backends will never miscompile from simply an mismatch in declaration. That seems like a taller order though, honestly.</p>",
        "id": 261032933,
        "sender_full_name": "Lokathor",
        "timestamp": 1636568700
    },
    {
        "content": "<blockquote>\n<p>if so, we could accept the situation and update the docs and lang.</p>\n</blockquote>\n<p>I believe this is what I am proposing</p>",
        "id": 261033555,
        "sender_full_name": "Jake",
        "timestamp": 1636568955
    },
    {
        "content": "<p>If we do not go this route, then I would like to see an example of a case where it is not correct for rustc to simply assume the suggested new attribute. If such a case does not exist, then I do not see what value the additional attribute provides</p>",
        "id": 261034169,
        "sender_full_name": "Jake",
        "timestamp": 1636569197
    },
    {
        "content": "<p>won't that cause huge breakage? A less aggressive form of 2 is to make the declarations \"unsafe\" without adding any required text to the declaration itself, only making them illegal when <code>deny(unsafe_code)</code> is in effect</p>",
        "id": 261034422,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636569286
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Attribute.20for.20trusted.20external.20static.20declara.E2.80.A6.20lang-team.23118/near/261034422\">said</a>:</p>\n<blockquote>\n<p>won't that cause huge breakage? A less aggressive form of 2 is to make the declarations \"unsafe\" without adding any required text to the declaration itself, only making them illegal when <code>deny(unsafe_code)</code> is in effect</p>\n</blockquote>\n<p>Oh yeah, that is what I am suggesting. I'll go edit to clarify some more</p>",
        "id": 261034563,
        "sender_full_name": "Jake",
        "timestamp": 1636569349
    },
    {
        "content": "<p>although, that change on its own is not great since it means that lots of extern statics are getting grandfathered in to an invisible unsafe block without review</p>",
        "id": 261034807,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636569448
    },
    {
        "content": "<p>the attribute, at least, provides a time for the review to take place</p>",
        "id": 261035019,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636569517
    },
    {
        "content": "<p>The discussion above indicates that this is what they already are and always were. In other words, the breakage here  is not that stuff which didn't used to be unsafe is now unsafe, but rather that stuff which used to be unsafe but didn't lint as such now also lints as such. There may be alternatives, but there does not seem to be any agreement on what the semantics of such alternatives would actually be</p>",
        "id": 261035271,
        "sender_full_name": "Jake",
        "timestamp": 1636569622
    },
    {
        "content": "<p>sure, but this was not effectively communicated when the various extern statics in the world were written. They probably need more review now that their status is changing</p>",
        "id": 261035793,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636569849
    },
    {
        "content": "<p>Their status is not really changing, is ultimately the thing.</p>\n<p>if they were broken before they stay broken, if they were actually fine before they're still actually fine. We didn't communicate the requirements properly in the past, but that doesn't mean the actual requirements are changing in any way.</p>",
        "id": 261036463,
        "sender_full_name": "Lokathor",
        "timestamp": 1636570166
    },
    {
        "content": "<p>I agree with Jake that not having the attribute is really the better long term solution. However, as a fix for current-edition, i think an attribute could be an appropriate transitional solution</p>",
        "id": 261036674,
        "sender_full_name": "Lokathor",
        "timestamp": 1636570240
    },
    {
        "content": "<p>I do see an argument here in favor of the existence of such an attribute, but I think its role should be clarified in that case. If we interpret the attribute to mean \"this code has been written after the clarification of immutable statics and was reviewed to ensure it meets the requirements,\" then this seems reasonable. In that case though immutable extern static declarations, with or without the attribute, should still lint as <code>unsafe_code</code>, since that is still what they are.</p>",
        "id": 261037340,
        "sender_full_name": "Jake",
        "timestamp": 1636570532
    },
    {
        "content": "<p>Also, this is probably a bad idea, but at least worth considering: Not including this attribute issues a warning. This has the downside of suddenly issuing a lot of warnings (almost certainly way disproportionately to the rate at which there's actual UB), but it is in principle \"correct\" in that new code should never declare an extern static without including the attribute.</p>",
        "id": 261037774,
        "sender_full_name": "Jake",
        "timestamp": 1636570729
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Attribute.20for.20trusted.20external.20static.20declara.E2.80.A6.20lang-team.23118/near/260888241\">said</a>:</p>\n<blockquote>\n<p>Since, like, they have to be immutable anyway, and then they're either ok or not is basically how my thinking goes - there's nothing extra at each use site</p>\n</blockquote>\n<p>they could be interior mutable</p>",
        "id": 261206568,
        "sender_full_name": "RalfJ",
        "timestamp": 1636685242
    },
    {
        "content": "<p>I think any interior mutability would still have clear safety conditions (i.e., the same ones as on a regular Rust static with the same interior mutability).</p>",
        "id": 261206663,
        "sender_full_name": "simulacrum",
        "timestamp": 1636685347
    },
    {
        "content": "<p>but there is something extra at each use site -- the value must actually be of the given type</p>",
        "id": 261206675,
        "sender_full_name": "RalfJ",
        "timestamp": 1636685387
    },
    {
        "content": "<p>so I dont see how statics are fundamentally less problematic than function calls</p>",
        "id": 261206683,
        "sender_full_name": "RalfJ",
        "timestamp": 1636685398
    },
    {
        "content": "<p>you mean since the compiler can't otherwise manufacture reads into UnsafeCell?</p>",
        "id": 261206732,
        "sender_full_name": "simulacrum",
        "timestamp": 1636685417
    },
    {
        "content": "<p>that was meant just each time the value is read</p>",
        "id": 261206744,
        "sender_full_name": "RalfJ",
        "timestamp": 1636685444
    },
    {
        "content": "<p>since it can change</p>",
        "id": 261206747,
        "sender_full_name": "RalfJ",
        "timestamp": 1636685446
    },
    {
        "content": "<p>so it's kind of like calling a function <code>fn() -&gt; T</code></p>",
        "id": 261206750,
        "sender_full_name": "RalfJ",
        "timestamp": 1636685455
    },
    {
        "content": "<p>sure we avoid all the UB that running the function may cause on the C side, but we still have all the UB that might arise from the value not actually being a <code>T</code></p>",
        "id": 261206771,
        "sender_full_name": "RalfJ",
        "timestamp": 1636685498
    },
    {
        "content": "<p>(plus potential UB due to data races)</p>",
        "id": 261206823,
        "sender_full_name": "RalfJ",
        "timestamp": 1636685535
    },
    {
        "content": "<p>I guess it's true that the static may not have type T, and we could say that it's OK to have <code>extern { static FOO: UnsafeCell&lt;NonZeroU64&gt;; }</code> that sometimes is zero but is externally known to be non-zero when actually read by Rust -- but it also seems like the same can maybe be said of a regular rust static with the same type?</p>",
        "id": 261206911,
        "sender_full_name": "simulacrum",
        "timestamp": 1636685680
    },
    {
        "content": "<p>IOW, the interior mutability does not actually add anything special because it's in an extern static -- it's always not valid to \"speculate\" it as being of type T (e.g., niches etc should not in theory pass through unsafecell)</p>",
        "id": 261206940,
        "sender_full_name": "simulacrum",
        "timestamp": 1636685728
    },
    {
        "content": "<blockquote>\n<p>IOW, the interior mutability does not actually add anything special because it's in an extern static</p>\n</blockquote>\n<p>the special thing is that it is accessible to C code <span aria-label=\"scream\" class=\"emoji emoji-1f631\" role=\"img\" title=\"scream\">:scream:</span></p>",
        "id": 261207146,
        "sender_full_name": "RalfJ",
        "timestamp": 1636685992
    },
    {
        "content": "<p>whereas with a regular rust static the compiler will do whatever it can to ensure no wrong value is ever written there</p>",
        "id": 261207238,
        "sender_full_name": "RalfJ",
        "timestamp": 1636686020
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Attribute.20for.20trusted.20external.20static.20declara.E2.80.A6.20lang-team.23118/near/261206940\">said</a>:</p>\n<blockquote>\n<p>IOW, the interior mutability does not actually add anything special because it's in an extern static -- it's always not valid to \"speculate\" it as being of type T (e.g., niches etc should not in theory pass through unsafecell)</p>\n</blockquote>\n<p>for immutable statics that should be totally valid IMO</p>",
        "id": 261207268,
        "sender_full_name": "RalfJ",
        "timestamp": 1636686048
    },
    {
        "content": "<p>er, maybe my parens are off or something</p>",
        "id": 261207280,
        "sender_full_name": "simulacrum",
        "timestamp": 1636686066
    },
    {
        "content": "<p>I meant that it's never valid to speculate as type T for interior mutability</p>",
        "id": 261207286,
        "sender_full_name": "simulacrum",
        "timestamp": 1636686078
    },
    {
        "content": "<p>(and niches passing through Cell is fine in principle I think, at least I dont know a counterexample -- though we probably still want to block them, that was certainly the intent when the change for unsafecell niches landed)</p>",
        "id": 261207298,
        "sender_full_name": "RalfJ",
        "timestamp": 1636686097
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Attribute.20for.20trusted.20external.20static.20declara.E2.80.A6.20lang-team.23118/near/261207286\">said</a>:</p>\n<blockquote>\n<p>I meant that it's never valid to speculate as type T for interior mutability</p>\n</blockquote>\n<p>ah I see. for data shared across threads this is definitely true because a speculative read might race.</p>\n<p>but I also think that for interior mutability we dont even need to invoke speculation to show that only marking the declaration site as unsafe is insufficient -- every actual read site asserts that at the time of the read, whatever the current value is, it is a valid T.</p>",
        "id": 261207425,
        "sender_full_name": "RalfJ",
        "timestamp": 1636686211
    },
    {
        "content": "<p><code>static FOO: UnsafeCell&lt;NonZeroU64&gt;;</code> in regular Rust code I'd expect to be able to temporarily initialize to zero, if you write to it through <code>*mut u64</code> for example -- so long as you never read that value at type NonZeroU64. but maybe this conflicts with something...</p>\n<p>it seems like if the model is that internally mutable statics are <code>fn() -&gt; T</code> for extern statics the same should be true of Rust statics, too, in some sense.</p>",
        "id": 261207429,
        "sender_full_name": "simulacrum",
        "timestamp": 1636686223
    },
    {
        "content": "<blockquote>\n<p>but I also think that for interior mutability we dont even need to invoke speculation to show that only marking the declaration site as unsafe is insufficient -- every actual read site asserts that at the time of the read, whatever the current value is, it is a valid T.</p>\n</blockquote>\n<p>Right, but that's specific to the interior mutability -- if I choose <code>Cell&lt;u64&gt;</code>, then reading/writing is safe (and presumably that can just be a <code>u64</code> in C-land)</p>",
        "id": 261207492,
        "sender_full_name": "simulacrum",
        "timestamp": 1636686294
    },
    {
        "content": "<p>and I'd expect that to be OK</p>",
        "id": 261207508,
        "sender_full_name": "simulacrum",
        "timestamp": 1636686312
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Attribute.20for.20trusted.20external.20static.20declara.E2.80.A6.20lang-team.23118/near/261207429\">said</a>:</p>\n<blockquote>\n<p><code>static FOO: UnsafeCell&lt;NonZeroU64&gt;;</code> in regular Rust code I'd expect to be able to temporarily initialize to zero, if you write to it through <code>*mut u64</code> for example -- so long as you never read that value at type NonZeroU64. but maybe this conflicts with something...</p>\n<p>it seems like if the model is that internally mutable statics are <code>fn() -&gt; T</code> for extern statics the same should be true of Rust statics, too, in some sense.</p>\n</blockquote>\n<p>That looks a lot what's being talked about in <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability\">this unsafe-code-guidelines</a> thread.</p>",
        "id": 261207514,
        "sender_full_name": "Connor Horman",
        "timestamp": 1636686318
    },
    {
        "content": "<p>hm I see where you are coming from. I am trying to see why this feels very different for me and I think the reason is that with a <code>static</code> I think of that other code being Rust code, so if it temporarily puts a 0 somewhere it is already <code>unsafe</code>. whereas with <code>extern static</code> it is C code that might not even know that putting a 0 there is in any way risky.</p>",
        "id": 261207516,
        "sender_full_name": "RalfJ",
        "timestamp": 1636686319
    },
    {
        "content": "<p>for sure</p>",
        "id": 261207523,
        "sender_full_name": "simulacrum",
        "timestamp": 1636686335
    },
    {
        "content": "<p>but that's sort of \"the price of C\"</p>",
        "id": 261207531,
        "sender_full_name": "simulacrum",
        "timestamp": 1636686355
    },
    {
        "content": "<p>I'm not sure we gain anything by asserting at each use site, personally.</p>",
        "id": 261207572,
        "sender_full_name": "simulacrum",
        "timestamp": 1636686369
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Attribute.20for.20trusted.20external.20static.20declara.E2.80.A6.20lang-team.23118/near/261207516\">said</a>:</p>\n<blockquote>\n<p>hm I see where you are coming from. I am trying to see why this feels very different for me and I think the reason is that with a <code>static</code> I think of that other code being Rust code, so if it temporarily puts a 0 somewhere it is already <code>unsafe</code>. whereas with <code>extern static</code> it is C code that might not even know that putting a 0 there is in any way risky.</p>\n</blockquote>\n<p>To be fair, this is true of a lot of FFI things.</p>",
        "id": 261207581,
        "sender_full_name": "Connor Horman",
        "timestamp": 1636686385
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Attribute.20for.20trusted.20external.20static.20declara.E2.80.A6.20lang-team.23118/near/261207492\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>but I also think that for interior mutability we dont even need to invoke speculation to show that only marking the declaration site as unsafe is insufficient -- every actual read site asserts that at the time of the read, whatever the current value is, it is a valid T.</p>\n</blockquote>\n<p>Right, but that's specific to the interior mutability -- if I choose <code>Cell&lt;u64&gt;</code>, then reading/writing is safe (and presumably that can just be a <code>u64</code> in C-land)</p>\n</blockquote>\n<p>reading/writing might still cause a data race. (does <code>extern static</code> have the usual check that the type must be <code>Sync</code>?)</p>",
        "id": 261207596,
        "sender_full_name": "RalfJ",
        "timestamp": 1636686425
    },
    {
        "content": "<p>also, if the C code leaves the static uninit, even a <code>u64</code> static might not be valid at its type</p>",
        "id": 261207622,
        "sender_full_name": "RalfJ",
        "timestamp": 1636686480
    },
    {
        "content": "<p>uninit static is zero-init (in C)</p>",
        "id": 261207667,
        "sender_full_name": "Connor Horman",
        "timestamp": 1636686496
    },
    {
        "content": "<p>So it would be valid for anything that doesn't have zero as a niche.</p>",
        "id": 261207678,
        "sender_full_name": "Connor Horman",
        "timestamp": 1636686512
    },
    {
        "content": "<p>(I guess normal C statics are 0-inited but presumably uninit'ed statics could be created somehow? also they could be de-inited, in principle. and there are other invalid values for u64, potentially, such as ptrs with provenance. so I wouldnt want to get hung up on the idea that some types might have \"no invalid values\" here.)</p>",
        "id": 261207688,
        "sender_full_name": "RalfJ",
        "timestamp": 1636686534
    },
    {
        "content": "<p>anyway I got to go eat something... ttyl</p>",
        "id": 261207712,
        "sender_full_name": "RalfJ",
        "timestamp": 1636686601
    },
    {
        "content": "<p>deiniting isn't possible in C without UB, except for character types.</p>",
        "id": 261207759,
        "sender_full_name": "Connor Horman",
        "timestamp": 1636686616
    },
    {
        "content": "<p>yeah, even if it was, I don't think that would be a deal breaker here -- you're just saying \"this static is going to be valid <code>Cell&lt;u64&gt;</code> by declaring it in Rust.</p>\n<p>Technically I guess that invalidates some patterns (e.g., you could imagine the C code is actually a union between different types but the Rust code only ever reads it when it's in the u64 state), but that doesn't seem particularly common (and potentially the answer there is that you just use some additional combinators like MaybeUninit).</p>",
        "id": 261207858,
        "sender_full_name": "simulacrum",
        "timestamp": 1636686740
    },
    {
        "content": "<p><span class=\"user-group-mention\" data-user-group-id=\"1977\">@T-lang</span>: Proposal <a href=\"https://github.com/rust-lang/lang-team/issues/118#issuecomment-1057269205\">#118</a> has been seconded, and will be approved in 10 days if no objections are raised.</p>",
        "id": 273857985,
        "sender_full_name": "triagebot",
        "timestamp": 1646247163
    }
]