[
    {
        "content": "<p>A new proposal has been announced: <a href=\"https://github.com/rust-lang/lang-team/issues/126\">Positional Associated Types #126</a>. It will be announced at the next meeting to try and draw attention to it, but usually MCPs are not discussed during triage meetings. If you think this would benefit from discussion amongst the team, consider proposing a design meeting.</p>",
        "id": 261202116,
        "sender_full_name": "triagebot",
        "timestamp": 1636679658
    },
    {
        "content": "<p>Hmm, I'm not sure how I feel about this one.  My instinct is that we should get <code>trait Fut&lt;T&gt; = Future&lt;Output=T&gt;;</code> stabilized before considering it.</p>",
        "id": 261202847,
        "sender_full_name": "scottmcm",
        "timestamp": 1636680535
    },
    {
        "content": "<p>Having a PAT on a trait basically means that it would be a breaking change to ever add a generic param (even if the restriction about not allowing PATs and generics was lifted you couldnt add a defaulted param backwards compatibly) That seems like sort of a huge commitment for std (and other crates I guess) to make just to save a bit of typing and because new users might take a while to figure out the difference between generics and associated types.</p>",
        "id": 261203097,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1636680837
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"326176\">@Boxy [she/her]</span> that is the reason for having PATs be opt-in by the trait definition.</p>",
        "id": 261203503,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636681333
    },
    {
        "content": "<p>right, but I'm not sure why you'd ever want to actually opt in</p>",
        "id": 261203513,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1636681351
    },
    {
        "content": "<p>there is very little benefit in exchange for a huge back compatibility promise</p>",
        "id": 261203520,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1636681362
    },
    {
        "content": "<p>I think for a trait like Iterator it is very very unlikely that we will ever want to add additional generics.</p>",
        "id": 261203534,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636681387
    },
    {
        "content": "<p>User traits would probably use this feature less often (if ever). TBH, I'm not even sure if we'd use an attribute for this. And if we did, it might be perma-unstable and only used by core.</p>",
        "id": 261203590,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636681450
    },
    {
        "content": "<p>I do think trait aliases are pretty good solution to this, but they don't really help at all with the toe-stub \"right, I need to type <code>Item=</code>\".  And if anything, increase the mental burden for new users rather than decrease it.</p>",
        "id": 261203739,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636681612
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"222520\">Sam Sartor</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Positional.20Associated.20Types.20lang-team.23126/near/261203590\">said</a>:</p>\n<blockquote>\n<p>User traits would probably use this feature less often (if ever). TBH, I'm not even sure if we'd use an attribute for this. And if we did, it might be perma-unstable and only used by core.</p>\n</blockquote>\n<p>I do actually want to stabilize it, but I have no problem stabilizing the ability to invoke it before the ability to use the attribute yourself.</p>",
        "id": 261241671,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636717831
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Positional.20Associated.20Types.20lang-team.23126/near/261202847\">said</a>:</p>\n<blockquote>\n<p>Hmm, I'm not sure how I feel about this one.  My instinct is that we should get <code>trait Fut&lt;T&gt; = Future&lt;Output=T&gt;;</code> stabilized before considering it.</p>\n</blockquote>\n<p>I would personally prefer <code>Future&lt;T&gt;</code> over <code>Fut&lt;T&gt;</code>; I don't want to have to use an alias.</p>",
        "id": 261241689,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636717851
    },
    {
        "content": "<p>Introducing a layer of indirection, where people look up <code>Fut</code> and see that it's an alias for <code>Future</code> and have to go look up <code>Future</code>, seems suboptimal.</p>",
        "id": 261241726,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636717880
    },
    {
        "content": "<p><span class=\"user-group-mention\" data-user-group-id=\"1977\">@T-lang</span>: Proposal <a href=\"https://github.com/rust-lang/lang-team/issues/126#issuecomment-967042801\">#126</a> has been seconded, and will be approved in 10 days if no objections are raised.</p>",
        "id": 261241748,
        "sender_full_name": "triagebot",
        "timestamp": 1636717897
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"261224\">triagebot</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Positional.20Associated.20Types.20lang-team.23126/near/261241748\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-group-mention silent\" data-user-group-id=\"1977\">T-lang</span>: Proposal <a href=\"https://github.com/rust-lang/lang-team/issues/126#issuecomment-967042801\">#126</a> has been seconded, and will be approved in 10 days if no objections are raised.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> I want to highlight the \"if no objections are raised\" here. I'm seconding this because I'm in favor of it, but we should still talk about it.</p>",
        "id": 261244662,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636719885
    },
    {
        "content": "<p>My own comments about this. First and foremost, I do share the feeling that having to spell out the associated type name can be cumbersome, sometimes, and that some help there. So I support the <em>rationale</em>, the <em>intent</em>. I remain skeptical of the suggest implementation / shape, however.</p>\n<p>There are a reason \"and a half\" for that.</p>\n<ul>\n<li>The \"half reason\" —because it's not really a concrete one, but rather a feeling-based one—, is that I find the syntax conceptually contradictory, in the \"traits are type-level functions\" realm, to go from <code>Iterator: Self -&gt; Item</code> to <code>Iterator: (Self, Item) -&gt; ()</code>. But maybe that's just a first impression, that shall pass, and it's not impossible that I could grow used to it (<em>e.g.</em>, I still have very mixed feelings about <code>match</code> ergonomics, but I have to admit having relied on them, in some proc-macro code, out of sheer Sloth (a capital <code>syn</code>? <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span>)).</li>\n<li>But the above half reason does lead to a more concrete one: it's a form of magic overloading, for the sake of sugar, and we should admit that that's something with which one has to be extremely careful. For instance, I wholeheartedly disagree that this kind of sugar will help beginners; quite the opposite! If the line between a generic parameter and an associated type is blurry for them, then removing the syntactic requirements that tell these two things apart will not help, I suspect: the <em>semantics</em> will remain different! If they see <code>-&gt; impl Iterator&lt;u8&gt;</code>, then it's only a matter of time before they try to write <code>impl Iterator&lt;u8&gt; for …</code> which will fail, and <em>that</em> would be quite inconsistent. Granted, this is only a hunch, and I'd thus be keen on hearing the opinion of ppl who have actual extensive experience in teaching Rust beginners (such as <span class=\"user-mention\" data-user-id=\"116155\">@Jake Goulding</span>?). Conceptually, however, the fact that this could be problematic, teaching-wise, should at the very least be <em>plausible</em>: sugar, by definition, hides (deemed-cumbersome) semantics, and hidden semantics don't help those that are not well acquainted with them. So it's a practical tradeoff, one which deserves more testing —in that regard, I'm not against experimenting with this MCP's implementation on <code>nightly</code>, provided it doesn't \"status quo\" its way into stable. But at the very least, the proposal should not be that confident upfront regarding its positive impact on beginners.</li>\n</ul>\n<p>So, on the one hand, we have explicit trait alias being cumbersome (as cumbersome as a type alias is, I'd say (<em>e.g.</em>, the pervasive <code>MyResult&lt;T&gt; = Result&lt;T, MyErr&gt;;</code>) which does indeed have some impact on the readability of the code, but I've always found it to be quite minimal), and on the other hand we have an extra feature to basically allow having a trait <code>Iterator&lt;Item = …&gt;</code> and its implicit alias <code>Iterator&lt;…&gt;</code> collide in the same name, which leads to the subtle implications <span class=\"user-mention\" data-user-id=\"326176\">@Boxy [she/her]</span> mentioned: what if default generic type parameters were added? In the explicit <code>trait alias</code> case, that can be handled, since we'd be forced to spell out the alias, and inside it, its type parameters).</p>",
        "id": 261263351,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1636729139
    },
    {
        "content": "<h1>A counter-proposal</h1>\n<p>When thinking about this, however, I've seen a way to conciliate sugar and semantics, by going back to the conceptual level: if an \"input type\" is the only possible \"input type\" (for each choice of genuine input types), <em>and if we managed to make the compiler enforce so</em>, then, for all intents and purposes, we have an \"output type\", even if it appears in input position.</p>\n<p>Indeed, if we had:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Factory</span><span class=\"o\">&lt;</span><span class=\"n\">Thing</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">make_another</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Thing</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>then it would be possible for a type to implement <code>Factory&lt;u8&gt;</code> and <code>Factory&lt;String&gt;</code>, and it would then be possible to have:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">id1</span>: <span class=\"kt\">u8</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">factory</span><span class=\"p\">.</span><span class=\"n\">make_another</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">id2</span>: <span class=\"nb\">String</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">factory</span><span class=\"p\">.</span><span class=\"n\">make_another</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">id3</span>: <span class=\"kt\">u8</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">factory</span><span class=\"p\">.</span><span class=\"n\">make_another</span><span class=\"p\">();</span><span class=\"w\"></span>\n</code></pre></div>\n<p>which could be an unintended usage of <code>factory</code>'s state machine, leading to logic bugs. I'd say that's a good reason to have <code>Iterator</code> and <code>Future</code> use associated types (similar <code>self</code>-mutating API that yields a value whose type is chosen by the <code>impl</code>).</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"sd\">/// With this definition, the above snippet would be impossible to have.</span>\n<span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Factory</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Thing</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">make_another</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span>::<span class=\"n\">Thing</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>So, at this point we could imagine something like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"sd\">//! pseudo-code!</span>\n<span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Factory</span><span class=\"o\">&lt;</span><span class=\"cp\">#[unique]</span><span class=\"w\"> </span><span class=\"n\">Thing</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n</code></pre></div>\n<p>This looks horrendous, I'll admit (what is <code>#[unique]</code> about it? Semantics are not clear), but I believe there is an idea to explore there:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Factory</span><span class=\"o\">&lt;</span><span class=\"n\">Thing</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Thing</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"bp\">Self</span>::<span class=\"n\">Thing</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"c1\">// assuming type-equality constraints!</span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Thing</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>And then we could even make it default to <code>Self::Thing</code> so as to get sugar, and to be able to retro-apply such a change to traits such as <code>Iterator</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"nb\">Iterator</span><span class=\"o\">&lt;</span><span class=\"n\">Item</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"bp\">Self</span>::<span class=\"n\">Item</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"cm\">/* default instantiation when not provided */</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Item</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"bp\">Self</span>::<span class=\"n\">Item</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"cm\">/* equality constraint (in case `Item` was explicitly provided) */</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n</code></pre></div>\n<ul>\n<li>which could even have a shorthand sugar: <code>trait Iterator&lt;Item == Self::Item&gt;</code></li>\n</ul>\n<p>This, incidentally, solves all of the other possible pitfalls, since we have that <code>Item</code> generic parameter explicitly spelled out, so it has a well-defined position there.</p>\n<p>It would, for instance, still allow for:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"cm\">/* … */</span><span class=\"w\"> </span><span class=\"nb\">Iterator</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"></span>\n</code></pre></div>\n<p>as well as:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"cm\">/* … */</span><span class=\"w\"> </span><span class=\"nb\">Iterator</span><span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"cm\">/* … */</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Item</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>and for added default type parameters, one would just have to write those after the <code>==</code> one:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"nb\">Iterator</span><span class=\"o\">&lt;</span><span class=\"n\">Item</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"bp\">Self</span>::<span class=\"n\">Item</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Dir</span><span class=\"w\"> </span>: <span class=\"nc\">Direction</span>::<span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Direction</span>::<span class=\"n\">Forward</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>It does mean that for a <code>Direction::Backward</code> impl, one would have to explicitly provide that <code>Item</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"nb\">Iterator</span><span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Direction</span>::<span class=\"n\">Backward</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"></span>\n</code></pre></div>\n<ul>\n<li>(but would still allow for a future <code>impl Iterator&lt;Dir = Direction::Backward&gt; for</code> extension…)</li>\n</ul>",
        "id": 261263383,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1636729151
    },
    {
        "content": "<blockquote>\n<p>Granted, this is only a hunch, and I'd thus be keen on hearing the opinion of ppl who have actual extensive experience in teaching Rust beginners (such as @Jake Goulding?)</p>\n</blockquote>\n<p>That would indeed be why I responded with:</p>\n<p><a href=\"/user_uploads/4715/WtVXmMuSuorpYeJO2iRB_adN/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/4715/WtVXmMuSuorpYeJO2iRB_adN/image.png\" title=\"image.png\"><img src=\"/user_uploads/4715/WtVXmMuSuorpYeJO2iRB_adN/image.png\"></a></div>",
        "id": 261263723,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1636729232
    },
    {
        "content": "<p>\"Does <code>SomeTrait&lt;T&gt;</code> mean associated type or generic?\" is a question I don't look forward to answering / explaining.</p>",
        "id": 261264379,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1636729466
    },
    {
        "content": "<p>I don't do as much teaching of absolute beginners lately, but the idea that I'd have to tell someone they can write <code>Iterator&lt;u8&gt;</code> in one place but not another is pretty unsettling.</p>",
        "id": 261264426,
        "sender_full_name": "Lokathor",
        "timestamp": 1636729494
    },
    {
        "content": "<p>I was hoping maybe PATs could delay discussion of associated types until users get further into the world of custom traits and generics? But I can see what you mean about it potentially just feeling inconsistent at that point. I wonder if it is better or worse for PATs to be a rare exception for Future/lterator or a common shorthand for most core traits.</p>",
        "id": 261265518,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636729873
    },
    {
        "content": "<p>I'd echo those sentiments, I'd love the more succinct syntax - having to write the name of many assoc types feels like boilerplate and there is cognitive overhead too (is it Item or Output?), but I feel like blurring the distinction on assoc types and generics, and how subtle the rules are for when you can use the shorthand will make things a lot harder for people learning/teaching</p>",
        "id": 261265553,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1636729889
    },
    {
        "content": "<p>I can't quite put it in words, but allowing <code>Foo&lt;Bar&gt;</code> to mean the same as <code>Foo&lt;Type = Bar&gt;</code> <strong>feels</strong> a lot like allowing <code>foo(&amp;self) -&gt; Iter</code> to mean <code>foo&lt;'a&gt;(&amp;'a self) -&gt; Iter&lt;'a&gt;</code>.</p>",
        "id": 261265608,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1636729915
    },
    {
        "content": "<p>I'll also add on that I agree with the underlying goal, especially addressing the \"is it <code>Item</code> or <code>Output</code>\"</p>",
        "id": 261265997,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1636730026
    },
    {
        "content": "<p>Random alternate idea with all of 30 seconds of thinking: <code>impl Iterator&lt;_ = u8&gt;</code>.</p>",
        "id": 261266132,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1636730060
    },
    {
        "content": "<p>The default argument counter proposal is an interesting use of type equality constraints, but I don't really see how it avoids any of the pitfalls TBH. In the end it seems to amount to the same thing, just at the type solver level not the parser level.</p>",
        "id": 261266432,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636730170
    },
    {
        "content": "<p>I do really like the the mental model of associated types as outputs, so I totally see where you're coming from. But in a way I'll have to think more about, I almost feel like that distinction goes away when you're using <code>impl/dyn Trait</code> a lot.</p>",
        "id": 261266839,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636730318
    },
    {
        "content": "<p>The major pitfall it avoids is that it maintains a syntactic difference between generic and associated types</p>",
        "id": 261266840,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1636730318
    },
    {
        "content": "<p>whilst saving typing the assoc type name and thinking about the name</p>",
        "id": 261266890,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1636730349
    },
    {
        "content": "<p>I certainly feel better about it at first blush</p>",
        "id": 261266919,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1636730364
    },
    {
        "content": "<p>At the technical level yes. But I think in practice it'll amount to the same thing to new users. And it almost seems like it would be harder to explain what is going on with the equality constraints, vs saying \"oh the positional attribute makes this a special case\".</p>",
        "id": 261266989,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636730391
    },
    {
        "content": "<p>I'll mention that it should be easy to remove PATs over an edition if we ever change our minds about a particular trait having additional defaulted generics.</p>",
        "id": 261267505,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636730592
    },
    {
        "content": "<p>Still thinking on the input/output distinction, but I am now wondering if PATs should be thought of as a feature of <code>impl/dyn Trait</code> not as a feature of the trait syntax in general. Because when you write</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">block_on</span><span class=\"o\">&lt;</span><span class=\"n\">F</span>: <span class=\"nc\">Future</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">fut</span>: <span class=\"nc\">F</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">F</span>::<span class=\"n\">Output</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>It needs to be obvious that F outputs a particular \"Output\" type. But then the moment I write</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">print_on</span><span class=\"p\">(</span><span class=\"n\">fut</span>: <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"n\">Future</span><span class=\"o\">&lt;</span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Display</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Technically the output types are still there, but because I am using <code>impl Trait</code> there is no actual way to access those type outputs. So anyone using impl/dyn is instead forced to _input_ constraints. They may be constraints on on those output types under the hood, but they are still being input by me the programmer right now. And I'm inputting them to the place where you usually input generic parameters (between the angle braces). IDK, might be a silly way of thinking about it since writting <code>F: Future&lt;Output=String&gt;</code> is mostly in the same boat.</p>",
        "id": 261269808,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636731600
    },
    {
        "content": "<p>Trait&lt;_=Ty&gt; seems like a good way to simplify having to remember the associated type name while still having it be clearly an associated type.</p>",
        "id": 261271525,
        "sender_full_name": "Lokathor",
        "timestamp": 1636732351
    },
    {
        "content": "<p>and if you need it as output, F::_ might work if there's just one associated type, which is the common case</p>",
        "id": 261271689,
        "sender_full_name": "Lokathor",
        "timestamp": 1636732422
    },
    {
        "content": "<p>\"And I'm inputting them to the place where you usually input generic parameters (between the angle braces)\" - I wouldn't put too much weight on this, it is just somewhat arbitrary sugar, and I'm not sure it is the syntax I would choose if starting again today</p>",
        "id": 261272599,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1636732797
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"222520\">Sam Sartor</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Positional.20Associated.20Types.20lang-team.23126/near/261265518\">said</a>:</p>\n<blockquote>\n<p>I was hoping maybe PATs could delay discussion of associated types until users get further into the world of custom traits and generics? But I can see what you mean about it potentially just feeling inconsistent at that point. I wonder if it is better or worse for PATs to be a rare exception for Future/lterator or a common shorthand for most core traits.</p>\n</blockquote>\n<p>I don't think this will, and even if it would I don't think that's necessarily a good idea. Sweeping the difference between <code>From&lt;T&gt;</code> and <code>Iterator&lt;T&gt;</code> under the rug is going to lead to a lot of confusion later. I'm a big fan of the <code>Iterator&lt;_ = T&gt;</code> syntax though, it only costs three characters over the proposed one and is much more clear</p>",
        "id": 261272768,
        "sender_full_name": "Jake",
        "timestamp": 1636732839
    },
    {
        "content": "<p>(admittedly in the dyn case, it is sugar for something without any other surface syntax,)</p>",
        "id": 261272795,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1636732847
    },
    {
        "content": "<p>Thinking about it more, I think my complaint is better phrased like this: For teachability, I would consider a desirable goal to be that someone transitioning from beginner to advanced user of Rust not have to <em>unlearn</em> anything. This MCP seems in danger of violating that, where we are not just going to be sweeping the distinction between <code>Iterator&lt;T&gt;</code> and <code>From&lt;T&gt;</code> under the rug (which might even be fine), but we are liable to accidentally teach people that they are the same, which seems worse.</p>",
        "id": 261273974,
        "sender_full_name": "Jake",
        "timestamp": 1636733345
    },
    {
        "content": "<p>I still think the positional syntax is conceptually justified for impl/dyn on traits a single AT, but it looks like I have an uphill battle there. I'd be will be willing to settle for <code>_ = T</code>. It is certainly shorter! I don't love that the additional characters are all symbols: it leaves a lot of the muddyness in place.</p>",
        "id": 261276086,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636734267
    },
    {
        "content": "<p>Good point re: unlearning. I am not convinced that PATs violate that on the face, but I agree it is a serious hazard.</p>",
        "id": 261276392,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636734405
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Positional.20Associated.20Types.20lang-team.23126/near/261272599\">said</a>:</p>\n<blockquote>\n<p>I wouldn't put too much weight on this, it is just somewhat arbitrary sugar, and I'm not sure it is the syntax I would choose if starting again today</p>\n</blockquote>\n<p>I've always thought about it as an arbitrary sugar for a type equality constraint like <code>where I::Item == i32</code>, but it doesn't seem like we'll allow clauses like that anytime in the near future, if ever. As a result I think just about any syntax would wind up saying \"give the associated types as inputs\", angle braces or no.</p>",
        "id": 261290536,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636740851
    },
    {
        "content": "<p>And the more I think about it, the more I'm convinced that is a correct interpretation.</p>",
        "id": 261291778,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636741414
    },
    {
        "content": "<p>Wait, I thought we did allow such where clauses (though not possible with dyn). Did I just imagine this?</p>",
        "id": 261291931,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1636741488
    },
    {
        "content": "<p>I thought they were available on nightly too, but it looks like no: <a href=\"https://github.com/rust-lang/rust/pull/87471\">https://github.com/rust-lang/rust/pull/87471</a></p>",
        "id": 261292138,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636741581
    },
    {
        "content": "<p>we allow <code>where I: Iterator&lt;Item = i32&gt;</code> which is basically the same I think</p>",
        "id": 261292150,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1636741586
    },
    {
        "content": "<p>Certainly if I have a type <code>struct MyType&lt;A&gt;</code> and an associated type <code>type B = Option&lt;A&gt;</code>, writing <code>MyType&lt;i32, B=Option&lt;i32&gt;&gt;</code> would be totally silly. There is no question that the parameter <code>A</code> is input and <code>B</code> is corresponding output.</p>",
        "id": 261292224,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636741619
    },
    {
        "content": "<p>But I think <code>impl MyTrait&lt;A&gt;</code> or <code>dyn MyTrait&lt;A&gt;</code> don't have any specific output <code>B</code> in the same way, since each implementor of <code>MyTrait</code> might choose a different output type. So IMO it makes perfect since to treat <code>dyn MyTrait&lt;i32, B=Option&lt;i32&gt;&gt;</code> as having two inputs, which each constrain implementations in some way.</p>",
        "id": 261292395,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636741686
    },
    {
        "content": "<p>One input parameter at the call site constrains an output type at the def site, which is weird. But it seems like a fair description of what is happening.</p>",
        "id": 261292578,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636741791
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"326176\">Boxy [she/her]</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Positional.20Associated.20Types.20lang-team.23126/near/261292150\">said</a>:</p>\n<blockquote>\n<p>we allow <code>where I: Iterator&lt;Item = i32&gt;</code> which is basically the same I think</p>\n</blockquote>\n<p>Maybe I'm playing games with words here. But rather than saying this is a alias for two where clauses, I'm trying to say it is a single clause produced by the type constraint constructor \"Iterator&lt;Item = i32&gt;\" where i32 is an input type.</p>",
        "id": 261292984,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636741971
    },
    {
        "content": "<p>But please tell me if I'm going off the deep end.</p>",
        "id": 261293522,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636742226
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232018\">@Daniel Henry-Mantilla</span> FWIW, for one of the problems you mentioned, I would solve that by making <code>impl Iterator&lt;T&gt; for ...</code> work. ;)</p>",
        "id": 261293826,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636742377
    },
    {
        "content": "<p>I don't see why it shouldn't.</p>",
        "id": 261293840,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636742386
    },
    {
        "content": "<p>I think the approach you mentioned, though, seems viable as well.</p>",
        "id": 261293919,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636742408
    },
    {
        "content": "<p>Mapping from generic to associated.</p>",
        "id": 261293976,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636742432
    },
    {
        "content": "<p>Note that even if <code>impl Iterator&lt;T&gt; for ...</code> works, it's still confusing in a bunch of other places.  For example, <code>impl Iterator&lt;&amp;T&gt; for ...</code> won't work, whereas <code>impl Add&lt;&amp;T&gt; for ...</code> <em>will</em>, because the distinction between input and output modes for generic arguments and associated types.</p>",
        "id": 261294693,
        "sender_full_name": "scottmcm",
        "timestamp": 1636742782
    },
    {
        "content": "<p><code>Foo&lt;_ = T&gt;</code> seems like a semver hazard -- adding another associated type, even with a default, would make it ambiguous.</p>",
        "id": 261295045,
        "sender_full_name": "scottmcm",
        "timestamp": 1636743010
    },
    {
        "content": "<p>you'd only be assigning the non-default type, and it could even warn if a second type were added</p>",
        "id": 261295600,
        "sender_full_name": "Lokathor",
        "timestamp": 1636743290
    },
    {
        "content": "<p>adding a second non-default associated type is sv break anyway</p>",
        "id": 261295645,
        "sender_full_name": "Lokathor",
        "timestamp": 1636743317
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Positional.20Associated.20Types.20lang-team.23126/near/261295045\">said</a>:</p>\n<blockquote>\n<p><code>Foo&lt;_ = T&gt;</code> seems like a semver hazard -- adding another associated type, even with a default, would make it ambiguous.</p>\n</blockquote>\n<p>Wouldn't the same be true of the original positional associated types proposal?</p>",
        "id": 261311012,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1636751351
    },
    {
        "content": "<p>you could borrow the same positional aspect:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Example</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// type AddingHereIsBad;</span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Alpha</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// type AddingHereIsOk;</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 261312769,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1636752326
    },
    {
        "content": "<p>There might be a way around this, but honestly I'm fine considering it a semvar hazard to add any new positional or associated types once one is positional.</p>",
        "id": 261312922,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636752413
    },
    {
        "content": "<p>The user story here is pretty narrow in scope, mostly focusing on just a few core traits that people have to type a lot.</p>",
        "id": 261312987,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636752452
    },
    {
        "content": "<p>Speaking of which, I am warming up to <span class=\"user-mention\" data-user-id=\"232018\">@Daniel Henry-Mantilla</span>'s version of this. I think it was edited  from when I first read it, but having the associated type explicitly spelled out in the definition line is nice. I do wonder if there is a way to reduce the grammar burden or otherwise get more bang for our buck out of a grammar change? But that getting into bikeshed color a bit.</p>",
        "id": 261313850,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636752916
    },
    {
        "content": "<p>One key detail about an MCP: this is a proposal to solve a problem, not necessarily a commitment to a specific solution.</p>",
        "id": 261320751,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636756915
    },
    {
        "content": "<p>So the syntax could change.</p>",
        "id": 261320798,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636756925
    },
    {
        "content": "<p>I don't think my complaints are specifically about syntax, really.</p>\n<p>The difference between generic types and associated types is important, that's why associated types were added in the first place &lt;<a href=\"https://rust-lang.github.io/rfcs/0195-associated-items.html#clearer-trait-matching\">https://rust-lang.github.io/rfcs/0195-associated-items.html#clearer-trait-matching</a>&gt; and we don't just have <code>Add&lt;T, O&gt;</code> but <code>Add&lt;T, Output = O&gt;</code>.</p>\n<p>It'd not obvious to me that \"it may not be clear to incoming Rust programmers why\" is a good reason to hide the difference <em>sometimes</em>, especially given Jake's comment.</p>\n<p>I think that's especially the case if it's only for a few types and given we've accepted trait aliases as a thing.  If 90% of the terseness benefit can be gotten by putting <code>trait Fut&lt;T&gt; = Future&lt;Output = T&gt;;</code> in the futures crate prelude, it's not clear to me that it's worth a language feature.</p>\n<p>(If <code>async fn</code> required mentioning <code>Future</code> I might feel differently, but it doesn't.  And similarly that implies that if we get generators, people won't have to write <code>-&gt; impl Iterator&lt;Output = T&gt;</code> for them either.)</p>",
        "id": 261321846,
        "sender_full_name": "scottmcm",
        "timestamp": 1636757714
    },
    {
        "content": "<p>So, the <em>main</em> reason to hide it isn't for the benefit of new programmers, and I think it's worth doing even if it's just neutral for new programmers, because it's convenient.</p>",
        "id": 261322589,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636758181
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Positional.20Associated.20Types.20lang-team.23126/near/261321846\">said</a>:</p>\n<blockquote>\n<p>(If <code>async fn</code> required mentioning <code>Future</code> I might feel differently, but it doesn't.  And similarly that implies that if we get generators, people won't have to write <code>-&gt; impl Iterator&lt;Output = T&gt;</code> for them either.)</p>\n</blockquote>\n<p>That's actually exactly what motivated this proposal in the first place: a discussion about generators, in which we were talking about using the syntax <code>-&gt; impl Iterator&lt;Item = T&gt;</code>, and then thinking it'd be preferable to just write <code>-&gt; impl Iterator&lt;T&gt;</code>.</p>",
        "id": 261322717,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636758267
    },
    {
        "content": "<p>(Also, I think you just demonstrated another reason to do this: people <em>really</em> don't care what the associated type is called, nor should they have to. The fact that <code>Iterator</code> calls it <code>Item</code>, not <code>Output</code>, is a fairly unimportant implementation detail.)</p>",
        "id": 261322773,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636758314
    },
    {
        "content": "<p>I have seen a few new programmers stub their toes on <code>Future&lt;Output=T&gt;</code> long before needing deal with ATs directly. And optimistically asserted this could help new users when writing up the MCP. But I think the bar is just that we don't force anyone to unlearn misconceptions more than they already have to. I really just want to stop having to remember/type out AT names in these common cases.</p>",
        "id": 261324408,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636759539
    },
    {
        "content": "<p>(running this by one friend today who had never seen <code>impl Iterator&lt;Item=T&gt;</code> syntax before, he guessed that \"it iterates through a collection of i32 collections\")</p>",
        "id": 261324626,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636759705
    },
    {
        "content": "<blockquote>\n<p>people really don't care what the associated type is called</p>\n</blockquote>\n<p>That's actually all that interests me in this proposal, and why the <code>&lt;_ = i32&gt;</code> straw man alternative came to mind.</p>",
        "id": 261366675,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1636818519
    },
    {
        "content": "<p>I also think that the proposed syntax of positional associated types doesn't pass the \"code is written a few times, and read many times\" test.</p>",
        "id": 261366689,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1636818584
    },
    {
        "content": "<p>I see what you mean, but I think it actually improves readability for iterators and futures specifically. The associated type name just adds noise to those.</p>",
        "id": 261368441,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636820911
    },
    {
        "content": "<blockquote>\n<p>improves readability for iterators and futures specifically</p>\n</blockquote>\n<p>This is probably technically true, but the particular reason here is relevant. Iterator and Future are traits that people write <em>all the time</em> and the only reason that the fact that their <code>T</code>s are associated and not generic is noise right now is because of their popularity. If you'd like to make an argument that we should special-case these two, I'd be sympathetic, but imo the reason that this might work for Iterator/Future is entirely inapplicable to the rest of the ecosystem</p>",
        "id": 261369402,
        "sender_full_name": "Jake",
        "timestamp": 1636822291
    },
    {
        "content": "<p>Honestly, this all started with me and Josh wanting to special case the two (and probably also Stream once it is stable).</p>",
        "id": 261369482,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636822400
    },
    {
        "content": "<p>And I'd still be fine with that if it came to it.</p>",
        "id": 261369488,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636822409
    },
    {
        "content": "<p>But I wanted to at least try for a more general solution.</p>",
        "id": 261369494,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636822426
    },
    {
        "content": "<p>I definitely think that's possible, but imo this isn't the one. I know <span class=\"user-mention\" data-user-id=\"116155\">@Jake Goulding</span> has said that <code>&lt;_ = i32&gt;</code> is not meant to be too serious a suggestion, but I genuinely like it</p>",
        "id": 261369867,
        "sender_full_name": "Jake",
        "timestamp": 1636822892
    },
    {
        "content": "<p>I'm willing to settle for <code>&lt;_ = T&gt;</code> given that seems to have more support so far.</p>",
        "id": 261369922,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636822933
    },
    {
        "content": "<p>But my option is still that: in the context of <code>impl/dyn Trait</code> there just isn't a meaningful difference between default type params and associated types, and so the <code>=</code> doesn't really add anything.</p>",
        "id": 261370118,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636823222
    },
    {
        "content": "<p>Pondering: the <code>impl</code> is nearly as noisy as the <code>Item=</code>.</p>\n<p>What if we could do <code>bikeshed Iter&lt;T&gt; = impl Iterator&lt;Item = T&gt;;</code>?  And then write code like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">it</span>: <span class=\"nc\">Iter</span><span class=\"o\">&lt;</span><span class=\"kt\">i32</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Iter</span><span class=\"o\">&lt;</span><span class=\"kt\">i64</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">it</span><span class=\"p\">.</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"nb\">Into</span>::<span class=\"n\">into</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 261385572,
        "sender_full_name": "scottmcm",
        "timestamp": 1636845218
    },
    {
        "content": "<p>which kind of <code>impl Trait</code> does <code>it: Iter&lt;i32&gt;</code> correspond to here</p>",
        "id": 261385743,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1636845459
    },
    {
        "content": "<p>does the kind of <code>impl Trait</code> just depend on where we use <code>Iter</code></p>",
        "id": 261385795,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1636845497
    },
    {
        "content": "<p><code>macro Iter($t:ty) { impl Iterator&lt;Item = $t&gt; }</code>?</p>",
        "id": 261385834,
        "sender_full_name": "Matthew Jasper",
        "timestamp": 1636845593
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> I don't mind the <code>impl</code> keyword personally, since I think it is important to notice when a function is generic over a trait. But I also just think that words add less noise than symbols.</p>",
        "id": 261388018,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636848895
    },
    {
        "content": "<p>Interesting idea to write  <code>fn bar() -&gt; Iter!&lt;i32&gt;</code>. I like that it could potentially help with lifetime elision by adding a <code> + '_</code>. But something feels a little icky about it that I can't put my finger on yet.</p>",
        "id": 261388170,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636849121
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"326176\">Boxy [she/her]</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Positional.20Associated.20Types.20lang-team.23126/near/261385795\">said</a>:</p>\n<blockquote>\n<p>does the kind of <code>impl Trait</code> just depend on where we use <code>Iter</code></p>\n</blockquote>\n<p>I guess?  This is not an idea thought about for a long time before posting, so it might be terrible :P</p>",
        "id": 261393405,
        "sender_full_name": "scottmcm",
        "timestamp": 1636857145
    },
    {
        "content": "<p>fwiw I'd have expected <code>type Foo = impl Trait</code> to work the way you're describing <code>bikeshed</code> then</p>",
        "id": 261393487,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1636857282
    },
    {
        "content": "<p>(it of course, does not behave that way, so oh well)</p>",
        "id": 261393492,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1636857291
    },
    {
        "content": "<p>Years ago, the plan for impl Trait was to drop the impl once we required dyn for trait objects, which we now do, so perhaps we could just do that rather than permit impl in aliases? Personally I’d prefer to do neither since I don’t mind the impl keyword, but I know I’m often on the wrong side of these discussion in the long run 😀</p>",
        "id": 261413967,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1636891513
    },
    {
        "content": "<p>The original RFC for <code>impl Trait</code> mentioned the possibility for <code>some MyTrait</code> and <code>any MyTrait</code> differenciating syntaxes to distinguish between the universal and existential aspects. As time goes by, I am more and more convinced this is a useful distinction to mark syntactically, not only teaching-wise, but also to allow for extra expressibility of the language:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">type</span> <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">MyTrait</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// current existential semantics</span>\n<span class=\"k\">type</span> <span class=\"nc\">Iter</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">any</span><span class=\"w\"> </span><span class=\"nb\">Iterator</span><span class=\"o\">&lt;</span><span class=\"n\">Item</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// to handle the suggestion in this thread.</span>\n</code></pre></div>\n<p>Out-of-topic aside: it would also incidentally allow for existential input types, which would itself allow for the following pattern:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">returns_unboxed_slice</span><span class=\"p\">(</span><span class=\"n\">slot</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">Slot</span><span class=\"o\">&lt;</span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"nb\">Sized</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kp\">&amp;</span><span class=\"nc\">own</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">slot</span><span class=\"p\">.</span><span class=\"n\">insert</span><span class=\"p\">([</span><span class=\"mi\">42</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">27</span><span class=\"p\">])</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">returns_unboxed_trait_obj</span><span class=\"p\">(</span><span class=\"n\">slot</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">Slot</span><span class=\"o\">&lt;</span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"nb\">Sized</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kp\">&amp;</span><span class=\"nc\">own</span><span class=\"w\"> </span><span class=\"nb\">FnOnce</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">not_copy</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">String</span>::<span class=\"n\">new</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">slot</span><span class=\"p\">.</span><span class=\"n\">insert</span><span class=\"p\">(</span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nb\">drop</span><span class=\"p\">(</span><span class=\"n\">not_copy</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">})</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 261414997,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1636893093
    },
    {
        "content": "<p>What do people think in general of syntax like this?</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"nb\">Iterator</span><span class=\"o\">&lt;</span><span class=\"bp\">Self</span>::<span class=\"n\">Item</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 261703545,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1637095150
    },
    {
        "content": "<p>(building on what <span class=\"user-mention\" data-user-id=\"232018\">@Daniel Henry-Mantilla</span>  is doing)</p>",
        "id": 261703594,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1637095179
    },
    {
        "content": "<p>I'm not sure how I feel about it indicate the ability to do stuff like </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">MyTrait</span><span class=\"o\">&lt;</span><span class=\"kt\">i32</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 261703812,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1637095279
    },
    {
        "content": "<p>Which I can't imagine any sane use-case for</p>",
        "id": 261703854,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1637095306
    },
    {
        "content": "<p>Hmmm, having the positional-ness encoded into the definition line would be best. But looking at it now, I think I'd prefer any of <code>_ = T</code>, trait aliases, or <code>#[positional]</code> more the version of that I wrote above.</p>",
        "id": 261704591,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1637095650
    },
    {
        "content": "<p>I personally would be entirely fine with a syntax like that at the trait declaration, in order to allow the simplified syntax at usage sites.</p>",
        "id": 261717224,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1637102012
    },
    {
        "content": "<p>I think this should be purely a sugar for the use site, I wouldn’t want to introduce a new class of associated types</p>",
        "id": 261717811,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1637102292
    },
    {
        "content": "<p>Okay, I finally added the comment that I promised long ago that summarizes the concerns raised at both lang team meeting and on this zulip thread. (This zulip thread was pretty clutch in helping me make sense of the lang team notes now.): <a href=\"https://github.com/rust-lang/lang-team/issues/126#issuecomment-1002233625\">https://github.com/rust-lang/lang-team/issues/126#issuecomment-1002233625</a></p>",
        "id": 266281757,
        "sender_full_name": "pnkfelix",
        "timestamp": 1640717054
    },
    {
        "content": "<p>10/10 summary, thanks!</p>",
        "id": 266288786,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1640722420
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> Thanks for the summary!</p>",
        "id": 266294710,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640727547
    },
    {
        "content": "<p>Shouldn't the mentions of <code>-&gt; Future&lt;...&gt;</code> be <code>-&gt; impl Future&lt;...&gt;</code>?</p>",
        "id": 266294725,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640727565
    },
    {
        "content": "<p>oh probably. :)</p>",
        "id": 266294749,
        "sender_full_name": "pnkfelix",
        "timestamp": 1640727583
    },
    {
        "content": "<p>(fixed)</p>",
        "id": 266294805,
        "sender_full_name": "pnkfelix",
        "timestamp": 1640727612
    }
]