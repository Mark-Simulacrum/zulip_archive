[
    {
        "content": "<p>A new proposal has been announced: <a href=\"https://github.com/rust-lang/lang-team/issues/139\">inner crates, aka multiple crates per file #139</a>. It will be announced at the next meeting to try and draw attention to it, but usually MCPs are not discussed during triage meetings. If you think this would benefit from discussion amongst the team, consider proposing a design meeting.</p>",
        "id": 269297398,
        "sender_full_name": "triagebot",
        "timestamp": 1643133727
    },
    {
        "content": "<p>I would have frequently used this for demonstrating <code>non_exhaustive</code>.  As it is I've done things like open PRs to add tests since playground links can't, like <a href=\"https://github.com/rust-lang/rust/issues/91281\">#91281</a>.</p>\n<p>I don't know how critical this would be for \"real\" code.  But we could probably give it a not-super-pretty syntax and just do it if compiler says it's feasible.</p>",
        "id": 269300333,
        "sender_full_name": "scottmcm",
        "timestamp": 1643134916
    },
    {
        "content": "<blockquote>\n<p>playground links can't</p>\n</blockquote>\n<p>They can if you're <del>desperate</del> motivated enough: <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=116f1eb53eaf1a0588470c7bd1b05356\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=116f1eb53eaf1a0588470c7bd1b05356</a> <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span></p>",
        "id": 269300686,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1643135066
    },
    {
        "content": "<p>More seriously, I'm all up for any proposal that helps inlining proc-macros (more generally, any proposal that at least helps bundling the proc-macro crate within the same <strong>package</strong> as the frontend rlib crate: no more <code>foo-proc_macros</code>/<code>foo-derive</code> extra packages on <a href=\"http://crates.io\">crates.io</a>!)</p>",
        "id": 269301007,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1643135212
    },
    {
        "content": "<p>I would much rather just have a way for proc macros to be defined in the same crate they are used in, it’s much more ergonomic than making the programmer consider multiple crates, though would probably end up implemented that way</p>",
        "id": 269302007,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1643135599
    },
    {
        "content": "<p>I'd note that inner crates may be problematic to implement. It would require multiple link steps (especially for proc-macros, which need to compiled for host, rather than target).</p>",
        "id": 269302600,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643135811
    },
    {
        "content": "<p>One intermediate thing, which requires less grammar work, would be for there to be an attribute, say <code>#[extern_crate]</code>, or w/e, which could be slapped onto non-inline modules at the root of a crate (<code>src/lib.rs</code>, or whatever entrypoint is designed in the <code>Cargo.toml</code>). Wouldn't work for macro-expanded stuff, or other things like that, for similar reasons to <code>#[macro_export]</code> \"not working\" when emitted through macro-expansion:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"sd\">//! src/lib.rs</span>\n\n<span class=\"cp\">#[extern_crate]</span><span class=\"w\"></span>\n<span class=\"k\">mod</span> <span class=\"nn\">proc_macros</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<ul>\n<li>With options such as: <code>#[extern_crate(path = \"…\", kind = \"…\", dependencies = […])]</code></li>\n</ul>\n<p>then becoming, on top of the auto-generated rust-flags / meta-compilation stuff:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"k\">crate</span><span class=\"w\"> </span><span class=\"n\">__crate__proc_macros</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">use</span><span class=\"w\"> </span>::<span class=\"n\">__crate__proc_macros</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">proc_macros</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>With that implemented, we could indeed feature a <code>#[proc_macro_crate]</code> attribute as an alias for <code>#[extern_crate(kind = \"proc-macro\")]</code>.</p>\n<p>Maybe I'm just bikeshedding the <code>crate { … }</code> <em>vs.</em> <code>mod …</code> syntax thing but:</p>\n<ul>\n<li>an extern crate ends up behaving like a mod (modulo <code>::</code>-lead paths);</li>\n<li>requires less grammar changes (although, granted, that's the least of the concerns)</li>\n</ul>\n<p>I do believe that these things not being macro-expanded and being at the top-level seems to be a quite necessary thing; the \"preprocessor\" pass ought to perform minimal/easy work to figure out what the new extra crates are.</p>",
        "id": 269305607,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1643136995
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232018\">Daniel Henry-Mantilla</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/inner.20crates.2C.20aka.20multiple.20crates.20per.20file.20lang-team.23139/near/269305607\">said</a>:</p>\n<blockquote>\n<p>would be for there to be an attribute [...]</p>\n</blockquote>\n<p>That's a good point.  All the things where I've wanted this for examples would be fine with just a perma-unstable <code>#[rustc_treat_this_module_like_a_different_crate]</code>.</p>\n<p>(Though I assume that wouldn't make implementation any easier, since I would guess the logic today is looking at the CrateNum field or just knowing what's local vs loaded from metadata, and making any syntax do that is the hard part.)</p>",
        "id": 269307505,
        "sender_full_name": "scottmcm",
        "timestamp": 1643137730
    },
    {
        "content": "<p>\"Obviously\" we just need an <code>outclude!</code> macro that does the opposite of <code>include!</code> <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 269307875,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1643137901
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/inner.20crates.2C.20aka.20multiple.20crates.20per.20file.20lang-team.23139/near/269302007\">said</a>:</p>\n<blockquote>\n<p>I would much rather just have a way for proc macros to be defined in the same crate they are used in, it’s much more ergonomic than making the programmer consider multiple crates, though would probably end up implemented that way</p>\n</blockquote>\n<p>Are you worried that adding an ugly path like this will lead to us never implementing “the right thing”? (Because, yeah, I can understand that worry. See also <code>#[may_dangle]</code> attribute.)</p>",
        "id": 269364549,
        "sender_full_name": "pnkfelix",
        "timestamp": 1643173789
    },
    {
        "content": "<blockquote>\n<p>I do believe that these things not being macro-expanded and being at the top-level seems to be a quite necessary thing; the \"preprocessor\" pass ought to perform minimal/easy work to figure out what the new extra crates are.</p>\n</blockquote>\n<p>I agree 100% with these statements. I considered spelling out some of this stuff in the proposal, and going so far as to say e.g. “you can’t nest these things; no <code>crate foo { crate bar { crate quux { /* … */ } } }</code> nonsense.</p>",
        "id": 269364793,
        "sender_full_name": "pnkfelix",
        "timestamp": 1643174024
    },
    {
        "content": "<p>but yeah: They’re strictly top-level, and you shouldn’t be able to create them via macro expansion.</p>",
        "id": 269364849,
        "sender_full_name": "pnkfelix",
        "timestamp": 1643174063
    },
    {
        "content": "<p>I’m not so hot on the idea of making it “just an attribute on <code>mod</code>” — crates really do behave so differently than modules in a number of places…. e.g. trait coherence rules. And of course, everyone’s favorite, <code>pub(crate)</code> ...</p>",
        "id": 269364906,
        "sender_full_name": "pnkfelix",
        "timestamp": 1643174151
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/inner.20crates.2C.20aka.20multiple.20crates.20per.20file.20lang-team.23139/near/269302600\">said</a>:</p>\n<blockquote>\n<p>I'd note that inner crates may be problematic to implement. It would require multiple link steps (especially for proc-macros, which need to compiled for host, rather than target).</p>\n</blockquote>\n<p>I hadn’t considered this. So the implementation may be more complicated than I anticipated. But not <em>absurdly</em> so, I think...</p>",
        "id": 269364982,
        "sender_full_name": "pnkfelix",
        "timestamp": 1643174227
    },
    {
        "content": "<blockquote>\n<p>Are you worried that adding an ugly path like this will lead to us never implementing “the right thing”? (Because, yeah, I can understand that worry. See also #[may_dangle] attribute.)</p>\n</blockquote>\n<p>I was reacting to a comment specifically about proc macros, rather than reacting to the proposal. But I think it is worth reframing in terms of the actual proposal:</p>\n<p>I think that using this proposal for proc macros would be not nice, but hopefully we could share implementation with a nice way to do proc macros. Therefore, I think when considering the pros and cons of the proposal we should not consider the proc macro use case on the pros side, only the examples and testing use cases. I would prefer to see the proc macro case handled first, since I think that would be more impactful for more Rust programmers, but given the potential shared implementation, I think it might also make sense to tackle transparent inner crates (for proc macros) and explicit inner crates (for examples/tests) at the same time. I realise that the former probably requires a bunch more design work though. I think that we should strongly avoid a path that results in using explicit inner crates for macros because I think that will mean either we never get the nice way for macros, or we have two ways for macros and encouraging everyone to use the late arriving one will be a nightmare.</p>",
        "id": 269379079,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1643187421
    },
    {
        "content": "<p>The proc-macro issue is not really related to this, that is simply a cargo-thing. Currently each package can only contain at most one \"main\" library crate, if the rule is extended to have a <code>[[aux-libs]]</code>(or anything else you want to call it) section in the <code>Cargo.toml</code> spec, this problem is solved, i think.</p>",
        "id": 269542392,
        "sender_full_name": "Charles Lew",
        "timestamp": 1643274186
    },
    {
        "content": "<p>Its somewhat related in that I want to declare a proc macro in the same file in which I use it, which is pretty much what is proposed here, but implicit</p>",
        "id": 269544209,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1643275331
    },
    {
        "content": "<p>oh i see. But proc macros requires their dependencies and itself compiled for the host platform. Cargo's awareness is quite important here....</p>",
        "id": 269549025,
        "sender_full_name": "Charles Lew",
        "timestamp": 1643277873
    },
    {
        "content": "<p>it is, but it should also work if you're just using the compiler without Cargo, as long as you pass the right flags</p>",
        "id": 269552591,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1643279814
    },
    {
        "content": "<p>Previously one crate corresponds to one rustc invocation (with one set of flags). If different sets of flags needs to be handled at the same time, it will introduce quite some complexity...</p>",
        "id": 269553415,
        "sender_full_name": "Charles Lew",
        "timestamp": 1643280138
    },
    {
        "content": "<p>Yeah, I'm not saying its easy :-)</p>",
        "id": 269553947,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1643280342
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/inner.20crates.2C.20aka.20multiple.20crates.20per.20file.20lang-team.23139/near/269544209\">said</a>:</p>\n<blockquote>\n<p>Its somewhat related in that I want to declare a proc macro in the same file in which I use it, which is pretty much what is proposed here, but implicit</p>\n</blockquote>\n<p>It may be better to go one step at a time for this, though: feature multiple crates per package other than the current limitation to <code>lib</code>-&amp;-<code>bin</code>s; and <em>then</em> allow a rust source file to embed such same-package crates (\"move declaration noise from <code>Cargo.toml</code>  to <code>src.lib.rs</code>\"), by feature outlined <code>#[src_path = \"…\"] crate foo;</code> declarations or something, and from there allowing inlining such crates could be featured as well.</p>",
        "id": 269557618,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1643281903
    },
    {
        "content": "<p>FWIW, I personally have never felt that much the need to have proc-macro definitions be inlined in other places; having them defined in a separate <code>foo.rs</code> file or <code>mod.rs</code> is quite enough. I've been scoping my proc-macro crates for that purpose under <code>src/</code> and targeting a <code>mod.rs</code> file for a while now, and modulo still outstanding crate renaming bugs when proc-macro crates are involved (I guess not that many people have been doing that), the whole thing is quite neat.</p>\n<p>I am thus curious about the motivation for <em>explicitly inlined</em> proc-macro defs that you have in mind, <span class=\"user-mention\" data-user-id=\"256841\">@Nick Cameron</span>:</p>\n<ul>\n<li>is it because when writing a trait you'd like to feature the eponymous derive adjacent to the trait's definition?</li>\n<li>is it to be able to test/share proc-macro code in the Playground? (I personally think that that's something the Playground could improve itself, <em>should there be enough person-power behind it to drive it to completion</em>; I have been using things <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=65b245a1bd1bd9be16ea02146fa966fe\">like this</a> for a while now, and so does the Discord bot on the community-server (<code>?procmacro</code> command which takes two snippets of code).</li>\n<li>or is it because sometimes you'd like to feature very ad-hoc derives or attributes, and the fact that <code>macro_rules!</code> macros can't go in that position is limiting? In that regard the <a href=\"https://docs.rs/macro_rules_attribute/latest/macro_rules_attribute/\">https://docs.rs/macro_rules_attribute/latest/macro_rules_attribute/</a> prototype exists, and I think I'm not alone in thinking that such a feature could somehow be blessed by the language.</li>\n</ul>\n<p>Aside: I'm somehow thinking more and more of this <code>outline!</code> proposal <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span>, it would just need a <code>inline_outlined!</code> counter-part and it could actually work <span aria-label=\"see no evil\" class=\"emoji emoji-1f648\" role=\"img\" title=\"see no evil\">:see_no_evil:</span></p>",
        "id": 269558734,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1643282561
    },
    {
        "content": "<p>I don't care too much about literally being in the same file, being in a different module is fine, but rustc doesn't care too much about files, so if <br>\nthey can be in the same crate, they should be ok in the same file too.</p>",
        "id": 269558952,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1643282695
    },
    {
        "content": "<p>My motivation is that I would like to be able to write proc macros as easily as decl macros. E.g., if macro_rules is not expressive enough I want to just change the decl to a proc macro and be done</p>",
        "id": 269559079,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1643282773
    },
    {
        "content": "<p>And I want people to choose proc or decl based only on which mechanism is better for the job, not that one requires a whole bunch more boilerplate and Cargo-ceremony</p>",
        "id": 269559144,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1643282819
    },
    {
        "content": "<p>I'm with Nick. I've frequently wanted a proc-macro for things and said to myself \"setting up a separate crate as a build dep etc is more work than copy and paste, so I'll just not write the proc-macro at all.\"</p>",
        "id": 269594600,
        "sender_full_name": "Lokathor",
        "timestamp": 1643299507
    },
    {
        "content": "<p>How would you build an inline proc-macro?</p>",
        "id": 269595060,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643299672
    },
    {
        "content": "<p>It seems like that would require $RUSTC to know things about the build system.</p>",
        "id": 269595148,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643299698
    },
    {
        "content": "<p>I’m tempted to say “lets explicit cut proc-macros out of this proposal”, because I can see that the issues of distinguishing the flags intended for the host from the flags intended for the target is thorny enough that I’d prefer not to have to deal with it at all.</p>",
        "id": 269682867,
        "sender_full_name": "pnkfelix",
        "timestamp": 1643341609
    },
    {
        "content": "<p>(I know that I explicitly listed proc-macros as a motivation, but it wasn’t my primary motivation, and I can see that resolving it is beyond the scope of what I intended here.)</p>",
        "id": 269682893,
        "sender_full_name": "pnkfelix",
        "timestamp": 1643341647
    },
    {
        "content": "<p>Yeah, \"being able to split your crate into subcrates without making the crate submission process 10 times harder\" is a pretty good justification on its own.</p>",
        "id": 269871080,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1643470636
    },
    {
        "content": "<p>I could see that feature being a huge boost to the compilation speed of the ecosystem, because suddenly it's a lot easier to split crates with long compile times and parallelize the whole build.</p>",
        "id": 269871161,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1643470708
    },
    {
        "content": "<p>How would crate declarations interact with conditional compilation? <code>#[cfg(test)] crate something {}</code>, …</p>",
        "id": 269879688,
        "sender_full_name": "fmease",
        "timestamp": 1643480244
    },
    {
        "content": "<p>My thinking was that the crate separation would be treated <em>prior</em> to macro expansion. The grammar would be pretty restricted, like solely a series of <code>crate { … }</code> followed by the code for this crate, if any. Something like: 1. Parse any prefix matching <code>crate { … }</code>; 2. compile (including expansion) that crate to object code; 3. if a <code>crate { … }</code> is in remaining suffix, goto step 1. 4. Now there are no more <code>crate { … }</code> in remaining suffix, so compile the remaining code as normal.</p>",
        "id": 270083224,
        "sender_full_name": "pnkfelix",
        "timestamp": 1643654795
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"348675\">fmease</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/inner.20crates.2C.20aka.20multiple.20crates.20per.20file.20lang-team.23139/near/269879688\">said</a>:</p>\n<blockquote>\n<p>How would crate declarations interact with conditional compilation? <code>#[cfg(test)] crate something {}</code>, …</p>\n</blockquote>\n<p>I made my previous comment thinking of <code>#[cfg(…)]</code> as a special case of macro expansion, but I am now remembering that maybe it is not quite handled that way. In any case, I don’t think I’d allow <code>#[cfg(test)] crate something { … }</code></p>",
        "id": 270083347,
        "sender_full_name": "pnkfelix",
        "timestamp": 1643654844
    },
    {
        "content": "<p>Thats interesting! Do we have any other pre-macro expansion syntax? I guess <code>use</code> is concurrent with macro expansion</p>",
        "id": 270085380,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1643655438
    },
    {
        "content": "<p>is <code>cfg</code> itself pre-macro expansion? or maybe it does something wilder; I’d have to go check ...</p>",
        "id": 270086364,
        "sender_full_name": "pnkfelix",
        "timestamp": 1643655789
    },
    {
        "content": "<p>I think it is yeah</p>",
        "id": 270092500,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1643658144
    },
    {
        "content": "<p>at least it was years ago :-)</p>",
        "id": 270092540,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1643658163
    },
    {
        "content": "<p><code>#[macro_export]</code> being able to populate <em>locally</em> the root of the crate namespace is only possible prior to macro-expansion</p>",
        "id": 270093460,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1643658565
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"263609\">Olivier FAURE</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/inner.20crates.2C.20aka.20multiple.20crates.20per.20file.20lang-team.23139/near/269871161\">said</a>:</p>\n<blockquote>\n<p>I could see that feature being a huge boost to the compilation speed of the ecosystem, because suddenly it's a lot easier to split crates with long compile times and parallelize the whole build.</p>\n</blockquote>\n<p>That’s … a strong assertion. I honestly hadn’t expected this feature to be heavily used in the ecosystem. In particular, I hadn’t really thought about whether one could put <code>crate { … }</code> <em>under</em> a <code>mod { … }</code> (and likewise, under the contents of a source file denotedb y <code>mod f;</code> , which seems like a feature one would have to have if one were talking about trying to make use of this in “real world” code bases.</p>",
        "id": 270094259,
        "sender_full_name": "pnkfelix",
        "timestamp": 1643658901
    },
    {
        "content": "<p>FWIW, almost nothing is pre-macro expansion except for parsing the initial tokens in the crate.<br>\nThen we start expanding starting from crate-level macro attributes (which are unstable though) and such attributes can change any crate content below.</p>",
        "id": 270140969,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1643682033
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232018\">Daniel Henry-Mantilla</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/inner.20crates.2C.20aka.20multiple.20crates.20per.20file.20lang-team.23139/near/270093460\">said</a>:</p>\n<blockquote>\n<p><code>#[macro_export]</code> being able to populate <em>locally</em> the root of the crate namespace is only possible prior to macro-expansion</p>\n</blockquote>\n<p>This is also not true.</p>",
        "id": 270140980,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1643682043
    },
    {
        "content": "<p><code>cfg(_attr)</code>s on the crate root are also speculatively expanded to get crate <code>feature</code>s before the main expansion starts, but that's some hacky hackery that maybe needs to be eliminated.</p>",
        "id": 270141190,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1643682225
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"123856\">@Vadim Petrochenkov</span> I know that something like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">mod</span> <span class=\"nn\">foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"cp\">#[cfg(all())]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">super</span>::<span class=\"n\">m</span><span class=\"o\">!</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">mod</span> <span class=\"nn\">bar</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span>::<span class=\"n\">cfg_if</span>::<span class=\"n\">cfg_if</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"cp\">#[cfg(all())]</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"cp\">#[macro_export]</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"fm\">macro_rules!</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"p\">{()</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">()}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">});</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<ul>\n<li>\n<p><a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=444a58d91894e323a44ad6a76fc3e80d\">Playground</a> (the <code>cfg</code>s and <code>cfg-if</code> is there for a semi-realistic example, feel free to get rid of those and just use an <code>identity!</code> macro to wrap the macro-export).</p>\n</li>\n<li>\n<p><a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=8a067bf3716ce8d171e956ea87199b38\">It works for a non-macro-expanded <code>#[macro_export]</code></a></p>\n</li>\n</ul>\n<p>triggers both the <code>macro_expanded_macro_exports_accessed_by_absolute_paths</code> error-by-default lint, as well as a <code>import resolution is stuck, try simplifying macro imports</code> fatal error.</p>\n<p>Granted, the <code>#[macro_use]</code> effect of the <code>#[macro_export]</code> at the root of the crate does work (as in, you can use <code>m!</code>, <strong>unqualified</strong>, at the root of the crate), but I wouldn't say that that counts as having <em>properly</em> populated \"the root of the crate\".</p>",
        "id": 270196817,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1643717021
    }
]