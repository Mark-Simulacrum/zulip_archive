[
    {
        "content": "<p>A new proposal has been announced: <a href=\"https://github.com/rust-lang/lang-team/issues/46\">#46</a>. It will be announced at the next meeting to try and draw attention to it, but usually MCPs are not discussed during triage meetings. If you think this would benefit from discussion amongst the team, consider proposing a design meeting.</p>",
        "id": 205924326,
        "sender_full_name": "triagebot",
        "timestamp": 1596556218
    },
    {
        "content": "<p>I'd liaison this one.</p>",
        "id": 206370960,
        "sender_full_name": "Lokathor",
        "timestamp": 1596932453
    },
    {
        "content": "<p>I am not sure if this is the appropriate place for this comment, but I have previously suggested replacing <code>extern \"&lt;ABI string\"</code> with <code>abi \"&lt;ABI string&gt;\"</code>, because <code>extern</code> on its own does not actually give a function external linkage, nor does it demangle the function name (as it does in C++).</p>",
        "id": 207476002,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1597881954
    },
    {
        "content": "<p>I would like to propose, as an alternative to this proposal, deprecating <code>extern</code> in 2021 and replacing it with <code>abi</code>, then removing <code>extern</code> entirely in the edition after that.</p>",
        "id": 207476087,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1597881993
    },
    {
        "content": "<p>Where does the linkage go then?</p>\n<p>Because the part about <code>extern</code> that I do strongly like is that you can link some code without a <code>build.rs</code> by just marking the block as linking to somewhere.</p>",
        "id": 207480928,
        "sender_full_name": "Lokathor",
        "timestamp": 1597887426
    },
    {
        "content": "<p>though in the case of functions you export this might read a lot better:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">abi</span><span class=\"w\"> </span><span class=\"s\">&quot;C&quot;</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">four</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">i32</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"mi\">4_</span><span class=\"k\">i32</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 207481002,
        "sender_full_name": "Lokathor",
        "timestamp": 1597887535
    },
    {
        "content": "<p>If I remember correctly, <code>no_mangle</code> does that essentially as a side-effect. I'm not really thrilled with that behavior either, though.</p>",
        "id": 207481298,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1597887989
    },
    {
        "content": "<p>Arguably anything <code>pub</code> at the crate level should be externally linkable when compiled as a dynamic library.</p>",
        "id": 207481313,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1597888042
    },
    {
        "content": "<p>(without <code>abi</code> and <code>no_mangle</code>, it would use the Rust ABI, but of course that requires toolchain versions to match.)</p>",
        "id": 207481376,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1597888095
    },
    {
        "content": "<p><code>no_mangle</code> is such a weirdness that I don't think it should be automatically applied. It should be visually apparent within the code that something is up with this particular function. Particularly since a lot of <code>extern \"C\"</code> functions <em>don't</em> need to be <code>no_mangle</code> in the first place (eg, a callback function you're going to pass to an API at runtime).</p>",
        "id": 207482019,
        "sender_full_name": "Lokathor",
        "timestamp": 1597888988
    },
    {
        "content": "<p>but either way, <code>no_mangle</code> absolutely doesn't create a linking from your crate to another library.</p>\n<p>You do that with something like this</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"cp\">#[link(name = </span><span class=\"s\">&quot;curses&quot;</span><span class=\"cp\">)]</span><span class=\"w\"> </span><span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"s\">&quot;C&quot;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 207482100,
        "sender_full_name": "Lokathor",
        "timestamp": 1597889093
    },
    {
        "content": "<p>I'm not saying <code>no_mangle</code> declarations link to external definitions; I'm saying that <code>no_mangle</code> on a definition sets the linkage attributes. <a href=\"https://internals.rust-lang.org/t/precise-semantics-of-no-mangle/4098\">https://internals.rust-lang.org/t/precise-semantics-of-no-mangle/4098</a></p>",
        "id": 207539376,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1597939038
    },
    {
        "content": "<p>I also am definitely not suggesting that <code>no_mangle</code> should be automatically applied; <code>abi</code> and <code>no_mangle</code> would remain separate.</p>",
        "id": 207539419,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1597939063
    },
    {
        "content": "<p>I think we should have both <code>extern</code> and <code>abi</code>. <code>extern</code> should be used for <code>extern {}</code> blocks and <code>abi</code> should be used to specify the ABI of a function.</p>",
        "id": 207555831,
        "sender_full_name": "Amanieu",
        "timestamp": 1597947371
    },
    {
        "content": "<p>So <code>extern</code> on a function definition (rather than a block of declarations) would be deprecated?</p>",
        "id": 207555879,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1597947408
    },
    {
        "content": "<p>And <code>abi</code> would be used in conjunction with <code>extern</code> for declaration blocks?</p>",
        "id": 207555912,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1597947430
    },
    {
        "content": "<p>Yes.</p>",
        "id": 207555943,
        "sender_full_name": "Amanieu",
        "timestamp": 1597947444
    },
    {
        "content": "<p>I've always found it weird that <code>extern</code> has two very different meanings depending on how it's used.</p>",
        "id": 207555945,
        "sender_full_name": "Amanieu",
        "timestamp": 1597947445
    },
    {
        "content": "<p>Agreed!</p>",
        "id": 207555957,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1597947452
    },
    {
        "content": "<p>It feels like C's <code>static</code> all over again.</p>",
        "id": 207555970,
        "sender_full_name": "Amanieu",
        "timestamp": 1597947459
    },
    {
        "content": "<p>would <code>abi</code> automatically cause a function to have external linkage?</p>",
        "id": 207556066,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1597947484
    },
    {
        "content": "<p>No it just changes the ABI.</p>",
        "id": 207556096,
        "sender_full_name": "Amanieu",
        "timestamp": 1597947506
    },
    {
        "content": "<p>Only <code>#[no_mangle]</code> gives you external linkage.</p>",
        "id": 207556130,
        "sender_full_name": "Amanieu",
        "timestamp": 1597947526
    },
    {
        "content": "<p>How would external linkage be enabled? <code>pub</code>, <code>no_mangle</code>, or some combination?</p>",
        "id": 207556131,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1597947526
    },
    {
        "content": "<p>that still seems like a rather odd side-effect of <code>no_mangle</code>. Couldn't mangled function names still be linked dynamically if we wanted to enable that?</p>",
        "id": 207556237,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1597947590
    },
    {
        "content": "<p>Sure but that's done through Rust's normal privacy system. A mangled symbol will be exported only if the compiler determines it can be accessed from outside the crate. This includes private functions that are referred by inline functions, since crates that inline the latter will need to dynamically link to the former.</p>",
        "id": 207556454,
        "sender_full_name": "Amanieu",
        "timestamp": 1597947718
    },
    {
        "content": "<p><code>#[no_mangle]</code> bypasses Rust's privacy system and assumes it is referenced directly from external code.</p>",
        "id": 207556530,
        "sender_full_name": "Amanieu",
        "timestamp": 1597947745
    },
    {
        "content": "<p>Okay, so <code>pub</code> functions already are externally linkable?</p>",
        "id": 207556570,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1597947780
    },
    {
        "content": "<p>modulo bugs like <a href=\"https://github.com/rust-lang/rust/issues/50007\">https://github.com/rust-lang/rust/issues/50007</a></p>",
        "id": 207556583,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1597947789
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Require.20ABI.20for.20extern.20in.202021.20lang-team.2346/near/207556583\">said</a>:</p>\n<blockquote>\n<p>modulo bugs like <a href=\"https://github.com/rust-lang/rust/issues/50007\">https://github.com/rust-lang/rust/issues/50007</a></p>\n</blockquote>\n<p><span aria-label=\"grimacing\" class=\"emoji emoji-1f62c\" role=\"img\" title=\"grimacing\">:grimacing:</span></p>",
        "id": 207556666,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1597947841
    },
    {
        "content": "<p>Removing external linkage from non Rust-ABI symbols would reduce the mess slightly, but it would still be a mess.</p>",
        "id": 207563441,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1597951347
    },
    {
        "content": "<p>The linkage system needs a principled design, and that's certainly a larger challenge than changing the syntax from <code>extern \"ABI\"</code> to <code>abi \"ABI\"</code> (which I support).</p>",
        "id": 207563538,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1597951411
    },
    {
        "content": "<p>Right now it has a design that is typical for a compiler area without a careful maintainer - \"the general rule works in the common case, a couple of other important cases are patched with hacks, step to the left or right and things break\".</p>",
        "id": 207563955,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1597951633
    },
    {
        "content": "<p>Is there a use for <code>#[no_mangle]</code> <em>without</em> external linkage?</p>",
        "id": 207566408,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1597952978
    },
    {
        "content": "<p>And do you have any thoughts on what, if not <code>#[no_mangle]</code>, could be used to control external linkage? Perhaps a new <code>pub(...)</code> argument? (<code>pub(link)</code>?)</p>",
        "id": 207566571,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1597953059
    },
    {
        "content": "<p>I suppose you could use <code>#[no_mangle]</code> to intercept things that would otherwise link externally -- kind of like <code>LD_PRELOAD</code> hacks, but self-contained</p>",
        "id": 207568215,
        "sender_full_name": "cuviper",
        "timestamp": 1597953865
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120076\">BatmanAoD (Kyle Strand)</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Require.20ABI.20for.20extern.20in.202021.20lang-team.2346/near/207566571\">said</a>:</p>\n<blockquote>\n<p>And do you have any thoughts on what, if not <code>#[no_mangle]</code>, could be used to control external linkage? Perhaps a new <code>pub(...)</code> argument? (<code>pub(link)</code>?)</p>\n</blockquote>\n<p><code>pub</code> doesn't seem like the same thing here. You could, theoretically, have a symbol that's private to a Rust module (so you can't import it via Rust), but made available under an unmangled name as an ELF symbol.</p>",
        "id": 207568685,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1597954123
    },
    {
        "content": "<p>I can think of good reasons to do that, such as the symbol being an implementation detail of a library crate and how it handles a library it's wrapping, but not something the library crate wants to expose as part of its public API.</p>",
        "id": 207568738,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1597954158
    },
    {
        "content": "<p>I think we need an orthogonal concept of symbol visibility (and a better name for that because Rust uses \"visibility\" to describe things like <code>pub</code> and <code>pub(crate)</code>).</p>",
        "id": 207568828,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1597954207
    },
    {
        "content": "<p><code>#[export]</code>? And perhaps <code>#[export(name=\"...\")]</code> for aliases?</p>",
        "id": 207568871,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1597954232
    },
    {
        "content": "<p>(I also wonder if <code>#[export]</code> should <em>imply</em> <code>#[no_mangle]</code>. Is there any value in exporting a symbol whose name depends on Rust name mangling?)</p>",
        "id": 207568928,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1597954269
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> I think so, e.g., you might want to have a Rust dylib that exports symbols and imports them from another Rust dylib, both using Rust name mangling</p>",
        "id": 207570671,
        "sender_full_name": "simulacrum",
        "timestamp": 1597955378
    },
    {
        "content": "<p>is rust name mangling stable though? otherwise doing that sounds fraught with peril</p>",
        "id": 207571885,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1597956007
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Require.20ABI.20for.20extern.20in.202021.20lang-team.2346/near/207571885\">said</a>:</p>\n<blockquote>\n<p>is rust name mangling stable though? otherwise doing that sounds fraught with peril</p>\n</blockquote>\n<p>It's fraught with peril anyway, because the ABI needs to match as well.</p>",
        "id": 207572202,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1597956204
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"138448\">cuviper</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Require.20ABI.20for.20extern.20in.202021.20lang-team.2346/near/207568215\">said</a>:</p>\n<blockquote>\n<p>I suppose you could use <code>#[no_mangle]</code> to intercept things that would otherwise link externally -- kind of like <code>LD_PRELOAD</code> hacks, but self-contained</p>\n</blockquote>\n<p>That's clever!</p>",
        "id": 207572407,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1597956334
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Require.20ABI.20for.20extern.20in.202021.20lang-team.2346/near/207568928\">said</a>:</p>\n<blockquote>\n<p>(I also wonder if <code>#[export]</code> should <em>imply</em> <code>#[no_mangle]</code>. Is there any value in exporting a symbol whose name depends on Rust name mangling?)</p>\n</blockquote>\n<p>I'm not a fan of it being implicit, but perhaps <code>no_mangle</code> could be an alternative to <code>name=\"...\"</code> in the <code>export</code> annotation: <code>#[export(no_mangle)]</code></p>",
        "id": 207572540,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1597956409
    },
    {
        "content": "<p>What about if <code>#[export]</code> uses the name mangling appropriate for the ABI of the symbol being exported? The <code>abi</code> keyword or argument to <code>#[export]</code> could also be added to <code>static</code> variables, since functions are only part of what can be linked.</p>",
        "id": 207572583,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1597956434
    },
    {
        "content": "<p>So this 2015/2018 definition:</p>\n<div class=\"codehilite\"><pre><span></span><code>#[no_mangle]\nextern &quot;C&quot; fn ....\n</code></pre></div>\n\n\n<p>would become:</p>\n<div class=\"codehilite\"><pre><span></span><code>#[export(no_mangle)]\nabi &quot;C&quot; fn ...\n</code></pre></div>",
        "id": 207572692,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1597956492
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"229517\">Jacob Lifshay</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Require.20ABI.20for.20extern.20in.202021.20lang-team.2346/near/207572583\">said</a>:</p>\n<blockquote>\n<p>What about if <code>#[export]</code> uses the name mangling appropriate for the ABI of the symbol being exported? The <code>abi</code> keyword or argument to <code>#[export]</code> could also be added to <code>static</code> variables, since functions are only part of what can be linked.</p>\n</blockquote>\n<p>Unfortunately, as far as I know there isn't much relation between ABI and name-mangling.</p>",
        "id": 207572804,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1597956559
    },
    {
        "content": "<p>Another way it could be done is:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"cp\">#[export(mangle=</span><span class=\"s\">&quot;C&quot;</span><span class=\"cp\">)]</span><span class=\"w\"></span>\n<span class=\"n\">abi</span><span class=\"w\"> </span><span class=\"s\">&quot;C&quot;</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"></span>\n<span class=\"cp\">#[export(mangle=</span><span class=\"s\">&quot;Win32Pascal&quot;</span><span class=\"cp\">)]</span><span class=\"w\"> </span><span class=\"c1\">// IIRC this is slightly different than C on Win32</span>\n<span class=\"n\">abi</span><span class=\"w\"> </span><span class=\"s\">&quot;system&quot;</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"></span>\n<span class=\"cp\">#[export(mangle=</span><span class=\"s\">&quot;C&quot;</span><span class=\"cp\">)]</span><span class=\"w\"></span>\n<span class=\"k\">static</span><span class=\"w\"> </span><span class=\"n\">my_variable</span>: <span class=\"nc\">UnsafeCell</span><span class=\"o\">&lt;</span><span class=\"kt\">i32</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.;</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 207573132,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1597956747
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"138448\">cuviper</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Require.20ABI.20for.20extern.20in.202021.20lang-team.2346/near/207568215\">said</a>:</p>\n<blockquote>\n<p>I suppose you could use <code>#[no_mangle]</code> to intercept things that would otherwise link externally -- kind of like <code>LD_PRELOAD</code> hacks, but self-contained</p>\n</blockquote>\n<p>you cannot define same symbol twice within a crate in any way. monomorph collector will be angry at you trying to do so.</p>",
        "id": 207573232,
        "sender_full_name": "nagisa",
        "timestamp": 1597956810
    },
    {
        "content": "<p>We could potentially add <code>#[export(mangle=\"C++\")]</code> as a future extension.</p>",
        "id": 207573254,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1597956820
    },
    {
        "content": "<p>This includes <code>declare</code> and then further attempt to to define the symbol.</p>",
        "id": 207573356,
        "sender_full_name": "nagisa",
        "timestamp": 1597956866
    },
    {
        "content": "<p>C doesn't mangle, and C++ varies from compiler to compiler (and almost certainly between different compiler versions).</p>",
        "id": 207573380,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1597956881
    },
    {
        "content": "<p>C mangles to some extent: several systems have <code>fn my_fn</code> produce the symbol <code>_my_fn</code></p>",
        "id": 207573453,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1597956934
    },
    {
        "content": "<p>_maybe_ we could support a <code>const</code> function to determine the actual name:</p>\n<p><code>#[export(mangle=my_mangle_fn)]</code></p>",
        "id": 207573522,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1597956962
    },
    {
        "content": "<p>C++ on Linux has only a few commonly used C++ manglings (only 2 that I recall), and at least Clang and G++ are interoperable.</p>",
        "id": 207573685,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1597957077
    },
    {
        "content": "<p>Reference for one of the C++ mangling schemes: <a href=\"https://itanium-cxx-abi.github.io/cxx-abi/abi.html#mangling\">https://itanium-cxx-abi.github.io/cxx-abi/abi.html#mangling</a></p>",
        "id": 207573852,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1597957159
    },
    {
        "content": "<p>So, we could use <code>#[export(mangle=\"C++-itanium\")]</code></p>",
        "id": 207574051,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1597957277
    },
    {
        "content": "<p>Or, for windows: <code>#[export(mangle=\"C++-msvc\")]</code> and maybe use a more specific string if MSVC's name mangling ever had a incompatible break.</p>",
        "id": 207574297,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1597957424
    },
    {
        "content": "<p>I'm less opposed to that than just <code>=\"C++\"</code>.</p>",
        "id": 207574310,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1597957433
    },
    {
        "content": "<p>I'm not sure about it, though. It seems like any code wishing to be cross-platform would need to set its mangling scheme conditionally. I guess that's something of an argument for <code>\"C++\"</code> meaning \"the typical mangling scheme for the target platform\", but that seems much too \"magic\".</p>",
        "id": 207574451,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1597957507
    },
    {
        "content": "<p>In any case, I think we should leave non-Rust non-C name mangling schemes for later, just making sure that we have thought about how they could fit in in the future</p>",
        "id": 207574565,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1597957564
    },
    {
        "content": "<p>Actually, now that I think about it, the Rust compiler's target should contain all the information to determine the C++ name mangling scheme unambiguously, since Rust can and often does link to C++ code.</p>",
        "id": 207574754,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1597957700
    },
    {
        "content": "<p>So, <code>x86_64-pc-windows-msvc</code> would tell rustc that it needs to use the MSVC C++ mangling scheme and <code>x86_64-unknown-linux-gnu</code> tells it to use the Linux G++ mangling scheme (itanium)</p>",
        "id": 207574990,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1597957859
    },
    {
        "content": "<p>So <code>#[export(mangle=\"C++\")]</code> should work just fine.</p>",
        "id": 207575064,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1597957913
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"229517\">Jacob Lifshay</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Require.20ABI.20for.20extern.20in.202021.20lang-team.2346/near/207574754\">said</a>:</p>\n<blockquote>\n<p>...Rust can and often does link to C++ code.</p>\n</blockquote>\n<p>Is it really supported to link to C++ functions that aren't <code>extern \"C\"</code>?</p>",
        "id": 207576208,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1597958523
    },
    {
        "content": "<blockquote>\n<p>I'm not sure about it, though. It seems like any code wishing to be cross-platform would need to set its mangling scheme conditionally.</p>\n</blockquote>\n<p>cfg_attr</p>",
        "id": 207577841,
        "sender_full_name": "Lokathor",
        "timestamp": 1597959705
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120076\">BatmanAoD (Kyle Strand)</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Require.20ABI.20for.20extern.20in.202021.20lang-team.2346/near/207576208\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"229517\">Jacob Lifshay</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Require.20ABI.20for.20extern.20in.202021.20lang-team.2346/near/207574754\">said</a>:</p>\n<blockquote>\n<p>...Rust can and often does link to C++ code.</p>\n</blockquote>\n<p>Is it really supported to link to C++ functions that aren't <code>extern \"C\"</code>?</p>\n</blockquote>\n<p>I should clarify, Rust programs often link to different C++ libraries that link to each other, like this:</p>\n<div class=\"codehilite\"><pre><span></span><code>Rust Lib &lt;-&gt; C++ Lib1 &lt;-&gt; C++ Lib2\n  ^                         ^\n  +-------------------------+\n</code></pre></div>\n\n\n<p>A good example of that is rustc linking to LLVMCore linking to LLVMCodeGen.</p>\n<p>Even if Rust doesn't currently use C++ mangling, the C++ mangling scheme still needs to be well defined for each target for the two C++ libraries to link to each other.</p>",
        "id": 207586322,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1597966222
    },
    {
        "content": "<p>Do the entry-points for those libraries not use <code>extern \"C\"</code>?</p>",
        "id": 207586569,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1597966444
    },
    {
        "content": "<blockquote>\n<p><code>pub(link)</code></p>\n</blockquote>\n<p>To be clear, this would require making <code>link</code> a keyword in this position</p>\n<p><code>pub(restricted)</code> syntax _must_ start with a keyword so the parser can know in fixed lookahead what to parse</p>",
        "id": 207593610,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1597974033
    },
    {
        "content": "<p>Given e.g. <code>struct Foo ( pub ( &gt;|&lt;</code>, do you parse a visibility restriction or a type</p>",
        "id": 207593646,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1597974079
    },
    {
        "content": "<p>It could be <code>struct Foo ( pub ( link, Type ) )</code> with a field of tuple type <code>(link, Type)</code></p>",
        "id": 207593703,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1597974151
    },
    {
        "content": "<p>And since both paths and types can be arbitrarily long, visibility restrictions must start with a keyword so the parser can decide in fixed lookahead</p>",
        "id": 207593723,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1597974204
    },
    {
        "content": "<p>IIRC it's a max of two tokens (including the keyword) at this specific location.</p>",
        "id": 207593734,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1597974226
    },
    {
        "content": "<p>I don't see new contextual keywords for <code>pub</code> as too much of a problem, but I am convinced by Josh T's argument above that <code>pub</code> isn't appropriate for this</p>",
        "id": 207652356,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1598025978
    },
    {
        "content": "<p>(Though I am certainly open to counterarguments in favor of <code>pub</code>)</p>",
        "id": 207652375,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1598025993
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120076\">BatmanAoD (Kyle Strand)</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Require.20ABI.20for.20extern.20in.202021.20lang-team.2346/near/207586569\">said</a>:</p>\n<blockquote>\n<p>Do the entry-points for those libraries not use <code>extern \"C\"</code>?</p>\n</blockquote>\n<p>No, basically all of LLVM uses C++ linkage between the different libraries. LLVM does provide an <code>extern \"C\"</code> API, but doesn't really use that API internally.</p>",
        "id": 207656685,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1598028409
    },
    {
        "content": "<p>Interesting. I assume that's only really expected to work when all these libraries are compiled and linked with the same toolchain?</p>\n<p>In that case, I think there's definitely a valid use for specifying \"toolchain-default mangling\".</p>",
        "id": 207664886,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1598033039
    },
    {
        "content": "<p>(And ABI.)</p>",
        "id": 207664939,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1598033047
    },
    {
        "content": "<p>Well, (IIUC) in theory C++ doesn't have a stable ABI. In practice, the committee has been unwilling/unable to do things which change the ABI because so many people treat it as stable. I'd think people don't expect gcc and clang compiled c++ to link together, but users definitely expect to continue to use existing precompiled c++ <code>.o</code>s and dylibs when upgrading compilers in practice.</p>",
        "id": 207688392,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1598046404
    },
    {
        "content": "<p>Like, <code>std::unique_ptr</code> can't be passed in a register. People want to fix it, and nominally, they can, because nothing about ISO C++ promises a stable ABI for <code>std::unique_ptr</code>. But because of the ABI breakage, the comittee has resisted \"fixing\" that deficiency so far.</p>",
        "id": 207688529,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1598046514
    },
    {
        "content": "<p>g++ and clang++ absolutely do link together, at least on Linux (Itanium C++ ABI)</p>",
        "id": 207689338,
        "sender_full_name": "cuviper",
        "timestamp": 1598047121
    },
    {
        "content": "<p>otherwise clang++ couldn't use libstdc++ at all</p>",
        "id": 207689346,
        "sender_full_name": "cuviper",
        "timestamp": 1598047130
    },
    {
        "content": "<p>(which is the default on Linux)</p>",
        "id": 207689354,
        "sender_full_name": "cuviper",
        "timestamp": 1598047139
    },
    {
        "content": "<p>You're absolutely correct about C++ not having a stable ABI; the supported use-case for \"toolchain-default mangling (and ABI)\" would <em>only</em> be for linking binaries generated with the same version of the same toolchain. Of course, other combinations (versions without ABI-breaking changes, g++ with clang++) would often work, but it wouldn't be considered a bug when it doesn't work.</p>",
        "id": 207695547,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1598052468
    },
    {
        "content": "<p>When/If Rust adds support for C++ mangling/ABI (or maybe earlier if needed), we can split any targets we find that use multiple different incompatible C++ compilers. For example, if it turned out that G++ and the Intel C++ compiler weren't compatible on x86_64-unknown-linux-gnu, we could split out x86_64-unknown-linux-gnu-icc as a separate target to x86_64-unknown-linux-gnu (which would use G++).</p>",
        "id": 207699673,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1598057431
    },
    {
        "content": "<p>I find the motivation for changing the keyword a bit weak -- confusion alone doesn't seem like enough to me.</p>",
        "id": 208382040,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1598640970
    },
    {
        "content": "<p>But also woah there's a lot going on in this topic beyond the original proposal</p>",
        "id": 208382098,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1598641003
    },
    {
        "content": "<p>Sorry, yeah, the connection to the original proposal is tenuous at best. I brought up my idea here because I wanted to make its connection to the original proposal clear, but I probably should have opened a separate topic elsewhere and just linked to that.</p>",
        "id": 208433764,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1598707347
    },
    {
        "content": "<p>One other motivation for changing the keyword for function definitions is that, as Amanieu pointed out, we could leave <code>extern</code> for declaration blocks, which would make the terminology for discussing the two types of \"extern functions\" much clearer.</p>",
        "id": 208433859,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1598707467
    },
    {
        "content": "<p>I do agree that there is no good way to discuss <code>extern \"C\" fn foo() { }</code> as opposed to external linkage</p>",
        "id": 208890294,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1599082130
    },
    {
        "content": "<p>I am still not inclined to make changes here for the time being just because it doesn't seem worth it</p>",
        "id": 208890307,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1599082139
    },
    {
        "content": "<p>Side note: I'd also like to see a notion of ABI for function pointers.</p>",
        "id": 208891098,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599082629
    },
    {
        "content": "<p>Including being generic over ABI.</p>",
        "id": 208891169,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599082671
    },
    {
        "content": "<p>Function pointers can (and must) have ABI properly declared, though you cannot be generic over it. Niko has opened a MCP (first one even I think) about this but opted to close it eventually I think.</p>",
        "id": 208891467,
        "sender_full_name": "simulacrum",
        "timestamp": 1599082834
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Require.20ABI.20for.20extern.20in.202021.20lang-team.2346/near/208891169\">said</a>:</p>\n<blockquote>\n<p>Including being generic over ABI.</p>\n</blockquote>\n<p>+1, this entire function would be unnecessary if that were possible <a href=\"https://gitlab.com/YottaDB/Lang/YDBRust/-/blob/master/src/simple_api/mod.rs#L959-977\">https://gitlab.com/YottaDB/Lang/YDBRust/-/blob/master/src/simple_api/mod.rs#L959-977</a></p>",
        "id": 208891492,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599082853
    },
    {
        "content": "<p>On the topic of generics for <code>fn</code>, someone on discord yesterday was wishing they could have non-<code>'static</code> functions pointers, for when they're generating executable code at runtime (which they also deallocate later).</p>",
        "id": 208891544,
        "sender_full_name": "scottmcm",
        "timestamp": 1599082894
    },
    {
        "content": "<p>I have been thinking off and on about proposing an edition-break that makes fn(...) not a function pointer type, instead requiring &amp;'static fn(...)</p>",
        "id": 208891737,
        "sender_full_name": "simulacrum",
        "timestamp": 1599082987
    },
    {
        "content": "<p>Since we somewhat regularly hit confusion over function pointers being non-null in unsafe code for example. But I'm not sold on the idea given how wide spread the breakage would be.</p>",
        "id": 208891902,
        "sender_full_name": "simulacrum",
        "timestamp": 1599083054
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> I'd like that as well.</p>",
        "id": 208892145,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599083179
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> Here's another interesting usage...</p>",
        "id": 208892165,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599083196
    },
    {
        "content": "<p>Inside the Linux kernel, you're allowed to use things like AVX or SSE, <em>only</em> if you first save off userspace state and restore it later; otherwise, you can't.</p>",
        "id": 208892205,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599083223
    },
    {
        "content": "<p>It'd be interesting to have a safe function that retrieves a callable function pointer to a function using such instructions, with a lifetime of \"until you clean up the state\".</p>",
        "id": 208892261,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599083255
    },
    {
        "content": "<p>Hmm, if those two ideas were combined then that function could return a guard that derefs to a <code>fn</code> <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>\n<p>I guess one weirdness with <code>&amp;fn</code> is that it should be a thin pointer but it's still not <code>Sized</code>...</p>",
        "id": 208895279,
        "sender_full_name": "scottmcm",
        "timestamp": 1599084968
    },
    {
        "content": "<p>Would <code>fn&lt;'a&gt;</code> for non-<code>static</code> function pointers be a breaking change?</p>",
        "id": 208895592,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1599085153
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> we have to make it sized, because otherwise it's backwards incompatible I think when passing to <code>fn foo&lt;T&gt;(v: T) {}</code> functions</p>",
        "id": 208896823,
        "sender_full_name": "simulacrum",
        "timestamp": 1599085916
    },
    {
        "content": "<p>Well, <code>&amp;'static fn</code> would still be sized of course.  (Which is what I'd understood would be the replacement for what's currently typed as just <code>fn</code>.)</p>",
        "id": 208904745,
        "sender_full_name": "scottmcm",
        "timestamp": 1599091386
    },
    {
        "content": "<p>Why would <code>&amp;'a fn</code> not be sized as well?</p>",
        "id": 208906099,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1599092364
    },
    {
        "content": "<p>Ah, right, yes.</p>",
        "id": 208907266,
        "sender_full_name": "simulacrum",
        "timestamp": 1599093511
    },
    {
        "content": "<p>having <code>fn</code> pointers with generic ABI and lifetimes sounds awesome, I'm writing a JIT compiler (for the <a href=\"https://salsa.debian.org/Kazan-team/kazan\">Kazan Vulkan driver</a>) where scoping the <code>fn</code> pointers to the lifetime of the allocated memory would make it much nicer.</p>\n<p>If <code>fn</code> were to need to be a pointer/reference to <code>Sized</code>, the pointee could be a zero-sized type of some sort.</p>",
        "id": 208989874,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1599148824
    }
]