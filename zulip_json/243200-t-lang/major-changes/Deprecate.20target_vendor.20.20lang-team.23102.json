[
    {
        "content": "<p>A new proposal has been announced: <a href=\"https://github.com/rust-lang/lang-team/issues/102\">Deprecate target_vendor  #102</a>. It will be announced at the next meeting to try and draw attention to it, but usually MCPs are not discussed during triage meetings. If you think this would benefit from discussion amongst the team, consider proposing a design meeting.</p>",
        "id": 244751977,
        "sender_full_name": "triagebot",
        "timestamp": 1625256573
    },
    {
        "content": "<p><span class=\"user-group-mention\" data-user-group-id=\"1977\">@T-lang</span>: Proposal <a href=\"https://github.com/rust-lang/lang-team/issues/102#issuecomment-873235819\">#102</a> has been seconded, and will be approved in 10 days if no objections are raised.</p>",
        "id": 244752522,
        "sender_full_name": "triagebot",
        "timestamp": 1625256899
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> (psst, discussion goes in Zulip. ;) )</p>",
        "id": 244752611,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625256961
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"123586\">@nagisa</span> Thank you!</p>",
        "id": 244752653,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625256967
    },
    {
        "content": "<p>The <code>gba</code> project <em>had</em> been using target_vendor to distinguish the GBA from other similar CPUs. However, when a target for it was added to the compiler it was added as <code>thumbv4t-none-eabi</code>, and it's actually too hard to use any non-standard target info so we just gave up on doing that at all.</p>",
        "id": 244752665,
        "sender_full_name": "Lokathor",
        "timestamp": 1625256975
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> Once the UWP and Fortanix targets set target_abi, and the Apple targets set target_family, I propose to carefully deprecate the target_vendor field, by adding a warn-by-default future-compatibility lint. target_vendor should continue to work for several years. We may eventually choose to remove it in a future edition.</p>",
        "id": 244752790,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625257069
    },
    {
        "content": "<p>In other words, I think that <code>target_vendor</code> could be useful, but other parts of the rust toolchain overall make it next to impossible for it to be used easily.</p>",
        "id": 244752793,
        "sender_full_name": "Lokathor",
        "timestamp": 1625257069
    },
    {
        "content": "<p>I believe that there are other avenues to differentiate targets like these, still.</p>",
        "id": 244752873,
        "sender_full_name": "nagisa",
        "timestamp": 1625257097
    },
    {
        "content": "<p>if GBA is materially different from bare-metal thumbv4t, then perhaps cpu architecture should be different?</p>",
        "id": 244752951,
        "sender_full_name": "nagisa",
        "timestamp": 1625257150
    },
    {
        "content": "<p>The CPU is the same, the mmio is not</p>",
        "id": 244752980,
        "sender_full_name": "Lokathor",
        "timestamp": 1625257171
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"123586\">@nagisa</span> Depends on the nature of the differences. If it had different instructions I'd say change the architecture name; if it has the same instruction set but different available interfaces I'd say change the \"OS\".</p>",
        "id": 244753068,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625257209
    },
    {
        "content": "<p>Don't most baremetal CPUs have their own ideas about the peripherals?</p>",
        "id": 244753070,
        "sender_full_name": "nagisa",
        "timestamp": 1625257210
    },
    {
        "content": "<p>thumbv4t is <em>just</em> a cpu, thus has no mmio assumptions, but the GBA is a specific device, thus has mmio, and even a small bios you can call.</p>",
        "id": 244753099,
        "sender_full_name": "Lokathor",
        "timestamp": 1625257233
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123586\">nagisa</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Deprecate.20target_vendor.20.20lang-team.23102/near/244753070\">said</a>:</p>\n<blockquote>\n<p>Don't most baremetal CPUs have their own ideas about the peripherals?</p>\n</blockquote>\n<p>For something with no runtime discoverability, you may need the target to distinguish.</p>",
        "id": 244753116,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625257247
    },
    {
        "content": "<p>One way a \"baremetal\" could differ is in its… yeah, firmware APIs. At which point I would vary the ABI field.</p>",
        "id": 244753137,
        "sender_full_name": "nagisa",
        "timestamp": 1625257259
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123586\">nagisa</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Deprecate.20target_vendor.20.20lang-team.23102/near/244753137\">said</a>:</p>\n<blockquote>\n<p>One way a \"baremetal\" could differ is in its… yeah, firmware APIs. At which point I would vary the ABI field.</p>\n</blockquote>\n<p>Honestly, I'd call that \"OS\" rather than \"ABI\", though the difference isn't critical.</p>",
        "id": 244753165,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625257276
    },
    {
        "content": "<p>setting the OS to be \"gba\" would be a sane way to handle this distinction</p>",
        "id": 244753167,
        "sender_full_name": "Lokathor",
        "timestamp": 1625257278
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> As an alternative, we could choose to emit a warning if you use it to match something <em>other</em> than fortanix or uwp, and defer warning about it for those. However, I don't actually think that's a good idea. Once we have <code>target_abi</code> set for those (and <code>target_family</code> for apple targets), the deprecation can give a structured suggestion for exactly what to switch to.</p>",
        "id": 244753267,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625257330
    },
    {
        "content": "<p>I don't think i like the abi field being changed because the call abi is not different. You use the normal call abi rules. it's other parts of the environment that's different.</p>",
        "id": 244753282,
        "sender_full_name": "Lokathor",
        "timestamp": 1625257344
    },
    {
        "content": "<p>Part of the issue here is that \"environment\" is overloaded.</p>",
        "id": 244753372,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625257409
    },
    {
        "content": "<p>if we add a new <code>linux-gnu</code> arch, would we call it <code>NEW-linux-gnu</code>, or still put <code>unknown</code> in there to align with its peers?</p>",
        "id": 244753380,
        "sender_full_name": "cuviper",
        "timestamp": 1625257414
    },
    {
        "content": "<p><del>@<strong>cuviper</strong> I think that depends on if we're the first ones to add it.</del><br>\nEDIT: retracted, if we're adding a <code>linux-gnu</code> or <code>linux-musl</code> target, by definition we're not the first ones to add it, since glibc or musl would need support.</p>",
        "id": 244753403,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625257427
    },
    {
        "content": "<p>first among whom?</p>",
        "id": 244753474,
        "sender_full_name": "cuviper",
        "timestamp": 1625257449
    },
    {
        "content": "<p>Toolchains.</p>",
        "id": 244753479,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625257455
    },
    {
        "content": "<p>What I think I would like here is a way for rustc to add an OS to a no-os target profile but otherwise use everything else for the target, including any tier 2 pre-built artifacts from rustup.</p>",
        "id": 244753500,
        "sender_full_name": "Lokathor",
        "timestamp": 1625257476
    },
    {
        "content": "<p><del>If we're inventing the target name I think we could choose to call it <code>newarch-linux-gnu</code>. If there's an existing toolchain we need to be compatible with, we should be compatible with that toolchain.</del><br>\nEDIT: retracted, if we're adding a <code>linux-gnu</code> or <code>linux-musl</code> target there would already be support in the underlying library by definition, so we'd want to be compatible with that, and it's likely to use <code>newarch-unknown-linux-env</code></p>",
        "id": 244753529,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625257499
    },
    {
        "content": "<p>So then, for baremetals, if we utilize OS to define the peripherals of the SoC; how do you differentiate between different OSes (e.g. FreeRTOS?) that you may want to run on those SoCs? You will still want to know what set of peripherals you're interacting, but also which RTOS you have on hand.</p>",
        "id": 244753539,
        "sender_full_name": "nagisa",
        "timestamp": 1625257503
    },
    {
        "content": "<p>\"gnu\" implies there's already glibc support, at least, if not gcc etc.</p>",
        "id": 244753580,
        "sender_full_name": "cuviper",
        "timestamp": 1625257528
    },
    {
        "content": "<p>taking the gba example, one could run <a href=\"https://github.com/rust-lang/RTOS/issues/1\">RTOS#1</a> and <a href=\"https://github.com/rust-lang/RTOS/issues/2\">RTOS#2</a>, both of which provide the necessary primitives to implement <code>libstd</code>. What would the gba targets look like?</p>",
        "id": 244753690,
        "sender_full_name": "nagisa",
        "timestamp": 1625257570
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"138448\">@cuviper</span> That's true. So it may be a moot point for linux-gnu targets, in practice, and only apply to targets we originate and add first.</p>",
        "id": 244753692,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625257573
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"123586\">@nagisa</span> good point</p>",
        "id": 244753715,
        "sender_full_name": "Lokathor",
        "timestamp": 1625257591
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Deprecate.20target_vendor.20.20lang-team.23102/near/244753372\">said</a>:</p>\n<blockquote>\n<p>Part of the issue here is that \"environment\" is overloaded.</p>\n</blockquote>\n<p>Arguably, something like \"UWP\" is kind of an environment, not exactly an OS. <code>x86_64-unknown-windows-uwp</code> would make sense, except that we still <em>also</em> need to distinguish <code>gnu</code> and <code>msvc</code>...</p>",
        "id": 244753826,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625257664
    },
    {
        "content": "<p>I think ABI is the closest match we have.</p>",
        "id": 244753939,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625257720
    },
    {
        "content": "<p>\"vendor\" definitely isn't; UWP isn't a vendor.</p>",
        "id": 244753950,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625257726
    },
    {
        "content": "<p>So we do have a couple of situations where there I think aren't a way to distinguish between two targets based on target_* cfgs: gnueabi and gnueabihf for arm targets.</p>",
        "id": 244754105,
        "sender_full_name": "nagisa",
        "timestamp": 1625257818
    },
    {
        "content": "<p>they both are <code>target_env=\"gnu\"</code></p>",
        "id": 244754137,
        "sender_full_name": "nagisa",
        "timestamp": 1625257841
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"123586\">@nagisa</span> We have <code>target_abi</code> for exactly that purpose.</p>",
        "id": 244754158,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625257852
    },
    {
        "content": "<p>gnueabi has <code>target_abi=\"eabi\"</code>, and gnueabihf has <code>target_abi=\"eabihf\"</code>.</p>",
        "id": 244754185,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625257865
    },
    {
        "content": "<p>Huh, <code>--print cfg</code> does not output these <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 244754211,
        "sender_full_name": "nagisa",
        "timestamp": 1625257881
    },
    {
        "content": "<p><code>target_env</code> for both of these is <code>gnu</code> though.</p>",
        "id": 244754324,
        "sender_full_name": "nagisa",
        "timestamp": 1625257933
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123586\">nagisa</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Deprecate.20target_vendor.20.20lang-team.23102/near/244754324\">said</a>:</p>\n<blockquote>\n<p><code>target_env</code> for both of these is <code>gnu</code> though.</p>\n</blockquote>\n<p>Yeah, that's intentional.</p>",
        "id": 244754354,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625257949
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123586\">nagisa</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Deprecate.20target_vendor.20.20lang-team.23102/near/244754211\">said</a>:</p>\n<blockquote>\n<p>Huh, <code>--print cfg</code> does not output these <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>\n</blockquote>\n<p>I'll file that as a bug.</p>",
        "id": 244754364,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625257954
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Deprecate.20target_vendor.20.20lang-team.23102/near/244754185\">said</a>:</p>\n<blockquote>\n<p>gnueabi has <code>target_env=\"eabi\"</code>, and gnueabihf has <code>target_env=\"eabihf\"</code>.</p>\n</blockquote>\n<p>these should have said <code>target_abi</code></p>",
        "id": 244754400,
        "sender_full_name": "cuviper",
        "timestamp": 1625257970
    },
    {
        "content": "<p>seems hard to be fully precise if both are just <code>gnu</code></p>",
        "id": 244754437,
        "sender_full_name": "Lokathor",
        "timestamp": 1625257999
    },
    {
        "content": "<p>env is gnu, abi is the other stuff</p>",
        "id": 244754463,
        "sender_full_name": "cuviper",
        "timestamp": 1625258022
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"123586\">@nagisa</span> <a href=\"https://github.com/rust-lang/rust/issues/80970#issuecomment-873243549\">https://github.com/rust-lang/rust/issues/80970#issuecomment-873243549</a></p>",
        "id": 244754469,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625258027
    },
    {
        "content": "<p>there's also env=musl</p>",
        "id": 244754474,
        "sender_full_name": "cuviper",
        "timestamp": 1625258031
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"138448\">cuviper</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Deprecate.20target_vendor.20.20lang-team.23102/near/244754400\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Deprecate.20target_vendor.20.20lang-team.23102/near/244754185\">said</a>:</p>\n<blockquote>\n<p>gnueabi has <code>target_env=\"eabi\"</code>, and gnueabihf has <code>target_env=\"eabihf\"</code>.</p>\n</blockquote>\n<p>these should have said <code>target_abi</code></p>\n</blockquote>\n<p><span aria-label=\"face palm\" class=\"emoji emoji-1f926\" role=\"img\" title=\"face palm\">:face_palm:</span> Sigh, typo.</p>",
        "id": 244754484,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625258038
    },
    {
        "content": "<p>Sorry for the gratuitous confusion there.</p>",
        "id": 244754540,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625258061
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"123586\">@nagisa</span> ^</p>",
        "id": 244754548,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625258064
    },
    {
        "content": "<p>I think this target_abi RFC just hasn't been implemented, perhaps.</p>",
        "id": 244754633,
        "sender_full_name": "nagisa",
        "timestamp": 1625258131
    },
    {
        "content": "<p>there are no tests for it, or any references at all in the rustc codebase. But regardless, I think we can accept that it is a likely option to utilize to differentiate in the future.</p>",
        "id": 244754725,
        "sender_full_name": "nagisa",
        "timestamp": 1625258168
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123586\">nagisa</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Deprecate.20target_vendor.20.20lang-team.23102/near/244754633\">said</a>:</p>\n<blockquote>\n<p>I think this target_abi RFC just hasn't been implemented, perhaps.</p>\n</blockquote>\n<p>Ah, you're right. I thought it had been partially implemented.</p>",
        "id": 244754766,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625258204
    },
    {
        "content": "<p>/me updates the MCP.</p>",
        "id": 244754771,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625258209
    },
    {
        "content": "<p>Done.</p>",
        "id": 244755103,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625258434
    },
    {
        "content": "<p>Hm, it feels kinda weird to call UWP an ABI. But I'm not sure of a better way to do it and I guess it's no weirder than \"vendor\".</p>",
        "id": 244756238,
        "sender_full_name": "Chris Denton",
        "timestamp": 1625259125
    },
    {
        "content": "<p>Yeah, I'm not suggesting it's <em>exactly</em> accurate, but it seems more accurate than \"vendor\".</p>",
        "id": 244756626,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625259349
    },
    {
        "content": "<p>I sorta wish ABI strictly meant the C call ABI, and we use another name for environment variants (in either OS or Hardware)</p>",
        "id": 244757095,
        "sender_full_name": "Lokathor",
        "timestamp": 1625259646
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Deprecate.20target_vendor.20.20lang-team.23102/near/244757095\">said</a>:</p>\n<blockquote>\n<p>I sorta wish ABI strictly meant the C call ABI, and we use another name for environment variants (in either OS or Hardware)</p>\n</blockquote>\n<p>i think the usage i've tended to hear is \"calling convention\" for the part of the the ABI that specifies how functions get called (registers, stack frames, etc), while ABI includes stuff like object and executable formats, available system library interfaces, etc</p>",
        "id": 244757789,
        "sender_full_name": "Taylor Yu [they/she]",
        "timestamp": 1625260148
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Deprecate.20target_vendor.20.20lang-team.23102/near/244753167\">said</a>:</p>\n<blockquote>\n<p>setting the OS to be \"gba\" would be a sane way to handle this distinction</p>\n</blockquote>\n<p>I actually ended up doing this for <a href=\"https://github.com/chorman0773/SNES-Dev\">https://github.com/chorman0773/SNES-Dev</a> in config-sh, because I found out about the <code>wdc</code> vendor, which, when finalizing the target system  I chose to leave intact as the default vendor for <code>w65-*</code>. </p>\n<p>From the MCP:</p>\n<blockquote>\n<p>For future new targets, I propose to omit the \"vendor\" component entirely unless needed for compatibility with naming already used by other existing widespread toolchains</p>\n</blockquote>\n<p>For this, I have to ask what \"widespread\" means? Does it mean that if compatibility for existing config-sh targets is desired for the target, it should leave the vendor intact, or does it consider future targets? Would it include forks of config-sh? If so, I could make the argument, for any target really, of \"I intend to extend xyz tool to support this in the reasonable future\". If not, however, it could interfere with the ability to add new targets to rust and eventually support them with with other toolchains. If config-sh is not considered at all for these purposes, then I'd raise a concern about that, given the tools I work on and with that take config.sub in particular as a normative definition for target tuples, that would reasonably need or want to interact with rust targets (<a href=\"https://github.com/chorman0773/rust-autotools\">https://github.com/chorman0773/rust-autotools</a>, <a href=\"https://github.com/chorman0773/rust-target-tuples\">https://github.com/chorman0773/rust-target-tuples</a>, <a href=\"https://github.com/LightningCreations/lccc\">https://github.com/LightningCreations/lccc</a>, <a href=\"https://github.com/LightingCreations/lc-binutils\">https://github.com/LightingCreations/lc-binutils</a>).</p>",
        "id": 244758043,
        "sender_full_name": "Connor Horman",
        "timestamp": 1625260328
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> So, two separate things...</p>",
        "id": 244760584,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625262112
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> First, I don't have the strong impression that autoconf's <code>config.*</code> would have a <em>hard</em> requirement that the vendor field exist. Second, I think it's reasonable to distinguish between \"GCC or LLVM or binutils or glibc or musl or similar has implemented this under a specific target name and we should be compatible with that\" from \"this is a proposed new target for various things, including Rust\".</p>",
        "id": 244761131,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625262553
    },
    {
        "content": "<p>If someone is still in the \"I intend to\" phase, it's reasonable for us to provide input on the utility of the vendor field.</p>",
        "id": 244761143,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625262579
    },
    {
        "content": "<p>Also, as far as I can tell, there are <em>many</em> Rust targets that don't exist in config.{sub,guess}..</p>",
        "id": 244761504,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625262876
    },
    {
        "content": "<p>Not because they can't, but because nobody has added them.</p>",
        "id": 244761518,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625262893
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Deprecate.20target_vendor.20.20lang-team.23102/near/244761131\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> First, I don't have the strong impression that autoconf's <code>config.*</code> would have a <em>hard</em> requirement that the vendor field exist. Second, I think it's reasonable to distinguish between \"GCC or LLVM or binutils or glibc or musl or similar has implemented this under a specific target name and we should be compatible with that\" from \"this is a proposed new target for various things, including Rust\".</p>\n</blockquote>\n<p>As far as I can tell, the vendor field in <code>config.sub</code> is guaranteed to be produced in it's ouput (but is not required in the input, many basic_machines will infer the vendor component from the architecture, and I think a couple infer from the os component). So then the question would become whether rust targets are considered to be in canonical form. </p>\n<p>Turning to the second point, sure general intention may not be applicable, but if the intention is specifically to support the target in GCC or LLVM, and significant steps towards that have been taken, it could be reasonably necessary for compatibiltiy. See for example, <code>w65-wdc-snes-elf</code>, I've added support for this (canonical) target to a fork of <a href=\"https://github.com/chorman0773/config-sh\">config-sh</a> and <a href=\"https://github.com/chorman0773/binutils-gdb\">binutils-gdb</a>, and intend to support it in gcc after binutils is complete. As I also intend to add support for this to rust, I would argue that compatibility is desired, even though the gcc support does not exist, and nothing is yet upstream (though patches for the sys component <code>snes-elf</code> and several others in that family, are on the config mailing list, with indeterminate status), as someone who has had a lot of <em>fun</em> attempting to bridge autotools and rustc targets.</p>",
        "id": 244761757,
        "sender_full_name": "Connor Horman",
        "timestamp": 1625263121
    },
    {
        "content": "<p>That's the kind of thing the Candidate Target Policy is supposed to help coordinate.</p>",
        "id": 244764233,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625265154
    },
    {
        "content": "<p>But also, I think that again comes down to what it takes to support a target in GCC/config.guess/config.sub.</p>",
        "id": 244764260,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625265179
    },
    {
        "content": "<p>Copying over what I accidentally posted to the Github issue:</p>\n<p>With my autoconf maintainer hat on, I endorse all of the proposal _except_ for:</p>\n<blockquote>\n<p>For future new targets, I propose to omit the \"vendor\" component entirely unless needed for compatibility with naming already used by other existing widespread toolchains. Whenever we create a new target name, we should omit the \"vendor\" element entirely, as we did for wasm32-wasi</p>\n</blockquote>\n<p>Omitting the \"vendor\" element entirely is not safe, as it triggers a \"this must not be in canonical form\" parsing mode in a variety of tools (most prominently <code>config.sub</code> but also IIRC there are independently developed system-name parsers in CMake, Ansible, etc.), which may lead to surprising errors. You should always set the \"vendor\" element to a dummy value; if there is no reason to choose a different one, use <code>unknown</code>.  In particular <code>wasm32-wasi</code> should become <code>wasm32-unknown-wasi</code> as soon as practical.</p>\n<p>It would be appreciated if the Rust community would in future discuss the naming of new targets with <code>config-patches@gnu.org</code>; this will help avoid accidental name collisions and ensure that <code>config.sub</code> handles them properly.  (It's not necessary for a system to support <code>config.guess</code> for us to want to know about it; many existing bare-metal and embedded contexts already don't.)  We would also like to hear about existing Rust targets that config.sub doesn't yet recognize.</p>",
        "id": 244770440,
        "sender_full_name": "Zack Weinberg",
        "timestamp": 1625271777
    },
    {
        "content": "<p>Semi-relatedly, I'm happy to advise (innn my copious free time) on any issues related to coordination between Rust and GNU projects.</p>",
        "id": 244770580,
        "sender_full_name": "Zack Weinberg",
        "timestamp": 1625271940
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"424715\">@Zack Weinberg</span> The name <code>wasm32-wasi</code> isn't likely to change; it's a stable target name.</p>",
        "id": 244771062,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625272528
    },
    {
        "content": "<p>It'd certainly help to have input in terms of \"what kinds of things does config.sub have trouble parsing\", though, for future reference.</p>",
        "id": 244771117,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625272580
    },
    {
        "content": "<p>All that said, while I'd like to see future target names omit the vendor field, that's a less important part of this proposal, and I may separate that out to focus on the deprecation of and transition away from <code>cfg(target_vendor)</code>.</p>",
        "id": 244771148,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625272646
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"424715\">Zack Weinberg</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Deprecate.20target_vendor.20.20lang-team.23102/near/244770440\">said</a>:</p>\n<blockquote>\n<p>Copying over what I accidentally posted to the Github issue:</p>\n<p>With my autoconf maintainer hat on, I endorse all of the proposal _except_ for:</p>\n<blockquote>\n<p>For future new targets, I propose to omit the \"vendor\" component entirely unless needed for compatibility with naming already used by other existing widespread toolchains. Whenever we create a new target name, we should omit the \"vendor\" element entirely, as we did for wasm32-wasi</p>\n</blockquote>\n<p>Omitting the \"vendor\" element entirely is not safe, as it triggers a \"this must not be in canonical form\" parsing mode in a variety of tools (most prominently <code>config.sub</code> but also IIRC there are independently developed system-name parsers in CMake, Ansible, etc.), which may lead to surprising errors. You should always set the \"vendor\" element to a dummy value; if there is no reason to choose a different one, use <code>unknown</code>.  In particular <code>wasm32-wasi</code> should become <code>wasm32-unknown-wasi</code> as soon as practical.</p>\n</blockquote>\n<p>Yeah, I had the same thought. My tools that parse targets also have the same \"feature\" (that all canonical forms of targets have a vendor field).</p>\n<blockquote>\n<p>We would also like to hear about existing Rust targets that config.sub doesn't yet recognize.</p>\n</blockquote>\n<p>I could probably actually compile that list, as I've got the stuff setup for testing that manually pretty well done (and could probably automate it fairly well). I've already identified a few that config.sub doesn't support (and I also would be willing to add them to <code>config.sub</code>).</p>",
        "id": 244771232,
        "sender_full_name": "Connor Horman",
        "timestamp": 1625272768
    },
    {
        "content": "<p><code>cfg(target_vendor = \"apple\")</code> is a semi-common way to do <code>cfg(any(target_os = \"macos\", target_os = \"tvos\", target_os = \"ios\"))</code>, although it also handles the hypothetical <code>target_os = \"watchos\"</code> (which takes a special build of the compiler at the moment).</p>\n<p>IDK if this is <em>really</em> an argument for keeping it, so much as describing a hard-to-replace use that it currently has.</p>\n<p>In the past, I've stated that it's a dodgy hack to work around the lack of some kind of <code>target_family = \"darwin\"</code>,  although I had been told that couldn't be added, because target_family was single-value and too many build scripts check for <code>env::var(CARGO_CFG_TARGET_FAMILY) == \"unix\"</code>... which... I've done. Looking over <a href=\"https://grep.app/search?q=CARGO_CFG_TARGET_FAMILY\">https://grep.app/search?q=CARGO_CFG_TARGET_FAMILY</a>, I'm... not alone.</p>\n<p>Obviously, using <code>target_vendor</code> for that includes the assumption that Apple will never release a non-Darwin OS... while seems somewhat safe in the short term (even the small OS that runs on the macbook touchbars (eOS/BridgeOS) is a stripped down variant of Darwin), but could very reasonably change further in the future...</p>",
        "id": 244771444,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1625273080
    },
    {
        "content": "<p>ah, i missed that this is in the proposal as target_family = \"apple\". that name seems fine to me (it has the same assumption but avoids the ambiguity given that rust already calls macos darwin in the last part of the target triple).</p>\n<p>That said, it would likely break a lot of build scripts that currently work on apple...</p>",
        "id": 244771519,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1625273177
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"209168\">@Thom Chiovoloni</span> I'm not proposing to break existing code that uses <code>target_vendor</code>. It'd get a deprecation warning, but cap-lints would suppress that for dependencies. (And cargo's machinery for surfacing future-incompatibility warnings would flag it.)</p>",
        "id": 244772436,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625274604
    },
    {
        "content": "<p>right, i'm more concernted about the suggestion to change target_family (or, particularly, what CARGO_CFG_TARGET_FAMILY returns for build scripts, since if both <code>apple</code> and <code>unix</code> are set, it should be <code>CARGO_CFG_TARGET_FAMILY=\"apple,unix\"</code>, but lots of existing code tests for <code>env::var(\"CARGO_CFG_TARGET_FAMILY\").unwrap() == \"unix\"</code>.</p>",
        "id": 244772488,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1625274704
    },
    {
        "content": "<p>i guess that's more of a tangential concern — even without a replacement for <code>target_vendor = \"apple\"</code> it's not really a reason not to deprecate it</p>",
        "id": 244772531,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1625274734
    },
    {
        "content": "<p>(and i may be over-worried. it certainly seems like it would be a problem, but it would be to check with crater... although i remember hearing it's linux only...)</p>",
        "id": 244772604,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1625274862
    },
    {
        "content": "<p>Ah! I didn't actually realize that apple had <code>target_family</code> already set.</p>",
        "id": 244772956,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625275495
    },
    {
        "content": "<p>I updated the proposal to make that particular change optional.</p>",
        "id": 244773171,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625275877
    },
    {
        "content": "<p>We can evaluate how much we think it'll help vs how much it might break existing build scripts that parse the family incorrectly.</p>",
        "id": 244773174,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625275896
    },
    {
        "content": "<blockquote>\n<p>In particular wasm32-wasi should become wasm32-unknown-wasi as soon as practical.</p>\n</blockquote>\n<p>FWIW I think it'd be great if target triples could be simplified to remove that \"vendor\" field... literally <em>every single time</em> I need to pass a triple, I have to go somewhere and copy-paste it. As far as I am concerned, the current triple names are opaque blobs that only the machine can really keep track of: I know where I can go to copy-paste the triple for \"32bit linux\", but I entirely gave up trying to remember this one (even though I actually need it fairly frequently).</p>",
        "id": 244792582,
        "sender_full_name": "RalfJ",
        "timestamp": 1625303017
    },
    {
        "content": "<p>possibly I could remember <code>i686-linux-gnu</code> or <code>x86_64-windows-msvc</code>, but where to put the useless \"unknown\" or \"pc\" seems entirely random</p>",
        "id": 244792629,
        "sender_full_name": "RalfJ",
        "timestamp": 1625303060
    },
    {
        "content": "<p>So I am actually quite happy about target names like <code>wasm32-wasi</code> that are not just computer- but also human readable and memorable. ;)</p>",
        "id": 244792640,
        "sender_full_name": "RalfJ",
        "timestamp": 1625303102
    },
    {
        "content": "<p>I'd love if this proposal was extended to suggest that rustc should accept target triples without the vendor field in them... but I have the impression that this would get quite a bit of pushback, sadly. Since it looks like everyone agrees that the vendor field is useless, I'd hope that some day we can remove it entirely from the user-visible interface, instead of forcing users to remember arcane runes by heart that long lost their usefulness.</p>",
        "id": 244792716,
        "sender_full_name": "RalfJ",
        "timestamp": 1625303240
    },
    {
        "content": "<p>Debian doesn't use <code>-unknown-</code> either in filesystem paths. On my system I have <code>/usr/aarch64-linux-gnu</code>, <code>/usr/riscv64-linux-gnu</code>, <code>/usr/x86_64-w64-mingw32</code>, <code>/lib/x86_64-linux-gnu/</code> and <code>/lib/x86_64-linux-musl/</code>.</p>",
        "id": 244793059,
        "sender_full_name": "bjorn3",
        "timestamp": 1625303633
    },
    {
        "content": "<p>We already support multiple target_family values per target.</p>",
        "id": 244793519,
        "sender_full_name": "nagisa",
        "timestamp": 1625304236
    },
    {
        "content": "<p>as of <a href=\"https://github.com/rust-lang/rust/pull/84072\">https://github.com/rust-lang/rust/pull/84072</a></p>",
        "id": 244793573,
        "sender_full_name": "nagisa",
        "timestamp": 1625304260
    },
    {
        "content": "<p>so <code>cfg(all(target_family=\"apple\", target_family=\"unix\"))</code> can very well hold true.</p>",
        "id": 244793577,
        "sender_full_name": "nagisa",
        "timestamp": 1625304278
    },
    {
        "content": "<p>No idea what cargo would do with environment variables though ^^</p>",
        "id": 244793600,
        "sender_full_name": "nagisa",
        "timestamp": 1625304345
    },
    {
        "content": "<p>I guess it would be the same as what it does for <code>target_feature</code>?</p>",
        "id": 244793679,
        "sender_full_name": "nagisa",
        "timestamp": 1625304469
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123586\">nagisa</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Deprecate.20target_vendor.20.20lang-team.23102/near/244793600\">said</a>:</p>\n<blockquote>\n<p>No idea what cargo would do with environment variables though ^^</p>\n</blockquote>\n<p>Multi-valued cfgs (currently) are comma-separated, so it should come through as \"apple,unix\" (maybe the order would be another way). This might be fine, but i think it has a real risk of breaking macos/ios support on existing <a href=\"http://build.rs\">build.rs</a> code that just tests that CARGO_CFG_TARGET_FAMILY == \"unix\"...</p>\n<p>However, one way to test if my fear is founded occurred to me while reading that issue when you mentioned <code>cfg(target_family = \"x86\")</code>. I suspect if we did a crater run to see how much bustage occurs from making something like adding target_family = \"x86\" to x86_64-unknown-linux-gnu (or rather, whatever linux target it is that crater prefers to run).</p>\n<p>Concretely, I suspect a lot would break if <code>CARGO_CFG_TARGET_FAMILY</code> started to come through as <code>\"unix,x86\"</code> on x86 linux — I think it would break almost all the build scripts that look at that env var... <em>but</em> I could be wrong, and if that doesn't cause massive breakage, it seems like a very safe bet that adding <code>\"apple\"</code> to the target_family on darwin-variants would be fine as well.</p>\n<p>Just for clarity: I'm mentioning x86 linux here since i believe crater supports it, and I also believe crater does not support macos (This might be wrong). The test would function as a proxy for macos, or could more broadly be seen as testing that additions to <code>target_family</code> can be done in a likely-nonbreaking way.</p>\n<p>I'm also explicitly not saying that I think x86 targets should all have <code>target_family=\"x86\"</code> — just that it seems plausible, and likely to function as a canary that may indicate how fragile <code>target_family</code> handling is in real-world <a href=\"http://build.rs\">build.rs</a> scripts</p>",
        "id": 244803533,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1625316248
    },
    {
        "content": "<p>(I guess this is getting off-topic, but am unsure where to move it since adding a new topic in the MCP stream would not be correct, really)</p>",
        "id": 244803557,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1625316279
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"209168\">@Thom Chiovoloni</span> yes, crater only supports x86_64 Linux (this has given <a href=\"http://docs.rs\">docs.rs</a> trouble since they use the same sandbox)</p>",
        "id": 244805123,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1625318422
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span>  said (side note, why does zulip mobile not have quote function):</p>\n<blockquote>\n<p>I'd love if this proposal was extended to suggest that rustc should accept target triples without the vendor field in them... but I have the impression that this would get quite a bit of pushback, sadly. Since it looks like everyone agrees that the vendor field is useless, I'd hope that some day we can remove it entirely from the user-visible interface, instead of forcing users to remember arcane runes by heart that long lost their usefulness.</p>\n</blockquote>\n<p>As was mentioned a few times above, there is a use for the vendor field: ensuring consistency in canonical forms, which makes mechanical parsing easier (All of my shell script \"fixing\" rustc targets in rust-autotools assumes that <code>*-*-*</code> matches any target, and that consuming the third component gives the entire system). Of course, that doesn't mean that rustc cannot accept targets w/o the vendor field, it just means that rust code using \"TARGET\" need to acknowledge that it may be (and that it needs to be canonicalized, which is fun, before processing it in the normal way).<br>\nI'd support this, iff they were made aliases of the canonical form (with the vendor field). That is, for some target $targ, if rustc accepts $targ it should also accept <code>config.sub $targ</code> (unless and while that is an error, which it currently is for 52 targets) and they should mean the same thing. This supports using build systems like autotools (which precanonicalizes targets) with rustc, and implementations that internally canonicalizes targets (which lccc <a href=\"https://https://github.com/LightningCreations/lccc/blob/620bbd5e028c59dab89696af90077c1a51507f8d/xlang/include/xlang%2B%2B/Target.hpp#L152..L172\">does</a>).</p>",
        "id": 244807179,
        "sender_full_name": "Connor Horman",
        "timestamp": 1625320926
    },
    {
        "content": "<p>You can let rustc \"parse\" the target triple for you: <code>rustc --target my-target --print cfg</code>.</p>",
        "id": 244807354,
        "sender_full_name": "bjorn3",
        "timestamp": 1625321223
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Deprecate.20target_vendor.20.20lang-team.23102/near/244807354\">said</a>:</p>\n<blockquote>\n<p>You can let rustc \"parse\" the target triple for you: <code>rustc --target my-target --print cfg</code>.</p>\n</blockquote>\n<p>Wouldn't that give me a bunch of CFG fields (and also, wouldn't that require that rustc accept the target in the first place?). The point of the shell script in rust-autotools is that rustc <em>doesn't</em> accept the host target or host_alias (if supplied) and I have to parse it's canonical form to find the equivalent target that rustc <em>does</em> accept (and it's a bunch of very fragile, hacky special cases). Also, if the reason you are parsing targets is for support for existing toolchains, I'm going to assume that whatever rustc does isn't going to be perfectly compatible with that, mainly because of backwards compatibility issues that isn't cross-compatible. Could I do so? Probably. Would I? No, merely because it won't parse it precisely the way I expect it (then I break other things down the line).</p>",
        "id": 244808377,
        "sender_full_name": "Connor Horman",
        "timestamp": 1625322515
    },
    {
        "content": "<p>(Also, I doubt the output of <code>rustc --target my-target --print cfg</code> will be any easier to parse with a shell script)</p>",
        "id": 244808509,
        "sender_full_name": "Connor Horman",
        "timestamp": 1625322691
    },
    {
        "content": "<p>I was thinking about rustc target -&gt; autotools target.</p>",
        "id": 244808716,
        "sender_full_name": "bjorn3",
        "timestamp": 1625322928
    },
    {
        "content": "<p>I actually have an entire library that does that, and also that does autotools canonicalizations. Specifically (once I go through the supported targets list I copied into a shell script and implement them), it goes from rustc=&gt;canonical and a subset of noncanonical=&gt;canonical (because some of the noncanonical targets config.sub accepts are just painful to implement, and I highly doubt I'd ever encounter them in the wild).</p>",
        "id": 244809141,
        "sender_full_name": "Connor Horman",
        "timestamp": 1625323415
    },
    {
        "content": "<blockquote>\n<p>As was mentioned a few times above, there is a use for the vendor field: ensuring consistency in canonical forms, which makes mechanical parsing easier</p>\n</blockquote>\n<p>I don't follow. Canonical forms could just as well be defined without the vendor field. This is just a historical artifact, nothing set in stone -- even less so for Rust, which often likes to do the right thing instead of doing the old thing.</p>",
        "id": 244846886,
        "sender_full_name": "RalfJ",
        "timestamp": 1625384636
    },
    {
        "content": "<p>I guess it could, but then all code parsing canonical targets would have to be updated for rust specifically (and this affects code that <em>also</em> needs to deal with autotools targets, which means it cannot merely change how it works). <br>\nThus, it would have to be a non-canonical target form (wrt. autotools targets), and that should be made known for anyone using it directly, without attempting to canonicalize it. I have one crate that does, but it's intended to use the non-canonical form anyways, though the projects I mentioned previously, especially lccc, would be affected. Beyond that, I don't know how much code would break if targets became non-canonical. <br>\nOf course, if targets are in non-canonical form, then I think it would be a very good idea to also accept the canonical form of each such target, for the reasons I mentioned above.</p>",
        "id": 244854523,
        "sender_full_name": "Connor Horman",
        "timestamp": 1625397341
    }
]