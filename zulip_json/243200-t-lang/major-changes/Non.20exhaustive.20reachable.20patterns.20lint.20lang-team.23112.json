[
    {
        "content": "<p>A new proposal has been announced: <a href=\"https://github.com/rust-lang/lang-team/issues/112\">Non exhaustive reachable patterns lint #112</a>. It will be announced at the next meeting to try and draw attention to it, but usually MCPs are not discussed during triage meetings. If you think this would benefit from discussion amongst the team, consider proposing a design meeting.</p>",
        "id": 246709756,
        "sender_full_name": "triagebot",
        "timestamp": 1626869173
    },
    {
        "content": "<p><span class=\"user-group-mention\" data-user-group-id=\"1977\">@T-lang</span>: Proposal <a href=\"https://github.com/rust-lang/lang-team/issues/112#issuecomment-884359258\">#112</a> has been seconded, and will be approved in 10 days if no objections are raised.</p>",
        "id": 246751026,
        "sender_full_name": "triagebot",
        "timestamp": 1626888187
    },
    {
        "content": "<p>I've been working on two options, there is now a WIP lint inside <a href=\"http://usefulness.rs\">usefulness.rs</a> and a normal lint (using the LateLintPass mechanics). There is a rather large problem in the normal lint, it cannot detect guards or or-patterns, basically it would have to use/reimplement parts of the mechanics of <a href=\"https://github.com/rust-lang/rust/blob/master/compiler/rustc_mir_build/src/thir/pattern/check_match.rs\">check_match</a>. It seems to me that adding the lint to the usefulness and check_match files makes sense.</p>\n<p>I was able to make the lint work for <a href=\"https://github.com/DevinR528/rust/commit/df377ca309fd5acf1a3dcdcb90ecdfef9578eafb\">enums</a> but am having trouble with structs and variants with fields <a href=\"https://github.com/DevinR528/rust/commits/useful-reachable\">WIP commits</a> (first commit is the normal lint, the second two are an enum impl in usefulness and the start of me exploring for structs). For struct/variant fields I'm not really sure how to go about checking for the attribute (either place, see bellow) or the best way to skip the <code>..</code> rest/wildcard-ish and check for missing fields.</p>\n<p>The other issue is where the attribute should be placed? In the <a href=\"https://github.com/rust-lang/rust/issues/84332\">issue</a> as well as the <code>non_exhaustive</code> PR <a href=\"https://github.com/rust-lang/rust/issues/44109#issuecomment-521781237\">comments</a> it was mentioned adding the attribute to the wildcard in a match</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">Bar</span>::<span class=\"n\">A</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Bar</span>::<span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{},</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Bar</span>::<span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{},</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"cp\">#[deny(reachable)]</span><span class=\"w\"> </span><span class=\"c1\">// attribute goes here or on the expression</span>\n<span class=\"w\">    </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"c1\">// triggers lint \"missing Bar::C...\"</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>The problem with this is that it's struct counterpart  isn't exactly valid <a href=\"https://github.com/rust-lang/rust/issues/81282\">issue</a></p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">a</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">b</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"cp\">#[warn(reachable)]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">..</span><span class=\"w\"> </span><span class=\"c1\">// triggers lint \"missing field `c`...\"</span>\n<span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">structure</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>So the options, at least what I can come up with, are to make this valid or put the attribute on the expr/stmt instead of the wild patterns.</p>\n<p>I also opened a compiler-team MCP <a href=\"https://github.com/rust-lang/compiler-team/issues/445\">https://github.com/rust-lang/compiler-team/issues/445</a> should I close this or is this needed also?</p>",
        "id": 247068177,
        "sender_full_name": "DevinR528",
        "timestamp": 1627123226
    },
    {
        "content": "<p>I don't know if you need a compiler MCP too, but I think the questions about <code>LateLintPass</code> vs something else are better in a compiler stream of some sort, since I at least have no idea how to answer those :P</p>\n<p>As for the location (which I think <em>is</em> a lang question, though doesn't need to be resolved in the MCP), my question would be whether it could ever make sense on things like other arms than the last one.</p>\n<p>For example, it could be phrased</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[warn(unmentioned_field)]</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">structure</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>since it's not like you'd want the \"reachable\" on other parts of the pattern, as far as I understand.  (And I think I prefer that form to the one that expands out all the fields to different lines.)</p>",
        "id": 247094954,
        "sender_full_name": "scottmcm",
        "timestamp": 1627162495
    },
    {
        "content": "<blockquote>\n<p>whether it could ever make sense on things like other arms than the last one.</p>\n</blockquote>\n<p>This is a good point, I agree that it probably won't ever be used on anything other than the last (wildcard). I wonder if it makes the intent more clear on the wildcard/rest pattern (like the examples in my above message)? Since it would be a whole thing to add the ability to put the attribute on struct rest patterns (<code>..</code>) I'm leaning towards putting the attribute on the expr/stmt as you showed in your example for structs and enums but this isn't a strong preference.</p>\n<p>Is the next step waiting for the MCP to finish it's 10 days before discussing specifics or are we waiting on me to come up with a full implementation so it's easier to see pros/cons?</p>",
        "id": 247187674,
        "sender_full_name": "DevinR528",
        "timestamp": 1627296944
    },
    {
        "content": "<p>Lints aren't a forever promise, so I think you should consider the MCP as \"you're good to go on implementing it\".  If some of the details change over the course of implementing that's fine.</p>\n<p>Personally I see it more as a \"make sure you don't waste time doing something that people will want to not happen at all\" than something you strictly need to wait for.</p>",
        "id": 247272882,
        "sender_full_name": "scottmcm",
        "timestamp": 1627339041
    },
    {
        "content": "<p>(Especially for something that's allow-by-default, right?  If you wanted to turn on something heuristic that would start warning on \"did you maybe intend to add a case for qqqqqq?\" then people would probably want another check-in before it turns on, but for an opt-in lint I suspect that the compiler folks will give plenty of review in PR if there's better ways of doing something.)</p>",
        "id": 247273155,
        "sender_full_name": "scottmcm",
        "timestamp": 1627339240
    },
    {
        "content": "<p>Cool sounds good thanks!! Back to learning all the ins and outs of usefulness checking <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span> hehe</p>",
        "id": 247317718,
        "sender_full_name": "DevinR528",
        "timestamp": 1627383064
    },
    {
        "content": "<p>For anyone interested there is now a working PR for this lint! It does only work with enums and only top-level <code>non_exhaustive</code> enums at that.  <a href=\"https://github.com/rust-lang/rust/pull/86809\">https://github.com/rust-lang/rust/pull/86809</a></p>",
        "id": 249513812,
        "sender_full_name": "DevinR528",
        "timestamp": 1629035570
    },
    {
        "content": "<p>How would this work in the case of <code>#[doc(hidden)]</code> or <code>#[unstable]</code> enum variants? Those should probably be ignored as they aren't part of the public api, but it does make the <code>_</code> reachable,  making <code>deny(reachable)</code> very confusing.</p>",
        "id": 249799346,
        "sender_full_name": "Mara",
        "timestamp": 1629251594
    },
    {
        "content": "<p>I think the lint should only trigger when the user could write new arms just before the <code>_</code> and have them be reachable. This would be the case for  new stable variants, but not unstable variants (unless maybe the corresponding feature gate is enabled)</p>",
        "id": 249897118,
        "sender_full_name": "bjorn3",
        "timestamp": 1629313343
    },
    {
        "content": "<p>Is there anyone who is familiar with the <a href=\"https://github.com/rust-lang/rust/blob/master/compiler/rustc_mir_build/src/thir/pattern/usefulness.rs#L1205\">compute_match_usefulness</a> workings to point me where to look to ignore the \"wildcard\" when constructing a <code>witness</code>. I wonder if ignoring each wildcard for any type marked <code>non_exhaustive</code> with a <code>#[deny(non_exhaustive_reachable_pattern)]</code> attribute wold work. My problem is that I can check in <code>compute_match_usefulness</code> or <code>is_useful</code> but I need to check deeper than \"top-level\". I was able to make it work for enums but only flat top-level variants where the enum is marked <code>non_exhaustive</code> but nothing else (could be marked and the check work).</p>\n<p><a href=\"https://github.com/rust-lang/rust/pull/86809\">PR</a></p>",
        "id": 250067353,
        "sender_full_name": "DevinR528",
        "timestamp": 1629422096
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"245339\">@Nadrieril</span> would be a good person to ask</p>",
        "id": 250069829,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1629425046
    },
    {
        "content": "<p>I would indeed, I know the code very well</p>",
        "id": 250087457,
        "sender_full_name": "Nadrieril",
        "timestamp": 1629445268
    },
    {
        "content": "<p>Lemme try to understand what's happening</p>",
        "id": 250087513,
        "sender_full_name": "Nadrieril",
        "timestamp": 1629445312
    },
    {
        "content": "<p>I haven't yet understood what you've done, but a general warning about this code is: to make something work nested is much harder than making it work top-level</p>",
        "id": 250087879,
        "sender_full_name": "Nadrieril",
        "timestamp": 1629445632
    },
    {
        "content": "<p>It really is a tricky piece of code</p>",
        "id": 250087930,
        "sender_full_name": "Nadrieril",
        "timestamp": 1629445682
    },
    {
        "content": "<p>So what do you want to do? Filtering out some wildcards when constructing witnesses sounds doable: in one of the functions that call apply_constructor, whenever one of the fields is a wildcard you want to skip then you skip the whole witness</p>",
        "id": 250088250,
        "sender_full_name": "Nadrieril",
        "timestamp": 1629446004
    },
    {
        "content": "<p>I'd be surprised if that's what you wanted to do though: the feature shouldn't be changing any of the usefulness reports, it should only emit a lint sometimes</p>",
        "id": 250088348,
        "sender_full_name": "Nadrieril",
        "timestamp": 1629446066
    },
    {
        "content": "<p>Also I expect that non_exhaustive enums and structs need to be treated very differently. It's actually quite a different feature. You don't need other match arms to know if a struct wildcard is reachable so that one should be easy. The enum case is the tricky one</p>",
        "id": 250088427,
        "sender_full_name": "Nadrieril",
        "timestamp": 1629446158
    },
    {
        "content": "<p>(Plz mention my name when you reply, because I will only be checking my notifications)</p>",
        "id": 250088849,
        "sender_full_name": "Nadrieril",
        "timestamp": 1629446460
    },
    {
        "content": "<p>If I understand correctly, currently you're removing the NonExhaustive constructor when the lint should be triggered, so that the relevant wildcard would be considered unreachable. Then I imagine you want to detect this and emit the new lint instead?</p>",
        "id": 250089135,
        "sender_full_name": "Nadrieril",
        "timestamp": 1629446684
    },
    {
        "content": "<p>As you've probably noticed, your wild_reachable check can only be done at the top-level. To go deeper you'd need much more complex logic that would duplicate usefulness code. Indeed, detecting when a pattern is reachable is already what usefulness does! Somehow you'll need to reuse that but I don't see how just yet</p>",
        "id": 250089520,
        "sender_full_name": "Nadrieril",
        "timestamp": 1629447057
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"245339\">@Nadrieril</span> </p>\n<p>So what I have (that probably won't work) is:</p>\n<ul>\n<li><a href=\"https://github.com/rust-lang/rust/blob/5d354fb75e39b30c9952124937490a9aed64697c/compiler/rustc_mir_build/src/thir/pattern/usefulness.rs#L1286-L1299\">check if it's non_exhaustive and has a wildcard</a></li>\n<li><a href=\"https://github.com/rust-lang/rust/blob/5d354fb75e39b30c9952124937490a9aed64697c/compiler/rustc_mir_build/src/thir/pattern/usefulness.rs#L1313-L1318\">if it is and were at the <code>_</code> don't push to the matrix</a></li>\n<li><a href=\"https://github.com/rust-lang/rust/blob/5d354fb75e39b30c9952124937490a9aed64697c/compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs#L929\">have <code>SplitWildcards</code> return the variant list if reachable_non_exhaustive (variants minus wildcard)</a></li>\n<li><a href=\"https://github.com/rust-lang/rust/blob/5d354fb75e39b30c9952124937490a9aed64697c/compiler/rustc_mir_build/src/thir/pattern/check_match.rs#L258\">emit the lint</a></li>\n</ul>\n<p>I'm finding that this is too destructive to anything else that uses this (see <a href=\"https://github.com/rust-lang/rust/blob/5d354fb75e39b30c9952124937490a9aed64697c/compiler/rustc_mir_build/src/thir/pattern/check_match.rs#L232-L240\">this</a> as an example of messing up other lints/errors). What I'm wonder about now is if I should just implement the lint using the <code>LateLintPass</code> trait. I can make the <code>compute_match_usefulness</code> pub and change the arms or fields before I call <code>compute_match_usfulness</code> <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>\n<p>I'm gonna check out if this is even possible I'll keep you up to date on my progress.</p>",
        "id": 250109585,
        "sender_full_name": "DevinR528",
        "timestamp": 1629461528
    },
    {
        "content": "<p>Hm you should be able to do it without changing the matrix or the witnesses. Lemme try to explain.<br>\nWhat usefulness does is kind of trying all possible values and seeing if there's any value that isn't caught by a match arm. What your lint needs is to detect when an enum variant is caught by a wildcard. Sounds doable with the current code.<br>\nLet's be more precise. To make non_exhaustive work, we add a fake NonExhaustive variant to the enum, but then treat it like a normal enum. I think you understand so far. Whenever there's a wildcard for our enum type, the code will try to specialize in turn with each variant, to see if it's useful. That's where we can lint! If a variant (that is not NonExhaustive) from a non_exhaustive enum is found useful for a wildcard, that's when we should lint. You should be able to observe that in is_useful somewhere.<br>\nThere's just one problem with that: <a href=\"https://github.com/rust-lang/rust/blob/9ccf661694423895b02e513c69e6ad263b2f3d8e/compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs#L923\">this line</a> is a cheat that says \"let's pretend the enum only has the fake variant\" to go faster. As you correctly noticed for your case we need the real variants too; that cheat won't work anymore. So we have to add back the real variants before we can do what I described above.<br>\nAm I making sense?</p>",
        "id": 250112388,
        "sender_full_name": "Nadrieril",
        "timestamp": 1629463467
    },
    {
        "content": "<p>I expect removing the cheat will change the text of error messages sadly. That's harder to fix, but if we can get everything else to work that'd be great already</p>",
        "id": 250112631,
        "sender_full_name": "Nadrieril",
        "timestamp": 1629463611
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"245339\">@Nadrieril</span> <br>\nI think I have a general understanding, my specifics are a the problem. So if we change <code>SplitwildCard::new</code> to return the full set of variants when appropriate we end up triggering <code>unreachable_pattern</code> for the <code>_ =&gt; {}</code> arm. I am not quite sure of the next steps after getting the list of variants. Is <code>Matrix::specialize_constructor</code> the only method that does any filtering of variants that aren't covered? How do I collect the variants that are matched by the wildcard and are __not__ part of the pattern stack (arms of the match)?</p>",
        "id": 250250642,
        "sender_full_name": "DevinR528",
        "timestamp": 1629600640
    },
    {
        "content": "<p>Isn't this <a href=\"https://github.com/rust-lang/rust/blob/9ccf661694423895b02e513c69e6ad263b2f3d8e/compiler/rustc_mir_build/src/thir/pattern/usefulness.rs#L1236\">https://github.com/rust-lang/rust/blob/9ccf661694423895b02e513c69e6ad263b2f3d8e/compiler/rustc_mir_build/src/thir/pattern/usefulness.rs#L1236</a> the only check for patterns that are missing in the arms (match is not exhaustive) although this is only for regular enums and structs (not non_exhaustive)</p>",
        "id": 250251111,
        "sender_full_name": "DevinR528",
        "timestamp": 1629601370
    },
    {
        "content": "<p>We need to make Splitwildcard::new return the full set of variants _plus_ the NonExhaustive variant, indeed otherwise we'll get the wrong result</p>",
        "id": 250262179,
        "sender_full_name": "Nadrieril",
        "timestamp": 1629619866
    },
    {
        "content": "<p>The line you show is indeed where match exhaustiveness is computed; arm_usefulness is about arm reachability. This is not only for regular enums and structs, this applies to any patterns</p>",
        "id": 250262307,
        "sender_full_name": "Nadrieril",
        "timestamp": 1629620119
    },
    {
        "content": "<blockquote>\n<p>Is <code>Matrix::specialize_constructor</code> the only method that does any filtering of variants that aren't covered?</p>\n</blockquote>\n<p>Yep</p>\n<blockquote>\n<p>How do I collect the variants that are matched by the wildcard and are __not__ part of the pattern stack (arms of the match)?</p>\n</blockquote>\n<p>You should be able to do that <a href=\"https://github.com/rust-lang/rust/blob/9ccf661694423895b02e513c69e6ad263b2f3d8e/compiler/rustc_mir_build/src/thir/pattern/usefulness.rs#L1161\">here</a>: if <code>v_ctor</code> is a wildcard, for an enum you care about, and <code>ctor</code> is a variant, then <code>usefulness</code> will tell you whether <code>ctor</code> is matched by the wildcard or by a previous arm. I thought there was a <code>Usefulness::is_useful</code> method but apparently I deleted it; you'll have to figure it out from what compute_match_usefulness does.<br>\nBtw in is_useful the pattern stack is the current arm and the matrix is the previous arms.</p>",
        "id": 250262901,
        "sender_full_name": "Nadrieril",
        "timestamp": 1629621148
    },
    {
        "content": "<p>Another potential footgun: <a href=\"https://github.com/rust-lang/rust/blob/9ccf661694423895b02e513c69e6ad263b2f3d8e/compiler/rustc_mir_build/src/thir/pattern/usefulness.rs#L913\">this line</a> stops trying new constructors when we know they won't change anything. This might interfere with what you're trying to do. You can comment that line while you're testing</p>",
        "id": 250267697,
        "sender_full_name": "Nadrieril",
        "timestamp": 1629628836
    },
    {
        "content": "<p>Not gonna ping you since I'm sure I'll have more questions and you'll see this:</p>\n<p>THANK YOU for the help! Also much respect for writing this section of the compiler wow! well done.</p>",
        "id": 250284135,
        "sender_full_name": "DevinR528",
        "timestamp": 1629652665
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"245339\">@Nadrieril</span> </p>\n<p>Well I'm still pretty stumped I came up with this <a href=\"https://github.com/rust-lang/rust/compare/master...DevinR528:comp-use\">https://github.com/rust-lang/rust/compare/master...DevinR528:comp-use</a></p>\n<ul>\n<li>return all variants when needed (non_exhausted enum with lint attr) in <code>Splitwildcard::new</code></li>\n<li>in <code>compute_match_usefulness</code> we check for missing variants <a href=\"https://github.com/DevinR528/rust/blob/4b5d4f4f7f0044b4ddfffe4754bf4b124d7592b9/compiler/rustc_mir_build/src/thir/pattern/usefulness.rs#L1251-L1260\">here</a></li>\n</ul>\n<p>I realize I'm just doing a variation on what I had before but I for the life of me cannot figure out how to get/compare a list of patterns (the seen arms of a match) against a wildcard except from a high at the end of <code>compute_match_usefulness</code> that's the only place I see where you have all the info you need to make the comparison. this at least accomplishes the task without being destructive of the other checks the <code>thir::pattern</code> mod does.</p>",
        "id": 250708697,
        "sender_full_name": "DevinR528",
        "timestamp": 1629942659
    },
    {
        "content": "<p>You should have all the info you need from within <code>is_useful</code>; the only problem is figuring out what form it takes. In particular you won't exactly get a list of seen patterns, it'll be things about constructors.<br>\nFirst you care about a wildcard pattern for some particular enum type. For that you can test that <code>v_ctor.is_wildcard()</code> and that <code>pcx.ty</code> is a non_exhaustive enum. Then you want to see if the wildcard is reachable with a constructor other than <code>NonExhaustive</code>. Here <code>v_ctor.split(..)</code> will return a list of possible constructors, so you only have to see if one of them is reachable and isn't <code>NonExhaustive</code>.  You can check that by looking if <code>ctor</code> is <code>NonExhaustive</code> and checking if <code>usefulness</code> says that <code>ctor</code> was useful. Then you can emit your lint (<code>pcx.span</code> will be the span of the wildcard).</p>",
        "id": 250740220,
        "sender_full_name": "Nadrieril",
        "timestamp": 1629966887
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"245339\">@Nadrieril</span> <br>\nOk, I think I'm getting closer to what you want! This is now all done in <code>is_useful</code> and the methods called within. <a href=\"https://github.com/rust-lang/rust/compare/master...DevinR528:comp-use\">new diff</a></p>\n<ul>\n<li><code>Splitwildcard::new</code> still returns the variants + <code>NonExhaustive</code> when enum + <code>non_exhaustive</code></li>\n<li><code>Usefulness::WithWitness { exhaustive: Vec&lt;Witness&gt;, non_exhaustive: Vec&lt;Witness&gt; }</code> so non_exhaustive collects the patterns that are useful aganist the wildcard (whats missing in the match if you ignore the <code>_</code>) this is only toplevel</li>\n<li>we add missed patterns to Usefulness via <a href=\"https://github.com/rust-lang/rust/compare/master...DevinR528:comp-use#diff-1812b3836d7a3c164bf3a9f917fc16487795aaaffeecb836f6d9f0096aec9ae5R974-R983\"><code>Usefulness::apply_constructor</code></a> which we do only if enum + non_exhaustive</li>\n</ul>\n<p>I'm now trying to get struct <code>let Foo { a, b, .. } = Foo::default()</code> to work, it seems maybe a similar thing would work...</p>",
        "id": 251096986,
        "sender_full_name": "DevinR528",
        "timestamp": 1630202034
    },
    {
        "content": "<p>that looks a bit better :) That won't work though, because you're storing the results in the WithWitnesses case. But when checking a given arm we're always in the NoWitnesses case. WithWitnesses is only for the fake extra arm we add to check exhaustiveness</p>",
        "id": 251115938,
        "sender_full_name": "Nadrieril",
        "timestamp": 1630224904
    },
    {
        "content": "<p>you could add some tests where the pattern isn't at the toplevel</p>",
        "id": 251116554,
        "sender_full_name": "Nadrieril",
        "timestamp": 1630225542
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243877\">DevinR528</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Non.20exhaustive.20reachable.20patterns.20lint.20lang-team.23112/near/251096986\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"245339\">Nadrieril</span> <br>\nI think I'm getting closer to what you want!</p>\n</blockquote>\n<p>Were my pointers above not explicit enough to get you there? If you tried them, did they work?</p>",
        "id": 251117587,
        "sender_full_name": "Nadrieril",
        "timestamp": 1630226653
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"245339\">@Nadrieril</span>  <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Non.20exhaustive.20reachable.20patterns.20lint.20lang-team.23112/near/250740220\">said</a>:</p>\n<blockquote>\n<p>so you only have to see if one of them is reachable and isn't <code>NonExhaustive</code>.  You can check that by looking if <code>ctor</code> is <code>NonExhaustive</code> and checking if <code>usefulness</code> says that <code>ctor</code> was useful. Then you can emit your lint (<code>pcx.span</code> will be the span of the wildcard).</p>\n</blockquote>\n<p><code>ctor</code> never stays <code>NonExhaustive</code> it's converted to <code>Missing</code> is this what I should be looking for or change <code>Splitwildcard::into_ctors</code> to preserve the <code>NonExhaustive</code>?  <code>is_useful</code> gives the variants that are caught by the pattern right, so we still need to compute <code>enum_variants - known_patterns</code>to give us the patterns that we need to show?</p>\n<p>I'm not sure how or where to find these missing patterns? Do I need to alter <code>Usefulness::NoWitnesses(SubPatSet)</code> or could I just emit the lint in <code>Usefulness::apply_constructor</code> using the  same thing as the 3rd bullet point point in my msg above (moving the check for <code>Missing</code> and <code>new_patterns</code> building outside of the match, this still doesn't get nested enums but I'm not sure we want to, this way it is consistent with the <code>non_exhaustive</code> patterns lint <a href=\"https://doc.rust-lang.org/stable/error-index.html#E0004\">https://doc.rust-lang.org/stable/error-index.html#E0004</a> ? </p>\n<p>I think the biggest problem is you are super familiar with the code and I'm taking everything you say very literally because I'm not as familiar <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span> so without a bit more specific do this here or change this method to do this kinda thing I might not comfortable enough with the code to get what your thinking. Thanks for the patients!</p>",
        "id": 251148989,
        "sender_full_name": "DevinR528",
        "timestamp": 1630261287
    },
    {
        "content": "<p>For context the new <code>Usefulness::apply_constructor</code> would look like this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">apply_constructor</span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">pcx</span>: <span class=\"nc\">PatCtxt</span><span class=\"o\">&lt;'</span><span class=\"nb\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">p</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">tcx</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">matrix</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">Matrix</span><span class=\"o\">&lt;'</span><span class=\"na\">p</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">tcx</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"c1\">// used to compute missing ctors</span>\n<span class=\"w\">    </span><span class=\"n\">ctor</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">Constructor</span><span class=\"o\">&lt;'</span><span class=\"na\">tcx</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">ctor_wild_subpatterns</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">Fields</span><span class=\"o\">&lt;'</span><span class=\"na\">p</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">tcx</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">is_wildcard</span>: <span class=\"kt\">bool</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">new_pats</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"fm\">matches!</span><span class=\"p\">(</span><span class=\"n\">ctor</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Constructor</span>::<span class=\"n\">Missing</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">split_wildcard</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">SplitWildcard</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">pcx</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">split_wildcard</span><span class=\"p\">.</span><span class=\"n\">split</span><span class=\"p\">(</span><span class=\"n\">pcx</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">matrix</span><span class=\"p\">.</span><span class=\"n\">head_ctors</span><span class=\"p\">(</span><span class=\"n\">pcx</span><span class=\"p\">.</span><span class=\"n\">cx</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">missing_pats</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">split_wildcard</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">.</span><span class=\"n\">iter_missing</span><span class=\"p\">(</span><span class=\"n\">pcx</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">.</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">missing_ctor</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">Fields</span>::<span class=\"n\">wildcards</span><span class=\"p\">(</span><span class=\"n\">pcx</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">missing_ctor</span><span class=\"p\">).</span><span class=\"n\">apply</span><span class=\"p\">(</span><span class=\"n\">pcx</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">missing_ctor</span><span class=\"p\">))</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">.</span><span class=\"n\">collect</span>::<span class=\"o\">&lt;</span><span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">_</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">();</span><span class=\"w\"></span>\n\n<span class=\"w\">        </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">pcx</span><span class=\"p\">.</span><span class=\"n\">cx</span><span class=\"p\">.</span><span class=\"n\">is_foreign_non_exhaustive_enum</span><span class=\"p\">(</span><span class=\"n\">pcx</span><span class=\"p\">.</span><span class=\"n\">ty</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">is_wildcard</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">witnesses</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">missing_pats</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"p\">.</span><span class=\"n\">iter</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"c1\">// Must remove the wildcard for `non_exhaustive` enums</span>\n<span class=\"w\">                </span><span class=\"p\">.</span><span class=\"n\">filter</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">p</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"o\">!</span><span class=\"fm\">matches!</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">.</span><span class=\"n\">kind</span><span class=\"p\">.</span><span class=\"n\">as_ref</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">PatKind</span>::<span class=\"n\">Wild</span><span class=\"p\">))</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"p\">.</span><span class=\"n\">cloned</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"p\">.</span><span class=\"n\">collect</span>::<span class=\"o\">&lt;</span><span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">_</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"o\">!</span><span class=\"n\">witnesses</span><span class=\"p\">.</span><span class=\"n\">is_empty</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"n\">non_exhaustive_reachable_match</span><span class=\"p\">(</span><span class=\"n\">pcx</span><span class=\"p\">.</span><span class=\"n\">cx</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">pcx</span><span class=\"p\">.</span><span class=\"n\">ty</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">pcx</span><span class=\"p\">.</span><span class=\"n\">span</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">pcx</span><span class=\"p\">.</span><span class=\"n\">hir_id</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">witnesses</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">        </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">missing_pats</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nb\">None</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"c1\">// same as before }</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 251149103,
        "sender_full_name": "DevinR528",
        "timestamp": 1630261400
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243877\">DevinR528</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Non.20exhaustive.20reachable.20patterns.20lint.20lang-team.23112/near/251148989\">said</a>:</p>\n<blockquote>\n<p><code>ctor</code> never stays <code>NonExhaustive</code> it's converted to <code>Missing</code></p>\n</blockquote>\n<p>Ohhh oops you're right. That must have made it more confusing sorry &gt;&lt;. This is getting harder than I thought.<br>\nYour <code>apply_constructor</code> looks good, but you'll have the same problem as before: it's only called in the <code>WithWitnesses</code> case. I guess we could indeed only catch it at toplevel for now, and think of a cleverer solution later.</p>",
        "id": 251150009,
        "sender_full_name": "Nadrieril",
        "timestamp": 1630262323
    },
    {
        "content": "<p>Doesn't it catch it for both? Or is there something else that stops it. Actually now that I'm thinking about it I'm not sure why it doesn't work nested I'm ignoring the different Usefulness variants <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span>‍♂️</p>",
        "id": 251150500,
        "sender_full_name": "DevinR528",
        "timestamp": 1630262843
    },
    {
        "content": "<p>Here's an idea. We replace <code>Missing</code> with <code>Missing(Vec&lt;Constructor&gt;)</code> that stores the list of missing constructors. (We used to do that a while ago). That way we can know if a <code>Missing</code> stands for only <code>NonExhaustive</code> or also for some real variants.<br>\nSo in <code>is_useful</code>, if <code>pcx.ty</code> is an enum we care about, and <code>ctor</code> is <code>Missing(missings)</code>, and <code>missings</code> contains a real variant, and <code>ctor</code> is useful, then that means a real variant was caught by the wildcard.</p>",
        "id": 251150514,
        "sender_full_name": "Nadrieril",
        "timestamp": 1630262870
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243877\">DevinR528</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Non.20exhaustive.20reachable.20patterns.20lint.20lang-team.23112/near/251150500\">said</a>:</p>\n<blockquote>\n<p>Doesn't it catch it for both? Or is there something else that stops it. Actually now that I'm thinking about it I'm not sure why it doesn't work nested I'm ignoring the different Usefulness variants <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span>‍♂️</p>\n</blockquote>\n<p>Nah the two sentences were unrelated. Usefulness variants don't have to do with nesting, they have to do with whether we're analyzing an actual pattern from a match arm or the fake final wildcard used to check exhaustiveness.</p>",
        "id": 251150597,
        "sender_full_name": "Nadrieril",
        "timestamp": 1630262941
    },
    {
        "content": "<p>In our case we only care about patterns written by the user in a match arm, so we'll only see <code>NoWitnesses</code></p>",
        "id": 251150632,
        "sender_full_name": "Nadrieril",
        "timestamp": 1630262980
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243877\">DevinR528</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Non.20exhaustive.20reachable.20patterns.20lint.20lang-team.23112/near/251148989\">said</a>:</p>\n<blockquote>\n<p>I think the biggest problem is you are super familiar with the code</p>\n</blockquote>\n<p>Yeah, that and the algorithm is a specific kind of convoluted that takes a while to grasp :/</p>",
        "id": 251150728,
        "sender_full_name": "Nadrieril",
        "timestamp": 1630263070
    },
    {
        "content": "<p>Would you prefer it if I gave you more explicit instructions? I can do that too</p>",
        "id": 251150841,
        "sender_full_name": "Nadrieril",
        "timestamp": 1630263184
    },
    {
        "content": "<p>I think the instructions for our new Missing(missed) should be good to get me going then I should have more detail/specific questions. Should be able to give it another go in a few hours.</p>\n<p>Any ideas for structs I feel like that's going to require a larger change of the  Fields struct maybe?</p>",
        "id": 251151508,
        "sender_full_name": "DevinR528",
        "timestamp": 1630263896
    },
    {
        "content": "<p>Hm, for structs I was thinking it should be a ton easier. It's just syntactic, right? If we see <code>Foo { a, b, .. }</code> and <code>Foo</code> has a <code>c</code> field then we lint. This doesn't depend on other patterns or anything like it</p>",
        "id": 251153320,
        "sender_full_name": "Nadrieril",
        "timestamp": 1630265993
    },
    {
        "content": "<p>For <code>Missing(missed)</code> here's the idea. We change <code>Missing</code> to <code>Missing(Vec&lt;Constructor&gt;)</code>, and at first the only things that need to change is where we return <code>Missing</code>, in <code>SplitWildcard::into_ctors</code>. There we'll return <code>Missing(self.iter_missing().collect())</code>. So far tests should pass the same.<br>\nThen after <a href=\"https://github.com/rust-lang/rust/blob/daa4dc997c777676b0f0e48d0311cc5e7bde5f87/compiler/rustc_mir_build/src/thir/pattern/usefulness.rs#L1161\">this line</a> we'll want to check if 1/ <code>pcx.ty</code> is a non_exhaustive enum; 2/ <code>ctor</code> is <code>Missing(missed)</code>; 3/ <code>missed</code> contains more than just <code>NonExhaustive</code>; 4/ <code>usefulness</code> is <code>NoWitnesses(set)</code> with <code>!set.is_empty()</code>. If all those conditions hold then we lint.</p>",
        "id": 251153804,
        "sender_full_name": "Nadrieril",
        "timestamp": 1630266563
    },
    {
        "content": "<p>I expect this will have a negative perf impact because we construct that new <code>Vec</code> all the time. If it does we can be more clever but let's get everything working first</p>",
        "id": 251153900,
        "sender_full_name": "Nadrieril",
        "timestamp": 1630266662
    },
    {
        "content": "<p>Would this be a place to add the struct check then <a href=\"https://github.com/rust-lang/rust/blob/daa4dc997c777676b0f0e48d0311cc5e7bde5f87/compiler/rustc_typeck/src/check/pat.rs#L1185\">https://github.com/rust-lang/rust/blob/daa4dc997c777676b0f0e48d0311cc5e7bde5f87/compiler/rustc_typeck/src/check/pat.rs#L1185</a></p>",
        "id": 251170106,
        "sender_full_name": "DevinR528",
        "timestamp": 1630283768
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"245339\">@Nadrieril</span> <br>\nYAY!!! Nesting works! I reset my old branch to the new one and pushed to the PR <a href=\"https://github.com/rust-lang/rust/pull/86809\">https://github.com/rust-lang/rust/pull/86809</a></p>\n<p>I'm gonna keep looking into structs I think you may be right, it would of been a pain to do it in usefulness but I think just checking syntactically should be enough.</p>",
        "id": 251171841,
        "sender_full_name": "DevinR528",
        "timestamp": 1630285692
    },
    {
        "content": "<p>Yay!! <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span></p>",
        "id": 251191873,
        "sender_full_name": "Nadrieril",
        "timestamp": 1630307734
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243877\">DevinR528</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Non.20exhaustive.20reachable.20patterns.20lint.20lang-team.23112/near/251170106\">said</a>:</p>\n<blockquote>\n<p>Would this be a place to add the struct check then <a href=\"https://github.com/rust-lang/rust/blob/daa4dc997c777676b0f0e48d0311cc5e7bde5f87/compiler/rustc_typeck/src/check/pat.rs#L1185\">https://github.com/rust-lang/rust/blob/daa4dc997c777676b0f0e48d0311cc5e7bde5f87/compiler/rustc_typeck/src/check/pat.rs#L1185</a></p>\n</blockquote>\n<p>Definitely looks like it</p>",
        "id": 251192174,
        "sender_full_name": "Nadrieril",
        "timestamp": 1630307930
    },
    {
        "content": "<p>There's also an error we created by listing all variants. We should be able to fix that in <code>apply_constructor</code> as follows: if <code>iter_missing</code> contains a <code>NonExhaustive</code>, then we set <code>new_patterns</code> to be a single wildcard, otherwise we continue as before.</p>",
        "id": 251193271,
        "sender_full_name": "Nadrieril",
        "timestamp": 1630308661
    },
    {
        "content": "<p>oops, the perf impact is really bad <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 251217155,
        "sender_full_name": "Nadrieril",
        "timestamp": 1630324083
    },
    {
        "content": "<p>We could maybe construct the <code>missed</code> vec only when the lint is active? Is that easy to check?</p>",
        "id": 251219612,
        "sender_full_name": "Nadrieril",
        "timestamp": 1630325269
    },
    {
        "content": "<p>Yeah it shouldn't be too bad, I was actually doing that now, sort of. We can check <code>cx.tcx.lint_level()</code> with the <code>HirId</code> which I added to <code>PatCtxt</code> so yea we can even check it inside <code>into_ctors</code>.</p>",
        "id": 251220243,
        "sender_full_name": "DevinR528",
        "timestamp": 1630325634
    },
    {
        "content": "<p>Can I run the perf thing? Is there a way to run benchmarks locally for just this section of the compiler?</p>",
        "id": 251220350,
        "sender_full_name": "DevinR528",
        "timestamp": 1630325682
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243877\">@DevinR528</span> yes, there are instructions on <a href=\"https://github.com/rust-lang/rustc-perf/tree/master/collector\">https://github.com/rust-lang/rustc-perf/tree/master/collector</a></p>",
        "id": 251224243,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1630327939
    },
    {
        "content": "<p>You can run just the \"match-stress\" benchmark by itself</p>",
        "id": 251224282,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1630327964
    },
    {
        "content": "<p>That <code>Missing(vec![])</code> is going to cause errors. Plz remember to change it to <code>Missing(Option&lt;Vec&lt;Constructor&gt;&gt;)</code> when you're done testing</p>",
        "id": 251225024,
        "sender_full_name": "Nadrieril",
        "timestamp": 1630328362
    },
    {
        "content": "<p>Any idea which <code>apply_constructors</code> this refers to \"trying to apply the <code>Missing</code> constructor; this should have been done in <code>apply_constructors</code>\" <a href=\"https://github.com/rust-lang/rust/blob/master/compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs#L1269\">https://github.com/rust-lang/rust/blob/master/compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs#L1269</a></p>\n<p>We have somewhat of a chicken and egg problem, when we have <code>Missing(None)</code> we need to reconstruct the missing fields using <code>SplitWildcard::new/split</code> in <code>Usefulness::apply_constructor</code> but that just gives us another <code>Missing(None)</code> so we end up with panicking <a href=\"https://github.com/rust-lang/rust/blob/master/compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs#L1268\">here</a>. This worked when we always constructed the missing variants (<code>Missing(Vec&lt;..&gt;)</code>) but now that we only do it for the lint when we actually need missing variants for <code>non_exhaustive</code> types we have none. Would it be best to add another <code>SplitWildcard::split</code> that constructs the missing variants without using the <code>Constructor::Missing(..)</code> so for the times we actually need the missing variants in the old way we can build them? Or you got a better way of getting around this?</p>\n<p>The problem is that this ends up changing the error message of <code>match non_exhaustive_enum {}</code> from listing the fields to just saying missing <code>_</code> because the way I temporarily fixed the panic is returning <code>Pat::wildcard_from_ty</code> which is where the wrong error message comes from.</p>\n<p>Setting up the rustc-perf thing so I can make informed choices about how to proceed.</p>",
        "id": 251279945,
        "sender_full_name": "DevinR528",
        "timestamp": 1630351073
    },
    {
        "content": "<p>Oops didn't see this</p>",
        "id": 252017002,
        "sender_full_name": "Nadrieril",
        "timestamp": 1630779247
    },
    {
        "content": "<p>It refers to Usefulness::apply_constructor I think, is there another one?</p>",
        "id": 252017022,
        "sender_full_name": "Nadrieril",
        "timestamp": 1630779274
    },
    {
        "content": "<p>We should not have a chicken-and-egg problem because Missing used to carry no information and that worked fine. You removed the relevant code when we switched to Missing(Vec&lt;&gt;) but you can just add it back</p>",
        "id": 252017131,
        "sender_full_name": "Nadrieril",
        "timestamp": 1630779384
    },
    {
        "content": "<p>The difference with what you're saying is that we use SplitWildcard::iter_missing in apply_constructors, which never generates a Missing</p>",
        "id": 252017166,
        "sender_full_name": "Nadrieril",
        "timestamp": 1630779442
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"245339\">@Nadrieril</span> </p>\n<p>Isn't the relevant code that I removed <a href=\"https://github.com/rust-lang/rust/blob/master/compiler/rustc_mir_build/src/thir/pattern/usefulness.rs#L943-L964\">this</a> in which case I can't just add it back because the combo of <code>SplitWildcard::new / split</code> is what creates the <code>Constructor::Missing(..)</code> variant so when I do it like <a href=\"https://github.com/rust-lang/rust/blob/c242ef0e9b9156345a467f19fdc79c988478859a/compiler/rustc_mir_build/src/thir/pattern/usefulness.rs#L949-L978\">this</a> I get the same problem so I end up just always using <code>missing</code> like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">new_patterns</span>: <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">_</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">missed</span><span class=\"p\">.</span><span class=\"n\">contains</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">Constructor</span>::<span class=\"n\">NonExhaustive</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">vec!</span><span class=\"p\">[</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">Fields</span>::<span class=\"n\">wildcards</span><span class=\"p\">(</span><span class=\"n\">pcx</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">Constructor</span>::<span class=\"n\">NonExhaustive</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">.</span><span class=\"n\">apply</span><span class=\"p\">(</span><span class=\"n\">pcx</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">Constructor</span>::<span class=\"n\">NonExhaustive</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">missed</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">.</span><span class=\"n\">iter</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">.</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">missing_ctor</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">Fields</span>::<span class=\"n\">wildcards</span><span class=\"p\">(</span><span class=\"n\">pcx</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">missing_ctor</span><span class=\"p\">).</span><span class=\"n\">apply</span><span class=\"p\">(</span><span class=\"n\">pcx</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">missing_ctor</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">})</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">.</span><span class=\"n\">collect</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>\n<p>I was able to get the enum stress bench down to like 30% and most everything else about even with the above in <code>Usefulness::apply_constructor</code> but having to collect all the missing variants if there is any missing kills us, I think, from adding more profiling calls in this section of code the worst part seems to be </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">into_ctors</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">pcx</span>: <span class=\"nc\">PatCtxt</span><span class=\"o\">&lt;'</span><span class=\"nb\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"nb\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">tcx</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">SmallVec</span><span class=\"o\">&lt;</span><span class=\"p\">[</span><span class=\"n\">Constructor</span><span class=\"o\">&lt;'</span><span class=\"na\">tcx</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_guard</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">pcx</span><span class=\"p\">.</span><span class=\"n\">cx</span><span class=\"p\">.</span><span class=\"n\">tcx</span><span class=\"p\">.</span><span class=\"n\">sess</span><span class=\"p\">.</span><span class=\"n\">timer</span><span class=\"p\">(</span><span class=\"s\">\"into_ctors\"</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">any_missing</span><span class=\"p\">(</span><span class=\"n\">pcx</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">report_when_all_missing</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">pcx</span><span class=\"p\">.</span><span class=\"n\">is_top_level</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"o\">!</span><span class=\"n\">IntRange</span>::<span class=\"n\">is_integral</span><span class=\"p\">(</span><span class=\"n\">pcx</span><span class=\"p\">.</span><span class=\"n\">ty</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ctor</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"o\">!</span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">matrix_ctors</span><span class=\"p\">.</span><span class=\"n\">is_empty</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"n\">report_when_all_missing</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">matrix_ctors</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">matrix_ctors</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">Missing</span><span class=\"p\">(</span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">all_ctors</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"p\">.</span><span class=\"n\">into_iter</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"p\">.</span><span class=\"n\">filter</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">ctor</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"o\">!</span><span class=\"n\">ctor</span><span class=\"p\">.</span><span class=\"n\">is_covered_by_any</span><span class=\"p\">(</span><span class=\"n\">pcx</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">matrix_ctors</span><span class=\"p\">))</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"p\">.</span><span class=\"n\">collect</span><span class=\"p\">(),</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">))</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">Wildcard</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">smallvec</span><span class=\"o\">!</span><span class=\"p\">[</span><span class=\"n\">ctor</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">all_ctors</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<blockquote>\n<p>I think, is there another one?</p>\n</blockquote>\n<p>There is also <code>Witness::apply_constructor</code> but I doubt that would make sense so your right.</p>",
        "id": 252025222,
        "sender_full_name": "DevinR528",
        "timestamp": 1630788478
    },
    {
        "content": "<blockquote>\n<p>Isn't the relevant code that I removed <a href=\"https://github.com/rust-lang/rust/blob/master/compiler/rustc_mir_build/src/thir/pattern/usefulness.rs#L943-L964\">this</a> in which case I can't just add it back.</p>\n</blockquote>\n<p>The bit that adds Missing is SpltiWildcard::into_ctors, but the code you point to uses SplitWildcard::iter_missing. They do quite different things. So you can add back that code no problem</p>",
        "id": 252034964,
        "sender_full_name": "Nadrieril",
        "timestamp": 1630799482
    },
    {
        "content": "<p>Ok collecting all the variants is what's slow, I'm not surprised. So we should only do it when we need to, i.e. when pcx.ty is a non_exhaustive enum and the lint is active</p>",
        "id": 252035125,
        "sender_full_name": "Nadrieril",
        "timestamp": 1630799675
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"245339\">@Nadrieril</span> </p>\n<p>Ok so I was able to get perf back to a reasonable range (under +5% instructions and I went green on some of the timing measurements) I didn't have to change it much since I think I was looking in the wrong place. Anyway if CI goes green another perf run would be great, thanks! I'll attach screen shots of my run now.</p>",
        "id": 252230295,
        "sender_full_name": "DevinR528",
        "timestamp": 1630968887
    },
    {
        "content": "<p><a href=\"/user_uploads/4715/MyQIKvjXVA3u3QHUAAj0diDU/rustc-perf-inst.png\">rustc-perf-inst.png</a> <a href=\"/user_uploads/4715/laMweEWLREPgDh-GaotObNfQ/rustc-perf.png\">rustc-perf.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/4715/MyQIKvjXVA3u3QHUAAj0diDU/rustc-perf-inst.png\" title=\"rustc-perf-inst.png\"><img src=\"/user_uploads/4715/MyQIKvjXVA3u3QHUAAj0diDU/rustc-perf-inst.png\"></a></div><div class=\"message_inline_image\"><a href=\"/user_uploads/4715/laMweEWLREPgDh-GaotObNfQ/rustc-perf.png\" title=\"rustc-perf.png\"><img src=\"/user_uploads/4715/laMweEWLREPgDh-GaotObNfQ/rustc-perf.png\"></a></div>",
        "id": 252230305,
        "sender_full_name": "DevinR528",
        "timestamp": 1630968899
    },
    {
        "content": "<p>The second picture is \"Comparing cpu-clock\"</p>",
        "id": 252230359,
        "sender_full_name": "DevinR528",
        "timestamp": 1630968960
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/pull/86809\">https://github.com/rust-lang/rust/pull/86809</a> so you don't have to search for the PR link</p>",
        "id": 252236035,
        "sender_full_name": "DevinR528",
        "timestamp": 1630974561
    },
    {
        "content": "<p>Hm, 6% on unicode_normalization is still too much for such a niche feature :/</p>",
        "id": 252331539,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631031801
    },
    {
        "content": "<p>(deleted: misunderstood)</p>",
        "id": 252331707,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1631031861
    },
    {
        "content": "<p>Nah that'd be cheating, the perf impact is real</p>",
        "id": 252331769,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631031882
    },
    {
        "content": "<p>But it's ok because we still have the option I suggested the other day: only build the list of constructors when we'll need it</p>",
        "id": 252331835,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631031906
    },
    {
        "content": "<p>(Sorry, I misunderstood your comment; you meant \"on the <code>unicode_normalization</code> benchmark component\", not \"on unicode normalization within the compiler\".)</p>",
        "id": 252331900,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1631031933
    },
    {
        "content": "<p>Oh right ^^</p>",
        "id": 252331929,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631031946
    },
    {
        "content": "<p>Makes more sense</p>",
        "id": 252331945,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631031951
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"245339\">@Nadrieril</span>  do you know if only non_exhaustive lints need the missing ctors in the warnings/error messages. The problem I was trying to avoid is that Split wildcard::split calls into_ctors which is what gives Missing when we have a wildcard ctor</p>",
        "id": 252332683,
        "sender_full_name": "DevinR528",
        "timestamp": 1631032246
    },
    {
        "content": "<p>I can try to give links when I'm back to my desk in 20 min or so</p>",
        "id": 252332755,
        "sender_full_name": "DevinR528",
        "timestamp": 1631032280
    },
    {
        "content": "<p>the normal \"this match is not exhaustive\" also needs the list of missing constructors, but since it's rarely triggered we rebuild the SplitWildcards for that purpose</p>",
        "id": 252333325,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631032505
    },
    {
        "content": "<p>your new lint is the only one that needs the missing ctors as part of the logic and not just the messages</p>",
        "id": 252333408,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631032537
    },
    {
        "content": "<p>one thing we could easily do: instead of <code>Missing(Vec&lt;&gt;)</code>, we do <code>Missing { more_than_one: bool }</code> that stores whether there's exactly one constructor missing or more than one. That's enough info to decide whether to lint, and then we can rebuild the list of missing constructors in the rare case that we need it</p>",
        "id": 252333872,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631032698
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243877\">DevinR528</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Non.20exhaustive.20reachable.20patterns.20lint.20lang-team.23112/near/252332683\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"245339\">Nadrieril</span>  do you know if only non_exhaustive lints need the missing ctors in the warnings/error messages. The problem I was trying to avoid is that Split wildcard::split calls into_ctors which is what gives Missing when we have a wildcard ctor</p>\n</blockquote>\n<p>I don't understand this. <code>SplitWildcard::split</code> doesn't call <code>into_ctors</code>. And we really can't avoid <code>Missing</code> in the general case, it's used absolutely all the time (hence the perf impact)</p>",
        "id": 252334072,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631032797
    },
    {
        "content": "<p>So it might not matter but here goes <a href=\"https://github.com/rust-lang/rust/blob/7265e2c697c8acee89d10561a6ba24138df2dd98/compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs#L1015\">SplitWildcard::split</a> calls <a href=\"https://github.com/rust-lang/rust/blob/7265e2c697c8acee89d10561a6ba24138df2dd98/compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs#L731\">Constructor::split</a> which when it's a wildcard calls <a href=\"https://github.com/rust-lang/rust/blob/7265e2c697c8acee89d10561a6ba24138df2dd98/compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs#L743\">SplitWildcard::into_ctor</a></p>",
        "id": 252334489,
        "sender_full_name": "DevinR528",
        "timestamp": 1631032986
    },
    {
        "content": "<p>ah I see. The comment in <code>SplitWildcard::split</code> explains it: <code>all_ctors</code> never contains a wildcard, so this never actually happens</p>",
        "id": 252334778,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631033117
    },
    {
        "content": "<p>If I try to reconstruct the <code>SplitWildcard</code> in <code>apply_constructor</code> (so only constructing all the missing for foreign non_exhaustive) I run into this <a href=\"https://github.com/rust-lang/rust/blob/7265e2c697c8acee89d10561a6ba24138df2dd98/compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs#L1302\">https://github.com/rust-lang/rust/blob/7265e2c697c8acee89d10561a6ba24138df2dd98/compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs#L1302</a></p>",
        "id": 252339642,
        "sender_full_name": "DevinR528",
        "timestamp": 1631035061
    },
    {
        "content": "<p>Maybe here <a href=\"https://github.com/rust-lang/rust/blob/master/library/core/src/num/dec2flt/mod.rs#L238\">https://github.com/rust-lang/rust/blob/master/library/core/src/num/dec2flt/mod.rs#L238</a> the ICE says <code>num::dec2flt::dec2flt</code>?</p>",
        "id": 252340056,
        "sender_full_name": "DevinR528",
        "timestamp": 1631035227
    },
    {
        "content": "<p>The above happens when <code>apply_constructor</code> looks like <a href=\"https://github.com/rust-lang/rust/blob/c242ef0e9b9156345a467f19fdc79c988478859a/compiler/rustc_mir_build/src/thir/pattern/usefulness.rs#L939\">this</a></p>",
        "id": 252340469,
        "sender_full_name": "DevinR528",
        "timestamp": 1631035431
    },
    {
        "content": "<p>huh that's really weird</p>",
        "id": 252343211,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631036536
    },
    {
        "content": "<p>particularly since that apply_constructor is essentially the same as the current one, which obviously doesn't trigger this error</p>",
        "id": 252343271,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631036562
    },
    {
        "content": "<p>This is why I was confused about SplitWildcard</p>",
        "id": 252343550,
        "sender_full_name": "DevinR528",
        "timestamp": 1631036688
    },
    {
        "content": "<p>Since that's the only difference between the apply_constructors</p>",
        "id": 252343694,
        "sender_full_name": "DevinR528",
        "timestamp": 1631036753
    },
    {
        "content": "<p>yeah that's very confusing</p>",
        "id": 252343840,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631036804
    },
    {
        "content": "<p>The other thing that's odd is that it now should only ever be <code>Missing(Some())</code> when there is a <code>Constructor::NonExhaustive</code> present so why it every hits the else is beyond me...</p>",
        "id": 252344618,
        "sender_full_name": "DevinR528",
        "timestamp": 1631037135
    },
    {
        "content": "<p>just checking, it's commit <a href=\"https://github.com/rust-lang/rust/commit/c242ef0e9b9156345a467f19fdc79c988478859a\">c242ef0e9b9156345a467f19fdc79c988478859a</a>, with a diff that looks like <a href=\"https://github.com/rust-lang/rust/compare/59ce76548484806ac4970c57c0bb6ad9e53b80f6..c242ef0e9b9156345a467f19fdc79c988478859a\">this</a>?</p>",
        "id": 252344625,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631037137
    },
    {
        "content": "<p>correct</p>",
        "id": 252344679,
        "sender_full_name": "DevinR528",
        "timestamp": 1631037160
    },
    {
        "content": "<p>sure there's not a lingering change where you typoed <code>missing_ctor</code> into <code>ctor</code> by any chance?</p>",
        "id": 252344840,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631037218
    },
    {
        "content": "<p>because I really don't understand how that can happen</p>",
        "id": 252344965,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631037262
    },
    {
        "content": "<p>did you look at the stack trace? which call of <code>Fields::apply</code> triggers the error?</p>",
        "id": 252345613,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631037515
    },
    {
        "content": "<blockquote>\n<p>sure there's not a lingering change where you typoed <code>missing_ctor</code> into <code>ctor</code> by any chance?</p>\n</blockquote>\n<p>I'm pretty sure this didn't happen</p>\n<p>It's the <code>Fields::apply</code> call inside of <code>Usefulness::apply_constructors</code> <a href=\"https://github.com/rust-lang/rust/compare/59ce76548484806ac4970c57c0bb6ad9e53b80f6..c242ef0e9b9156345a467f19fdc79c988478859a#diff-1812b3836d7a3c164bf3a9f917fc16487795aaaffeecb836f6d9f0096aec9ae5R965\">here</a></p>",
        "id": 252349052,
        "sender_full_name": "DevinR528",
        "timestamp": 1631038907
    },
    {
        "content": "<p>Wait that's not true ughhh, it's <code>Witness::apply_construcor</code> <a href=\"https://github.com/rust-lang/rust/blob/7265e2c697c8acee89d10561a6ba24138df2dd98/compiler/rustc_mir_build/src/thir/pattern/usefulness.rs#L1058\">here</a></p>",
        "id": 252350043,
        "sender_full_name": "DevinR528",
        "timestamp": 1631039319
    },
    {
        "content": "<p>YAY I fixed that problem now on to </p>\n<div class=\"codehilite\"><pre><span></span><code>-       error[E0004]: non-exhaustive patterns: `_` not covered\n+       error[E0004]: non-exhaustive patterns: `Unit`, `Tuple(_)`, `Struct { .. }` and 1 more not covered\n20        --&gt; $DIR/enum.rs:23:11\n21         |\n22      LL |     match enum_unit {};\n\n-          |           ^^^^^^^^^ pattern `_` not covered\n+          |           ^^^^^^^^^ patterns `Unit`, `Tuple(_)`, `Struct { .. }` and 1 more not covered\n24         |\n25         = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n26         = note: the matched value is of type `NonExhaustiveEnum`, which is marked as non-exhaustive\n</code></pre></div>",
        "id": 252352075,
        "sender_full_name": "DevinR528",
        "timestamp": 1631040142
    },
    {
        "content": "<p>Fixed that too but now I think it's worse instruction count wise? I'll do some more checking and push a commit if I think I've made progress</p>",
        "id": 252355763,
        "sender_full_name": "DevinR528",
        "timestamp": 1631041439
    },
    {
        "content": "<p>Oh wow how did you fix it?</p>",
        "id": 252376969,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631051534
    },
    {
        "content": "<p>I suggest you don't try to use whatever is carried by <code>Missing</code> in apply_constructor. This is cold code, we can afford to rebuild every time for simplicity's sake</p>",
        "id": 252377177,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631051677
    },
    {
        "content": "<p>let me know if you want a perf run</p>",
        "id": 252377415,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631051852
    },
    {
        "content": "<p>I don't think <code>into_ctors</code> is hot enough to be sensitive to an extra branch there. However I remember that the stress tests are sentitive to the size of <code>pcx</code> so that might be the cause ^^'. You don't need pcx.hir_id, try to remove it to see if that makes a difference</p>",
        "id": 252377987,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631052168
    },
    {
        "content": "<p>another possible explanation is that <code>is_foreign_non_exhaustive_enum</code> could be slow, I don't know what kind of queries it involves</p>",
        "id": 252378170,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631052278
    },
    {
        "content": "<blockquote>\n<p>Oh wow how did you fix it?</p>\n</blockquote>\n<p>I was calling <code>Fields::wildcards / apply</code> when I shouldn't have in <code>Usefulness::apply_constructor</code> now revert to the old behavior when <code>Missing(None)</code> which works</p>\n<p>Ok according to my perf I'm at exactly 0.00% for a few of the enum stress tests</p>",
        "id": 252383887,
        "sender_full_name": "DevinR528",
        "timestamp": 1631056055
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"245339\">@Nadrieril</span> <br>\nShould be ready for a perf run, it should pass this time according to my local perf run. Any idea why they would be different, one of the runs was like &gt;5% less instructions locally than in the CI run?</p>",
        "id": 252444551,
        "sender_full_name": "DevinR528",
        "timestamp": 1631101082
    },
    {
        "content": "<p>Hm, one of the things I think are different between local and CI are compilation options. Incremental and other details like compilation units might differ and change what optimizations LLVM can do</p>",
        "id": 252445135,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631101353
    },
    {
        "content": "<p>Makes sense, I figured out just enough to make the rustc-perf work but didn't go further than that.</p>",
        "id": 252445287,
        "sender_full_name": "DevinR528",
        "timestamp": 1631101422
    },
    {
        "content": "<p>is the link <a href=\"https://github.com/rust-lang/rust/pull/86809\">https://github.com/rust-lang/rust/pull/86809</a> helpful</p>",
        "id": 252445365,
        "sender_full_name": "DevinR528",
        "timestamp": 1631101443
    },
    {
        "content": "<p>I was just reading your last commit</p>",
        "id": 252445512,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631101520
    },
    {
        "content": "<p>Ahh sorry I know it always takes me a while to find my PR if I close the tab <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 252445639,
        "sender_full_name": "DevinR528",
        "timestamp": 1631101568
    },
    {
        "content": "<p>Haha it would have but you had given me the link a few messages back so I used that ^^</p>",
        "id": 252445722,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631101608
    },
    {
        "content": "<p>I'm excited to merge this soon I'm planning on giving myself a Ferris (the rust crab) tattoo once its done <span aria-label=\"crab\" class=\"emoji emoji-1f980\" role=\"img\" title=\"crab\">:crab:</span>.</p>",
        "id": 252446045,
        "sender_full_name": "DevinR528",
        "timestamp": 1631101795
    },
    {
        "content": "<p>Woah that's dedication ^^</p>",
        "id": 252446108,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631101809
    },
    {
        "content": "<p>I only have a Ferris plushie</p>",
        "id": 252446117,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631101816
    },
    {
        "content": "<p>Haha yeah!!</p>",
        "id": 252446168,
        "sender_full_name": "DevinR528",
        "timestamp": 1631101857
    },
    {
        "content": "<p>I will have a few more comments once we're sure the perf is ok</p>",
        "id": 252446221,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631101892
    },
    {
        "content": "<p>Yeah I figured there were a few rough spots still, and the warning message could probably be imporoved/bikeshedded.</p>",
        "id": 252446646,
        "sender_full_name": "DevinR528",
        "timestamp": 1631102092
    },
    {
        "content": "<p>Lemme check the logic of <code>missing_non_exhaustive</code>. It says \"the enum is marked non_exhaustive and also there's some real variant that's missing\", right? The logic looks sound but the naming is unclear. Maybe <code>nonexhaustive_enum_missing_real_variants</code>?</p>",
        "id": 252447457,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631102466
    },
    {
        "content": "<p>Yeah, that's the logic and I would agree on the name</p>",
        "id": 252447544,
        "sender_full_name": "DevinR528",
        "timestamp": 1631102511
    },
    {
        "content": "<p>Or you could compute something that's less specific to non_exhaustive, I don't mind either way</p>",
        "id": 252447594,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631102523
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"245339\">@Nadrieril</span> </p>\n<p>I renamed it to your suggested name and fixed a few other things but it seems there was a download failure when trying to run rustc-perf <a href=\"https://github.com/rust-lang-ci/rust/runs/3544186219#step:26:20848\">https://github.com/rust-lang-ci/rust/runs/3544186219#step:26:20848</a></p>",
        "id": 252610953,
        "sender_full_name": "DevinR528",
        "timestamp": 1631187876
    },
    {
        "content": "<p>ok, I'll retry</p>",
        "id": 252611296,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631188078
    },
    {
        "content": "<p>We did it!! perf regressions are gone.</p>",
        "id": 252656815,
        "sender_full_name": "DevinR528",
        "timestamp": 1631205720
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"245339\">@Nadrieril</span> </p>\n<p>Should I squash all the commits for easier reviewing, or maybe separate them into enum/struct lint <br>\nand a third for the UI testing stuff and other misc changes?</p>",
        "id": 252814737,
        "sender_full_name": "DevinR528",
        "timestamp": 1631292066
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243877\">DevinR528</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Non.20exhaustive.20reachable.20patterns.20lint.20lang-team.23112/near/252656815\">said</a>:</p>\n<blockquote>\n<p>We did it!! perf regressions are gone.</p>\n</blockquote>\n<p>Yay! Well done</p>",
        "id": 252821187,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631294948
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243877\">DevinR528</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Non.20exhaustive.20reachable.20patterns.20lint.20lang-team.23112/near/252814737\">said</a>:</p>\n<blockquote>\n<p>maybe separate them into enum/struct lint and a third for the UI testing stuff and other misc changes?</p>\n</blockquote>\n<p>Oh yeah that'd be convenient, thanks. That's not required though, you can also just squash</p>",
        "id": 252821376,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631295036
    },
    {
        "content": "<p>ping me when you're done and I'll have a look</p>",
        "id": 252822287,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631295450
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243877\">DevinR528</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Non.20exhaustive.20reachable.20patterns.20lint.20lang-team.23112/near/252656815\">said</a>:</p>\n<blockquote>\n<p>We did it!! perf regressions are gone.</p>\n</blockquote>\n<p>congrats! That's awesome :D</p>",
        "id": 252824927,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1631296622
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"232545\">@Joshua Nelson</span>  I'm glad I got this far <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> </p>\n<p><span class=\"user-mention\" data-user-id=\"245339\">@Nadrieril</span>  squashed into 3 commits </p>\n<ul>\n<li>enums + the lint declaration</li>\n<li>structs</li>\n<li>ui test stuff</li>\n</ul>",
        "id": 252851590,
        "sender_full_name": "DevinR528",
        "timestamp": 1631308503
    },
    {
        "content": "<p>Lovely, that does make it a lot easier to review :)</p>",
        "id": 252856301,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631311149
    },
    {
        "content": "<p>Review done. I hope I'm not overwhelming you with nitpicks. The only real thing we need to fix is error messages</p>",
        "id": 252863618,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631316008
    },
    {
        "content": "<p>I'm starting to like the idea of \"matched explicitly\". Like \"this lint detects when some fields/variants are not matched explicitly\" etc</p>",
        "id": 252863794,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631316176
    },
    {
        "content": "<p>We could rename it to something like <code>non_exhaustive_implicit_pattern</code></p>",
        "id": 252863851,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631316235
    },
    {
        "content": "<p>Now that I think about it, the current lint name isn't very clear</p>",
        "id": 252863952,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631316298
    },
    {
        "content": "<p>Hm actually, \"explicit\" isn't what it does. The lint would trigger for</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">Foo</span>::<span class=\"n\">A</span><span class=\"p\">(</span><span class=\"kc\">true</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>even if Foo has only one variant, right?</p>",
        "id": 252864430,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631316676
    },
    {
        "content": "<p>Wait no it doesn't, because Missing would only contain NonExhaustive here. I think. Cool, that would mean we really are talking about implicit variants</p>",
        "id": 252864642,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631316832
    },
    {
        "content": "<p>Could you add the test above? It's an interesting one, because that differs from the original idea in <a href=\"https://github.com/rust-lang/rust/issues/84332\">#84332</a> of a \"reachable\" lint</p>",
        "id": 252864759,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631316898
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"245339\">@Nadrieril</span></p>\n<p>Yeah you are right about the single variant enum, it does not trigger the lint. I added it as a test also.</p>\n<p>I like <code>non_exhaustive_implicit_pattern</code> but what if we used simpler language, how about <code>non_exhaustive_hidden_pattern</code>.  I'm totally on board with \"matched explicitly\" I think that is a much better way of explaining the lint in a few words.</p>",
        "id": 252905373,
        "sender_full_name": "DevinR528",
        "timestamp": 1631362438
    },
    {
        "content": "<p>Err hmm, no hidden doesn't work, not really a synonym, hmm I'm not opposed to <code>non_exhaustive_implicit_pattern</code> it does capture the meaning pretty good.</p>",
        "id": 252907909,
        "sender_full_name": "DevinR528",
        "timestamp": 1631365117
    },
    {
        "content": "<p>I'm working on fixing the <code>if let NonExhaustiveEnum::A = non_enum {}</code> problem (see github PR). All the review issues I resolved are actually resovled their just sitting locally until I fix this problem that makes the tests fail.</p>",
        "id": 252909954,
        "sender_full_name": "DevinR528",
        "timestamp": 1631367354
    },
    {
        "content": "<p>Ok ignore my previous message I fixed the <code>if let ..</code> thing so all resolved issues should be addressed.</p>",
        "id": 252910567,
        "sender_full_name": "DevinR528",
        "timestamp": 1631367950
    },
    {
        "content": "<p>I've added comments about your recent changes. We're almost there</p>",
        "id": 252990664,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631457142
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243877\">DevinR528</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Non.20exhaustive.20reachable.20patterns.20lint.20lang-team.23112/near/252905373\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"245339\">Nadrieril</span><br>\nI like <code>non_exhaustive_implicit_pattern</code> but what if we used simpler language, how about <code>non_exhaustive_hidden_pattern</code>.  I'm totally on board with \"matched explicitly\" I think that is a much better way of explaining the lint in a few words.</p>\n</blockquote>\n<p><code>non_exhaustive_omitted_patterns</code>? I would prefer <code>non_exhaustive_omitted_fields</code> and <code>non_exhaustive_omitted_variants</code> actually but we don't want to split the lint in two</p>",
        "id": 252991075,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631457572
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"245339\">@Nadrieril</span> </p>\n<p>I think the only thing left is the <code>if let ..</code> stuff which I left a few comments about <span aria-label=\"sweat\" class=\"emoji emoji-1f613\" role=\"img\" title=\"sweat\">:sweat:</span> and then once were all set I'll change the name to <code>non_exhaustive_omitted_patterns</code>. Unless anyone has any other ideas...</p>",
        "id": 253026492,
        "sender_full_name": "DevinR528",
        "timestamp": 1631497492
    },
    {
        "content": "<p>yeah, I don't know if there's a procedure for choosing lint names. They're not too hard to rename so let's just go with that and we'll get feedback about it I guess</p>",
        "id": 253088651,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631539585
    },
    {
        "content": "<p>ohh ok right your comment clarifies a lot of things, I was quite confused</p>",
        "id": 253097531,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631542839
    },
    {
        "content": "<p>I replied, your suggestion is good</p>",
        "id": 253097548,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631542846
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"245339\">@Nadrieril</span> </p>\n<p>Made all the changes from your last few comments on the PR and renamed the lint.</p>",
        "id": 253154298,
        "sender_full_name": "DevinR528",
        "timestamp": 1631564602
    },
    {
        "content": "<p>woo this looks excellent!</p>",
        "id": 253170326,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631572072
    },
    {
        "content": "<p>logic is clear, comments are detailed, and we nailed the user-facing explanations</p>",
        "id": 253170413,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631572113
    },
    {
        "content": "<p>Thanks you again for the help!! I'm excited about this lint being activated, I think it turned out pretty good too! Also nice if you ever need help onboarding someone to this section of code I could at least take a \"first pass\" at showing/explaining stuff <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 253170677,
        "sender_full_name": "DevinR528",
        "timestamp": 1631572272
    },
    {
        "content": "<p>thanks for being patient with my comments!</p>",
        "id": 253170695,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631572286
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243877\">DevinR528</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Non.20exhaustive.20reachable.20patterns.20lint.20lang-team.23112/near/253170677\">said</a>:</p>\n<blockquote>\n<p>Also nice if you ever need help onboarding someone to this section of code I could at least take a \"first pass\" at showing/explaining stuff <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>\n</blockquote>\n<p>oh yeah that'd be lovely! This is a rarely touched section of the compiler though ^^</p>",
        "id": 253170918,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631572440
    },
    {
        "content": "<p>Yeah I noticed I could see the end of the commit history in the userfulness file with little to no scrolling <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span></p>",
        "id": 253184049,
        "sender_full_name": "DevinR528",
        "timestamp": 1631581901
    },
    {
        "content": "<p>ah that's because this and deconstruct_pat used to be a single file and I split them recently. If you go back in time you can find a <code>_match.rs</code> file that has a lot more history behind it</p>",
        "id": 253186034,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631583797
    },
    {
        "content": "<p>Ahh gotcha that makes more sense.</p>",
        "id": 253186052,
        "sender_full_name": "DevinR528",
        "timestamp": 1631583824
    },
    {
        "content": "<p>and then there's the move of a ton of files to <code>compiler/</code> that also broke the history</p>",
        "id": 253186156,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631583924
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"245339\">@Nadrieril</span> </p>\n<p>Do we have to wait for more approvals? Oh should I squash to 1 commit for getting it ready to merge?</p>",
        "id": 253288815,
        "sender_full_name": "DevinR528",
        "timestamp": 1631640108
    },
    {
        "content": "<p>nope we were just waiting for me to get back from work ^^</p>",
        "id": 253290135,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631640591
    },
    {
        "content": "<p>you don't even need to squash since your commits are readable. Do you want to anyway?</p>",
        "id": 253290316,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631640645
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243877\">@DevinR528</span> lemme know which you prefer, I'm ready to merge either way</p>",
        "id": 253290417,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631640680
    },
    {
        "content": "<p>I'm fine with not squashing I think all the messages were decent and bors kinda squashes anyways right?</p>",
        "id": 253292690,
        "sender_full_name": "DevinR528",
        "timestamp": 1631641537
    },
    {
        "content": "<p>bors does not squash</p>",
        "id": 253292801,
        "sender_full_name": "simulacrum",
        "timestamp": 1631641575
    },
    {
        "content": "<p>Oh just a merge commit?</p>",
        "id": 253292876,
        "sender_full_name": "DevinR528",
        "timestamp": 1631641612
    },
    {
        "content": "<p>Generally we don't want \"address review\" or similar commits in history, if I'm looking at the right PR</p>",
        "id": 253292877,
        "sender_full_name": "simulacrum",
        "timestamp": 1631641613
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/issues/86809\">#86809</a> looks like it has quite a few \"fixup\" commits basically, which is great for PR review but less great for long-term git blame and such</p>",
        "id": 253292992,
        "sender_full_name": "simulacrum",
        "timestamp": 1631641678
    },
    {
        "content": "<p>Yeah I do think there were a few of those. I'll be back to my computer in an hour or so and I'll squash the review commits <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 253293079,
        "sender_full_name": "DevinR528",
        "timestamp": 1631641711
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Non.20exhaustive.20reachable.20patterns.20lint.20lang-team.23112/near/253292877\">said</a>:</p>\n<blockquote>\n<p>Generally we don't want \"address review\" or similar commits in history, if I'm looking at the right PR</p>\n</blockquote>\n<p>ok, good to know</p>",
        "id": 253293204,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631641784
    },
    {
        "content": "<p>Pushed squashed commit. Would it be a good idea to rewrite the first comment of the PR so it describes what the state is now (like \"This PR adds ...\")</p>",
        "id": 253312330,
        "sender_full_name": "DevinR528",
        "timestamp": 1631648845
    },
    {
        "content": "<p>Yes, that would be great -- the PR description gets put into commit history by bors, so keeping it updated is a great thing. Also helps reviewers and others looking at the PR later down the line (e.g., release note writers :)</p>",
        "id": 253312542,
        "sender_full_name": "simulacrum",
        "timestamp": 1631648930
    },
    {
        "content": "<p>Since the initial comment goes into the commit msg is it bad form to add an example?</p>",
        "id": 253314181,
        "sender_full_name": "DevinR528",
        "timestamp": 1631649570
    },
    {
        "content": "<p>Or is this enough <a href=\"https://github.com/rust-lang/rust/pull/86809#issue-682590854\">https://github.com/rust-lang/rust/pull/86809#issue-682590854</a></p>",
        "id": 253314240,
        "sender_full_name": "DevinR528",
        "timestamp": 1631649597
    },
    {
        "content": "<p>Examples etc are totally fine, the actual content can be long/short whatever</p>",
        "id": 253314368,
        "sender_full_name": "simulacrum",
        "timestamp": 1631649622
    },
    {
        "content": "<p>just outdated is unfortunate :)</p>",
        "id": 253314419,
        "sender_full_name": "simulacrum",
        "timestamp": 1631649633
    },
    {
        "content": "<p>oops I started the merge before seeing this</p>",
        "id": 253330503,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631656802
    },
    {
        "content": "<p>ah good, you updated the comment</p>",
        "id": 253330682,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631656853
    },
    {
        "content": "<p>yeee done, this is a cool new lint I'm excited to see ppl using it</p>",
        "id": 253330791,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631656914
    },
    {
        "content": "<p>Yeah I agree!! I might open a WIP, until this hits stable, PR for syn adding this (I think syn was one of the original examples). I'd also be interested in working on private enum variants.</p>",
        "id": 253333695,
        "sender_full_name": "DevinR528",
        "timestamp": 1631658524
    },
    {
        "content": "<p>ooh I want private enum variants, is there an RFC for that?</p>",
        "id": 253342919,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631664341
    },
    {
        "content": "<p>as far as I can see they were all closed. It keeps popping up though</p>",
        "id": 253343212,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631664522
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rfcs/pull/2028\">This</a> seems to be closed because of non_exhaustive but I agree with <a href=\"https://github.com/rust-lang/rfcs/pull/2028#issuecomment-422547712\">this comment</a> that it is not the same thing.</p>",
        "id": 253347456,
        "sender_full_name": "DevinR528",
        "timestamp": 1631667837
    },
    {
        "content": "<p>I agree too</p>",
        "id": 253388036,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631699566
    },
    {
        "content": "<p>still, doesn't look like we'll be implementing it anytime soon</p>",
        "id": 253388072,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631699594
    },
    {
        "content": "<blockquote>\n<p>still, doesn't look like we'll be implementing it anytime soon</p>\n</blockquote>\n<p>Yeah, the fact that there is disagreement means it will be awhile <span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span> </p>\n<p>It looks like <a href=\"https://github.com/rust-lang/rust/issues/88924\">this issue</a> was closed based on <a href=\"https://github.com/actions/virtual-environments/issues/4086\">this issue</a> (sorry to bug you <span class=\"user-mention\" data-user-id=\"245339\">@Nadrieril</span> )</p>",
        "id": 253404130,
        "sender_full_name": "DevinR528",
        "timestamp": 1631708599
    },
    {
        "content": "<p>Oh cool</p>",
        "id": 253404449,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631708761
    },
    {
        "content": "<p>And @ehuss was super fast ^^</p>",
        "id": 253404524,
        "sender_full_name": "Nadrieril",
        "timestamp": 1631708790
    },
    {
        "content": "<p>We did it!!! Tomorrow the <code>#[warn(non_exhaustive_omitted_patterns)]</code> lint should work <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span></p>",
        "id": 253593762,
        "sender_full_name": "DevinR528",
        "timestamp": 1631803587
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243877\">@DevinR528</span> I'm catching up here -- that's awesome! Was there a PR?</p>",
        "id": 255251701,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1632848497
    },
    {
        "content": "<p>Thanks! I couldn't have done without <span class=\"user-mention\" data-user-id=\"245339\">@Nadrieril</span> he was awesomely helpful.</p>\n<p>The PR <a href=\"https://github.com/rust-lang/rust/pull/86809\">https://github.com/rust-lang/rust/pull/86809</a> was merged but this issue was filed <a href=\"https://github.com/rust-lang/rust/issues/89042\">https://github.com/rust-lang/rust/issues/89042</a> and this PR against that issue <a href=\"https://github.com/rust-lang/rust/pull/89105\">https://github.com/rust-lang/rust/pull/89105</a></p>",
        "id": 255252831,
        "sender_full_name": "DevinR528",
        "timestamp": 1632848890
    },
    {
        "content": "<p>Awesome</p>",
        "id": 255268507,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1632851973
    },
    {
        "content": "<p>Wow exhaustive checking in skip lang looks familiar <a href=\"https://github.com/skiplang/skip/blob/master/src/frontend/skipExhaustivePatterns.sk\">https://github.com/skiplang/skip/blob/master/src/frontend/skipExhaustivePatterns.sk</a> <span aria-label=\"smiley\" class=\"emoji emoji-1f603\" role=\"img\" title=\"smiley\">:smiley:</span></p>",
        "id": 257297069,
        "sender_full_name": "DevinR528",
        "timestamp": 1634088902
    },
    {
        "content": "<p>Just wondering if anyone has opinions about <a href=\"https://github.com/rust-lang/rust/issues/89042\">https://github.com/rust-lang/rust/issues/89042</a> and <a href=\"https://github.com/rust-lang/rust/pull/90358#discussion_r747763197\">https://github.com/rust-lang/rust/pull/90358#discussion_r747763197</a></p>\n<p>TL;DR:<br>\nNow that <code>non_exhaustive</code> struct and enum patterns can show all fields/variants we ran into problems with stdlib internal <code>stable/unstable</code> fields and variants, so they had to be filtered out of the pattern set when preparing for the error message. The decision that needs to be made is about <code>doc(hidden)</code> fields and variants, should they be filtered out and replaced with a wildcard suggestion?</p>",
        "id": 262076253,
        "sender_full_name": "DevinR528",
        "timestamp": 1637333770
    }
]