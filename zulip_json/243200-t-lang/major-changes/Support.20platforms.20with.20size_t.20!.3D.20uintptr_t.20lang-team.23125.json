[
    {
        "content": "<p>A new proposal has been announced: <a href=\"https://github.com/rust-lang/lang-team/issues/125\">Support platforms with size_t != uintptr_t #125</a>. It will be announced at the next meeting to try and draw attention to it, but usually MCPs are not discussed during triage meetings. If you think this would benefit from discussion amongst the team, consider proposing a design meeting.</p>",
        "id": 259426954,
        "sender_full_name": "triagebot",
        "timestamp": 1635443518
    },
    {
        "content": "<p>Neither of the proposed solutions involve a new core type, which seems unfortunate.</p>",
        "id": 259427815,
        "sender_full_name": "Lokathor",
        "timestamp": 1635443830
    },
    {
        "content": "<p>or maybe it could be said that <em>both</em> of the solutions involve a new core type and we're just picking which usize is and then either uptr or uindex is the one that usize isn't.</p>",
        "id": 259428024,
        "sender_full_name": "Lokathor",
        "timestamp": 1635443904
    },
    {
        "content": "<p>Yeah. The intent is that it can be dealt with when there's a more clear idea of what way to progress, whether we get a new core language type or a <code>c_size_t</code> in either std::os:raw or even core::ffi (both of which are T-libs domain I believe).</p>",
        "id": 259428334,
        "sender_full_name": "Connor Horman",
        "timestamp": 1635444009
    },
    {
        "content": "<p>if we want to handle this properly, and they're really different sizes, then it probably shouldn't be just a C thing. rust in general would need to be much more aware of the difference, including the Index trait and such.</p>",
        "id": 259435556,
        "sender_full_name": "Lokathor",
        "timestamp": 1635447264
    },
    {
        "content": "<p>Yeah, <em>if</em> we want to do this (which I'm not yet sure of), I do think we need a new type <code>uptr</code>.</p>",
        "id": 259444422,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1635451434
    },
    {
        "content": "<p>This would be a massive, wide-sweeping change down either path, though.</p>",
        "id": 259445058,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1635451729
    },
    {
        "content": "<p>Either everyone using <code>usize</code> as <code>size_t</code> needs to change their code, or everyone using <code>usize</code> as \"integer big enough to hold and round-trip a pointer value\" needs to change their code, or we declare the two equal and live with not supporting platforms that do otherwise.</p>",
        "id": 259445120,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1635451785
    },
    {
        "content": "<p>None of those is a desirable outcome.</p>",
        "id": 259445135,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1635451795
    },
    {
        "content": "<p>I personally feel that we should <em>not</em> have a thing named <code>usize</code> be something other than <code>size_t</code>; that's going to be incredibly confusing.</p>",
        "id": 259445225,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1635451826
    },
    {
        "content": "<p>you don't even need <code>usize as size_t</code> now, because it's a direct type alias</p>",
        "id": 259445233,
        "sender_full_name": "cuviper",
        "timestamp": 1635451829
    },
    {
        "content": "<p>Having <code>usize</code> be <code>size_t</code> and <code>uptr</code> be <code>uintptr_t</code> is at least understandable, though disruptive.</p>",
        "id": 259445274,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1635451853
    },
    {
        "content": "<p>Having <code>usize</code> be <code>uintptr_t</code> and something <em>else</em> be <code>size_t</code> seems deeply confusing and a source of many, many errors.</p>",
        "id": 259445345,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1635451894
    },
    {
        "content": "<blockquote>\n<p>Having usize be uintptr_t and something else be size_t seems deeply confusing and a source of many, many errors.</p>\n</blockquote>\n<p>Maybe, but we've also promised (in RFCs and in other text) that <code>usize</code> was large enough to roundtrip a pointer. Going back on that promise really sucks IMO.</p>",
        "id": 259446161,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1635452249
    },
    {
        "content": "<p>Yeah. I mentioned that in the MCP and in the original IRLO pre-rfc. rfc 544 says explicitly it's the pointer-sized type.</p>",
        "id": 259446266,
        "sender_full_name": "Connor Horman",
        "timestamp": 1635452300
    },
    {
        "content": "<p>uindex/iindex ?</p>",
        "id": 259446823,
        "sender_full_name": "Lokathor",
        "timestamp": 1635452566
    },
    {
        "content": "<p>Maybe those would be good names for <code>size_t</code> <code>ptrdiff_t</code>. However, that doesn't solve one of the larger issues with not making <code>usize</code>=<code>size_t</code>, which is the amount of code that relies on the type being equivalent to <code>size_t</code>, that's going to be broken, and isn't going to be noisly broken either. That was actually one of the main reasons that made me reconsider making <code>usize</code>=<code>size_t</code> and reversing the guarantee from RFC 544: in that case, at least the breakage is loud and obnoxious (though only with a lint until a new edition) instead of completely silent until such code is compiled on one of these platforms.</p>",
        "id": 259447189,
        "sender_full_name": "Connor Horman",
        "timestamp": 1635452754
    },
    {
        "content": "<p>The fact that they're named <code>size</code> but have the pointer semantics was even called out in the original RFC — <a href=\"https://github.com/nox/rust-rfcs/blob/master/text/0544-rename-int-uint.md#drawbacks-of-isizeusize\">https://github.com/nox/rust-rfcs/blob/master/text/0544-rename-int-uint.md#drawbacks-of-isizeusize</a></p>",
        "id": 259447760,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1635453058
    },
    {
        "content": "<p>Yeah, indeed.</p>",
        "id": 259447785,
        "sender_full_name": "Connor Horman",
        "timestamp": 1635453075
    },
    {
        "content": "<p>… are there any platforms where <code>sizeof(size_t)</code> must be greater than <code>sizeof(uintptr_t)</code>?</p>",
        "id": 259461631,
        "sender_full_name": "nagisa",
        "timestamp": 1635460952
    },
    {
        "content": "<p>I don't necessarily see a conflict either way though, <code>usize</code> _could_ be <code>max(sizeof(size_t), sizeof(uintptr_t))</code>. That way it can both be suitable for indexing and for pointer roundtrips.</p>",
        "id": 259461717,
        "sender_full_name": "nagisa",
        "timestamp": 1635461001
    },
    {
        "content": "<p>then it's just not suitable for folks who <em>assume</em> <code>usize</code> is equal to those in FFI</p>",
        "id": 259461831,
        "sender_full_name": "cuviper",
        "timestamp": 1635461058
    },
    {
        "content": "<p>well, if both of them are different, <code>usize</code> can't possibly be equal to both, can it?</p>",
        "id": 259461882,
        "sender_full_name": "nagisa",
        "timestamp": 1635461102
    },
    {
        "content": "<p>no it can't</p>",
        "id": 259461904,
        "sender_full_name": "cuviper",
        "timestamp": 1635461117
    },
    {
        "content": "<p>So the assumption can't hold either way (well, for code that purports to be portable, anyway)</p>",
        "id": 259462053,
        "sender_full_name": "nagisa",
        "timestamp": 1635461189
    },
    {
        "content": "<p>it's a bad assumption, but <code>bindgen --size_t-is-usize</code> is a thing</p>",
        "id": 259462136,
        "sender_full_name": "cuviper",
        "timestamp": 1635461262
    },
    {
        "content": "<p>and <code>cbindgen</code> hardcodes a mapping for <code>usize =&gt; uintptr_t</code><br>\n<a href=\"https://github.com/eqrion/cbindgen/blob/master/docs.md#std-types\">https://github.com/eqrion/cbindgen/blob/master/docs.md#std-types</a></p>",
        "id": 259462350,
        "sender_full_name": "cuviper",
        "timestamp": 1635461402
    },
    {
        "content": "<p>hmm, and also a config option:</p>\n<div class=\"codehilite\"><pre><span></span><code># If this option is true `usize` and `isize` will be converted into `size_t` and `ptrdiff_t`\n# instead of `uintptr_t` and `intptr_t` respectively.\nusize_is_size_t = true\n</code></pre></div>",
        "id": 259462751,
        "sender_full_name": "cuviper",
        "timestamp": 1635461665
    },
    {
        "content": "<p>Yes, this is not the only poor decision made by <code>cbindgen</code>; it focuses on convenience over correctness/pedantry at times.</p>",
        "id": 259462871,
        "sender_full_name": "nagisa",
        "timestamp": 1635461742
    },
    {
        "content": "<p>I don't see it as a particularly huge problem though; its something <code>cbindgen</code> could fix by releasing more versions and yanking some others.</p>",
        "id": 259462958,
        "sender_full_name": "nagisa",
        "timestamp": 1635461782
    },
    {
        "content": "<p>the pedantic solution would be that <code>usize</code> and <code>isize</code> should not be used in FFI at all, right?</p>",
        "id": 259463050,
        "sender_full_name": "cuviper",
        "timestamp": 1635461861
    },
    {
        "content": "<p>Yeah, except _maybe_ through type aliases?</p>",
        "id": 259463131,
        "sender_full_name": "nagisa",
        "timestamp": 1635461901
    },
    {
        "content": "<p>(well, or in unportable code)</p>",
        "id": 259463144,
        "sender_full_name": "nagisa",
        "timestamp": 1635461918
    },
    {
        "content": "<p>(Option 3 remains \"usize is the size of size_t and of a pointer, which are required to be equal\".)</p>",
        "id": 259463173,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1635461943
    },
    {
        "content": "<p>If making usize not size_t is too painful, and making usize not round-trip a pointer is too painful, then that'd be what we're left with.</p>",
        "id": 259463206,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1635461971
    },
    {
        "content": "<p>I also want to say that what C code I have read in the past, I haven't seen much of it that used <code>*size_t</code> and <code>*intptr_t</code> correctly either, so I see a lot of value in not having 2 types for this.</p>",
        "id": 259463210,
        "sender_full_name": "nagisa",
        "timestamp": 1635461973
    },
    {
        "content": "<p>I've honestly never seen production code that used <code>uintptr_t</code> for <em>anything</em>.</p>",
        "id": 259463276,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1635462004
    },
    {
        "content": "<p>All the systems I've seen that assumed there was a pointer-sized integer spelled it <code>unsigned long</code> (which is emphatically not portable, but works widely if you're not on Windows).</p>",
        "id": 259463374,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1635462048
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> that Option 3 means saying \"no\" to the <code>$subject</code>, we can't support such platforms</p>",
        "id": 259463434,
        "sender_full_name": "cuviper",
        "timestamp": 1635462096
    },
    {
        "content": "<p>but that is an option</p>",
        "id": 259463436,
        "sender_full_name": "cuviper",
        "timestamp": 1635462099
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"138448\">cuviper</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Support.20platforms.20with.20size_t.20!.3D.20uintptr_t.20lang-team.23125/near/259463434\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> that Option 3 means saying \"no\" to the <code>$subject</code>, we can't support such platforms</p>\n</blockquote>\n<p>I realize that, yes.</p>",
        "id": 259463522,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1635462144
    },
    {
        "content": "<p>Or rather, we can't support such platforms without some additional compromises.</p>",
        "id": 259463532,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1635462158
    },
    {
        "content": "<p>For instance, using a less efficient size_t on 65c816.</p>",
        "id": 259463590,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1635462205
    },
    {
        "content": "<p><em>we</em> don't get to choose <code>size_t</code></p>",
        "id": 259463615,
        "sender_full_name": "cuviper",
        "timestamp": 1635462233
    },
    {
        "content": "<p>There isn't one single established standard ABI for that platform; the proposed Rust target is setting the sizes.</p>",
        "id": 259463874,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1635462397
    },
    {
        "content": "<p>Last it heard, it sounded like it could set them differently.</p>",
        "id": 259463885,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1635462406
    },
    {
        "content": "<p>Yeah, this would implicate the C abi.</p>",
        "id": 259463890,
        "sender_full_name": "Connor Horman",
        "timestamp": 1635462410
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Support.20platforms.20with.20size_t.20!.3D.20uintptr_t.20lang-team.23125/near/259463276\">said</a>:</p>\n<blockquote>\n<p>I've honestly never seen production code that used <code>uintptr_t</code> for <em>anything</em>.</p>\n</blockquote>\n<p>it's... pretty common in my experience <a href=\"https://searchfox.org/mozilla-central/search?q=uintptr_t\">https://searchfox.org/mozilla-central/search?q=uintptr_t</a></p>",
        "id": 259464002,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1635462497
    },
    {
        "content": "<p>i think CHERI is a bigger concern than w65, tbf, and it can't choose the sizes</p>",
        "id": 259464072,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1635462556
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Support.20platforms.20with.20size_t.20!.3D.20uintptr_t.20lang-team.23125/near/259463885\">said</a>:</p>\n<blockquote>\n<p>Last it heard, it sounded like it could set them differently.</p>\n</blockquote>\n<p>The abi I'm working on can in theory be changed, right up until the completion of the gcc fork. However, the question would end up being how that impacts the ability to generate reasonable code. integers of size&gt;2 have less than optimal abi when the maximum value in most cases for <code>size_t</code> is still 64k. The benchmark I've been using is cycle-counting the <code>mem*</code> functions.</p>",
        "id": 259464607,
        "sender_full_name": "Connor Horman",
        "timestamp": 1635462944
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"209168\">@Thom Chiovoloni</span> FWIW, I wasn't doubting it was used; just noting that I hadn't seen it in any of the codebases I had encountered.</p>",
        "id": 259469467,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1635466812
    },
    {
        "content": "<p>And yes, I'm concerned about CHERI as well. I'm wondering what userspace and things like mmap look like on such a platform.</p>",
        "id": 259469521,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1635466863
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Support.20platforms.20with.20size_t.20!.3D.20uintptr_t.20lang-team.23125/near/259446161\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>Having usize be uintptr_t and something else be size_t seems deeply confusing and a source of many, many errors.</p>\n</blockquote>\n<p>Maybe, but we've also promised (in RFCs and in other text) that <code>usize</code> was large enough to roundtrip a pointer. Going back on that promise really sucks IMO.</p>\n</blockquote>\n<p>I think this is an instance where having future programmers go \"why did they write this in such a confusing way? it's impossible to learn\" would really suck. I'm not saying for sure that breaking our past commitments is acceptable here either, but if I had to pick one, it strikes me as by far the less bad of the two options.</p>",
        "id": 261579779,
        "sender_full_name": "inquisitivecrystal",
        "timestamp": 1637021243
    },
    {
        "content": "<p>Breaking past commitments means peoples code can break in a rustc update, which we've been very careful to avoid because it strands people on old versions.</p>",
        "id": 261580461,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1637021737
    },
    {
        "content": "<p>In general, rust strives to have a good story around backwards compatibility, so breaking it here would be very unfortunate.</p>",
        "id": 261580532,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1637021764
    },
    {
        "content": "<p>The other direction means that as new targets that don't support this exist, then yeah, perhaps $lib doesn't support that target out of the box, but people on that target are likely going to be used to that at first, since many C libraries will be in that camp too.</p>",
        "id": 261580619,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1637021832
    },
    {
        "content": "<p>Yeah, the consideration isn't \"Which change isn't breaking\" it's \"what change is the least breaking, and how can we do it the least problematically.\"</p>",
        "id": 261585504,
        "sender_full_name": "Connor Horman",
        "timestamp": 1637025163
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Support.20platforms.20with.20size_t.20!.3D.20uintptr_t.20lang-team.23125/near/261580461\">said</a>:</p>\n<blockquote>\n<p>Breaking past commitments means peoples code can break in a rustc update, which we've been very careful to avoid because it strands people on old versions.</p>\n</blockquote>\n<p>Well, if I understand correctly, only on new platforms. Which is not great, but I'd argue infinitely better than it breaking on existing platforms. Am I missing something?</p>",
        "id": 261624027,
        "sender_full_name": "inquisitivecrystal",
        "timestamp": 1637060287
    }
]