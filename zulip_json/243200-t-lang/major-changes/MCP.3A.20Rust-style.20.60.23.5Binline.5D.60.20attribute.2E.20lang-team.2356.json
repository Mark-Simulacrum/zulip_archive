[
    {
        "content": "<p>A new proposal has been announced: <a href=\"https://github.com/rust-lang/lang-team/issues/56\">MCP: Rust-style <code>#[inline]</code> attribute. #56</a>. It will be announced at the next meeting to try and draw attention to it, but usually MCPs are not discussed during triage meetings. If you think this would benefit from discussion amongst the team, consider proposing a design meeting.</p>",
        "id": 210623728,
        "sender_full_name": "triagebot",
        "timestamp": 1600533700
    },
    {
        "content": "<blockquote>\n<p>** #[inline] -&gt; try the compiler's best to inline (always invoke MIR inliner), keep silent when failing to do so (and tag as alwaysinline to ask llvm to try again).</p>\n</blockquote>\n<p>did you mean to say 'tag as inlinehint to ask to try again'? seems odd to mark <code>#[inline]</code> as <code>alwaysinline</code></p>",
        "id": 210623883,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600533853
    },
    {
        "content": "<p>It feels like this should be a T-compiler MCP; I don't see why this needs lang team involvement modulo the lint suggestion.</p>",
        "id": 210623972,
        "sender_full_name": "simulacrum",
        "timestamp": 1600533977
    },
    {
        "content": "<p>I think the claim is that <code>inlinehint</code> is not particularly useful</p>",
        "id": 210623973,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600533979
    },
    {
        "content": "<p>But the lint seems good to add (much) later, when we can say things like \"it rarely triggers\" (or vice versa).</p>",
        "id": 210623987,
        "sender_full_name": "simulacrum",
        "timestamp": 1600533998
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232545\">@Joshua Nelson</span>  I propose interpreting <code>#[inline]</code> as intentional and we should try our best to inline the function.</p>",
        "id": 210624007,
        "sender_full_name": "Charles Lew",
        "timestamp": 1600534025
    },
    {
        "content": "<p>(I also think that IIRC we don't have a working MIR inliner yet...?)</p>",
        "id": 210624011,
        "sender_full_name": "simulacrum",
        "timestamp": 1600534043
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> There're related chapters in the reference. That's why i submitted this as a language mcp.</p>",
        "id": 210624020,
        "sender_full_name": "Charles Lew",
        "timestamp": 1600534071
    },
    {
        "content": "<p>I don't see that they would need to change (again modulo the lint that I think we're not prepared to discuss without an impl)</p>",
        "id": 210624093,
        "sender_full_name": "simulacrum",
        "timestamp": 1600534144
    },
    {
        "content": "<p>I guess I'm not understanding the difference between <code>inline</code> and <code>inline(always)</code> in your proposal. Is the difference that <code>always</code> warns if it's inlined by llvm instead of Mir opts? That doesn't seem very useful</p>",
        "id": 210624165,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600534267
    },
    {
        "content": "<p>I think... I'm proposing change <code>#[inline]</code> from a hint to a requirement <a href=\"https://doc.rust-lang.org/nightly/reference/attributes/codegen.html?highlight=inline#the-inline-attribute\">in the reference</a>.</p>",
        "id": 210624173,
        "sender_full_name": "Charles Lew",
        "timestamp": 1600534286
    },
    {
        "content": "<p>my question is higher-level: why do we need to change the language spec for this?</p>",
        "id": 210624176,
        "sender_full_name": "simulacrum",
        "timestamp": 1600534297
    },
    {
        "content": "<p>I don't see what we get by making it a requirement</p>",
        "id": 210624183,
        "sender_full_name": "simulacrum",
        "timestamp": 1600534310
    },
    {
        "content": "<p>I'd like to note that inline and inline(always) actually do make a <em>correctness</em> difference in the presence of cpu features. inline(always) <em>can</em> convince llvm to inline a different cpu featured function, while inline cannot.</p>",
        "id": 210624186,
        "sender_full_name": "Lokathor",
        "timestamp": 1600534319
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> I think that's perhaps an llvm bug or \"misfeature\" in some sense though?</p>",
        "id": 210624238,
        "sender_full_name": "simulacrum",
        "timestamp": 1600534352
    },
    {
        "content": "<p>do you have an example?</p>",
        "id": 210624243,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600534359
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> probably, but it's a danger either way</p>",
        "id": 210624252,
        "sender_full_name": "Lokathor",
        "timestamp": 1600534384
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> not offhand.</p>",
        "id": 210624270,
        "sender_full_name": "Lokathor",
        "timestamp": 1600534421
    },
    {
        "content": "<p>How would a correctness bug occur here?</p>",
        "id": 210624314,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600534449
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> For example, when user specify <code>#[inline]</code>, instead of heuristically calculating whether it might be beneficial at call site, we always just inline the call.</p>",
        "id": 210624315,
        "sender_full_name": "Charles Lew",
        "timestamp": 1600534458
    },
    {
        "content": "<p>I think it was <span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> who pointed out to me that inline(always) can force a cross-feature inlining</p>",
        "id": 210624316,
        "sender_full_name": "Lokathor",
        "timestamp": 1600534459
    },
    {
        "content": "<p>So we're no longer relying LLVM to decide.</p>",
        "id": 210624321,
        "sender_full_name": "Charles Lew",
        "timestamp": 1600534477
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116458\">@Charles Lew</span> my point is that we can do that in the compiler <em>now</em> without language spec changes (well, we could if MIR inlining worked...)</p>",
        "id": 210624328,
        "sender_full_name": "simulacrum",
        "timestamp": 1600534501
    },
    {
        "content": "<p>but it's a pretty big requirement on compiler implementors to have to support this and doesn't seem hugely beneficial</p>",
        "id": 210624338,
        "sender_full_name": "simulacrum",
        "timestamp": 1600534522
    },
    {
        "content": "<p>under what circumstances would inline or inline(always) fail? (My guess is only recursive functions.) In particular, can mir always detect such situations before turning it over to llvm?</p>",
        "id": 210624346,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600534552
    },
    {
        "content": "<p>if so, then Joshua's concern about warning on inlining that mir fails to do and llvm succeeds wouldn't be an issue</p>",
        "id": 210624399,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600534599
    },
    {
        "content": "<p>my point is that we have failed to write a working MIR inliner for over 2 years now, and not fully through lack of effort</p>",
        "id": 210624422,
        "sender_full_name": "simulacrum",
        "timestamp": 1600534675
    },
    {
        "content": "<p>so requiring every implementation of Rust to do it seems... overly harsh</p>",
        "id": 210624459,
        "sender_full_name": "simulacrum",
        "timestamp": 1600534687
    },
    {
        "content": "<p>It is also possible to suppress the warning even if mir doesn't do the inlining as long as we are confident that llvm will</p>",
        "id": 210624468,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600534710
    },
    {
        "content": "<p>Another high level point: I don't think Ilvm and mir should be written into the language spec</p>",
        "id": 210624487,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600534770
    },
    {
        "content": "<p>What happens if you don't use llvm as a backend? What would the warning mean?</p>",
        "id": 210624492,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600534789
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> <br>\nThe situation i want to improve is that:   Currently libstd <code>Option::map</code> has an <code>#[inline]</code> attribute, and currently rustc compiler doesn't know whether it will be inlined for a specific <code>T</code> type.</p>",
        "id": 210624501,
        "sender_full_name": "Charles Lew",
        "timestamp": 1600534802
    },
    {
        "content": "<p>The warning means we could not ensure that it was inlined</p>",
        "id": 210624533,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600534806
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116458\">@Charles Lew</span> I am confused -- making this a language-level guarantee doesn't help with that at all?</p>",
        "id": 210624548,
        "sender_full_name": "simulacrum",
        "timestamp": 1600534834
    },
    {
        "content": "<p>it should be correct for a rust implementation to never inline and just give a warning on every <code>inline(always)</code></p>",
        "id": 210624549,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600534836
    },
    {
        "content": "<p>Inlining has user-visible effects in some cases: I use a combination of <code>#[inline(always)]</code> and <code>#[inline(never)]</code> to skip a fixed number of frames in my custom backtrace implementation. At the very least <code>#[inline(never)]</code> should be a hard guarantee.</p>",
        "id": 210624555,
        "sender_full_name": "Amanieu",
        "timestamp": 1600534854
    },
    {
        "content": "<p>If the promise is that this will be always inlined, mir inliner can just go ahead and  inline it.</p>",
        "id": 210624569,
        "sender_full_name": "Charles Lew",
        "timestamp": 1600534892
    },
    {
        "content": "<p>it doesn't need to supply this to llvm inliner any more.</p>",
        "id": 210624575,
        "sender_full_name": "Charles Lew",
        "timestamp": 1600534907
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116458\">@Charles Lew</span> I don't understand I guess, MIR inlining isn't hard because we're not sure whether to inline or not</p>",
        "id": 210624590,
        "sender_full_name": "simulacrum",
        "timestamp": 1600534923
    },
    {
        "content": "<p>Sorry, i'm not very familiar with the implementation details, maybe there're some deeper reasons?</p>",
        "id": 210624663,
        "sender_full_name": "Charles Lew",
        "timestamp": 1600535034
    },
    {
        "content": "<p><em>If</em> we had a working inliner, then maybe this MCP would make more sense to me, though I do not find it personally convincing. I think I would prefer that we have other attributes for \"no I really do need this to have a significant callframe for e.g. <span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span>'s case\" or \"yes, please do inline this so that the target CPU/feature attributes work out, for <span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span>'s case\"</p>",
        "id": 210624665,
        "sender_full_name": "simulacrum",
        "timestamp": 1600535040
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116458\">@Charles Lew</span> the reasons MIR inlining is hard have ~nothing to do with the language not guaranteeing inlining</p>",
        "id": 210624711,
        "sender_full_name": "simulacrum",
        "timestamp": 1600535070
    },
    {
        "content": "<p>I'm with Amanieu, i want a \"inline(absolutely_never)\"</p>",
        "id": 210624734,
        "sender_full_name": "Lokathor",
        "timestamp": 1600535125
    },
    {
        "content": "<p><code>#[inline(never)]</code> currently already does this, there is no need to change anything.</p>",
        "id": 210624745,
        "sender_full_name": "Amanieu",
        "timestamp": 1600535150
    },
    {
        "content": "<p>Wouldn't <code>inline(always)</code> then just be the counterpoint to that?</p>",
        "id": 210624788,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600535173
    },
    {
        "content": "<p>I think there are some edge cases where <code>#[inline(always)]</code> will refuse to inline. I'll need to double-check.</p>",
        "id": 210624801,
        "sender_full_name": "Amanieu",
        "timestamp": 1600535207
    },
    {
        "content": "<p>Currently <code>#[inline(never)]</code> is also a suggestion.</p>",
        "id": 210624804,
        "sender_full_name": "Charles Lew",
        "timestamp": 1600535211
    },
    {
        "content": "<p>yeah i thought that inline(never) was a hint, and thus could potentially fail</p>",
        "id": 210624807,
        "sender_full_name": "Lokathor",
        "timestamp": 1600535220
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"cp\">#[inline(always)]</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\">  </span><span class=\"n\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n\n\n<p>definitely will fail...</p>",
        "id": 210624827,
        "sender_full_name": "Charles Lew",
        "timestamp": 1600535271
    },
    {
        "content": "<p>when I want <code>inline(always_really_no_joke)</code> I use a macro <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 210624830,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600535278
    },
    {
        "content": "<p>recursive functions are pretty easy to detect though. It could either look for the pattern specifically or just use a depth limit</p>",
        "id": 210624903,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600535344
    },
    {
        "content": "<p>no, it's halting problem.</p>",
        "id": 210624908,
        "sender_full_name": "Charles Lew",
        "timestamp": 1600535372
    },
    {
        "content": "<p>huh? The call graph is statically known</p>",
        "id": 210624923,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600535401
    },
    {
        "content": "<p>it's as hard as finding cycles in a graph</p>",
        "id": 210624966,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600535411
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"cp\">#[inline(always)]</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">silly_true</span><span class=\"p\">(</span><span class=\"n\">first_landing</span>: <span class=\"kt\">bool</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">bool</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">first_entry</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">!</span><span class=\"n\">silly_false</span><span class=\"p\">(</span><span class=\"kc\">false</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kc\">true</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"cp\">#[inline(always)]</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">silly_false</span><span class=\"p\">(</span><span class=\"n\">first_landing</span>: <span class=\"kt\">bool</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">bool</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">first_entry</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">!</span><span class=\"n\">silly_true</span><span class=\"p\">(</span><span class=\"kc\">false</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kc\">false</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 210624967,
        "sender_full_name": "Charles Lew",
        "timestamp": 1600535412
    },
    {
        "content": "<p>yeah that's a recursive function</p>",
        "id": 210624986,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600535450
    },
    {
        "content": "<p>for example, this can and should be inlined successfully intuitively.</p>",
        "id": 210624999,
        "sender_full_name": "Charles Lew",
        "timestamp": 1600535465
    },
    {
        "content": "<p>Not really, you are relying on a certain order of operations to ensure that</p>",
        "id": 210625010,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600535489
    },
    {
        "content": "<p>there are definitely nonterminating reduction strategies on that code</p>",
        "id": 210625018,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600535513
    },
    {
        "content": "<p>but for all input they both terminates...</p>",
        "id": 210625061,
        "sender_full_name": "Charles Lew",
        "timestamp": 1600535546
    },
    {
        "content": "<p>\"can\", yes. \"should\", absolutely not unless you want to try to legislate the halting problem</p>",
        "id": 210625065,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600535564
    },
    {
        "content": "<p>Who cares if they terminate on all inputs, we're not running the code we're inlining it</p>",
        "id": 210625080,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600535614
    },
    {
        "content": "<p>in order to successfully inline that code you have to do a bit of inlining, then a bit of constant propagation, then a bit of dead code elimination, in that order</p>",
        "id": 210625142,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600535695
    },
    {
        "content": "<p>if you do inlining then inlining then inlining some more then you fail to halt</p>",
        "id": 210625143,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600535695
    },
    {
        "content": "<p>so from a language design perspective you really have to say \"that's recursive, <code>inline(always)</code> not allowed\"</p>",
        "id": 210625163,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600535741
    },
    {
        "content": "<p>Yes, indeed! That's why i want to lift this to language level.</p>",
        "id": 210625204,
        "sender_full_name": "Charles Lew",
        "timestamp": 1600535772
    },
    {
        "content": "<p>Currently mir-optimizer can partially support this. That's why i guess <span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> said MIR inlining is hard.</p>",
        "id": 210625208,
        "sender_full_name": "Charles Lew",
        "timestamp": 1600535776
    },
    {
        "content": "<p>lifting it to language level seems to just hurt though?</p>",
        "id": 210625218,
        "sender_full_name": "simulacrum",
        "timestamp": 1600535800
    },
    {
        "content": "<p>No the compiler just tell user, you can't do this.</p>",
        "id": 210625234,
        "sender_full_name": "Charles Lew",
        "timestamp": 1600535824
    },
    {
        "content": "<p>No longer relying on \"best effort\".</p>",
        "id": 210625243,
        "sender_full_name": "Charles Lew",
        "timestamp": 1600535842
    },
    {
        "content": "<p>I think there is value in letting the user mandate the inlining and warn/error if it failed due to the compiler not being smart enough</p>",
        "id": 210625248,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600535849
    },
    {
        "content": "<p>I don't disagree that there could be value in that</p>",
        "id": 210625301,
        "sender_full_name": "simulacrum",
        "timestamp": 1600535900
    },
    {
        "content": "<p>like what else could <code>inline(always)</code> even mean?</p>",
        "id": 210625311,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600535919
    },
    {
        "content": "<p>Today, it's \"just\" a stronger hint than <code>#[inline]</code> in some sense</p>",
        "id": 210625320,
        "sender_full_name": "simulacrum",
        "timestamp": 1600535940
    },
    {
        "content": "<p>I guess -- all I'm saying -- is that I would prefer to wait on trying to specify warnings on never/always <em>until</em> we have a way of actually implementing those warnings that's not \"pretty much always lints\"</p>",
        "id": 210625331,
        "sender_full_name": "simulacrum",
        "timestamp": 1600535974
    },
    {
        "content": "<p>I would hope that the success rate on these attributes is higher than that</p>",
        "id": 210625380,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600536004
    },
    {
        "content": "<p>and it also seems likely that it'll just mean really-hard-to-close bugs of \"LLVM was told not to inline but decided to anyway\"</p>",
        "id": 210625382,
        "sender_full_name": "simulacrum",
        "timestamp": 1600536006
    },
    {
        "content": "<p>my point is that the current impl basically can't provide any certainty here</p>",
        "id": 210625387,
        "sender_full_name": "simulacrum",
        "timestamp": 1600536025
    },
    {
        "content": "<p>that part actually does sound like a language change, of a sort. It means we take responsibility for any such LLVM bugs as rust bugs too</p>",
        "id": 210625412,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600536098
    },
    {
        "content": "<p>Exactly</p>",
        "id": 210625418,
        "sender_full_name": "simulacrum",
        "timestamp": 1600536119
    },
    {
        "content": "<p>indeed</p>",
        "id": 210625453,
        "sender_full_name": "Charles Lew",
        "timestamp": 1600536124
    },
    {
        "content": "<p>and I think we're basically not in a position to do so (yet)</p>",
        "id": 210625462,
        "sender_full_name": "simulacrum",
        "timestamp": 1600536132
    },
    {
        "content": "<p>and I'm not sure we'd ever want to take such responsibility for inlining decisions</p>",
        "id": 210625467,
        "sender_full_name": "simulacrum",
        "timestamp": 1600536159
    },
    {
        "content": "<p>ok... and mcp is just a proposal. i just want to evaluate the possibility here.</p>",
        "id": 210625506,
        "sender_full_name": "Charles Lew",
        "timestamp": 1600536243
    },
    {
        "content": "<p>There are plenty of other language elements that are not negotiable from the compiler's POV, e.g. write order on volatile variables. Why should inlining be any different, being always subject to some compiler fuzziness?</p>",
        "id": 210625541,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600536250
    },
    {
        "content": "<p>The two feel different to me - maybe they shouldn't. Not sure.</p>",
        "id": 210625568,
        "sender_full_name": "simulacrum",
        "timestamp": 1600536314
    },
    {
        "content": "<p>might be worth some research on LLVM design to see how insistent we can get</p>",
        "id": 210625571,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600536334
    },
    {
        "content": "<p>it would be great if there was some simple criterion that we could test (e.g. recursive function) outside of which LLVM can actually guarantee inlining</p>",
        "id": 210625624,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600536382
    },
    {
        "content": "<p>Given that we have two different mechanisms, one to hint at inlining, and one to force inlining, what is the goal you're trying to achieve by turning the existing inline hint into a second mechanism to force?</p>",
        "id": 210625625,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1600536385
    },
    {
        "content": "<p>the first is almost not doing anything. (actually it does lift the tolerate value a little, but that's ignorable)</p>",
        "id": 210625654,
        "sender_full_name": "Charles Lew",
        "timestamp": 1600536460
    },
    {
        "content": "<p>How valuable are inlining hints anyway? I always assumed (from C++ experience) that compilers take one look at it and say \"heh, we'll see about that!\"</p>",
        "id": 210625657,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600536462
    },
    {
        "content": "<p>If that's the issue, then perhaps we should just tweak the hint threshold values or similar, or work with LLVM to do so.</p>",
        "id": 210625703,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1600536489
    },
    {
        "content": "<p>For a threshold tweaking hint I would prefer something more quantitative like <code>inline(+3.5)</code></p>",
        "id": 210625714,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600536521
    },
    {
        "content": "<p>That seems like way more information than we should expose at the surface area of the language.</p>",
        "id": 210625725,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1600536564
    },
    {
        "content": "<p>I really can't imagine any scenario in which a person would have enough information to set that in a useful manner.</p>",
        "id": 210625743,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1600536595
    },
    {
        "content": "<p>I don't think that users are really in a position to give those values, which is part of the reason compiler writers turn their noses up at inlining \"hints\"</p>",
        "id": 210625772,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600536603
    },
    {
        "content": "<p>I don't think <em>that</em> is the reason. and I don't think it's a foregone conclusion that compiler writers don't like hints.</p>",
        "id": 210625805,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1600536640
    },
    {
        "content": "<p>It may just be that they're not currently doing a very good job with them. ;)</p>",
        "id": 210625809,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1600536650
    },
    {
        "content": "<p>which is why I'm fine with the general direction of this MCP, where your only options are \"yes, no, compiler decide for me\"</p>",
        "id": 210625812,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600536654
    },
    {
        "content": "<p>instead of \"no, probably yes, compiler decide for me, compiler decide for me but consider yes\"</p>",
        "id": 210625831,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600536697
    },
    {
        "content": "<p>I would certainly be in favor of having a clear error if you use \"always\" and it can't be inlined.</p>",
        "id": 210625835,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1600536704
    },
    {
        "content": "<p>Whereas the usual inline directive shouldn't complain if it can't inline for some reasonable reason.</p>",
        "id": 210625884,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1600536735
    },
    {
        "content": "<p>If you're using \"always\", there may be some semantically significant reason for it.</p>",
        "id": 210625894,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1600536766
    },
    {
        "content": "<p>It is worth noting that <code>#[inline]</code> isn't just LLVM <code>inlinehint</code>. It also compiles the function into every crate compilation unit, even if it's non-generic, such that it _can_ be inlined.</p>",
        "id": 210628454,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1600540244
    },
    {
        "content": "<p>If I write some non-generic function <code>foo</code> in a crate lib, and use it from a crate bin, it's not inlined (until/without LTO), because bin only has the signature and symbol to work with.</p>",
        "id": 210628552,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1600540337
    },
    {
        "content": "<p>If it's marked <code>#[inline]</code>, however, it's treated similarly to generic code where MIR (and maybe some precompiled object code) from lib are provided to bin so that bin can inline <code>foo</code> during regular compilation</p>",
        "id": 210628589,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1600540407
    },
    {
        "content": "<p>On generic functions, <code>#[inline]</code> has a similar impact; without <code>#[inline]</code>, only a single copy of a given monomorphization is compiled per crate. With <code>#[inline]</code>, however, a copy of the monomorphization is in every compilation unit (of which there may be multiple per crate) for better application of inlining heuristics.</p>",
        "id": 210628684,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1600540506
    },
    {
        "content": "<p>(disclaimer: this info is recalled from things other people have said about <code>#[inline]</code>, not actual knowledge of how it's processed)</p>",
        "id": 210628706,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1600540555
    },
    {
        "content": "<p>Yeah the biggest single improvement would be to separate \"inline this more often\" from \"make this inlinable at all please\". And maybe people often use both at once, and <code>inline</code> can continue to be both at once, but if there was a way to <em>just</em> mark a function as inlinable without fiddling threshold for example that would be a simpler way to improve user control.</p>",
        "id": 210630029,
        "sender_full_name": "Lokathor",
        "timestamp": 1600542080
    },
    {
        "content": "<p>or call site inline declaration. \"This call here, inline it this time even if the function isn't normally inlined other places\"</p>",
        "id": 210630046,
        "sender_full_name": "Lokathor",
        "timestamp": 1600542120
    },
    {
        "content": "<p>\"make this inlinable at all please\" is <code>-Copt-level=2+</code>.</p>",
        "id": 210630133,
        "sender_full_name": "nagisa",
        "timestamp": 1600542211
    },
    {
        "content": "<p>I have been told that is not the case for non-generic functions</p>",
        "id": 210630188,
        "sender_full_name": "Lokathor",
        "timestamp": 1600542255
    },
    {
        "content": "<p>Well <code>-Copt-level=2+ -Clto=thin+</code>.</p>",
        "id": 210630198,
        "sender_full_name": "nagisa",
        "timestamp": 1600542277
    },
    {
        "content": "<p>(if you need it to happen cross-cu)</p>",
        "id": 210630204,
        "sender_full_name": "nagisa",
        "timestamp": 1600542289
    },
    {
        "content": "<p>yes i do mean cross-crate</p>",
        "id": 210630211,
        "sender_full_name": "Lokathor",
        "timestamp": 1600542301
    },
    {
        "content": "<p>duplicating function code across codegen units to achieve inlining is a significantly worse approach to the problem compared to doing it at the end with lto.</p>",
        "id": 210630297,
        "sender_full_name": "nagisa",
        "timestamp": 1600542379
    },
    {
        "content": "<p>then turn on whatever lto level does that by default in release builds</p>",
        "id": 210630312,
        "sender_full_name": "Lokathor",
        "timestamp": 1600542408
    },
    {
        "content": "<p>Basically no normal user actually wants to think about codegen unit count or crate barriers or anything like this, they \"just want it to work\" in a release build.</p>",
        "id": 210630325,
        "sender_full_name": "Lokathor",
        "timestamp": 1600542432
    },
    {
        "content": "<p>There's a semantic mismatch of sorts in that whether inlining should or can be done is not a local decision its mostly a global one. And so no local annotation can properly express what's proposed by the MCP here. There are some pre-existing projects that further erode the boundaries however (such as MIR-only rlibs), but ultimately anything that does so will result in everybody paying a cost in compile time. And its fairly clear to me at least that to most compile time matters more than better-specified inlining.</p>\n<p>That’s why I don’t believe cross-crate LTO will ever be enabled by default. (And also why this proposal is somewhat under-researched perhaps and not super feasible)</p>",
        "id": 210630860,
        "sender_full_name": "nagisa",
        "timestamp": 1600543229
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116458\">Charles Lew</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/MCP.3A.20Rust-style.20.60.23.5Binline.5D.60.20attribute.2E.20lang-team.2356/near/210624827\">said</a>:</p>\n<blockquote>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"cp\">#[inline(always)]</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\">  </span><span class=\"n\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n\n\n<p>definitely will fail...</p>\n</blockquote>\n<p>Not necessarily. The compiler can first convert recursion into a loop and then inline the loop code for this function into the callers.</p>",
        "id": 210630957,
        "sender_full_name": "nagisa",
        "timestamp": 1600543354
    },
    {
        "content": "<p>Same holds for various cases of mutual recursion.</p>",
        "id": 210631044,
        "sender_full_name": "nagisa",
        "timestamp": 1600543466
    },
    {
        "content": "<p>Check/Debug compile time matters, and time to complete a Test suite run matters (both compile time <em>and</em> execution time combined), but rust should have the default for Release builds really should be \"do everything you can, I'm gonna go get coffee\".</p>\n<p>And a particular project can <em>turn it down</em> if they want some sort of Release build that's faster to build at the expense of execution time. However, usually a release binary is build the once and executed hundreds or thousands of times, so that is what should get favored.</p>\n<p>Or, heck, make an extra profile for \"really release for real, i mean it\"</p>",
        "id": 210631345,
        "sender_full_name": "Lokathor",
        "timestamp": 1600543879
    },
    {
        "content": "<p>yeah, the extra profile thing has been proposed in the past (I believe it was called <code>deploy</code> or <code>distribute</code> or something along those lines? as in \"for shipping to the clients\")</p>",
        "id": 210631416,
        "sender_full_name": "nagisa",
        "timestamp": 1600543972
    },
    {
        "content": "<p>(its not only a compile _time_ tradeoff however, but a space one as well, and that's somewhat more difficult to mitigate by just making the trip to the coffee machine longer)</p>",
        "id": 210631595,
        "sender_full_name": "nagisa",
        "timestamp": 1600544173
    },
    {
        "content": "<p>If only we had some of those infinite Turing’s tapes!</p>",
        "id": 210631623,
        "sender_full_name": "nagisa",
        "timestamp": 1600544223
    },
    {
        "content": "<p>Obviously we give people a slider like in a video game where you favor either small binary at the expense of speed or the other way around ;P</p>",
        "id": 210631809,
        "sender_full_name": "Lokathor",
        "timestamp": 1600544413
    },
    {
        "content": "<p>So I guess you could say I'm against this MCP because all inline hints are a necessary evil, not an inherent good. The mythical Sufficiently Smart Compiler would never need an inline hint to produce the perfect program. Of course we will likely never have such a compiler, so in the mean time we have inline as a band-aid. However, I think we should always consider it a band-aid, and try to remove the need for it, instead of making it further enshrined in the language as something people should use regularly.</p>",
        "id": 210632568,
        "sender_full_name": "Lokathor",
        "timestamp": 1600545420
    },
    {
        "content": "<p>Having an \"I really meant it\" makes sense to me, but I think it might be better to make a new name for it so we can error about it.  Maybe <code>#[inline(required)]</code>?  As a new one we could make it an error to put that on a recursive function, for example -- giving warnings on <em>use</em> of the function is too much like monomorphization-time errors for my taste.</p>",
        "id": 210634849,
        "sender_full_name": "scottmcm",
        "timestamp": 1600548952
    },
    {
        "content": "<p>That said, I also like <span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span>'s point about \"just use a macro\" -- that's what Ralf had to do to get the perf of the slice iterators as good as they are, for example, as even trivial methods that LLVM did always inline was still just enough to impact the phase ordering and have the performance come out worse.</p>\n<p>I've often pondered a middle-ground between functions and macros, one where you can only take values (like a function) but it's typed in the context of the caller at use (like a macro)...</p>",
        "id": 210635024,
        "sender_full_name": "scottmcm",
        "timestamp": 1600549174
    },
    {
        "content": "<p>Hello, I've updated the MCP proposal text about the wordings here. I also like the <code>#[inline(required)]</code> idea, just that maybe it's a little churn to deprecate <code>#[inline(always)]</code> and migrate all existing <code>#[inline(always)]</code>usages.</p>",
        "id": 210702633,
        "sender_full_name": "Charles Lew",
        "timestamp": 1600665960
    },
    {
        "content": "<p>Would it really cause breakage to just make <code>inline(always)</code> produce errors if it can't inline?</p>",
        "id": 210703723,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1600667586
    },
    {
        "content": "<p>I feel like it's got to be breaking for at least somebody -- I've seen plenty of people on Discord who like putting <code>#[inline(always)]</code> all over the place because they've seen just <code>#[inline]</code> not do what they wanted.</p>\n<p>Thinking more, this seems like it'd be an easy edition change, though.  We could start warn-linting it immediately (it seems reasonable that legitimate uses of it would welcome such a warning) and then make it a hard error in a new edition.  (Or just deny-by-default, depending what the semantics people want are.)</p>\n<p>That'd also be helpful in that such a lint could just be added without an MCP -- the usual check it in allow-by-default until it's known to work, then make it warn-by-default with just an FCP'd PR.</p>",
        "id": 210710115,
        "sender_full_name": "scottmcm",
        "timestamp": 1600674532
    },
    {
        "content": "<p>I think my concern is still that we wouldn't be able to not produce warnings here until MIR inlining is in a better shape -- and even then, LLVM could \"outline\" code we inlined, in theory.</p>",
        "id": 210733699,
        "sender_full_name": "simulacrum",
        "timestamp": 1600691431
    },
    {
        "content": "<p>We can still guess what LLVM is going to do and treat any mismatch as a rust bug though</p>",
        "id": 210747295,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600697771
    },
    {
        "content": "<p>I think I would be opposed to adding linting until we can plausibly <em>fix</em> such bugs.</p>",
        "id": 210747761,
        "sender_full_name": "simulacrum",
        "timestamp": 1600697944
    },
    {
        "content": "<p>well the \"fix\" in this setup would be to make the linting check more conservative</p>",
        "id": 210748624,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600698324
    },
    {
        "content": "<p>but the claim is that most cases are in the gray area where we didn't inline it (because the MIR inliner isn't all there) but we have reasonable confidence that the LLVM inliner will follow our suggestion to inline, so a maximally conservative lint may well be unacceptable where an optimistic lint can perform quite well, possibly being refined as we find more LLVM edge cases</p>",
        "id": 210749036,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600698519
    },
    {
        "content": "<p>hm, okay, maybe I'm misreading, but it seems to me that it loses value the more conservative it is. Basically what I'm trying to get at is that the implementation here seems really hard to get right -- maybe even essentially impossible. e.g., if someone casts a inline(required) or inline(always) to a function pointer, that's pretty unlikely to end up inlined (in general) -- is that considered a bug? should we lint on that cast?</p>",
        "id": 210749073,
        "sender_full_name": "simulacrum",
        "timestamp": 1600698536
    },
    {
        "content": "<p>e.g., this lint seems like it would need to be a monomorphization time in codegen and maybe even per-callsite -- surely LLVM will have different inlining requirements depending on the caller</p>",
        "id": 210749173,
        "sender_full_name": "simulacrum",
        "timestamp": 1600698584
    },
    {
        "content": "<blockquote>\n<p>if someone casts a inline(required) or inline(always) to a function pointer, that's pretty unlikely to end up inlined (in general) -- is that considered a bug? should we lint on that cast?</p>\n</blockquote>\n<p>That sounds like a language definition problem. If <code>inline(required)</code> or whatever becomes a guaranteed part of rust then we need rules on what kinds of calls it applies to</p>",
        "id": 210749349,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600698664
    },
    {
        "content": "<p>I don't actually know what would be the best option from a langauge design POV regarding inline(always) functions cast to pointers. If we silently drop the inlining requirement that could be a footgun, but if we error then it might make certain otherwise perfectly reasonable actions impossible, essentially putting them outside the regular type system. Since <code>#[inline(always)]</code> is an attribute and not a fundamental part of the function signature (which itself possibly needs cross analysis), any subsequent issues in usage should probably also be controlled by lint suppression attributes</p>",
        "id": 210750422,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600699153
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> The narrowness of the guarantee we'd be willing to make is one reason I was thinking of this as a new kind of inline (strawman <code>#[inline(required)]</code>).  The idea would be like we've talked about with <code>become</code> for tail recursion: We just make the things we're not willing to promise yet not compile.  So yes, we'd do things like say \"nope, can't get a function pointer to that\" and \"no, you can't call yourself (even unreachably) in such a function\".</p>\n<p>I don't know for sure what all those restrictions would need to be, but past-and-current bugs in the MIR inliner would probably give a good list of candidates for things to block <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 210773832,
        "sender_full_name": "scottmcm",
        "timestamp": 1600709466
    },
    {
        "content": "<p>Yeah, I think a new name for it would be necessary for that vs reusing always, but I could see us doing something like that. A bit unfortunate to have always and required, though.</p>",
        "id": 210773980,
        "sender_full_name": "simulacrum",
        "timestamp": 1600709524
    },
    {
        "content": "<p>It's easy to explain though, \"always\" means \"always try to (but move on if you can't)\" and \"required\" means \"actually error if you can't\"</p>",
        "id": 210785514,
        "sender_full_name": "Lokathor",
        "timestamp": 1600715000
    },
    {
        "content": "<p>Yeah, I guess since <code>#[inline]</code> is just \"be <em>more</em> likely\" there could still be a place for \"please always try but it's not a correctness issue if sometimes you can't for some subtle reason\".</p>",
        "id": 210787803,
        "sender_full_name": "scottmcm",
        "timestamp": 1600716114
    },
    {
        "content": "<p>Even if we inline things in MIR, LLVM has an <a href=\"https://reviews.llvm.org/D26872\">outlining pass</a> that we can't prevent from running (IIUC, enabled by default on arm with <code>-Oz</code>)</p>",
        "id": 210808774,
        "sender_full_name": "tmandry",
        "timestamp": 1600727706
    },
    {
        "content": "<p>I'm still having trouble understanding how inlining can cause a correctness issue. LLVM obviously doesn't consider the possibility, or else they would have more strict controls on inlining</p>",
        "id": 210829336,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600752569
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/MCP.3A.20Rust-style.20.60.23.5Binline.5D.60.20attribute.2E.20lang-team.2356/near/210624186\">said</a>:</p>\n<blockquote>\n<p>I'd like to note that inline and inline(always) actually do make a <em>correctness</em> difference in the presence of cpu features. inline(always) <em>can</em> convince llvm to inline a different cpu featured function, while inline cannot.</p>\n</blockquote>\n<p>Certainly in the presence of architectural weirdness things like inlining can make observable differences, but not any more so than the usual compiler code motion</p>",
        "id": 210829467,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600752761
    },
    {
        "content": "<p>you can, based on preliminary tests that <code>Amanieu</code> did, force LLVM to inline code across CPU feature differences. However, this can also do things like inline <code>t32</code> instruction set code into <code>a32</code> instruction set code.</p>",
        "id": 210829544,
        "sender_full_name": "Lokathor",
        "timestamp": 1600752887
    },
    {
        "content": "<p>but, perhaps it's the case that there's safeguards elsewhere in the overall system to prevent actual problems. We just did a quick offhand check once when discussing the <code>instruction_set</code> RFC</p>",
        "id": 210829567,
        "sender_full_name": "Lokathor",
        "timestamp": 1600752955
    },
    {
        "content": "<p>that sounds like it should be an LLVM bug</p>",
        "id": 210829689,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600753108
    },
    {
        "content": "<p>I suppose. We live in the world we got though.</p>",
        "id": 210829722,
        "sender_full_name": "Lokathor",
        "timestamp": 1600753195
    },
    {
        "content": "<p>well as long as it is identified as an LLVM bug (violating LLVM's own language rules) we can just file the bug and work around it (or maybe even just do nothing since it seems pretty unlikely to come across this issue by accident), and the spec can go forward with inline(required) and a fairly optimistic linter</p>",
        "id": 210829853,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600753406
    },
    {
        "content": "<p>If however the LLVM folks don't count it as a bug at all, because they have some theory for why their handling of inlining with cpu feature differences is reasonable, then we should think about how to match our spec to theirs, perhaps dropping <code>inline(required)</code> and instead patching whatever correctness holes are caused by inlining</p>",
        "id": 210829933,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600753530
    }
]