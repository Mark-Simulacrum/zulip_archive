[
    {
        "content": "<p>Anyway, if it can't be added now that's fine. Nothing about the current design would prevent this from being added in the future if more people ended up needing it later.</p>",
        "id": 254887863,
        "sender_full_name": "Lokathor",
        "timestamp": 1632621418
    },
    {
        "content": "<p>register alloc and inlining means it should \"just work\" anyways.</p>",
        "id": 254946858,
        "sender_full_name": "Jubilee",
        "timestamp": 1632676822
    },
    {
        "content": "<p>I don't follow what inlining you mean.</p>",
        "id": 254950792,
        "sender_full_name": "Lokathor",
        "timestamp": 1632680344
    },
    {
        "content": "<p>If it goes something like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">top_fn</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">some_fn</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">fn_with_asm</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">another_fn</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>and those all get pulled together and inlined<br>\nLLVM shouldn't need to feel the need to align to the ABI before/after <code>fn_with_asm()</code> when it looks at them all together. It should \"just work\".</p>",
        "id": 254962678,
        "sender_full_name": "Jubilee",
        "timestamp": 1632690939
    },
    {
        "content": "<p>and LLVM's baseline inlining heuristics should mean this basically always happens.</p>",
        "id": 254962758,
        "sender_full_name": "Jubilee",
        "timestamp": 1632690993
    },
    {
        "content": "<p>my concern was more to the effect of:</p>\n<div class=\"codehilite\"><pre><span></span><code>// version 1\nsome_fn() {\n  // stuff that requires pushing an odd number of stack values\n\n  inline_asm_call_that_uses_stack_but_only_aligned_to_4()\n}\n</code></pre></div>\n<p>Imagining for a moment that the stack is aligned to 8 the start of all rust calls (which honestly doesn't seems necessary on ARM32, but whatever).<br>\nAnd supposing that <code>some_fn</code> was <em>otherwise</em> going to push an odd number of values to the stack. Say it needs to use a callee save register to have enough space to do all its work for example. So it needs to push one value. This would make the stack aligned to only 4 during the function.<br>\nNow we have that inline_asm call, which uses the stack, and technically only requires a stack alignment of 4, but we have no way to communicate that to rustc/LLVM.<br>\nThis means that some_fn, which was going to push an odd number of registers onto the stack, must now push 1 additional register to the stack to keep it aligned to 8. And pop one additional register after the call as well.<br>\nThis costs us a whopping 2 sequential accesses, which is probably 2 CPU cycles because your stack is probably in memory fast enough to have no waiting. Which is a very small cost, but not zero.</p>\n<p>And enough inline can probably reduce how often you hit the case where the stack was going to have an odd number of registers pushed, but it can still come up.</p>",
        "id": 254969351,
        "sender_full_name": "Lokathor",
        "timestamp": 1632697143
    },
    {
        "content": "<p>it's true, only a great compiler would always fix this without needing to be explicitly told, and LLVM is merely a pretty good one.</p>",
        "id": 255286766,
        "sender_full_name": "Jubilee",
        "timestamp": 1632858548
    },
    {
        "content": "<p>Well, usually the stack pointer is adjusted first and values are saved to stack pointer plus offset, rather than individual pushes. So compiler would only need to change the adjustment.</p>",
        "id": 255287531,
        "sender_full_name": "Gary Guo",
        "timestamp": 1632858828
    },
    {
        "content": "<p>I was already assuming just one batch of pushes at the start, and then one batch of pops at the end.</p>",
        "id": 255289470,
        "sender_full_name": "Lokathor",
        "timestamp": 1632859511
    },
    {
        "content": "<p>But even if all pushes are in one batch at the start of the function it takes an extra sequential access cycle to push an additional register.</p>",
        "id": 255289733,
        "sender_full_name": "Lokathor",
        "timestamp": 1632859595
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span> I'm afraid that no amount of compiler smartness can fix the issue. It's like, just a natural consequence of the way that these definitions come together.</p>\n<p>The fix, if it were critical, would be a new <code>asm!</code> option that's defined more loosely, or a new compiler target with a different data layout definition.</p>",
        "id": 255290225,
        "sender_full_name": "Lokathor",
        "timestamp": 1632859783
    },
    {
        "content": "<p>i feel like there are way lower hanging fruit in rust/llvm codegen than this</p>",
        "id": 255327567,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1632878991
    },
    {
        "content": "<p>well, sorta. If you go the custom-target path then it's literally just a json file you put in a project for the new target and you're done. Otherwise, yes, it requires an actual rustc/llvm change.</p>",
        "id": 255330141,
        "sender_full_name": "Lokathor",
        "timestamp": 1632881104
    },
    {
        "content": "<p>if this is just a complaint about the current target file for some target then i feel like it might be a bit off topic.</p>",
        "id": 255333148,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1632883695
    },
    {
        "content": "<p>No. I've tried to be quite clear about this. There's two possible fixes to the potential problem, and one of them is to add an extra option to how <code>asm!</code> works, which is how this thread started.</p>",
        "id": 255334310,
        "sender_full_name": "Lokathor",
        "timestamp": 1632884646
    }
]