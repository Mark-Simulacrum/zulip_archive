[
    {
        "content": "<p>On ARM and other 32-bit targets, 64-bit integers take up two registers. Is there any current way for this to be supported with inline-asm, or is there any plan for this to be supported in the future?</p>\n<p>(Similarly, 128-bit integers on 64-bit targets use two registers).</p>",
        "id": 252961709,
        "sender_full_name": "Lokathor",
        "timestamp": 1631425638
    },
    {
        "content": "<p>It's asm so shouldn't it be up to the caller to split their u64 into two u32 before feeding them to asm!()?</p>\n<p>Move + shift would be a no-op because the values are already in the 32 wide registers.</p>",
        "id": 252962494,
        "sender_full_name": "Bot+",
        "timestamp": 1631426572
    },
    {
        "content": "<p>Libre-SOC's SimpleV requires using ranges of registers for vectors (e.g. 28 registers for a <code>f32x56</code>), so we will be adding inline assembly i/o arguments for PowerPC that are a contiguous range of registers (assuming Rust and LLVM accept our changes).</p>",
        "id": 252970862,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1631436170
    },
    {
        "content": "<p>Isn't this something that would be better expressed using LLVM intrinsics via std::arch, or even auto-vectorization?</p>",
        "id": 252972501,
        "sender_full_name": "Amanieu",
        "timestamp": 1631438043
    },
    {
        "content": "<p>perhaps, but that shouldn't prevent us from passing it to/from inline asm, just like <code>xmm</code> registers can be passed from/to inline asm on x86 even though calling <code>f32x4</code>'s <code>Add</code> impl may be better</p>",
        "id": 252972644,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1631438254
    },
    {
        "content": "<p>also, there are instruction sequences we're working on designing that aren't realistically going to be supported by llvm for a while, such as FFT instructions</p>",
        "id": 252972736,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1631438376
    },
    {
        "content": "<p>we still want to be able to use them from inline asm</p>",
        "id": 252972790,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1631438408
    },
    {
        "content": "<p>If you add LLVM assembler support for FFT instructions, you could add platform specific LLVM intrinsics for said instructions, right? Or are you telling LLVM to emit asm and then run an external assembler?</p>",
        "id": 252973135,
        "sender_full_name": "bjorn3",
        "timestamp": 1631438817
    },
    {
        "content": "<p>well, like risc-v's LL/SC atomics, the generated instructions would need to be in a specially restricted block (for FFTs), so we would need to add support to LLVM's Register Allocator, Schedulers, etc. to correctly support them. Adding them to LLVM's integrated assembler is trivial by comparison</p>",
        "id": 252973323,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1631439010
    },
    {
        "content": "<p>for general traditional vector ops, LLVM's built-in support for vectors is sufficient</p>",
        "id": 252973453,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1631439170
    },
    {
        "content": "<p>so, for FFT instructions, adding LLVM intrinsics could easily be done but they wouldn't work right</p>",
        "id": 252973491,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1631439239
    },
    {
        "content": "<p>one problem here is that intrinsics and inline asm are naturally at odds with each other. If you wanted to do one or two things, then a long multiply, then one or two other specific things, you'd need an asm block, a single intrinsic call, and then a second asm block. It's not ergonomic in the least.</p>",
        "id": 252991432,
        "sender_full_name": "Lokathor",
        "timestamp": 1631457896
    },
    {
        "content": "<blockquote>\n<p>Move + shift would be a no-op because the values are already in the 32 wide registers.</p>\n</blockquote>\n<p>I suspect this is probably the case, but that's also an extra detail that's probably error prone to be doing yourself all the time. Example: we <em>could</em> only accept usize and tell people that want pointers to cast them to and from usize values at asm block bounds, but that's fiddly and error prone, so we just let people pass pointers directly.</p>",
        "id": 252991672,
        "sender_full_name": "Lokathor",
        "timestamp": 1631458167
    }
]