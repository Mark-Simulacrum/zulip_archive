[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> I'd like to give this one a shot; I need some more experience with compiler internals. Mind if I try it?</p>",
        "id": 200787383,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592085283
    },
    {
        "content": "<p>Sure, go ahead. Feel free to ask if you have any questions.</p>",
        "id": 200790742,
        "sender_full_name": "Amanieu",
        "timestamp": 1592091323
    },
    {
        "content": "<p>Will do.</p>",
        "id": 200790856,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592091509
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 200790860,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592091520
    },
    {
        "content": "<p>Currently finding that I need to go back and tweak config.toml, because the combination of <code>codegen-units = 0</code> and <code>parallel-compiler = true</code> means that compiling <code>rustc_middle</code> takes so much RAM it triggers the OOM killer.</p>",
        "id": 200791009,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592091760
    },
    {
        "content": "<p>At the point the kernel killed it, the <code>rustc_middle</code> compilation had gotten to <code>3501452kB</code> of memory, including <code>2928204kB</code> of anonymous memory.</p>",
        "id": 200791067,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592091848
    },
    {
        "content": "<p>...apparently turning off <code>parallel-compiler = true</code> didn't suffice. Hrm.</p>",
        "id": 200791286,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592092280
    },
    {
        "content": "<p>...and neither did <code>codegen-units = 1</code>, so now I'm a little baffled.</p>",
        "id": 200791663,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592092985
    },
    {
        "content": "<p>Disable debug info</p>",
        "id": 200797960,
        "sender_full_name": "Amanieu",
        "timestamp": 1592105375
    },
    {
        "content": "<p>It uses a ton of memory when linking</p>",
        "id": 200797963,
        "sender_full_name": "Amanieu",
        "timestamp": 1592105397
    },
    {
        "content": "<p>Wasn't an issue with linking as far as I can tell.</p>",
        "id": 200800128,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592110078
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/issues/73337\">https://github.com/rust-lang/rust/issues/73337</a></p>",
        "id": 200800166,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592110109
    },
    {
        "content": "<p>Worked around it for now I think.</p>",
        "id": 200800167,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592110128
    },
    {
        "content": "<p>If <code>format!()</code> and friends doesn't support multiple strings, then why <code>asm!()</code> should?</p>",
        "id": 200806569,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1592123451
    },
    {
        "content": "<p>Because it's common, and semantically meaningful, to need multiple lines in asm, whereas <code>println!</code> can be broken into multiple lines.</p>",
        "id": 200828184,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592160081
    },
    {
        "content": "<p>And because it's valuable for those individual lines to appear on individual source lines.</p>",
        "id": 200828189,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592160096
    },
    {
        "content": "<p>And then for those lines to be formattable by <code>rustfmt</code>.</p>",
        "id": 200828190,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592160106
    },
    {
        "content": "<p>Also, <code>format!</code> <em>can't</em> support multiple strings in the obvious way, because the second and subsequent strings could just as easily be format arguments.</p>",
        "id": 200828261,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592160221
    },
    {
        "content": "<p>Whereas in <code>asm!</code> they can't be operands, because they don't start with <code>in</code> or <code>out</code> or <code>inout</code> or <code>options</code> or similar.</p>",
        "id": 200828266,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592160238
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> Can I get a quick opinion on something?</p>",
        "id": 200828311,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592160272
    },
    {
        "content": "<p>I was currently thinking \"all template string arguments must come before all non-template arguments\".</p>",
        "id": 200828317,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592160287
    },
    {
        "content": "<p>I <em>could</em> see a case for relaxing that, which would make it easy to do things like <code>\"instruction {}\", in(reg) foo, \"anotherinst {}\", out(reg) bar</code>. But I personally think we should avoid that, at least initially. And it's not like people couldn't create a macro that allows it and then sorts all the template strings first.</p>",
        "id": 200828349,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592160359
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> Would you agree that we should only allow multiple template strings <em>before</em> we see any other argument?</p>",
        "id": 200828397,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592160382
    },
    {
        "content": "<p>Yes that's what I had in mind as well.</p>",
        "id": 200829457,
        "sender_full_name": "Amanieu",
        "timestamp": 1592162133
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> In the course of working on this, I realized that in the test case <code>asm!(\"{}\", foo);</code>, <code>foo</code> will parse with <code>parse_expr</code>, and won't get rejected until the later <code>expand_preparsed_asm</code>.</p>",
        "id": 200836493,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592173522
    },
    {
        "content": "<p>Which means that the whole \"expected <code>in</code>, <code>out</code>, ...\" logic won't flag it at that point.</p>",
        "id": 200836540,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592173577
    },
    {
        "content": "<p>I'm trying to figure out if there's some reasonable way to address that without merging the whole <code>expr_to_spanned_string</code> handling into <code>parse_args</code>.</p>",
        "id": 200836552,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592173625
    },
    {
        "content": "<p>(Another option would be to only allow string literals for the second and subsequent template arguments. Not sure if I can get away with that.)</p>",
        "id": 200836791,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592173985
    },
    {
        "content": "<p>Making some progress on that front...</p>",
        "id": 200839303,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592178613
    },
    {
        "content": "<p>OK, I managed to preserve the quality of the diagnostics.</p>",
        "id": 200839917,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592179733
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> Managed to find an unrelated bug in the asm prettyprinting code. <code>print_string</code> already takes care of calling <code>escape_debug</code> for you, so <code>impl fmt::Display for InlineAsmTemplatePiece</code> doing so for every character was escaping twice, which resulted in <code>\\n</code> becoming <code>\\\\n</code> and similar.</p>",
        "id": 200852912,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592201909
    },
    {
        "content": "<p>I'll fix that in the same series, in a separate commit.</p>",
        "id": 200852919,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592201923
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/pull/73364\">https://github.com/rust-lang/rust/pull/73364</a></p>",
        "id": 200855235,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592204632
    },
    {
        "content": "<p>Currently working on a patch to the RFC.</p>",
        "id": 200856279,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592205565
    },
    {
        "content": "<p><a href=\"https://github.com/Amanieu/rfcs/pull/1\">https://github.com/Amanieu/rfcs/pull/1</a></p>",
        "id": 200857358,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592206544
    },
    {
        "content": "<p>/me is currently looking up the semantics for format string argument numbering...</p>",
        "id": 200860495,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592209097
    },
    {
        "content": "<p>@Amanieu Meanwhile, could you elaborate a little more on the <code>line_spans</code> problem? As far as I can tell, I'm getting the results I'd expect even when I have an <code>asm!</code> with a <code>concat!</code> call for each of its template arguments.</p>",
        "id": 200860883,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592209383
    },
    {
        "content": "<p>I'm also getting exactly the results I'd expect that point directly to the specific template string, when not using <code>concat!</code> macros. (With <code>concat!</code> I get a pointer to the beginning of the <code>concat!</code> invocation, which is the same behavior <code>asm!</code> already seems to have with the first template argument.)</p>",
        "id": 200861219,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592209635
    },
    {
        "content": "<p>Oh, wait. I think I understand now. Writing a new test...</p>",
        "id": 200861595,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592209897
    },
    {
        "content": "<p>OK, I managed to write a test that triggers this.</p>",
        "id": 200862300,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592210421
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"w\">        </span><span class=\"n\">asm</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">concat</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"s\">&quot;invalid&quot;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">&quot;_&quot;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">&quot;instruction1&quot;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">&quot;</span><span class=\"se\">\\n</span><span class=\"s\">&quot;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"s\">&quot;invalid&quot;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">&quot;_&quot;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">&quot;instruction2&quot;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">//~^^^^^ ERROR: invalid instruction mnemonic &#39;invalid_instruction1&#39;</span>\n<span class=\"w\">        </span><span class=\"c1\">//~^^^^^^ ERROR: invalid instruction mnemonic &#39;invalid_instruction2&#39;</span>\n\n<span class=\"w\">        </span><span class=\"n\">asm</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">concat</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"s\">&quot;mov eax&quot;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">&quot;, &quot;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">&quot;eax&quot;</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">concat</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"s\">&quot;invalid&quot;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">&quot;_&quot;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">&quot;instruction1&quot;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">&quot;</span><span class=\"se\">\\n</span><span class=\"s\">&quot;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"s\">&quot;invalid&quot;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">&quot;_&quot;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">&quot;instruction2&quot;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">concat</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"s\">&quot;mov eax&quot;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">&quot;, &quot;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">&quot;eax&quot;</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">//~^^^^^^ ERROR: invalid instruction mnemonic &#39;invalid_instruction1&#39;</span>\n<span class=\"w\">        </span><span class=\"c1\">//~^^^^^^^ ERROR: invalid instruction mnemonic &#39;invalid_instruction2&#39;</span>\n</code></pre></div>",
        "id": 200862540,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592210587
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> I'm trying to understand how this currently works when provided with a <code>concat!</code> as the first argument.</p>",
        "id": 200863253,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592211080
    },
    {
        "content": "<p>What do you mean?</p>",
        "id": 200863377,
        "sender_full_name": "Amanieu",
        "timestamp": 1592211158
    },
    {
        "content": "<p>The line spans are basically passed unmodified to LLVM (actually we can only pass an <code>i32</code> so we pass in the start of the span only).</p>",
        "id": 200863474,
        "sender_full_name": "Amanieu",
        "timestamp": 1592211219
    },
    {
        "content": "<p>When an assembler error occurs, LLVM gives us the <code>i32</code> corresponding to the line on which the error occurred. However if there are fewer <code>i32</code>s than lines then LLVM returns the first <code>i32</code>.</p>",
        "id": 200863604,
        "sender_full_name": "Amanieu",
        "timestamp": 1592211272
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143274\">Amanieu</span> <a href=\"#narrow/stream/216763-project-inline-asm/topic/multiple.20template.20string.20arguments/near/200863604\">said</a>:</p>\n<blockquote>\n<p>When an assembler error occurs, LLVM gives us the <code>i32</code> corresponding to the line on which the error occurred. However if there are fewer <code>i32</code>s than lines then LLVM returns the first <code>i32</code>.</p>\n</blockquote>\n<p>Ah, <em>that's</em> what I was missing.</p>",
        "id": 200863627,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592211289
    },
    {
        "content": "<p>And we can't get away with that anymore if there are actually more line spans.</p>",
        "id": 200863661,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592211314
    },
    {
        "content": "<p>Argh.</p>",
        "id": 200863664,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592211317
    },
    {
        "content": "<p>The solution is simple: just duplicate <code>template_sp</code> for every line in the asm.</p>",
        "id": 200863705,
        "sender_full_name": "Amanieu",
        "timestamp": 1592211350
    },
    {
        "content": "<p>That way the number of spans always matches the number of lines.</p>",
        "id": 200863745,
        "sender_full_name": "Amanieu",
        "timestamp": 1592211362
    },
    {
        "content": "<p>Does it suffice to simply count the <code>\\n</code> characters in a string literal, and assume that we should have one copy of <code>template_sp</code> for each one?</p>",
        "id": 200863766,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592211364
    },
    {
        "content": "<p>That would work. I was thinking of modifying <code>Parser</code> to always generate line spans but you solution might be better.</p>",
        "id": 200863844,
        "sender_full_name": "Amanieu",
        "timestamp": 1592211421
    },
    {
        "content": "<p>I'm assuming this will all just fall over dead if someone manages to substitute in an operand whose value contains a literal <code>\\n</code>?</p>",
        "id": 200864077,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592211564
    },
    {
        "content": "<p>I don't think that's possible.</p>",
        "id": 200864110,
        "sender_full_name": "Amanieu",
        "timestamp": 1592211592
    },
    {
        "content": "<p>And in any case there's nothing we could do about it.</p>",
        "id": 200864120,
        "sender_full_name": "Amanieu",
        "timestamp": 1592211601
    },
    {
        "content": "<p>Really weird constant or symbol name? :)</p>",
        "id": 200864168,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592211610
    },
    {
        "content": "<p>Still nothing we can do about it, so let's not worry about it.</p>",
        "id": 200864228,
        "sender_full_name": "Amanieu",
        "timestamp": 1592211671
    },
    {
        "content": "<p>Alright. Then this should be straightforward enough.</p>",
        "id": 200864252,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592211684
    },
    {
        "content": "<p>It's only diagnostics anyways.</p>",
        "id": 200864256,
        "sender_full_name": "Amanieu",
        "timestamp": 1592211685
    },
    {
        "content": "<p>I'd still like to get it right. I appreciate you catching the bug.</p>",
        "id": 200864414,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592211800
    },
    {
        "content": "<p>I revised the test to be meaner, covering a few more cases that I want to get right.</p>",
        "id": 200864667,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592212005
    },
    {
        "content": "<p>I remember you mentioning that LLVM re-generates the assembly instructions.</p>",
        "id": 200864826,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592212120
    },
    {
        "content": "<p>(And in particular that indentation doesn't matter.)</p>",
        "id": 200864850,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592212138
    },
    {
        "content": "<p>What happens if you write something like <code>concat!(\"invalid_instruction1\", \"\\n\\n\\n\\n\\n\", \"invalid_instruction2\")</code>?</p>",
        "id": 200864884,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592212167
    },
    {
        "content": "<p>Is the srcloc mapping taking place based on the user's whitespace, or LLVM's?</p>",
        "id": 200864913,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592212199
    },
    {
        "content": "<p>The user's whitespace.</p>",
        "id": 200866167,
        "sender_full_name": "Amanieu",
        "timestamp": 1592213011
    },
    {
        "content": "<p>Assembler errors happen when LLVM is parsing the asm string.</p>",
        "id": 200866185,
        "sender_full_name": "Amanieu",
        "timestamp": 1592213034
    },
    {
        "content": "<p>Ah, got it. Thanks!</p>",
        "id": 200866286,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592213105
    },
    {
        "content": "<p>As for the positional argument issue across multiple string literal arguments, I'm trying to figure out if there's some easier way to solve that than to add a \"base\" argument to the format string parsing machinery.</p>",
        "id": 200866455,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592213249
    },
    {
        "content": "<p>Because something like <code>asm!(\"{1} {0}\", \"{}\", ...)</code> would need to have that last <code>{}</code> translate to <code>{1}</code>, since it should advance from the <code>{0}</code>.</p>",
        "id": 200866871,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592213509
    },
    {
        "content": "<p>Just carry the argument index over across parser invocations.</p>",
        "id": 200866933,
        "sender_full_name": "Amanieu",
        "timestamp": 1592213534
    },
    {
        "content": "<p>Hmmm. I'm trying to figure out if...right.</p>",
        "id": 200866939,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592213542
    },
    {
        "content": "<p>It's basically the <code>curarg</code> field of <code>Parser</code>.</p>",
        "id": 200866995,
        "sender_full_name": "Amanieu",
        "timestamp": 1592213586
    },
    {
        "content": "<p>The simplest thing to do would be to make it <code>pub</code>.</p>",
        "id": 200867034,
        "sender_full_name": "Amanieu",
        "timestamp": 1592213617
    },
    {
        "content": "<p>/me was thinking about whether it would be possible to just remember the last argument index from the previous iteration, and add that to all the indexes obtained from the next parser.</p>",
        "id": 200867118,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592213648
    },
    {
        "content": "<p>Trying to find a counterexample where that wouldn't work...</p>",
        "id": 200867148,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592213670
    },
    {
        "content": "<p>Oh. Right, that'd be much more complicated.</p>",
        "id": 200867211,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592213711
    },
    {
        "content": "<p>Just initialize <code>curarg</code> in <code>Parser</code> with the value from the previous iteration.</p>",
        "id": 200867230,
        "sender_full_name": "Amanieu",
        "timestamp": 1592213722
    },
    {
        "content": "<p>Yeah, agreed.</p>",
        "id": 200867246,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592213730
    },
    {
        "content": "<p>Given that <code>Parser</code> seems guaranteed to be lazy (and not do any parsing until you call <code>.next()</code>).</p>",
        "id": 200867448,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592213823
    },
    {
        "content": "<p>Thanks for all the help!</p>",
        "id": 200867970,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592214155
    },
    {
        "content": "<p>This is the first time I've done non-trivial rustc hacking.</p>",
        "id": 200867992,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592214176
    },
    {
        "content": "<p>Implementing inline asm was the same for me!</p>",
        "id": 200868037,
        "sender_full_name": "Amanieu",
        "timestamp": 1592214197
    },
    {
        "content": "<p>Wow. I'm impressed. :)</p>",
        "id": 200868046,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592214208
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> I still think <code>TemplateBoundary</code> should just be replaced with <code>String(\"\\n\")</code>.</p>",
        "id": 200868732,
        "sender_full_name": "Amanieu",
        "timestamp": 1592214721
    },
    {
        "content": "<p>I didn't want to special-case <code>String(\"\\n\")</code>, because then if someone passed <code>\"\\n\"</code> as a template string argument, the pretty-printed output wouldn't match the input.</p>",
        "id": 200868813,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592214763
    },
    {
        "content": "<p>The pretty-printed output already doesn't match the input, as I stated in my reply.</p>",
        "id": 200868839,
        "sender_full_name": "Amanieu",
        "timestamp": 1592214787
    },
    {
        "content": "<p>Didn't see that reply.</p>",
        "id": 200868869,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592214821
    },
    {
        "content": "<p>Github UI fail, it's because you marked it resolved.</p>",
        "id": 200868940,
        "sender_full_name": "Amanieu",
        "timestamp": 1592214856
    },
    {
        "content": "<p>Yes, that's true, but it still seemed like a useful property, and in particular, preserving that property made it easier for me to catch some bugs in the pretty-printing.</p>",
        "id": 200868949,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592214870
    },
    {
        "content": "<p>Yeah, if something is marked as resolved and someone posts a new comment, it should be un-resolved.</p>",
        "id": 200868959,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592214885
    },
    {
        "content": "<p>I'm not <em>incredibly</em> opposed to dropping <code>TemplateBoundary</code>, but I have a mild preference. What's the reason for dropping it? Just so that things parsing an <code>InlineAsmTemplatePiece</code> don't have to get updated?</p>",
        "id": 200869027,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592214950
    },
    {
        "content": "<p>Are there that many of those?</p>",
        "id": 200869032,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592214953
    },
    {
        "content": "<p>It just feels unnecessary to have this distinction in the AST. The split template is really just sugar for multi-line strings and we should desugar to a single multi-line string.</p>",
        "id": 200869135,
        "sender_full_name": "Amanieu",
        "timestamp": 1592215014
    },
    {
        "content": "<p>/me tries an experiment.</p>",
        "id": 200869150,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592215030
    },
    {
        "content": "<p>I think I might be able to make this work in a way that doesn't need <code>TemplateBoundary</code> and still maintains the property I'd like.</p>",
        "id": 200869174,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592215046
    },
    {
        "content": "<p>What is this property?</p>",
        "id": 200869194,
        "sender_full_name": "Amanieu",
        "timestamp": 1592215060
    },
    {
        "content": "<p>Pretty-printing mostly maintaining the boundaries.</p>",
        "id": 200869273,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592215103
    },
    {
        "content": "<p>The main use for pretty printing is <code>cargo expand</code> where you want to see what code the compiler is actually going to be processing. I feel that it is more beneficial to see exactly what asm is being passed to the backend, newlines and all.</p>",
        "id": 200869359,
        "sender_full_name": "Amanieu",
        "timestamp": 1592215190
    },
    {
        "content": "<p>It's also really useful for the pretty-printing tests, for which it's really nice to see the arguments separately. :)</p>",
        "id": 200869434,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592215227
    },
    {
        "content": "<p>As long as I have a separate entry in the list that contains <em>only</em> a <code>String(\"\\n\")</code>, I can split on those and do the same thing. It won't match if you have <code>\"\\n\"</code> as an argument by itself, but I can live with that to avoid excess complexity.</p>",
        "id": 200869441,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592215240
    },
    {
        "content": "<p>That feels like a worse solution overall.</p>",
        "id": 200869482,
        "sender_full_name": "Amanieu",
        "timestamp": 1592215274
    },
    {
        "content": "<p>It does avoid having to change backends. And it pretty-prints in a format <em>equivalent</em> to what you put in.</p>",
        "id": 200869516,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592215309
    },
    {
        "content": "<p>What would be the disadvantage of this approach?</p>",
        "id": 200869593,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592215354
    },
    {
        "content": "<p>/me is absolutely open to dropping it, and just wants to understand what the concern is.</p>",
        "id": 200869627,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592215375
    },
    {
        "content": "<p>/me doesn't want to have to debug massive concatenated assembly strings if he doesn't have to.</p>",
        "id": 200869662,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592215406
    },
    {
        "content": "<p>But you don't use pretty-printing for debugging?</p>",
        "id": 200869695,
        "sender_full_name": "Amanieu",
        "timestamp": 1592215436
    },
    {
        "content": "<p>My main concern is that I want the concept of split template strings to be syntax sugar in the macro itself. It should not be reflected in the AST.</p>",
        "id": 200869763,
        "sender_full_name": "Amanieu",
        "timestamp": 1592215461
    },
    {
        "content": "<p>I absolutely would use <code>cargo expand</code> or equivalent if using macro-generated assembly.</p>",
        "id": 200869830,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592215516
    },
    {
        "content": "<p>(Which is not uncommon.)</p>",
        "id": 200869835,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592215523
    },
    {
        "content": "<p>And it was useful when debugging <code>asm!</code> itself.</p>",
        "id": 200869850,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592215537
    },
    {
        "content": "<p>Then do the splitting in pretty-printing by splitting on all \"\\n\".</p>",
        "id": 200869865,
        "sender_full_name": "Amanieu",
        "timestamp": 1592215551
    },
    {
        "content": "<p>Even those embedded in <code>String()</code></p>",
        "id": 200869872,
        "sender_full_name": "Amanieu",
        "timestamp": 1592215560
    },
    {
        "content": "<p>Hmmm. Definitely not opposed to doing that. :)</p>",
        "id": 200869937,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592215583
    },
    {
        "content": "<p>You're wanting there to be a canonical form of the expansion that doesn't care where you put the format string boundaries?</p>",
        "id": 200869966,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592215605
    },
    {
        "content": "<p>Sure.</p>",
        "id": 200870000,
        "sender_full_name": "Amanieu",
        "timestamp": 1592215630
    },
    {
        "content": "<p>Alright. Will do.</p>",
        "id": 200870011,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592215636
    },
    {
        "content": "<p><code>asm!(\"a\", \"b\")</code> and <code>asm!(\"a\\nb\")</code> should both expand to the same thing.</p>",
        "id": 200870033,
        "sender_full_name": "Amanieu",
        "timestamp": 1592215662
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> Can you try <code>asm!(\"mov eax, eax\\n\", \"invalid_instruction\")</code> to see if the error points to the correct location?</p>",
        "id": 200870456,
        "sender_full_name": "Amanieu",
        "timestamp": 1592215990
    },
    {
        "content": "<p>All on one line like that?</p>",
        "id": 200870466,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592216001
    },
    {
        "content": "<p>Sure.</p>",
        "id": 200870474,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592216012
    },
    {
        "content": "<p>The error span should point to the start of <code>invalid_instruction</code>.</p>",
        "id": 200870487,
        "sender_full_name": "Amanieu",
        "timestamp": 1592216024
    },
    {
        "content": "<p><em>nod</em></p>",
        "id": 200870494,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592216029
    },
    {
        "content": "<p>(It doesn't matter if it's all on the same line or not)</p>",
        "id": 200870501,
        "sender_full_name": "Amanieu",
        "timestamp": 1592216037
    },
    {
        "content": "<p>OK, test case added. Will test after I've finished working on the pretty-printing.</p>",
        "id": 200870618,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592216127
    },
    {
        "content": "<p>I think the parser will only generate 1 line span instead of 2 for the first string, which will cause issues.</p>",
        "id": 200870716,
        "sender_full_name": "Amanieu",
        "timestamp": 1592216171
    },
    {
        "content": "<p>Hmmm.</p>",
        "id": 200870801,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592216251
    },
    {
        "content": "<p>Is that because the <code>\\n</code> is at the end of that string, or because the string is all on one Rust source line?</p>",
        "id": 200870881,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592216302
    },
    {
        "content": "<p>Because the \\n is at the end of the string</p>",
        "id": 200870906,
        "sender_full_name": "Amanieu",
        "timestamp": 1592216323
    },
    {
        "content": "<p>It's because of this line in the parser: <code>if self.is_literal &amp;&amp; self.cur_line_start != self.input.len() {</code></p>",
        "id": 200870939,
        "sender_full_name": "Amanieu",
        "timestamp": 1592216349
    },
    {
        "content": "<p>So <code>mov eax, eax\\nmov eax, eax</code> would be fine?</p>",
        "id": 200870941,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592216351
    },
    {
        "content": "<p>I see.</p>",
        "id": 200871034,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592216404
    },
    {
        "content": "<p>Is there such a thing as a span where <code>lo==hi</code>?</p>",
        "id": 200871053,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592216421
    },
    {
        "content": "<p>Or does a span <em>have</em> to include at least one character?</p>",
        "id": 200871064,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592216432
    },
    {
        "content": "<p>If the former, then that seems easy enough to fix by adding another line_span at the end of the string.</p>",
        "id": 200871080,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592216450
    },
    {
        "content": "<p>Yes zero-length spans are perfectly valid</p>",
        "id": 200871101,
        "sender_full_name": "Amanieu",
        "timestamp": 1592216471
    },
    {
        "content": "<p>I think just removing <code>self.cur_line_start != self.input.len()</code> from the condition should be enough.</p>",
        "id": 200871130,
        "sender_full_name": "Amanieu",
        "timestamp": 1592216496
    },
    {
        "content": "<p>I'll try that.</p>",
        "id": 200871200,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592216530
    },
    {
        "content": "<p>It has the unfortunate side-effect of adding a trailing line span every time the iterator returns <code>None</code>, but that shouldn't be a problem in practice.</p>",
        "id": 200871208,
        "sender_full_name": "Amanieu",
        "timestamp": 1592216541
    },
    {
        "content": "<p>Maybe also check that the last <code>line_span</code> doesn't cover to the end of the string.</p>",
        "id": 200871243,
        "sender_full_name": "Amanieu",
        "timestamp": 1592216579
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143274\">Amanieu</span> <a href=\"#narrow/stream/216763-project-inline-asm/topic/multiple.20template.20string.20arguments/near/200871208\">said</a>:</p>\n<blockquote>\n<p>It has the unfortunate side-effect of adding a trailing line span every time the iterator returns <code>None</code>, but that shouldn't be a problem in practice.</p>\n</blockquote>\n<p>Would <code>.fuse()</code> solve that problem?</p>",
        "id": 200871280,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592216622
    },
    {
        "content": "<p>Yes, but realistically we don't care since we don't poke the iterator after it's done.</p>",
        "id": 200871355,
        "sender_full_name": "Amanieu",
        "timestamp": 1592216669
    },
    {
        "content": "<p>Oh, wait, I see what you're proposing.</p>",
        "id": 200871361,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592216672
    },
    {
        "content": "<p>Would it suffice to check that the last line_span isn't identical to the one we're about to push?</p>",
        "id": 200871398,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592216703
    },
    {
        "content": "<p>That would work.</p>",
        "id": 200871423,
        "sender_full_name": "Amanieu",
        "timestamp": 1592216729
    },
    {
        "content": "<p>Would this change change the behavior of parsing <code>\"\"</code>?</p>",
        "id": 200871556,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592216809
    },
    {
        "content": "<p>We would just generate 1 line span for it instead of 0.</p>",
        "id": 200871602,
        "sender_full_name": "Amanieu",
        "timestamp": 1592216839
    },
    {
        "content": "<p>But line spans are only used for diagnostics, so there's no functional change.</p>",
        "id": 200871629,
        "sender_full_name": "Amanieu",
        "timestamp": 1592216858
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143274\">Amanieu</span> <a href=\"#narrow/stream/216763-project-inline-asm/topic/multiple.20template.20string.20arguments/near/200871602\">said</a>:</p>\n<blockquote>\n<p>We would just generate 1 line span for it instead of 0.</p>\n</blockquote>\n<p>Right. Which is fine. Without that, we were using the macro case of \"add the whole <code>template_sp</code>\" for that case.</p>",
        "id": 200871666,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592216880
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> I just realized that in order to implement a canonical expansion that doesn't care where the boundaries are, I'd have to also concatenate the strings <em>before</em> splitting them. That's seeming like more work (memory-wise) than the expander should be doing. I'll just go with the one-big-string approach.</p>",
        "id": 200872520,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592217442
    },
    {
        "content": "<p>Rebuilding now. This may take a while, since I changed the AST, which means a rebuild of <code>rustc_middle</code>.</p>",
        "id": 200872646,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592217536
    },
    {
        "content": "<p>By the way this is the command-line I use to run only the asm tests: <code>./x.py test --stage 1 src/test/ui --test-args asm --bless</code></p>",
        "id": 200873084,
        "sender_full_name": "Amanieu",
        "timestamp": 1592217926
    },
    {
        "content": "<p>I've been using this, because I want some of the tests outside of <code>ui</code> as well: <code>./x.py test -i --stage 1 src/test/assembly/ src/test/codegen/asm-options.rs src/test/incremental/issue-72386.rs src/test/ui/asm/ src/test/ui/consts/miri_unleashed/inline_asm.rs src/test/ui/feature-gates/feature-gate-asm.rs src/test/ui/feature-gates/feature-gate-asm2.rs src/test/ui/macros/macro-expanded-include/foo/mod.rs src/test/ui/macros/macros-nonfatal-errors.rs src/test/pretty/asm.rs</code></p>",
        "id": 200874043,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592218644
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> As you predicted, removing <code>self.cur_line_start != self.input.len()</code> completely fixed the issue with string literals that have <code>\\n</code> at the end.</p>",
        "id": 200874536,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592219020
    },
    {
        "content": "<p>PR pushed.</p>",
        "id": 200874740,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592219145
    },
    {
        "content": "<p>Resolving the two new comments you made...</p>",
        "id": 200875065,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592219376
    },
    {
        "content": "<p>Done.</p>",
        "id": 200875284,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592219541
    },
    {
        "content": "<p>OK, I <em>think</em> I've incorporated all of your feedback, and the current version is passing tests. Any further thoughts?</p>",
        "id": 200944713,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1592254671
    }
]