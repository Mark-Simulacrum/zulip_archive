[
    {
        "content": "<p>If i try to use <code>in(\"esi\")</code> on x86 (32-bit), i get this error:</p>\n<div class=\"codehilite\"><pre><span></span><code>error: invalid register `esi`: esi is used internally by LLVM and cannot be used as an operand for inline asm\n</code></pre></div>\n<p>But if i then add <code>push esi; mov esi, {arg}; ... pop esi</code> and <code>arg = in(reg) arg</code>, it  ends up picking <code>esi</code> anyway, resulting in a useless <code>mov esi, esi</code>. Is that a bug? Should it avoid esi there as well? Or should it allow picking esi explicitly too?</p>",
        "id": 266567478,
        "sender_full_name": "Mara",
        "timestamp": 1641059343
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> since you added that error in <a href=\"https://github.com/rust-lang/rust/issues/84658\">#84658</a></p>",
        "id": 266567486,
        "sender_full_name": "Mara",
        "timestamp": 1641059372
    },
    {
        "content": "<p>Esi is reserved by LLVM. Under certain conditions I believe it stores a frame pointer there. If this is not the case, LLVM can use it for inline asm just fine. It isn't possible for rustc to conditionally allow it as it depends on optimizations if esi is used by LLVM.</p>",
        "id": 266567860,
        "sender_full_name": "bjorn3",
        "timestamp": 1641060001
    },
    {
        "content": "<p><span aria-label=\"grimacing\" class=\"emoji emoji-1f62c\" role=\"img\" title=\"grimacing\">:grimacing:</span></p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"fm\">asm!</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"s\">\"int $0x80</span>\n<span class=\"s\">        .set _check_esi_is_esi, 0</span>\n<span class=\"s\">        .set _check_esi_is_{esi}, 1</span>\n<span class=\"s\">        .if _check_esi_is_esi == 0</span>\n<span class=\"s\">        .err </span><span class=\"se\">\\\"</span><span class=\"s\">Selected register {esi} instead of esi.</span><span class=\"se\">\\\"</span><span class=\"s\"></span>\n<span class=\"s\">        .endif\"</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">esi</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"p\">(</span><span class=\"n\">reg</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">arg4</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"c1\">// HACK: We can't explicitly pick esi, but this will implicitly pick esi.</span>\n<span class=\"w\">        </span><span class=\"k\">in</span><span class=\"p\">(</span><span class=\"s\">\"eax\"</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">num</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">in</span><span class=\"p\">(</span><span class=\"s\">\"ebx\"</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">arg1</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">in</span><span class=\"p\">(</span><span class=\"s\">\"ecx\"</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">arg2</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">in</span><span class=\"p\">(</span><span class=\"s\">\"edx\"</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">arg3</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">lateout</span><span class=\"p\">(</span><span class=\"s\">\"eax\"</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">ret</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">options</span><span class=\"p\">(</span><span class=\"n\">nostack</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 266568332,
        "sender_full_name": "Mara",
        "timestamp": 1641060680
    },
    {
        "content": "<p>(joking, obviously ^^. seems to work fine though ^^')</p>",
        "id": 266568342,
        "sender_full_name": "Mara",
        "timestamp": 1641060720
    },
    {
        "content": "<p>I approve of this hack.</p>",
        "id": 266568616,
        "sender_full_name": "Amanieu",
        "timestamp": 1641061177
    },
    {
        "content": "<p>improved hack that keeps working if it picks another register:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"fm\">asm!</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"s\">\".set _arg4_is_esi, 0</span>\n<span class=\"s\">         .set _arg4_is_{arg4}, 1</span>\n<span class=\"s\">         .if _arg4_is_esi</span>\n<span class=\"s\">         int $0x80</span>\n<span class=\"s\">         .else</span>\n<span class=\"s\">         push esi</span>\n<span class=\"s\">         mov esi, {arg4}</span>\n<span class=\"s\">         int $0x80</span>\n<span class=\"s\">         pop esi</span>\n<span class=\"s\">         .endif\"</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">arg4</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"p\">(</span><span class=\"n\">reg</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">arg4</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">in</span><span class=\"p\">(</span><span class=\"s\">\"eax\"</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">num</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">in</span><span class=\"p\">(</span><span class=\"s\">\"ebx\"</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">arg1</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">in</span><span class=\"p\">(</span><span class=\"s\">\"ecx\"</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">arg2</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">in</span><span class=\"p\">(</span><span class=\"s\">\"edx\"</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">arg3</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">lateout</span><span class=\"p\">(</span><span class=\"s\">\"eax\"</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">ret</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">options</span><span class=\"p\">(</span><span class=\"n\">nostack</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 266568673,
        "sender_full_name": "Mara",
        "timestamp": 1641061237
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span> thanks for the explanation :)</p>",
        "id": 266568682,
        "sender_full_name": "Mara",
        "timestamp": 1641061261
    },
    {
        "content": "<p>This comment in LLVM explains why 3 different pointers into the stack frame are needed (esp+ebp+esi): <a href=\"https://github.com/llvm/llvm-project/blob/69ccc96162aa3471389d98184e0d683573edb47d/llvm/lib/Target/X86/X86FrameLowering.cpp#L2361\">https://github.com/llvm/llvm-project/blob/69ccc96162aa3471389d98184e0d683573edb47d/llvm/lib/Target/X86/X86FrameLowering.cpp#L2361</a></p>",
        "id": 266569666,
        "sender_full_name": "Amanieu",
        "timestamp": 1641062815
    },
    {
        "content": "<p>thank you!</p>",
        "id": 266570007,
        "sender_full_name": "Mara",
        "timestamp": 1641063276
    },
    {
        "content": "<p>Note, when making syscalls on 32-bit x86 linux, esi and ebp contain two later (4th and 6th) arguments, so this is a potential issue.</p>",
        "id": 266571830,
        "sender_full_name": "Connor Horman",
        "timestamp": 1641065995
    },
    {
        "content": "<p>I love this solution</p>",
        "id": 266572264,
        "sender_full_name": "asquared31415",
        "timestamp": 1641066686
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> I don't think I understand why LLVM can't just do stack offset tracking, the same way it does when doing without a frame pointer.</p>",
        "id": 266576297,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1641072648
    },
    {
        "content": "<p>In any case, esi/rsi is definitely a register people need to be able to use; this seems like something LLVM could save and restore on behalf of the asm block, the same way it arranges to move a variable out of a register if the asm block says it needs that register.</p>",
        "id": 266576377,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1641072743
    },
    {
        "content": "<p>The stack size may sometimes be unknown at compile time. Either because of requiring stack aligning or because of alloca. In that case stack adding and substracting fixed amounts from the stack pointer isn't enough. It would be possible to save the pointers at a fixed offset on the stack, but that would quickly get complicated and likely be less performant.</p>",
        "id": 266578283,
        "sender_full_name": "bjorn3",
        "timestamp": 1641074942
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span> I can definitely understand alloca requiring <em>one</em> stack pointer; I just don't know why it'd need <em>two</em>.</p>",
        "id": 266584357,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1641082844
    },
    {
        "content": "<p>Because of stack realignment on function entry.</p>",
        "id": 266584370,
        "sender_full_name": "Amanieu",
        "timestamp": 1641082887
    },
    {
        "content": "<p>If the incoming stack alignment is 4 but your locals need an alignment of 64 then you need to dynamically align the stack. The frame pointer points to the stack frame <em>before</em> alignment: this is needed to address incoming stack parameters. The base pointer points to your fixed-sized locals. The stack pointer points to the edge of the stack, after any dynamic allocas.</p>",
        "id": 266584440,
        "sender_full_name": "Amanieu",
        "timestamp": 1641082991
    },
    {
        "content": "<p>Basically you have 2 unknown offsets:</p>\n<ul>\n<li>the offset between your locals and the parent frame (which contains stack args).</li>\n<li>the offset between your locals and the bottom of the stack (due to variable alloca).</li>\n</ul>",
        "id": 266584561,
        "sender_full_name": "Amanieu",
        "timestamp": 1641083166
    },
    {
        "content": "<p>example of llvm messing up inline assembly with <code>esi</code>: <a href=\"https://llvm.godbolt.org/z/MKqTdqvrG\">https://llvm.godbolt.org/z/MKqTdqvrG</a></p>",
        "id": 266588089,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641088946
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310399\">Mara</span> <a href=\"#narrow/stream/216763-project-inline-asm/topic/esi.20register.20on.20x86/near/266568673\">said</a>:</p>\n<blockquote>\n<p>improved hack that keeps working if it picks another register:<br>\n...</p>\n</blockquote>\n<p>i came to reference this because its very cursed (which i like), but in case you didn't notice this and used it as-is, it shouldn't have <code>options(nostack)</code>.</p>",
        "id": 269051640,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1642988711
    },
    {
        "content": "<p>Is this also fine?</p>\n<div class=\"codehilite\"><pre><span></span><code>pub unsafe fn syscall6(mut n: isize, a1: isize, a2: isize, a3: isize, a4: isize, a5: isize, a6: isize) -&gt; isize {\n    asm! {&quot;\n        .if {a4} != esi\n            push esi\n            mov esi, {a4}\n        .endif\n        .if {a6} != ebp\n            push ebp\n            mov ebp {a6}\n        .endif\n\n        int $0x80\n\n        .if {a4} != esi\n            pop esi\n        .endif\n        .if {a6} != ebp\n            pop ebp\n        .endif\n        &quot;,\n    a4 = in(reg) a4,\n    a6 = in(reg) a6,\n    inlateout(&quot;eax&quot;) n,\n    in(&quot;ebx&quot;) a1,\n    in(&quot;ecx&quot;) a2,\n    in(&quot;edx&quot;) a3,\n    in(&quot;edi&quot;) a5,\n    options(nostack)\n    };\n    n\n}\n</code></pre></div>",
        "id": 271482397,
        "sender_full_name": "Elichai Turkel",
        "timestamp": 1644521464
    },
    {
        "content": "<p>What if <code>a6</code> is assigned to <code>esi</code> and <code>a4</code> is assigned to <code>ebp</code>?</p>",
        "id": 271482604,
        "sender_full_name": "Amanieu",
        "timestamp": 1644521554
    },
    {
        "content": "<p>Also if there's any kind of complex stack frame that requires a frame pointer then register allocation is simply going to fail hard.</p>",
        "id": 271482703,
        "sender_full_name": "Amanieu",
        "timestamp": 1644521601
    }
]