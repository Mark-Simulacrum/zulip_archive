[
    {
        "content": "<p>The chart for what register classes mean on what targets says:</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Arch</th>\n<th align=\"left\">Class</th>\n<th align=\"left\">Registers</th>\n<th align=\"left\">LLVM Code</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">ARM</td>\n<td align=\"left\"><code>reg</code></td>\n<td align=\"left\">r[0-12], r14</td>\n<td align=\"left\"><code>r</code></td>\n</tr>\n<tr>\n<td align=\"left\">ARM (Thumb)</td>\n<td align=\"left\"><code>reg_thumb</code></td>\n<td align=\"left\">r[0-r7]</td>\n<td align=\"left\"><code>l</code></td>\n</tr>\n<tr>\n<td align=\"left\">ARM (ARM)</td>\n<td align=\"left\"><code>reg_thumb</code></td>\n<td align=\"left\">r[0-r12], r14</td>\n<td align=\"left\"><code>l</code></td>\n</tr>\n</tbody>\n</table>\n<p>Question: <code>reg</code> works on Thumb targets, so should I be worried that it'll potentially assign me a high register in my thumb code?</p>\n<p>Question 2: If the answer is \"yes\" then why don't thumb targets default to only using the correct registers? If the answer is \"no\" then what's the point of <code>reg_thumb</code> at all?</p>",
        "id": 251160939,
        "sender_full_name": "Lokathor",
        "timestamp": 1630274466
    },
    {
        "content": "<p>1) Yes<br>\n2) Some thumb instructions can use all registers, some can only use <code>r[0-7]</code>.</p>",
        "id": 251168567,
        "sender_full_name": "Amanieu",
        "timestamp": 1630282239
    },
    {
        "content": "<p>I am aware that some instructions can use high registers, but that's just (approximately) three operations among the (approximately) nineteen that the CPU offers in Thumb code. You would never ever want to be handed a high register on accident in thumb code the same as you would never want to be handed <code>pc</code> or <code>sp</code> on accident even though you can access them in the assembly block.</p>",
        "id": 251174563,
        "sender_full_name": "Lokathor",
        "timestamp": 1630288862
    },
    {
        "content": "<p>Also that only applies to Thumb1. Thumb2 has 32-bit encodings for all Thumb1 instructions that accept the full set of registers.</p>",
        "id": 251174672,
        "sender_full_name": "Amanieu",
        "timestamp": 1630288960
    },
    {
        "content": "<p>Sure, but since Rust does support Thumb 1 devices, on at least those devices the default for <code>reg</code> should be a low register only.</p>",
        "id": 251174780,
        "sender_full_name": "Lokathor",
        "timestamp": 1630289055
    },
    {
        "content": "<p>I don't mean to bring this up so close to stabilization, but this really is kinda a footgun if you're doing Thumb 1 programming.</p>",
        "id": 251174808,
        "sender_full_name": "Lokathor",
        "timestamp": 1630289102
    },
    {
        "content": "<p>and I only noticed it today, because in the past I assumed that <code>reg</code> was just \"give me any <em>useful</em> register\" and that the compiler would know what i mean.</p>",
        "id": 251174828,
        "sender_full_name": "Lokathor",
        "timestamp": 1630289135
    },
    {
        "content": "<p>I suppose we could swap the definitions around so <code>reg</code> is r0-r7 on thumb and have a separate register class for the full set. Not sure what to name it though.</p>",
        "id": 251174838,
        "sender_full_name": "Amanieu",
        "timestamp": 1630289155
    },
    {
        "content": "<p>I just woke up from a nap but my first inclination is:<br>\n<code>reg</code> is r0-r7 on thumb1 and r0-r12/r14 on thumb2 or arm<br>\n<code>reg_any</code> is r0-r12/r14 even in thumb1</p>",
        "id": 251174932,
        "sender_full_name": "Lokathor",
        "timestamp": 1630289258
    },
    {
        "content": "<p>and if you want to specify only a low register even on thumb 2, <code>reg_low</code> perhaps</p>",
        "id": 251174991,
        "sender_full_name": "Lokathor",
        "timestamp": 1630289299
    },
    {
        "content": "<p>LLVM only exposes <code>l</code> and <code>r</code> constraints that we can use here.</p>",
        "id": 251175047,
        "sender_full_name": "Amanieu",
        "timestamp": 1630289375
    },
    {
        "content": "<p><a href=\"https://llvm.org/docs/LangRef.html#constraint-codes\">https://llvm.org/docs/LangRef.html#constraint-codes</a></p>",
        "id": 251175058,
        "sender_full_name": "Amanieu",
        "timestamp": 1630289394
    },
    {
        "content": "<p>Oh actually it seems that <code>r</code> is already r0-r7 in Thumb1 mode.</p>",
        "id": 251175134,
        "sender_full_name": "Amanieu",
        "timestamp": 1630289447
    },
    {
        "content": "<p>ah, so just the docs on the Rust side need a fix then</p>",
        "id": 251175189,
        "sender_full_name": "Lokathor",
        "timestamp": 1630289523
    },
    {
        "content": "<p>Problem is that now the register set depends on whether the <code>thumb2</code> target feature is enabled...</p>",
        "id": 251175269,
        "sender_full_name": "Amanieu",
        "timestamp": 1630289605
    },
    {
        "content": "<p>potentially a shame that we can't allocate registers on our side of things and thus break free of LLVM's grip, but i do understand the complexity there, and the performance fails when two separate groups are each doing part of the register allocation</p>",
        "id": 251175274,
        "sender_full_name": "Lokathor",
        "timestamp": 1630289616
    },
    {
        "content": "<p>Which is why I originally specified <code>reg</code> so generally.</p>",
        "id": 251175278,
        "sender_full_name": "Amanieu",
        "timestamp": 1630289621
    },
    {
        "content": "<p>Also I just checked and GCC treats <code>r</code> as the full set of registers, even in Thumb1 mode.</p>",
        "id": 251175643,
        "sender_full_name": "Amanieu",
        "timestamp": 1630290002
    },
    {
        "content": "<p>we could call them <code>reg</code>, <code>reg_lo</code>, and <code>reg_hi</code>, but since <code>reg_hi</code> maps to the low registers anyway in thumb1, maybe reject the register class from thumb1</p>",
        "id": 251175697,
        "sender_full_name": "Lokathor",
        "timestamp": 1630290029
    },
    {
        "content": "<p>I've been thinking about this and in the end I stand by my original decision to have <code>reg</code> return any register <code>r0-r12/r14</code>. It is what you would expect on ARM (give me any register) and what GCC/Clang's <code>r</code> constraint does.</p>",
        "id": 256393897,
        "sender_full_name": "Amanieu",
        "timestamp": 1633519056
    },
    {
        "content": "<p>For low registers, I'm open to renaming <code>reg_thumb</code> to <code>reg_low</code>, but I'm still unsure about this.</p>",
        "id": 256393921,
        "sender_full_name": "Amanieu",
        "timestamp": 1633519075
    },
    {
        "content": "<p>My main concern is that in ARM mode <code>reg_thumb</code> will still return any register <code>r0-r12/r14</code> since that's what the LLVM <code>l</code> constraint does.</p>",
        "id": 256393991,
        "sender_full_name": "Amanieu",
        "timestamp": 1633519106
    },
    {
        "content": "<p>If I'm writing T32 code for a Thumb1 target there is absolutely no justification for \"reg\", the default register class, to offer me up <code>r8</code>. It's simply not usable to me with any normal instruction. It's exactly as unusable as <code>pc</code>, and <code>lr</code>, and <code>cpsr</code>.</p>",
        "id": 256428757,
        "sender_full_name": "Lokathor",
        "timestamp": 1633533520
    },
    {
        "content": "<p>Specifically, it is <em>not</em> usable by simply having some two-u16 instruction instead of a single u16.</p>",
        "id": 256428927,
        "sender_full_name": "Lokathor",
        "timestamp": 1633533587
    },
    {
        "content": "<p>AFAIK you can use it with <code>add</code> and <code>mov</code>, and that's about it.</p>",
        "id": 256428948,
        "sender_full_name": "Amanieu",
        "timestamp": 1633533599
    },
    {
        "content": "<p>Why can't you just use <code>reg_thumb</code> in that case then?</p>",
        "id": 256429148,
        "sender_full_name": "Amanieu",
        "timestamp": 1633533661
    },
    {
        "content": "<p>I still think <code>reg</code> is still a good default since it is the most general register class.</p>",
        "id": 256429516,
        "sender_full_name": "Amanieu",
        "timestamp": 1633533785
    },
    {
        "content": "<p>it is possible to write out \"reg_thumb\", but less ergonomic.</p>\n<p>let me reverse the question: when the entire program is Thumb1 by default because of the target why can't the default register group just do the right thing automatically?</p>",
        "id": 256429638,
        "sender_full_name": "Lokathor",
        "timestamp": 1633533838
    },
    {
        "content": "<p>I see absolutely zero programmer benefits to the compiler being able to accidentally select an invalid register</p>",
        "id": 256429831,
        "sender_full_name": "Lokathor",
        "timestamp": 1633533897
    },
    {
        "content": "<p>if you need a high register you can just specify a high register in that exceptional situation.</p>",
        "id": 256429996,
        "sender_full_name": "Lokathor",
        "timestamp": 1633533934
    },
    {
        "content": "<p>Because then I'd need to add another register class just for \"the full register set\"</p>",
        "id": 256430004,
        "sender_full_name": "Amanieu",
        "timestamp": 1633533936
    },
    {
        "content": "<p>...then please do?</p>",
        "id": 256430054,
        "sender_full_name": "Lokathor",
        "timestamp": 1633533956
    },
    {
        "content": "<p>there's already like 30 of them it's a very small delta to add one more</p>",
        "id": 256430160,
        "sender_full_name": "Lokathor",
        "timestamp": 1633533985
    },
    {
        "content": "<p>also, i would like to point out that \"we would need to change the compiler some\" is not a programmer benefit.</p>",
        "id": 256430321,
        "sender_full_name": "Lokathor",
        "timestamp": 1633534052
    },
    {
        "content": "<p>IMO having the definition of <code>reg</code> change within the same target is already quite a lot of complexity. And I'm still concerned about the precedent from GCC where <code>r</code> gives the full set of register even on thumb1 targets.</p>",
        "id": 256430498,
        "sender_full_name": "Amanieu",
        "timestamp": 1633534113
    },
    {
        "content": "<p>do you mean between A32 and T32 mode on a target with interworking?</p>",
        "id": 256431040,
        "sender_full_name": "Lokathor",
        "timestamp": 1633534307
    },
    {
        "content": "<p>Yes there's that but also in general I feel that it is much clearer for a register class to have a single meaning in a target.</p>",
        "id": 256432166,
        "sender_full_name": "Amanieu",
        "timestamp": 1633534688
    },
    {
        "content": "<p>Hmm then again there is a precedent for doing this in RISC-V with the E feature which disables <code>x16</code>-<code>x31</code>.</p>",
        "id": 256432286,
        "sender_full_name": "Amanieu",
        "timestamp": 1633534716
    },
    {
        "content": "<p>I think you're in the best position to figure out what is the right thing to do here, so I'll defer to you. Would you be interested in making a PR to fix <code>reg</code>/<code>reg_thumb</code> on ARM targets?</p>",
        "id": 256432407,
        "sender_full_name": "Amanieu",
        "timestamp": 1633534762
    },
    {
        "content": "<p>I suppose I could do a PR. It's mostly editing some sort of list of stuff that a macro expands out I'm assuming?</p>",
        "id": 256432646,
        "sender_full_name": "Lokathor",
        "timestamp": 1633534842
    },
    {
        "content": "<p>Yes, essentially.</p>",
        "id": 256432717,
        "sender_full_name": "Amanieu",
        "timestamp": 1633534869
    },
    {
        "content": "<p>And adjusting the tests in src/test/assembly/asm accordingly.</p>",
        "id": 256432755,
        "sender_full_name": "Amanieu",
        "timestamp": 1633534885
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143274\">Amanieu</span> <a href=\"#narrow/stream/216763-project-inline-asm/topic/Design.20of.20ARM.20reg_thumb/near/256432286\">said</a>:</p>\n<blockquote>\n<p>Hmm then again there is a precedent for doing this in RISC-V with the E feature which disables <code>x16</code>-<code>x31</code>.</p>\n</blockquote>\n<p>Technically by RISC-V spec, E is base spec not an extension. So RV32I, RV64I and RV32E are distinct base ISAs</p>",
        "id": 256432778,
        "sender_full_name": "Gary Guo",
        "timestamp": 1633534892
    },
    {
        "content": "<p>Sure, but in LLVM it's implemented as a target feature and we sort of just went along with that.</p>",
        "id": 256432876,
        "sender_full_name": "Amanieu",
        "timestamp": 1633534927
    },
    {
        "content": "<p>I think RV32E and Thumb are quite different. On RV32E x16-x31 are just non-existent, but IIRC on Thumb r8-r12 still exists.</p>",
        "id": 256433248,
        "sender_full_name": "Gary Guo",
        "timestamp": 1633535069
    },
    {
        "content": "<p>So I think reg returning r8-r12 is okay</p>",
        "id": 256433430,
        "sender_full_name": "Gary Guo",
        "timestamp": 1633535137
    },
    {
        "content": "<p>I think that <code>reg</code> should always give a default usable register, in all situations, all the time. That's simply the convention we pick for ourselves in life, even regardless of what other compilers do.</p>\n<p>And then we can have register groups for specific situations when non-default groups are what you'd want.</p>\n<p>In other words:<br>\nThumb1: r0-r7<br>\nThumb2 or ARM: r0-r12,r14</p>",
        "id": 256433444,
        "sender_full_name": "Lokathor",
        "timestamp": 1633535142
    },
    {
        "content": "<blockquote>\n<p>So I think reg returning r8-r12 is okay</p>\n</blockquote>\n<p>it is not allowed, at all, to use r8 and above with most ops in thumb1. It will just turn into a compiler error.</p>",
        "id": 256433704,
        "sender_full_name": "Lokathor",
        "timestamp": 1633535231
    },
    {
        "content": "<p>Specifically, MOV, CMP, and ADD can access high registers. All other operations cannot.</p>",
        "id": 256434266,
        "sender_full_name": "Lokathor",
        "timestamp": 1633535397
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> I remember that a few days ago you wanted me to do a PR in this area, but reviewing the thread it doesn't seem to have a clear consensus of what the PR would do specifically</p>",
        "id": 257093143,
        "sender_full_name": "Lokathor",
        "timestamp": 1633972619
    },
    {
        "content": "<p>Yea I still have a preference for the current behavior, despite your arguments.</p>",
        "id": 257105949,
        "sender_full_name": "Amanieu",
        "timestamp": 1633979946
    },
    {
        "content": "<p>I think your intended design works fine for ARM and thumb2, but is just a broken design for thumb1 code. It should absolutely not be possible for <code>orr {reg}, #1</code> to ever end up selecting to use a register that's not actually allowed, which is what could happen if <code>reg</code> for thumb1 included registers above r7.</p>\n<p>LLVM already works in the style I'm suggesting. Rust's <code>reg</code> class maps to the <code>r</code> constraint, which gives only r0 to r7 with Thumb1 code (<a href=\"https://llvm.org/docs/LangRef.html#supported-constraint-code-list\">docs</a>).</p>\n<p>So basically we have two choices:<br>\n1) Rust can adjust the intent/docs to match what LLVM already does. I could do this if you want, I just need to change a markdown file.<br>\n2) Rust can try to fight against LLVM and make thumb1 have the same register selection as thumb2 and ARM. With this path, not only am I not able to do it for lack of LLVM knowledge, but I wouldn't do it even if I could, because I think it's a bad idea that would hurt my own Rust projects (and any other thumb1 users).</p>",
        "id": 257144870,
        "sender_full_name": "Lokathor",
        "timestamp": 1634009646
    }
]