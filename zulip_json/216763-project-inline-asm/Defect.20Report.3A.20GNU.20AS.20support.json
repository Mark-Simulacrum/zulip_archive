[
    {
        "content": "<p>Currently, <a href=\"https://doc.rust-lang.org/nightly/reference/inline-assembly.html#template-string-arguments\">https://doc.rust-lang.org/nightly/reference/inline-assembly.html#template-string-arguments</a> defines the following:</p>\n<blockquote>\n<p>Currently, all supported targets follow the assembly code syntax used by LLVM's internal assembler which usually corresponds to that of the GNU assembler (GAS). On x86, the .intel_syntax noprefix mode of GAS is used by default. On ARM, the .syntax unified mode is used. These targets impose an additional restriction on the assembly code: any assembler state (e.g. the current section which can be changed with .section) must be restored to its original value at the end of the asm string. Assembly code that does not conform to the GAS syntax will result in assembler-specific behavior.</p>\n</blockquote>\n<p>This has an argubly unfortunate side effect of guaranteeing, at least for current targets, the ability to use full macro assembly syntax.<br>\nI would ideally like this guarantee reversed, if possible, before it hits stable. In lccc, the current (and likely future) x86 codegen does not function by creating assembly from the ir, then running the result through as or any internal assembler, but rather directly generates x86 machine code (&lt;<a href=\"https://github.com/LightningCreations/lccc/blob/d262162a46c16d767b5b24aca82715db641bca53/codegen-x86/src/lib.rs#L431\">https://github.com/LightningCreations/lccc/blob/d262162a46c16d767b5b24aca82715db641bca53/codegen-x86/src/lib.rs#L431</a>&gt;). The same will likely be true of other codegens written as part of the lccc project that do not go through another IR. This was a deliberate decision to avoid complicating target information, and to allow backends and other plugins to be largely isolated and avoid running system commands (which would allow, for example, the project to host in wasm).<br>\nThis, however, means that in the future, it will be difficult to support full GNU AS macro assembly syntax, as this would necessitate implementing an assembly parser equivalent to GNU AS within the codegen (heavily complicating an already complicated plugin).</p>\n<p>My proposal is to revise the above sentance to the following:</p>\n<blockquote>\n<p>The format of inline assembly is platform specific, but may contain labels and instructions. The use of directives, if any, are assembler and implementation specific and may not be supported. </p>\n</blockquote>\n<p>For <code>global_asm</code>, a more relaxed form could be used, allowing simple directives, such as <code>.section</code> and data declaration directives. However, I would be strongly adverse to guaranteeing that macros or conditional assembly directives are guaranteed to be supported.</p>",
        "id": 269054045,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642991576
    },
    {
        "content": "<p>The <code>asm!</code> feature is specifically designed so that you can pass it to an external assembler and just link to the resulting object file. After that you can just call the assembly code like a normal function and avoid the need for any special handling in the backend. This is the approach used by the cranelift backend which has no plans to support inline assembly.</p>",
        "id": 269054204,
        "sender_full_name": "Amanieu",
        "timestamp": 1642991870
    },
    {
        "content": "<p>Implementing any kind of assembler, even a basic one capable of parsing x86 intel syntax, is a massive effort on its own and I certainly don't expect every codegen backend to support it natively.</p>",
        "id": 269054291,
        "sender_full_name": "Amanieu",
        "timestamp": 1642991955
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143274\">Amanieu</span> <a href=\"#narrow/stream/216763-project-inline-asm/topic/Defect.20Report.3A.20GNU.20AS.20support/near/269054204\">said</a>:</p>\n<blockquote>\n<p>The <code>asm!</code> feature is specifically designed so that you can pass it to an external assembler and just link to the resulting object file. After that you can just call the assembly code like a normal function and avoid the need for any special handling in the backend. This is the approach used by the cranelift backend which has no plans to support inline assembly.</p>\n</blockquote>\n<p>As mentioned, I would like to avoid running an external assembler, which would bring the advantage of allowing the xlang stack to be run without the benefit of an actual operating system (such as on wasm as I mentioned).</p>",
        "id": 269054296,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642991961
    },
    {
        "content": "<p>I'm sure it's possible to make an external assembler work in wasm, you'd just need to package it up as a library. I think you can use LLVM's internal assembler this way.</p>",
        "id": 269054372,
        "sender_full_name": "Amanieu",
        "timestamp": 1642992081
    },
    {
        "content": "<p>Supporting a basic assembler in it (or rather, the support library it calls out to for x86 code generation - arch-ops) wouldn't be unreasonable. The thing I would like to avoid is writing a fully capable macro assembler.</p>",
        "id": 269054431,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642992170
    },
    {
        "content": "<p>The other question is, what if there is no GNU AS compatible assembler available, even if an external one is called out to? What if the only assembler on the system is ml.exe?</p>",
        "id": 269054504,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642992289
    },
    {
        "content": "<p>Then you package one with the compiler.</p>",
        "id": 269054518,
        "sender_full_name": "Amanieu",
        "timestamp": 1642992324
    },
    {
        "content": "<p>Ok. I'll just package a binary with the lccc source code... And ship one that works on everything.</p>",
        "id": 269054528,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642992354
    },
    {
        "content": "<p>I'd ideally like to avoid packaging all of llvm, with a project that's trying to be independant from it.</p>",
        "id": 269054573,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642992390
    },
    {
        "content": "<p>(And noting that llvm does not support a number of the targets I am intent to support)</p>",
        "id": 269054592,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642992440
    },
    {
        "content": "<p>I'm not sure what I can say here. There are a number of features from GAS that people are actually using with inline assembly. And really do need these features.</p>\n<p>For example, in my own projects I've used:</p>\n<ul>\n<li><code>.globl</code>, <code>.type</code>, <code>.size</code>, <code>.hidden</code>, <code>.weak</code> directives to define a symbol in <code>global_asm!</code>.</li>\n<li><code>.pushsection</code>, <code>.popsection</code> to add data to a section from an <code>asm!</code> which references code locations in the generated assembly.</li>\n<li><code>.cfi_*</code>, <code>.seh_*</code> directives to emit specific unwind information for custom functions defined using <code>global_asm!</code>.</li>\n</ul>",
        "id": 269054776,
        "sender_full_name": "Amanieu",
        "timestamp": 1642992697
    },
    {
        "content": "<p>Just saying that only instructions and labels are supported is not good enough, I need to be able to use assembler directives.</p>",
        "id": 269054820,
        "sender_full_name": "Amanieu",
        "timestamp": 1642992725
    },
    {
        "content": "<p>For global_asm, I believe that's still unstable, so that can probably be discussed. <br>\nHowever, asm has basically stabilized the existance of GNU as <em>or</em> LLVM, which, in my opinion, is an unreasonable burden to bear, and I would like that to be avoided before the macro hits stable.</p>",
        "id": 269054989,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642992978
    },
    {
        "content": "<p><code>global_asm!</code> was stabilized at the same time as <code>asm!</code>.</p>",
        "id": 269054998,
        "sender_full_name": "Amanieu",
        "timestamp": 1642992999
    },
    {
        "content": "<p>Oh brilliant.</p>",
        "id": 269055110,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642993161
    },
    {
        "content": "<p>Speaking of GAS, I think we need to prevent MASM-style integer literals from being used because it's only recognized by LLVM assembler but not GAS.</p>",
        "id": 269087965,
        "sender_full_name": "Gary Guo",
        "timestamp": 1643021726
    },
    {
        "content": "<p>It's also not recognized by LLVM assembler if the Intel syntax is enabled by <code>.intel_syntax</code></p>",
        "id": 269088122,
        "sender_full_name": "Gary Guo",
        "timestamp": 1643021786
    },
    {
        "content": "<p>Essentially the \"Intel mode\" of LLVM assembler is only there for MSVC compatibility.</p>",
        "id": 269088348,
        "sender_full_name": "Gary Guo",
        "timestamp": 1643021897
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303710\">Gary Guo</span> <a href=\"#narrow/stream/216763-project-inline-asm/topic/Defect.20Report.3A.20GNU.20AS.20support/near/269087965\">said</a>:</p>\n<blockquote>\n<p>Speaking of GAS, I think we need to prevent MASM-style integer literals from being used because it's only recognized by LLVM assembler but not GAS.</p>\n</blockquote>\n<p>I don't know if it needs to be prevented, but it could be included in what is excluded from being guaranteed to work.</p>",
        "id": 269108963,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643032744
    },
    {
        "content": "<p>It is already excluded from being guaranteed to work. Only the common subset of LLVM and GCC is guaranteed to work.</p>",
        "id": 269109847,
        "sender_full_name": "bjorn3",
        "timestamp": 1643033073
    },
    {
        "content": "<p><a href=\"https://doc.rust-lang.org/nightly/reference/inline-assembly.html\">https://doc.rust-lang.org/nightly/reference/inline-assembly.html</a></p>\n<blockquote>\n<p>Assembly code that does not conform to the GAS syntax will result in assembler-specific behavior.</p>\n</blockquote>",
        "id": 269110030,
        "sender_full_name": "bjorn3",
        "timestamp": 1643033162
    },
    {
        "content": "<p>Yes the MASM-style integer literals are a bug but I'm not sure how to solve it without breaking Clang's use of intel syntax. Keep in mind both rustc and Clang have to share the same LLVM IR when doing cross-language LTO.</p>",
        "id": 269110228,
        "sender_full_name": "Amanieu",
        "timestamp": 1643033249
    },
    {
        "content": "<p><a href=\"https://rust-lang.github.io/rfcs/2873-inline-asm.html#validate-the-assembly-code-in-rustc\">https://rust-lang.github.io/rfcs/2873-inline-asm.html#validate-the-assembly-code-in-rustc</a></p>\n<blockquote>\n<p>While it might be possible for rustc to verify that inline assembly code conforms to a minimal stable subset of the assembly syntax supported by LLVM and GAS, doing so would effectively require rustc to parse the assembly code itself. Implementing a full assembler for all target architectures supported by this RFC is a huge amount of work, most of which is redundant with the work that LLVM has already done in implementing an assembler. As such, this RFC does not propose that rustc perform any validation of the generated assembly code.</p>\n</blockquote>",
        "id": 269110273,
        "sender_full_name": "bjorn3",
        "timestamp": 1643033271
    },
    {
        "content": "<p>Yeah. To be clear, I'm proposing no changes to rustc itself, only to what is guaranteed about inline assembly. rustc itself can provide stronger guarantees, or happen to support LLVM assembly itself.</p>",
        "id": 269110705,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643033440
    },
    {
        "content": "<p>(It may not be a good idea to guarantee too much more, as additional rustc codegens may run into the same issue)</p>",
        "id": 269114665,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643035321
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143274\">Amanieu</span> <a href=\"#narrow/stream/216763-project-inline-asm/topic/Defect.20Report.3A.20GNU.20AS.20support/near/269110228\">said</a>:</p>\n<blockquote>\n<p>Yes the MASM-style integer literals are a bug but I'm not sure how to solve it without breaking Clang's use of intel syntax. Keep in mind both rustc and Clang have to share the same LLVM IR when doing cross-language LTO.</p>\n</blockquote>\n<p>In theory, LLVM could add a flag to its inline-assembly IR representation, to say \"don't support MASM integer literals\", or any number of other things like that. We could set that flag internally, and clang wouldn't have to.</p>",
        "id": 269142457,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643046420
    },
    {
        "content": "<p>That would require an LLVM change, but it seems like a useful one.</p>",
        "id": 269142502,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643046439
    },
    {
        "content": "<p>It's a breaking change to the IR bitcode, so it would require a major LLVM version bump.</p>",
        "id": 269142560,
        "sender_full_name": "Amanieu",
        "timestamp": 1643046467
    },
    {
        "content": "<p>Is any change that older versions of LLVM can't parse automatically considered a breaking change? There's no mechanism for \"compatible extensions\", where if the older version doesn't understand something that's acceptable?</p>",
        "id": 269142786,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643046543
    },
    {
        "content": "<p>In this context, since it's just \"please prevent X from working\", it wouldn't be the end of the world if older LLVM didn't enforce it.</p>",
        "id": 269142846,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643046570
    },
    {
        "content": "<p>(Aside: it wouldn't have to be MASM integer literals in general, it could <em>just</em> fix the ambiguity in <code>b</code> suffixes vs backward labels like 0b, 1b, 10b, etc.)</p>",
        "id": 269143034,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643046639
    },
    {
        "content": "<p>Any flag in the bitcode would need to be understood by both rustc and clang since cross-lang LTO could be done by either of them.</p>",
        "id": 269143554,
        "sender_full_name": "Amanieu",
        "timestamp": 1643046878
    },
    {
        "content": "<p>would it work to use the <code>.intel_syntax</code> directive instead of the llvm flag?</p>",
        "id": 269144610,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643047309
    },
    {
        "content": "<p>It would, but then it would still break cross-lang LTO.</p>",
        "id": 269144728,
        "sender_full_name": "Amanieu",
        "timestamp": 1643047346
    },
    {
        "content": "<p>We already only support cross-lang LTO when both rustc and clang use the same LLVM version.</p>",
        "id": 269144793,
        "sender_full_name": "bjorn3",
        "timestamp": 1643047364
    },
    {
        "content": "<p>Well then we need to ensure that the modified <code>intel_syntax</code> flag is accepted in LLVM upstream first so that it gets into LLVM 14.</p>",
        "id": 269144884,
        "sender_full_name": "Amanieu",
        "timestamp": 1643047396
    },
    {
        "content": "<p>uuh, how would it break, it shouldn't require any modifications to llvm for rustc to generate <code>.intel_syntax</code> in the llvm asm string</p>",
        "id": 269145028,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643047447
    },
    {
        "content": "<p>We'd need to add something like <code>.intel_syntax no_masm_literals</code>. It would need to be understood by the LLVM assembler.</p>",
        "id": 269145125,
        "sender_full_name": "Amanieu",
        "timestamp": 1643047495
    },
    {
        "content": "<p>iirc the llvm assembler already doesn't use masm literals if you use <code>.intel_syntax</code> instead of the llvm flag</p>",
        "id": 269145399,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643047608
    },
    {
        "content": "<p>Oh right, it's using some flag from inline assembly to determine that.</p>",
        "id": 269145463,
        "sender_full_name": "Amanieu",
        "timestamp": 1643047636
    },
    {
        "content": "<p>We still need to use the intel syntax dialect when generating inline assembly since we want LLVM to render register names as <code>rax</code> instead of <code>%rax</code>.</p>",
        "id": 269145536,
        "sender_full_name": "Amanieu",
        "timestamp": 1643047676
    },
    {
        "content": "<p>On the main topic, would it be possible to determine a subset of assembly that would be acceptable from both sides? One of the main things I'd like to avoid is arbitrary interpolations in the asm string, as well as avoiding macros (<code>if</code> may be reasonable, but I'd have to look into it). The way I'd want handle interpolations would be to just replace them in the codegen with the correct operand, rather than doing a textual replacement (which skips having to parse the string, then rewrite it, then parse it, then rewrite it again, then finally parse it again).</p>",
        "id": 269146863,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643048268
    },
    {
        "content": "<p>Would combining of specifying intel syntax using a flag on the asm statement with adding <code>.intel_syntax noprefix</code> at the start of the asm source work?</p>",
        "id": 269146880,
        "sender_full_name": "bjorn3",
        "timestamp": 1643048275
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> You'd only have to parse the string once after the substitutions have been made. There's no need to parse it before then, it's just treated as a <code>format!</code> string template.</p>",
        "id": 269147824,
        "sender_full_name": "Amanieu",
        "timestamp": 1643048665
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143274\">Amanieu</span> <a href=\"#narrow/stream/216763-project-inline-asm/topic/Defect.20Report.3A.20GNU.20AS.20support/near/269147824\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> You'd only have to parse the string once after the substitutions have been made. There's no need to parse it before then, it's just treated as a <code>format!</code> string template.</p>\n</blockquote>\n<p>Yeah, the first parsing is in the frontend, and that's true for that. Then I have to replace it with the bikesheddable xir syntax for asm declarations (which will probably use positional arguments exclusively). I'm pretty sure I'd still have to parse the string in the backend, perform the interpolation, then reparse everything. Ideally, I can do all 3 of those in one step, and just put in the the right <code>X86Operand</code>s.</p>",
        "id": 269148399,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643048886
    },
    {
        "content": "<p>This is how <code>asm!</code> is currently represented in the various stages of the compiler: <a href=\"https://rustc-dev-guide.rust-lang.org/asm.html\">https://rustc-dev-guide.rust-lang.org/asm.html</a></p>",
        "id": 269148650,
        "sender_full_name": "Amanieu",
        "timestamp": 1643048996
    },
    {
        "content": "<p>(And it would be hard to pick a generalized syntax that won't be context dependant in at least some architectures)</p>",
        "id": 269148652,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643048996
    },
    {
        "content": "<p>LLVM and GCC interpolate first and only parse the resulting asm. This allows <code>{}</code> to be used for example as part of a symbol name.</p>",
        "id": 269148785,
        "sender_full_name": "bjorn3",
        "timestamp": 1643049051
    },
    {
        "content": "<p>My point is, apart from the initial parsing which disassembles the template string into an AST structure, no parsing is needed until after register allocation where you need to fill in the placeholders.</p>",
        "id": 269148855,
        "sender_full_name": "Amanieu",
        "timestamp": 1643049085
    },
    {
        "content": "<p>I may look into that and hold that argument. Macros are still the main thing, though. <br>\nHaving to track that kind of state is <em>fun</em>.</p>",
        "id": 269149616,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643049411
    },
    {
        "content": "<p>Also, question. What is rustc supposed to do if it's using !llvm, and on a host where there isn't a GNU compatible assembler available?</p>",
        "id": 269187009,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643066426
    },
    {
        "content": "<p>Seems like it would run into the same problem of \"IDK how to run a GNU Compatible assembler on this code\".</p>",
        "id": 269187040,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643066459
    },
    {
        "content": "<p>package binutils with rustc? alternatively, on the weird archs without binutils support, just declare your assembler to be vacuously compatible with gnu as</p>",
        "id": 269187193,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643066581
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"229517\">Jacob Lifshay</span> <a href=\"#narrow/stream/216763-project-inline-asm/topic/Defect.20Report.3A.20GNU.20AS.20support/near/269187193\">said</a>:</p>\n<blockquote>\n<p>package binutils with rustc? alternatively, on the weird archs without binutils support, just declare your assembler to be vacuously compatible with gnu as</p>\n</blockquote>\n<p>What if binutils doesn't run on the host?</p>",
        "id": 269187223,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643066606
    },
    {
        "content": "<p>then you have one seriously weird host...binutils can be linked into your code as a library iirc</p>",
        "id": 269187365,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643066692
    },
    {
        "content": "<p>binutils doesn't compile on windows, except mingw (even there, IIRC, it requires some modifications).</p>",
        "id": 269187411,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643066723
    },
    {
        "content": "<p>(It also can't target windows-msvc)</p>",
        "id": 269187633,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643066901
    },
    {
        "content": "<p>hmm...</p>",
        "id": 269187784,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643067016
    },
    {
        "content": "<p>if your on windows just use a mingw binary?</p>",
        "id": 269188113,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643067278
    },
    {
        "content": "<p>It's the same issue as with lccc, but aggrevated by the additional fact that what lccc distributes is source code (I have no plans for binary distributions). And I think it would be huge defect if lccc had any additional runtime dependencies on a major platform that the main C compiler wouldn't.</p>",
        "id": 269188120,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643067286
    },
    {
        "content": "<p>I would tend to expect that if a code generation backend doesn't want to use LLVM, and (sensibly) doesn't want to shell out to an external assembler, that it'd end up developing its own internal assembly parser and assembler, ideally as a reusable library. Perhaps by extracting some of the relevant code from LLVM for reuse.</p>",
        "id": 269211423,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643088474
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/216763-project-inline-asm/topic/Defect.20Report.3A.20GNU.20AS.20support/near/269211423\">said</a>:</p>\n<blockquote>\n<p>I would tend to expect that if a code generation backend doesn't want to use LLVM, and (sensibly) doesn't want to shell out to an external assembler, that it'd end up developing its own internal assembly parser and assembler, ideally as a reusable library. Perhaps by extracting some of the relevant code from LLVM for reuse.</p>\n</blockquote>\n<p>That was my issue here: this was my goal, but I don't want to have to write a full on macro assembler in really any lccc backend, as it would further complicate my already complicated job, especially if the assembler has to effectively be bug compatible with GNU as.</p>",
        "id": 269250381,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643114365
    },
    {
        "content": "<p>if you are ok with running a separate assembler, you can use llvm-mc iirc</p>",
        "id": 269261245,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643119713
    },
    {
        "content": "<p>which does compile just fine on msvc and supports gnu as syntax</p>",
        "id": 269261320,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643119749
    },
    {
        "content": "<p>They mentioned wanting to avoid an LLVM dependency, so that sounds like not really an ideal option. That said, I think in practice its not as bad as they're making it out. It clearly doesn't need to be bug compatible (the amount of Rust code using asm in the wild is not <em>that</em> large, and probably wont grow to be), and in practice failing to support directives (at least when no external assembler is present) is probably an option, at least at first.</p>",
        "id": 269323624,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1643144546
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> has marked this topic as unresolved.</p>",
        "id": 269668939,
        "sender_full_name": "Notification Bot",
        "timestamp": 1643333246
    },
    {
        "content": "<p>Being discussed in <a class=\"stream\" data-stream-id=\"213817\" href=\"/#narrow/stream/213817-t-lang\">#t-lang</a> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends\">https://rust-lang.zulipchat.com/#narrow/stream/213817-t-lang/topic/asm!.20and.20backends</a></p>",
        "id": 270332758,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643776555
    }
]