[
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119239\">sky d</span> has marked this topic as resolved.</p>",
        "id": 269354647,
        "sender_full_name": "Notification Bot",
        "timestamp": 1643163665
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/216763-project-inline-asm/topic/.E2.9C.94.20Defect.20Report.3A.20GNU.20AS.20support/near/269323624\">said</a>:</p>\n<blockquote>\n<p>They mentioned wanting to avoid an LLVM dependency, so that sounds like not really an ideal option. That said, I think in practice its not as bad as they're making it out. It clearly doesn't need to be bug compatible (the amount of Rust code using asm in the wild is not <em>that</em> large, and probably wont grow to be), and in practice failing to support directives (at least when no external assembler is present) is probably an option, at least at first.</p>\n</blockquote>\n<p>The llvm dependency is also a non-starter, due to cmake's poor cross-compiling story.</p>",
        "id": 269358546,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643168340
    },
    {
        "content": "<p>I'l  do what I can, though. Most of this is exagerated (I do not yet know how difficult or easy some parts will be), mostly because of timing. It's easier to leave it not-guaranteed early, then increase guarantees later than it is to reverse course after the fact.</p>",
        "id": 269358705,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643168504
    },
    {
        "content": "<p>iirc google's been working on adding bazel support to llvm, it may cross-compile more easily if you use bazel to build it...idk though, i've never looked into bazel</p>",
        "id": 269359867,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643169613
    },
    {
        "content": "<p><a href=\"https://github.com/llvm/llvm-project/tree/main/utils/bazel\">https://github.com/llvm/llvm-project/tree/main/utils/bazel</a></p>",
        "id": 269360006,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643169722
    },
    {
        "content": "<p>Nice. I'd still avoid it if at all possible -especially for one argubly minor portion. The submodule is massive and several minutes worth of cloning.</p>",
        "id": 269360103,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643169795
    },
    {
        "content": "<p>one other option maybe worth considering is compiling binutils to run inside a wasm/wasi runtime -- you may end up needing a wasm runtime anyway for the isolated proc-macros that are maybe getting added to rustc</p>",
        "id": 269360226,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643169893
    },
    {
        "content": "<p>That wouldn't work if the <code>--build</code> system is windows-msvc, I don't think.</p>",
        "id": 269360362,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643170000
    },
    {
        "content": "<p>(Also gets excessive when you have n+1 supported targets)</p>",
        "id": 269360386,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643170039
    },
    {
        "content": "<p>some very cursory googling led to <a href=\"https://www.npmjs.com/package/wasm-binutils-arm-linux\">https://www.npmjs.com/package/wasm-binutils-arm-linux</a></p>",
        "id": 269360389,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643170041
    },
    {
        "content": "<p>with wasm you'd only need one binary for every supported target, no matter what platform your building on...</p>",
        "id": 269360511,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643170183
    },
    {
        "content": "<p>binutils only supports one target arch per binary anyway iirc, so if you want to target msvc-x86 and ppc-linux you'd need two binaries...but those two wasm binaries can run on any host</p>",
        "id": 269360645,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643170305
    },
    {
        "content": "<p>Yeah, if you're starting anything new that you have to do non-trivial architectural work on anyway, it seems preferable to avoid the gcc/binutils limitation of \"one target per binary\" if at all possible, and use some other base that doesn't have that fundamental limitation.</p>",
        "id": 269360722,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643170359
    },
    {
        "content": "<p>Yeah, that's ideal to avoid, especially since the project is designed to avoid that legacy problem.<br>\nGoing for internal is probably the best bet, the question is how much can be supported easily.</p>",
        "id": 269362880,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643172104
    },
    {
        "content": "<p>I feel that in practice what we say in the spec won't matter much in practice: in the end people will end up using assembler directives since we don't restrict them on the rustc side. You'll end up in a similar situation to Clang having to catch up to GCC in terms of niche features to be able to compile GNU C codebases like the Linux kernel.</p>",
        "id": 269378862,
        "sender_full_name": "Amanieu",
        "timestamp": 1643187307
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143274\">Amanieu</span> <a href=\"#narrow/stream/216763-project-inline-asm/topic/.E2.9C.94.20Defect.20Report.3A.20GNU.20AS.20support/near/269378862\">said</a>:</p>\n<blockquote>\n<p>I feel that in practice what we say in the spec won't matter much in practice: in the end people will end up using assembler directives since we don't restrict them on the rustc side.</p>\n</blockquote>\n<p>What if you did? I agree with Connor that this is a spec nightmare. You should start with a small subset and work your way out to stabilizing more obscure features, not just accept everything and \"accidentally\" stabilize all of the undocumented quirks of GNU <code>as</code> as part of the rust specification. This is a pattern that has paid off many times in rust history, and it's not clear why asm needs to be so completely opposed in design</p>",
        "id": 269454163,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643219923
    },
    {
        "content": "<p>An asm macro that just passes things directly to LLVM sounds useful for some applications but also sounds like it should be perma-unstable</p>",
        "id": 269454858,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643220155
    },
    {
        "content": "<p>The RFC specifically explains why we don't want to try to validate the assembly code in rustc: <a href=\"https://rust-lang.github.io/rfcs/2873-inline-asm.html#validate-the-assembly-code-in-rustc\">https://rust-lang.github.io/rfcs/2873-inline-asm.html#validate-the-assembly-code-in-rustc</a></p>",
        "id": 269455196,
        "sender_full_name": "Amanieu",
        "timestamp": 1643220278
    },
    {
        "content": "<p>Isn't it pretty easy to separate directives from instructions? It's already mostly line by line, and the directives start with a <code>.</code></p>",
        "id": 269462557,
        "sender_full_name": "Lokathor",
        "timestamp": 1643223322
    },
    {
        "content": "<p>you don't have to actually understand any assembly instructions at all</p>",
        "id": 269462644,
        "sender_full_name": "Lokathor",
        "timestamp": 1643223356
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> I recall there being some issues that make it more difficult than just looking for <code>.</code> at the start of a line.</p>",
        "id": 269463725,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643223728
    },
    {
        "content": "<p>Line continuations, comments, something like that.</p>",
        "id": 269463796,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643223755
    },
    {
        "content": "<p>Sure, I don't imagine it would be done in an hour, but I bet it could be done within a fairly short period. And it's largely a one time cost to build, the actual syntax of assembly doesn't change much over the years.</p>",
        "id": 269464478,
        "sender_full_name": "Lokathor",
        "timestamp": 1643223995
    },
    {
        "content": "<p>And I'm not saying it absolutely must be done  but the amount of effort seems a little exaggerated when we're talking about a language stabilization.</p>",
        "id": 269464606,
        "sender_full_name": "Lokathor",
        "timestamp": 1643224055
    },
    {
        "content": "<p>I think that any implementation that calls out to any assembler that is not built into the compiler is inherently incompatible with the goals of the RFC as written.</p>\n<blockquote>\n<p>The intent is that support for asm! should be independent of the rustc back-end used: it should always work, but with lower performance if the backend does not support inline assembly.<br>\nThis is at odds with any implementation besides an asm parser that is part of rustc and conforms to some specific syntax per target.</p>\n</blockquote>\n<p>The previous sentence in the RFC is</p>\n<blockquote>\n<p>If a back-end does not support inline assembly natively then we can fall back to invoking an external assembler.<br>\nWhich also conflicts with the goal to be backend independent, since any external tools are effectively part of the back-end codegen. So this may be an issue with the RFC as written rather than an implementation issue.</p>\n</blockquote>\n<p>I think that the only correct implementation that can allow Rust to have <code>asm!</code> that doesn't rely on an exact back-end toolset is to parse the asm and emit the instructions completely via the compiler.  I don't know how rustc can accomplish that, whether it can make an object file and link it in or however that works, but I think it is required that the compiler be an assembly parser to allow asm to be backend independent.</p>\n<p><a href=\"https://rust-lang.github.io/rfcs/2873-inline-asm.html#supporting-back-ends-without-inline-assembly\">relevant rfc section</a></p>",
        "id": 269662986,
        "sender_full_name": "asquared31415",
        "timestamp": 1643329415
    },
    {
        "content": "<p>However I think it is important that GNU AS-like syntax is supported because a lot of the directives are used by people and people expect to be able to <code>(global_)asm!(include_str!(\"file.s\"))</code></p>",
        "id": 269663520,
        "sender_full_name": "asquared31415",
        "timestamp": 1643329709
    }
]