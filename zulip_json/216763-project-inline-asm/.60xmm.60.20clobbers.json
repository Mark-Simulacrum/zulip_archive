[
    {
        "content": "<p>Does a <code>out(\"xmm0\") _</code> clobber tell the compiler that the entire fpu register is clobbered?</p>",
        "id": 266462997,
        "sender_full_name": "asquared31415",
        "timestamp": 1640902768
    },
    {
        "content": "<p>It clobbers <code>ymm0</code> and <code>zmm0</code> as well.</p>",
        "id": 266465407,
        "sender_full_name": "Amanieu",
        "timestamp": 1640905421
    },
    {
        "content": "<p>If that's what you're asking.</p>",
        "id": 266465414,
        "sender_full_name": "Amanieu",
        "timestamp": 1640905427
    },
    {
        "content": "<p>It has no effect on the x87 registers, which are separate.</p>",
        "id": 266465462,
        "sender_full_name": "Amanieu",
        "timestamp": 1640905444
    },
    {
        "content": "<p>Speaking of the x87 registers, is thee a guaranteed state for them entering the asm or would you need to use <code>fninit</code> to do anything with them at all?</p>",
        "id": 266465574,
        "sender_full_name": "Connor Horman",
        "timestamp": 1640905589
    },
    {
        "content": "<p>If you clobber them then the FP stack is guaranteed to be empty.</p>",
        "id": 266465602,
        "sender_full_name": "Amanieu",
        "timestamp": 1640905640
    },
    {
        "content": "<p>Hmm that's not documented though.</p>",
        "id": 266465613,
        "sender_full_name": "Amanieu",
        "timestamp": 1640905662
    },
    {
        "content": "<p>That would be good to document. Does that apply if you just clobber st0, or do you need to clobber all 8 of them?</p>",
        "id": 266465666,
        "sender_full_name": "Connor Horman",
        "timestamp": 1640905697
    },
    {
        "content": "<p>At the moment clobbering one of them will cause all of them to be clobbered.</p>",
        "id": 266465686,
        "sender_full_name": "Amanieu",
        "timestamp": 1640905727
    },
    {
        "content": "<p>GCC inline assembly has pretty complex rules to deal with the x87 register stack that I frankly do not want to bother with: <a href=\"https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html#x86-Floating-Point-asm-Operands\">https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html#x86-Floating-Point-asm-Operands</a></p>",
        "id": 266465963,
        "sender_full_name": "Amanieu",
        "timestamp": 1640906040
    },
    {
        "content": "<p>I think making the rule that if you clobber any x87 floating point register you clobber them all seems reasonable.</p>",
        "id": 266479553,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640923355
    },
    {
        "content": "<p>I don't think we should strive for making it easy or efficient to pass in values via floating point stack state, because if you wanted ease or efficiency you wouldn't use x87.</p>",
        "id": 266479584,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640923395
    },
    {
        "content": "<p>Well, it should be reasonable to call subroutines in x86, most of which, the calling convention requires the stack be empty at entry (and leaves it either empty, or, for 32-bit, with 1 value for a floating-point return value)</p>",
        "id": 266480249,
        "sender_full_name": "Connor Horman",
        "timestamp": 1640924415
    },
    {
        "content": "<p>It also may be useful for such to be able to store values from the fp stack into f32 and f64 values, again, to match the calling conventions of such functions returning float or double. It shouldn't be unreasonable to match well-known calling conventions with rust's inline assembly, especially ones that aren't supported (even unstably). This (actually this entire thread) came up on the Rust Community Discord's dark-arts channel, where a couple of people were trying to wrap the Borland register calling convention.</p>",
        "id": 266480722,
        "sender_full_name": "Connor Horman",
        "timestamp": 1640925217
    },
    {
        "content": "<p>(And these aren't really limited to that convention either, every 32-bit x86 convention I can find returns <code>float</code>, <code>double</code>, and <code>long double</code> in <code>st(0)</code>)</p>",
        "id": 266480944,
        "sender_full_name": "Connor Horman",
        "timestamp": 1640925532
    },
    {
        "content": "<p>To clarify, I absolutely agree that we need to support such calling conventions and other similar things. Rather, I'm saying we don't necessarily need the full complexity of supporting partial clobbers of the x87 floating-point stack, for instance.</p>",
        "id": 266482885,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640928646
    },
    {
        "content": "<p><em>Arbitrary</em> floating-point stack state doesn't seem as critical as the portions of that state used by calling conventions.</p>",
        "id": 266482903,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640928703
    }
]