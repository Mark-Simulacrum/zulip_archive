[
    {
        "content": "<p>I wonder if there's a satisfactory way to define <code>nonportable_</code> versions of the float min/max/cmp operations such that the operation is still safe/sound, but that it returns an unspecified[^1] result if the inputs contain a NaN, or if the comparison is between <code>+0.0</code> and <code>-0.0</code>, etc[^2]. Implementations would be encouraged (but not required) to use a more efficient lowering if one is available.</p>\n<p>This would help a lot more code actually transition from <code>core::arch</code> to <code>core::simd</code>, rather than just using it as the fallback. Yeah, the overhead of portability here is like 1-3 extra instructions, but... in a optimized kernel, if the old version was just a single instruction, the new one might be 3x or 4x slower, which could be a significant overhead — given that (IMO) the point of SIMD is performance, that's a big problem[^3].</p>\n<h2>Alternatives</h2>\n<p>Up til now, I had imagined folks who really care would still use a platform-specific <code>#[cfg()]</code> in the middle, or even just maintain target-specific code and only <code>core::simd</code> as the portable fallback, but honestly the more I think about it, the more I think I'd consider that to be an indication that we've, kinda... failed those users somewhat. Of course, to some extent these users will definitely will exist, since we don't provide every operation available from <code>core::arch</code>, but IMO they shouldn't expect to need to reach into <code>core::arch</code> just to get a faster version of something we <em>do</em> provide. (And I imagine often they won't debug the perf issue, and will just say \"oh, it's slower\", and keep both, only using core::simd on <code>#[cfg(not(&lt;x86-family&gt;))]</code> — this is what I'd do)</p>\n<p>The other alternative we've floated is that some future \"Rust equivalent to <code>-ffast-math</code>\" would fix this. Unfortunately, in practice the fast-math flags that improve things here are the ones that consider NaN and/or signed zeros UB. I suspect the rust versions of these flags (or whatever non-flag equivalent there is) won't include options for making a subset of floats UB, as it's too dangerous (it tends to be very easy for users to craft inputs that trigger some derived computation to produce a <code>NaN</code>, let alone a <code>-0.0</code>). Moreover, often enough a user would either handle the problem case later[^4], if they need to handle it at all[^5], so there's no reason for it to be UB.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Footnotes (I'm sorry, I have a problem)</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>[^1]: Unspecified but with constraints like \"max/min must return one of the inputs\" and such, but beyond that it possibly could even be considered non-determinstic, given that it's going to depend on the target features active for the code in question, which depends on how much it gets inlined, etc. Obviously the precise wording here is important, but probably not the point.</p>\n<p>[^2]: Is there anything else we'd want to carve out as to allow a more efficient impl on some target? Short of stuff like forbidding denormals, which is too general to try to solve here.</p>\n<p>[^3]: For example, I know that the fix for &lt;<a href=\"https://github.com/rust-lang/stdarch/pull/1155\">https://github.com/rust-lang/stdarch/pull/1155</a>&gt; caused a 1.5x speedup in some SIMD code of mine that I can share later.</p>\n<p>[^4]: While <code>NaN</code>s are often an indication my code has a bug (and the cases where I'd use this are cases where I truly believe it to be impossible), if the compiler believes it's UB for some operation to return a NaN (because that would require a NaN input, which it considers UB), it can remove a downstream <code>assert!(!f.is_nan())</code> call (or, the C equivalent — I've seen this with gcc's <code>-ffast-math</code>).</p>\n<p>[^5]:  For example: most code just won't even notice what sign a given zero has, so <code>splat(+0.0).max(splat(-0.0))</code> could return either argument for all they care.</p>\n</div></div>",
        "id": 267512774,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1641854875
    },
    {
        "content": "<p>Bikeshedding: I guess this could also be a <code>use core::simd::nonportable::Ext as _</code> trait or something. I'd prefer that to actually be target specific well-defined ops, which IDT we should have (better off in core::arch) — the nice thing about these is that codegen backends can just impl them identically to the current versions if they want.</p>",
        "id": 267513110,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1641855030
    },
    {
        "content": "<p>If there are non-comparison operations that are worth having the same treatment (possibly casts/conversions?) it would be nice to handle them similarly</p>",
        "id": 267513339,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1641855188
    },
    {
        "content": "<p>I suppose my thought on this is that ieee754 is already a hardware abstraction, as is fast-math, so we can really draw arbitrary lines at every level that include all hardware with particular behavior on a particular architecture</p>",
        "id": 267518923,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641858880
    },
    {
        "content": "<p>This one seems to prioritize making an operation that compiles down to x86 vmin specifically and finding semantics that match that</p>",
        "id": 267518976,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641858920
    }
]