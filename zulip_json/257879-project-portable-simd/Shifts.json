[
    {
        "content": "<p>Hi all, I'm trying to figure out how to do a logical shift right on an <code>i32x16</code> and finding it pretty difficult.  I understand that if I can convert to a <code>u32x16</code> and do the right shift it will be logical, but I can't figure out how to go from <code>i32x16</code> -&gt; <code>u32x16</code> -&gt; <code>i32x16</code> without going through a non-portable type like __mm512.  Am I missing an API?</p>",
        "id": 272481477,
        "sender_full_name": "Dan Burkert",
        "timestamp": 1645233801
    },
    {
        "content": "<p>Separately, I know there has been recent discussions over whether to add scalar shifts or not.  From where I'm sitting that'd be really nice.  I'm doing a ton of scalar shifts in some generic code, and having to write <code>thing &lt;&lt; Simd::&lt;i32, LANES&gt;::splat(n)</code> instead of <code>thing &lt;&lt; n</code> is adding a lot of code noise.  I have checked on godbolt that LLVM removes the <code>splat</code>, but it's really a lot of noise in the source code.</p>",
        "id": 272481675,
        "sender_full_name": "Dan Burkert",
        "timestamp": 1645233965
    },
    {
        "content": "<p>you want <code>Simd::cast</code> -- it's basically <code>as</code> for simd types</p>",
        "id": 272482301,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1645234625
    },
    {
        "content": "<p><a href=\"https://doc.rust-lang.org/nightly/std/simd/struct.Simd.html#method.cast\">https://doc.rust-lang.org/nightly/std/simd/struct.Simd.html#method.cast</a></p>",
        "id": 272482309,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1645234634
    },
    {
        "content": "<p>Yep, I totally missed that.  Thanks <span class=\"user-mention\" data-user-id=\"229517\">@Jacob Lifshay</span> !</p>",
        "id": 272482410,
        "sender_full_name": "Dan Burkert",
        "timestamp": 1645234739
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"457711\">Dan Burkert</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/Shifts/near/272481675\">said</a>:</p>\n<blockquote>\n<p>Separately, I know there has been recent discussions over whether to add scalar shifts or not.  From where I'm sitting that'd be really nice.  I'm doing a ton of scalar shifts in some generic code, and having to write <code>thing &lt;&lt; Simd::&lt;i32, LANES&gt;::splat(n)</code> instead of <code>thing &lt;&lt; n</code> is adding a lot of code noise.  I have checked on godbolt that LLVM removes the <code>splat</code>, but it's really a lot of noise in the source code.</p>\n</blockquote>\n<p>These were mostly removed because the initial implementation broke type inference for scalar code, so we do plan to readd them, more cautiously this time.</p>\n<p>However, you should only have to write <code>Simd::splat(n)</code>, the rest should be inferred?</p>",
        "id": 272482447,
        "sender_full_name": "Jubilee",
        "timestamp": 1645234769
    },
    {
        "content": "<blockquote>\n<p>However, you should only have to write Simd::splat(n), the rest should be inferred?</p>\n</blockquote>\n<p>Quite possibly, I haven't tried that.  Will report back.</p>",
        "id": 272482526,
        "sender_full_name": "Dan Burkert",
        "timestamp": 1645234826
    },
    {
        "content": "<p>logical shift: <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=release&amp;edition=2021&amp;gist=78f4bf12c87e1b0118e9dd0a2feb1300\">https://play.rust-lang.org/?version=nightly&amp;mode=release&amp;edition=2021&amp;gist=78f4bf12c87e1b0118e9dd0a2feb1300</a></p>",
        "id": 272482539,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1645234844
    },
    {
        "content": "<p><code>Simd::splat</code> does appear to work, thanks <span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span></p>",
        "id": 272483042,
        "sender_full_name": "Dan Burkert",
        "timestamp": 1645235283
    },
    {
        "content": "<p>maybe we should add <code>Simd::cast</code> as something that comes up in the docs if you search for <code>as</code>...</p>",
        "id": 272483214,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1645235441
    },
    {
        "content": "<p>I was looking for a <code>From</code> impl FWIW, I think I subconsciously avoid <code>as</code> since it's such a footgun in other contexts</p>",
        "id": 272483344,
        "sender_full_name": "Dan Burkert",
        "timestamp": 1645235541
    },
    {
        "content": "<p>dunno if it'd be coherent, but something like <code>impl From&lt;Simd&lt;U; LANES&gt;&gt; for Simd&lt;T; LANES&gt; where U: SimdElement</code> was what I was expecting</p>",
        "id": 272483479,
        "sender_full_name": "Dan Burkert",
        "timestamp": 1645235674
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"457711\">@Dan Burkert</span> Those aren't actually implemented for u32 to i32 and back.</p>",
        "id": 272483594,
        "sender_full_name": "Jubilee",
        "timestamp": 1645235779
    },
    {
        "content": "<p>we're not using <code>from</code> for all casting, cuz <code>from</code> is supposed to be value-preserving, not all casts preserve values</p>",
        "id": 272483602,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1645235788
    },
    {
        "content": "<p>e.g. <code>3.4 as i32 == 3</code></p>",
        "id": 272483614,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1645235806
    },
    {
        "content": "<p>oh of course</p>",
        "id": 272483615,
        "sender_full_name": "Dan Burkert",
        "timestamp": 1645235808
    },
    {
        "content": "<p>yep makes sense</p>",
        "id": 272483622,
        "sender_full_name": "Dan Burkert",
        "timestamp": 1645235812
    },
    {
        "content": "<p>we should implement from for the value-preserving casts though, such as <code>i8</code> to <code>i32</code>. icr if we implemented those yet.</p>",
        "id": 272483737,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1645235908
    },
    {
        "content": "<p>We had not!</p>",
        "id": 272544363,
        "sender_full_name": "Jubilee",
        "timestamp": 1645306734
    },
    {
        "content": "<p>Re. casting, is there a safe way to go from (unaligned) <code>&amp;[u8]</code> to <code>Simd&lt;T, L&gt;</code>?  I.e. a safe wrapper around ptr::read_unaligned?</p>",
        "id": 273691586,
        "sender_full_name": "Dan Burkert",
        "timestamp": 1646160783
    },
    {
        "content": "<p>or equivalent to <code>u64::from_be_bytes</code></p>",
        "id": 273691872,
        "sender_full_name": "Dan Burkert",
        "timestamp": 1646160862
    },
    {
        "content": "<p>It won't be efficient, but you could use <code>from_*_bytes</code> and write each lane manually</p>",
        "id": 273692109,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1646160943
    },
    {
        "content": "<p>The compiler _might_ see through that and optimize it</p>",
        "id": 273692143,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1646160961
    },
    {
        "content": "<p>Ah - I don't need BE specifically, I actually want NE.  So right now I'm using unsafe ptr::read_unaligned (which works), but can't help but think there should be a safe function built in that does length checks</p>",
        "id": 273692245,
        "sender_full_name": "Dan Burkert",
        "timestamp": 1646160990
    },
    {
        "content": "<p>The closest thing we have right now is you could use TryInto to convert the slice into an array, then convert the array into a vector</p>",
        "id": 273692387,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1646161045
    },
    {
        "content": "<p>it does seem like there should be a vectorized conversions between NE, BE, LE.  not sure if the instruction sets have that, or if it'd just be a fancy shuffle</p>",
        "id": 273692432,
        "sender_full_name": "Dan Burkert",
        "timestamp": 1646161068
    },
    {
        "content": "<blockquote>\n<p>The closest thing we have right now is you could use TryInto to convert the slice into an array, then convert the array into a vector</p>\n</blockquote>\n<p>hmm, what type would the array be?  I'm starting with an unaligned <code>&amp;[u8]</code> and want to end up with a <code>Simd&lt;u32, L&gt;</code></p>",
        "id": 273692691,
        "sender_full_name": "Dan Burkert",
        "timestamp": 1646161172
    },
    {
        "content": "<p>For <code>[u8]</code> specifically, it'll probably be the safe-transmute work eventually, for <code>ne</code>.</p>",
        "id": 273693316,
        "sender_full_name": "scottmcm",
        "timestamp": 1646161370
    },
    {
        "content": "<p>We have some byte conversion functions but they require beyond what's currently possible with stable const generics, since the size of the byte vector doesn't have the same length as the desired vector</p>",
        "id": 273693436,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1646161420
    },
    {
        "content": "<p>Hmm, for <code>i32</code> it could maybe work off <code>[u8; 4]</code>s, which you can get from a slice via <a href=\"https://doc.rust-lang.org/nightly/std/primitive.slice.html#method.as_chunks\">https://doc.rust-lang.org/nightly/std/primitive.slice.html#method.as_chunks</a></p>",
        "id": 273693764,
        "sender_full_name": "scottmcm",
        "timestamp": 1646161558
    },
    {
        "content": "<p>(I need to go try and push that method to stabilization...)</p>",
        "id": 273693843,
        "sender_full_name": "scottmcm",
        "timestamp": 1646161573
    },
    {
        "content": "<p>Thanks for the thoughts <span class=\"user-mention\" data-user-id=\"312331\">@Caleb Zulawski</span> <span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span></p>",
        "id": 273713286,
        "sender_full_name": "Dan Burkert",
        "timestamp": 1646170169
    },
    {
        "content": "<p>No problem</p>",
        "id": 273713610,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1646170262
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"457711\">Dan Burkert</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/Shifts/near/273692245\">said</a>:</p>\n<blockquote>\n<p>Ah - I don't need BE specifically, I actually want NE.  So right now I'm using unsafe ptr::read_unaligned (which works), but can't help but think there should be a safe function built in that does length checks</p>\n</blockquote>",
        "id": 273724173,
        "sender_full_name": "Jubilee",
        "timestamp": 1646175340
    },
    {
        "content": "<p>that would presumably still be unsafe, right?  It could be made safe if it was a <code>&amp;[u8] -&gt; Simd&lt;T, L&gt;</code> conversion that had length checks internally</p>",
        "id": 273726247,
        "sender_full_name": "Dan Burkert",
        "timestamp": 1646176400
    },
    {
        "content": "<p>in my case the length checks get removed anyway since I do length checks all-at-once for an unrolled loop</p>",
        "id": 273726276,
        "sender_full_name": "Dan Burkert",
        "timestamp": 1646176426
    },
    {
        "content": "<p>IMO I think there will probably never be a function that reads a slice of u8 as a vector of u32 since that's a pretty roundabout operation.  I expect safe transmute to eventually allow creation of a [u32; N] from a [u8; N * 4] though, which would solve this problem</p>",
        "id": 273726539,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1646176610
    },
    {
        "content": "<p>Reading from the pointer would still be unsafe, correct</p>",
        "id": 273726672,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1646176686
    },
    {
        "content": "<p>I see, I agree that'd solve the problem as well</p>",
        "id": 273731652,
        "sender_full_name": "Dan Burkert",
        "timestamp": 1646179426
    },
    {
        "content": "<p>I'm surprised looking at the <code>bytemuck</code> API that it doesn't offer a way to do this, it seems like it would fit right in to the domain of <code>Pod</code>.  I suppose the author wants to limit it to just casts</p>",
        "id": 273731759,
        "sender_full_name": "Dan Burkert",
        "timestamp": 1646179476
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span></p>",
        "id": 273731945,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1646179578
    },
    {
        "content": "<p>Lol</p>",
        "id": 273731952,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1646179579
    },
    {
        "content": "<p>you can probably already do this with bytemuck</p>",
        "id": 273732073,
        "sender_full_name": "Lokathor",
        "timestamp": 1646179654
    },
    {
        "content": "<p>oh, hm, maybe you'd need bytemuck2 for this i guess</p>",
        "id": 273732168,
        "sender_full_name": "Lokathor",
        "timestamp": 1646179697
    },
    {
        "content": "<p>well if you want &amp;[u8] to T:Pod that's possible and maybe just not implemented</p>",
        "id": 273732242,
        "sender_full_name": "Lokathor",
        "timestamp": 1646179744
    },
    {
        "content": "<p>&lt;<a href=\"https://github.com/Lokathor/bytemuck/pull/92\">https://github.com/Lokathor/bytemuck/pull/92</a>&gt; I need someone who isn't me to double check this.</p>",
        "id": 273736607,
        "sender_full_name": "Lokathor",
        "timestamp": 1646182565
    },
    {
        "content": "<p>I assume Pod implies all bit patterns are valid?</p>",
        "id": 273736815,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1646182787
    },
    {
        "content": "<p>It seems okay to me, then</p>",
        "id": 273736820,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1646182800
    },
    {
        "content": "<p>Maybe I'm crazy but couldn't you technically make that read any slice of <code>Pod</code>s into a different <code>Pod</code> type?</p>",
        "id": 273737074,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1646182864
    },
    {
        "content": "<p>Not just u8</p>",
        "id": 273737081,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1646182871
    },
    {
        "content": "<p>you could probably, but the API becomes more complicated that way I'd say, and &amp;[u8] is usually the common case. and that slice of pods can also already be cast to a slice of u8</p>",
        "id": 273737344,
        "sender_full_name": "Lokathor",
        "timestamp": 1646183104
    },
    {
        "content": "<p>Good point</p>",
        "id": 273737489,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1646183195
    },
    {
        "content": "<p>&lt;<a href=\"https://docs.rs/bytemuck/latest/bytemuck/fn.pod_read_unaligned.html\">https://docs.rs/bytemuck/latest/bytemuck/fn.pod_read_unaligned.html</a>&gt;</p>",
        "id": 273739231,
        "sender_full_name": "Lokathor",
        "timestamp": 1646184387
    },
    {
        "content": "<p>hah wait did that just get added because of this thread?  Absolutely stellar, thanks Lokathor, Caleb</p>",
        "id": 273758388,
        "sender_full_name": "Dan Burkert",
        "timestamp": 1646199259
    },
    {
        "content": "<p>As much as I do want everything in bytemuck to some day get blobbed into core for the benefit of all rustfolk (hi jwrenn!), being an outside crate does give me quite the edge on turn-around time.</p>",
        "id": 273763454,
        "sender_full_name": "Lokathor",
        "timestamp": 1646204038
    },
    {
        "content": "<p>Re. casts (again) - I'm finding the lack of <code>Mask::cast</code> to be painful in some generic code where I've got a mask generated by <code>Simd&lt;T, L&gt;::lanes_eq</code>, where T is a type parameter to the function, and then using that to select from a <code>Simd&lt;f64&gt;</code>, e.g. a non-parameterized vector type</p>",
        "id": 273895505,
        "sender_full_name": "Dan Burkert",
        "timestamp": 1646263765
    },
    {
        "content": "<p>I'm hoping I can use to_int + cast + from_int as a workaround</p>",
        "id": 273895595,
        "sender_full_name": "Dan Burkert",
        "timestamp": 1646263804
    },
    {
        "content": "<p>I believe masks should all implement Into?</p>",
        "id": 273895776,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1646263840
    },
    {
        "content": "<p>Into the other various mask types, I mean</p>",
        "id": 273895798,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1646263856
    },
    {
        "content": "<p>It's not done via a blanket impl though</p>",
        "id": 273895956,
        "sender_full_name": "Dan Burkert",
        "timestamp": 1646263948
    },
    {
        "content": "<p>So I could add some more type bounds on my function, but I'd like to keep it to just <code>where T: SimdElement</code></p>",
        "id": 273895976,
        "sender_full_name": "Dan Burkert",
        "timestamp": 1646263969
    },
    {
        "content": "<p>LMK if that's not clear - I can give a better example</p>",
        "id": 273896025,
        "sender_full_name": "Dan Burkert",
        "timestamp": 1646264004
    },
    {
        "content": "<p>into gives this error:</p>\n<div class=\"codehilite\"><pre><span></span><code>error[E0277]: the trait bound `std::simd::Mask&lt;i64, 8_usize&gt;: From&lt;std::simd::Mask&lt;&lt;T as SimdElement&gt;::Mask, 8_usize&gt;&gt;` is not satisfied\n   --&gt; file.rs:136:101\n    |\n136 |             let mask: Mask&lt;i64, LANES&gt; = Simd::from(*values).lanes_eq(Simd::splat(v)).into();\n    |                                                                                       ^^^^ the trait `From&lt;std::simd::Mask&lt;&lt;T as SimdElement&gt;::Mask, 8_usize&gt;&gt;` is not implemented for `std::simd::Mask&lt;i64, 8_usize&gt;`\n    |\n    = note: required because of the requirements on the impl of `Into&lt;std::simd::Mask&lt;i64, 8_usize&gt;&gt;` for `std::simd::Mask&lt;&lt;T as SimdElement&gt;::Mask, 8_usize&gt;`\nhelp: consider introducing a `where` bound, but there might be an alternative better way to express this requirement\n    |\n111 | impl MyTrait for MyType where std::simd::Mask&lt;i64, 8_usize&gt;: From&lt;std::simd::Mask&lt;&lt;T as SimdElement&gt;::Mask, 8_usize&gt;&gt; {\n    |                                      +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n...\n</code></pre></div>",
        "id": 273896449,
        "sender_full_name": "Dan Burkert",
        "timestamp": 1646264290
    },
    {
        "content": "<p>Ahhh I see.</p>",
        "id": 273896461,
        "sender_full_name": "Jubilee",
        "timestamp": 1646264297
    },
    {
        "content": "<p>Thank you, yes we can probably add that.</p>",
        "id": 273896510,
        "sender_full_name": "Jubilee",
        "timestamp": 1646264325
    },
    {
        "content": "<p>BTW the to_int + cast + from_int workaround does work</p>",
        "id": 273896511,
        "sender_full_name": "Dan Burkert",
        "timestamp": 1646264325
    },
    {
        "content": "<p>I think because <code>cast</code> is generic</p>",
        "id": 273896527,
        "sender_full_name": "Dan Burkert",
        "timestamp": 1646264334
    },
    {
        "content": "<p>yeah that's probably what the inner implementation will look like. &lt;_&lt;</p>",
        "id": 273896538,
        "sender_full_name": "Jubilee",
        "timestamp": 1646264339
    },
    {
        "content": "<p>yeah, I fully expect that will optimize out so not a huge deal</p>",
        "id": 273896568,
        "sender_full_name": "Dan Burkert",
        "timestamp": 1646264358
    },
    {
        "content": "<p>tbh I am not sure our Mask implementation is actually enabling optimizations atm, but we don't have as many larger programs to bench/test on.</p>",
        "id": 273897257,
        "sender_full_name": "Jubilee",
        "timestamp": 1646264747
    },
    {
        "content": "<p>Changing mask widths is not necessarily likely to optimize out</p>",
        "id": 273900929,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1646266698
    },
    {
        "content": "<p>ahhh, the bloody <code>From&lt;T&gt; for T</code> reflexive blanket impl conflicts with </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"nb\">From</span><span class=\"o\">&lt;</span><span class=\"n\">Mask</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Mask</span><span class=\"o\">&lt;</span><span class=\"n\">U</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">LaneCount</span><span class=\"o\">&lt;</span><span class=\"n\">N</span><span class=\"o\">&gt;</span>: <span class=\"nc\">SupportedLaneCount</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">U</span>: <span class=\"nc\">MaskElement</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">from</span><span class=\"p\">(</span><span class=\"n\">value</span>: <span class=\"nc\">Mask</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"bp\">Self</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">.</span><span class=\"mf\">0.</span><span class=\"n\">convert</span><span class=\"p\">())</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 273918954,
        "sender_full_name": "Jubilee",
        "timestamp": 1646279974
    },
    {
        "content": "<p>Oh yeah, I meant to say that earlier</p>",
        "id": 273920019,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1646280737
    },
    {
        "content": "<p>It wasn't possible to make a generic implementation</p>",
        "id": 273920025,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1646280750
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/portable-simd/pull/251\">https://github.com/rust-lang/portable-simd/pull/251</a> Fortunately this still works.</p>",
        "id": 273921262,
        "sender_full_name": "Jubilee",
        "timestamp": 1646281878
    },
    {
        "content": "<p>And when it's a bitmask it's a no-op, so</p>",
        "id": 273921270,
        "sender_full_name": "Jubilee",
        "timestamp": 1646281899
    },
    {
        "content": "<p>I guess I don't understand why the generic bounds can't be specified with Into</p>",
        "id": 273921379,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1646282034
    },
    {
        "content": "<p>hmm</p>",
        "id": 273921421,
        "sender_full_name": "Jubilee",
        "timestamp": 1646282056
    },
    {
        "content": "<p><code>Mask&lt;u64, N&gt;: Into&lt;Mask&lt;T::Mask, N&gt;&gt;</code></p>",
        "id": 273921454,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1646282108
    },
    {
        "content": "<p>Something along those lines</p>",
        "id": 273921457,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1646282113
    },
    {
        "content": "<p>i think the idea is users want to get out of having to specify 7 dozen trait bounds everywhere, the new method lets us get away with just the <code>T: MaskElement</code> one</p>",
        "id": 273921648,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1646282302
    },
    {
        "content": "<p>yeah, the issue is satisfying</p>\n<blockquote>\n<p>error[E0277]: the trait bound <code>std::simd::Mask&lt;i64, 8_usize&gt;: From&lt;std::simd::Mask&lt;&lt;T as SimdElement&gt;::Mask, 8_usize&gt;&gt;</code> is not satisfied</p>\n</blockquote>",
        "id": 273921705,
        "sender_full_name": "Jubilee",
        "timestamp": 1646282359
    },
    {
        "content": "<p>Imo that's like saying we just add an <code>add</code> function to the vector because you don't want to use an Add trait bound</p>",
        "id": 273921850,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1646282459
    },
    {
        "content": "<p>I think reducing the bounds is a problem to be solved later, along with for scalars</p>",
        "id": 273921870,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1646282479
    },
    {
        "content": "<p>That's the point of num-traits and I think we can put it off here, too</p>",
        "id": 273921970,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1646282543
    },
    {
        "content": "<p>Basically I'm not convinced that <code>Into</code> isn't the correct way to do it</p>",
        "id": 273921986,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1646282566
    },
    {
        "content": "<p>num-traits sucks though.</p>",
        "id": 273922162,
        "sender_full_name": "Jubilee",
        "timestamp": 1646282783
    },
    {
        "content": "<p>it creates a giant ergonomic pitfall and everyone is just gonna describe this function anyways</p>",
        "id": 273922178,
        "sender_full_name": "Jubilee",
        "timestamp": 1646282813
    },
    {
        "content": "<p>Minimum I would say <code>cast</code> isn't the right word for this</p>",
        "id": 273923326,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1646283758
    },
    {
        "content": "<p>Well okay.</p>",
        "id": 273923346,
        "sender_full_name": "Jubilee",
        "timestamp": 1646283789
    },
    {
        "content": "<p>retype?</p>",
        "id": 273923365,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1646283813
    },
    {
        "content": "<p>I'm not saying we literally need to implement num-traits identically, I'm just saying this is certainly what Into is for</p>",
        "id": 273923368,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1646283816
    },
    {
        "content": "<p>have an inherent <code>into</code> function?</p>",
        "id": 273923421,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1646283846
    },
    {
        "content": "<p>Lol, that's not what I meant</p>",
        "id": 273923438,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1646283869
    },
    {
        "content": "<p>yeah...i got that</p>",
        "id": 273923445,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1646283885
    },
    {
        "content": "<p>I just meant that Into exists as a trait because then you can use it as a trait</p>",
        "id": 273923448,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1646283889
    },
    {
        "content": "<p>i meant as a suggestion for what to rename <code>Mask::cast</code> to</p>",
        "id": 273923469,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1646283921
    },
    {
        "content": "<p>I mean I am not sure how you are going to impl Into without that also conflicting.</p>",
        "id": 273923544,
        "sender_full_name": "Jubilee",
        "timestamp": 1646283990
    },
    {
        "content": "<p>because</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">note</span>: <span class=\"nc\">conflicting</span><span class=\"w\"> </span><span class=\"n\">implementation</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"k\">crate</span><span class=\"w\"> </span><span class=\"err\">`</span><span class=\"n\">core</span><span class=\"err\">`</span>:\n            <span class=\"o\">-</span><span class=\"w\"> </span><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"nb\">Into</span><span class=\"o\">&lt;</span><span class=\"n\">U</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"></span>\n<span class=\"w\">              </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"n\">U</span>: <span class=\"nb\">From</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 273923546,
        "sender_full_name": "Jubilee",
        "timestamp": 1646284006
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">LANES</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Mask</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">LANES</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">T</span>: <span class=\"nc\">MaskElement</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">LaneCount</span><span class=\"o\">&lt;</span><span class=\"n\">LANES</span><span class=\"o\">&gt;</span>: <span class=\"nc\">SupportedLaneCount</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">into</span><span class=\"o\">&lt;</span><span class=\"n\">U</span>: <span class=\"nc\">MaskElement</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Mask</span><span class=\"o\">&lt;</span><span class=\"n\">U</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">LANES</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">Mask</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"mf\">0.</span><span class=\"n\">convert</span><span class=\"p\">())</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 273923968,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1646284394
    },
    {
        "content": "<p>i don't know that naming it <code>into</code> is the best idea though...</p>",
        "id": 273924038,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1646284465
    },
    {
        "content": "<p>resize?</p>",
        "id": 273924075,
        "sender_full_name": "Jubilee",
        "timestamp": 1646284522
    },
    {
        "content": "<p>sounds like the length changes...</p>",
        "id": 273924086,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1646284547
    },
    {
        "content": "<p>on the bit level, I suppose.</p>",
        "id": 273924135,
        "sender_full_name": "Jubilee",
        "timestamp": 1646284567
    },
    {
        "content": "<p>yeah, i meant it's confusing because it sounds like the lane count changes rather than the lane type</p>",
        "id": 273924160,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1646284610
    },
    {
        "content": "<p><a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=8f471f3efa134d06426bec6abb257b87\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=8f471f3efa134d06426bec6abb257b87</a></p>",
        "id": 273924338,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1646284797
    },
    {
        "content": "<p>Two different cases of using a generic mask with a particular mask</p>",
        "id": 273924385,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1646284810
    },
    {
        "content": "<p>I really don't think it's a big deal just using <code>Into</code></p>",
        "id": 273924395,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1646284817
    }
]