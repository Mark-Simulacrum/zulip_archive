[
    {
        "content": "<p>So, I've been thinking more about masks and something hasn't been sitting quite right with me.  We took the <code>m8</code> etc types by default from packed_simd, but maybe they shouldn't exist at all?  I couldn't find a compelling reason why <code>m8x8</code> should implement <code>AsRef&lt;[m8]&gt;</code> rather than just provide functions for converting to and from <code>u8x8</code> in addition to the <code>set</code> and <code>test</code> functions that all masks have.</p>",
        "id": 218943663,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607188201
    },
    {
        "content": "<p>I think this would simplify the interface quite a bit.  All of the scalar mask types can be removed, and the full width and single bit width masks would have identical interfaces, except they would have different conversion functions/trait implementations.</p>",
        "id": 218943724,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607188292
    },
    {
        "content": "<p>If for some reason you absolutely need to mutate the mask vector by slice rather than with the <code>set</code> function it would require unsafe or an additional check, but I really don't see why you would need to insist on using a slice in the first place.</p>",
        "id": 218943839,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607188447
    },
    {
        "content": "<p>Anyone have any thoughts?</p>",
        "id": 218943851,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607188479
    },
    {
        "content": "<p>Yeah, that sounds good. Any way to make masks do less means that it's also easier to figure out what they can be used for.</p>",
        "id": 218965436,
        "sender_full_name": "Lokathor",
        "timestamp": 1607223098
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"312331\">@Caleb Zulawski</span> This sounds good to me so far since it simplifies everything. Sounds pretty different from where stdsimd#44 is at right now though. Should we start with a new PR or merge stdsimd#44 for now and then build that PR on top of master?</p>",
        "id": 219032551,
        "sender_full_name": "Jubilee",
        "timestamp": 1607301706
    },
    {
        "content": "<p>I rebased my const generic branch off of that PR so we can just hold off and review the final product</p>",
        "id": 219032613,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607301784
    },
    {
        "content": "<p>It'll probably be a pretty significant reduction in API between the const generics and removing the extra mask types</p>",
        "id": 219032671,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607301870
    },
    {
        "content": "<p>(and therefore hopefully easier to review?)</p>",
        "id": 219032673,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607301893
    },
    {
        "content": "<p>hopefully!</p>",
        "id": 219159678,
        "sender_full_name": "Jubilee",
        "timestamp": 1607389272
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"229517\">@Jacob Lifshay</span> what types of registers do the RISC-V masks use?  And can you have more than say 128 lanes?  I'm trying to figure out the appropriate datatype for the single bit masks (most compilers seem to just use plain integers for AVX-512's masks)</p>",
        "id": 219162124,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607391844
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"312331\">@Caleb Zulawski</span>  <a href=\"https://github.com/riscv/riscv-v-spec/blob/master/v-spec.adoc\">https://github.com/riscv/riscv-v-spec/blob/master/v-spec.adoc</a></p>\n<blockquote>\n<p>A vector mask occupies only one vector register regardless of SEW and LMUL. Each element is allocated a single mask bit in a mask vector register.</p>\n</blockquote>\n<blockquote>\n<p>Comparison operations that set a mask register are also implicitly a narrowing operation.</p>\n</blockquote>",
        "id": 219166875,
        "sender_full_name": "Jubilee",
        "timestamp": 1607397170
    },
    {
        "content": "<p>Oh interesting</p>",
        "id": 219167381,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607397726
    },
    {
        "content": "<p>Okay that confirms my suspicions though. They can be extremely wide</p>",
        "id": 219167388,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607397743
    },
    {
        "content": "<p>VLEN = 2^N where N &gt;= 7.<br>\nELEN = 2^N where N &gt;= 3.</p>\n<p>XLEN must fit this value: The XLEN-bit-wide read-only CSR vlenb holds the value VLEN/8, i.e., the vector register length in bytes.</p>\n<blockquote>\n<p>In base V extension, only data elements widths up to max(XLEN,FLEN) must be supported.</p>\n</blockquote>\n<blockquote>\n<p>In base V extension, only index widths up to XLEN must be supported.</p>\n</blockquote>\n<blockquote>\n<p>RV128 will require index EEW of 128.</p>\n</blockquote>",
        "id": 219167667,
        "sender_full_name": "Jubilee",
        "timestamp": 1607398151
    },
    {
        "content": "<p>I'm... confused</p>",
        "id": 219167994,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607398647
    },
    {
        "content": "<p>...sorry, was trying to see if I could take enough notes that I could easily pin down a fatness for mask lengths without pulling out a full-blown SAT solver, heh.</p>",
        "id": 219168074,
        "sender_full_name": "Jubilee",
        "timestamp": 1607398758
    },
    {
        "content": "<p>Lol</p>",
        "id": 219168084,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607398796
    },
    {
        "content": "<p>If a mask is a whole vector register that's a little different than the AVX mask registers which are small</p>",
        "id": 219168156,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607398870
    },
    {
        "content": "<p>Though I wonder if LLVM would optimize to the same thing regardless of memory layout</p>",
        "id": 219168172,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607398902
    },
    {
        "content": "<p>It would actually be much better code if we could just say the masks take a whole vector register even on AVX512</p>",
        "id": 219168218,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607398933
    },
    {
        "content": "<p>And leave the upper bits 0</p>",
        "id": 219168236,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607398955
    },
    {
        "content": "<p>I mean... why not?</p>",
        "id": 219268259,
        "sender_full_name": "Jubilee",
        "timestamp": 1607464409
    },
    {
        "content": "<p>Also this actually implicitly says something about RISCVV that I didn't notice before!</p>",
        "id": 219268386,
        "sender_full_name": "Jubilee",
        "timestamp": 1607464461
    },
    {
        "content": "<p>a vector mask must fit in a vector register, so you can't mask anything bigger than VLEN, so you <em>cannot</em> have  more than VLEN elements in a vector and also do a masking operation which means <em>in practice</em> VLEN is a cap on vector element count.</p>",
        "id": 219268496,
        "sender_full_name": "Jubilee",
        "timestamp": 1607464534
    },
    {
        "content": "<p>So maybe I'm confused, but since you can't have an element smaller than 1 bit, isn't that a given?</p>",
        "id": 219271093,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607465935
    },
    {
        "content": "<p>Or is vlen simply a _minimum_ vector length?</p>",
        "id": 219271156,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607465971
    },
    {
        "content": "<p>(one of these days I'll learn how zulip formatting works...)</p>",
        "id": 219271187,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607465993
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"312331\">@Caleb Zulawski</span> well the entire point of RISCV-V's design is it lets you have \"vectors\" that occupy multiple vector registers, so that the code can be relatively hardware-agnostic. I  don't fully understand all the details yet.</p>",
        "id": 219271361,
        "sender_full_name": "Jubilee",
        "timestamp": 1607466070
    },
    {
        "content": "<p>What I was suggesting is that typical avx512 implementations use say i16 for __mmask16, but we may be able to avoid a slew of issues by using u8x16, even if it's wasteful</p>",
        "id": 219271484,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607466133
    },
    {
        "content": "<p>(and hope that the optimizer chooses to ignore the wasted bits)</p>",
        "id": 219271512,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607466152
    },
    {
        "content": "<p>This is at least partially motivated by const generics</p>",
        "id": 219271565,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607466193
    },
    {
        "content": "<p>what kind of issues are we avoiding? but after our experiences so far I am definitely very game for \"pray to LLVM-kun to optimize our code correctly\".</p>",
        "id": 219272017,
        "sender_full_name": "Jubilee",
        "timestamp": 1607466426
    },
    {
        "content": "<p>So one that's not const generic specific is layout</p>",
        "id": 219272048,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607466455
    },
    {
        "content": "<p>It's probably not meaningful but it would be very convenient if they were the same type</p>",
        "id": 219272117,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607466486
    },
    {
        "content": "<p>The two types of masks</p>",
        "id": 219272124,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607466492
    },
    {
        "content": "<p>Another thing is that for avx512 the masks don't need to be repr(simd) but for other architectures they probably do. So might as well make them all repr(simd)</p>",
        "id": 219272194,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607466542
    },
    {
        "content": "<p>Yeah, that constraint is on us anyways.</p>",
        "id": 219272250,
        "sender_full_name": "Jubilee",
        "timestamp": 1607466585
    },
    {
        "content": "<p>The const generic issue is extremely frustrating, though</p>",
        "id": 219272325,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607466619
    },
    {
        "content": "<p>So</p>",
        "id": 219272329,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607466622
    },
    {
        "content": "<p>You can do this just fine:</p>\n<div class=\"codehilite\"><pre><span></span><code>#[repr(simd)]\npub struct SimdU8&lt;const LANES: usize&gt;([u8; LANES]);\n</code></pre></div>",
        "id": 219272371,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607466661
    },
    {
        "content": "<p>But to make a bitmask you need to do this:</p>\n<div class=\"codehilite\"><pre><span></span><code>#[repr(simd)]\npub struct SimdBitMask&lt;const LANES: usize&gt;([u8; (LANES + 7) / 8]) where [(); (LANES + 7) / 8]: Sized;\n</code></pre></div>",
        "id": 219272530,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607466747
    },
    {
        "content": "<p>...lol.</p>",
        "id": 219272576,
        "sender_full_name": "Jubilee",
        "timestamp": 1607466774
    },
    {
        "content": "<p>Supposedly the bound syntax will be cleaned up at some point (once const generic bounds become a thing)</p>",
        "id": 219272581,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607466778
    },
    {
        "content": "<p>But regardless, you have a bound because it basically needs to ensure that your anonymous const actually evaluates and doesn't overflow or something</p>",
        "id": 219272630,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607466801
    },
    {
        "content": "<p>You can of course make the variable the number of bytes instead of the number of lanes, but that just moves the bound to somewhere else</p>",
        "id": 219272675,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607466837
    },
    {
        "content": "<p>right.</p>",
        "id": 219272716,
        "sender_full_name": "Jubilee",
        "timestamp": 1607466853
    },
    {
        "content": "<p>unfortunately that would mean our \"opaque\" mask type would also have the bound on it</p>",
        "id": 219272745,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607466874
    },
    {
        "content": "<p>I think if the situation ever improved in the future we would reserve the right to change the layout and remove the extra bytes</p>",
        "id": 219272793,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607466918
    },
    {
        "content": "<p>and that bound would infect everywhere it is used</p>",
        "id": 219272797,
        "sender_full_name": "Jubilee",
        "timestamp": 1607466920
    },
    {
        "content": "<p>yep.</p>",
        "id": 219272801,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607466924
    },
    {
        "content": "<p>can we type alias that bound by any chance</p>",
        "id": 219272839,
        "sender_full_name": "Jubilee",
        "timestamp": 1607466959
    },
    {
        "content": "<p>bound alias</p>",
        "id": 219272885,
        "sender_full_name": "Jubilee",
        "timestamp": 1607466969
    },
    {
        "content": "<p>yeah, you can do</p>",
        "id": 219272890,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607466974
    },
    {
        "content": "<p>traitify it</p>",
        "id": 219272892,
        "sender_full_name": "Jubilee",
        "timestamp": 1607466974
    },
    {
        "content": "<p>aha.</p>",
        "id": 219272898,
        "sender_full_name": "Jubilee",
        "timestamp": 1607466978
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>const fn valid_lanes(lanes: usize) { (lanes + 7 / 8) }\nstruct SimdBitmask&lt;const LANES: usize&gt;([u8; valid_lanes(LANES)]) where [(); valid_lanes(LANES)]: Sized;\n</code></pre></div>",
        "id": 219273069,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607467078
    },
    {
        "content": "<p>maybe something slightly better than that</p>",
        "id": 219273148,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607467109
    },
    {
        "content": "<p>but i'm not thrilled about</p>\n<ul>\n<li>such a hacky bound</li>\n<li>having a bound at all</li>\n</ul>",
        "id": 219273177,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607467130
    },
    {
        "content": "<p>mhm...</p>",
        "id": 219273229,
        "sender_full_name": "Jubilee",
        "timestamp": 1607467167
    },
    {
        "content": "<p>Maybe we need a language extension of some sort (which would be unfortunate) but this is basically C++'s <code>std::bitset</code></p>",
        "id": 219273239,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607467178
    },
    {
        "content": "<p>Not sure if it's even possible, but this would also be solved with a <code>u1</code> type that was allowed to pack sub-byte-width <span aria-label=\"smiling devil\" class=\"emoji emoji-1f608\" role=\"img\" title=\"smiling devil\">:smiling_devil:</span></p>",
        "id": 219273694,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607467453
    },
    {
        "content": "<p>so <a href=\"https://crates.io/crates/bitvec\">https://crates.io/crates/bitvec</a></p>",
        "id": 219273810,
        "sender_full_name": "Jubilee",
        "timestamp": 1607467559
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"312331\">@Caleb Zulawski</span>  I believe imposing a bound of either usize or VLEN on masks is fine for the condition of shipping core::simd on nightly. I believe we won't find a good answer for this problem before we get our code into nightly.</p>",
        "id": 219274336,
        "sender_full_name": "Jubilee",
        "timestamp": 1607467918
    },
    {
        "content": "<p>( using VLEN the same way RISCV-V does, here... as the actual size of a vector register's state. )</p>",
        "id": 219274502,
        "sender_full_name": "Jubilee",
        "timestamp": 1607468036
    },
    {
        "content": "<p>Yeah, just like bitvec, except I think that would have the same problems with bounds as we're seeing here</p>",
        "id": 219274949,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607468312
    },
    {
        "content": "<p>So we can impose a bound by making separate types for each bit width, but I'm still not sure that's what we want</p>",
        "id": 219275016,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607468375
    },
    {
        "content": "<p>It would be nice if we could somehow prove to the compiler our const fn will never fail so the bound can be removed</p>",
        "id": 219275115,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607468411
    },
    {
        "content": "<p>yeah, basically my feeling is we should just do whatever ships right now and then punt this to a discussion with the const generics folks about how to make it happen.</p>",
        "id": 219275333,
        "sender_full_name": "Jubilee",
        "timestamp": 1607468561
    },
    {
        "content": "<p>That would be skipping bit masks <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 219275387,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607468599
    },
    {
        "content": "<p>Which is probably fine</p>",
        "id": 219275394,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607468604
    },
    {
        "content": "<p>I agree we should probably bring it up with them</p>",
        "id": 219275473,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607468648
    },
    {
        "content": "<p>Fine With Me, right now!<br>\nI was previously anxious about deprioritizing things too early but I don't think that's actually a concern anymore.</p>",
        "id": 219275638,
        "sender_full_name": "Jubilee",
        "timestamp": 1607468774
    },
    {
        "content": "<p>I think as long as we address them and don't rule them out we're in good shape</p>",
        "id": 219275692,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607468825
    },
    {
        "content": "<p>So I realized something potentially evil we can do.  Should we extend #[repr(simd)] to support i1xN vectors?  I think we can make the argument that i1 is much more relevant in SIMD than elsewhere so it doesn't need a broader implementation</p>",
        "id": 219395793,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607547049
    },
    {
        "content": "<p>There's <a href=\"https://github.com/rust-lang/rfcs/pull/2581#issuecomment-439966415\">some level of lang support for more integer widths</a>, so it might not be all that evil.</p>",
        "id": 219397707,
        "sender_full_name": "scottmcm",
        "timestamp": 1607547935
    },
    {
        "content": "<p>Maybe I'm wrong, but that comment seems to indicate there isn't any support yet?</p>",
        "id": 219400461,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607549179
    },
    {
        "content": "<p>Not for that RFC as-is, but in a vague sense of \"it doesn't need to just be library; there can be language semantic changes from these things too\"</p>",
        "id": 219403007,
        "sender_full_name": "scottmcm",
        "timestamp": 1607550318
    },
    {
        "content": "<p>Though I guess you might be able to get pretty far with <code>#[repr(u8)] enum Mask { Zero = 0, All = 0xFF }</code> or whatever...</p>",
        "id": 219403142,
        "sender_full_name": "scottmcm",
        "timestamp": 1607550371
    },
    {
        "content": "<p><code>i1xN</code> sounds like a good plan to me! If we do it right, we could have:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">i1</span><span class=\"p\">(</span><span class=\"kt\">bool</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n<p>where <code>#[repr(simd)]</code> treats <code>i1</code> specially, changing the layout to a bit-vector such that you can read or write array elements but can't take their address. when not in <code>#[repr(simd)]</code>, <code>i1</code> is otherwise a normal struct most likely with <code>bool</code>'s layout.</p>",
        "id": 219412600,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1607555015
    },
    {
        "content": "<p>this should be compatible with future bitfields support, assuming those need a <code>#[repr(bitpacked)]</code> or similar.</p>",
        "id": 219412755,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1607555122
    },
    {
        "content": "<p>if there's a future <code>i1</code> built-in integer type, that would replace the <code>struct i1</code> type.</p>",
        "id": 219413106,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1607555319
    },
    {
        "content": "<p><code>#[repr(simd)]</code> could also directly handle <code>bool</code> as <code>i1</code>.</p>",
        "id": 219414101,
        "sender_full_name": "bjorn3",
        "timestamp": 1607556015
    },
    {
        "content": "<p>Yeah, that's more along the lines of what I was thinking of, since it doesn't require significant changes</p>",
        "id": 219415247,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607556961
    },
    {
        "content": "<p>A problem I see, though, is you couldn't really access the fields and would probably require a lot of special casing that</p>",
        "id": 219415355,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607557042
    },
    {
        "content": "<p>If we do support bitmasks using:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[derive(Copy, Clone)]</span><span class=\"w\"></span>\n<span class=\"cp\">#[repr(simd)]</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">i1x8</span><span class=\"p\">([</span><span class=\"kt\">bool</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"p\">]);</span><span class=\"w\"></span>\n</code></pre></div>\n<p>I would expect the compiler to gain support (perhaps using simd intrinsics instead) for:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">b</span>: <span class=\"kt\">bool</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">ba</span>: <span class=\"p\">[</span><span class=\"kt\">bool</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">bv</span>: <span class=\"nc\">i1x8</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">i</span>: <span class=\"kt\">usize</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.;</span><span class=\"w\"></span>\n<span class=\"n\">bv</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">i1x8</span><span class=\"p\">(</span><span class=\"n\">ba</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// convert to bit-vector</span>\n<span class=\"n\">bv</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">i1x8</span><span class=\"p\">([</span><span class=\"n\">b</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"p\">]);</span><span class=\"w\"> </span><span class=\"c1\">// splat (can fall back to convert to bit-vector)</span>\n<span class=\"n\">ba</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">bv</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// convert from bit-vector</span>\n<span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">bv</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">];</span><span class=\"w\"> </span><span class=\"c1\">// read element</span>\n<span class=\"n\">bv</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// write element</span>\n</code></pre></div>\n<p>All fallback implementations of mask ops can be implemented in terms of those ops.</p>",
        "id": 219419157,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1607560167
    },
    {
        "content": "<p>in <a href=\"#narrow/stream/260443-project-const-generics/topic/const_evaluatable_checked.20bound.20repetition\">https://rust-lang.zulipchat.com/#narrow/stream/260443-project-const-generics/topic/const_evaluatable_checked.20bound.20repetition</a> i mentioned the issue around the bounds in const_evaluable_checked being an abstraction leak in annoying ways.</p>\n<p>also the issue with i1 was terrible codegen universally as soon as everything stopped being inlined (because the compiler will spill it to an actual bool array, which isn't how anything works)</p>",
        "id": 219427549,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1607569778
    },
    {
        "content": "<p>#[repr(simd)] may fix that because it passes things by reference. We may also be able to explicitly cast it so it's packed</p>",
        "id": 219427740,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607570071
    },
    {
        "content": "<p>heh, should I link lcnr to <a href=\"https://github.com/rust-lang/stdsimd/issues/50\">https://github.com/rust-lang/stdsimd/issues/50</a> there, then?</p>",
        "id": 219427750,
        "sender_full_name": "Jubilee",
        "timestamp": 1607570102
    },
    {
        "content": "<p>Maybe lol</p>",
        "id": 219427852,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607570240
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"312331\">@Caleb Zulawski</span> not sure why passing things by reference would make any difference at all here... That actually sounds much worse. The issue is that the vector types can't stay abstract forever. At the end of the day llvm/rustc needs to know what they layout of these masks are in situations like when they're in memory/on the stack, or passed/returned via from/to a function which the def can't be seen... and with &lt;i1 x N&gt;  the answer is \"it's basically a complete disaster\".</p>",
        "id": 219428006,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1607570452
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"209168\">@Thom Chiovoloni</span> looking at some llvm bugs, the problem only seems to really come up when using GEP?  We will need to make sure to do actual bit accesses on packed vectors. Which maybe means we should store them as u8 arrays in rust but lower the simd ops to i1 with bitcast (and definitely don't use GEP!)</p>",
        "id": 219428302,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607570867
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"312331\">@Caleb Zulawski</span> the example from the last time we had this debate was <a href=\"https://gcc.godbolt.org/z/qbEzv5\">https://gcc.godbolt.org/z/qbEzv5</a>. I don't even really think it's an LLVM bug. This is exactly what I'd expect LLVM (or any compiler backend) to do here.</p>",
        "id": 219428383,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1607571000
    },
    {
        "content": "<p>recur(\"aw shit here we go again\")</p>",
        "id": 219428504,
        "sender_full_name": "Jubilee",
        "timestamp": 1607571126
    },
    {
        "content": "<p>Ok. I remember this example.  So I don't think it's quite the same debate as we were having before.  Before we were discussing whether we could always use the i1 type, I think</p>",
        "id": 219428596,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607571248
    },
    {
        "content": "<p>note that that example is just as bad on every arch, and what you should be looking at is the difference between <code>f_sse_inlined</code> and everything else. basically, going from an <code>&lt;i1 x N&gt;</code> to the actual mask type needed for any intrinsics a very difficult operation.</p>\n<p>If we could convince LLVM to that the concrete representation of <code>&lt;i1 x N&gt;</code> (when one is needed) should actually be something other than <code>[bool; N]</code> that'd be one thing, but I don't expect that to be feasible for many reasons. For one, the right representations for most current vector ISAs will depend on what produces/consumes the mask — that's why there's both <code>N</code> and <code>M</code> in <code>mNxM</code>.</p>",
        "id": 219428625,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1607571353
    },
    {
        "content": "<p>Hmm, I see the difference here. Just... please don't go with a  design that is clean but compiles to terrible code on common arches as soon as the program becomes too big for the compiler to see all at once.</p>",
        "id": 219428755,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1607571548
    },
    {
        "content": "<p>I wouldn't want to do anything that compiles to absolute garbage, but I want to at least see the tradeoffs of different things, and those tradeoffs are a bit less clear at the current moment.</p>",
        "id": 219428830,
        "sender_full_name": "Jubilee",
        "timestamp": 1607571643
    },
    {
        "content": "<p>So, I'm both bad at LLVM IR and ASM, but this looks to me like it's correct? <a href=\"https://gcc.godbolt.org/z/M4Eqrh\">https://gcc.godbolt.org/z/M4Eqrh</a></p>",
        "id": 219428858,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607571696
    },
    {
        "content": "<p>I'm just hazarding a guess based on all of the <code>bfi</code> and <code>ubfx</code> instructions that it's unpacking it to a NEON vector</p>",
        "id": 219428923,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607571765
    },
    {
        "content": "<p>This is actually part of the reason why I suggested <code>#[repr(simd)]</code> may resolve the problem because then the return type isn't actually a vector, it's a reference to a vector, and I'm guessing i1 doesn't play nice with calling conventions for some reason</p>",
        "id": 219429088,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607571991
    },
    {
        "content": "<p>The reason you're getting tons of junk code is because you're trying to use bitvectors on an ISA that doesn't use bitvectors as the mask type, if you switch it to an ISA that does use bitvectors, the code generation is perfectly fine: <a href=\"https://gcc.godbolt.org/z/6jfPT8\">https://gcc.godbolt.org/z/6jfPT8</a></p>",
        "id": 219429481,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1607572549
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"229517\">@Jacob Lifshay</span> I'm aware of that, that's not the issue I think (the bit vectors should still work on any ISA).  The issue is that Thom's example uses 1 byte per vector element, but mine fixes that and correctly packs them</p>",
        "id": 219429599,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607572687
    },
    {
        "content": "<p>I think we shouldn't be too worried about the code quality when we tell the compiler \"I want bitvectors! I don't care, give me bitvectors anyway!\", because that's exactly what's happening when we use <code>i1x8</code> instead of <code>m8x8</code> or <code>m32x8</code></p>",
        "id": 219429628,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1607572736
    },
    {
        "content": "<p>since the <code>m8x8</code> type is supposed to compile at the rustc level to the optimal mask representation for our ISA.</p>",
        "id": 219429648,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1607572782
    },
    {
        "content": "<p>The issue isn't code quality, it was that it was actually using an incorrect in-memory representation</p>",
        "id": 219429650,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607572783
    },
    {
        "content": "<p>However your example shows that yes, the code quality will definitely be much better when bit vectors are actually supported directly :)</p>",
        "id": 219429731,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607572849
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"229517\">Jacob Lifshay</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/Mask.20API/near/219429481\">said</a>:</p>\n<blockquote>\n<p>The reason you're getting tons of junk code is because you're trying to use bitvectors on an ISA that doesn't use bitvectors as the mask type, if you switch it to an ISA that does use bitvectors, the code generation is perfectly fine: <a href=\"https://gcc.godbolt.org/z/6jfPT8\">https://gcc.godbolt.org/z/6jfPT8</a></p>\n</blockquote>\n<p>Uh, that's still terrible, though.</p>",
        "id": 219429811,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1607572929
    },
    {
        "content": "<p>Hmm, it looked fine to me, though I didn't read it too closely. Note that if LLVM spills something to memory, it can use any arbitrary type it chooses, it doesn't have to be the exact type we asked for originally, since it could be spilling the temporary part-way through conversion, or something similar</p>",
        "id": 219429812,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1607572930
    },
    {
        "content": "<p>Yeah, I think it looks ok to me.  Isn't that the best you're going to get without inlining?</p>",
        "id": 219429948,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607573123
    },
    {
        "content": "<p>Yeah, I'd expect so</p>",
        "id": 219429961,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1607573140
    },
    {
        "content": "<p>most of the stuff is required by the ABI</p>",
        "id": 219429971,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1607573156
    },
    {
        "content": "<p>That's by no means perfectly fine — <code>f_sse</code> and <code>f_sse_inlined</code> only differ by whether or not the comparison is inlined. it's not as terrible as on arm, but I'd still consider that a disaster honestly.</p>\n<p>It's certainly not even close to what you'd write with manual intrinsics (even if the function isn't inlined), or what we'd have if the code didn't use bitvectors for masks</p>",
        "id": 219430031,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1607573179
    },
    {
        "content": "<p>most of the code is required since none of the <code>zmm</code> registers are callee-save requiring the spills and since masks are apparently treated as integers, requiring passing through <code>eax</code></p>",
        "id": 219430085,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1607573278
    },
    {
        "content": "<p>So, I'd expect it to be almost exactly what you'd get using intrinsics.</p>",
        "id": 219430139,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1607573307
    },
    {
        "content": "<blockquote>\n<p>and since masks are apparently treated as integers, requiring passing through eax</p>\n</blockquote>\n<p>I suspect this means you'd probably stick with vector masks rather than bit masks for this, then</p>",
        "id": 219430207,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1607573398
    },
    {
        "content": "<p>If you're forcing it to come in from an uninlined function, yeah probably</p>",
        "id": 219430304,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607573469
    },
    {
        "content": "<p>idk, maybe? depends on how much power full masks take over bitmasks, that may cause downclocking.</p>",
        "id": 219430305,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1607573470
    },
    {
        "content": "<p>I do also think this example is extremely contrived.  It does prove that the bit vector masks work in both inlined and non-inlined code!</p>",
        "id": 219430381,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607573525
    },
    {
        "content": "<p>This calling convention also doesn't match <code>#[repr(simd)]</code>'s so I don't think it's worth really nitpicking it</p>",
        "id": 219430392,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607573570
    },
    {
        "content": "<p>With the mask vector passed by reference rather than value I'm not sure that it would need to pass through <code>eax</code> like this example</p>",
        "id": 219430465,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607573662
    },
    {
        "content": "<p>(also I think the non-inlined code will be inherently worse because of that calling convention, but it's a necessary evil)</p>",
        "id": 219430493,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607573725
    },
    {
        "content": "<p>I'd expect that calling convention to match <code>#[repr(simd)] struct i1x8([bool; 8]);</code> since rustc would translate that to LLVM's <code>&lt;8 x i1&gt;</code> so we'd get the exact same code.</p>",
        "id": 219430502,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1607573752
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/Mask.20API/near/219430465\">said</a>:</p>\n<blockquote>\n<p>With the mask vector passed by reference rather than value I'm not sure that it would need to pass through <code>eax</code> like this example</p>\n</blockquote>\n<p>passing through <code>eax</code> is almost certainly faster than passing through memory.</p>",
        "id": 219430561,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1607573805
    },
    {
        "content": "<p><code>#[repr(simd)]</code> forces the type to be passed by reference even if it's slower</p>",
        "id": 219430577,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607573846
    },
    {
        "content": "<p>until rustc's gains support for pass simd by value, you mean</p>",
        "id": 219430590,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1607573880
    },
    {
        "content": "<p>I would expect the calling convention to match <code>#[repr(simd)] struct i1x8(u8)</code> at least</p>",
        "id": 219430632,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607573894
    },
    {
        "content": "<p>If the code for bitmasks is known to be pretty bad if it requires actually calling a function (which I think is something we should expect to be frequent), then is it worth the substantial increase in the API surface required by supporting the the bitmasks in addition to the other masks? in fully inlined cases it seems likely that the compiler would use the optimal thing anywya, so the whole point of these was to be a win in non-inlined cases, which they aren't.</p>",
        "id": 219430641,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1607573913
    },
    {
        "content": "<p>yeah. is that ever planned? I thought it cannot happen</p>",
        "id": 219430644,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607573914
    },
    {
        "content": "<p>bit vector masks are necessary because they're the only mask type on some architectures</p>",
        "id": 219430656,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607573949
    },
    {
        "content": "<p>they will absolutely not be the default on x86-64 though, you will need to opt into a trait to gain access to them</p>",
        "id": 219430667,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607573975
    },
    {
        "content": "<p>Hm, okay.</p>",
        "id": 219430719,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1607574005
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/Mask.20API/near/219430641\">said</a>:</p>\n<blockquote>\n<p>If the code for bitmasks is known to be pretty bad if it requires actually calling a function (which I think is something we should expect to be frequent), then is it worth the substantial increase in the API surface required by supporting the the bitmasks in addition to the other masks? in fully inlined cases it seems likely that the compiler would use the optimal thing anywya, so the whole point of these was to be a win in non-inlined cases, which they aren't.</p>\n</blockquote>\n<p>I thought the whole point of the specifically bitmask API (rather than just the generic API) is that you can efficiently use bitmasks when you need them (rather than a for loop or something), not that bitmasks are always fastest.</p>",
        "id": 219430727,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1607574028
    },
    {
        "content": "<p>I don't think it had anything to do with non-inlined cases?  Other than that was clearly a buggy part of LLVM</p>",
        "id": 219430729,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607574030
    },
    {
        "content": "<p>Yeah.  There was some desire to use them with SSE for some table lookup tricks.  And there's definitely reasons to want to use them with AVX-512 sometimes as well</p>",
        "id": 219430742,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607574068
    },
    {
        "content": "<p>But the default will be \"full\" vector masks for most architectures, since they're better in most cases</p>",
        "id": 219430752,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607574109
    },
    {
        "content": "<p>maybe there could be a separate avx512 x86 target that uses bitvectors (since those are generally more efficient on avx512) instead of full vector masks? We'd probably also want that on OpenPower for SimpleV, since that also uses bitvectors.</p>",
        "id": 219430882,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1607574259
    },
    {
        "content": "<p>if there's a full separate target, you don't have issues with ABI incompatability</p>",
        "id": 219430896,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1607574293
    },
    {
        "content": "<p>yeah, on an avx512 target it would probably use them as well</p>",
        "id": 219430909,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607574326
    },
    {
        "content": "<p>we can use <code>#[cfg(target_feature)]</code> for that</p>",
        "id": 219430921,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607574353
    },
    {
        "content": "<p>ah, that might work better (though the layout of types depending on target features seems like a good way to accidentally shoot yourself in the foot)</p>",
        "id": 219430988,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1607574436
    },
    {
        "content": "<p>the \"opaque\" mask type explicitly has an unspecified layout</p>",
        "id": 219430993,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607574480
    },
    {
        "content": "<p>if you need a particular layout you can opt into the trait (or use <code>Into</code> on the opaque mask to ensure a particular layout)</p>",
        "id": 219431044,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607574524
    },
    {
        "content": "<p>yeah, though if it is de-facto defined, people will probably unintentionally depend on it.</p>",
        "id": 219431049,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1607574546
    },
    {
        "content": "<p>Maybe, but you can't screw that up without <code>unsafe</code>, and we're providing safe ways of doing it, so I think that's unsound</p>",
        "id": 219431062,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607574587
    },
    {
        "content": "<p>you can transmute a fat pointer but I don't think the layout is actually specified, even though it probably has never changed?</p>",
        "id": 219431114,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607574620
    },
    {
        "content": "<p>I was thinking more of how copying a <code>i1x32</code> is quite cheap, but a <code>m32x32</code> is waay more expensive.</p>",
        "id": 219431140,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1607574659
    },
    {
        "content": "<p>since it is 32x larger</p>",
        "id": 219431155,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1607574694
    },
    {
        "content": "<p>right but the rest of the ops will be way slower except on avx512 or risc-v or similar</p>",
        "id": 219431161,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607574719
    },
    {
        "content": "<p>I guess my point is we're going to pick the default to be what's usually the best, but provide access to both on all platforms so you can do whatever you need to do</p>",
        "id": 219431219,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607574767
    },
    {
        "content": "<p>yup, sounds good!</p>",
        "id": 219431227,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1607574785
    },
    {
        "content": "<p>I think we long ago admitted that you will absolutely be able to generate slow code, we're just trying to make it as easy as possible to make it fast</p>",
        "id": 219431251,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607574821
    },
    {
        "content": "<p>Any ideas why masks use signed integers rather than unsigned?  I figure u8 is probably the best type for bit vector masks, but not sure</p>",
        "id": 219543365,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607639468
    },
    {
        "content": "<p>i think because llvm internals are all signed ints</p>",
        "id": 219543527,
        "sender_full_name": "Lokathor",
        "timestamp": 1607639552
    },
    {
        "content": "<p>just a quirk</p>",
        "id": 219543542,
        "sender_full_name": "Lokathor",
        "timestamp": 1607639560
    },
    {
        "content": "<p>That seems reasonable</p>",
        "id": 219543577,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607639583
    },
    {
        "content": "<p>LLVM's integer types are neither signed nor unsigned; only the operators on them are.</p>",
        "id": 219545361,
        "sender_full_name": "scottmcm",
        "timestamp": 1607640754
    },
    {
        "content": "<p>An 8-bit mask that's either <code>00000000</code> or <code>11111111</code> is easier considered as signed so it's either <code>0</code> or <code>-1</code>, so that might be why they were used as signed.</p>",
        "id": 219545497,
        "sender_full_name": "scottmcm",
        "timestamp": 1607640845
    },
    {
        "content": "<p>bitmasks might be better as <code>u1xN</code> rather than <code>i1xN</code> since that matches <code>bool</code> better</p>",
        "id": 219550083,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1607644240
    },
    {
        "content": "<p>I think I determined yesterday it will almost definitely be implemented on top of u8 vectors since element alignment is unambiguous, and it gives a handy way of doing other ops</p>",
        "id": 219550210,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607644338
    },
    {
        "content": "<p>LLVM doesn't seem to like i1 vectors in function signatures</p>",
        "id": 219550326,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1607644446
    },
    {
        "content": "<p>I meant as the user-visible type</p>",
        "id": 219550998,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1607645032
    },
    {
        "content": "<p>The docs say that the layout of <code>Mask8</code> is unspecified. Why? Isn't it rather the point of having specified-lane-width mask types that their layout is specified?</p>",
        "id": 226106298,
        "sender_full_name": "Henri Sivonen",
        "timestamp": 1613116384
    },
    {
        "content": "<p>oh, I should really review the cargo doc output when doing code review.</p>",
        "id": 226112056,
        "sender_full_name": "Jubilee",
        "timestamp": 1613120757
    },
    {
        "content": "<p>The idea is that depending on architecture, a Mask8 might either be a SimdMask8 or a BitMask</p>",
        "id": 226137504,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613137219
    },
    {
        "content": "<p>wow. <a href=\"https://twitter.com/NikolaiVazquez/status/1361024473760153600\">https://twitter.com/NikolaiVazquez/status/1361024473760153600</a></p>\n<div class=\"inline-preview-twitter\"><div class=\"twitter-tweet\"><a href=\"https://twitter.com/NikolaiVazquez/status/1361024473760153600\"><img class=\"twitter-avatar\" src=\"https://pbs.twimg.com/profile_images/1240202107699040258/A-4ZSEfi_normal.jpg\"></a><p><a href=\"https://twitter.com/ekuber\">@ekuber</a> All that &lt;&lt;&lt;&lt; trait-dependent type sizes <a href=\"https://t.co/BbwSJARzNd\">https://github.com/nvzqz/impls#trait-dependent-type-sizes</a> <a href=\"https://t.co/NWDcx4PMj4\">https://twitter.com/NikolaiVazquez/status/1361024473760153600/photo/1</a></p><span>- nikolai (@NikolaiVazquez)</span><div class=\"twitter-image\"><a href=\"https://t.co/NWDcx4PMj4\"><img src=\"https://pbs.twimg.com/media/EuNUaegXYA4f_vC.png:small\"></a></div></div></div>",
        "id": 226320249,
        "sender_full_name": "Jubilee",
        "timestamp": 1613330507
    },
    {
        "content": "<p>Wow.  That's awesome and horrific at the same time.</p>",
        "id": 226320955,
        "sender_full_name": "scottmcm",
        "timestamp": 1613331565
    },
    {
        "content": "<p>yeah I can't read that rust <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 226324309,
        "sender_full_name": "Miguel Raz Guzmán Macedo",
        "timestamp": 1613336060
    },
    {
        "content": "<p>Too much ancient knowledge.</p>",
        "id": 226324315,
        "sender_full_name": "Miguel Raz Guzmán Macedo",
        "timestamp": 1613336077
    }
]