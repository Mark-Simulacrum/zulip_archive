[
    {
        "content": "<p>Right now, if someone looks at the docs, they see like a million versions of certain functions on <code>Simd&lt;T, L&gt;</code>. I have drafted the beginnings of a PR that offers a way out: <a href=\"https://github.com/rust-lang/portable-simd/pull/191\">https://github.com/rust-lang/portable-simd/pull/191</a></p>",
        "id": 261436620,
        "sender_full_name": "Jubilee",
        "timestamp": 1636921521
    },
    {
        "content": "<p>I'll have to take a closer look later, but this would require importing traits, correct?</p>",
        "id": 261436785,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636921710
    },
    {
        "content": "<p>No.</p>",
        "id": 261436793,
        "sender_full_name": "Jubilee",
        "timestamp": 1636921733
    },
    {
        "content": "<p>Works the same way Select does.</p>",
        "id": 261436799,
        "sender_full_name": "Jubilee",
        "timestamp": 1636921760
    },
    {
        "content": "<p>Oh gotcha. Yeah, I like that.  Take a look at how I did lanes_eq etc, there's also the option of putting marker traits on the scalar like that</p>",
        "id": 261436940,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636921943
    },
    {
        "content": "<p>Slight difference, but I think that might actually be preferable</p>",
        "id": 261436948,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636921969
    },
    {
        "content": "<p>Yeah, I will try to get rid of SimdSInt and just have SInt.</p>",
        "id": 261437023,
        "sender_full_name": "Jubilee",
        "timestamp": 1636922087
    },
    {
        "content": "<p>But the way I wound up muddling through last night with the type constraints, for some reason it worked more easily with SimdSInt still in play.</p>",
        "id": 261437046,
        "sender_full_name": "Jubilee",
        "timestamp": 1636922130
    },
    {
        "content": "<p>Makes sense</p>",
        "id": 261437051,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636922144
    },
    {
        "content": "<p>I think if we are doing marker traits on the scalars I might prefer doing them per-function, which would end up with more traits but also easier to extend in the future</p>",
        "id": 261437119,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636922232
    },
    {
        "content": "<p>Hm, so my thought was designing it around the category of type.</p>",
        "id": 261437182,
        "sender_full_name": "Jubilee",
        "timestamp": 1636922286
    },
    {
        "content": "<p>Yeah, my only concern with that is certain things may break that in the future</p>",
        "id": 261437191,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636922306
    },
    {
        "content": "<p>Hmm.</p>",
        "id": 261437193,
        "sender_full_name": "Jubilee",
        "timestamp": 1636922313
    },
    {
        "content": "<p>Like if we supported non-zero ints but we had a trait for all ints that already defined a <code>zero</code> fn, for example</p>",
        "id": 261437207,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636922347
    },
    {
        "content": "<p>Ah I see.</p>",
        "id": 261437216,
        "sender_full_name": "Jubilee",
        "timestamp": 1636922360
    },
    {
        "content": "<p>Instead we could implement Zero for all types except that, but implement Add for all of them</p>",
        "id": 261437232,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636922400
    },
    {
        "content": "<p>Something like that</p>",
        "id": 261437273,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636922407
    },
    {
        "content": "<p>It would be easy enough to make a crate that does categories on top of that if someone wants categories</p>",
        "id": 261437291,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636922442
    },
    {
        "content": "<p>I'm thinking we basically are implementing std::ops for simd</p>",
        "id": 261437367,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636922574
    },
    {
        "content": "<p>Yeah, I think we still want to incline towards natural categories somewhat but I understand what you mean now.</p>",
        "id": 261437373,
        "sender_full_name": "Jubilee",
        "timestamp": 1636922584
    },
    {
        "content": "<p>Yeah I think there's room for it in the future, but might be jumping the gun doing categories now (in std, I mean)</p>",
        "id": 261437387,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636922635
    },
    {
        "content": "<p>Maybe. I think it's an idea whose time has come at this point since, effectively, we now have this need to describe a scalar data type in a way that makes sense.</p>",
        "id": 261437437,
        "sender_full_name": "Jubilee",
        "timestamp": 1636922690
    },
    {
        "content": "<p>could we just do</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Simd</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">T</span>: <span class=\"nc\">Add</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">SimdElement</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 261437455,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636922745
    },
    {
        "content": "<p>Plausible.</p>",
        "id": 261437499,
        "sender_full_name": "Jubilee",
        "timestamp": 1636922787
    },
    {
        "content": "<p>I was thinking the markers would be super traits of SimdElement</p>",
        "id": 261437502,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636922796
    },
    {
        "content": "<p>But yeah, that's basically what I was imagining</p>",
        "id": 261437519,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636922841
    },
    {
        "content": "<p>I was thinking more about this, I think maybe we can group functionality, but should still divide it up more finely than the number category</p>",
        "id": 261443174,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636931085
    },
    {
        "content": "<p>Like there can be a <code>Comparable</code> trait that gives you all of the <code>lanes_*</code> functions, <code>Arithmetic</code> can give you regular math, <code>BitArithmetic</code> can give you bitwise ops</p>",
        "id": 261443210,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636931138
    },
    {
        "content": "<p>neg and abs probably belong in <code>SignedArithmetic</code> or something like that</p>",
        "id": 261443271,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636931188
    },
    {
        "content": "<p>that's making some assumptions but much fewer</p>",
        "id": 261443296,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636931252
    },
    {
        "content": "<p>Okay, pulled out <code>SimdSInt</code> trivially.<br>\ntbqh I have no idea why I needed it before.</p>",
        "id": 261713512,
        "sender_full_name": "Jubilee",
        "timestamp": 1637100219
    },
    {
        "content": "<p>One thing I realized, that could complicate this a bit, is that the integer and float versions of various functions might end up being fairly different and definitely need different docs</p>",
        "id": 261714172,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637100550
    },
    {
        "content": "<p>Then throw pointers in there...</p>",
        "id": 261714198,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637100563
    },
    {
        "content": "<p>Not necessarily a problem, but something to be aware of</p>",
        "id": 261714349,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637100623
    },
    {
        "content": "<p>Well, that's why my initial intention was to simply impl <code>SInt</code>, <code>UInt</code>, and <code>Float</code>, <span class=\"user-mention\" data-user-id=\"312331\">@Caleb Zulawski</span>.</p>",
        "id": 261714700,
        "sender_full_name": "Jubilee",
        "timestamp": 1637100803
    },
    {
        "content": "<p>So that functions with 10 versions now have 3, with 2 now have 1, with 8 now have 2.</p>",
        "id": 261714736,
        "sender_full_name": "Jubilee",
        "timestamp": 1637100830
    },
    {
        "content": "<p>Maybe I'm missing something, wouldn't there only be one neg function for example?</p>",
        "id": 261715172,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637101050
    },
    {
        "content": "<p>Even though it exists for both floats and integers</p>",
        "id": 261715186,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637101060
    },
    {
        "content": "<p>Well when we poke a float with <code>simd_neg</code>, we set the sign bit.<br>\nWhen we poke a signed integer, we do a 2s complement flip, so 1 becomes -1, so e.g. <code>0b0000_0001u8 as i8</code> becomes <code>0b1111_1111u8 as i8</code>.</p>",
        "id": 261715481,
        "sender_full_name": "Jubilee",
        "timestamp": 1637101194
    },
    {
        "content": "<p>I'm not suggesting anything that deep</p>",
        "id": 261715601,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637101239
    },
    {
        "content": "<p>This is why my inclination was to define by type, because what this means is abs is abs arithmetically but not bit-operationally.</p>",
        "id": 261715623,
        "sender_full_name": "Jubilee",
        "timestamp": 1637101250
    },
    {
        "content": "<p>Neg is a bad example</p>",
        "id": 261715675,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637101280
    },
    {
        "content": "<p>And trying to abstract over that difference is actually a mistake, imo.</p>",
        "id": 261715678,
        "sender_full_name": "Jubilee",
        "timestamp": 1637101281
    },
    {
        "content": "<p>Take abs</p>",
        "id": 261715684,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637101285
    },
    {
        "content": "<p>It's a good example. :D</p>",
        "id": 261715691,
        "sender_full_name": "Jubilee",
        "timestamp": 1637101289
    },
    {
        "content": "<p>How can you have more than one function named abs?</p>",
        "id": 261715710,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637101300
    },
    {
        "content": "<p>You cannot.<br>\nBut it can have different implementations based on what you are interacting with.</p>",
        "id": 261715798,
        "sender_full_name": "Jubilee",
        "timestamp": 1637101328
    },
    {
        "content": "<p>Sure. So the documentation will be shared, which is what I was saying</p>",
        "id": 261715881,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637101375
    },
    {
        "content": "<p><em>headtilt</em></p>",
        "id": 261715919,
        "sender_full_name": "Jubilee",
        "timestamp": 1637101400
    },
    {
        "content": "<p>Abs is different for floats and ints</p>",
        "id": 261715987,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637101439
    },
    {
        "content": "<p>...No, it won't be?</p>",
        "id": 261716033,
        "sender_full_name": "Jubilee",
        "timestamp": 1637101447
    },
    {
        "content": "<p>I...</p>",
        "id": 261716052,
        "sender_full_name": "Jubilee",
        "timestamp": 1637101454
    },
    {
        "content": "<p>They handle T::MAX differently no?</p>",
        "id": 261716093,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637101481
    },
    {
        "content": "<p>So, I am going to back up to my original design here and then implement that and we can subslice it further after we have it in front of us and can actually run <code>cargo doc --open</code> and see what we are talking about.</p>",
        "id": 261716139,
        "sender_full_name": "Jubilee",
        "timestamp": 1637101505
    },
    {
        "content": "<p>Is that okay?</p>",
        "id": 261716171,
        "sender_full_name": "Jubilee",
        "timestamp": 1637101523
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232545\">@Joshua Nelson</span> might be interested in this conversation, since part of the issue is a rustdoc issue</p>",
        "id": 261716206,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1637101544
    },
    {
        "content": "<p>Do you understand what I am saying?</p>",
        "id": 261716208,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637101545
    },
    {
        "content": "<p>I believe I do understand what you are saying.</p>",
        "id": 261716284,
        "sender_full_name": "Jubilee",
        "timestamp": 1637101570
    },
    {
        "content": "<p>I'm just saying that floats and ints will share documentation, and for some functions that will need to be addressed</p>",
        "id": 261716413,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637101643
    },
    {
        "content": "<p>The documentation will need to refer to both cases</p>",
        "id": 261716448,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637101662
    },
    {
        "content": "<p><em>head tilts</em></p>",
        "id": 261716462,
        "sender_full_name": "Jubilee",
        "timestamp": 1637101667
    },
    {
        "content": "<p><code>abs</code> will need to indicate it does something different for ints and floats</p>",
        "id": 261716561,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637101700
    },
    {
        "content": "<p>For example</p>",
        "id": 261716602,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637101714
    },
    {
        "content": "<p>...Yes, I am aware of this problem.</p>",
        "id": 261716622,
        "sender_full_name": "Jubilee",
        "timestamp": 1637101730
    },
    {
        "content": "<p>Okay that's all I was saying from the beginning</p>",
        "id": 261716648,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637101745
    },
    {
        "content": "<p>It's something we need to be aware of</p>",
        "id": 261716666,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637101753
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/Approaches.20to.20cleaning.20up.20docs/near/261716206\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"232545\">Joshua Nelson</span> might be interested in this conversation, since part of the issue is a rustdoc issue</p>\n</blockquote>\n<p>I don't have time to read the backscroll - I replied on <span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span>'s PR, has anything changed since?</p>",
        "id": 261717523,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1637102160
    },
    {
        "content": "<p>I don't think so.</p>",
        "id": 261717635,
        "sender_full_name": "Jubilee",
        "timestamp": 1637102217
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"312331\">@Caleb Zulawski</span> The ones which require an implementation on the vector are the ones which require static dispatch on Simd's type argument. The operation for each must be different. The intrinsics are not polymorphic over it, and it is questionable whether they should be or could be.</p>",
        "id": 261842845,
        "sender_full_name": "Jubilee",
        "timestamp": 1637180418
    },
    {
        "content": "<p>As for the name and division of the trait bounds, I don't really care that much, but we have had libs members repeatedly express support to us for the idea of introducing trait-based categorization into std and the bound is convenient if implemented thusly. I can rename it to Bikeshed if you like and we can slice it apart later.</p>",
        "id": 261843378,
        "sender_full_name": "Jubilee",
        "timestamp": 1637180650
    },
    {
        "content": "<p>With the latter part I think I already gave my concern that it's potentially an issue in the future if we try to add more scalar types</p>",
        "id": 261843558,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637180743
    },
    {
        "content": "<p>The way this works really, really depends on all of our types being POD.</p>",
        "id": 261843646,
        "sender_full_name": "Jubilee",
        "timestamp": 1637180772
    },
    {
        "content": "<p>With all bit values being valid.</p>",
        "id": 261843670,
        "sender_full_name": "Jubilee",
        "timestamp": 1637180785
    },
    {
        "content": "<p>Yeah, which potentially makes sense, but I do think there's value to allowing things like non null pointers, and that pretty easily extends to non zero numbers etc</p>",
        "id": 261843822,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637180867
    },
    {
        "content": "<p>But regardless, I mostly don't care much at the moment. I am trying to address a problem, now, that people can't even open the docs because it ships with over 5 megabytes of HTML, and if I can do this much refactoring in an afternoon, I am hard pressed to believe this is actually going to introduce problems down the line unless you are saying you want to stabilize the API tomorrow and make no changes.</p>",
        "id": 261844007,
        "sender_full_name": "Jubilee",
        "timestamp": 1637180955
    },
    {
        "content": "<p>I'm not totally opposed, but I don't think changing the API purely to fix a documentation issue is necessarily correct, I'm also concerned about the inconsistency in how the traits are implemented</p>",
        "id": 261844226,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637181034
    },
    {
        "content": "<p>It would also be totally legitimate for rustdoc to collapse all functions that have identical function signatures but different type parameters, and it would have the same effect but no added traits</p>",
        "id": 261844409,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637181120
    },
    {
        "content": "<p>i also have some concerns about a rustdoc bug motivating changes in the api design, although i agree its important to address somehow</p>",
        "id": 261844564,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1637181185
    },
    {
        "content": "<p>Rustdoc could even provide an attribute to allow the functions to be collapsed optionally, rather than by default</p>",
        "id": 261844573,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637181188
    },
    {
        "content": "<p>Collapsing would not fix this issue at all.</p>",
        "id": 261846772,
        "sender_full_name": "Jubilee",
        "timestamp": 1637182176
    },
    {
        "content": "<p>I think you're misunderstanding what I mean by collapse</p>",
        "id": 261846987,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637182264
    },
    {
        "content": "<p>\"merge\"? Rustdoc could be changed to provide only one documentation section for all of the functions that have the same signature, but different type parameters</p>",
        "id": 261847062,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637182306
    },
    {
        "content": "<p>Joshua already said that he doesn't have any timetable for such a fix.</p>",
        "id": 261847135,
        "sender_full_name": "Jubilee",
        "timestamp": 1637182325
    },
    {
        "content": "<p>And you have already pushed a rather lot of decisions based on working with what we have, not with speculative future features.</p>",
        "id": 261847192,
        "sender_full_name": "Jubilee",
        "timestamp": 1637182355
    },
    {
        "content": "<p>I don't believe we should be comprising the API purely for an issue in rustdoc, regardless of the timetable in fixing it</p>",
        "id": 261847200,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637182359
    },
    {
        "content": "<p>Then I don't agree with our entire API.</p>",
        "id": 261847243,
        "sender_full_name": "Jubilee",
        "timestamp": 1637182379
    },
    {
        "content": "<p>Because it is compromised by bugs in rustc.</p>",
        "id": 261847271,
        "sender_full_name": "Jubilee",
        "timestamp": 1637182389
    },
    {
        "content": "<p>Like what? Other than a handful of scenarios I don't believe that's the case</p>",
        "id": 261847292,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637182407
    },
    {
        "content": "<p>I have argued <strong>vociferously</strong> and had to cave several times. That is precisely why I burned out and stopped working for several weeks over the summer. Just because you didn't notice, doesn't mean it didn't happen.</p>",
        "id": 261847474,
        "sender_full_name": "Jubilee",
        "timestamp": 1637182471
    },
    {
        "content": "<p>I think you're taking this personally when it's really not personal</p>",
        "id": 261847555,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637182513
    },
    {
        "content": "<p>I agree that the lane count limitations, for example, are a compromise because of rustc, but the alternative is not using generics at all which would be much more of a compromise</p>",
        "id": 261847640,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637182555
    },
    {
        "content": "<p>It involves human beings, it IS personal.</p>",
        "id": 261847641,
        "sender_full_name": "Jubilee",
        "timestamp": 1637182555
    },
    {
        "content": "<p>But I believe these traits complicate the API in a way that isn't desirable</p>",
        "id": 261847733,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637182581
    },
    {
        "content": "<p>Because it literally involves a person.</p>",
        "id": 261847734,
        "sender_full_name": "Jubilee",
        "timestamp": 1637182582
    },
    {
        "content": "<p>I don't think they do because users are not exposed to these implementation details and we can clean things up later.</p>",
        "id": 261847763,
        "sender_full_name": "Jubilee",
        "timestamp": 1637182603
    },
    {
        "content": "<p>And the idea that Rust should never expose a trait genericizing over i8, i16, i32, and i64 continues to be one of the biggest frustrations of users with Rust.</p>",
        "id": 261847816,
        "sender_full_name": "Jubilee",
        "timestamp": 1637182636
    },
    {
        "content": "<p>They are, though, they're in bounds of the function</p>",
        "id": 261847820,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637182637
    },
    {
        "content": "<p>Then we should group more of them.</p>",
        "id": 261847858,
        "sender_full_name": "Jubilee",
        "timestamp": 1637182659
    },
    {
        "content": "<p>But you can call these functions without having the traits in view.</p>",
        "id": 261847889,
        "sender_full_name": "Jubilee",
        "timestamp": 1637182672
    },
    {
        "content": "<p>But you have been arguing against grouping them.</p>",
        "id": 261847945,
        "sender_full_name": "Jubilee",
        "timestamp": 1637182685
    },
    {
        "content": "<p>We <strong>could</strong> special case these during lowering but that involves complicating the entire compiler.</p>",
        "id": 261848080,
        "sender_full_name": "Jubilee",
        "timestamp": 1637182743
    },
    {
        "content": "<p>This solution is apparently acceptable for Select.</p>",
        "id": 261848142,
        "sender_full_name": "Jubilee",
        "timestamp": 1637182770
    },
    {
        "content": "<p>Select is generic over the scalar type, this is inspired by it but it's not really the same</p>",
        "id": 261848303,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637182817
    },
    {
        "content": "<p>I have argued for using more const evaluation features to minimize these sorts of cases, but we went with trait bounds.</p>",
        "id": 261848320,
        "sender_full_name": "Jubilee",
        "timestamp": 1637182820
    },
    {
        "content": "<p>I don't really think that Select's genericity is meaningful, to be quite honest.</p>",
        "id": 261848401,
        "sender_full_name": "Jubilee",
        "timestamp": 1637182849
    },
    {
        "content": "<p>I would have <strong>none</strong> of this, not Select, not LaneCount, if I had my druthers.</p>",
        "id": 261848450,
        "sender_full_name": "Jubilee",
        "timestamp": 1637182874
    },
    {
        "content": "<p>Just use math.</p>",
        "id": 261848464,
        "sender_full_name": "Jubilee",
        "timestamp": 1637182881
    },
    {
        "content": "<p>But const generics aren't that far along yet, and in this case we at least sometimes need to do the type dispatch.</p>",
        "id": 261848565,
        "sender_full_name": "Jubilee",
        "timestamp": 1637182915
    },
    {
        "content": "<p>I'm just saying that this isn't identical. The types that select is valid for is much more clear because it's independent of the scalar type and you don't need to track down implementations</p>",
        "id": 261848651,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637182937
    },
    {
        "content": "<p>Select only has a single implementation for Simd, and a single one for Mask</p>",
        "id": 261848703,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637182962
    },
    {
        "content": "<p>And we <strong>should</strong> have all of this defined by a trait that is inherently brought into view by working with the type of the correct parameter.</p>",
        "id": 261848707,
        "sender_full_name": "Jubilee",
        "timestamp": 1637182963
    },
    {
        "content": "<p>So that there can be a single implementation of that behavior for all the appropriate types.</p>",
        "id": 261848794,
        "sender_full_name": "Jubilee",
        "timestamp": 1637183001
    },
    {
        "content": "<p>With no additional overhead.</p>",
        "id": 261848823,
        "sender_full_name": "Jubilee",
        "timestamp": 1637183016
    },
    {
        "content": "<p>I'm not following</p>",
        "id": 261848845,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637183027
    },
    {
        "content": "<p>And no unintentional conflict with users.</p>",
        "id": 261848859,
        "sender_full_name": "Jubilee",
        "timestamp": 1637183035
    },
    {
        "content": "<p>Sigh. I am just talking about dreamlands things now.</p>",
        "id": 261848917,
        "sender_full_name": "Jubilee",
        "timestamp": 1637183045
    },
    {
        "content": "<p>Are you suggesting that the math be implemented in a trait, which is implemented on Simd, and you must <code>use</code> the trait?</p>",
        "id": 261848971,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637183079
    },
    {
        "content": "<p>Or did I totally invent that</p>",
        "id": 261848980,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637183085
    },
    {
        "content": "<p>No.</p>",
        "id": 261848981,
        "sender_full_name": "Jubilee",
        "timestamp": 1637183085
    },
    {
        "content": "<p>Yeah, I'm not following what you're saying then</p>",
        "id": 261849006,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637183097
    },
    {
        "content": "<p>I am talking about starry-eyed things that don't exist yet.</p>",
        "id": 261849011,
        "sender_full_name": "Jubilee",
        "timestamp": 1637183102
    },
    {
        "content": "<p>And are barely proposed.<br>\nThe absence of which are things I view as bugs.</p>",
        "id": 261849053,
        "sender_full_name": "Jubilee",
        "timestamp": 1637183121
    },
    {
        "content": "<p>I have no idea what you're talking about, though</p>",
        "id": 261849077,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637183137
    },
    {
        "content": "<p>I rambled on, my apologies.</p>",
        "id": 261849112,
        "sender_full_name": "Jubilee",
        "timestamp": 1637183154
    },
    {
        "content": "<p>The main point: I regard the entire state of Rust library design to be shambolic, and I am proposing this as a temporary intermediary to fix some things up. I am not attached to the implementation details, because I want to burn those down, and I am willfully desirous of breaking users who depend on these impl details.</p>",
        "id": 261849354,
        "sender_full_name": "Jubilee",
        "timestamp": 1637183244
    },
    {
        "content": "<p>( \"of core::simd?\" \"no just... of libraries.\" )</p>",
        "id": 261849384,
        "sender_full_name": "Jubilee",
        "timestamp": 1637183262
    },
    {
        "content": "<p>I would be happy to talk about my ideal state for this library and indeed libraries for Rust in general, but I have been told that it is unrealistic and should not be considered at all.</p>",
        "id": 261849829,
        "sender_full_name": "Jubilee",
        "timestamp": 1637183483
    },
    {
        "content": "<p>I think fundamentally what I am saying is that API should never be compromised for documentation, since documentation generation can always be fixed but at a certain point the API will be stable, and our goal is to write something that will be stable eventually.  Clarity and documentation aren't the same, if we can change this such that it's both clearer and produces better documentation that's great, but my opinion of this now is that it produces better documentation but a less clear API.</p>",
        "id": 261849844,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637183492
    },
    {
        "content": "<p>It does not seem less clear to me.</p>",
        "id": 261849870,
        "sender_full_name": "Jubilee",
        "timestamp": 1637183510
    },
    {
        "content": "<p>Well, maybe that's where we disagree.  Right now you just need to look at which functions are implemented for which types, but in the PR you need to follow the traits, look at those implementations, and I think the inconsistency of the implementations makes it even worse</p>",
        "id": 261850023,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637183588
    },
    {
        "content": "<p>That is why I wanted to bound the implementations on type-associated traits (where possible).</p>",
        "id": 261850076,
        "sender_full_name": "Jubilee",
        "timestamp": 1637183619
    },
    {
        "content": "<p>So it can be intuitive and follow the natural categories.</p>",
        "id": 261850103,
        "sender_full_name": "Jubilee",
        "timestamp": 1637183636
    },
    {
        "content": "<p>Then I ran into the ones which require implementation dispatch.</p>",
        "id": 261850288,
        "sender_full_name": "Jubilee",
        "timestamp": 1637183716
    },
    {
        "content": "<p>Those are trickier.</p>",
        "id": 261850428,
        "sender_full_name": "Jubilee",
        "timestamp": 1637183779
    },
    {
        "content": "<p>If we back out the ones which require the special dispatch, would that be acceptable? It should still kill off something like 250kb.<br>\nAnd we still have a lot more to win by simplifying the trait implementations for ops in general.</p>",
        "id": 261850585,
        "sender_full_name": "Jubilee",
        "timestamp": 1637183872
    },
    {
        "content": "<p>Defining them in the <code>impl Shr for Simd&lt;T, L&gt; where T: SimdElement + Shr</code> way.</p>",
        "id": 261850690,
        "sender_full_name": "Jubilee",
        "timestamp": 1637183909
    },
    {
        "content": "<p>I'm still on the fence even if they're more consistent</p>",
        "id": 261850800,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637183955
    },
    {
        "content": "<p>You run into the issue that if two completely different scalar types happen to have the same function name, they collide</p>",
        "id": 261850881,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637183987
    },
    {
        "content": "<p>Well, that's why SimdAbs follows the pattern it does.</p>",
        "id": 261850960,
        "sender_full_name": "Jubilee",
        "timestamp": 1637184012
    },
    {
        "content": "<p>Regardless of what specifically the traits are implemented on</p>",
        "id": 261850964,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637184013
    },
    {
        "content": "<p>To block the collision.</p>",
        "id": 261850975,
        "sender_full_name": "Jubilee",
        "timestamp": 1637184016
    },
    {
        "content": "<p>That's not what I mean, I mean if u8 and *const T both have functions with the same name, but different signatures, you're out of luck</p>",
        "id": 261851064,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637184067
    },
    {
        "content": "<p>?</p>",
        "id": 261851074,
        "sender_full_name": "Jubilee",
        "timestamp": 1637184074
    },
    {
        "content": "<p><em>headtilts</em></p>",
        "id": 261851085,
        "sender_full_name": "Jubilee",
        "timestamp": 1637184081
    },
    {
        "content": "<p>Can you give a more particular example?</p>",
        "id": 261851101,
        "sender_full_name": "Jubilee",
        "timestamp": 1637184089
    },
    {
        "content": "<p>This isn't an issue right now, but for example, pointer <code>add</code> takes usize as the second argument</p>",
        "id": 261851139,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637184112
    },
    {
        "content": "<p>Right.</p>",
        "id": 261851142,
        "sender_full_name": "Jubilee",
        "timestamp": 1637184116
    },
    {
        "content": "<p>Everyone calls ops::Add tho' (on u8)</p>",
        "id": 261851202,
        "sender_full_name": "Jubilee",
        "timestamp": 1637184131
    },
    {
        "content": "<p>If we ever wanted to make a function on u8 called <code>add</code>, we wouldn't be able to do it</p>",
        "id": 261851212,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637184137
    },
    {
        "content": "<p>Of course we wouldn't want to, but that's the problem</p>",
        "id": 261851254,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637184152
    },
    {
        "content": "<p>Hm.</p>",
        "id": 261851267,
        "sender_full_name": "Jubilee",
        "timestamp": 1637184160
    },
    {
        "content": "<p>With this method you're saying that a particular function name has a particular meaning for all vectors, and then just gating it on the trait impl, as opposed to what we have now which allows them to be unrelated</p>",
        "id": 261851349,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637184198
    },
    {
        "content": "<p>Honestly, if something has to be a non-arithmetic SIMD type, we should probably reconsider using <code>Simd</code> for it.</p>",
        "id": 261851472,
        "sender_full_name": "Jubilee",
        "timestamp": 1637184248
    },
    {
        "content": "<p>I don't see any reason why a vector of pointers shouldn't be Simd, since the common operations all make sense for it</p>",
        "id": 261851541,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637184288
    },
    {
        "content": "<p>The common behaviors which in Rust are defined by traits, yes.</p>",
        "id": 261851582,
        "sender_full_name": "Jubilee",
        "timestamp": 1637184304
    },
    {
        "content": "<p><em>steeples fingers</em></p>",
        "id": 261851596,
        "sender_full_name": "Jubilee",
        "timestamp": 1637184314
    },
    {
        "content": "<p>But even then, you're suggesting that all signed, unsigned, and float operations have the exact same functions, which are then later gated on the element type, which I disagree with</p>",
        "id": 261851668,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637184351
    },
    {
        "content": "<p>And that's the fundamental difference between this and Select, all vectors, regardless of element type, can be selected</p>",
        "id": 261851745,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637184373
    },
    {
        "content": "<p>This is why I think it should be legal to impl a trait which functionally appears as a type's body, tbh.</p>",
        "id": 261851914,
        "sender_full_name": "Jubilee",
        "timestamp": 1637184465
    },
    {
        "content": "<p>f64 and f32 should just have a single trait that describes their common behavior and is impl'd for them, and when you look at their type, you basically just see that trait as their body.</p>",
        "id": 261852068,
        "sender_full_name": "Jubilee",
        "timestamp": 1637184538
    },
    {
        "content": "<p>This has been batted around a few times as \"inherent associated traits\" or w/e.</p>",
        "id": 261852132,
        "sender_full_name": "Jubilee",
        "timestamp": 1637184574
    },
    {
        "content": "<p>No additional need to <code>use</code> them.</p>",
        "id": 261852316,
        "sender_full_name": "Jubilee",
        "timestamp": 1637184648
    },
    {
        "content": "<p>probably you've been over this a dozen times, but could portable introduce its own trait that does that? or use <code>num</code> or something?</p>",
        "id": 261852354,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1637184670
    },
    {
        "content": "<p>We are in fact permitted to bring in our own traits, and libs has expressed <strong>enthusiasm</strong> for defining, finally, some kind of num-traits in core.</p>",
        "id": 261852419,
        "sender_full_name": "Jubilee",
        "timestamp": 1637184715
    },
    {
        "content": "<p>Even just a limited set of.</p>",
        "id": 261852428,
        "sender_full_name": "Jubilee",
        "timestamp": 1637184720
    },
    {
        "content": "<p>that seems like a good way to clean up both the documentation and reduce the number of impl blocks :)</p>",
        "id": 261852615,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1637184812
    },
    {
        "content": "<p>But the question of what if we want to add <code>Simd&lt;NonZeroU8, LANES&gt;</code> is being held against that. Now, I found a way to drop the need for e.g. the associated constant for additive/multiplicative identity.</p>",
        "id": 261852635,
        "sender_full_name": "Jubilee",
        "timestamp": 1637184825
    },
    {
        "content": "<p>So <code>NonZeroU8</code> should not be a blocking issue for that anymore.</p>",
        "id": 261852806,
        "sender_full_name": "Jubilee",
        "timestamp": 1637184914
    },
    {
        "content": "<p>Caleb would, as I understand it, prefer if we take a more function-oriented split rather than introducing <code>core::num_traits</code>.</p>",
        "id": 261852911,
        "sender_full_name": "Jubilee",
        "timestamp": 1637184963
    },
    {
        "content": "<p>However, I believe Caleb must have changed his mind since he said that, because now that seems to be too confusing.</p>",
        "id": 261853020,
        "sender_full_name": "Jubilee",
        "timestamp": 1637185008
    },
    {
        "content": "<p>I am not sure what's okay and what's not okay atm.</p>",
        "id": 261853095,
        "sender_full_name": "Jubilee",
        "timestamp": 1637185059
    },
    {
        "content": "<p>I fear introducing numeric traits into core will make this even more of a bikeshed than it would otherwise be</p>",
        "id": 261853223,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1637185113
    },
    {
        "content": "<p>That's why I only wanted to introduce some salutary bounds and am happy to rename them Bikeshed tbh.</p>",
        "id": 261853272,
        "sender_full_name": "Jubilee",
        "timestamp": 1637185144
    },
    {
        "content": "<p>but maybe its unavoidable</p>",
        "id": 261853274,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1637185144
    },
    {
        "content": "<p>imo \"rustdoc generates such fat html that it is impossible to load\" is a warning sign that the impl of our type is actually pretty high cognitive overhead.</p>",
        "id": 261853496,
        "sender_full_name": "Jubilee",
        "timestamp": 1637185249
    },
    {
        "content": "<p>I don't really think this reduces the cognitive load, since the API is largely functionally the same</p>",
        "id": 261853647,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1637185328
    },
    {
        "content": "<p>similarly, I don't think the other types that have this same problem (<a href=\"https://doc.rust-lang.org/nightly/core/num/struct.Wrapping.html\">https://doc.rust-lang.org/nightly/core/num/struct.Wrapping.html</a>, specifically) are high cognitive load</p>",
        "id": 261853709,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1637185364
    },
    {
        "content": "<p>I do.</p>",
        "id": 261853727,
        "sender_full_name": "Jubilee",
        "timestamp": 1637185374
    },
    {
        "content": "<p>re: Wrapping.</p>",
        "id": 261853740,
        "sender_full_name": "Jubilee",
        "timestamp": 1637185382
    },
    {
        "content": "<p>hmm</p>",
        "id": 261853770,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1637185397
    },
    {
        "content": "<p>You can't simply compartmentalize on a shared set of names between i32 and Wrapping&lt;i32&gt;, because they actually have subtly different impls.</p>",
        "id": 261853817,
        "sender_full_name": "Jubilee",
        "timestamp": 1637185421
    },
    {
        "content": "<p>Compartmentalization on a few markers allows reducing cognitive load.</p>",
        "id": 261853832,
        "sender_full_name": "Jubilee",
        "timestamp": 1637185432
    },
    {
        "content": "<p>There is no trait that defines their common subset.</p>",
        "id": 261853922,
        "sender_full_name": "Jubilee",
        "timestamp": 1637185463
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/Approaches.20to.20cleaning.20up.20docs/near/261853223\">said</a>:</p>\n<blockquote>\n<p>I fear introducing numeric traits into core will make this even more of a bikeshed than it would otherwise be</p>\n</blockquote>\n<p>you can somewhat avoid this by making the traits private</p>",
        "id": 261854516,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1637185669
    },
    {
        "content": "<p>Yeah, everything I have introduced is actually bounded on our SimdElement marker trait.</p>",
        "id": 261854694,
        "sender_full_name": "Jubilee",
        "timestamp": 1637185702
    },
    {
        "content": "<p>and say \"functions taking BikeshedTrait accept i8/16/32/64\" instead of having it autogenerated on the trait page</p>",
        "id": 261854708,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1637185705
    },
    {
        "content": "<p>Which is <code>unsafe</code> to impl and sealed.</p>",
        "id": 261854866,
        "sender_full_name": "Jubilee",
        "timestamp": 1637185741
    },
    {
        "content": "<p>if we're so adamant on using traits for shared behavior, then why not just implement the arithmetic in traits and implement those traits for vectors, and you need to have those traits imported to use them?</p>",
        "id": 261856131,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637186342
    },
    {
        "content": "<p>and then you can tell what functions are implemented for which types the regular way--just look at what vectors the trait is implemented on</p>",
        "id": 261856199,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637186375
    },
    {
        "content": "<p>Because every time I propose that idea I am shot down with \"requires an additional <code>use</code>\" tbh.</p>",
        "id": 261856203,
        "sender_full_name": "Jubilee",
        "timestamp": 1637186378
    },
    {
        "content": "<p>well, in our current state, would we want to try that?</p>",
        "id": 261856565,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637186508
    },
    {
        "content": "<p>that would solidify the stance of \"vectors are containers, these traits let you handle them as something more than a container\"</p>",
        "id": 261856651,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637186539
    },
    {
        "content": "<p>I'm wary of the whole nonzero problem still, but in that situation you could just make a whole new <code>NonZeroInt</code> trait or whatever, and it would work fine</p>",
        "id": 261856730,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637186588
    },
    {
        "content": "<p>are there any functions that would be implemented on <code>u8</code>, for example, that wouldn't be implemented on <code>u64</code>?</p>",
        "id": 261856899,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637186636
    },
    {
        "content": "<p>Uhh, maybe <code>widening_mul</code>.</p>",
        "id": 261856999,
        "sender_full_name": "Jubilee",
        "timestamp": 1637186649
    },
    {
        "content": "<p>yeah, that's a good example</p>",
        "id": 261857144,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637186681
    },
    {
        "content": "<p>In that case I should make the PR hacking apart <code>core_simd/src/ops.rs</code> first.</p>",
        "id": 261857206,
        "sender_full_name": "Jubilee",
        "timestamp": 1637186693
    },
    {
        "content": "<p>that would cause a problem because it couldn't be part of the trait</p>",
        "id": 261857215,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637186695
    },
    {
        "content": "<p>another hack, of course, would be something like implementing <code>Deref&lt;Target = SimdInt&gt;</code> for <code>Simd</code></p>",
        "id": 261857434,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637186747
    },
    {
        "content": "<p>What. <em>laughing</em></p>",
        "id": 261857509,
        "sender_full_name": "Jubilee",
        "timestamp": 1637186772
    },
    {
        "content": "<p>I think that gets blocked on coherence.</p>",
        "id": 261857895,
        "sender_full_name": "Jubilee",
        "timestamp": 1637187003
    },
    {
        "content": "<p>Not that I think it's a good idea, but this: <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=3af665c5446635861cc966a146cab05e\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=3af665c5446635861cc966a146cab05e</a></p>",
        "id": 261858413,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637187282
    },
    {
        "content": "<p>izzat really better than the proposed version that delegates inside a shared function?</p>",
        "id": 261858508,
        "sender_full_name": "Jubilee",
        "timestamp": 1637187356
    },
    {
        "content": "<p>well, it still entirely separates functionality as opposed to implementing every function for every scalar type, gated by a trait</p>",
        "id": 261858623,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637187419
    },
    {
        "content": "<p>but I think traits would probably still be better</p>",
        "id": 261858675,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637187453
    },
    {
        "content": "<p>just need to work out what you do when a particular function doesn't fit in the trait</p>",
        "id": 261858730,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637187474
    },
    {
        "content": "<p>create a new trait?</p>",
        "id": 261859106,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1637187569
    },
    {
        "content": "<p>yeah, you would need more traits, which is potentially fine but slightly annoying</p>",
        "id": 261859244,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637187625
    },
    {
        "content": "<p>I am concerned about a failure to elide the deref games, tbh.</p>",
        "id": 261859293,
        "sender_full_name": "Jubilee",
        "timestamp": 1637187660
    },
    {
        "content": "<p>Maybe I should not be? I don't know.</p>",
        "id": 261859342,
        "sender_full_name": "Jubilee",
        "timestamp": 1637187689
    },
    {
        "content": "<p>I think you shouldn't be, since then the entire language wouldn't work</p>",
        "id": 261859350,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637187699
    },
    {
        "content": "<p>but, it's still not necessarily a clear api</p>",
        "id": 261859381,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637187718
    },
    {
        "content": "<p>This is why I think the <code>where</code> bounds, while suboptimal, are preferable. They create a visible and upfront conditional.</p>",
        "id": 261859557,
        "sender_full_name": "Jubilee",
        "timestamp": 1637187787
    },
    {
        "content": "<p>I think it's less clear than just implementing a trait with all of the operations, at least</p>",
        "id": 261859688,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637187858
    },
    {
        "content": "<p>but, again, it has the fundamental issue that you can't implement something like <code>fn foo(self)</code> for <code>Simd&lt;u8, N&gt;</code> and <code>fn foo(self, usize)</code> for <code>Simd&lt;*const T, N&gt;</code> simultaneously</p>",
        "id": 261859749,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637187899
    },
    {
        "content": "<p>You mean the deref version shares that issue?</p>",
        "id": 261859789,
        "sender_full_name": "Jubilee",
        "timestamp": 1637187927
    },
    {
        "content": "<p>no, the deref version does not have that issue</p>",
        "id": 261859808,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637187939
    },
    {
        "content": "<p>Or just the where bound... ah.</p>",
        "id": 261859817,
        "sender_full_name": "Jubilee",
        "timestamp": 1637187943
    },
    {
        "content": "<p>it just has the issue of deref magic</p>",
        "id": 261859819,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637187944
    },
    {
        "content": "<p><em>shrug</em></p>",
        "id": 261859821,
        "sender_full_name": "Jubilee",
        "timestamp": 1637187946
    },
    {
        "content": "<p>I think it also doesn't really solve the problem of figuring out \"I have a Simd&lt;u8, N&gt;, what are all the functions I can call\"?</p>",
        "id": 261859970,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637188025
    },
    {
        "content": "<p>you need to go through every single function and inspect the bounds</p>",
        "id": 261859989,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637188038
    },
    {
        "content": "<p>I guess that's actually the same problem I was already describing, but phrased differently</p>",
        "id": 261860031,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637188063
    },
    {
        "content": "<p>does rustdoc correctly show all the different deref impls if you implement deref in more than one way?</p>",
        "id": 261860868,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1637188578
    },
    {
        "content": "<p>oh wait, that's a good point, maybe what Jubilee was saying, you can't actually implement deref more than once</p>",
        "id": 261860941,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637188645
    },
    {
        "content": "<p>I mean, you potentially could will some brilliant trait solver, but now you can't</p>",
        "id": 261860978,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637188674
    },
    {
        "content": "<p><code>impl Deref for Simd&lt;u8, ...&gt;</code> and <code>impl Deref for Simd&lt;f32, ...&gt;</code>... wonder if that works</p>",
        "id": 261861067,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1637188718
    },
    {
        "content": "<p>oh true, that should work, not sure how it would be documented</p>",
        "id": 261861110,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637188747
    },
    {
        "content": "<p>though honestly, i think the multiple deref approach is too weird from a user perspective</p>",
        "id": 261861157,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1637188772
    },
    {
        "content": "<p>yeah, I think it's too weird too, it was just a thought I had</p>",
        "id": 261861181,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637188790
    },
    {
        "content": "<p>a trait solves basically the same problem</p>",
        "id": 261861236,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637188805
    },
    {
        "content": "<p>We could paper over the multi-deref with manually documenting things, but the advantage of the <code>where</code> bounds is that it solves for generic programming issues and is machine-legible as well.</p>",
        "id": 261861579,
        "sender_full_name": "Jubilee",
        "timestamp": 1637189042
    },
    {
        "content": "<p>i like traits better than multi-deref, imho something like str::parse/FromStr situation is probably what we should aim for</p>",
        "id": 261861711,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1637189128
    },
    {
        "content": "<p>That is somewhat what I was aiming for.</p>",
        "id": 261861791,
        "sender_full_name": "Jubilee",
        "timestamp": 1637189164
    },
    {
        "content": "<p>fromstr is the trait we put all the goodies on, str::parse is just for user friendliness</p>",
        "id": 261861826,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1637189186
    },
    {
        "content": "<p>I think that when bounds are correct, they should not be avoided, and if we can describe relationships in associated types and the like, that's of use to us. They should rarely be unclear in practice.</p>",
        "id": 261861884,
        "sender_full_name": "Jubilee",
        "timestamp": 1637189239
    },
    {
        "content": "<p>I'm still thinking the traits should contain the functions themselves and be imported, rather than put functions on the vector directly with bounds</p>",
        "id": 261862229,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637189470
    },
    {
        "content": "<p>if we are to go in any direction involving traits at all</p>",
        "id": 261862240,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637189484
    },
    {
        "content": "<p>And: The reason behind inclining towards fewer rather than more traits dividing on a per-function basis is because, while it's good for std::ops, that's because std::ops is describing, in truth, <strong>lexical operators</strong>, not \"a behavior implemented by arithmetical entities.\" Most telling: <code>+</code> does not even have to commute!<br>\nAnyways, I need to take care of other things.</p>",
        "id": 261862427,
        "sender_full_name": "Jubilee",
        "timestamp": 1637189630
    },
    {
        "content": "<p>( probably the integer types would implement more than literally one trait shared by types in the ints or uints category, like... a few. )</p>",
        "id": 261862536,
        "sender_full_name": "Jubilee",
        "timestamp": 1637189698
    },
    {
        "content": "<p>well, like I said, my concern lies more with implementing the functions directly on the vectors in this case, and less about having traits at all</p>",
        "id": 261862543,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637189704
    },
    {
        "content": "<p>with regular traits, you could always just add more traits if you have a problem with your old ones</p>",
        "id": 261862589,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637189743
    },
    {
        "content": "<p>tbh given we have functions that <code>Simd&lt;T, LANES&gt;</code> impls, I am not sure why that is an ish, but like fair ig?</p>",
        "id": 261862686,
        "sender_full_name": "Jubilee",
        "timestamp": 1637189799
    },
    {
        "content": "<p>because all of those functions right now apply to either all scalar types, or only one specifically</p>",
        "id": 261862710,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637189825
    },
    {
        "content": "<p>that's it, I just have a problem with the generic functions only applying to some but not all</p>",
        "id": 261862736,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637189846
    },
    {
        "content": "<p>&lt;demon voice&gt;<strong>Let's fix this with specialization.</strong>&lt;/demon voice&gt;</p>",
        "id": 261862770,
        "sender_full_name": "Jubilee",
        "timestamp": 1637189869
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/Approaches.20to.20cleaning.20up.20docs/near/261862770\">said</a>:</p>\n<blockquote>\n<p>&lt;demon voice&gt;<strong>Let's fix this with specialization.</strong>&lt;/demon voice&gt;</p>\n</blockquote>\n<p>Jubilee wins. &lt;font face=\"dripping\"&gt;<strong>SPECIALITY</strong>&lt;/font&gt;</p>",
        "id": 261863555,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1637190323
    },
    {
        "content": "<p>a special kind of winning</p>",
        "id": 261863833,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1637190486
    },
    {
        "content": "<p>I don't really want to \"win\" anything...<br>\nI just want to make things better, and sometimes that means an intermediate fix.<br>\nMy long term fix I would like to see is inherent traits. Makes all the possible problems go away, basically.</p>",
        "id": 261993889,
        "sender_full_name": "Jubilee",
        "timestamp": 1637271106
    },
    {
        "content": "<p>yay for inherent traits!</p>",
        "id": 261994363,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1637271345
    },
    {
        "content": "<p>Yeah, I think inherent traits may solve this problem</p>",
        "id": 261996050,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637272218
    },
    {
        "content": "<p>Though I'm not especially opposed to requiring use imports right now</p>",
        "id": 261996109,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637272248
    },
    {
        "content": "<p>we also could consider adding the trait as part of the prelude, which would avoid the need to use imports and keep it as a trait. if the trait is unstable, it might even be compatible with moving to other options in the future too</p>",
        "id": 261996669,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1637272489
    },
    {
        "content": "<p>I was wondering about it being part of the prelude, but was afraid of bringing it up lol</p>",
        "id": 261996734,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637272525
    },
    {
        "content": "<p>Hm, <span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> can we get a temperature check on that idea?</p>",
        "id": 261996900,
        "sender_full_name": "Jubilee",
        "timestamp": 1637272615
    },
    {
        "content": "<p>i don't think it's likely to cause problems since it's sealed, and imported <code>as _</code>, since it shouldn't cause inference issues for things that don't implement it (i think?)</p>",
        "id": 261997032,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1637272683
    },
    {
        "content": "<p>It might weird out some error messages.</p>",
        "id": 261997078,
        "sender_full_name": "Jubilee",
        "timestamp": 1637272700
    },
    {
        "content": "<p>But I don't think it will introduce errors we weren't already hitting with e.g. Iterator.</p>",
        "id": 261997109,
        "sender_full_name": "Jubilee",
        "timestamp": 1637272719
    },
    {
        "content": "<p>iterator woudl be worse in several ways, since iterator gets implemented by user code, and gets extended by user code</p>",
        "id": 261997158,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1637272746
    },
    {
        "content": "<p>Right, I am mostly noting that we hit spurious messages due to Iterator all the time.</p>",
        "id": 261997258,
        "sender_full_name": "Jubilee",
        "timestamp": 1637272796
    },
    {
        "content": "<p>i think this would be closer to SliceExt (which has been removed now), e.g. a trait that exists as a way to hack inherent methods on to something, and is only a trait in the prelude for technical reasons</p>",
        "id": 261997434,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1637272833
    },
    {
        "content": "<p>Like, totally unrelated basically?<br>\nBut it doesn't kill anyone's usage entirely, it just makes people go \"eh?\" for a bit until a bug gets fixed.</p>",
        "id": 261997449,
        "sender_full_name": "Jubilee",
        "timestamp": 1637272838
    },
    {
        "content": "<p>Yeah.</p>",
        "id": 261997454,
        "sender_full_name": "Jubilee",
        "timestamp": 1637272841
    },
    {
        "content": "<p>Complete sidebar, but I want to back up for a second.  <span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span> was your problem with implementing some traits on the scalar and some on the vector related specifically to calling the intrinsics?  An nothing with the ability to write an API like in general</p>",
        "id": 261997609,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637272903
    },
    {
        "content": "<p>I want to at least completely understand that problem before moving on</p>",
        "id": 261997638,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637272919
    },
    {
        "content": "<p>Sssortof.</p>",
        "id": 261997716,
        "sender_full_name": "Jubilee",
        "timestamp": 1637272940
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"312331\">@Caleb Zulawski</span> Some of the intrinsics we use are polymorphic over all our relevant scalar types.<br>\nSome are not.</p>",
        "id": 261998023,
        "sender_full_name": "Jubilee",
        "timestamp": 1637273083
    },
    {
        "content": "<p>For those which are totally polymorphic, we can just call e.g. simd_add and it handles that appropriately.</p>",
        "id": 261998240,
        "sender_full_name": "Jubilee",
        "timestamp": 1637273192
    },
    {
        "content": "<p>For those which are not, we need to implement something ourselves.</p>",
        "id": 261998427,
        "sender_full_name": "Jubilee",
        "timestamp": 1637273288
    },
    {
        "content": "<p>abs was one of those, right?</p>",
        "id": 261998710,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637273420
    },
    {
        "content": "<p>Yes.</p>",
        "id": 261998720,
        "sender_full_name": "Jubilee",
        "timestamp": 1637273427
    },
    {
        "content": "<p><a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=fb01b433b183c7184aeabbcc7c834b43\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=fb01b433b183c7184aeabbcc7c834b43</a></p>",
        "id": 261998739,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637273436
    },
    {
        "content": "<p>am I missing something here?</p>",
        "id": 261998747,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637273441
    },
    {
        "content": "<p><em>arches a brow</em></p>",
        "id": 261998799,
        "sender_full_name": "Jubilee",
        "timestamp": 1637273468
    },
    {
        "content": "<p>That... is a very strange way of handling it tbqh.</p>",
        "id": 261998836,
        "sender_full_name": "Jubilee",
        "timestamp": 1637273485
    },
    {
        "content": "<p>that's exactly how select is done, right now</p>",
        "id": 261998936,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637273529
    },
    {
        "content": "<p>well I suppose not exactly</p>",
        "id": 261998949,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637273536
    },
    {
        "content": "<p>but very similar</p>",
        "id": 261998960,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637273541
    },
    {
        "content": "<p>But you are correct that that approach could be used, ig.</p>",
        "id": 261998972,
        "sender_full_name": "Jubilee",
        "timestamp": 1637273549
    },
    {
        "content": "<p>I assume the abs trait is sealed, and we can make the internal function unstable</p>",
        "id": 261999023,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637273587
    },
    {
        "content": "<p>Yes.</p>",
        "id": 261999037,
        "sender_full_name": "Jubilee",
        "timestamp": 1637273598
    },
    {
        "content": "<p>if we can do all marker traits on scalars, and not have that inconsistency, i'm much more on the fence again</p>",
        "id": 261999161,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637273661
    },
    {
        "content": "<p>im actually a fan of that</p>",
        "id": 261999493,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1637273745
    },
    {
        "content": "<p>thats a lot like how stuff like str patterns work</p>",
        "id": 261999511,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1637273758
    },
    {
        "content": "<p>this way is _probably_ less obtuse than implementing all of the operations in traits that you import, but it also means we're probably going to break from some conventions slightly from the regular primitive types, since we're going to make various things work for both floats and integers (and potentially pointers)</p>",
        "id": 261999629,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637273821
    },
    {
        "content": "<p>I'm guessing that we're never going to support something that isn't an integer, float, or pointer of some sort</p>",
        "id": 261999707,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637273862
    },
    {
        "content": "<p>it's slightly complicated because we aren't going to have separate sections for pointer and number operations, we can put them in separate impl blocks but that's not necessarily that meaningful yet (but maybe in the future we'll be able to document the impl blocks)</p>",
        "id": 261999918,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637273954
    },
    {
        "content": "<p>actually... are the impl block docs shown somewhere?</p>",
        "id": 262000051,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637274010
    },
    {
        "content": "<p>I think so. I think that's actually part of why our HTML is so huge, which is why I am working rn on a different PR which just does trait simplification.</p>",
        "id": 262000223,
        "sender_full_name": "Jubilee",
        "timestamp": 1637274121
    },
    {
        "content": "<p>would you mind if I made my own branch with how I'm envisioning it with only scalar traits, and then we can compare them and work the differences and go from there?</p>",
        "id": 262000782,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637274441
    },
    {
        "content": "<p>i'm kinda hoping we eventually gain support for things like <code>Simd&lt;Simd&lt;f32, N&gt;, M&gt;</code>, so if possible I'd like to avoid assuming Simd element types are always float, int, or pointers</p>",
        "id": 262000815,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1637274465
    },
    {
        "content": "<p>what would be the point of that?</p>",
        "id": 262000889,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637274487
    },
    {
        "content": "<p><code>Simd&lt;ComplexF32, N&gt;</code> too</p>",
        "id": 262000903,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1637274497
    },
    {
        "content": "<p>I think at a certain point, the wrappers need to be around <code>Simd</code> and not internal to it</p>",
        "id": 262000995,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637274534
    },
    {
        "content": "<p>vectorizing code that already uses some vectors</p>",
        "id": 262001036,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1637274556
    },
    {
        "content": "<p>SimpleV is planning on supporting vectors of vectors natively</p>",
        "id": 262001100,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1637274602
    },
    {
        "content": "<p>How does such a type differ from the same but as its ravel?</p>",
        "id": 262001329,
        "sender_full_name": "Jubilee",
        "timestamp": 1637274729
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/Approaches.20to.20cleaning.20up.20docs/near/262000782\">said</a>:</p>\n<blockquote>\n<p>would you mind if I made my own branch with how I'm envisioning it with only scalar traits, and then we can compare them and work the differences and go from there?</p>\n</blockquote>\n<p>Go for it ig.</p>",
        "id": 262001435,
        "sender_full_name": "Jubilee",
        "timestamp": 1637274814
    },
    {
        "content": "<blockquote>\n<p>How does such a type differ from the same but as its ravel?</p>\n</blockquote>\n<p>??? i'm not sure what you mean</p>",
        "id": 262003492,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1637276092
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"229517\">@Jacob Lifshay</span> How does SIMD[SIMD[f32;3]; 3] differ from SIMD[f32; 9]</p>",
        "id": 262004081,
        "sender_full_name": "Jubilee",
        "timestamp": 1637276407
    },
    {
        "content": "<p>it acts differently for things like swizzle, horizontal_sum, and others</p>",
        "id": 262004198,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1637276446
    },
    {
        "content": "<p>on the one hand i've done stuff like this (in c++), on the other it seems like more trouble than its worth, and would be better off externalized</p>",
        "id": 262004257,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1637276482
    },
    {
        "content": "<p><code>Simd::&lt;T, N&gt;::horizontal_sum() -&gt; T</code>, so for <code>T = Simd&lt;f32, 3&gt;</code> it returns <code>Simd&lt;f32, 3&gt;</code></p>",
        "id": 262004404,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1637276548
    },
    {
        "content": "<p>If LLVM were to ever add intrinsics that do that, we can just add a new type that wraps it, if it were important enough</p>",
        "id": 262004445,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637276570
    },
    {
        "content": "<p>it's also handy for stuff like matrix operations</p>",
        "id": 262004564,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1637276638
    },
    {
        "content": "<p>or tensor operations</p>",
        "id": 262004624,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1637276652
    },
    {
        "content": "<p>i used it for stuff like strided SOA, e.g.  <code>Simd&lt;f32x8, 3&gt;</code>  as something like <code>{ xs: f32x8, ys: f32x8, zs: f32x8 }</code> for getting some of the benefits of SOA without giving up all of the convenience of AOS</p>",
        "id": 262004842,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1637276773
    },
    {
        "content": "<p>that said you can still build that stuff on top</p>",
        "id": 262004860,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1637276783
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/Approaches.20to.20cleaning.20up.20docs/near/261996900\">said</a>:</p>\n<blockquote>\n<p>Hm, <span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> can we get a temperature check on that idea?</p>\n</blockquote>\n<p>Generally positive towards inherent traits; somewhat negative towards adding a trait to the prelude as a substitute if it's primarily to provide methods for specific types, but not entirely opposed. Would like to understand better.</p>",
        "id": 262004939,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1637276850
    },
    {
        "content": "<p>I think I'm not fully understanding the proposal, though.</p>",
        "id": 262005164,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1637276993
    },
    {
        "content": "<p>In general, if someone proposed to implement inherent traits, I'd heavily cheer them on, and I think the entire lang team is completely in favor.</p>",
        "id": 262005251,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1637277032
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/Approaches.20to.20cleaning.20up.20docs/near/262004939\">said</a>:</p>\n<blockquote>\n<p>Generally positive towards inherent traits; somewhat negative towards adding a trait to the prelude as a substitute if it's primarily to provide methods for specific types, but not entirely opposed. Would like to understand better.</p>\n</blockquote>\n<p>That would be ooonly as a temporary \"until inherent methods\" measure, basically, if we went that route.</p>",
        "id": 262008478,
        "sender_full_name": "Jubilee",
        "timestamp": 1637279021
    },
    {
        "content": "<p>...wow, the traits might be even more megabytes.</p>",
        "id": 262009142,
        "sender_full_name": "Jubilee",
        "timestamp": 1637279532
    },
    {
        "content": "<p>Yeah, I just knocked several megabytes off by just implementing traits generically with only a <strong>mild</strong> hack.</p>",
        "id": 262016840,
        "sender_full_name": "Jubilee",
        "timestamp": 1637285438
    },
    {
        "content": "<p>Woo!</p>",
        "id": 262016849,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637285457
    },
    {
        "content": "<p>( A trait \"Vector\" with a single associated type \"Scalar\". )</p>",
        "id": 262016864,
        "sender_full_name": "Jubilee",
        "timestamp": 1637285478
    },
    {
        "content": "<p>Hmmm and what's the purpose?</p>",
        "id": 262016884,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637285502
    },
    {
        "content": "<p>We obviously used to have that, it just didn't come up after we went generic</p>",
        "id": 262016904,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637285521
    },
    {
        "content": "<p>The trait solver can't recognize that</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">LANES</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Mul</span><span class=\"o\">&lt;</span><span class=\"n\">Simd</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">LANES</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"n\">etc</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"n\">etc</span><span class=\"p\">.</span><span class=\"w\"></span>\n</code></pre></div>\n<p>doesn't break coherence because I control everything.</p>",
        "id": 262016968,
        "sender_full_name": "Jubilee",
        "timestamp": 1637285559
    },
    {
        "content": "<p>Ah</p>",
        "id": 262017002,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637285594
    },
    {
        "content": "<p>And we need lazy norm for inherent associated types.</p>",
        "id": 262017009,
        "sender_full_name": "Jubilee",
        "timestamp": 1637285599
    },
    {
        "content": "<p>Is there any chance an associated const would work?</p>",
        "id": 262017027,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637285617
    },
    {
        "content": "<p>Er, associated type</p>",
        "id": 262017039,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637285628
    },
    {
        "content": "<p>That's why trait yes.</p>",
        "id": 262017090,
        "sender_full_name": "Jubilee",
        "timestamp": 1637285646
    },
    {
        "content": "<p>This works fine and is only <strong>mildly</strong> horrifying:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">LANES</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">BitAnd</span><span class=\"o\">&lt;</span><span class=\"n\">Simd</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">LANES</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">Simd</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">LANES</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"o\">&gt;</span>::<span class=\"n\">Scalar</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">T</span>: <span class=\"nc\">SimdElement</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Simd</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">LANES</span><span class=\"o\">&gt;</span>: <span class=\"nc\">BitAnd</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Output</span><span class=\"o\">=</span><span class=\"n\">Simd</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">LANES</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">LaneCount</span><span class=\"o\">&lt;</span><span class=\"n\">LANES</span><span class=\"o\">&gt;</span>: <span class=\"nc\">SupportedLaneCount</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Output</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Simd</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">LANES</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"cp\">#[inline]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">bitand</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">rhs</span>: <span class=\"nc\">Simd</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">LANES</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span>::<span class=\"n\">Output</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">rhs</span><span class=\"p\">.</span><span class=\"n\">bitand</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 262017127,
        "sender_full_name": "Jubilee",
        "timestamp": 1637285679
    },
    {
        "content": "<p>Oh, I mean using an inherent associated type instead of a trait</p>",
        "id": 262017180,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637285739
    },
    {
        "content": "<p>We are on nightly, after all</p>",
        "id": 262017183,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637285748
    },
    {
        "content": "<p>Do we really have so many op trait implementations that it's such a big deal?</p>",
        "id": 262017239,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637285782
    },
    {
        "content": "<p>In the absence of lazy norm I don't know if that's sound. <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 262017244,
        "sender_full_name": "Jubilee",
        "timestamp": 1637285788
    },
    {
        "content": "<p>Yes, we really have entire megabytes of HTML generated from the trait op macros alone.</p>",
        "id": 262017264,
        "sender_full_name": "Jubilee",
        "timestamp": 1637285804
    },
    {
        "content": "<p>I imagine it's the exact same thing</p>",
        "id": 262017267,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637285808
    },
    {
        "content": "<p>The solution is identical since you're explicitly using the trait in the type, I think</p>",
        "id": 262017305,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637285865
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>warning: the feature `inherent_associated_types` is incomplete and may not be safe to use and/or cause compiler crashes\n --&gt; src/lib.rs:1:12\n  |\n1 | #![feature(inherent_associated_types)]\n  |            ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(incomplete_features)]` on by default\n  = note: see issue #8995 &lt;https://github.com/rust-lang/rust/issues/8995&gt; for more information\n</code></pre></div>\n<p>That would be a no.</p>",
        "id": 262017478,
        "sender_full_name": "Jubilee",
        "timestamp": 1637286012
    },
    {
        "content": "<p>Ah I didn't realize it was incomplete</p>",
        "id": 262017496,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637286029
    },
    {
        "content": "<p>Yeah, guess we can use the trait for now</p>",
        "id": 262017505,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637286041
    },
    {
        "content": "<p>I'm just slightly concerned something somewhere may not work too well with type inference, since the op traits seem to give us so much trouble</p>",
        "id": 262017539,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637286089
    },
    {
        "content": "<p>I don't think it will actually be that much issue tbh.<br>\nAll tests are passing rn and the documented html is 4 MB smaller.</p>",
        "id": 262019356,
        "sender_full_name": "Jubilee",
        "timestamp": 1637288011
    },
    {
        "content": "<p>I was hoping it could be inverted with GATs (making the trait type the vector, not the scalar), but that doesn't seem to work since you can't then make it generic over the lane count because the scalar isn't constrained by it</p>",
        "id": 262019904,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637288686
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>#![feature(associated_type_defaults)]\n\ntrait Add&lt;const LANES: usize&gt;: Sized {\n    type Vector = Simd&lt;Self, LANES&gt;;\n}\n\nimpl&lt;T, const LANES: usize&gt; core::ops::Add&lt;T::Vector&gt; for T where T: Add&lt;LANES&gt; {\n    type Output = T::Vector;\n    fn add(self, rhs: T::Vector) -&gt; Self::Output {\n        unimplemented!()\n    }\n}\n</code></pre></div>",
        "id": 262020004,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637288810
    },
    {
        "content": "<p>even something like this would be nice but sadly not possible</p>",
        "id": 262020007,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637288818
    },
    {
        "content": "<p>Alright, let's try this again. <a href=\"https://github.com/rust-lang/portable-simd/pull/195\">https://github.com/rust-lang/portable-simd/pull/195</a></p>",
        "id": 262021214,
        "sender_full_name": "Jubilee",
        "timestamp": 1637290425
    },
    {
        "content": "<p>without digging into the details yet, is gating the vector operation on the presence of the scalar operation the way we should go?</p>",
        "id": 262021346,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637290604
    },
    {
        "content": "<p>I'm aware that I already did it for PartialEq etc, but we never really discussed it</p>",
        "id": 262021356,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637290619
    },
    {
        "content": "<p>it's sound because SimdElement is sealed and we can ensure that's correct before we actually make anything valid to use in a vector</p>",
        "id": 262021375,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637290656
    },
    {
        "content": "<p>but is that going to come back to bite us in the future?</p>",
        "id": 262021426,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637290699
    },
    {
        "content": "<p>Hmm.</p>",
        "id": 262021440,
        "sender_full_name": "Jubilee",
        "timestamp": 1637290766
    },
    {
        "content": "<p>it makes sense for the semantic meaning of the op traits, but not necessarily valid for any arbitrary type implementing those of course, depending on what the intrinsics can monomorphize</p>",
        "id": 262021445,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637290790
    },
    {
        "content": "<p>Well, as I figured out more of the details, the impls started being gated on</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"n\">T</span>: <span class=\"nc\">SimdElement</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"n\">Simd</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">LANES</span><span class=\"o\">&gt;</span>: <span class=\"nc\">Op</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Output</span><span class=\"o\">=</span><span class=\"n\">Simd</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">LANES</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"n\">etc</span><span class=\"p\">.</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 262021595,
        "sender_full_name": "Jubilee",
        "timestamp": 1637290899
    },
    {
        "content": "<p>I think it's a little sketchy, imo, to have it go both ways for the non-commutative ops.</p>",
        "id": 262021653,
        "sender_full_name": "Jubilee",
        "timestamp": 1637290934
    },
    {
        "content": "<p>That is,<br>\nI think</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">Simd</span>::<span class=\"n\">from_array</span><span class=\"p\">([</span><span class=\"mf\">5.0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mf\">4.0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mf\">3.0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mf\">2.0</span><span class=\"p\">])</span><span class=\"w\"> </span><span class=\"o\">/</span><span class=\"w\"> </span><span class=\"mf\">1.0</span><span class=\"w\"></span>\n</code></pre></div>\n<p>makes sense<br>\nbut I don't... really think so for the reverse.</p>",
        "id": 262021724,
        "sender_full_name": "Jubilee",
        "timestamp": 1637290998
    },
    {
        "content": "<p>well, id think for the reverse direction you could swap the order in the trait?</p>",
        "id": 262021742,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637291032
    },
    {
        "content": "<p>hmm</p>",
        "id": 262021747,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637291039
    },
    {
        "content": "<p>BUT</p>",
        "id": 262021780,
        "sender_full_name": "Jubilee",
        "timestamp": 1637291043
    },
    {
        "content": "<p>Yes, I have figured out all the shenanigans.</p>",
        "id": 262021790,
        "sender_full_name": "Jubilee",
        "timestamp": 1637291055
    },
    {
        "content": "<p>how about gating on a <code>SealedSimdOp&lt;Rhs, OpKind&gt; for Lhs</code> trait, currently implemented for all element types, but in the future it could be implemented for not all element types when we add something non-orthogonal</p>",
        "id": 262021809,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1637291078
    },
    {
        "content": "<p>I would be happy if we decided that e.g. the \"promotion\" impls and the vector impls had to \"stay as-is\", that is, be actually explicit.</p>",
        "id": 262021816,
        "sender_full_name": "Jubilee",
        "timestamp": 1637291086
    },
    {
        "content": "<p><code>L: SealedSimdOp&lt;R, AddOp&gt; + Add&lt;R, Output=O&gt;</code></p>",
        "id": 262021896,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1637291166
    },
    {
        "content": "<p>actually, I think it can be substantially simpler because none of our ops support different rhs or output types</p>",
        "id": 262021918,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637291235
    },
    {
        "content": "<p>As a lot of it is just generically \"lifting\" the impls.</p>",
        "id": 262021919,
        "sender_full_name": "Jubilee",
        "timestamp": 1637291237
    },
    {
        "content": "<p>Right.</p>",
        "id": 262021924,
        "sender_full_name": "Jubilee",
        "timestamp": 1637291247
    },
    {
        "content": "<p>so you could simply have a sealed <code>Add</code> trait, which enables all of the variations of the ops</p>",
        "id": 262021927,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637291257
    },
    {
        "content": "<p>and of course it's sealed by virtue of <code>trait Add: SimdElement</code></p>",
        "id": 262021983,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637291287
    },
    {
        "content": "<p>sigh.</p>",
        "id": 262022005,
        "sender_full_name": "Jubilee",
        "timestamp": 1637291338
    },
    {
        "content": "<p>new types may support different rhs or output types, e.g. we decide to implement <code>Add&lt;Simd&lt;isize, N&gt;&gt; for Simd&lt;*const T, N&gt;</code></p>",
        "id": 262022014,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1637291351
    },
    {
        "content": "<p>i think we wouldn't support the add operator on pointers</p>",
        "id": 262022099,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1637291446
    },
    {
        "content": "<p>that is true, though it's worth noting that pointers don't implement Add</p>",
        "id": 262022104,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637291449
    },
    {
        "content": "<p>i feel like pointers not implementing ops::Add was deliberate and and the right call</p>",
        "id": 262022118,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1637291476
    },
    {
        "content": "<p>if we ever had an asymmetric case come up you can always add a new marker trait for it</p>",
        "id": 262022119,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637291476
    },
    {
        "content": "<p>Anyway, most of the magic here works fine if we have some of the impls actually be explicit per type.</p>",
        "id": 262022120,
        "sender_full_name": "Jubilee",
        "timestamp": 1637291477
    },
    {
        "content": "<p>In fact all of it does on purpose basically</p>",
        "id": 262022136,
        "sender_full_name": "Jubilee",
        "timestamp": 1637291503
    },
    {
        "content": "<p>the thing with marker traits is we have to get all the ones we'll ever need when we stabilize, cuz otherwise generic user code would break or we couldn't impl new types cuz generic impl Add would overlap</p>",
        "id": 262022220,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1637291591
    },
    {
        "content": "<p>yeah, actually that's true even without marker traits though right? isn't that true with just using the core::ops traits as markers?</p>",
        "id": 262022312,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637291674
    },
    {
        "content": "<p>maybe we should just make a SimdAdd trait, and impl Add for all SimdAdd</p>",
        "id": 262022313,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1637291678
    },
    {
        "content": "<p>i'm not sure how that's different than this, or different from my suggestion of our own trait over scalars</p>",
        "id": 262022344,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637291734
    },
    {
        "content": "<p>I think I would rather be chewed out for writing lousy code explicitly than continue bikeshedding without referent.</p>",
        "id": 262022426,
        "sender_full_name": "Jubilee",
        "timestamp": 1637291824
    },
    {
        "content": "<p>people see the Add impl, but don't need to look at simdadd's impls so a mess is less of a concern? also simdadd would be on a different docs page, so that could help</p>",
        "id": 262022433,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1637291836
    },
    {
        "content": "<p>simdadd could still have non-type-generic impls</p>",
        "id": 262022516,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1637291910
    },
    {
        "content": "<p>I have to stress that we really<br>\nreally<br>\nreally<br>\ndo not actually gain much of anything at all by introducing an additional marker trait.</p>",
        "id": 262022538,
        "sender_full_name": "Jubilee",
        "timestamp": 1637291941
    },
    {
        "content": "<p>i'd be worried if SimdAdd actually showed up in the docs at all</p>",
        "id": 262022567,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1637291976
    },
    {
        "content": "<p>that sounds like its confusing</p>",
        "id": 262022570,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1637291980
    },
    {
        "content": "<p>it wouldn't be on the same page as the simdsub, simdmul, etc...so pages don't get as horrendously long</p>",
        "id": 262022573,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1637291984
    },
    {
        "content": "<p>i think having extra simd ops traits in the docs page sounds bad</p>",
        "id": 262022580,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1637291999
    },
    {
        "content": "<p>I am suggesting adding it purely for soundness</p>",
        "id": 262022618,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637292004
    },
    {
        "content": "<p>For soundness,<br>\nI think we actually are better off implementing Add&lt;Self&gt; for Simd&lt;f32, LANES&gt; etc.</p>",
        "id": 262022638,
        "sender_full_name": "Jubilee",
        "timestamp": 1637292039
    },
    {
        "content": "<p>I'm not absolutely convinced that gating on the core::ops trait is sound and felt a little queasy when I first introduced it</p>",
        "id": 262022644,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637292054
    },
    {
        "content": "<p>what do you mean?</p>",
        "id": 262022648,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637292062
    },
    {
        "content": "<p>just that?</p>",
        "id": 262022651,
        "sender_full_name": "Jubilee",
        "timestamp": 1637292068
    },
    {
        "content": "<p>did we not already have that?</p>",
        "id": 262022659,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637292085
    },
    {
        "content": "<p>cuz all impls are strictly controlled and we don't have to worry about new core non-simd Add impls causing unsoundness accidentally due to interactions with simd's add impl</p>",
        "id": 262022716,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1637292149
    },
    {
        "content": "<p>We did, and as I explored <a href=\"https://github.com/rust-lang/portable-simd/issues/195\">portable-simd#195</a>, I used the relative route.</p>",
        "id": 262022734,
        "sender_full_name": "Jubilee",
        "timestamp": 1637292191
    },
    {
        "content": "<p>which introduced the trait bound.</p>",
        "id": 262022737,
        "sender_full_name": "Jubilee",
        "timestamp": 1637292199
    },
    {
        "content": "<p>like most of the weight is seriously in e.g. the ref ops.</p>",
        "id": 262022742,
        "sender_full_name": "Jubilee",
        "timestamp": 1637292242
    },
    {
        "content": "<p>okay let me clarify exactly what I'm getting at because I think everyone is talking past each other</p>",
        "id": 262022803,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637292304
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>impl&lt;T, const LANES: usize&gt; BitAnd for Simd&lt;T, LANES&gt;\nwhere\n    T: SimdElement + BitAnd&lt;Output = T&gt;,\n    LaneCount&lt;LANES&gt;: SupportedLaneCount,\n{\n    type Output = Self;\n\n    #[inline]\n    fn bitand(self, rhs: Self) -&gt; Self::Output {\n        unsafe { intrinsics::simd_and(self, rhs) }\n    }\n}\n</code></pre></div>",
        "id": 262022811,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637292315
    },
    {
        "content": "<p>hmm, maybe we should leave out the ref versions? iirc there was a proposal to add autoderef to operators</p>",
        "id": 262022812,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1637292315
    },
    {
        "content": "<p>Yes, I know.</p>",
        "id": 262022819,
        "sender_full_name": "Jubilee",
        "timestamp": 1637292338
    },
    {
        "content": "<p>That is also what I am talking about.</p>",
        "id": 262022820,
        "sender_full_name": "Jubilee",
        "timestamp": 1637292346
    },
    {
        "content": "<p>This bothers me, somewhat, because that's not _really_ what the T: BitAnd really means</p>",
        "id": 262022826,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637292361
    },
    {
        "content": "<p>And I agree that it is a concern and we should probably just use base impls then.</p>",
        "id": 262022875,
        "sender_full_name": "Jubilee",
        "timestamp": 1637292394
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>impl&lt;T, const LANES: usize&gt; BitAnd&lt;T&gt; for Simd&lt;T, LANES&gt;\nwhere\n    T: SimdElement + BitAnd&lt;Output = T&gt;,\n    LaneCount&lt;LANES&gt;: SupportedLaneCount,\n{\n    type Output = Self;\n\n    #[inline]\n    fn bitand(self, rhs: T) -&gt; Self::Output {\n        unsafe { intrinsics::simd_and(self, Simd::splat(rhs)) }\n    }\n}\n</code></pre></div>\n<p>this I think is completely fine if it were rewritten such that <code>Self: BitAnd</code> instead of <code>T: BitAnd</code>, and instead of calling the intrinsic, just used &amp; directly</p>",
        "id": 262022888,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637292431
    },
    {
        "content": "<p>Yeah.</p>",
        "id": 262022896,
        "sender_full_name": "Jubilee",
        "timestamp": 1637292447
    },
    {
        "content": "<p>and then, yeah, if you do the base impls, I think that's a good compromise</p>",
        "id": 262022900,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637292453
    },
    {
        "content": "<p>I can do that adjustment.</p>",
        "id": 262022901,
        "sender_full_name": "Jubilee",
        "timestamp": 1637292454
    },
    {
        "content": "<p>unfortunately the base impls still explode a bit, but it's only those</p>",
        "id": 262022948,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637292491
    },
    {
        "content": "<p>q: Does anyone else feel that <code>scalar.div(vector)</code> is kinda sus?</p>",
        "id": 262022952,
        "sender_full_name": "Jubilee",
        "timestamp": 1637292497
    },
    {
        "content": "<p>heh</p>",
        "id": 262022954,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637292504
    },
    {
        "content": "<p>it's no weirder than the other lhs splats</p>",
        "id": 262022961,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637292523
    },
    {
        "content": "<p>div just makes you question it more</p>",
        "id": 262022968,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637292533
    },
    {
        "content": "<p>no, some code needs to compute 1 / x, that's just the vector version</p>",
        "id": 262022973,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1637292543
    },
    {
        "content": "<p>to be fair, that's what <code>recip</code> is for</p>",
        "id": 262022977,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637292555
    },
    {
        "content": "<p>Yeah I kinda do not enjoy <code>1 / x</code> being an idiom. :P</p>",
        "id": 262023047,
        "sender_full_name": "Jubilee",
        "timestamp": 1637292631
    },
    {
        "content": "<p>I think if we have any automatic splatting, there's nothing wrong with the lhs being splatted for div</p>",
        "id": 262023061,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637292653
    },
    {
        "content": "<p>another example: vectorizing <code>for i in 1..n { sum += a / i as f32; }</code></p>",
        "id": 262023062,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1637292656
    },
    {
        "content": "<p>Well okay.</p>",
        "id": 262023066,
        "sender_full_name": "Jubilee",
        "timestamp": 1637292663
    },
    {
        "content": "<p>I think <code>vector.div(scalar)</code> is fine tho', Jacob.</p>",
        "id": 262023078,
        "sender_full_name": "Jubilee",
        "timestamp": 1637292695
    },
    {
        "content": "<p>I agree that it's strange, just because div isn't commutitive</p>",
        "id": 262023089,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637292713
    },
    {
        "content": "<p>what about <code>1 - vec</code> though?</p>",
        "id": 262023093,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637292721
    },
    {
        "content": "<p>that would turn into, for i in 5 to 8: <code>sum += a / Simd::from_array([5., 6., 7., 8.])</code></p>",
        "id": 262023176,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1637292818
    },
    {
        "content": "<p>Yes, I satisfy this trait bound: <a href=\"https://www.youtube.com/watch?v=efHCdKb5UWc\">https://www.youtube.com/watch?v=efHCdKb5UWc</a></p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"efHCdKb5UWc\" href=\"https://www.youtube.com/watch?v=efHCdKb5UWc\"><img src=\"https://uploads.zulipusercontent.net/0556a2a6d0e4c921cdc74f9635f6bc1b9fb7d94d/68747470733a2f2f692e7974696d672e636f6d2f76692f65664843644b62355557632f64656661756c742e6a7067\"></a></div>",
        "id": 262023177,
        "sender_full_name": "Jubilee",
        "timestamp": 1637292818
    }
]