[
    {
        "content": "<p>Hello, I'm trying to make my polynomial resampling code SIMD and I'm a bit stuck about how to handle this part, which involves using multiple indices based on values in a simd vector. Is this possible or am I going about it all wrong?</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">pitches</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">f32x4</span>::<span class=\"n\">from_array</span><span class=\"p\">([</span><span class=\"mf\">1.01</span><span class=\"p\">,</span><span class=\"mf\">0.99</span><span class=\"p\">,</span><span class=\"mf\">1.02</span><span class=\"p\">,</span><span class=\"mf\">0.98</span><span class=\"p\">]);</span><span class=\"w\"></span>\n<span class=\"c1\">// phases is also f32x4</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">phases</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"n\">phases</span><span class=\"p\">.</span><span class=\"n\">floor</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"mf\">0.5</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"c1\">// the idx will likely be different for each value</span>\n<span class=\"c1\">// should be used to index the c_n coefficients</span>\n<span class=\"c1\">// can this be made usizex4 and used to index or something?</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">idx</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">phases</span><span class=\"p\">.</span><span class=\"n\">floor</span><span class=\"p\">();</span><span class=\"w\"></span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ratios</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">f32x4</span>::<span class=\"n\">splat</span><span class=\"p\">(</span><span class=\"mf\">1.</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">/</span><span class=\"w\"> </span><span class=\"n\">pitches</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"c1\">// update the phases</span>\n<span class=\"n\">phases</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">phases</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">ratios</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"c1\">// return outputs of the polynomia summed</span>\n<span class=\"k\">return</span><span class=\"w\"> </span><span class=\"p\">(((</span><span class=\"n\">c3</span><span class=\"p\">[</span><span class=\"n\">idx</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">c2</span><span class=\"p\">[</span><span class=\"n\">idx</span><span class=\"p\">])</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">c1</span><span class=\"p\">[</span><span class=\"n\">idx</span><span class=\"p\">])</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">c0</span><span class=\"p\">[</span><span class=\"n\">idx</span><span class=\"p\">]).</span><span class=\"n\">horizontal_sum</span><span class=\"p\">();</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 266881026,
        "sender_full_name": "Fredemus",
        "timestamp": 1641340719
    },
    {
        "content": "<p>Hi, I don't quite understand the problem, but usually I try to avoid indexing into SIMD vectors as much as possible because it's typically not very efficient</p>",
        "id": 267370337,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641752335
    },
    {
        "content": "<p>You may be looking for something like <code>Mask::select</code> which can allow you to conditionally change the values in lanes</p>",
        "id": 267370352,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641752368
    },
    {
        "content": "<p>I'm not trying to index into a simd vector, I was wondering if it's possible to use a simd vector to index into an array. <br>\nSomething like </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">array</span>: <span class=\"p\">[</span><span class=\"kt\">f32</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">2048</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mf\">1.</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">2048</span><span class=\"p\">];</span><span class=\"w\"></span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">indices</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">usizex4</span>::<span class=\"n\">from_array</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">]</span><span class=\"w\"></span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">chosen</span>: <span class=\"nc\">f32x4</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">array</span><span class=\"p\">[</span><span class=\"n\">indices</span><span class=\"p\">];</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 267641302,
        "sender_full_name": "Fredemus",
        "timestamp": 1641933360
    },
    {
        "content": "<p>Well, <code>Index</code> needs to return a reference, and there isn't an <code>f32x4</code> in memory anywhere to refer to, in general, so it's impossible with <code>[]</code> right now.</p>",
        "id": 267652816,
        "sender_full_name": "scottmcm",
        "timestamp": 1641938866
    },
    {
        "content": "<p>Ah yes, that's a gather operation</p>",
        "id": 267653259,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641939061
    },
    {
        "content": "<p><a href=\"https://doc.rust-lang.org/nightly/std/simd/struct.Simd.html#method.gather_or\">https://doc.rust-lang.org/nightly/std/simd/struct.Simd.html#method.gather_or</a></p>",
        "id": 267653383,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641939096
    },
    {
        "content": "<p>if you can, it's best to avoid gather on x86/arm cuz it's often very slow (not really faster than a bunch of scalar loads).</p>",
        "id": 267663332,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641944615
    },
    {
        "content": "<p>Thanks! I can guarantee that the 4 indices will be next to each other, so from my research it should be possible to do <code>from_slice</code>, but I think this has to be unaligned, is that better performance wise?</p>",
        "id": 267673199,
        "sender_full_name": "Fredemus",
        "timestamp": 1641952166
    },
    {
        "content": "<p>If the scalars are aligned, that's fine</p>",
        "id": 267673533,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641952545
    },
    {
        "content": "<p>The slice doesn't need to be vector-aligned</p>",
        "id": 267673540,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641952557
    },
    {
        "content": "<p>vector load, even if unaligned, is waay faster than gather on x86</p>",
        "id": 267676598,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641956228
    },
    {
        "content": "<p>iirc aligned vector load might not be any faster than unaligned load if the actual address your loading from happens to be aligned</p>",
        "id": 267676672,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641956306
    }
]