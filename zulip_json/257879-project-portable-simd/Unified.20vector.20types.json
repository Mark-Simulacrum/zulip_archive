[
    {
        "content": "<p>Well, here's a wrench:</p>\n<div class=\"codehilite\"><pre><span></span><code>error[E0077]: SIMD vector element type should be a primitive scalar (integer/float/pointer) type\n  --&gt; crates/core_simd/src/vector.rs:30:1\n   |\n30 | pub struct Simd&lt;Element: SimdElement, const LANES: usize&gt;([Element; LANES]) where crate::LaneCount&lt;LANES&gt;: crate::SupportedLaneCount;\n   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n</code></pre></div>",
        "id": 248169421,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627950133
    },
    {
        "content": "<p>I feel there's no reason this should be checked pre-monomorphisation</p>",
        "id": 248169455,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627950176
    },
    {
        "content": "<p>I think it's worth checking pre-monomorphization, however it should allow things it can't prove are wrong rather than only allow things it can prove correct.</p>",
        "id": 248169579,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1627950273
    },
    {
        "content": "<p>Yes, that's what I mean</p>",
        "id": 248169596,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627950291
    },
    {
        "content": "<p>perhaps I'll put together <em>that</em> PR tonight.  I doubt it's too difficult...</p>",
        "id": 248169654,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627950345
    },
    {
        "content": "<p><code>rustc_typeck\\src\\check\\check.rs</code></p>",
        "id": 248169861,
        "sender_full_name": "Jubilee",
        "timestamp": 1627950581
    },
    {
        "content": "<p>yup</p>",
        "id": 248169874,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627950594
    },
    {
        "content": "<p>What if we define a well-known symbol (a trait) associated with vector types?</p>",
        "id": 248170006,
        "sender_full_name": "Jubilee",
        "timestamp": 1627950709
    },
    {
        "content": "<p>Hm</p>",
        "id": 248170084,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627950753
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[lang = </span><span class=\"s\">\"simd_element\"</span><span class=\"cp\">]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">SimdElement</span><span class=\"w\"> </span>: <span class=\"nc\">Sealed</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 248170138,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1627950808
    },
    {
        "content": "<p>Yeah just a one line change in the compiler</p>",
        "id": 248171267,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627951759
    },
    {
        "content": "<p>(as far as I can tell, building/testing is going to take like 100x as long)</p>",
        "id": 248171279,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627951792
    },
    {
        "content": "<p>What's your diff?</p>",
        "id": 248171609,
        "sender_full_name": "Jubilee",
        "timestamp": 1627952151
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>diff --git a/compiler/rustc_typeck/src/check/check.rs b/compiler/rustc_typeck/src/check/check.rs\nindex b5db3331d04..ba99e0c03d8 100644\n--- a/compiler/rustc_typeck/src/check/check.rs\n+++ b/compiler/rustc_typeck/src/check/check.rs\n@@ -1220,6 +1220,7 @@ pub fn check_simd(tcx: TyCtxt&lt;&#39;_&gt;, sp: Span, def_id: LocalDefId) {\n             match e.kind() {\n                 ty::Param(_) =&gt; (), // pass struct&lt;T&gt;(T, T, T, T) through, let monomorphization catch errors\n                 ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::RawPtr(_) =&gt; (), // struct(u8, u8, u8, u8) is ok\n+                ty::Array(t, _) if matches!(t.kind(), ty::Param(_)) =&gt; (), // pass struct&lt;T&gt;([T; N]) through, let monomorphization catch errors\n                 ty::Array(t, _clen)\n                     if matches!(\n                         t.kind(),\n</code></pre></div>",
        "id": 248172208,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627952696
    },
    {
        "content": "<p>oh whoops brainspasm. Yes this is passing tests, looks like.</p>",
        "id": 248174116,
        "sender_full_name": "Jubilee",
        "timestamp": 1627954853
    },
    {
        "content": "<blockquote>\n<p>test result: FAILED. 11961 passed; 1 failed; 135 ignored; 0 measured; 0 filtered out; finished in 294.14s</p>\n</blockquote>\n<p>the test that fails is the one that always fails on some platforms :P</p>",
        "id": 248174299,
        "sender_full_name": "Jubilee",
        "timestamp": 1627955096
    },
    {
        "content": "<p>I'm still building LLVM :)</p>",
        "id": 248174316,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627955124
    },
    {
        "content": "<p>Jubilee has the tech hookup, builds LLVM in 0.68 seconds just for kicks</p>",
        "id": 248174370,
        "sender_full_name": "Lokathor",
        "timestamp": 1627955174
    },
    {
        "content": "<p>I think all we need is to add a test that it actually does what I think it does</p>",
        "id": 248174371,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627955174
    },
    {
        "content": "<p>uhh you should use<br>\n<code>download-ci-llvm = true</code></p>",
        "id": 248174375,
        "sender_full_name": "Jubilee",
        "timestamp": 1627955182
    },
    {
        "content": "<p>in your config.toml</p>",
        "id": 248174380,
        "sender_full_name": "Jubilee",
        "timestamp": 1627955195
    },
    {
        "content": "<p>oh right, I have mine set up for codegen so asserts on</p>",
        "id": 248174383,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627955200
    },
    {
        "content": "<p>but I don't really need that</p>",
        "id": 248174385,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627955203
    },
    {
        "content": "<p>lol I don't have Mara's machine. SHE has a system that builds LLVM in seconds for realsies.</p>",
        "id": 248174402,
        "sender_full_name": "Jubilee",
        "timestamp": 1627955238
    },
    {
        "content": "<p>wasn't it that her machine builds it in like 1 min and yours builds it in 6 min?</p>",
        "id": 248174417,
        "sender_full_name": "Lokathor",
        "timestamp": 1627955266
    },
    {
        "content": "<p>like those are all still wildly fast values</p>",
        "id": 248174420,
        "sender_full_name": "Lokathor",
        "timestamp": 1627955272
    },
    {
        "content": "<p>I've built LLVM countless times at work on some pretty decent servers but it still takes like half an hour!</p>",
        "id": 248174465,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627955288
    },
    {
        "content": "<p>which machine do you have?</p>",
        "id": 248174480,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1627955311
    },
    {
        "content": "<p>i think 30-45min on my desktop, i forget exactly but i did do it once for a thing</p>",
        "id": 248174487,
        "sender_full_name": "Lokathor",
        "timestamp": 1627955322
    },
    {
        "content": "<p>specifically for building the compiler, IIRC.</p>",
        "id": 248174532,
        "sender_full_name": "Jubilee",
        "timestamp": 1627955384
    },
    {
        "content": "<p>i have a Ryzen 3900X...it builds LLVM in somewhere &gt;10min iirc, I'll be finding out in detail when I start working on LLVM again</p>",
        "id": 248174716,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1627955539
    },
    {
        "content": "<p>I guess now that I think about it I'm including clang/binutils in that time</p>",
        "id": 248174753,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627955616
    },
    {
        "content": "<p>and lld...</p>",
        "id": 248174759,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627955624
    },
    {
        "content": "<p>lld can't even link GBA code, joke linker</p>",
        "id": 248174804,
        "sender_full_name": "Lokathor",
        "timestamp": 1627955652
    },
    {
        "content": "<p>binutils...I thought rustc uses the system binutils on linux...</p>",
        "id": 248174840,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1627955697
    },
    {
        "content": "<p>doesn't mean the \"build llvm\" path doesn't build the tools anyway</p>",
        "id": 248174867,
        "sender_full_name": "Lokathor",
        "timestamp": 1627955740
    },
    {
        "content": "<p>welp</p>",
        "id": 248174913,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1627955784
    },
    {
        "content": "<p>I don't know for sure either way, but i could easily imagine that it builds them to have them available for when you want them</p>",
        "id": 248174920,
        "sender_full_name": "Lokathor",
        "timestamp": 1627955820
    },
    {
        "content": "<p>Got distracted but opened <a href=\"https://github.com/rust-lang/rust/issues/87716\">#87716</a></p>",
        "id": 248179107,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627961965
    },
    {
        "content": "<p>Approved.</p>",
        "id": 248182744,
        "sender_full_name": "Jubilee",
        "timestamp": 1627967324
    },
    {
        "content": "<p>Somewhat related, I wonder if GATs are useful to us? <a href=\"https://blog.rust-lang.org/2021/08/03/GATs-stabilization-push.html\">https://blog.rust-lang.org/2021/08/03/GATs-stabilization-push.html</a></p>",
        "id": 248284883,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628026870
    },
    {
        "content": "<p>Not necessarily for our public types but perhaps for helper types</p>",
        "id": 248285023,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628026955
    },
    {
        "content": "<p><span aria-label=\"eyes\" class=\"emoji emoji-1f440\" role=\"img\" title=\"eyes\">:eyes:</span></p>",
        "id": 248290252,
        "sender_full_name": "Jubilee",
        "timestamp": 1628030766
    },
    {
        "content": "<p>So one thing I'm running into is that to implement functions with traits rather than over each type individually, I think we still need macros (so it doesn't necessarily clean up every function)</p>",
        "id": 248434859,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628134486
    },
    {
        "content": "<p>it also makes a few things a little confusing like</p>\n<div class=\"codehilite\"><pre><span></span><code>impl&lt;Element, const LANES: usize&gt; Simd&lt;Element, LANES&gt; {\n    fn lanes_ge(self, other: Self) -&gt; Mask&lt;Element::Mask, LANES&gt; { ... }\n}\n</code></pre></div>",
        "id": 248434949,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628134622
    },
    {
        "content": "<p>it's not immediately obvious what <code>Element::Mask</code> is</p>",
        "id": 248434964,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628134646
    },
    {
        "content": "<p>though it may still be beneficial over <code>lanes_ge</code> existing only once rather than 12 times</p>",
        "id": 248435009,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628134714
    },
    {
        "content": "<p>I think this is going to take long enough that we want to decide beforehand whether we actually want this or not</p>",
        "id": 248435800,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628135973
    },
    {
        "content": "<p>I was hoping it would be quicker but implementing all of the <code>core::ops</code> traits is going to take a very long time to go through</p>",
        "id": 248435860,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628136008
    },
    {
        "content": "<p>This doesn't quite sound like the correct design then.</p>",
        "id": 248438014,
        "sender_full_name": "Jubilee",
        "timestamp": 1628138998
    },
    {
        "content": "<p>Well, it would have been quicker if it was the original design</p>",
        "id": 248438066,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628139034
    },
    {
        "content": "<p>^^;;</p>",
        "id": 248438096,
        "sender_full_name": "Jubilee",
        "timestamp": 1628139097
    },
    {
        "content": "<p>But one thing I ran into that was slightly concerning, for example, is that signum is implemented for both signed integers and floats, so it would probably require its own trait</p>",
        "id": 248438153,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628139142
    },
    {
        "content": "<p>The mask being a property of the element rather than vector seems wrong, in particular.</p>",
        "id": 248438154,
        "sender_full_name": "Jubilee",
        "timestamp": 1628139145
    },
    {
        "content": "<p>It's unfortunate because it seems that for certain things, such as shuffles, array conversions, etc, it makes sense to be a single type</p>",
        "id": 248438241,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628139258
    },
    {
        "content": "<p>But for the int, float, etc ops it makes more sense to be separate types</p>",
        "id": 248438248,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628139276
    },
    {
        "content": "<p>(I think I am describing traits)</p>",
        "id": 248438269,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628139306
    },
    {
        "content": "<p>One thing that we didn't try, which is an inversion of what we currently have, is there is a single Simd type, which implements all of the things like splat, shuffle, etc, and then there are Float, Int traits that implement the special functions</p>",
        "id": 248438509,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628139541
    },
    {
        "content": "<p>\"This is a SIMD vector, also this one in particular can do Float things\"</p>",
        "id": 248438544,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628139591
    },
    {
        "content": "<p>This feels backwards at first because for example i8 and f32 aren't two instances of the same type, but here we really fundamentally have arrays</p>",
        "id": 248438865,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628139830
    },
    {
        "content": "<p>A good question might be why wasn't this done with atomics though, for example</p>",
        "id": 248438930,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628139866
    },
    {
        "content": "<p>Well atomics aren't really the best API to begin with</p>",
        "id": 248438953,
        "sender_full_name": "Lokathor",
        "timestamp": 1628139894
    },
    {
        "content": "<p>I've had to be vehemently against Volatile stuff taking on the same path as Atomic stuff does, for example.</p>",
        "id": 248438979,
        "sender_full_name": "Lokathor",
        "timestamp": 1628139928
    },
    {
        "content": "<p>Yeah, it's possible that it was just a mistake</p>",
        "id": 248438997,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628139944
    },
    {
        "content": "<p>I can't help but think fundamentally the type should be Simd&lt;T; N&gt; just as [T; N], the difference is that arrays don't have particular functions for particular Ts</p>",
        "id": 248439050,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628140013
    },
    {
        "content": "<p>I mean it's a design that looks good enough in the first pass, i'm not saying anyone is a dummy just because we have the atomics api we do, hindsight is 20/20 and all that.</p>\n<p>It just doesn't work as a good foundation for more</p>",
        "id": 248439118,
        "sender_full_name": "Lokathor",
        "timestamp": 1628140099
    },
    {
        "content": "<p>Also, it's arguably a significantly less complicated API than SIMD</p>",
        "id": 248439139,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628140155
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/Unified.20vector.20types/near/248439050\">said</a>:</p>\n<blockquote>\n<p>I can't help but think fundamentally the type should be Simd&lt;T; N&gt; just as [T; N], the difference is that arrays don't have particular functions for particular Ts</p>\n</blockquote>\n<p>super spicy wasabi take: maybe they should</p>",
        "id": 248439148,
        "sender_full_name": "Lokathor",
        "timestamp": 1628140178
    },
    {
        "content": "<p>Well, if they did would it be better as traits?</p>",
        "id": 248439171,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628140203
    },
    {
        "content": "<p>so, the \"point\" of traits, at least one of the points, is that they let others extend what you're building with. If we want to have ops on just, say, i32 and i16, we can just plain impl Simd&lt;i32; N&gt; and impl Simd&lt;i16; N&gt;</p>",
        "id": 248439231,
        "sender_full_name": "Lokathor",
        "timestamp": 1628140297
    },
    {
        "content": "<p>I'm imagining something like</p>\n<div class=\"codehilite\"><pre><span></span><code>trait Float {\n    type Bits;\n    fn to_bits(self) -&gt; Simd&lt;Self::Bits; Self::LANES&gt;;\n}\n</code></pre></div>\n<p>as an example</p>",
        "id": 248439279,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628140334
    },
    {
        "content": "<p>i think a \"problem\" of this design is that anyone is gonna immediately say \"hey why don't scalar types have this stuff?\"</p>",
        "id": 248439294,
        "sender_full_name": "Lokathor",
        "timestamp": 1628140377
    },
    {
        "content": "<p>and... you're sunk in bikeshed land</p>",
        "id": 248439298,
        "sender_full_name": "Lokathor",
        "timestamp": 1628140385
    },
    {
        "content": "<p>Yep. Though I do think we have the good argument of distinguishing between universal, inherent operations, and things that only apply to some vectors</p>",
        "id": 248439324,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628140443
    },
    {
        "content": "<p>Though alternatively we may end up with exactly the design we have now</p>",
        "id": 248439368,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628140466
    },
    {
        "content": "<p>Like, we <em>should</em> have traits for numbers, being generic over primitives is something Rust needs for ergonomics. Rust is not fun to use for math.<br>\nbut i don't think we've got the clout to push a num traits api out in front of a simd api.<br>\nAnd while the \"one trait per op\" design keeps it simple and works in some crates, T-libs-api will probably balk</p>",
        "id": 248439404,
        "sender_full_name": "Lokathor",
        "timestamp": 1628140535
    },
    {
        "content": "<p>Well, one alternative is to make them all one vector type, but implement the functions manually over every valid element type, just like packed_simd</p>",
        "id": 248439495,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628140665
    },
    {
        "content": "<p>I think that's the worst option, you end up with one page for one type with every function in the entire API</p>",
        "id": 248439539,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628140687
    },
    {
        "content": "<p>if looking for vector traits, you could look at the code I wrote for <a href=\"https://github.com/rust-lang/stdsimd/issues/109\">stdsimd#109</a> for inspiration</p>",
        "id": 248439581,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1628140769
    },
    {
        "content": "<p>pro: that's the most doable in terms of what you could get T-libs-api to approve because it has no new traits you're adding to the standard library, and traits have a fairly high bar to be added to the standard library.</p>\n<p>con: i hate the packed_simd docs and i made the entire <code>wide</code> crate specifically because of how bad the packed_simd docs are.</p>",
        "id": 248439590,
        "sender_full_name": "Lokathor",
        "timestamp": 1628140780
    },
    {
        "content": "<p><a href=\"https://salsa.debian.org/Kazan-team/vector-math/-/blob/master/src/traits.rs\">https://salsa.debian.org/Kazan-team/vector-math/-/blob/master/src/traits.rs</a></p>",
        "id": 248439652,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1628140822
    },
    {
        "content": "<p>We could almost get away with no new traits other than unstable traits</p>",
        "id": 248439706,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628140922
    },
    {
        "content": "<p>Perma-unstable</p>",
        "id": 248439744,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628140931
    },
    {
        "content": "<p>i really hate the idea of perma-unstable</p>",
        "id": 248439749,
        "sender_full_name": "Lokathor",
        "timestamp": 1628140946
    },
    {
        "content": "<p>It's useful in a few cases but yeah, agreed</p>",
        "id": 248439759,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628140961
    },
    {
        "content": "<p>which would be the perma-unstable trait we'd need?</p>",
        "id": 248439763,
        "sender_full_name": "Lokathor",
        "timestamp": 1628140974
    },
    {
        "content": "<p>Well the traits for saying which element types are allowed</p>",
        "id": 248439846,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628141077
    },
    {
        "content": "<p>They wouldn't be part of the API beyond restricting which types can be used</p>",
        "id": 248439856,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628141098
    },
    {
        "content": "<p>no reason that needs to be perma-unstable i can think of.</p>",
        "id": 248439870,
        "sender_full_name": "Lokathor",
        "timestamp": 1628141128
    },
    {
        "content": "<p>(as in, they're only used for bounds and implementations, and not the actual api fns you call)</p>",
        "id": 248439873,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628141133
    },
    {
        "content": "<p>Well I am saying they can be perma-unstable for the reason of not adding new traits to std</p>",
        "id": 248439884,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628141155
    },
    {
        "content": "<p>If we are adding new traits might want to just put the fns directly in the traits</p>",
        "id": 248439931,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628141185
    },
    {
        "content": "<p>so the traits themselves could be stabilized, but all methods would be perma-unstable implementation details</p>",
        "id": 248439937,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1628141208
    },
    {
        "content": "<p>on the other hand: think of how sweet it would be if your repr(transparent) wrapper over an i32 could implement some trait and then suddenly it's SIMD everywhere</p>",
        "id": 248439943,
        "sender_full_name": "Lokathor",
        "timestamp": 1628141215
    },
    {
        "content": "<p>I doubt it'll ever be automatic because you'll have to deal with loading and storing data</p>",
        "id": 248440022,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628141304
    },
    {
        "content": "<p>But it can make the conversion easier</p>",
        "id": 248440032,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628141310
    },
    {
        "content": "<p>yay! <code>Simd&lt;NonZeroU32&gt;</code></p>",
        "id": 248440033,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1628141310
    },
    {
        "content": "<p>or ranged integers</p>",
        "id": 248440049,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1628141346
    },
    {
        "content": "<p>I'd expect it to be a trait that you manually add to your newtype, and then the compiler has magic which will reject the impl when it's incompatible</p>",
        "id": 248440065,
        "sender_full_name": "Lokathor",
        "timestamp": 1628141372
    },
    {
        "content": "<p>or non-NaN floats</p>",
        "id": 248440071,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1628141381
    },
    {
        "content": "<p>At that point why wouldn't you just newtype over the vector instead</p>",
        "id": 248440119,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628141408
    },
    {
        "content": "<p>I don't think there is any hope of making our API flexible enough for that</p>",
        "id": 248440131,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628141428
    },
    {
        "content": "<p>the value is that you think of it as a scalar and then when it turns out that you want to process more at once... one line added and bam you're into simd land</p>",
        "id": 248440157,
        "sender_full_name": "Lokathor",
        "timestamp": 1628141464
    },
    {
        "content": "<p>but i mean, that's just a thing that would be cool it doesn't have to happen</p>",
        "id": 248440173,
        "sender_full_name": "Lokathor",
        "timestamp": 1628141490
    },
    {
        "content": "<p>It would be cool but I think there are too many invariants that are being checked in unusual ways to actually make it happen</p>",
        "id": 248440226,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628141542
    },
    {
        "content": "<p>wild thought: Rayon has <code>par_iter</code>, we need <code>simd_iter</code> where we don't have to hope it's simple enough for the compiler to auto-vectorize it...</p>",
        "id": 248440250,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1628141596
    },
    {
        "content": "<p>we can do that already ;3 <a href=\"https://docs.rs/bytemuck/1.7.2/bytemuck/fn.pod_align_to_mut.html\">https://docs.rs/bytemuck/1.7.2/bytemuck/fn.pod_align_to_mut.html</a></p>",
        "id": 248440318,
        "sender_full_name": "Lokathor",
        "timestamp": 1628141674
    },
    {
        "content": "<p>hmm, don't see simd there...</p>",
        "id": 248440344,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1628141748
    },
    {
        "content": "<p>So I think the two issues with unifying the vector types that I ran into is 1) there are some weird type relationships such as mask or bit representations that I think either need explicit implementations or traits encoding the relationship and 2) there are some name collisions such as integers and floats both having <code>signum</code></p>",
        "id": 248440346,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628141752
    },
    {
        "content": "<p>Our current implementation successfully avoids both of these problems because the vector types are completely independent</p>",
        "id": 248440391,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628141800
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"229517\">Jacob Lifshay</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/Unified.20vector.20types/near/248440344\">said</a>:</p>\n<blockquote>\n<p>hmm, don't see simd there...</p>\n</blockquote>\n<p>you'd take the <code>&amp;[f32]</code> and <code>pod_align_to::&lt;_, f32x4&gt;</code> with it, getting the initial, simd middle, and tail parts as your return value.</p>",
        "id": 248440396,
        "sender_full_name": "Lokathor",
        "timestamp": 1628141807
    },
    {
        "content": "<p>but that is like, not ergonomic on its own, but you know, fix it with more helper code and stuff</p>",
        "id": 248440409,
        "sender_full_name": "Lokathor",
        "timestamp": 1628141832
    },
    {
        "content": "<p>ok, so it could be used to implement <code>simd_iter</code></p>",
        "id": 248440415,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1628141852
    },
    {
        "content": "<p>sure</p>",
        "id": 248440423,
        "sender_full_name": "Lokathor",
        "timestamp": 1628141877
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"312331\">@Caleb Zulawski</span> the signum issue is a bit of a pain</p>",
        "id": 248440489,
        "sender_full_name": "Lokathor",
        "timestamp": 1628141931
    },
    {
        "content": "<p>make a <code>trait SigNum</code>?</p>",
        "id": 248440509,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1628141981
    },
    {
        "content": "<p>maybe a limited amount of bloat in core::ops would be fine...?</p>",
        "id": 248440559,
        "sender_full_name": "Lokathor",
        "timestamp": 1628142019
    },
    {
        "content": "<p>the docs issue is quite real though. packed_simd and nalgebra are incomprihensable</p>",
        "id": 248440572,
        "sender_full_name": "Lokathor",
        "timestamp": 1628142058
    },
    {
        "content": "<p>where the trait contains the implementations and you just have one type-generic <code>signum</code> on <code>Simd</code> that's shared between ints and floats</p>",
        "id": 248440583,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1628142087
    },
    {
        "content": "<p>not sure i follow that</p>",
        "id": 248440643,
        "sender_full_name": "Lokathor",
        "timestamp": 1628142151
    },
    {
        "content": "<p>like <code>[T]::get()</code> does for indexes and ranges</p>",
        "id": 248440645,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1628142153
    },
    {
        "content": "<p>but the output type of get doesn't change based on T</p>",
        "id": 248440811,
        "sender_full_name": "Lokathor",
        "timestamp": 1628142416
    },
    {
        "content": "<p>i guess you're saying that the output of signum can just be Self?</p>",
        "id": 248440826,
        "sender_full_name": "Lokathor",
        "timestamp": 1628142450
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">SigNum</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Output</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">signum</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span>::<span class=\"n\">Output</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">LANES</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Simd</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">LANES</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"bp\">Self</span>: <span class=\"nc\">SigNum</span><span class=\"o\">&lt;</span><span class=\"n\">Output</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Simd</span><span class=\"o\">&lt;</span><span class=\"n\">R</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">LANES</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">signum</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span>::<span class=\"n\">Output</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">SigNum</span>::<span class=\"n\">signum</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 248440828,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1628142451
    },
    {
        "content": "<p>wait now that I think about it why can't the output type of signum just be Self?</p>",
        "id": 248440875,
        "sender_full_name": "Lokathor",
        "timestamp": 1628142505
    },
    {
        "content": "<p>icr if the type changes...</p>",
        "id": 248440880,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1628142533
    },
    {
        "content": "<p>well, floats return a float signum, signed ints return a signed int signum, and normally unsigned ints don't have a signum operation at all</p>",
        "id": 248440890,
        "sender_full_name": "Lokathor",
        "timestamp": 1628142568
    },
    {
        "content": "<p>ah, ok. so, like my code but replace return type stuff with <code>Self</code></p>",
        "id": 248440944,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1628142618
    },
    {
        "content": "<p>So if we go the route of having two traits (Float, SignedInt) that more or less solves the docs issues I think, as well as finding an appropriate place to put things like signum</p>",
        "id": 248441012,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628142733
    },
    {
        "content": "<p>if we are going to stabilize the <code>SigNum</code> trait, I think it'd be worthwhile having a separate output type for things like <code>BigFloat</code> which want to take their input by reference or by value</p>",
        "id": 248441014,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1628142735
    },
    {
        "content": "<p>Unsigned ints don't need a trait because they don't have any special functions...</p>",
        "id": 248441027,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628142756
    },
    {
        "content": "<p>otherwise, just skip output type stuff</p>",
        "id": 248441028,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1628142757
    },
    {
        "content": "<p>what happens to unsigned ints for stuff like <code>reduce_xor</code>, that would have to not be in floats?</p>",
        "id": 248441086,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1628142844
    },
    {
        "content": "<p>so, I think there are things we want an unsigned int trait for</p>",
        "id": 248441121,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1628142880
    },
    {
        "content": "<p>or just a generic int trait</p>",
        "id": 248441125,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1628142897
    },
    {
        "content": "<p>for <a href=\"https://github.com/rust-lang/stdsimd/issues/109\">stdsimd#109</a> I have a generic int trait and a signed int trait and a basically empty unsigned int trait</p>",
        "id": 248441182,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1628142967
    },
    {
        "content": "<p>the signed/unsigned traits have associated types for the opposite signedness</p>",
        "id": 248441203,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1628143024
    },
    {
        "content": "<p>I should note that I'm specifically not trying to solve the problem that something like the <code>num</code> crate is solving</p>",
        "id": 248441215,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628143066
    },
    {
        "content": "<p>not the worst idea to have that</p>",
        "id": 248441216,
        "sender_full_name": "Lokathor",
        "timestamp": 1628143067
    },
    {
        "content": "<p>Yeah I don't think we want to take on the weight of the world like <code>num</code> is doing</p>",
        "id": 248441264,
        "sender_full_name": "Lokathor",
        "timestamp": 1628143096
    },
    {
        "content": "<p>I think all we really need to do is segment the fact that there are vectors (arrays with some special memory access operations) and vectors (things that do particular operations on particular element types)</p>",
        "id": 248441471,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628143324
    },
    {
        "content": "<p>like that we're calling two separate things the same thing, very programmer-like to overload names like that.</p>",
        "id": 248441825,
        "sender_full_name": "Lokathor",
        "timestamp": 1628143761
    },
    {
        "content": "<p>Well the way I'm looking at it, a ymm register is a ymm register, we are using it in a floating point mode so we use the float trait</p>",
        "id": 248441888,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628143821
    },
    {
        "content": "<p>If you were just writing asm you could switch as much as you want</p>",
        "id": 248441903,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628143857
    },
    {
        "content": "<p>though the bits are just bits, 123int and 123float have very different encoding, so at least that much needs to be preserved</p>",
        "id": 248441926,
        "sender_full_name": "Lokathor",
        "timestamp": 1628143903
    },
    {
        "content": "<p>Well, I meant legally you could switch as much as you want. Doesn't mean it will do anything useful lol</p>",
        "id": 248441985,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628143947
    },
    {
        "content": "<p>In our API you could switch as much as you want too but we make it a little cumbersome at least</p>",
        "id": 248442014,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628143996
    },
    {
        "content": "<p>well...bitwise and is handy for floats occasionally, you could use them to help round</p>",
        "id": 248442026,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1628144009
    },
    {
        "content": "<p>I've been pondering this a bit more and I came to two conclusions</p>",
        "id": 248546776,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628203492
    },
    {
        "content": "<p>1) I think the existence of vectors of pointers is a convincing argument that it would be particularly nice for vectors to be generic over element type as well</p>",
        "id": 248546888,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628203565
    },
    {
        "content": "<p>Not absolutely necessary but as we add new things that can be put into vectors, the API explodes</p>",
        "id": 248546918,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628203607
    },
    {
        "content": "<p>2) I think we already ran into the issue in the past of \"when is a vector an array and when is it number-like?\". The earliest example I can think of was when we were first designing the API I suggested that it's confusing that \"rotate\" could mean rotating lanes, as well as the bit rotation operation on integers</p>",
        "id": 248547055,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628203720
    },
    {
        "content": "<p>It would be very strange if arrays, Vecs, etc inherited all of the properties of their contents, so we put them into a special mode (iterators) to access them</p>",
        "id": 248547121,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628203793
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span> has repeatedly brought up the iterator comparison</p>",
        "id": 248547198,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628203842
    },
    {
        "content": "<p>Is there perhaps some non-cumbersome way to indicate we are operating on the contents of the vector and not the container itself?  Instead of having a single type with both sets of operations mashed together into one</p>",
        "id": 248547349,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628203972
    },
    {
        "content": "<p>I think the iterator comparison is a little lacking because you can chain iterator operations, but we would rather the API look a little more like regular numbers, but I wouldn't want to call a fn on vectors every time I want to add them, e.g. <code>a.foo() + b.foo()</code></p>",
        "id": 248547607,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628204168
    },
    {
        "content": "<p>maybe have a element ops type and a container ops type, that can be interconverted with special member fns?</p>",
        "id": 248548547,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1628204830
    },
    {
        "content": "<p>so, it could look like: <code>(a.el().rotate_left(b.el()) + c * d).co().rotate_left(5)</code></p>",
        "id": 248548710,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1628204972
    },
    {
        "content": "<p>where <code>a</code> and <code>b</code> are <code>CoSimd&lt;u32, N&gt;</code> and <code>c</code> and <code>d</code> are <code>ElSimd&lt;u32, N&gt;</code></p>",
        "id": 248548837,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1628205059
    },
    {
        "content": "<p>or, now that we have <code>Co</code>/<code>El</code> prefixes, just name them <code>CoVec</code> and <code>ElVec</code>?</p>",
        "id": 248549139,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1628205269
    },
    {
        "content": "<p>oh boy that sounds unergonomic</p>",
        "id": 248550837,
        "sender_full_name": "Lokathor",
        "timestamp": 1628206779
    },
    {
        "content": "<p>i think the default should be to ignore that a vector is happening and always think of it as an element type you're operating on.</p>\n<p>then in select cases you might have vector-ish methods, but they're not the default assumption</p>",
        "id": 248550946,
        "sender_full_name": "Lokathor",
        "timestamp": 1628206857
    },
    {
        "content": "<p>container-ish perhaps i should say i mean</p>",
        "id": 248551140,
        "sender_full_name": "Lokathor",
        "timestamp": 1628207007
    },
    {
        "content": "<p>so, container-ops could be named like <code>container_rotate_right</code> and the bitwise op is <code>rotate_right</code>?</p>",
        "id": 248551272,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1628207122
    },
    {
        "content": "<p>I agree that it's not ergonomic</p>",
        "id": 248551302,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628207159
    },
    {
        "content": "<p>The problem I have is that if you put all the functions all on one type you still have mix and matched element and vector operations</p>",
        "id": 248551359,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628207182
    },
    {
        "content": "<p>Also, the related issue of every possible element type function all on one Simd type</p>",
        "id": 248551393,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628207220
    },
    {
        "content": "<p>random suggestion: a short prefix for vector ops like <code>a.vrotate()</code> (vector op) vs <code>a.rotate()</code> (elementwise bit op)</p>",
        "id": 248551675,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628207440
    },
    {
        "content": "<p>Unfortunately I think that's not very rusty.  Maybe there's something else in std like that but nothing comes to mind</p>",
        "id": 248551894,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628207646
    },
    {
        "content": "<p>Also, messing around with the names doesn't deconflict element types, such as signum for both ints and floats</p>",
        "id": 248551931,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628207681
    },
    {
        "content": "<p>I think I keep settling on traits--if your function call is ambiguous the compiler will let you know, and you can use UFCS</p>",
        "id": 248551954,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628207710
    },
    {
        "content": "<p>container ops can just have more verbose names</p>",
        "id": 248559152,
        "sender_full_name": "Lokathor",
        "timestamp": 1628215684
    },
    {
        "content": "<p>like it's totally 100% fine if we call it rotate_elements for clarity</p>",
        "id": 248559182,
        "sender_full_name": "Lokathor",
        "timestamp": 1628215716
    },
    {
        "content": "<p>or rotate_lanes or whatever name</p>",
        "id": 248559197,
        "sender_full_name": "Lokathor",
        "timestamp": 1628215737
    },
    {
        "content": "<p>Agreed that we can change the name for clarity</p>",
        "id": 248559215,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628215765
    },
    {
        "content": "<p>I found a silly trick I can do to unify the types piece by piece: <code>pub type SimdF32&lt;const LANES: usize&gt; = Simd&lt;f32, LANES&gt;;</code> :)</p>",
        "id": 248559272,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628215813
    },
    {
        "content": "<p>what's the problem with signum? it's a consistent interface for both int and float</p>",
        "id": 248559294,
        "sender_full_name": "Lokathor",
        "timestamp": 1628215850
    },
    {
        "content": "<p>well, useless for unsigned ints, but still</p>",
        "id": 248559310,
        "sender_full_name": "Lokathor",
        "timestamp": 1628215866
    },
    {
        "content": "<p>well</p>",
        "id": 248559338,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628215907
    },
    {
        "content": "<p>One option is that you implement all of your functions on the 12 primitive types separately</p>",
        "id": 248559388,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628215930
    },
    {
        "content": "<p>so now not only does your vector have a bunch of container types, but now it has 2 copies of every float op, 5 of every signed int op, etc</p>",
        "id": 248559435,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628215984
    },
    {
        "content": "<p>so you have 7 signums, not 1 or 2</p>",
        "id": 248559448,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628215995
    },
    {
        "content": "<p>well signum always returns Self</p>",
        "id": 248559467,
        "sender_full_name": "Lokathor",
        "timestamp": 1628216022
    },
    {
        "content": "<p>So then perhaps you implement functions instead of over every type, but over something like <code>impl&lt;T, const LANES: usize&gt; Simd&lt;T; LANES&gt; where T: FloatElement</code></p>",
        "id": 248559522,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628216055
    },
    {
        "content": "<p>i guess I don't know if it's an intrinsic internally or not</p>",
        "id": 248559523,
        "sender_full_name": "Lokathor",
        "timestamp": 1628216058
    },
    {
        "content": "<p>int signum isn't an intrinsic iirc</p>",
        "id": 248559532,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1628216087
    },
    {
        "content": "<p>the problem here is now you have two signums, one for <code>T: FloatElement</code> and one for <code>T: IntElement</code> and they conflict (because the type system allows for a hypothetical <code>T: FloatElement + IntElement</code>)</p>",
        "id": 248559548,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628216113
    },
    {
        "content": "<p>but why is it T: Float and not just T: Numeric</p>",
        "id": 248559617,
        "sender_full_name": "Lokathor",
        "timestamp": 1628216165
    },
    {
        "content": "<p>i guess that would fix things by invoking another bikeshed</p>",
        "id": 248559623,
        "sender_full_name": "Lokathor",
        "timestamp": 1628216181
    },
    {
        "content": "<p>Well, in that case it would happen to be <code>T: Signed</code></p>",
        "id": 248559625,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628216189
    },
    {
        "content": "<p>my point is not that it's not possible, it's that any function you add you may risk needing to add new traits</p>",
        "id": 248559641,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628216212
    },
    {
        "content": "<p>and you'll end up with quite a few</p>",
        "id": 248559656,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628216234
    },
    {
        "content": "<p>this is quite literally above our pay grade</p>",
        "id": 248559668,
        "sender_full_name": "Lokathor",
        "timestamp": 1628216254
    },
    {
        "content": "<p>that's my point</p>",
        "id": 248559674,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628216266
    },
    {
        "content": "<p>yeah T-libs-api needs to say what they would find acceptable before you continue or it risks a whole ton of wasted work</p>",
        "id": 248559726,
        "sender_full_name": "Lokathor",
        "timestamp": 1628216297
    },
    {
        "content": "<p>the alternative that I'm proposing is that instead you can do</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">LANES</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">FloatVector</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Simd</span><span class=\"o\">&lt;</span><span class=\"kt\">f32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">LANES</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">signum</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 248559735,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628216317
    },
    {
        "content": "<p>we can introduce traits that are strictly traits over vectors</p>",
        "id": 248559763,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628216357
    },
    {
        "content": "<p>and they segment the functionality for different types of vectors</p>",
        "id": 248559779,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628216376
    },
    {
        "content": "<p>and then you wouldn't need a whole bunch--there are just a few, for each segment of our API</p>",
        "id": 248559850,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628216446
    },
    {
        "content": "<p>well, what happens when someone wants to impl that for <code>Simd&lt;MyF32Wrapper, 4&gt;</code>?</p>",
        "id": 248559859,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1628216457
    },
    {
        "content": "<p>These traits would be strictly sealed</p>",
        "id": 248559874,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628216478
    },
    {
        "content": "<p>ah, ok</p>",
        "id": 248559878,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1628216488
    },
    {
        "content": "<p>They must be (so we can add functions in the future)</p>",
        "id": 248559882,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628216494
    },
    {
        "content": "<p>I don't think there is any hope of allowing SIMD types over custom types, not any time soon at least</p>",
        "id": 248559937,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628216531
    },
    {
        "content": "<p>I don't really want to get bogged down by it, this approach is more amenable to it but I still don't think it's something that will ever happen</p>",
        "id": 248559982,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628216635
    },
    {
        "content": "<p>Especially considering we can't even get u128 to work, and that's a real first-class type!</p>",
        "id": 248560087,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628216753
    },
    {
        "content": "<p>k, though if it's a repr(transparent) wrapper, that should be easier to get working on the compiler side than i128, since no llvm modifications are necessary</p>",
        "id": 248560183,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1628216825
    },
    {
        "content": "<p>Yeah, that's true.  My concern is more about how you would expose the compiler intrinsics such that a user could implement their custom functions, without exposing the innards of the compiler</p>",
        "id": 248560281,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628216948
    },
    {
        "content": "<p>Anyway--is there any reason to think for some reason adding traits that abstract over vectors is for some reason out of our scope?</p>",
        "id": 248560572,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628217351
    },
    {
        "content": "<p>i don't think any needed traits in general are out of scope, i just think they just have a high bar to meet.</p>",
        "id": 248569295,
        "sender_full_name": "Lokathor",
        "timestamp": 1628222349
    },
    {
        "content": "<p>Gotcha.</p>",
        "id": 248569635,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628222711
    },
    {
        "content": "<p>So I tried a different direction of my changes today--if anyone wants to take a look at the <code>feature/generic-element-type</code> branch I've mostly combined all vectors into a single <code>Simd</code> type (I haven't unified masks yet)</p>",
        "id": 248569689,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628222764
    },
    {
        "content": "<p>As expected a ton of things are simplified--<code>splat</code> etc, all of the various traits (fmt, PartialEq etc), shuffles</p>",
        "id": 248569715,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628222819
    },
    {
        "content": "<p>I would argue that the API is basically the same with my changes but simpler</p>",
        "id": 248569730,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628222845
    },
    {
        "content": "<p>The thing that is worse is the documentation, since we have no option but to put all of the docs on one page</p>",
        "id": 248569779,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628222884
    },
    {
        "content": "<p>It's undoubtedly much harder to read, even though I would argue the API is better</p>",
        "id": 248569800,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628222919
    },
    {
        "content": "<p>Why don't we go the direction of the primitives? Have a macro_rules that expands out all the code for X type.</p>\n<p>I seem to recall we had a pile of macro_rules at one point.</p>",
        "id": 248569871,
        "sender_full_name": "Lokathor",
        "timestamp": 1628223006
    },
    {
        "content": "<p>or, do we still?</p>",
        "id": 248569875,
        "sender_full_name": "Lokathor",
        "timestamp": 1628223013
    },
    {
        "content": "<p>That's what we have now (and to some extent what we have with my changes, too)</p>",
        "id": 248569902,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628223086
    },
    {
        "content": "<p>That's not really what I mean</p>",
        "id": 248569904,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628223097
    },
    {
        "content": "<p>Right now we have <code>SimdF32&lt;N&gt;</code> and <code>SimdF64&lt;N&gt;</code>, with my changes we have <code>Simd&lt;f32, N&gt;</code> and <code>Simd&lt;f64, N&gt;</code></p>",
        "id": 248569945,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628223139
    },
    {
        "content": "<p>In terms of actual code I think this is strictly an improvement, I don't really see any downsides at all</p>",
        "id": 248569954,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628223162
    },
    {
        "content": "<p>There is the downside that now rustdoc combines both of <code>Simd&lt;f32, N&gt;</code> and <code>Simd&lt;f64, N&gt;</code> onto one page rather than two</p>",
        "id": 248569965,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628223199
    },
    {
        "content": "<p>That's all I'm saying</p>",
        "id": 248569967,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628223202
    },
    {
        "content": "<p>but for example, before if you searched the docs for <code>gather_or</code> you got 12 functions, and now you get only 1</p>",
        "id": 248570021,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628223257
    },
    {
        "content": "<p>Where I am suggesting we go with traits is:<br>\nIf you look at the API with my changes you'll see for example 7 abs fns, one each for <code>f32</code>, <code>f64</code>, <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, and <code>isize</code>.  These are all completely separate functions.  What we could do instead is have two traits, and then you will have only two functions: <code>Float::abs</code> and <code>Int::abs</code></p>",
        "id": 248570438,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628224001
    },
    {
        "content": "<p>Then you will have a <code>Simd&lt;T, N&gt;</code>, and depending on <code>T</code> you may also implement <code>Float</code>, and if you do, you get an <code>abs</code> fn</p>",
        "id": 248570449,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628224053
    },
    {
        "content": "<p>I think code-wise this is better because you don't have duplicate fns for every time--you have one fn that may or may not be implemented on <code>Simd</code>.  Discoverability-wise I think this is also better because if you look at <code>Simd</code> you will see a list of things that are common to all vectors, like shuffles, splat, etc, and you can look at the traits for particular functionality unique to specific vectors</p>",
        "id": 248570513,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628224166
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span> I am curious what you think of this as well--this is basically an inversion of where I think you originally wanted to go with this, but to the same end.</p>",
        "id": 248570573,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628224211
    },
    {
        "content": "<p>Instead of having a <code>Vector</code> trait with common impls and then each specific type has special functionality, you have a common <code>Simd</code> type that has the common impls, and then specific traits with extra functionality</p>",
        "id": 248570596,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628224269
    },
    {
        "content": "<p>A little example of what I mean:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[repr(simd)]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">Simd</span><span class=\"o\">&lt;</span><span class=\"n\">Element</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">LANES</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">([</span><span class=\"n\">Element</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">LANES</span><span class=\"p\">]);</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">Element</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">LANES</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Simd</span><span class=\"o\">&lt;</span><span class=\"n\">Element</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">LANES</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">splat</span><span class=\"p\">(</span><span class=\"n\">value</span>: <span class=\"nc\">Element</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"bp\">Self</span><span class=\"p\">([</span><span class=\"n\">value</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">LANES</span><span class=\"p\">])</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">abs</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">LANES</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Simd</span><span class=\"o\">&lt;</span><span class=\"kt\">f32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">LANES</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">LANES</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Simd</span><span class=\"o\">&lt;</span><span class=\"kt\">f64</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">LANES</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 248570690,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628224442
    },
    {
        "content": "<p>I quite like that idea!</p>",
        "id": 248570767,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1628224543
    },
    {
        "content": "<p>In terms of end-user experience, the trade off is now you need to add <code>use std::simd::Float;</code>, but the benefit is the API just shrunk by 5-10x</p>",
        "id": 248570850,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628224668
    },
    {
        "content": "<p>I think <code>use std::simd::prelude::*;</code> is better...</p>",
        "id": 248570918,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1628224784
    },
    {
        "content": "<p>I think the argument there would be to put these traits in the actual prelude, then</p>",
        "id": 248570968,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628224824
    },
    {
        "content": "<p>in that case, they definitely should be named <code>SimdFloat</code> unless they will be usable for non-simd types</p>",
        "id": 248570980,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1628224888
    },
    {
        "content": "<p>Yeah, you're probably right</p>",
        "id": 248570986,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628224907
    },
    {
        "content": "<p>I think these traits would be specifically SIMD</p>",
        "id": 248570990,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628224915
    },
    {
        "content": "<p>perhaps I'm being optimistic, but I think the entire API would boil down to <code>Simd</code>, <code>SimdFloat</code>, <code>SimdSignedInt</code>, <code>SimdUnsignedInt</code>, <code>Mask</code>, <code>LaneCount</code>, <code>SupportedLaneCount</code></p>",
        "id": 248571053,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628225016
    },
    {
        "content": "<p>the <code>Vector</code>, <code>Mask</code>, and <code>Select</code> traits would no longer be necessary, and in terms of structs we go from 17 to 2</p>",
        "id": 248571103,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628225061
    },
    {
        "content": "<p>sounds about right, though we might want a separate bitmask type</p>",
        "id": 248571118,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1628225110
    },
    {
        "content": "<p>yeah, if we can ever work that out</p>",
        "id": 248571125,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628225124
    },
    {
        "content": "<p>but for now we have just the opaque mask type</p>",
        "id": 248571127,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628225131
    },
    {
        "content": "<p>once we add pointers we would probably get one or two more traits, but no new structs</p>",
        "id": 248571154,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628225164
    },
    {
        "content": "<p>unless we get generic ints first, in which case we just write <code>Mask&lt;int&lt;1&gt;, N&gt;</code></p>",
        "id": 248571180,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1628225172
    },
    {
        "content": "<p>yep</p>",
        "id": 248571185,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628225196
    },
    {
        "content": "<p>or, better yet, <code>FixedMask&lt;int&lt;1&gt;, N&gt;</code> to indicate non-opaque layout</p>",
        "id": 248571268,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1628225314
    },
    {
        "content": "<p>yeah, well, it could actually just be <code>Simd&lt;i1, N&gt;</code></p>",
        "id": 248571297,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628225357
    },
    {
        "content": "<p>since we'd probably want <code>FixedMask&lt;i32, N&gt;</code></p>",
        "id": 248571299,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1628225363
    },
    {
        "content": "<p>I'd imagine LLVM might get support for indicating particular vectors are masks, allowing skipping unnecessary instructions, <code>FixedMask</code> could be how we tell LLVM that a type isn't just any arbitrary <code>Simd&lt;i32, N&gt;</code> value</p>",
        "id": 248571436,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1628225533
    },
    {
        "content": "<p>currently LLVM just guesses from the operations it can see -- but totally fails across memory/function boundaries</p>",
        "id": 248571459,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1628225610
    },
    {
        "content": "<p>I think one thing is, current rust programmers are used to having many identical functions, one for each type. Having an extra 7 copies of <code>abs</code> isn't a huge deal.</p>",
        "id": 248617000,
        "sender_full_name": "Lokathor",
        "timestamp": 1628259684
    },
    {
        "content": "<p>So I agree-the difference is if you search abs in std right now you get <code>f32::abs</code>, <code>f64::abs</code> etc, in this case you will just have <code>Simd::abs</code> listed a bunch of times</p>",
        "id": 248617305,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628259823
    },
    {
        "content": "<p>wouldn't it be SimdF32::abs, etc?</p>",
        "id": 248617977,
        "sender_full_name": "Lokathor",
        "timestamp": 1628260122
    },
    {
        "content": "<p>No, the whole point of my change is that there is a single vector type <code>Simd&lt;T, N&gt;</code></p>",
        "id": 248618067,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628260174
    },
    {
        "content": "<p>Just as arrays are a single generic type</p>",
        "id": 248618119,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628260201
    },
    {
        "content": "<p>right right, i mean if we didn't make this change to generic element, we see SimdF32::abs</p>\n<p>so what if we teach rustdoc that it should show some amount of generics in the search results?</p>",
        "id": 248618297,
        "sender_full_name": "Lokathor",
        "timestamp": 1628260277
    },
    {
        "content": "<p>Currently yes, that is what you would see</p>",
        "id": 248618329,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628260298
    },
    {
        "content": "<p>Yeah, you could potentially improve rustdoc</p>",
        "id": 248618377,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628260323
    },
    {
        "content": "<p>Though I don't think there is any good way to deal with the <code>Simd</code> type having hundreds of functions to sort through</p>",
        "id": 248618460,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628260358
    },
    {
        "content": "<p>no but we can at least make it show as Simd&lt;f32,N&gt;::abs in search results</p>",
        "id": 248619181,
        "sender_full_name": "Lokathor",
        "timestamp": 1628260746
    },
    {
        "content": "<p>Yep, that's true</p>",
        "id": 248620647,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628261497
    },
    {
        "content": "<p>Is there any good reason it shouldn't be a trait though?</p>",
        "id": 248620669,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628261509
    },
    {
        "content": "<p>Well traits doc worse than methods for one</p>",
        "id": 248649759,
        "sender_full_name": "Lokathor",
        "timestamp": 1628274473
    },
    {
        "content": "<p>I mean we can use a pile of traits but as soon as you've got traits for number types in simd someone is gonna want those traits for number types in scalar, and that's a can of worms.</p>",
        "id": 248649982,
        "sender_full_name": "Lokathor",
        "timestamp": 1628274563
    },
    {
        "content": "<p>Hello it will take a bit before I can review this thread properly.</p>",
        "id": 248685394,
        "sender_full_name": "Jubilee",
        "timestamp": 1628297888
    },
    {
        "content": "<p>This is a good example of the implementation improvements we get: <a href=\"https://github.com/rust-lang/portable-simd/commit/ea0280539cfee50c02fb5ed87960390d2d68008b?branch=ea0280539cfee50c02fb5ed87960390d2d68008b&amp;diff=split\">https://github.com/rust-lang/portable-simd/commit/ea0280539cfee50c02fb5ed87960390d2d68008b?branch=ea0280539cfee50c02fb5ed87960390d2d68008b&amp;diff=split</a></p>\n<p>Only one <code>select</code> implementation now!</p>",
        "id": 248697411,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628313645
    },
    {
        "content": "<p>I opened <a href=\"https://github.com/rust-lang/portable-simd/issues/154\">portable-simd#154</a> with my changes, I think it's strictly an improvement (ignoring rustdoc, at least), it's a big PR so no rush looking it over</p>",
        "id": 248738458,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628374788
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/Unified.20vector.20types/near/248620669\">said</a>:</p>\n<blockquote>\n<p>Is there any good reason it shouldn't be a trait though?</p>\n</blockquote>\n<p>afaict the stdlib has gone out of its way to avoid making anything a trait that it doesnt have to. stuff like containers, numerics, atomics, nonzero, ... and when it does expose a trait its after a lot of careful design.</p>",
        "id": 249064648,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1628652165
    },
    {
        "content": "<p>traits are harder to get right, since every api you add to them has to apply to all impls (potentially including user-provided ones in various cases). they have different semantics for stability (some things are insta-stable).</p>",
        "id": 249064815,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1628652373
    },
    {
        "content": "<p>i think if we have one we should plan on it being internal only, but i also think it might be worth finding out why that <em>wasn't</em> done for the internals of other parts of the stdlib.</p>",
        "id": 249064910,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1628652536
    },
    {
        "content": "<p>I agree with all that, though in this case the traits would all be sealed which helps quite a bit.  Though that could have been done for say atomics</p>",
        "id": 249064929,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628652584
    },
    {
        "content": "<p>i think for atomics it would have had the issue around stability i think (AtomicX128 being unstable, for example...)</p>",
        "id": 249065717,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1628653676
    },
    {
        "content": "<p>Hmm. you can't implement a stable trait on an unstable type?</p>",
        "id": 249065776,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628653736
    },
    {
        "content": "<p>you could do that</p>",
        "id": 249070067,
        "sender_full_name": "Lokathor",
        "timestamp": 1628659774
    },
    {
        "content": "<p>I believe that the rule is that if the program can see the type and see the trait, it automatically sees the type's impl of that trait, if any.</p>\n<p>However, if one part is nightly only that counts as \"not seen\".</p>",
        "id": 249070149,
        "sender_full_name": "Lokathor",
        "timestamp": 1628659855
    },
    {
        "content": "<p>I think the main reason atomics are the way they are is that the api was designed pre-1.0 when everyone knew a lot less about what's a good api in rust.</p>",
        "id": 249070222,
        "sender_full_name": "Lokathor",
        "timestamp": 1628659946
    },
    {
        "content": "<p>Recovering mental bandwidth slowly.</p>",
        "id": 249303484,
        "sender_full_name": "Jubilee",
        "timestamp": 1628808855
    },
    {
        "content": "<p>Yeah no rush!</p>",
        "id": 249303518,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628808898
    },
    {
        "content": "<p>Hmm, my initial impression I feel favorable, I think. One of the big things that makes me feel positive is that we now don't have to programmatically stringify certain names into the code to generate simple tests, which is more than just a wart: it's the type being much harder to use. It also does resemble existing impls for e.g. ArrayVec.</p>\n<p>My main concern was in enabling learning via enabling compartmentalization.<br>\nI feel like teaching rustdoc to handle this situation better feels plausible.<br>\nI am not afraid of a few cans of worms.</p>",
        "id": 249304093,
        "sender_full_name": "Jubilee",
        "timestamp": 1628809308
    },
    {
        "content": "<p>I agree that it's plausible.  It's probably a fairly big change though</p>",
        "id": 249305295,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628810374
    },
    {
        "content": "<p>There's also the possibility of using traits (which feels right to me, but not absolutely necessary)</p>",
        "id": 249305382,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1628810416
    },
    {
        "content": "<p>I agree traits are a plausible solution. I think either way we have a can of worms, basically.</p>",
        "id": 249305810,
        "sender_full_name": "Jubilee",
        "timestamp": 1628810745
    }
]