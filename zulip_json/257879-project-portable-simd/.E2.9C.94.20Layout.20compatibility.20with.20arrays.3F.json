[
    {
        "content": "<p>(I didn't see anything in the rustdocs about this)</p>\n<p>Is it sound to convert a <code>&amp;mut Simd&lt;T, N&gt;</code> to <code>&amp;[T; N]</code>?  AKA is it guaranteed to have the same length and order of elements?</p>\n<p>If it not <em>always</em> sound, is it sometimes sound?  Like is it sound so long as <code>sizeof(Simd&lt;T, N&gt;) == N * sizeof(T)</code>?</p>",
        "id": 263518967,
        "sender_full_name": "scottmcm",
        "timestamp": 1638490563
    },
    {
        "content": "<p>i'd expect it to be sound, with the current implementation (icr if we used <code>#[repr(transparent)]</code> in the appropriate places).</p>",
        "id": 263519105,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1638490670
    },
    {
        "content": "<p>it isn't sound for <code>Mask</code> tho</p>",
        "id": 263519177,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1638490716
    },
    {
        "content": "<p>If the size matches then yes, which it will for non-mask simd types.</p>\n<p>Note that the <em>other</em> direction isn't always allowed because a reference to an array might be under-aligned for the SIMD version of the reference</p>",
        "id": 263519237,
        "sender_full_name": "Lokathor",
        "timestamp": 1638490799
    },
    {
        "content": "<p>I think in this situation you can use <code>as_array</code>?  But yes, that's a valid conversion.  The other way around not.</p>",
        "id": 263519260,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1638490803
    },
    {
        "content": "<p>Yeah, I was confident the other way was not ok.</p>\n<p>I guess I was most unsure about <code>Simd&lt;T, 7&gt;</code>, but I suppose right now that doesn't even work, so meh.  Definitely makes sense that power-of-two sizes ought to be compatible like that.</p>",
        "id": 263519565,
        "sender_full_name": "scottmcm",
        "timestamp": 1638491004
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 263519570,
        "sender_full_name": "scottmcm",
        "timestamp": 1638491009
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> has marked this topic as resolved.</p>",
        "id": 263519573,
        "sender_full_name": "Notification Bot",
        "timestamp": 1638491012
    },
    {
        "content": "<p>jackw please save us from these worries ;_;</p>",
        "id": 263519686,
        "sender_full_name": "Lokathor",
        "timestamp": 1638491106
    },
    {
        "content": "<p><code>Simd&lt;T, 7&gt;</code> will work in the future...it's internally a 7-element llvm vector, which llvm guarantees is laid out exactly like a 7-element array -- in memory.</p>",
        "id": 263519693,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1638491110
    },
    {
        "content": "<p>Oh, I should have noticed the <code>Simd&lt;T, L&gt;: AsMut&lt;[T; L]&gt;</code>.  That's strong confirmation (edit: well, of the ordering at least).</p>",
        "id": 263519717,
        "sender_full_name": "scottmcm",
        "timestamp": 1638491129
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"229517\">Jacob Lifshay</span> has marked this topic as resolved.</p>",
        "id": 263520013,
        "sender_full_name": "Notification Bot",
        "timestamp": 1638491380
    },
    {
        "content": "<p><a href=\"https://releases.llvm.org/13.0.0/docs/BigEndianNEON.html\">https://releases.llvm.org/13.0.0/docs/BigEndianNEON.html</a> They go to <strong>considerable</strong> trouble to make sure this is valid even on Big Endian processors, though I am unsure/more concerned about how they handle it on PowerPC.</p>",
        "id": 263520498,
        "sender_full_name": "Jubilee",
        "timestamp": 1638491763
    },
    {
        "content": "<p>powerpc's simd instructions automatically do endian swapping internally, so they match memory order</p>",
        "id": 263520590,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1638491842
    },
    {
        "content": "<p>libre-soc had a big argument over wether we needed the extra hw that does that...</p>",
        "id": 263520663,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1638491884
    },
    {
        "content": "<p>Ahhh okay, so what I was reading is that they follow big endian for the elements if the processor is in BE mode, so if you load [f32; 4] into a vector, it's laid out<br>\n[0000, 1111, 2222, 3333] in memory<br>\nbut then the vector load warps it into <br>\n[3333, 2222, 1111, 0000], right?<br>\nlike,<br>\nthe actual order is unimportant, just that you can't actually \"see\" the difference.</p>",
        "id": 263520777,
        "sender_full_name": "Jubilee",
        "timestamp": 1638492001
    },
    {
        "content": "<p>not the vector load...that just copies bits. the actual arithmetic ops do endian swapping</p>",
        "id": 263520883,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1638492068
    },
    {
        "content": "<p>hm</p>",
        "id": 263520929,
        "sender_full_name": "Jubilee",
        "timestamp": 1638492110
    },
    {
        "content": "<p>though there are different schemes for where the swapping is actually done internally...it has to look like the arithmetic ops do endian swapping from the programmers perspective</p>",
        "id": 263521001,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1638492157
    }
]