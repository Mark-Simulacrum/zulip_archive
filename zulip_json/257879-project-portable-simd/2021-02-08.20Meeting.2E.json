[
    {
        "content": "<p>Hello everyone, meeting in... 3 hours and 15 minutes? \"wow this is opening this thread early\" yes, I want to check if anyone is actually going to show up. ^^; So, hi! <span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span></p>",
        "id": 225585406,
        "sender_full_name": "Jubilee",
        "timestamp": 1612808213
    },
    {
        "content": "<p>Hi! Big news in CrabLand <a href=\"https://foundation.rust-lang.org/\">https://foundation.rust-lang.org/</a></p>",
        "id": 225588620,
        "sender_full_name": "Miguel Raz Guzmán Macedo",
        "timestamp": 1612809577
    },
    {
        "content": "<p>Not sure what it means though - (Jane helped me get started with Rust and connect to this project so a million thanks to her)</p>",
        "id": 225588656,
        "sender_full_name": "Miguel Raz Guzmán Macedo",
        "timestamp": 1612809598
    },
    {
        "content": "<p>yeah I have no idea.</p>",
        "id": 225589258,
        "sender_full_name": "Jubilee",
        "timestamp": 1612809903
    },
    {
        "content": "<p>New member here, is there an audio channel for the meeting?</p>",
        "id": 225607966,
        "sender_full_name": "Edmund Cape",
        "timestamp": 1612818211
    },
    {
        "content": "<p>Yeah, are we doing it? I'm here for once</p>",
        "id": 225608023,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1612818235
    },
    {
        "content": "<p>Nope, we just meet here in zulip</p>",
        "id": 225608096,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612818254
    },
    {
        "content": "<p>Got it. <br>\nWhat's the best place to go to see the agenda or past agendas?</p>",
        "id": 225608351,
        "sender_full_name": "Edmund Cape",
        "timestamp": 1612818384
    },
    {
        "content": "<p>We haven't been doing a great job of tracking minutes, but all of the previous meetings are here in zulip.</p>",
        "id": 225608574,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612818502
    },
    {
        "content": "<p>I don't know if we have anything specific on today's agenda, but we have a few open PRs and a closed PR to discuss</p>",
        "id": 225608618,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612818539
    },
    {
        "content": "<p>Great!</p>",
        "id": 225608645,
        "sender_full_name": "Edmund Cape",
        "timestamp": 1612818561
    },
    {
        "content": "<p><a href=\"https://hackmd.io/vtoVeGpQTeSeUH1HaOpRCw\">https://hackmd.io/vtoVeGpQTeSeUH1HaOpRCw</a><br>\n<a href=\"https://hackmd.io/P8lA-Lk-SvO0wUH1mmZyPw\">https://hackmd.io/P8lA-Lk-SvO0wUH1mmZyPw</a><br>\n<a href=\"https://hackmd.io/PYi0ZMVdRF64J0we5Z4Ucw\">https://hackmd.io/PYi0ZMVdRF64J0we5Z4Ucw</a><br>\n<a href=\"https://hackmd.io/h5Coi4l8RZWS6T1Esw5WKQ\">https://hackmd.io/h5Coi4l8RZWS6T1Esw5WKQ</a><br>\n<a href=\"https://hackmd.io/koVzlGQ0QsWqn1iwLf-Wyg\">https://hackmd.io/koVzlGQ0QsWqn1iwLf-Wyg</a><br>\n<a href=\"https://hackmd.io/a2vhyS0ZTtq1e7JkH2kabA\">https://hackmd.io/a2vhyS0ZTtq1e7JkH2kabA</a></p>",
        "id": 225608675,
        "sender_full_name": "oliver",
        "timestamp": 1612818582
    },
    {
        "content": "<p>I think there have lately not been minutes kept other than what's communicated here on Zulip</p>",
        "id": 225608806,
        "sender_full_name": "oliver",
        "timestamp": 1612818657
    },
    {
        "content": "<p><a href=\"https://rust-lang.github.io/rfcs/1199-simd-infrastructure.html\">https://rust-lang.github.io/rfcs/1199-simd-infrastructure.html</a></p>",
        "id": 225608860,
        "sender_full_name": "oliver",
        "timestamp": 1612818694
    },
    {
        "content": "<p><a href=\"https://rust-lang.github.io/rfcs/2977-stdsimd.html\">https://rust-lang.github.io/rfcs/2977-stdsimd.html</a></p>",
        "id": 225608970,
        "sender_full_name": "oliver",
        "timestamp": 1612818742
    },
    {
        "content": "<p><a href=\"https://rust-lang.github.io/rfcs/2574-simd-ffi.html\">https://rust-lang.github.io/rfcs/2574-simd-ffi.html</a></p>",
        "id": 225609003,
        "sender_full_name": "oliver",
        "timestamp": 1612818762
    },
    {
        "content": "<p><a href=\"https://hackmd.io/SOHrC2_dRc2sPdwBliTbFw?both\">https://hackmd.io/SOHrC2_dRc2sPdwBliTbFw?both</a> Pow! An agenda</p>",
        "id": 225609053,
        "sender_full_name": "Jubilee",
        "timestamp": 1612818790
    },
    {
        "content": "<p>re PRs, on stdsimd or the RFC?</p>",
        "id": 225609183,
        "sender_full_name": "Edmund Cape",
        "timestamp": 1612818851
    },
    {
        "content": "<p>Hello is everyone here? I think <span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> might be in a docs meeting still? Wave hi! <span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span></p>",
        "id": 225609206,
        "sender_full_name": "Jubilee",
        "timestamp": 1612818865
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"388128\">@Edmund Cape</span> on stdsimd, as well as a recently closed one on rustc</p>",
        "id": 225609271,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612818905
    },
    {
        "content": "<p>Great minutes! Straight to the point :)<br>\n(I was referring to the agenda from <span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span> )</p>",
        "id": 225609279,
        "sender_full_name": "Edmund Cape",
        "timestamp": 1612818907
    },
    {
        "content": "<p>Hello Edmund! Oliver! Thom! Caleb! Wow, yes, actually lots of people.<br>\nThe RFCs are mostly useful background data to look at.</p>\n<p>So is this still a good time for people? It kind of looks like the answer is yes?</p>",
        "id": 225609504,
        "sender_full_name": "Jubilee",
        "timestamp": 1612819012
    },
    {
        "content": "<p>I think we should maybe still possibly pop a new scheduling calendar thing to make sure we aren't leaving anyone out or if there's better times, but it looks like we're good enough so unless something comes up as a better alternative we can probably stay the course.</p>",
        "id": 225610052,
        "sender_full_name": "Jubilee",
        "timestamp": 1612819266
    },
    {
        "content": "<p>re: branching<br>\nWe made a more-or-less decision a while back to omit panicking in debug mode for math and make the default addition also be equivalent to wrapping_add, do we want to make it a policy to write code in a way that minimizes branching unless it's already code involving masking?</p>",
        "id": 225610078,
        "sender_full_name": "Jubilee",
        "timestamp": 1612819277
    },
    {
        "content": "<p>Even if it involves masking, it can still be written branchless.  I think the policy should be more about if it makes sense to do without branching.  e.g. division by 0 <em>could</em> be handled branchless with masking, but I don't think it makes sense to do that</p>",
        "id": 225610320,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612819384
    },
    {
        "content": "<p>Right.</p>\n<p>I should also note though that a lot of simple <code>if else</code> cases get optimized out. I suppose we can't always rely on that, though.</p>",
        "id": 225610542,
        "sender_full_name": "Jubilee",
        "timestamp": 1612819479
    },
    {
        "content": "<p>Yeah.  I think more specifically we should avoid branch-panics if there is an alternative version of the function that doesn't have one.</p>",
        "id": 225610618,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612819522
    },
    {
        "content": "<p>I agree that wherever possible be explicit about not branching in the code as opposed to relying on the optimizer. If only to clarify intent.</p>",
        "id": 225610755,
        "sender_full_name": "Edmund Cape",
        "timestamp": 1612819579
    },
    {
        "content": "<p>Panicking <strong>is</strong> kind of a game-over, whereas a lot of the time during SIMD code you may just discard or zero out results that don't fall within accepted parameters.</p>",
        "id": 225611037,
        "sender_full_name": "Jubilee",
        "timestamp": 1612819727
    },
    {
        "content": "<p>I guess that makes a question of whether panicking on dividing by zero <strong>does</strong> make sense. :V<br>\nWith that in mind, what is the counterargument? I guess that we don't have a good way to do that in integer SIMD math, whereas in floats we could just pass on an infinity.</p>",
        "id": 225611281,
        "sender_full_name": "Jubilee",
        "timestamp": 1612819851
    },
    {
        "content": "<p>In integer math you could use a poison value that you pass on, but I think that should probably be up to the user to implement</p>",
        "id": 225611524,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612819963
    },
    {
        "content": "<p>Yeaaah.<br>\nI suppose that answers it for me. ^^;<br>\nSHUFFLES! <a href=\"https://github.com/rust-lang/stdsimd/pull/62\">https://github.com/rust-lang/stdsimd/pull/62</a><br>\nI documented the only question that came up so we can probably merge this?</p>",
        "id": 225611573,
        "sender_full_name": "Jubilee",
        "timestamp": 1612819986
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span> I had important, \"watching Stargate\" business &gt;_&gt;</p>",
        "id": 225611613,
        "sender_full_name": "Lokathor",
        "timestamp": 1612820002
    },
    {
        "content": "<p>StarGate is <em>very</em> important.</p>",
        "id": 225611660,
        "sender_full_name": "Jubilee",
        "timestamp": 1612820031
    },
    {
        "content": "<p>Yeah I think it's ready to merge.</p>",
        "id": 225611668,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612820035
    },
    {
        "content": "<p>Please feel free to \"offline\" my questions if they are off-course/not useful.  Quick question...</p>",
        "id": 225611765,
        "sender_full_name": "Edmund Cape",
        "timestamp": 1612820067
    },
    {
        "content": "<p>I think the next step I would like to have is non-parameterized shuffles since those can be immediately used without full const generics (and stabilized, wishful thinking)</p>",
        "id": 225611857,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612820109
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"388128\">@Edmund Cape</span> this is probably a good forum for general questions (and can always get split out to other zulip threads!)</p>",
        "id": 225611905,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612820139
    },
    {
        "content": "<p>Is the package expected to deal with divide by zero errors? When I look at the Intel intrinsics, id does not seem to UB when divide by zero. It just reports zero.</p>",
        "id": 225611931,
        "sender_full_name": "Edmund Cape",
        "timestamp": 1612820152
    },
    {
        "content": "<p>if we can just accept division by zero to do some predictable non-panic thing we should</p>",
        "id": 225612036,
        "sender_full_name": "Lokathor",
        "timestamp": 1612820188
    },
    {
        "content": "<p>The return description for divide by zero is different than sending unaligned mem when expecting aligned... example contrast.</p>",
        "id": 225612080,
        "sender_full_name": "Edmund Cape",
        "timestamp": 1612820212
    },
    {
        "content": "<p>Exactly what the machine does is not necessarily what we want to expose to users, especially because we then have to address Arm, RISCV, Power, etc.</p>",
        "id": 225612119,
        "sender_full_name": "Jubilee",
        "timestamp": 1612820226
    },
    {
        "content": "<p>right, if we can make a <em>general</em> claim we should. And maybe we should say \"division by 0 produces 0, though if the hardware won't do that we will do that for you and you won't like the performance there\"</p>",
        "id": 225612235,
        "sender_full_name": "Lokathor",
        "timestamp": 1612820281
    },
    {
        "content": "<p>Does anyone have a view of what ARM does with divide by zero?</p>",
        "id": 225612363,
        "sender_full_name": "Edmund Cape",
        "timestamp": 1612820328
    },
    {
        "content": "<p>So we're not trying to write the x86 SIMD API, we're trying to write a portable one.<br>\nIndeed they will not.</p>",
        "id": 225612373,
        "sender_full_name": "Jubilee",
        "timestamp": 1612820331
    },
    {
        "content": "<p>I would not be surprised if Arm does not even expose a SIMD div. Let me check.</p>",
        "id": 225612405,
        "sender_full_name": "Jubilee",
        "timestamp": 1612820348
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"388128\">@Edmund Cape</span> my understanding is that the Intel div intrinsics are not a single instruction, but resolve to a particular sequence of instructions with some particular behavior, but the actual idiv instruction will fail on a divide by zero</p>",
        "id": 225612454,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612820373
    },
    {
        "content": "<p>poop</p>",
        "id": 225612481,
        "sender_full_name": "Lokathor",
        "timestamp": 1612820383
    },
    {
        "content": "<p>Yeah, float divs only.</p>",
        "id": 225612509,
        "sender_full_name": "Jubilee",
        "timestamp": 1612820399
    },
    {
        "content": "<p>I don't believe intel actually provides a SIMD div, either.  It's just idiv used sequentially over the vector, I think</p>",
        "id": 225612589,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612820417
    },
    {
        "content": "<p>We basically just expose a div function not because it's fast but because, as Lokathor mentioned many meetings back, \"if you need to divide, you need to divide.\"</p>",
        "id": 225612684,
        "sender_full_name": "Jubilee",
        "timestamp": 1612820460
    },
    {
        "content": "<p>We could provide an implementation that does something similar, if we can agree on a behavior and API</p>",
        "id": 225612699,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612820467
    },
    {
        "content": "<p>non parameterized shuffles, <span class=\"user-mention\" data-user-id=\"312331\">@Caleb Zulawski</span>?</p>",
        "id": 225612827,
        "sender_full_name": "Jubilee",
        "timestamp": 1612820523
    },
    {
        "content": "<p>do you mean with dynamic indices instead of const ones?</p>",
        "id": 225612857,
        "sender_full_name": "Jubilee",
        "timestamp": 1612820541
    },
    {
        "content": "<p>No, I mean particular static shuffles that are typically fast on most or some hardware.  Reverse, interleave, things like that</p>",
        "id": 225612940,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612820583
    },
    {
        "content": "<p>Ah! yeah.</p>",
        "id": 225613003,
        "sender_full_name": "Jubilee",
        "timestamp": 1612820616
    },
    {
        "content": "<p>Just wrappers around the <code>shuffle</code> fn you wrote, but no const generics!</p>",
        "id": 225613019,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612820626
    },
    {
        "content": "<p>I am not sure if those don't resolve to... yeah, also shufflevector. ^^;</p>",
        "id": 225613042,
        "sender_full_name": "Jubilee",
        "timestamp": 1612820642
    },
    {
        "content": "<p>I think we should just come up with a variety of those that are common and useful</p>",
        "id": 225613117,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612820673
    },
    {
        "content": "<p>Mmm, I think we should file an issue and figure out what users want first on that front.</p>",
        "id": 225613207,
        "sender_full_name": "Jubilee",
        "timestamp": 1612820718
    },
    {
        "content": "<p>Masks! <a href=\"https://github.com/rust-lang/stdsimd/pull/61\">https://github.com/rust-lang/stdsimd/pull/61</a><br>\nIt's mostly getting caught on the finickiness of the Wasm SIMD test code.</p>",
        "id": 225613251,
        "sender_full_name": "Jubilee",
        "timestamp": 1612820749
    },
    {
        "content": "<p>Yeah, I briefly read through your comments.  I'll probably make the changes later today.  Hopefully it's ready to merge after addressing those?</p>",
        "id": 225613369,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612820795
    },
    {
        "content": "<p>Only as an FYI re SIMD div - I think it exists.  However, to a point made earlier, <code>Int</code> related.</p>\n<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"kr\">__m128i</span> <span class=\"n\">_mm_div_epi32</span> <span class=\"p\">(</span><span class=\"kr\">__m128i</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"kr\">__m128i</span> <span class=\"n\">b</span><span class=\"p\">)</span>\n<span class=\"n\">Synopsis</span>\n<span class=\"kr\">__m128i</span> <span class=\"n\">_mm_div_eci32</span> <span class=\"p\">(</span><span class=\"kr\">__m128i</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"kr\">__m128i</span> <span class=\"n\">b</span><span class=\"p\">)</span>\n<span class=\"cp\">#include</span> <span class=\"cpf\">&lt;immintrin.h&gt;</span><span class=\"cp\"></span>\n<span class=\"nl\">Instruction</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span>\n<span class=\"n\">CPUID</span> <span class=\"nl\">Flags</span><span class=\"p\">:</span> <span class=\"n\">SSE</span>\n<span class=\"n\">Description</span>\n<span class=\"n\">Divide</span> <span class=\"n\">packed</span> <span class=\"mi\">32</span><span class=\"o\">-</span><span class=\"n\">bit</span> <span class=\"n\">integers</span> <span class=\"n\">in</span> <span class=\"n\">a</span> <span class=\"n\">by</span> <span class=\"n\">packed</span> <span class=\"n\">elements</span> <span class=\"n\">in</span> <span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">and</span> <span class=\"n\">store</span> <span class=\"n\">the</span> <span class=\"n\">truncated</span> <span class=\"n\">results</span> <span class=\"n\">in</span> <span class=\"n\">dst</span><span class=\"p\">.</span>\n<span class=\"n\">Operation</span>\n<span class=\"n\">FOR</span> <span class=\"nl\">j</span> <span class=\"p\">:</span><span class=\"o\">=</span> <span class=\"mi\">0</span> <span class=\"n\">to</span> <span class=\"mi\">3</span>\n    <span class=\"nl\">i</span> <span class=\"p\">:</span><span class=\"o\">=</span> <span class=\"mi\">32</span><span class=\"o\">*</span><span class=\"n\">j</span>\n    <span class=\"n\">IF</span> <span class=\"n\">b</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"mi\">31</span><span class=\"o\">:</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"mi\">0</span>\n        <span class=\"cp\">#DE</span>\n    <span class=\"n\">FI</span>\n    <span class=\"n\">dst</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"mi\">31</span><span class=\"o\">:</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">:=</span> <span class=\"n\">Truncate32</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"mi\">31</span><span class=\"o\">:</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">/</span> <span class=\"n\">b</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"mi\">31</span><span class=\"o\">:</span><span class=\"n\">i</span><span class=\"p\">])</span>\n<span class=\"n\">ENDFOR</span>\n<span class=\"n\">dst</span><span class=\"p\">[</span><span class=\"nl\">MAX</span><span class=\"p\">:</span><span class=\"mi\">128</span><span class=\"p\">]</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n</code></pre></div>",
        "id": 225613452,
        "sender_full_name": "Edmund Cape",
        "timestamp": 1612820836
    },
    {
        "content": "<p>I would like to merge that in and update my proptest branch on that</p>",
        "id": 225613458,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612820843
    },
    {
        "content": "<p>Yeah, I think so, most of my comments were \"hm, maybe?\" thoughts rather than need-to-address except for the wasm tests one.</p>",
        "id": 225613501,
        "sender_full_name": "Jubilee",
        "timestamp": 1612820873
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"388128\">@Edmund Cape</span> That says \"Instruction: Sequence\" which is basically an admission that it generates a sequence of instructions, rather than generates a specific assembly instruction. It's not like <code>divps</code> or <code>divpd</code> which are packed divides of floats/doubles in xmm registers.</p>",
        "id": 225614142,
        "sender_full_name": "Jubilee",
        "timestamp": 1612821168
    },
    {
        "content": "<p>Yeah, I believe that intrinsic is part of SVML</p>",
        "id": 225614221,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612821205
    },
    {
        "content": "<p>It generates the instructions that use xmm registers for scalar division though which is why it uses \"SSE\" instructions.</p>",
        "id": 225614536,
        "sender_full_name": "Jubilee",
        "timestamp": 1612821346
    },
    {
        "content": "<p>alright now<br>\nthe contentious<br>\nnon-2^N vectors!</p>",
        "id": 225614695,
        "sender_full_name": "Jubilee",
        "timestamp": 1612821411
    },
    {
        "content": "<p>Well, the good news is that the rustc PR is merged, so we've deconflicted from cg_clif</p>",
        "id": 225614765,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612821451
    },
    {
        "content": "<p>As disappointing that a monomorpisation error is, it's \"okay\"</p>",
        "id": 225614811,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612821473
    },
    {
        "content": "<p>Much better than the ICEs I experienced <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 225614896,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612821502
    },
    {
        "content": "<p>I'm personally okay with allowing monomorpisation errors rather than using const_evaluatable_checked to catch the error.  I think it would come with all of the problems we are trying to avoid with the bitmasks</p>",
        "id": 225615199,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612821627
    },
    {
        "content": "<p>Additionally that would make the entirety of stdsimd stabilization blocked by const_evaluatable_checked.  I know stabilization is a long ways out but I have a feeling we will still be at the finish line first</p>",
        "id": 225615471,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612821730
    },
    {
        "content": "<p>(we probably have an easier problem to solve and fewer barriers to stabilization, I think)</p>",
        "id": 225615637,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612821789
    },
    {
        "content": "<p>here's the $64,000 question: when can we have this in nightly core?</p>",
        "id": 225615831,
        "sender_full_name": "Lokathor",
        "timestamp": 1612821859
    },
    {
        "content": "<p>I think if we comb through the API to make sure everything is okay, and maybe I finish proptesting to validate it a little better, we may be ready for that?</p>",
        "id": 225615975,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612821917
    },
    {
        "content": "<p>excellent</p>",
        "id": 225615996,
        "sender_full_name": "Lokathor",
        "timestamp": 1612821929
    },
    {
        "content": "<p>I think with shuffles and masks available you can do mostly everything</p>",
        "id": 225616023,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612821946
    },
    {
        "content": "<p>Trig is a large outstanding issue but I think it's relatively rarely used</p>",
        "id": 225616095,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612821969
    },
    {
        "content": "<p>Also with the rustc PR merged, I think it's stable enough for some level of public consumption?</p>",
        "id": 225616376,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612822122
    },
    {
        "content": "<p>For the stuff used for games yeah, plausibly. but in general... there's a lot of data manipulation instructions that are used in multimedia tasks, encoding too. <span class=\"user-mention\" data-user-id=\"314350\">@Henri Sivonen</span> mentioned being interested in porting his utf8 code (which uses packed_simd) to libcore once portable simd is available, and I suspect we couldn't do that as-is (Certainly we couldn't implement the stuff from the \"validating UTF-8 in less than 1 instruction per byte\" <a href=\"https://arxiv.org/abs/2010.03090\">https://arxiv.org/abs/2010.03090</a>, but I don't think we need to support parity with <em>all</em> intrinsics, and that uses direct hardware intrinsics)</p>\n<p>Concretely, IMO we should see what feature parity with packed_simd would look like.</p>",
        "id": 225616437,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1612822146
    },
    {
        "content": "<blockquote>\n<p>entirety of stdsimd stabilization blocked by const_evaluatable_checked</p>\n</blockquote>\n<p>What part of the const integration are you referring to?</p>",
        "id": 225616447,
        "sender_full_name": "Edmund Cape",
        "timestamp": 1612822152
    },
    {
        "content": "<p>That said the trig stuff is <em>way</em> more obscure IMO than these operations.</p>",
        "id": 225616470,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1612822168
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"209168\">@Thom Chiovoloni</span> if there's a particular set of ops worth prioritizing we can make a list</p>",
        "id": 225616587,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612822228
    },
    {
        "content": "<p>Uh, my comment is about being finished after shuffles / masks, not whetehr or not it should be publically available as unstable</p>",
        "id": 225616599,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1612822233
    },
    {
        "content": "<p>I mean do we even have stuff like packed min/max?</p>",
        "id": 225616781,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1612822327
    },
    {
        "content": "<p>I wouldn't say that trig stuff is super obscure</p>",
        "id": 225616819,
        "sender_full_name": "Lokathor",
        "timestamp": 1612822345
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"388128\">@Edmund Cape</span> there's a long saga around this, but <a href=\"https://github.com/rust-lang/stdsimd/issues/50\">https://github.com/rust-lang/stdsimd/issues/50</a> may be the place to start. Basically, the issue is with bounds on const generics leaking into the public API</p>",
        "id": 225616823,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612822348
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/2021-02-08.20Meeting.2E/near/225616819\">said</a>:</p>\n<blockquote>\n<p>I wouldn't say that trig stuff is super obscure</p>\n</blockquote>\n<p>I think it's just a very visible thing since its a difference from f32/f64, but almost no cpus support it, and existing simd code won't expect it.</p>",
        "id": 225616922,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1612822408
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"209168\">@Thom Chiovoloni</span> <span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> my point was really that there's quite a bit you can do with just arithmetic, comparisons and shuffles, not that we are done <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 225616938,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612822419
    },
    {
        "content": "<p>I'll agree there</p>",
        "id": 225616969,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1612822435
    },
    {
        "content": "<p>Yes, I vaguely understand that issue.  However, I also thought it was made moot because <code>[T; CONST]</code> is now stable... No?</p>",
        "id": 225617022,
        "sender_full_name": "Edmund Cape",
        "timestamp": 1612822444
    },
    {
        "content": "<p>That is stable, but using a const fn in the array length is not</p>",
        "id": 225617056,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612822470
    },
    {
        "content": "<p>And has some unfortunate implications currently</p>",
        "id": 225617077,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612822486
    },
    {
        "content": "<p>one problem is that if you set the array size too high then things explode in gross error messages, which isn't something people will want to do in practice, but people make typos and error messages should make sense when it happens</p>",
        "id": 225617156,
        "sender_full_name": "Lokathor",
        "timestamp": 1612822520
    },
    {
        "content": "<p>Actually now the error messages have the opposite problem, short and lacking context. If you know what it means you can easily figure it out, but it's very user-hostile</p>",
        "id": 225617310,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612822587
    },
    {
        "content": "<p>ah, yeah, i didn't mean that they're long error messages, like some async stuff does, but that the build will fail in a hostile way, yeah</p>",
        "id": 225617407,
        "sender_full_name": "Lokathor",
        "timestamp": 1612822644
    },
    {
        "content": "<p>Is the explosion unacceptable?  I ask because it seems to me that when I try to instantiate a large array on the stack I get an mem overload error.  <br>\nSo, par for the course?</p>",
        "id": 225617423,
        "sender_full_name": "Edmund Cape",
        "timestamp": 1612822653
    },
    {
        "content": "<p>\"Vector size must be a power of two\" isnt the worst message until you can't figure out which vector caused it</p>",
        "id": 225617444,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612822666
    },
    {
        "content": "<p>In my opinion it's absolutely acceptable for an unstable feature but should be better</p>",
        "id": 225617621,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612822697
    },
    {
        "content": "<p>yeah, the error can end up being somewhat.. uh... \"non local\" to the actual trigger for the error</p>",
        "id": 225617635,
        "sender_full_name": "Lokathor",
        "timestamp": 1612822699
    },
    {
        "content": "<p>ah, and yeah it'd be fine for Nightly</p>",
        "id": 225617746,
        "sender_full_name": "Lokathor",
        "timestamp": 1612822723
    },
    {
        "content": "<p>but would prevent stabilizing even the simple arithmetic until we can solve it</p>",
        "id": 225617796,
        "sender_full_name": "Lokathor",
        "timestamp": 1612822737
    },
    {
        "content": "<p>I think it's trivially solvable by making it a type of layout error but I'm not sure that's the way to go</p>",
        "id": 225617877,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612822784
    },
    {
        "content": "<p>But I think it may be better to ignore rather than drag in const_evaluatable_checked for now</p>",
        "id": 225617966,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612822817
    },
    {
        "content": "<p>Considering that would prevent using rustdoc and also force all users to use an incomplete feature</p>",
        "id": 225618019,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612822856
    },
    {
        "content": "<p>i mean, <em>right now</em>, in the initial phase, it would be fine to literally lock all lane counts to say, 16 or less</p>",
        "id": 225618084,
        "sender_full_name": "Lokathor",
        "timestamp": 1612822891
    },
    {
        "content": "<p>or 32, or pick any number, i don't care which number too much</p>",
        "id": 225618096,
        "sender_full_name": "Lokathor",
        "timestamp": 1612822902
    },
    {
        "content": "<p>Right, but how to do that?</p>",
        "id": 225618121,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612822917
    },
    {
        "content": "<p>T-compiler knows, not me XD</p>",
        "id": 225618171,
        "sender_full_name": "Lokathor",
        "timestamp": 1612822931
    },
    {
        "content": "<p>64 for bytes on avx512, and for SimpleV</p>",
        "id": 225618175,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1612822934
    },
    {
        "content": "<p>We could use the LanesUpTo64 or whatever that trait is called, on all vectors</p>",
        "id": 225618202,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612822956
    },
    {
        "content": "<p>I think that <span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> would be proud</p>",
        "id": 225618235,
        "sender_full_name": "Lokathor",
        "timestamp": 1612822975
    },
    {
        "content": "<p>The one added in my mask PR</p>",
        "id": 225618236,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612822976
    },
    {
        "content": "<p>LanesAtMost64</p>",
        "id": 225618266,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612822994
    },
    {
        "content": "<p>wait, we can't just name it <code>LE64</code>? :P (joking)</p>",
        "id": 225618351,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1612823047
    },
    {
        "content": "<p>yeah, u64 is fine for now.</p>",
        "id": 225618440,
        "sender_full_name": "Jubilee",
        "timestamp": 1612823129
    },
    {
        "content": "<p>It would make the API slightly noiser, but that bound should be inferred in most cases anyway</p>",
        "id": 225618566,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612823200
    },
    {
        "content": "<p>Mostly just slightly annoying in the docs and that's it</p>",
        "id": 225618615,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612823227
    },
    {
        "content": "<p>And yeah, I think we're pretty close to pushing this into nightly.</p>",
        "id": 225618659,
        "sender_full_name": "Jubilee",
        "timestamp": 1612823252
    },
    {
        "content": "<p>Much less annoying than a broken const fn bound</p>",
        "id": 225618670,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612823258
    },
    {
        "content": "<p>so if we just limit lane counts to 64 or less, then things should be sturdy enough for the full crate in Nightly, and <em>arithmetic</em> should be study enough for being the first Stabilization goal?</p>",
        "id": 225618673,
        "sender_full_name": "Lokathor",
        "timestamp": 1612823261
    },
    {
        "content": "<p>So the min lane width is 1-bit?</p>",
        "id": 225618800,
        "sender_full_name": "Edmund Cape",
        "timestamp": 1612823305
    },
    {
        "content": "<p>i think non-mask values have a minimum size of 1 byte per lane</p>",
        "id": 225618831,
        "sender_full_name": "Lokathor",
        "timestamp": 1612823328
    },
    {
        "content": "<p>It's 8 bits, except for bitmasks which have 1 bit lanes</p>",
        "id": 225618835,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612823330
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> Basically yeah, that's more or less what we're expecting. We want to start improving rustc's actual capabilities so that the API compiles better, basically, but from an <strong>API</strong> perspective we're close to being able to ship those.</p>",
        "id": 225618939,
        "sender_full_name": "Jubilee",
        "timestamp": 1612823387
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> I think we'll want to be sure that the API is safe to stabilize while being able to remove the LanesAtMost64 trait in the future, but other than that, yes</p>",
        "id": 225618949,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612823390
    },
    {
        "content": "<p>Unfortunately, unlike ArrayAtMost64, which only applied to trait implementations, this applies to the type definition as well</p>",
        "id": 225619108,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612823441
    },
    {
        "content": "<p>And it being a target doesn't mean it has to happen precisely right away or precisely in that order, just as a named goal is all</p>",
        "id": 225619116,
        "sender_full_name": "Lokathor",
        "timestamp": 1612823445
    },
    {
        "content": "<p><code>core_simd_arithmetic</code> seems fine for our feature flag.</p>",
        "id": 225619182,
        "sender_full_name": "Jubilee",
        "timestamp": 1612823477
    },
    {
        "content": "<p>so, for <code>LanesAtMost64</code> will that be namable by 3rd party sw, or will that be std-private?</p>",
        "id": 225619187,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1612823481
    },
    {
        "content": "<p>So bitmasks have min lane size of 1-bit?  The terminology of lanes to describe bit operations seems a little unusual.</p>",
        "id": 225619238,
        "sender_full_name": "Edmund Cape",
        "timestamp": 1612823508
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"229517\">@Jacob Lifshay</span> I think it will be inherently unstable, and never stabilize, since it will eventually be removed</p>",
        "id": 225619298,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612823527
    },
    {
        "content": "<p>But it will be public until it is removed.</p>",
        "id": 225619330,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612823548
    },
    {
        "content": "<p>(identical to ArrayAtMost64 in that way)</p>",
        "id": 225619375,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612823583
    },
    {
        "content": "<p>some cpus do treat individual bitmask bits as individual lanes, that will happen to some extent in Libre-SOC's cpu</p>",
        "id": 225619394,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1612823592
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"388128\">@Edmund Cape</span>  So, there's \"full masks\" and \"bitmasks\". a full mask is a vector with lanes of a certain element size and all the bits in that lane are set to 1 or 0, this is used in NEON and some Intel ISAs. The bitmask is used in some Intel instructions as well, and most notably in the AVX512 instruction set, and a bitmask is basically just a u32 or whatever. <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 225619454,
        "sender_full_name": "Jubilee",
        "timestamp": 1612823617
    },
    {
        "content": "<p>It's also roughly equivalent to the k registers in AVX-512</p>",
        "id": 225619466,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612823623
    },
    {
        "content": "<p>Will <code>LanesAtMost64</code> ever be used  to describe a bit-wise operation?</p>",
        "id": 225619482,
        "sender_full_name": "Edmund Cape",
        "timestamp": 1612823630
    },
    {
        "content": "<p>Yes, right now that's the only place I have it used</p>",
        "id": 225619547,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612823647
    },
    {
        "content": "<p>often, yes, either shoved into the low/high bits of a SIMD register, in a normal scalar register, or in a special register.</p>",
        "id": 225619552,
        "sender_full_name": "Jubilee",
        "timestamp": 1612823650
    },
    {
        "content": "<p>e.g. an operation using the bottom bit can finish executing before the top bit is computed thanks to out-of-order execution, similar to Cray-1's vector chaining</p>",
        "id": 225619574,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1612823665
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"388128\">@Edmund Cape</span> so there's two things: a \"bitwise operation\" such as AND / OR / XOR works on the bit pattern of the SIMD value. <em>separately</em> there's a \"bit mask\" which is a mask value (\"truthy\") where only true and false are stored. The minimum required to store true/false is obviously 1 bit each, but there's still some masks that are actually 1 bit each, and some masks that are a full lane width each (eg: masks used with i32x4 would be 32 bits per lane, all bits 1 or all bits 0).</p>",
        "id": 225619636,
        "sender_full_name": "Lokathor",
        "timestamp": 1612823712
    },
    {
        "content": "<p>there are also a few cpus with masks somewhere between bitmasks and full-lane masks</p>",
        "id": 225619687,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1612823758
    },
    {
        "content": "<p>and i like the engineers who invented those even less</p>",
        "id": 225619750,
        "sender_full_name": "Lokathor",
        "timestamp": 1612823780
    },
    {
        "content": "<p>abstracting over all of these details in a way that is portable and also allows people to, if necessary, do conversions that move from using our API to using architecture intrinsics, is the challenge of our API design and the source of many, many... spirited conversations!</p>",
        "id": 225619816,
        "sender_full_name": "Jubilee",
        "timestamp": 1612823839
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"312331\">@Caleb Zulawski</span> the distinction between running a bitwise operation on the register vs the lanes on the register makes sense as you describe it.  That distinction is required to understand where the scope for <code>LanesAtMost64</code> makes sense... this said, maybe it's the inclusion of <code>Lane</code> in <code>LanesAtMost64</code> that's having me ask.</p>",
        "id": 225619830,
        "sender_full_name": "Edmund Cape",
        "timestamp": 1612823848
    },
    {
        "content": "<p>Libre-SOC's cpu technically uses either 1-bit per lane masks or 4-bit per lane masks, I just decided that the 4-bit per lane masks won't ever be ABI visible</p>",
        "id": 225619879,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1612823877
    },
    {
        "content": "<p>this is a good point in that the trait might as well be named MaxLen64</p>",
        "id": 225619939,
        "sender_full_name": "Jubilee",
        "timestamp": 1612823887
    },
    {
        "content": "<p>Yeah, in the case of bitmasks, it's because the size of the bitmask is related to the number of lanes of the vector the bitmask is compatible with, not something specific about the bitmask itself</p>",
        "id": 225619988,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612823916
    },
    {
        "content": "<p>I think that within reason the api shouldn't shy away from using the term \"lane\" immediately and often. It simply won't make sense to read much of the documentation without knowing what a lane is, so you should see it a lot and then have a clear glossary that says what it means</p>",
        "id": 225620080,
        "sender_full_name": "Lokathor",
        "timestamp": 1612823979
    },
    {
        "content": "<p>It's encoded in the type, but doesn't actually change how it's used in-register</p>",
        "id": 225620081,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612823979
    },
    {
        "content": "<p>we could be extra clear that a bitmask and a bitwise operation are not related</p>",
        "id": 225620186,
        "sender_full_name": "Lokathor",
        "timestamp": 1612824026
    },
    {
        "content": "<p>we can also mention that lane is interchangable with element in the glossary</p>",
        "id": 225620239,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1612824047
    },
    {
        "content": "<p>masks (bitmasks or fullmasks) are generally used to merge data from two sources</p>",
        "id": 225620275,
        "sender_full_name": "Lokathor",
        "timestamp": 1612824068
    },
    {
        "content": "<p>either through a \"blend\" or a load/store</p>",
        "id": 225620300,
        "sender_full_name": "Lokathor",
        "timestamp": 1612824083
    },
    {
        "content": "<p>Perhaps it is worth reconsidering splitting masks into their own module so they can be independently documented and grouped together</p>",
        "id": 225620312,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612824094
    },
    {
        "content": "<p>So it's a little clearer they are different from normal simd vectors in some way</p>",
        "id": 225620331,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612824109
    },
    {
        "content": "<p>or in the case of SimpleV, any predicated instruction</p>",
        "id": 225620336,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1612824112
    },
    {
        "content": "<p>\"yes and\"</p>",
        "id": 225620344,
        "sender_full_name": "Lokathor",
        "timestamp": 1612824117
    },
    {
        "content": "<p>i think they should go in a sub-module with a public use::* in the upper module</p>",
        "id": 225620424,
        "sender_full_name": "Lokathor",
        "timestamp": 1612824137
    },
    {
        "content": "<p><code>Lane</code> ~ <code>Element</code> makes good sense;  so much so, I'm sure when they diverge...</p>",
        "id": 225620425,
        "sender_full_name": "Edmund Cape",
        "timestamp": 1612824137
    },
    {
        "content": "<p>so that importing isn't complicated, but docs place them separately</p>",
        "id": 225620433,
        "sender_full_name": "Lokathor",
        "timestamp": 1612824147
    },
    {
        "content": "<p>personally i generally think of the element as being the type of each lane (i32, u32, f64, etc), but that could just be me</p>",
        "id": 225620521,
        "sender_full_name": "Lokathor",
        "timestamp": 1612824208
    },
    {
        "content": "<p>oh, I just call that element type</p>",
        "id": 225620580,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1612824241
    },
    {
        "content": "<p>Is there anywhere else in std that has a public module with a reexport? (Other than the prelude)</p>",
        "id": 225620657,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612824286
    },
    {
        "content": "<p>The scope of my comment was only in terms of count.  I'm not sure that anywhere in the transformation/computation I would have more elements than lanes... Do you know what I mean?</p>",
        "id": 225620678,
        "sender_full_name": "Edmund Cape",
        "timestamp": 1612824305
    },
    {
        "content": "<p>std::collections::HashMap</p>",
        "id": 225620689,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1612824312
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"388128\">@Edmund Cape</span> yes, i follow. in that sense they're equivalent terms.</p>",
        "id": 225620734,
        "sender_full_name": "Lokathor",
        "timestamp": 1612824347
    },
    {
        "content": "<p>also std re-exports core::arch</p>",
        "id": 225620788,
        "sender_full_name": "Lokathor",
        "timestamp": 1612824363
    },
    {
        "content": "<p>Re bitmasks: In the terminology, does it imply that they operate on the register or lanes?</p>",
        "id": 225620837,
        "sender_full_name": "Edmund Cape",
        "timestamp": 1612824395
    },
    {
        "content": "<p>lanes are purely logical</p>",
        "id": 225620870,
        "sender_full_name": "Lokathor",
        "timestamp": 1612824411
    },
    {
        "content": "<p>they're just a way to understand what parts of a register are being affected</p>",
        "id": 225620905,
        "sender_full_name": "Lokathor",
        "timestamp": 1612824433
    },
    {
        "content": "<p>operations are always on registers</p>",
        "id": 225620914,
        "sender_full_name": "Lokathor",
        "timestamp": 1612824441
    },
    {
        "content": "<p>(or parts of registers, etc, many cpu types they're not all the same, yada yada)</p>",
        "id": 225620991,
        "sender_full_name": "Lokathor",
        "timestamp": 1612824482
    },
    {
        "content": "<p>Ah.  My understanding of a bitmask is that it operates on a lane.  So, I will make as many bitmasks as number of lanes.  Is this an unusual way to see it?</p>",
        "id": 225621057,
        "sender_full_name": "Edmund Cape",
        "timestamp": 1612824523
    },
    {
        "content": "<p>ah, that would be incorrect</p>",
        "id": 225621077,
        "sender_full_name": "Lokathor",
        "timestamp": 1612824540
    },
    {
        "content": "<p>one bitmask is used for an entire operation, and each lane of the bitmask affects a lane of the operation being performed.</p>",
        "id": 225621119,
        "sender_full_name": "Lokathor",
        "timestamp": 1612824573
    },
    {
        "content": "<p>the way I see it is a bitmask is really a vector of bools (with different representation), they have to have the same lane count as other bool/non-bool vectors they're used with</p>",
        "id": 225621237,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1612824626
    },
    {
        "content": "<p>most operations are <code>op(a,b)</code>, and masked operations are <code>op(a,b,control_mask)</code></p>",
        "id": 225621239,
        "sender_full_name": "Lokathor",
        "timestamp": 1612824626
    },
    {
        "content": "<p>Ok.  Where I got that impression was from Intel (all good if not a norm).  When describing an operation an a 512-bit vector:</p>\n<blockquote>\n<p>Add 16-bit masks in a and b, and store the result in k.</p>\n</blockquote>",
        "id": 225621263,
        "sender_full_name": "Edmund Cape",
        "timestamp": 1612824651
    },
    {
        "content": "<p>i'm not sure where the larger quote is from so i'm not clear on the context</p>",
        "id": 225621309,
        "sender_full_name": "Lokathor",
        "timestamp": 1612824690
    },
    {
        "content": "<p>but just from that, \"the result\" (singular) is being stored in <code>k</code>, so just one mask is produced</p>",
        "id": 225621335,
        "sender_full_name": "Lokathor",
        "timestamp": 1612824709
    },
    {
        "content": "<p><code>__mmask16 _kadd_mask16 (__mmask16 a, __mmask16 b)</code><br>\nSynopsis</p>\n<div class=\"codehilite\"><pre><span></span><code>#include &lt;immintrin.h&gt;\nInstruction: kaddw k, k, k\nCPUID Flags: AVX512DQ\nDescription\nAdd 16-bit masks in a and b, and store the result in k.\nOperation\nk[15:0] := a[15:0] + b[15:0]\nk[MAX:16] := 0\n</code></pre></div>",
        "id": 225621349,
        "sender_full_name": "Edmund Cape",
        "timestamp": 1612824717
    },
    {
        "content": "<p>hmm, that sounds like an operation on 16-bit values, not 512-bit values. regardless, the vector has 16 lanes</p>",
        "id": 225621404,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1612824729
    },
    {
        "content": "<p>yeah, for whatever reason, this lets you add together two 16-bit mask values. so similar to <code>u16 + u16</code>, and you get 16 bits of output. Not sure <em>why</em> you'd to that, but you apparently can</p>",
        "id": 225621492,
        "sender_full_name": "Lokathor",
        "timestamp": 1612824788
    },
    {
        "content": "<p>&lt;Intel&gt; \"look\"</p>",
        "id": 225621536,
        "sender_full_name": "Jubilee",
        "timestamp": 1612824821
    },
    {
        "content": "<p>probably because they could...</p>",
        "id": 225621542,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1612824825
    },
    {
        "content": "<p>But then what's up with <code>k[MAX:16] := 0</code>?</p>",
        "id": 225621565,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612824835
    },
    {
        "content": "<p>&lt;Intel&gt; \"we already had to implement an adder for other functions\"</p>",
        "id": 225621567,
        "sender_full_name": "Jubilee",
        "timestamp": 1612824838
    },
    {
        "content": "<p>lol</p>",
        "id": 225621615,
        "sender_full_name": "Jubilee",
        "timestamp": 1612824846
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> \"covering their butts against the future\". masks might be bigger in the future, hither bits are 0 by this operation</p>",
        "id": 225621622,
        "sender_full_name": "Lokathor",
        "timestamp": 1612824860
    },
    {
        "content": "<p>oh, <code>MAX=16</code> here?</p>",
        "id": 225621644,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612824877
    },
    {
        "content": "<p>yes.</p>",
        "id": 225621646,
        "sender_full_name": "Jubilee",
        "timestamp": 1612824881
    },
    {
        "content": "<p>this is basically describing from the tallest bit down to the 16th bit</p>",
        "id": 225621684,
        "sender_full_name": "Jubilee",
        "timestamp": 1612824905
    },
    {
        "content": "<p>max = 16 <em>now</em>, but considering that avx 256-bit registers are actually just bigger sse 128-bit registers, it's sane to say \"those registers might be bigger 10 years from now\"</p>",
        "id": 225621691,
        "sender_full_name": "Lokathor",
        "timestamp": 1612824911
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/2021-02-08.20Meeting.2E/near/225621565\">said</a>:</p>\n<blockquote>\n<p>But then what's up with <code>k[MAX:16] := 0</code>?</p>\n</blockquote>\n<p>that means that the instruction works on 16-bits and if the k register is bigger than 16-bits the upper bits are zeroed</p>",
        "id": 225621694,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1612824912
    },
    {
        "content": "<p>tol'lest</p>",
        "id": 225621700,
        "sender_full_name": "Jubilee",
        "timestamp": 1612824914
    },
    {
        "content": "<p>aren't there already k registers that can have 64 bits</p>",
        "id": 225621717,
        "sender_full_name": "Jubilee",
        "timestamp": 1612824929
    },
    {
        "content": "<p>In fact, masks are already bigger in the future, they are 64 bits if you have AVX-512BW</p>",
        "id": 225621723,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612824933
    },
    {
        "content": "<p>Yeah, that</p>",
        "id": 225621728,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612824937
    },
    {
        "content": "<p>yeah</p>",
        "id": 225621731,
        "sender_full_name": "Jubilee",
        "timestamp": 1612824938
    },
    {
        "content": "<p>If useful here is the link to the [because they can intrinsics] (<a href=\"https://software.intel.com/sites/landingpage/IntrinsicsGuide/#!=undefined&amp;expand=2125,2124,2123,413,402,305,304,2121,85,3536,3508,203,2030,2033,3206,3210&amp;cats=Mask\">https://software.intel.com/sites/landingpage/IntrinsicsGuide/#!=undefined&amp;expand=2125,2124,2123,413,402,305,304,2121,85,3536,3508,203,2030,2033,3206,3210&amp;cats=Mask</a>) :))</p>",
        "id": 225621746,
        "sender_full_name": "Edmund Cape",
        "timestamp": 1612824950
    },
    {
        "content": "<p>well, \"the future\" of whenever that op code's spec was written</p>",
        "id": 225621815,
        "sender_full_name": "Lokathor",
        "timestamp": 1612824982
    },
    {
        "content": "<p>for all i know that's a 5 year old instruction or something</p>",
        "id": 225621827,
        "sender_full_name": "Lokathor",
        "timestamp": 1612824992
    },
    {
        "content": "<p>When I think about masks in context of a vector, I think about a mask for each lane/element in my vector.</p>",
        "id": 225621932,
        "sender_full_name": "Edmund Cape",
        "timestamp": 1612825056
    },
    {
        "content": "<p>yes but they're bit-packed, that's why they're a bitmask. So a mask to cover 16 lanes, bitpacked, it a u16</p>",
        "id": 225622023,
        "sender_full_name": "Lokathor",
        "timestamp": 1612825098
    },
    {
        "content": "<p>and bit 0 of the u16 affects lane 0 of the operation, bit 1 affects lane 1, etc etc</p>",
        "id": 225622066,
        "sender_full_name": "Lokathor",
        "timestamp": 1612825130
    },
    {
        "content": "<p>Without that unified view of lane ~ element that would imply that I'm somehow able to do a ~horizontal <br>\n computation.  Or at least, not performing the same transformation on each element.</p>",
        "id": 225622082,
        "sender_full_name": "Edmund Cape",
        "timestamp": 1612825137
    },
    {
        "content": "<p>i can't speak to that. as i said, element is not a term i normally use at all when talking about simd, so whatever people wanna say \"element\" means is up to them</p>",
        "id": 225622166,
        "sender_full_name": "Lokathor",
        "timestamp": 1612825187
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/2021-02-08.20Meeting.2E/near/225618235\">said</a>:</p>\n<blockquote>\n<p>I think that <span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> would be proud</p>\n</blockquote>\n<p>Who'd have thought this would be my lasting legacy...</p>",
        "id": 225622167,
        "sender_full_name": "scottmcm",
        "timestamp": 1612825188
    },
    {
        "content": "<p>anyways!<br>\nit seems we have reached the \"discussing minutiae of the avx512 API\" part of the meeting! :^)<br>\nSo I think basically we're aiming at</p>\n<ol start=\"0\">\n<li>audit our API for necessities</li>\n<li>maybe \"static shuffles\" (interleave, etc.)?</li>\n<li>initially launching to the <code>core_simd_arithmetic</code> feature flag</li>\n</ol>",
        "id": 225622288,
        "sender_full_name": "Jubilee",
        "timestamp": 1612825236
    },
    {
        "content": "<p>lanes/elements on two vectors don't have to be the same size to have the same vector element count -- exactly what's happening with bitmasks</p>",
        "id": 225622290,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1612825237
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span> sounds good to me!</p>",
        "id": 225622619,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1612825427
    },
    {
        "content": "<p>Agree.  Likely a by-product of vector vs scalar. I'm only talking about the construction of a bitmask for a specific vector.  Vectors have several lanes.  In this context, lanes ~ elements is ok the way I'm thinking about it.  During the construction, I think about a bitmask, repeat the value (bitmask value) to load the vector, apply.</p>",
        "id": 225622694,
        "sender_full_name": "Edmund Cape",
        "timestamp": 1612825446
    },
    {
        "content": "<p>Good night everyone.</p>",
        "id": 225623178,
        "sender_full_name": "Edmund Cape",
        "timestamp": 1612825706
    },
    {
        "content": "<p>hmm, for me, a bitmask is just a vector where each lane is 1 bit. it can be created by a vector compare instruction, which sets the corresponding bit for each output lane to the comparison result for each input lane. the bitmask can then be used in a predicated instruction, where the instruction writes to the output register's N-bit wide lanes only where the corresponding 1-bit-wide lanes in the bitmask are a 1</p>",
        "id": 225623362,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1612825832
    },
    {
        "content": "<p>Huzzah. ^_^ Nightly Soon™<br>\n<a href=\"https://www.youtube.com/watch?v=AD6hV6XSgFo\">https://www.youtube.com/watch?v=AD6hV6XSgFo</a></p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"AD6hV6XSgFo\" href=\"https://www.youtube.com/watch?v=AD6hV6XSgFo\"><img src=\"https://i.ytimg.com/vi/AD6hV6XSgFo/default.jpg\"></a></div>",
        "id": 225623376,
        "sender_full_name": "Jubilee",
        "timestamp": 1612825842
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"229517\">@Jacob Lifshay</span> Fair enough.  It's something I'll keep an eye out for to make sure I'm not injecting a meaning that isn't universal. Thank you for that.</p>",
        "id": 225629820,
        "sender_full_name": "Edmund Cape",
        "timestamp": 1612830491
    }
]