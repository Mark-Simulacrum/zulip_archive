[
    {
        "content": "<p>In <a href=\"https://github.com/rust-lang/rust/pull/89167\">https://github.com/rust-lang/rust/pull/89167</a></p>",
        "id": 254453151,
        "sender_full_name": "Jubilee",
        "timestamp": 1632351640
    },
    {
        "content": "<p>Probably don't need to mention this explicitly in the PR, but we should make a note in our update post that we _do not_ have an RFC yet, and that the RFC comes after we experiment and are ready to propose the change</p>",
        "id": 254453935,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1632351997
    },
    {
        "content": "<p>Since multiple people have been confused by that</p>",
        "id": 254453951,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1632352005
    },
    {
        "content": "<p>Okay.</p>",
        "id": 254453959,
        "sender_full_name": "Jubilee",
        "timestamp": 1632352015
    },
    {
        "content": "<p>Took a quick look at the PR, lgtm</p>",
        "id": 254454187,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1632352147
    },
    {
        "content": "<p>I just realized no one is actually going to be able to use it due to the x86-64 codegen bug :)</p>",
        "id": 254457585,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1632354374
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/PR.20open.20to.20rust-lang.2Frust/near/254457585\">said</a>:</p>\n<blockquote>\n<p>I just realized no one is actually going to be able to use it due to the x86-64 codegen bug :)</p>\n</blockquote>\n<p>The second LLVM update that fixes that (supposedly) is already in the queue. <a href=\"https://github.com/rust-lang/rust/pull/89130\">https://github.com/rust-lang/rust/pull/89130</a></p>",
        "id": 254457709,
        "sender_full_name": "Jubilee",
        "timestamp": 1632354483
    },
    {
        "content": "<p>I am Not Mentioning it in the PR because by the time this goes in it <strong>should</strong> work again lmao</p>",
        "id": 254457901,
        "sender_full_name": "Jubilee",
        "timestamp": 1632354641
    },
    {
        "content": "<p>Okay, hm. Now I have to see if I can follow up on the latest review... <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 260855743,
        "sender_full_name": "Jubilee",
        "timestamp": 1636489576
    },
    {
        "content": "<p>I didn't comment, but I think the argument for removing the entirety of the module from bootstrap is that we would need to remove way too much interconnected code in std::simd</p>",
        "id": 260855967,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636489687
    },
    {
        "content": "<p>It's possible, it would just be a bit of a mess, and yeah we might not even need it anymore</p>",
        "id": 260856037,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636489719
    },
    {
        "content": "<p>It's unfortunately still needed, it seems. I don't pass x.py check otherwise.</p>",
        "id": 260860416,
        "sender_full_name": "Jubilee",
        "timestamp": 1636491638
    },
    {
        "content": "<p>I think it's actually possible to factor it out though.</p>",
        "id": 260860495,
        "sender_full_name": "Jubilee",
        "timestamp": 1636491671
    },
    {
        "content": "<p>What do you mean?</p>",
        "id": 260860651,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636491723
    },
    {
        "content": "<p>Oh, I think we can attach <code>#[cfg(not(bootstrap))]</code> to an internal module of ours.</p>",
        "id": 260860754,
        "sender_full_name": "Jubilee",
        "timestamp": 1636491763
    },
    {
        "content": "<p>Yeah, seems to pass just fine.</p>",
        "id": 260860793,
        "sender_full_name": "Jubilee",
        "timestamp": 1636491786
    },
    {
        "content": "<p>Wouldn't we need to remove everything that uses swizzling as well? Or can we do literally just the swizzle module</p>",
        "id": 260860817,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636491800
    },
    {
        "content": "<p>Yeah just the entire swizzle module and the intrinsics.</p>",
        "id": 260860851,
        "sender_full_name": "Jubilee",
        "timestamp": 1636491814
    },
    {
        "content": "<p>The intrinsics within the extern block?</p>",
        "id": 260860891,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636491835
    },
    {
        "content": "<p>That's not too bad</p>",
        "id": 260860898,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636491838
    },
    {
        "content": "<p>Yeah.</p>",
        "id": 260860901,
        "sender_full_name": "Jubilee",
        "timestamp": 1636491840
    },
    {
        "content": "<p>Yeah that sounds good to me</p>",
        "id": 260860978,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636491860
    },
    {
        "content": "<p>re: <a href=\"https://github.com/rust-lang/rust/pull/88868\">https://github.com/rust-lang/rust/pull/88868</a><br>\nI am confused, why is it okay to disable the test?</p>",
        "id": 260861845,
        "sender_full_name": "Jubilee",
        "timestamp": 1636492279
    },
    {
        "content": "<p>Mostly because we don't actually have any way of confirming if the test works or doesn't on anything big endian</p>",
        "id": 260861988,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636492339
    },
    {
        "content": "<p>(in portable-simd we reverse the bits and it worked in our tests)</p>",
        "id": 260862023,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636492363
    },
    {
        "content": "<p>Uhh...</p>",
        "id": 260862276,
        "sender_full_name": "Jubilee",
        "timestamp": 1636492464
    },
    {
        "content": "<p>For portable-simd I am okay with disabling a test if we can confirm it actually works on a real big endian machine but that seemed like an acceptable choice only because <span class=\"user-mention\" data-user-id=\"229517\">@Jacob Lifshay</span> confirmed it had to be a QEMU bug.</p>",
        "id": 260862376,
        "sender_full_name": "Jubilee",
        "timestamp": 1636492515
    },
    {
        "content": "<p>(there are no big-endian tier 1 targets)</p>",
        "id": 260862383,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636492517
    },
    {
        "content": "<p>No, you have it backwards I think</p>",
        "id": 260862413,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636492535
    },
    {
        "content": "<p>I am confused now.</p>",
        "id": 260862437,
        "sender_full_name": "Jubilee",
        "timestamp": 1636492544
    },
    {
        "content": "<p>well, powerpc64le is little-endian</p>",
        "id": 260862450,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636492551
    },
    {
        "content": "<p>Oh right.</p>",
        "id": 260862521,
        "sender_full_name": "Jubilee",
        "timestamp": 1636492574
    },
    {
        "content": "<p>so failing on that has nothing to do with big-endian</p>",
        "id": 260862522,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636492575
    },
    {
        "content": "<p>In that pull request I disabled the rust ui tests</p>",
        "id": 260862533,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636492581
    },
    {
        "content": "<p>On big endian</p>",
        "id": 260862551,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636492594
    },
    {
        "content": "<p>Because we simply don't even have a big endian tier 1 system anyway so the test could be totally wrong and still pass CI</p>",
        "id": 260862606,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636492627
    },
    {
        "content": "<p>Yeah but the test is meant to be there to let people verify it works before distributing to their distro.</p>",
        "id": 260862658,
        "sender_full_name": "Jubilee",
        "timestamp": 1636492652
    },
    {
        "content": "<p>I'm sure if anyone ever added a big endian system to tier 1, one of the tasks would be sorting out the tests</p>",
        "id": 260862684,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636492672
    },
    {
        "content": "<p>one idea for big/little-endian bitmasks: just treat the bitmask as an opaque binary blob and rely on bitcasting to a llvm i1 vector and using llvm vector ops to do all operations, rather than trying to read bits directly</p>",
        "id": 260862894,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636492763
    },
    {
        "content": "<p>that way it doesn't matter how llvm represents it, you always get the right answer</p>",
        "id": 260862974,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636492802
    },
    {
        "content": "<p>I think that defeats the purpose a little bit because then it's basically identical to the Mask type</p>",
        "id": 260863041,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636492820
    },
    {
        "content": "<p>(that discussion also has nothing to do with this PR, I think)</p>",
        "id": 260863063,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636492832
    },
    {
        "content": "<p>it has to do with big/little-endian issues...</p>",
        "id": 260863107,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636492855
    },
    {
        "content": "<p>Sure but not in the intrinsic</p>",
        "id": 260863131,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636492864
    },
    {
        "content": "<p>I was going to suggest multiple bitmasks functions with different orders</p>",
        "id": 260863204,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636492899
    },
    {
        "content": "<p>One of which being native order</p>",
        "id": 260863234,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636492912
    },
    {
        "content": "<p>Regardless of what we do there, I think we want the intrinsic to do the native order</p>",
        "id": 260863378,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636492968
    },
    {
        "content": "<p>ummm...wouldn't the intrinsic just bitcast the input bytes to a bit vector, do whatever op we wanted, then bitcast the resulting bit vector back to bytes?</p>",
        "id": 260863853,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636493175
    },
    {
        "content": "<p>there's also the issue that some arches (such as mc68000 or avr i'd guess) don't really have a native order, llvm is just picking whatever made llvm easier to write.</p>",
        "id": 260864195,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636493352
    },
    {
        "content": "<p>So... okay.<br>\nI think in order to proceed with <a href=\"https://github.com/rust-lang/rust/issues/88868\">#88868</a>, we need a very explicit, not-actually-in-a-programming-language definition of what the intrinsic is <em>supposed</em> to do, because I am suddenly feeling deeply unclear about that. We need our own definition that is not beholden to whatever LLVM has written at the moment.</p>",
        "id": 260864437,
        "sender_full_name": "Jubilee",
        "timestamp": 1636493456
    },
    {
        "content": "<p>By definition it's going to return an LLVM-specific order</p>",
        "id": 260864507,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636493492
    },
    {
        "content": "<p><em>waves dismissively</em> We would prefer GCC and Cranelift to be semantically compatible.</p>",
        "id": 260864604,
        "sender_full_name": "Jubilee",
        "timestamp": 1636493527
    },
    {
        "content": "<p>We could define that it needs to return a specific order, but then it's a useless intrinsic if you're forcing the bits to always be flipped</p>",
        "id": 260864614,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636493534
    },
    {
        "content": "<p>(on some architectures)</p>",
        "id": 260864632,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636493543
    },
    {
        "content": "<p>It's fine if the value is arch-dependent or CG-dependent, actually.</p>",
        "id": 260864674,
        "sender_full_name": "Jubilee",
        "timestamp": 1636493562
    },
    {
        "content": "<p>We just need to be able to grasp what we do next.</p>",
        "id": 260864692,
        "sender_full_name": "Jubilee",
        "timestamp": 1636493575
    },
    {
        "content": "<p>CG-dependent is a problem, since you want to be able to link gcc with llvm code</p>",
        "id": 260864747,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636493598
    },
    {
        "content": "<p>That is super optimistic lol</p>",
        "id": 260864775,
        "sender_full_name": "Jubilee",
        "timestamp": 1636493610
    },
    {
        "content": "<p>Well, what do we want bitmasks for?</p>",
        "id": 260864812,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636493625
    },
    {
        "content": "<p>well, we should at least try...</p>",
        "id": 260864814,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636493625
    },
    {
        "content": "<p>One use is to check if all lanes are unset (though we have an intrinsic for that)</p>",
        "id": 260864967,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636493673
    },
    {
        "content": "<p>we want bitmasks as a more-efficient for some archs representation of masks</p>",
        "id": 260864999,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636493688
    },
    {
        "content": "<p>also conversion to stdarch types</p>",
        "id": 260865070,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636493721
    },
    {
        "content": "<p>Basically, I moreso want a definition I could go implement in Miri or another simulator than one that like forces all CGs to play nice.</p>",
        "id": 260865121,
        "sender_full_name": "Jubilee",
        "timestamp": 1636493745
    },
    {
        "content": "<p>one other thing we want bitmasks for, but are not the primary usecase, are conversion of masks to/from integers in some defined bit-order</p>",
        "id": 260865212,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636493773
    },
    {
        "content": "<p>If it could be CG (or more likely, arch-dependent) then a symbex could flip which repr it uses each time through.</p>",
        "id": 260865218,
        "sender_full_name": "Jubilee",
        "timestamp": 1636493777
    },
    {
        "content": "<p>So my point is when we publicly expose bitmasks, we may need to say the order is arbitrary</p>",
        "id": 260865273,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636493809
    },
    {
        "content": "<p>Internally we already handle that</p>",
        "id": 260865284,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636493815
    },
    {
        "content": "<p>Right.</p>",
        "id": 260865294,
        "sender_full_name": "Jubilee",
        "timestamp": 1636493822
    },
    {
        "content": "<p>I mostly want something that helps us reason about it.</p>",
        "id": 260865352,
        "sender_full_name": "Jubilee",
        "timestamp": 1636493848
    },
    {
        "content": "<p>Fixing this intrinsic in the PR really helps us remove unnecessary bounds on our mask type, it doesn't change anything about the bit order we expose</p>",
        "id": 260865497,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636493904
    },
    {
        "content": "<p>We don't even need to expose bitmasks publicly, we just do because sometimes people need them</p>",
        "id": 260865543,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636493930
    },
    {
        "content": "<p>i'd say bitmasks should just be stored in whatever arbitrary way llvm decides bitvectors should be -- bitcast to an array of bytes</p>",
        "id": 260865584,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636493964
    },
    {
        "content": "<p>I am fine with that but I actually don't wanna see \"bitcast\" in the definition!</p>",
        "id": 260865650,
        "sender_full_name": "Jubilee",
        "timestamp": 1636494002
    },
    {
        "content": "<p>other CGs should just pick something consistent with llvm -- if llvm doesn't pick (e.g. doesn't support that arch) then the CG has to hash it out among all other CGs</p>",
        "id": 260865846,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636494085
    },
    {
        "content": "<p>See the reason I am suddenly antsy about this is I want to be able to detect if LLVM has miscompiled something.</p>",
        "id": 260865869,
        "sender_full_name": "Jubilee",
        "timestamp": 1636494097
    },
    {
        "content": "<p>You'll know when you use that bitmask to do something</p>",
        "id": 260865898,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636494116
    },
    {
        "content": "<p>yup!</p>",
        "id": 260865948,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636494125
    },
    {
        "content": "<p>Trivially you can convert it back to a full mask</p>",
        "id": 260865955,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636494126
    },
    {
        "content": "<p>I don't trust that.</p>",
        "id": 260865962,
        "sender_full_name": "Jubilee",
        "timestamp": 1636494129
    },
    {
        "content": "<p>Well, we already have an entire mask architecture predicated on having bitmasks, this PR just allows us to remove trait bounds on the masks</p>",
        "id": 260866066,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636494183
    },
    {
        "content": "<p>I don't think this conversation is relevant to approving this PR anyway</p>",
        "id": 260866105,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636494202
    },
    {
        "content": "<p>well, it should probably be moved to \"bitmask endianness\"</p>",
        "id": 260866162,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636494234
    },
    {
        "content": "<p>I also don't think it's practical to require the masks to have some particular bit order because then the bitmasks become useless, dumping conversion code around every operation</p>",
        "id": 260866221,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636494251
    },
    {
        "content": "<p>It's not about requiring the masks to have some particular bit order.</p>",
        "id": 260866244,
        "sender_full_name": "Jubilee",
        "timestamp": 1636494263
    },
    {
        "content": "<p>I just want to actually understand and know the change is correct.</p>",
        "id": 260866278,
        "sender_full_name": "Jubilee",
        "timestamp": 1636494288
    },
    {
        "content": "<p>I don't see how LLVM's bit order is relevant to the change, then, because this change doesn't touch bit order</p>",
        "id": 260866339,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636494321
    },
    {
        "content": "<p>imho the only way llvm could detectably miscompile bitmasks is if it's inconsistent with itself, since llvm is the definition of how our bitmasks are represented</p>",
        "id": 260866361,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636494338
    },
    {
        "content": "<p>YES.</p>",
        "id": 260866372,
        "sender_full_name": "Jubilee",
        "timestamp": 1636494345
    },
    {
        "content": "<p>I AM ASSUMING LLVM CAN BE INCONSISTENT WITH ITSELF</p>",
        "id": 260866399,
        "sender_full_name": "Jubilee",
        "timestamp": 1636494357
    },
    {
        "content": "<p>aaaa</p>",
        "id": 260866479,
        "sender_full_name": "Jubilee",
        "timestamp": 1636494381
    },
    {
        "content": "<p>well, when we see inconsistency, we report an llvm bug, just like any other inconsistency</p>",
        "id": 260866495,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636494393
    },
    {
        "content": "<p>how do we know what's inconsistent and what is just us being wrong</p>",
        "id": 260866540,
        "sender_full_name": "Jubilee",
        "timestamp": 1636494420
    },
    {
        "content": "<p>Well, like I said, you can trivially convert any bitmask back to a full mask, which has a defined layout</p>",
        "id": 260866600,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636494452
    },
    {
        "content": "<p>look at bitvectors from avx512 code on x86 c++?</p>",
        "id": 260866627,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636494470
    },
    {
        "content": "<p>how do we know if the conversion is correct</p>",
        "id": 260866716,
        "sender_full_name": "Jubilee",
        "timestamp": 1636494497
    },
    {
        "content": "<p>it's correct if it gives us the correct answer...defined by what operations produced the bitmask, not by the bytes in the bitmask</p>",
        "id": 260866780,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636494548
    },
    {
        "content": "<p>I don't really see how this is different than saying we can't use alloca load and store because if any of those are wrong but externally consistent we'd never know</p>",
        "id": 260866798,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636494560
    },
    {
        "content": "<p>if it's so trivial why can't anyone write it down</p>",
        "id": 260866803,
        "sender_full_name": "Jubilee",
        "timestamp": 1636494562
    },
    {
        "content": "<p>the bytes are opaque, llvm gets to put whatever it feels like there</p>",
        "id": 260866832,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636494582
    },
    {
        "content": "<p>we can't write it down cuz we didn't dig through llvm's code to find out how it represents bitvectors</p>",
        "id": 260866966,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636494654
    },
    {
        "content": "<p>gtg, ttyl</p>",
        "id": 260866999,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636494670
    },
    {
        "content": "<p>On every arch I tested the bit order corresponds to the endianness</p>",
        "id": 260867024,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636494684
    },
    {
        "content": "<p>We need a definition of the platform intrinsic that isn't just linkage to an LLVM intrinsic.</p>",
        "id": 260867032,
        "sender_full_name": "Jubilee",
        "timestamp": 1636494689
    },
    {
        "content": "<p>It's not actually about the bit order.</p>",
        "id": 260867065,
        "sender_full_name": "Jubilee",
        "timestamp": 1636494717
    },
    {
        "content": "<p>It's about understanding what the possibilities are.</p>",
        "id": 260867078,
        "sender_full_name": "Jubilee",
        "timestamp": 1636494726
    },
    {
        "content": "<p>And writing them down, so I stop wondering what is a correct change and what's not.</p>",
        "id": 260867101,
        "sender_full_name": "Jubilee",
        "timestamp": 1636494741
    },
    {
        "content": "<p>It does the conversion such that it's consistent with bitmask_select, that's it</p>",
        "id": 260867124,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636494756
    },
    {
        "content": "<p>Beyond that it can do whatever it wants for any particular target</p>",
        "id": 260867233,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636494798
    },
    {
        "content": "<p>And any particular codegen</p>",
        "id": 260867242,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636494804
    },
    {
        "content": "<p>Okay, fine?<br>\nThat's... what I needed.</p>",
        "id": 260867245,
        "sender_full_name": "Jubilee",
        "timestamp": 1636494808
    },
    {
        "content": "<p>Fwiw those requirements didn't change at all with this PR, in the current compiler the intrinsic is still opaque to rustc</p>",
        "id": 260867381,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636494883
    },
    {
        "content": "<p>I know the requirements we are expecting were not supposed to change.</p>",
        "id": 260867508,
        "sender_full_name": "Jubilee",
        "timestamp": 1636494955
    },
    {
        "content": "<p>I feel like I am being deliberately misunderstood here because I asked a simple question.</p>",
        "id": 260867739,
        "sender_full_name": "Jubilee",
        "timestamp": 1636495078
    },
    {
        "content": "<p>Sorry, you originally suggested that you don't want it to be dependent on LLVM</p>",
        "id": 260867949,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636495171
    },
    {
        "content": "<p>I think we're just saying by definition it has to be</p>",
        "id": 260867991,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636495196
    },
    {
        "content": "<p>The value is defined by <code>simd_bitmask</code>, and we pass that value to other functions, and we need to know what functions can legally accept that value.</p>",
        "id": 260868197,
        "sender_full_name": "Jubilee",
        "timestamp": 1636495253
    },
    {
        "content": "<p>If the answer is \"<code>simd_select_bitmask</code> and nothing else\" then we now know what our constraints are.</p>",
        "id": 260868291,
        "sender_full_name": "Jubilee",
        "timestamp": 1636495298
    },
    {
        "content": "<p>Yeah. So right now it's just bitmask select.  We are making assumptions about it in the portable-simd API based on what the function actually does, but maybe that's not legal</p>",
        "id": 260868302,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636495306
    },
    {
        "content": "<p>We know what to test for consistency, and what not.</p>",
        "id": 260868313,
        "sender_full_name": "Jubilee",
        "timestamp": 1636495312
    },
    {
        "content": "<p>(but that's a documentation issue more than anything else)</p>",
        "id": 260868375,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636495327
    },
    {
        "content": "<p>Perhaps it is just a documentation issue, but I can actually sign off on <a href=\"https://github.com/rust-lang/rust/issues/88868\">#88868</a> if I understand what the future issues will be.</p>",
        "id": 260868440,
        "sender_full_name": "Jubilee",
        "timestamp": 1636495358
    },
    {
        "content": "<p>We can theoretically provide a function (or maybe even a const or something??) that actually gives you the bit index for a particular lane, but that won't be consistent between cg, architecture, etc</p>",
        "id": 260868553,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636495417
    },
    {
        "content": "<p>It doesn't have to be entirely opaque, but it's going to be somewhat arbitrary</p>",
        "id": 260868666,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636495453
    },
    {
        "content": "<p>A definition that says that the bit order could be, in a hypothetical 8-lane <code>BitMask</code>, = <code>[0, 7, 1, 6, 2, 5, 3, 4]</code> OR <code>[0, 1, 2, 3, 4, 5, 6, 7]</code> but either way <code>simd_select_bitmask</code> will correctly \"index off\" it, and if we expand it into e.g. <code>u16s</code> on e.g. an LE system, it will have a given order of bytes, is fine.</p>",
        "id": 260868830,
        "sender_full_name": "Jubilee",
        "timestamp": 1636495550
    },
    {
        "content": "<p>Yep</p>",
        "id": 260868930,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636495592
    },
    {
        "content": "<p>It's that equational reasoning that I have suddenly become interested in.</p>",
        "id": 260868931,
        "sender_full_name": "Jubilee",
        "timestamp": 1636495592
    },
    {
        "content": "<p>... speaking of, what IS the order we want the <code>u16x8</code> to be in?</p>",
        "id": 260868968,
        "sender_full_name": "Jubilee",
        "timestamp": 1636495616
    },
    {
        "content": "<p>Same as an array</p>",
        "id": 260869012,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636495646
    },
    {
        "content": "<p>It has to be [0, 1, 2, 3, 4, 5, 6, 7] in Rustworld, right? Because it's an array.<br>\nYeah.</p>",
        "id": 260869022,
        "sender_full_name": "Jubilee",
        "timestamp": 1636495652
    },
    {
        "content": "<p>It doesn't change with endianness or anything</p>",
        "id": 260869033,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636495655
    },
    {
        "content": "<p>Yep</p>",
        "id": 260869038,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636495662
    },
    {
        "content": "<p>And what is our conversion function for that, again?</p>",
        "id": 260869153,
        "sender_full_name": "Jubilee",
        "timestamp": 1636495704
    },
    {
        "content": "<p>Ah, also <code>simd_select_bitmask</code></p>",
        "id": 260869299,
        "sender_full_name": "Jubilee",
        "timestamp": 1636495796
    },
    {
        "content": "<p>And the invariants are that <code>simd_bitmask</code> has to be used on integers with the value <code>0</code>, <code>uN::MAX</code>, or <code>iN::-1</code>, or it stops making sense.</p>",
        "id": 260869871,
        "sender_full_name": "Jubilee",
        "timestamp": 1636496009
    },
    {
        "content": "<p>Yeah, basically</p>",
        "id": 260869970,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636496045
    },
    {
        "content": "<p>hypothetically, we could have it used on <code>0b1000_0000_0000_0000</code> or <code>0b0000_0000_0000_0001</code> or e.g. the inversion of either of those and it would not be known with absolute certainty which boolean value it would produce on a given platform.</p>",
        "id": 260870135,
        "sender_full_name": "Jubilee",
        "timestamp": 1636496137
    },
    {
        "content": "<p>Yeah, so the previous tests assumed the order is based on endianness</p>",
        "id": 260870276,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636496202
    },
    {
        "content": "<p>We could add that extra bit if we really wanted to</p>",
        "id": 260870361,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636496262
    },
    {
        "content": "<p>Do we have any tests that mandate the equational reasoning I have defined so far?</p>",
        "id": 260870459,
        "sender_full_name": "Jubilee",
        "timestamp": 1636496295
    },
    {
        "content": "<p>I'm not sure what you specifically mean by equational reasoning</p>",
        "id": 260870539,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636496337
    },
    {
        "content": "<p>for all SIMD vectors of integers <code>vi</code><br>\nwhere all the integers are the \"SIMD Boolean\" values (all bits set or unset)<br>\nwe want the use of <code>simd_select</code> on <code>vi</code><br>\nand <code>simd_select_bitmask</code> on <code>simd_bitmask(vi)</code> to produce the same results.</p>",
        "id": 260871187,
        "sender_full_name": "Jubilee",
        "timestamp": 1636496680
    },
    {
        "content": "<p>Right now it tests one better, a specific bit order</p>",
        "id": 260871244,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636496714
    },
    {
        "content": "<p>Right, but only on LE, yes?</p>",
        "id": 260871279,
        "sender_full_name": "Jubilee",
        "timestamp": 1636496728
    },
    {
        "content": "<p>Only LE platforms are tested</p>",
        "id": 260871303,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636496744
    },
    {
        "content": "<p>There are no BE tier 1 platforms</p>",
        "id": 260871327,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636496761
    },
    {
        "content": "<p>Yes, in CI, but people run tier 2 tests on their own platforms and on their own recognizance.</p>",
        "id": 260871399,
        "sender_full_name": "Jubilee",
        "timestamp": 1636496788
    },
    {
        "content": "<p>Yes. I thought you indicated in the PR that other bitmask tests were already disabled on BE</p>",
        "id": 260871445,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636496823
    },
    {
        "content": "<p>Yes, and I think that is a bad thing. <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span> I would like a test that establishes the part we would like to rely on actually is platform-invariant.</p>",
        "id": 260871567,
        "sender_full_name": "Jubilee",
        "timestamp": 1636496886
    },
    {
        "content": "<p>I guess we could, though that isn't what the PR is about</p>",
        "id": 260871610,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636496922
    },
    {
        "content": "<p>We could just do it, but I don't really like writing tests I don't run</p>",
        "id": 260871694,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636496968
    },
    {
        "content": "<p>Hmmm.</p>",
        "id": 260871921,
        "sender_full_name": "Jubilee",
        "timestamp": 1636497092
    },
    {
        "content": "<p>That is a reasonable objection and I am going to think a bit about that.</p>",
        "id": 260872584,
        "sender_full_name": "Jubilee",
        "timestamp": 1636497452
    },
    {
        "content": "<p>Part of the reason I suddenly looked at this is because I think we may have to also <code>cfg(not(bootstrap))</code> on <code>simd_bitmask</code>.</p>",
        "id": 260874143,
        "sender_full_name": "Jubilee",
        "timestamp": 1636498333
    },
    {
        "content": "<p>And THAT is more of a pain.</p>",
        "id": 260874190,
        "sender_full_name": "Jubilee",
        "timestamp": 1636498366
    },
    {
        "content": "<p>I guess it's fine if the symbol stays the same but we change the definition...?</p>",
        "id": 260874251,
        "sender_full_name": "Jubilee",
        "timestamp": 1636498402
    },
    {
        "content": "<p>...it has to be, otherwise every single compilation adjustment would require <code>cfg(not(bootstrap))</code> lol.</p>",
        "id": 260874699,
        "sender_full_name": "Jubilee",
        "timestamp": 1636498621
    },
    {
        "content": "<p>...does the stdarch test suite pass?</p>",
        "id": 260876973,
        "sender_full_name": "Jubilee",
        "timestamp": 1636499776
    },
    {
        "content": "<p>Why wouldn't it?</p>",
        "id": 260877018,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636499811
    },
    {
        "content": "<p>I don't believe rust-lang/rust runs it in CI.</p>",
        "id": 260877042,
        "sender_full_name": "Jubilee",
        "timestamp": 1636499830
    },
    {
        "content": "<p>No clue, I've never run them</p>",
        "id": 260877170,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636499890
    },
    {
        "content": "<p>Okay, I spoke with Eddy and yes we will be fine if we apply <code>cfg(not(bootstrap))</code> to only <code>simd_shuffle</code> but that's going to block your byte array change re: <a href=\"https://github.com/rust-lang/portable-simd/issues/159\">portable-simd#159</a></p>",
        "id": 260878114,
        "sender_full_name": "Jubilee",
        "timestamp": 1636500672
    },
    {
        "content": "<p>Probably fine for now</p>",
        "id": 260878239,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636500747
    },
    {
        "content": "<p>( I am also game to start smearing half the code with <code>cfg(not(bootstrap))</code> but, well, it's only a temporary thing either way. )</p>",
        "id": 260878385,
        "sender_full_name": "Jubilee",
        "timestamp": 1636500850
    },
    {
        "content": "<p>I guess my question is why not just cfg the whole module at that point</p>",
        "id": 260878434,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636500903
    },
    {
        "content": "<p>^^;</p>",
        "id": 260878470,
        "sender_full_name": "Jubilee",
        "timestamp": 1636500941
    },
    {
        "content": "<p>A good point.</p>",
        "id": 260878483,
        "sender_full_name": "Jubilee",
        "timestamp": 1636500959
    },
    {
        "content": "<p>I didn't read the whole discussion here</p>",
        "id": 260878933,
        "sender_full_name": "simulacrum",
        "timestamp": 1636501243
    },
    {
        "content": "<p>It included a lot of not-necessarily-relevant back and forth so that's fine.</p>",
        "id": 260878975,
        "sender_full_name": "Jubilee",
        "timestamp": 1636501270
    },
    {
        "content": "<p>do you need some other solution or whatever, or do you have a plan?</p>",
        "id": 260879013,
        "sender_full_name": "simulacrum",
        "timestamp": 1636501293
    },
    {
        "content": "<p>(I hope my concern was clear)</p>",
        "id": 260879026,
        "sender_full_name": "simulacrum",
        "timestamp": 1636501302
    },
    {
        "content": "<p>Yeah at first I was going to adjust the library so that it cfgs out the swizzle stuff, but then we realized we plan on landing a change to how we can get bitmasks returned from the compiler.</p>",
        "id": 260879124,
        "sender_full_name": "Jubilee",
        "timestamp": 1636501363
    },
    {
        "content": "<p>And unfortunately bitmasks have to do with SIMD equality tests.</p>",
        "id": 260879197,
        "sender_full_name": "Jubilee",
        "timestamp": 1636501438
    },
    {
        "content": "<p>Which means it is <strong>everywhere</strong>.</p>",
        "id": 260879243,
        "sender_full_name": "Jubilee",
        "timestamp": 1636501450
    },
    {
        "content": "<p>Do we expect that to be common? I think it would potentially mean that we just for now always leave the cfg on there (i.e., never compile in stage 0)</p>",
        "id": 260879340,
        "sender_full_name": "simulacrum",
        "timestamp": 1636501559
    },
    {
        "content": "<p>which is fine!</p>",
        "id": 260879371,
        "sender_full_name": "simulacrum",
        "timestamp": 1636501562
    },
    {
        "content": "<p>just means std/core/rustc can't really use it</p>",
        "id": 260879389,
        "sender_full_name": "simulacrum",
        "timestamp": 1636501568
    },
    {
        "content": "<p>it'll become less fine if there's eventually usage in rustc deps and such, so we need to figure it out and stop doing that, but it doesn't <em>have to</em> block merging initially</p>",
        "id": 260879443,
        "sender_full_name": "simulacrum",
        "timestamp": 1636501612
    },
    {
        "content": "<p>Yeah, I think we don't expect that to be super-common, it's just gonna be a thing For Now, mostly.</p>",
        "id": 260879480,
        "sender_full_name": "Jubilee",
        "timestamp": 1636501639
    },
    {
        "content": "<p>Because we're trying to squeeze more... coherent? logic-friendly? less arbitrary? behaviors out of the codegen backend.</p>",
        "id": 260879577,
        "sender_full_name": "Jubilee",
        "timestamp": 1636501689
    },
    {
        "content": "<p>Seems OK. If that's the case I think we can probably just go ahead with the PR and deal with cfg(bootstrap) and such as this arises in the future</p>",
        "id": 260879666,
        "sender_full_name": "simulacrum",
        "timestamp": 1636501734
    },
    {
        "content": "<p>(I forget if I had other concerns. I don't think so)</p>",
        "id": 260879689,
        "sender_full_name": "simulacrum",
        "timestamp": 1636501745
    },
    {
        "content": "<p>Yeah.<br>\nI could only see us changing the repr of bitmasks in one other way in the future.</p>",
        "id": 260879697,
        "sender_full_name": "Jubilee",
        "timestamp": 1636501749
    },
    {
        "content": "<p>if that's the only thing I noted feel free to drop a comment and r=me or otherwise mark as waiting on review</p>",
        "id": 260879728,
        "sender_full_name": "simulacrum",
        "timestamp": 1636501778
    },
    {
        "content": "<p>And that would basically only happen if rustc essentially embedded a new type to represent what LLVM calls <code>i1xN</code>.</p>",
        "id": 260879731,
        "sender_full_name": "Jubilee",
        "timestamp": 1636501779
    },
    {
        "content": "<p>note that even on powerpc64 big-endian, bitmasks for SimpleV are lane #<code>n</code> corresponds to bit <code>1 &lt;&lt; n</code></p>",
        "id": 260879894,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636501864
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"229517\">@Jacob Lifshay</span> do you know why endianness effects bitmask bit order?</p>",
        "id": 260885791,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636505679
    },
    {
        "content": "<p>I was thinking about it more and now I'm starting to wonder why it <em>isn't</em> simply in LSB-&gt;MSB order</p>",
        "id": 260885828,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636505720
    },
    {
        "content": "<p>oh no I infected you too</p>",
        "id": 260885845,
        "sender_full_name": "Jubilee",
        "timestamp": 1636505748
    },
    {
        "content": "<p>cuz bit endianness is an independent variable from byte endianness</p>",
        "id": 260885909,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636505788
    },
    {
        "content": "<p>so it just happens to be for every platform we've tested, they're the same?</p>",
        "id": 260885945,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636505817
    },
    {
        "content": "<p>yes, more or less</p>",
        "id": 260885983,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636505860
    },
    {
        "content": "<p>does ppc64 actually have an instruction similar to movemask, and on ppc64le the bit order is swapped?</p>",
        "id": 260886034,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636505884
    },
    {
        "content": "<p>lemme look...</p>",
        "id": 260886046,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636505900
    },
    {
        "content": "<p>or is this an LLVM decision...</p>",
        "id": 260886048,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636505904
    },
    {
        "content": "<p>and should there be <code>cfg(bit_endian)</code></p>",
        "id": 260886064,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636505922
    },
    {
        "content": "<p>and is there any reason to believe LLVM will ever produce something that's not in one of these two bit orders?</p>",
        "id": 260886096,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636505959
    },
    {
        "content": "<p>it might produce something where each byte has bits in lsb to msb order, but bytes are in big-endian</p>",
        "id": 260886331,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636506121
    },
    {
        "content": "<p>powerpc movemask: <a href=\"https://github.com/WebAssembly/simd/issues/131\">https://github.com/WebAssembly/simd/issues/131</a></p>",
        "id": 260886385,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636506136
    },
    {
        "content": "<p>basically powerpc just uses a extract-arbitrary-bits-from-128-bit-vector-reg instruction</p>",
        "id": 260886432,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636506188
    },
    {
        "content": "<p>hmm, so then it's LLVM deciding the bit order changes?</p>",
        "id": 260886461,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636506236
    },
    {
        "content": "<p>yup, afaict</p>",
        "id": 260886501,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636506248
    },
    {
        "content": "<p>I wonder if we can figure out what bit order LLVM actually uses</p>",
        "id": 260886534,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636506287
    },
    {
        "content": "<p>like, a general rule</p>",
        "id": 260886547,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636506301
    },
    {
        "content": "<p>apparently stackoverflow doesn't know: <a href=\"https://stackoverflow.com/questions/61647221/is-llvm-bitcast-from-vector-of-bool-i1-to-i8-i16-etc-well-defined\">https://stackoverflow.com/questions/61647221/is-llvm-bitcast-from-vector-of-bool-i1-to-i8-i16-etc-well-defined</a></p>",
        "id": 260886732,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636506455
    },
    {
        "content": "<p>a top result from google</p>",
        "id": 260886741,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636506472
    },
    {
        "content": "<p>I read some stuff a while back that seemed to indicate it's fine, and consistent</p>",
        "id": 260886800,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636506491
    },
    {
        "content": "<p>as in it's guaranteed to pack your bits down, nothing about bit order</p>",
        "id": 260886813,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636506510
    },
    {
        "content": "<p>yeah</p>",
        "id": 260886827,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636506523
    },
    {
        "content": "<p>that's the basic summary of the answer to that SO question</p>",
        "id": 260886853,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636506548
    },
    {
        "content": "<p>i think the 68000 had opposite bitorder and byte order. ive at least heard \"least significant bit is 0, most significant byte is 0\" called \"motorola style\"</p>",
        "id": 260886885,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1636506581
    },
    {
        "content": "<p>i think gcc-rs/rustc-codegen-gcc would enable us to target that platform so it might not entirely be an academic concern</p>",
        "id": 260886971,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1636506608
    },
    {
        "content": "<p>I suppose for now we can assume they're the same, but if it comes up for any platforms, we can add a separate bit order cfg value</p>",
        "id": 260886996,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636506641
    },
    {
        "content": "<p>powerpc's spec is msb bit is bit 0, bytes are in either little/big endian. SV specifically defines bit masks using element #n is in bit <code>1 &lt;&lt; n</code></p>",
        "id": 260887024,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636506677
    },
    {
        "content": "<p><a href=\"https://lists.llvm.org/pipermail/llvm-dev/2016-August/103678.html\">https://lists.llvm.org/pipermail/llvm-dev/2016-August/103678.html</a></p>",
        "id": 260887047,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636506714
    },
    {
        "content": "<blockquote>\n<p>I highly recommend that you use only vectors of elements which have a size which is a whole number of bytes. There are known issues with how we handle the more-general cases</p>\n</blockquote>",
        "id": 260887109,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636506749
    },
    {
        "content": "<p>yeah, we do pad it</p>",
        "id": 260887119,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636506766
    },
    {
        "content": "<p>in that case, LLVM isn't using bit order for PPC then</p>",
        "id": 260887151,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636506797
    },
    {
        "content": "<p>that quote was for <code>&lt;8 x i1&gt;</code></p>",
        "id": 260887178,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636506817
    },
    {
        "content": "<p>yeah, I mean that we pad it to a whole number of bytes before casting</p>",
        "id": 260887379,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636507002
    },
    {
        "content": "<p>but yeah, ppc64le comes out LSB first</p>",
        "id": 260887399,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636507023
    },
    {
        "content": "<p>well, apparently llvm uses byte endian-ness for bit-endian-ness too: <a href=\"https://github.com/llvm/llvm-project/blob/18334a1c1afe1b8a83c2a6108413bc48d80107df/llvm/lib/Analysis/ConstantFolding.cpp#L218\">https://github.com/llvm/llvm-project/blob/18334a1c1afe1b8a83c2a6108413bc48d80107df/llvm/lib/Analysis/ConstantFolding.cpp#L218</a></p>",
        "id": 260888464,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636507968
    },
    {
        "content": "<p>well, that answers that</p>",
        "id": 260888488,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636507995
    },
    {
        "content": "<p>which is not always correct imho...</p>",
        "id": 260888499,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636508004
    },
    {
        "content": "<p>I think it's arbitrary</p>",
        "id": 260888581,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636508070
    },
    {
        "content": "<p>i think it's just that llvm never needed to support something where bit endianness != byte endianness</p>",
        "id": 260888625,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636508120
    },
    {
        "content": "<p>I wonder if that's the root of issues regarding PPC64LE...?</p>",
        "id": 260888656,
        "sender_full_name": "Jubilee",
        "timestamp": 1636508153
    },
    {
        "content": "<p>ppc64le should behave identially to x86 in that respect, so i don't think that's the issue...</p>",
        "id": 260888744,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636508201
    },
    {
        "content": "<p>well, except our code runs fine on an actual ppc64le system</p>",
        "id": 260888747,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636508204
    },
    {
        "content": "<p>i'd guess that qemu isn't tested that well in some of the weirder vector instructions</p>",
        "id": 260888814,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636508259
    },
    {
        "content": "<p>Ahh.</p>",
        "id": 260888823,
        "sender_full_name": "Jubilee",
        "timestamp": 1636508271
    },
    {
        "content": "<p>i'd expect that those who need powerpc64le almost always just use a native cpu, so not many have encountered the qemu bugs</p>",
        "id": 260888917,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636508346
    },
    {
        "content": "<p>as an example...qemu just plain doesn't implement the BCD instructions that the openpower spec declares are required on all cpus, even the tiniest ones.</p>",
        "id": 260889025,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636508429
    },
    {
        "content": "<p>it also doesn't match power9's behavior around the integer divide/remainder instructions</p>",
        "id": 260889065,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636508469
    },
    {
        "content": "<p>Alas.</p>",
        "id": 260889338,
        "sender_full_name": "Jubilee",
        "timestamp": 1636508691
    },
    {
        "content": "<p>for bit endianness, it may be easier for libre-soc to just switch predicate endian-ness on big-endian mode rather than add support to llvm for different bit/byte endianness</p>",
        "id": 260889538,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636508877
    },
    {
        "content": "<p>libre-soc bug for tracking endianness: <a href=\"https://bugs.libre-soc.org/show_bug.cgi?id=744\">https://bugs.libre-soc.org/show_bug.cgi?id=744</a></p>",
        "id": 260889665,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636508986
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span> since it does appear that bit- and byte-endianness are assumed to be the same by LLVM, I just documented that specifically</p>",
        "id": 260890023,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636509320
    },
    {
        "content": "<p>If anything else ever occurs we can consider it a bug and go from there</p>",
        "id": 260890035,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636509340
    },
    {
        "content": "<p>Fair enough!</p>",
        "id": 260890907,
        "sender_full_name": "Jubilee",
        "timestamp": 1636510221
    },
    {
        "content": "<p>If you can squishy the fixups in <a href=\"https://github.com/rust-lang/portable-simd/issues/175\">portable-simd#175</a> then that can be added in too.</p>",
        "id": 260891143,
        "sender_full_name": "Jubilee",
        "timestamp": 1636510552
    },
    {
        "content": "<p>Done</p>",
        "id": 260892019,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636510870
    },
    {
        "content": "<p>Nice.<br>\nDrafting a smol fix to catch future warnings in CI.</p>",
        "id": 260892839,
        "sender_full_name": "Jubilee",
        "timestamp": 1636510902
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"312331\">@Caleb Zulawski</span> Sorry about your SAN loss</p>",
        "id": 261040847,
        "sender_full_name": "Jubilee",
        "timestamp": 1636572122
    },
    {
        "content": "<p>I'll just be glad when we can catch errors before PRs to upstream</p>",
        "id": 261041213,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636572270
    },
    {
        "content": "<p>Thrash for an hour and then remember that conditioning data is an option (again), lol.</p>",
        "id": 261048071,
        "sender_full_name": "Jubilee",
        "timestamp": 1636575225
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"229517\">@Jacob Lifshay</span> I appreciate the help I just am deliberately keeping the scope down to things at roughly the complexity band of \"x86_64_v4\"</p>",
        "id": 261053000,
        "sender_full_name": "Jubilee",
        "timestamp": 1636577560
    },
    {
        "content": "<p>k, in that case you can specifically look for x86-64-v4: <a href=\"https://unix.stackexchange.com/questions/631217/how-do-i-check-if-my-cpu-supports-x86-64-v2/646289#646289\">https://unix.stackexchange.com/questions/631217/how-do-i-check-if-my-cpu-supports-x86-64-v2/646289#646289</a></p>",
        "id": 261053743,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636577926
    },
    {
        "content": "<p>seems like the best path</p>",
        "id": 261053768,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636577944
    },
    {
        "content": "<p>Mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm that is also \"rewrite entire thing in Rust\" tier.<br>\nMy current version works right now with GItHub's fleet and I am content with the knowledge it is transient if <span class=\"user-mention\" data-user-id=\"312331\">@Caleb Zulawski</span> is?</p>",
        "id": 261054023,
        "sender_full_name": "Jubilee",
        "timestamp": 1636578035
    },
    {
        "content": "<p>i'd expect it to be as simple as <code>/path/to/ld.so --help | grep 'x86-64-v4.*supported'</code></p>",
        "id": 261054307,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636578156
    },
    {
        "content": "<p><em>sighs</em> I am also fine with it just using <code>avx512f</code> if that's all that's available, atm.</p>",
        "id": 261054469,
        "sender_full_name": "Jubilee",
        "timestamp": 1636578238
    },
    {
        "content": "<p>I really need to detect when I offer a misleading example better.</p>",
        "id": 261054632,
        "sender_full_name": "Jubilee",
        "timestamp": 1636578324
    },
    {
        "content": "<p>the C flag should be similar to clang's <code>-march=x86-64-v4</code></p>",
        "id": 261054741,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636578371
    },
    {
        "content": "<p>we can fix it later and just land what you have now</p>",
        "id": 261054871,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636578430
    },
    {
        "content": "<p>Yeah, I am pretty game for improvements / fixing it later. ^^; I just want a solution that defers the existing problem (not detecting this class of errors) for like... a year or so.</p>",
        "id": 261054925,
        "sender_full_name": "Jubilee",
        "timestamp": 1636578468
    },
    {
        "content": "<p>Can I suggest instead keeping it so avx512 is a separate job in the matrix, but it only runs when it's on a proper agent?</p>",
        "id": 261054991,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636578485
    },
    {
        "content": "<p>Hmmm.</p>",
        "id": 261055023,
        "sender_full_name": "Jubilee",
        "timestamp": 1636578510
    },
    {
        "content": "<p>So nearly identical to what you have, just a slightly different job</p>",
        "id": 261055055,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636578526
    },
    {
        "content": "<p>I thiiiink I can get that going.</p>",
        "id": 261055059,
        "sender_full_name": "Jubilee",
        "timestamp": 1636578530
    },
    {
        "content": "<p>It doesn't have to be in the matrix technically, but that would be nice</p>",
        "id": 261055105,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636578564
    },
    {
        "content": "<p>Also, I think you can use GHA rules to selectively disable the job</p>",
        "id": 261055151,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636578592
    },
    {
        "content": "<p>To disable the specific step after detection, really</p>",
        "id": 261055219,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636578609
    },
    {
        "content": "<p>yeah.</p>",
        "id": 261055339,
        "sender_full_name": "Jubilee",
        "timestamp": 1636578688
    },
    {
        "content": "<p>Perhaps you can put it in the x86-tests then</p>",
        "id": 261055503,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636578770
    },
    {
        "content": "<p>Nice, yes, I can get it to skip one.</p>",
        "id": 261056409,
        "sender_full_name": "Jubilee",
        "timestamp": 1636579244
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"312331\">@Caleb Zulawski</span> I would like to further improve things and clean stuff up so we don't run like 67 computers in CI unconditionally, but does this look like an improvement enough atm?</p>",
        "id": 261057118,
        "sender_full_name": "Jubilee",
        "timestamp": 1636579591
    },
    {
        "content": "<p>Yeah I would like it to not take literally forever</p>",
        "id": 261057220,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636579656
    },
    {
        "content": "<p>So what happens if there isn't any avx512 at all?</p>",
        "id": 261057438,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636579776
    },
    {
        "content": "<p>It just doesn't run lol</p>",
        "id": 261057446,
        "sender_full_name": "Jubilee",
        "timestamp": 1636579782
    },
    {
        "content": "<p>or well, it reruns the default checks</p>",
        "id": 261057458,
        "sender_full_name": "Jubilee",
        "timestamp": 1636579792
    },
    {
        "content": "<p>Gotcha. Could you maybe change it to skip that step entirely if there's no avx512?</p>",
        "id": 261057530,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636579818
    },
    {
        "content": "<p>Just so we can at least see when it runs and when it doesn't</p>",
        "id": 261057557,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636579829
    },
    {
        "content": "<p>can you tell github actions to skip it with a message \"avx512 not supported on this server, test skipped\"?</p>",
        "id": 261057643,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636579864
    },
    {
        "content": "<p>or similar?</p>",
        "id": 261057671,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636579875
    },
    {
        "content": "<p>Let me try...</p>",
        "id": 261057715,
        "sender_full_name": "Jubilee",
        "timestamp": 1636579892
    },
    {
        "content": "<p>Yeah that would be perfect, if it can do that then it looks good to me</p>",
        "id": 261057719,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636579895
    },
    {
        "content": "<p>It will just have a <span aria-label=\"not allowed\" class=\"emoji emoji-1f6ab\" role=\"img\" title=\"not allowed\">:not_allowed:</span> symbol where the job would be atm.</p>",
        "id": 261057834,
        "sender_full_name": "Jubilee",
        "timestamp": 1636579928
    },
    {
        "content": "<p>I am not entirely clear on GHA's tools for tweaking job appearance but I know people have been asking for more, so I don't want to find out exactly how disappointed I would be yet.</p>",
        "id": 261057912,
        "sender_full_name": "Jubilee",
        "timestamp": 1636579965
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"312331\">@Caleb Zulawski</span> It looks like this atm. <a href=\"https://github.com/rust-lang/portable-simd/runs/4171171231?check_suite_focus=true\">https://github.com/rust-lang/portable-simd/runs/4171171231?check_suite_focus=true</a></p>",
        "id": 261059694,
        "sender_full_name": "Jubilee",
        "timestamp": 1636580965
    },
    {
        "content": "<p>That looks fine to me</p>",
        "id": 261060078,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636581147
    },
    {
        "content": "<p>Is there a reason it's in the check cargo features job though?</p>",
        "id": 261060134,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636581192
    },
    {
        "content": "<p>uhh.</p>",
        "id": 261060808,
        "sender_full_name": "Jubilee",
        "timestamp": 1636581538
    },
    {
        "content": "<p>To limit my scope to something I can finish and merge before rewriting all 261 lines of <code>ci.yml</code> tbh.</p>",
        "id": 261061225,
        "sender_full_name": "Jubilee",
        "timestamp": 1636581686
    },
    {
        "content": "<p>hmm question: doesn't the <code>native</code> target feature in the x86-tests job cover AVX-512 in this scenario already?</p>",
        "id": 261079158,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636592444
    },
    {
        "content": "<p>and do basically what that test is doing, but without all of the detection kludge (though I am impressed by it)</p>",
        "id": 261079287,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636592532
    },
    {
        "content": "<p>yes...</p>",
        "id": 261079331,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636592574
    },
    {
        "content": "<p>I think so.</p>",
        "id": 261079375,
        "sender_full_name": "Jubilee",
        "timestamp": 1636592612
    },
    {
        "content": "<p>I think we can probably take out the avx-512 specific stuff entirely, but we should probably comment that the native code _sometimes_ tests avx-512, since it's inconsistent</p>",
        "id": 261079456,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636592644
    },
    {
        "content": "<p>(also this is better because that job actually runs the tests, not just a build test)</p>",
        "id": 261079552,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636592720
    },
    {
        "content": "<p>though I now feel better knowing apparently we were testing avx-512 this whole time, maybe</p>",
        "id": 261079573,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636592738
    },
    {
        "content": "<p>unless someone is using build-std or whatever no one can actually activate that code anyway, though</p>",
        "id": 261079640,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636592777
    },
    {
        "content": "<p>Hmmm I think I would still want to leave in a job that signals whether or not AVX is present.</p>",
        "id": 261079642,
        "sender_full_name": "Jubilee",
        "timestamp": 1636592780
    },
    {
        "content": "<p>maybe just put a step in that job?</p>",
        "id": 261079661,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636592803
    },
    {
        "content": "<p>Yeah probably.</p>",
        "id": 261079668,
        "sender_full_name": "Jubilee",
        "timestamp": 1636592816
    },
    {
        "content": "<p>I don't know if it's possible, but can we somehow get rustc to dump what <code>native</code> actually means</p>",
        "id": 261079680,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636592828
    },
    {
        "content": "<p>?</p>",
        "id": 261079682,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636592831
    },
    {
        "content": "<p>I think so.</p>",
        "id": 261079690,
        "sender_full_name": "Jubilee",
        "timestamp": 1636592839
    },
    {
        "content": "<p>Yeah we do that here:</p>\n<div class=\"codehilite\" data-code-language=\"YAML+Jinja\"><pre><span></span><code>      <span class=\"c1\"># Super useful for debugging why a SIGILL occurred.</span>\n      <span class=\"p p-Indicator\">-</span> <span class=\"nt\">name</span><span class=\"p\">:</span> <span class=\"l l-Scalar l-Scalar-Plain\">Dump target configuration and support</span>\n        <span class=\"nt\">run</span><span class=\"p\">:</span> <span class=\"p p-Indicator\">|</span>\n          <span class=\"no\">rustc -Vv</span>\n          <span class=\"no\">echo \"Caveat: not all target features are expected to be logged\"</span>\n          <span class=\"no\">echo \"## Requested target configuration (RUSTFLAGS=$RUSTFLAGS)\"</span>\n          <span class=\"no\">rustc --print=cfg --target=$</span><span class=\"cp\">{{</span> <span class=\"nv\">matrix.target</span> <span class=\"cp\">}}</span><span class=\"no\"> $RUSTFLAGS</span>\n          <span class=\"no\">echo \"## Supported target configuration for --target=$</span><span class=\"cp\">{{</span> <span class=\"nv\">matrix.target</span> <span class=\"cp\">}}</span><span class=\"no\">\"</span>\n          <span class=\"no\">rustc --print=cfg --target=$</span><span class=\"cp\">{{</span> <span class=\"nv\">matrix.target</span> <span class=\"cp\">}}</span><span class=\"no\"> -Ctarget-cpu=native</span>\n          <span class=\"no\">echo \"## Natively supported target configuration\"</span>\n          <span class=\"no\">rustc --print=cfg -Ctarget-cpu=native</span>\n</code></pre></div>",
        "id": 261079816,
        "sender_full_name": "Jubilee",
        "timestamp": 1636592954
    },
    {
        "content": "<p>oh I literally just didn't scroll down, lol</p>",
        "id": 261079849,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636592997
    },
    {
        "content": "<p>tbh half the exercise of that entire kludge was figuring out how to do conditionals on GHA somewhat proper-like.</p>",
        "id": 261080169,
        "sender_full_name": "Jubilee",
        "timestamp": 1636593227
    },
    {
        "content": "<p>SIGSEGV -- fun!</p>",
        "id": 261097388,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636611074
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/pull/89167#issuecomment-966009262\">https://github.com/rust-lang/rust/pull/89167#issuecomment-966009262</a></p>",
        "id": 261097407,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636611109
    },
    {
        "content": "<p>is llvm compiled with debug asserts enabled? if not, that might be why it's crashing...we're somehow feeding it invalid llvm ir</p>",
        "id": 261097484,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636611207
    },
    {
        "content": "<p>This change also shouldn't in any way change compilation of existing crates...</p>",
        "id": 261097542,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636611253
    },
    {
        "content": "<p>rerun? maybe it's spurious</p>",
        "id": 261097572,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636611306
    },
    {
        "content": "<p>llvm ir: in my experience using llvm as a library, if you feed it invalid ir it loves to segfault if assertions are disabled, it would assert failure if assertions are enabled</p>",
        "id": 261097657,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636611426
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/pull/89167#issuecomment-966665501\">https://github.com/rust-lang/rust/pull/89167#issuecomment-966665501</a><br>\n<span class=\"user-mention\" data-user-id=\"229517\">@Jacob Lifshay</span> I was wrong, I was forgetting it's a Canadian cross, effectively.</p>",
        "id": 261190474,
        "sender_full_name": "Jubilee",
        "timestamp": 1636669154
    },
    {
        "content": "<p>ah</p>",
        "id": 261190758,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636669352
    },
    {
        "content": "<p>Two ARM compat fixes later. x_x<br>\n...I think maybe the conversion functions should actually live in stdarch, since they depend a lot more on the nuances of those targets. Unless... I guess since it's a From, but...?</p>",
        "id": 261339459,
        "sender_full_name": "Jubilee",
        "timestamp": 1636778609
    },
    {
        "content": "<p>Yeah, perhaps they should be migrated there</p>",
        "id": 261339584,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636778807
    },
    {
        "content": "<p>That really would make more sense</p>",
        "id": 261339590,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636778816
    },
    {
        "content": "<p>Did the merge really complete or am I hallucinating?  I just kind of assumed there would be infinite errors</p>",
        "id": 261342203,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636782460
    },
    {
        "content": "<p>Maybe we should write up an official post since we did that once</p>",
        "id": 261342256,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636782501
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/PR.20open.20to.20rust-lang.2Frust/near/261342203\">said</a>:</p>\n<blockquote>\n<p>Did the merge really complete or am I hallucinating?  I just kind of assumed there would be infinite errors</p>\n</blockquote>\n<p>same tbh, I've felt more sober and grounded on <code>${HIGHLY_CONTROLLED_SUBSTANCE}</code></p>",
        "id": 261342292,
        "sender_full_name": "Jubilee",
        "timestamp": 1636782585
    },
    {
        "content": "<p>Thanks for finding and fixing every bug we didn't know we had, lol</p>",
        "id": 261342434,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636782774
    },
    {
        "content": "<p>Massive congratulations to the portable-simd project!</p>",
        "id": 261350480,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636795088
    },
    {
        "content": "<p>big congrats indeed</p>",
        "id": 261364583,
        "sender_full_name": "Lokathor",
        "timestamp": 1636815679
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span> I started a post for inside rust: <a href=\"https://hackmd.io/VGGIcV3VQjeUPcKwXZ1TBA\">https://hackmd.io/VGGIcV3VQjeUPcKwXZ1TBA</a><br>\nnot really sure where to go with it, feel free to change whatever you'd like</p>",
        "id": 261366481,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636818205
    },
    {
        "content": "<p>it doesn't appear to be in today's docs :(</p>",
        "id": 261372194,
        "sender_full_name": "Lokathor",
        "timestamp": 1636826248
    },
    {
        "content": "<p>I think the build is around midnight UTC so we have another 6 hours or something?</p>",
        "id": 261372247,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636826292
    },
    {
        "content": "<p>So basically tomorrow</p>",
        "id": 261372256,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636826323
    },
    {
        "content": "<p>Yeah I had checked the commit and we had missed the cutoff point by a while.</p>",
        "id": 261372567,
        "sender_full_name": "Jubilee",
        "timestamp": 1636826720
    },
    {
        "content": "<p>And thank you for everyone putting up with me asking one million questions and starting to <strong>lose my mind</strong>.</p>",
        "id": 261379160,
        "sender_full_name": "Jubilee",
        "timestamp": 1636836294
    },
    {
        "content": "<p>Team work makes the dream work. \\,,/</p>",
        "id": 261379180,
        "sender_full_name": "Jubilee",
        "timestamp": 1636836340
    },
    {
        "content": "<p>I just expanded the blog post with some examples, I think I've added all I wanted for now</p>",
        "id": 261379954,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636837527
    },
    {
        "content": "<p>obligatory tweet <a href=\"https://twitter.com/workingjubilee/status/1459702038959251457\">https://twitter.com/workingjubilee/status/1459702038959251457</a></p>\n<div class=\"inline-preview-twitter\"><div class=\"twitter-tweet\"><a href=\"https://twitter.com/workingjubilee/status/1459702038959251457\"><img class=\"twitter-avatar\" src=\"https://uploads.zulipusercontent.net/b918d32b7ab0e274b678c4f5dfa1cb06074b0d52/68747470733a2f2f7062732e7477696d672e636f6d2f70726f66696c655f696d616765732f313335393238383834383733323138303438342f52675f333955665f5f6e6f726d616c2e6a7067\"></a><p>Finally. <a href=\"https://t.co/RsSrv7ocsg\">https://twitter.com/workingjubilee/status/1459702038959251457/photo/1</a></p><span>- futurejubilee (@workingjubilee)</span><div class=\"twitter-image\"><a href=\"https://t.co/RsSrv7ocsg\"><img src=\"https://uploads.zulipusercontent.net/e624258e2e69a88e954d9c4f7cb98c2efe44ae61/68747470733a2f2f7062732e7477696d672e636f6d2f6d656469612f4645486e524d4a566b41556b654d382e6a70673a7468756d62\"></a></div></div></div>",
        "id": 261392387,
        "sender_full_name": "Jubilee",
        "timestamp": 1636855484
    },
    {
        "content": "<p>Nice</p>",
        "id": 261393426,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636857215
    },
    {
        "content": "<p>Did you happen to get a chance to look at the announcement?</p>",
        "id": 261393475,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636857248
    },
    {
        "content": "<p>I did, and I am appreciating it, and my eyes are also slightly crosseyed.</p>",
        "id": 261393555,
        "sender_full_name": "Jubilee",
        "timestamp": 1636857377
    },
    {
        "content": "<p>Hahaha. That's a good start then</p>",
        "id": 261393559,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636857395
    },
    {
        "content": "<p>I'll take it</p>",
        "id": 261393562,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636857401
    },
    {
        "content": "<p>Man, like it's good but also makes me wish <code>array_chunks</code> was in std. I wonder if it compiles the same anyways?</p>",
        "id": 261393718,
        "sender_full_name": "Jubilee",
        "timestamp": 1636857654
    },
    {
        "content": "<p>It depends if LLVM is smart enough to remove the slice length assert</p>",
        "id": 261393781,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636857752
    },
    {
        "content": "<p>when I was writing fourier transforms I found I generally needed to write custom iterators to do exactly what I wanted, so as far as the example goes I think <code>chunks</code> is probably fine for illustrating the point</p>",
        "id": 261393795,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636857802
    },
    {
        "content": "<p>That's fair.</p>",
        "id": 261394288,
        "sender_full_name": "Jubilee",
        "timestamp": 1636858675
    },
    {
        "content": "<p>Good idea adding the feature gate to the example</p>",
        "id": 261423369,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636904278
    },
    {
        "content": "<p>I read it over again, looks good to me so just lmk and I can open the PR</p>",
        "id": 261423618,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636904672
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"229517\">@Jacob Lifshay</span> if you want to read it over, too</p>",
        "id": 261423622,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636904682
    },
    {
        "content": "<p>lgtm!</p>",
        "id": 261430726,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636913627
    },
    {
        "content": "<p>considering if we want to explain design rationales a bit?</p>",
        "id": 261435846,
        "sender_full_name": "Jubilee",
        "timestamp": 1636920428
    },
    {
        "content": "<p>hmm, if we're going to have design rationale, maybe we should just put that in portable-simd's docs and link to that?</p>",
        "id": 261436009,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636920634
    },
    {
        "content": "<p>seems more useful that way, since that way it won't be a one-time thing</p>",
        "id": 261436027,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636920669
    },
    {
        "content": "<p>eh, all design rationales are mutable over time.</p>",
        "id": 261436093,
        "sender_full_name": "Jubilee",
        "timestamp": 1636920750
    },
    {
        "content": "<p>Yeah, I was wondering if we should too</p>",
        "id": 261436344,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636921179
    },
    {
        "content": "<p>I agree that they're mutable and really just reflects our current mindset</p>",
        "id": 261436351,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636921193
    },
    {
        "content": "<p>What were you thinking we should add?</p>",
        "id": 261436402,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636921231
    },
    {
        "content": "<p><a href=\"https://twitter.com/symeoncarle/status/1459865633542262784\">https://twitter.com/symeoncarle/status/1459865633542262784</a> we should clearly change the character we use for the type aliases just because everyone thinks it is that.</p>\n<div class=\"inline-preview-twitter\"><div class=\"twitter-tweet\"><a href=\"https://twitter.com/symeoncarle/status/1459865633542262784\"><img class=\"twitter-avatar\" src=\"https://uploads.zulipusercontent.net/3d5c0584d6fe48722da5ba504f8006eba1647d1b/68747470733a2f2f7062732e7477696d672e636f6d2f70726f66696c655f696d616765732f313430373335323933343231323535303636362f34483768325062785f6e6f726d616c2e6a7067\"></a><p><a href=\"https://twitter.com/workingjubilee\">@workingjubilee</a> <a href=\"https://twitter.com/fasterthanlime\">@fasterthanlime</a> <a href=\"https://t.co/QmaH0ChESc\">https://twitter.com/symeoncarle/status/1459865633542262784/photo/1</a></p><span>- Symon Carle (@symeoncarle)</span><div class=\"twitter-image\"><a href=\"https://t.co/QmaH0ChESc\"><img src=\"https://uploads.zulipusercontent.net/cf708644b3436d7d2815ce032995e6be0823c9e5/68747470733a2f2f7062732e7477696d672e636f6d2f6d656469612f46454a3844436d5877417770365f422e6a70673a7468756d62\"></a></div></div></div>",
        "id": 261438583,
        "sender_full_name": "Jubilee",
        "timestamp": 1636924327
    },
    {
        "content": "<p>lol, i'll get right on that</p>",
        "id": 261443077,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636930980
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span> regarding design rationale, I just added the single sentence</p>\n<blockquote>\n<p>This design allows SIMD vectors to be treated like containers, much like arrays or <code>Vec</code>.</p>\n</blockquote>",
        "id": 261444064,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636932151
    },
    {
        "content": "<p>I think that mostly sums up our design principles, I'm just not sure if that's the right way of phrasing it</p>",
        "id": 261444109,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636932229
    },
    {
        "content": "<p>Yeah, our <code>Simd</code> type is essentially an array that you can interact with like it is a \"single\" number.</p>",
        "id": 261445421,
        "sender_full_name": "Jubilee",
        "timestamp": 1636934142
    },
    {
        "content": "<p>anything else you think should be added?</p>",
        "id": 261447476,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636937112
    },
    {
        "content": "<p>Question I am seeing: \"does this work for ${target}?\"</p>",
        "id": 261491190,
        "sender_full_name": "Jubilee",
        "timestamp": 1636979930
    },
    {
        "content": "<p>Hmm I thought that was implied...</p>",
        "id": 261491244,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636979966
    },
    {
        "content": "<p>I think people may have a legitimate question like<br>\n\"Wait, how would it work for ${TARGET_WITHOUT_SIMD_ISA}?\"</p>",
        "id": 261491853,
        "sender_full_name": "Jubilee",
        "timestamp": 1636980396
    },
    {
        "content": "<p>That's true</p>",
        "id": 261491876,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636980422
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span> I rearranged and added a little bit to explain what portable means</p>",
        "id": 261511033,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636989548
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"312331\">@Caleb Zulawski</span> pong, I added some deets.</p>",
        "id": 261559351,
        "sender_full_name": "Jubilee",
        "timestamp": 1637010554
    },
    {
        "content": "<p>basically FAQing what people are tweeting at me</p>",
        "id": 261559604,
        "sender_full_name": "Jubilee",
        "timestamp": 1637010662
    },
    {
        "content": "<p>mind splitting out the blog stuff into a separate zulip topic? it'll make it much easier to find</p>",
        "id": 261559645,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1637010680
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span> do you mind if I add some of what you added into the what is portable section?  I think it's a little repetitive as it stands now</p>",
        "id": 261560183,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637010919
    },
    {
        "content": "<p>Yes, please feel free to revise it, <span class=\"user-mention\" data-user-id=\"312331\">@Caleb Zulawski</span></p>",
        "id": 261560277,
        "sender_full_name": "Jubilee",
        "timestamp": 1637010962
    },
    {
        "content": "<p>Okay <span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span>, I made some changes</p>",
        "id": 261563760,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637012649
    },
    {
        "content": "<p>I tried to integrate what you added into the existing paragraphs</p>",
        "id": 261563783,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637012665
    },
    {
        "content": "<p>I also removed some of the things about optimization and LLVM representation because I think it was a little too specific, since we want this API to work with any backend anyway</p>",
        "id": 261563854,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637012709
    },
    {
        "content": "<p>I kind of rephrased that to say sometimes you may just need specific target instructions</p>",
        "id": 261563899,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1637012735
    }
]