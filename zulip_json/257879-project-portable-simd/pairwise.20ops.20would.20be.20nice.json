[
    {
        "content": "<p>Though speaking of horizontal ops: If Rust defaulted to pairwise summation for summing iterators of floating point numbers it would be both more accurate and also vectorizable.</p>",
        "id": 269982375,
        "sender_full_name": "Jubilee",
        "timestamp": 1643607553
    },
    {
        "content": "<p>It'd be really nice if core could guarantee O(Îµâˆšn) accuracy from <code>Iterator::sum</code> on floats.</p>\n<p>I tried to do compensated summation in <code>sum</code> a while back, hoping that SIMDing could recover the perf from the extra operations, but didn't manage to pull it off.  That was pre-<code>stdsimd</code>, though, so it might be easier now.</p>\n<p>Though a huge part of the problem was that I couldn't find a way that optimized well to get 4-item chunks from iterators -- even slice iterators everything I tried went poorly.</p>",
        "id": 269997903,
        "sender_full_name": "scottmcm",
        "timestamp": 1643619335
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/horizontal.20traits/near/269972538\">said</a>:</p>\n<blockquote>\n<p>Note that traits for <code>min</code> and <code>sqrt</code> and such would also be useful for generic scalar code, but <code>core</code> doesn't have them.  So it's not obvious to me that traits for horizontal stuff would be accepted.<br>\n...</p>\n</blockquote>\n<p>Good point.  The <code>num_traits</code> crate has many of these traits already and might be a good place to add simd support.</p>",
        "id": 270043754,
        "sender_full_name": "Daniel Goertzen",
        "timestamp": 1643640982
    },
    {
        "content": "<p>Compensated summation is probably overkill, pairwise summation is <code>O(log n)</code>.</p>",
        "id": 270050571,
        "sender_full_name": "Jubilee",
        "timestamp": 1643643421
    },
    {
        "content": "<p>Like that may sound like a big error margin but also our current error is <code>O(n)</code> and pairwise sums is apparently a good enough default for Julia and NumPy. You know. The highly technical language and the numerical library.</p>",
        "id": 270062736,
        "sender_full_name": "Jubilee",
        "timestamp": 1643647380
    },
    {
        "content": "<p>I have also generated a Bad Opinion on how we would make sure it would optimize well: <a href=\"https://twitter.com/workingjubilee/status/1488189719464669186\">https://twitter.com/workingjubilee/status/1488189719464669186</a></p>\n<div class=\"inline-preview-twitter\"><div class=\"twitter-tweet\"><a href=\"https://twitter.com/workingjubilee/status/1488189719464669186\"><img class=\"twitter-avatar\" src=\"https://uploads.zulipusercontent.net/b918d32b7ab0e274b678c4f5dfa1cb06074b0d52/68747470733a2f2f7062732e7477696d672e636f6d2f70726f66696c655f696d616765732f313335393238383834383733323138303438342f52675f333955665f5f6e6f726d616c2e6a7067\"></a><p>this would be trivial to implement if we had\n*presses lips to the mic*\ntail call optimization</p><span>- hyperðŸ’‰ðŸ’‰ðŸ’‰jubilee (@workingjubilee)</span></div></div>",
        "id": 270067044,
        "sender_full_name": "Jubilee",
        "timestamp": 1643648896
    },
    {
        "content": "<p>its tricky to implement pairwise summation on top of the iterator trait, but we could specialize for slices and such a version that did this.</p>",
        "id": 270073836,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1643651336
    },
    {
        "content": "<p>Yeah, I don't think that belongs as part of iterators</p>",
        "id": 270076200,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1643652153
    },
    {
        "content": "<p>I think it would be nice if slice.iter().sum::&lt;f64&gt;() and the like used non-naive summation.</p>",
        "id": 270076660,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1643652318
    },
    {
        "content": "<p>but it's a bit odd, and i don't think it matters that much. even pairwise or kahan isnt what you want if you really care about accuracy (i think we have a decent sum implementation in libtest somewhere)</p>",
        "id": 270077200,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1643652491
    },
    {
        "content": "<p>this is out of scope for simd group probably.</p>",
        "id": 270077233,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1643652504
    },
    {
        "content": "<p>I tend to agree, there are probably dozens of implementations suitable for different tasks</p>",
        "id": 270077335,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1643652539
    },
    {
        "content": "<p>Well, mostly I brought it up because apparently packed_simd was intending to define horizontal ops as pairwise.</p>",
        "id": 270077340,
        "sender_full_name": "Jubilee",
        "timestamp": 1643652542
    },
    {
        "content": "<p>( the term used was \"tree-reduction\". )</p>",
        "id": 270077406,
        "sender_full_name": "Jubilee",
        "timestamp": 1643652570
    },
    {
        "content": "<p>( this means the same thing, just depending on whether or not your head is tilted sideways. )</p>",
        "id": 270077460,
        "sender_full_name": "Jubilee",
        "timestamp": 1643652595
    },
    {
        "content": "<p>I _think_ the most suitable default is ordered such that it's equivalent to scalar implementations of any width, and anything that isn't sequential is useful for specific tasks where you're aware it's doing something slightly different</p>",
        "id": 270077669,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1643652662
    },
    {
        "content": "<p>well...the problem is not all hardware has reduction ops that are tree-wise reduction...so I think we should leave it as unspecified order</p>",
        "id": 270077751,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643652699
    },
    {
        "content": "<p>Well right now all of our reductions are specified to be sequential, not unspecified</p>",
        "id": 270077862,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1643652733
    },
    {
        "content": "<p>I think unspecified order is probably also out of scope since it's really a subset of fast math</p>",
        "id": 270077928,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1643652761
    },
    {
        "content": "<p>For horizontal_min and horizontal_max, though, it shouldn't matter, right?</p>",
        "id": 270078153,
        "sender_full_name": "Jubilee",
        "timestamp": 1643652848
    },
    {
        "content": "<p>well...sequential is kinda the worst choice...it has terrible numeric properties and often terrible hardware performance</p>",
        "id": 270078161,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643652852
    },
    {
        "content": "<p>it also doesn't matter for integer ops cuz those are associative</p>",
        "id": 270078230,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643652881
    },
    {
        "content": "<p>Right, we're only really talking about horizontal sum and product.</p>",
        "id": 270078285,
        "sender_full_name": "Jubilee",
        "timestamp": 1643652903
    },
    {
        "content": "<p>Sequential is chosen because it's the easiest to define and understand imo</p>",
        "id": 270078288,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1643652904
    },
    {
        "content": "<p>SimpleV defines all reductions to be tree reductions</p>",
        "id": 270078374,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643652948
    },
    {
        "content": "<p>There's nothing preventing you from doing anything else, and I think a future fast math extension would help you get the best version for your hardware</p>",
        "id": 270078391,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1643652952
    },
    {
        "content": "<p>It sucks tho'.<br>\nSequential summation will always yield less accurate results than pairwise and isn't necessarily appreciably faster.</p>",
        "id": 270078506,
        "sender_full_name": "Jubilee",
        "timestamp": 1643652991
    },
    {
        "content": "<p>In fact, I am pretty sure it's less fast on most arches.</p>",
        "id": 270078711,
        "sender_full_name": "Jubilee",
        "timestamp": 1643653075
    },
    {
        "content": "<p>A simple answer is that LLVM simply doesn't support it right now</p>",
        "id": 270078851,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1643653122
    },
    {
        "content": "<p>It has sequential, and unspecified</p>",
        "id": 270078882,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1643653137
    },
    {
        "content": "<p>Well yes, but that doesn't actually stop us from coding it to use the pairwise version.</p>",
        "id": 270078952,
        "sender_full_name": "Jubilee",
        "timestamp": 1643653166
    },
    {
        "content": "<p>now that i look again...simplev also has sequential reduction, but it's likely quite slow</p>",
        "id": 270078989,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643653182
    },
    {
        "content": "<p>It would be possible yeah, but you do potentially lose optimization opportunities.</p>",
        "id": 270079034,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1643653194
    },
    {
        "content": "<p>And by not using an intrinsic you also lose the ability to use a future fast math feature if that ever happens</p>",
        "id": 270079162,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1643653233
    },
    {
        "content": "<p>And maybe gain others? We could still use vector math.<br>\nI recommend we despecify the horizontal ops order for the moment, not as a commitment to a particular ordering or even to a lack of ordering, but simply because we actually want to leave our options open.</p>",
        "id": 270079259,
        "sender_full_name": "Jubilee",
        "timestamp": 1643653276
    },
    {
        "content": "<p>I think by definition of being \"portable\" it needs to be specified</p>",
        "id": 270079494,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1643653351
    },
    {
        "content": "<p>We discovered that rustc was emitting fast-math incorrectly precisely because we compared it to the equivalent scalar form</p>",
        "id": 270079589,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1643653391
    },
    {
        "content": "<p>Well yes, I am only saying that we should de-order it long enough to investigate what's actually best.</p>",
        "id": 270079603,
        "sender_full_name": "Jubilee",
        "timestamp": 1643653397
    },
    {
        "content": "<p>I would argue that we leave it specified and since it's an unstable feature we can change it in the future</p>",
        "id": 270079702,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1643653433
    },
    {
        "content": "<p>...Fair!</p>",
        "id": 270079798,
        "sender_full_name": "Jubilee",
        "timestamp": 1643653462
    },
    {
        "content": "<p>the tree-reduction algorithm SimpleV uses: <a href=\"https://libre-soc.org/openpower/sv/svp64/appendix/#index13h1\">https://libre-soc.org/openpower/sv/svp64/appendix/#index13h1</a></p>",
        "id": 270079814,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643653468
    },
    {
        "content": "<p>Not that I'm totally against all reduction algorithms, but with both avx and neon it makes very little difference if you do it sequentially or pairwise, and I'm not yet convinced that all architectures that do it pairwise do it the exact same way</p>",
        "id": 270079994,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1643653551
    },
    {
        "content": "<p>I think we should avoid specifying it for the horizontal ops. It shouldn't be wide enough to really matter.</p>",
        "id": 270080002,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1643653555
    },
    {
        "content": "<p>If it's not specified I don't think it meets the criteria of being portable.</p>",
        "id": 270080101,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1643653590
    },
    {
        "content": "<p>f32::sin isn't specified to the last bit, but most would agree it's portable</p>",
        "id": 270080213,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643653640
    },
    {
        "content": "<p>what measure a <del>man</del> portable function?</p>",
        "id": 270080271,
        "sender_full_name": "Jubilee",
        "timestamp": 1643653666
    },
    {
        "content": "<p>I don't think things need to be specified exactly to be portable enough for 99+% of use cases, if I'm being honest.</p>",
        "id": 270081638,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1643654193
    },
    {
        "content": "<p>If it's just about performance, I think that's what fast-math would be suitable for</p>",
        "id": 270081989,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1643654347
    },
    {
        "content": "<p>Fast math has no RFC for it or anyone working on it tho'.</p>",
        "id": 270082191,
        "sender_full_name": "Jubilee",
        "timestamp": 1643654414
    },
    {
        "content": "<p>Otherwise if you absolutely need a specific portable order you're mostly out of luck, because that's somewhat nontrivial to implement</p>",
        "id": 270082214,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1643654420
    },
    {
        "content": "<p>I know I have suggested waiting for seemingly outlandish things landing but most had actually made it to an RFC proposal and something resembling a partial implementation drafted.</p>",
        "id": 270082291,
        "sender_full_name": "Jubilee",
        "timestamp": 1643654454
    },
    {
        "content": "<p>I don't think this one is very crazy though, it may end up being an <code>unordered_horizontal_sum</code> for all we know, but I don't think having unordered sums is a critical feature of _portable_ simd</p>",
        "id": 270082524,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1643654532
    },
    {
        "content": "<p>ew.</p>",
        "id": 270082577,
        "sender_full_name": "Jubilee",
        "timestamp": 1643654555
    },
    {
        "content": "<p>If you want any particular type of sum there's nothing preventing you from writing it</p>",
        "id": 270082658,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1643654586
    },
    {
        "content": "<p>tru</p>",
        "id": 270083237,
        "sender_full_name": "Jubilee",
        "timestamp": 1643654801
    },
    {
        "content": "<p>I think we should still at least explore if we can persuade LLVM to <strong>consistently</strong> emit horizontal tree reductions.</p>",
        "id": 270083312,
        "sender_full_name": "Jubilee",
        "timestamp": 1643654830
    },
    {
        "content": "<p>Yeah, we can definitely explore that, but before making it a default I think we need to at least prove that there isn't any loss of performance on any architectures</p>",
        "id": 270083501,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1643654891
    },
    {
        "content": "<p>sequentially ordered reduction is twice as many instructions on avx2 for <code>f32x8</code>: <a href=\"https://llvm.godbolt.org/z/dhbdoeq4d\">https://llvm.godbolt.org/z/dhbdoeq4d</a></p>",
        "id": 270083594,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643654943
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 270083662,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643654978
    },
    {
        "content": "<p>Ah.<br>\nOh I should note:<br>\nThe IEEE754 <code>sum</code> function is actually specified to allow reassociation.</p>",
        "id": 270083718,
        "sender_full_name": "Jubilee",
        "timestamp": 1643654995
    },
    {
        "content": "<p>So that's part of why my stance has shifted so far towards allowing reassociation of any kind instead of purely sequential ordering on this one.<br>\n<strong>Kahan wills it.</strong></p>",
        "id": 270084084,
        "sender_full_name": "Jubilee",
        "timestamp": 1643655083
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/horizontal.20traits/near/270062736\">said</a>:</p>\n<blockquote>\n<p>Like that may sound like a big error margin but also our current error is <code>O(n)</code> and pairwise sums is apparently a good enough default for Julia and NumPy. You know. The highly technical language and the numerical library.</p>\n</blockquote>\n<p>So there is a long and <a href=\"https://discourse.julialang.org/t/accurate-summation-algorithm/7163/22\">legendary Julia thread</a> about Kahan (pairwise) summation and SIMD vectorizability and its history.<br>\nTL;DR - no one's yet found a way to make pairwise summation fast enough, if someone ever needs the implementation it's an easy import away.</p>",
        "id": 270084394,
        "sender_full_name": "Miguel Raz GuzmÃ¡n Macedo",
        "timestamp": 1643655135
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246783\">Miguel Raz GuzmÃ¡n Macedo</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/horizontal.20traits/near/270084394\">said</a>:</p>\n<blockquote>\n<p>TL;DR - no one's yet found a way to make pairwise summation fast enough, if someone ever needs the implementation it's an easy import away.</p>\n</blockquote>\n<p>Wait, pairwise summation ISN'T fast enough?</p>",
        "id": 270084627,
        "sender_full_name": "Jubilee",
        "timestamp": 1643655177
    },
    {
        "content": "<p>Ah derp, I mixed up the names. If pairwise isn't accurate enough, people can reach for the compensated/Kahan algorithm easily.<br>\nRarely do people need it, and we'd know about it.</p>",
        "id": 270085016,
        "sender_full_name": "Miguel Raz GuzmÃ¡n Macedo",
        "timestamp": 1643655281
    },
    {
        "content": "<p>Ohhhh okay!</p>",
        "id": 270085029,
        "sender_full_name": "Jubilee",
        "timestamp": 1643655289
    },
    {
        "content": "<p>I checked because I was curious, you're right that IEEE 754 doesn't specify any orders of reductions</p>",
        "id": 270085039,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1643655294
    },
    {
        "content": "<p>Yeah it specifically specifies pro-reassociation in the 2008 version.</p>",
        "id": 270085081,
        "sender_full_name": "Jubilee",
        "timestamp": 1643655313
    },
    {
        "content": "<p>in the 2019 version, it doesn't specify reassociation or not for scaledProd (the closest thing it has to product)</p>",
        "id": 270085286,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643655397
    },
    {
        "content": "<p>I've SIMDed first-order kahan summation before. I just did 4 streams at a time, and then summed them at the end (with scalar kahan summation). I think this might lose some benefits, but it was possible and fast.</p>\n<p>That said, I agree that there's so many techniques here that I think doing more than pairwise would be a bit overkill.</p>",
        "id": 270085941,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1643655631
    },
    {
        "content": "<p>I mean you can always implement the <a href=\"https://arxiv.org/abs/1505.05571\">superaccumulators paper</a>.</p>",
        "id": 270086086,
        "sender_full_name": "Miguel Raz GuzmÃ¡n Macedo",
        "timestamp": 1643655684
    },
    {
        "content": "<p>avx512f reduction: <a href=\"https://llvm.godbolt.org/z/bPjcfvor8\">https://llvm.godbolt.org/z/bPjcfvor8</a> sequential reduction is like 4x as many instructions -- there's no way that's fast</p>",
        "id": 270086139,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643655706
    },
    {
        "content": "<p>I personally think there is no good reason to go with any specific ordering that isn't sequential--it should either be sequential for repeatability or unspecified for performance, anything in between is probably based on the user's domain</p>",
        "id": 270086324,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1643655769
    },
    {
        "content": "<p>i'd argue we should have a specific tree reduction for repeatability...it should be waay faster than sequential and fast enough on all archs that have decent swizzles</p>",
        "id": 270086535,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643655859
    },
    {
        "content": "<p>Yeah, I only mentioned tree reductions because they <strong>do</strong> have a precise order, but are directly in the hardware (or easy to emulate), <strong>and</strong> are reasonably fast.</p>",
        "id": 270087011,
        "sender_full_name": "Jubilee",
        "timestamp": 1643656044
    },
    {
        "content": "<p>Take vectors, deinterleave, add.</p>",
        "id": 270087282,
        "sender_full_name": "Jubilee",
        "timestamp": 1643656139
    },
    {
        "content": "<p>Better than fast math is having the same transformation that fast math emits without allowing it to do \"whatever, lol\".</p>",
        "id": 270088117,
        "sender_full_name": "Jubilee",
        "timestamp": 1643656438
    },
    {
        "content": "<p>That said I agree with Caleb that if we can't actually improve perf while staying consistent, then F it.</p>",
        "id": 270088508,
        "sender_full_name": "Jubilee",
        "timestamp": 1643656571
    },
    {
        "content": "<p>Ideally we would have some sample programs to bench on that does a bunch of transformations on input float data and then does huge piles of summations and products.</p>",
        "id": 270088721,
        "sender_full_name": "Jubilee",
        "timestamp": 1643656667
    },
    {
        "content": "<p>Fortunately I think horizontal operations are typically not expected to be blazing fast so much as \"not terrible\"</p>",
        "id": 270089060,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1643656793
    },
    {
        "content": "<p>So we likely have some leeway over what makes the most sense overall</p>",
        "id": 270089167,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1643656821
    },
    {
        "content": "<p>Yeah, we're more trying to do \"okay\" with these.</p>",
        "id": 270089850,
        "sender_full_name": "Jubilee",
        "timestamp": 1643657096
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/horizontal.20traits/near/270085941\">said</a>:</p>\n<blockquote>\n<p>I've SIMDed first-order kahan summation before. I just did 4 streams at a time, and then summed them at the end (with scalar kahan summation). I think this might lose some benefits, but it was possible and fast.</p>\n</blockquote>\n<p><a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=c808f151daf3fd73282b779a69a17f59\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=c808f151daf3fd73282b779a69a17f59</a> is essentially what I did. (I'm not saying we should use this for anything, but I was curious if I would hit any issues with using std::simd for it)</p>",
        "id": 270090470,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1643657326
    },
    {
        "content": "<p>Unless AVX512 changes things, the only good horizontal ops on x86 are for small integers, where they're used for video codecs and such.</p>",
        "id": 270090583,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1643657384
    },
    {
        "content": "<p>So yeah, the ones for floats just need to be \"not worse than doing it manually\"</p>",
        "id": 270090670,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1643657405
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/horizontal.20traits/near/270090583\">said</a>:</p>\n<blockquote>\n<p>Unless AVX512 changes things, the only good horizontal ops on x86 are for small integers, where they're used for video codecs and such.</p>\n</blockquote>\n<p>Ah okay!</p>",
        "id": 270090737,
        "sender_full_name": "Jubilee",
        "timestamp": 1643657435
    },
    {
        "content": "<p>Opened an issue: <a href=\"https://github.com/rust-lang/portable-simd/issues/235\">https://github.com/rust-lang/portable-simd/issues/235</a></p>",
        "id": 270090902,
        "sender_full_name": "Jubilee",
        "timestamp": 1643657495
    },
    {
        "content": "<p>I'm definitely a fan of pairwise -- I even added <a href=\"https://docs.rs/itertools/latest/itertools/trait.Itertools.html#method.tree_fold1\">https://docs.rs/itertools/latest/itertools/trait.Itertools.html#method.tree_fold1</a> to have it for iterators.</p>\n<p>I think <code>Iterator::sum</code> should do a good thing (at least better than linear) for the same reason that <code>.sort()</code> is stable.  We should give something without footguns, and people can write <code>.reduce(Add::add)</code> if they want the naÃ¯ve one.</p>",
        "id": 270092553,
        "sender_full_name": "scottmcm",
        "timestamp": 1643658168
    },
    {
        "content": "<p>By the way, vectors right now don't even implement IntoIterator, so I doubt it's likely that someone will accidentally go through iterators. You'd have to pretty explicitly convert to a slice or array</p>",
        "id": 270093192,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1643658453
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"229517\">@Jacob Lifshay</span> <br>\nLooks like your architect intends to support both \"orientations\". ^^;</p>\n<blockquote>\n<p>Luke Kenneth Casson Leighton 2022-02-02 00:44:46 GMT</p>\n<p>there is already a \"reverse gear\" bit in SVP64</p>\n</blockquote>",
        "id": 270315967,
        "sender_full_name": "Jubilee",
        "timestamp": 1643763515
    },
    {
        "content": "<p><a href=\"https://bugs.libre-soc.org/show_bug.cgi?id=697#c4\">https://bugs.libre-soc.org/show_bug.cgi?id=697#c4</a></p>",
        "id": 270316564,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643763840
    },
    {
        "content": "<p>that reverse bit is for starting from the end and going to the beginning of a vector iirc</p>",
        "id": 270316669,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643763899
    },
    {
        "content": "<p>for things where order matters like scatter-store</p>",
        "id": 270316717,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643763931
    },
    {
        "content": "<p>ahhh.</p>",
        "id": 270316735,
        "sender_full_name": "Jubilee",
        "timestamp": 1643763949
    },
    {
        "content": "<p>I mean, arguably the operation is the same \"reversed\" in that sense, right? so the reverse gear bit could control that? or is it on a machine level and not per-instruction?</p>",
        "id": 270316850,
        "sender_full_name": "Jubilee",
        "timestamp": 1643764003
    },
    {
        "content": "<p>it's per instruction...it could control tree-reduce order, but we'd need to define it to do that and add the extra hardware paths to support both kinds of tree reduce efficiently</p>",
        "id": 270317017,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643764088
    },
    {
        "content": "<p>that's true.</p>",
        "id": 270317053,
        "sender_full_name": "Jubilee",
        "timestamp": 1643764121
    },
    {
        "content": "<p>(also, Luke isn't the only architect, it's a joint effort)</p>",
        "id": 270318073,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643764728
    },
    {
        "content": "<p>tru, I just figured \"we already have that tho'.\" would have been decisive, but maybe not~</p>",
        "id": 270318291,
        "sender_full_name": "Jubilee",
        "timestamp": 1643764834
    },
    {
        "content": "<p><a href=\"https://developer.arm.com/documentation/ddi0602/2021-09/SVE-Instructions/FADDV--Floating-point-add-recursive-reduction-to-scalar-?lang=en\">https://developer.arm.com/documentation/ddi0602/2021-09/SVE-Instructions/FADDV--Floating-point-add-recursive-reduction-to-scalar-?lang=en</a> can't quite tell if this has the same reduction pattern as <a href=\"https://developer.arm.com/documentation/ddi0602/2021-09/SIMD-FP-Instructions/FADDP--vector---Floating-point-Add-Pairwise--vector--?lang=en\">https://developer.arm.com/documentation/ddi0602/2021-09/SIMD-FP-Instructions/FADDP--vector---Floating-point-Add-Pairwise--vector--?lang=en</a> at a glance...</p>",
        "id": 270319021,
        "sender_full_name": "Jubilee",
        "timestamp": 1643765226
    },
    {
        "content": "<p>it would be very annoying if the answer was \"no lol\"</p>",
        "id": 270319158,
        "sender_full_name": "Jubilee",
        "timestamp": 1643765304
    },
    {
        "content": "<p>currently checking...arm's website is a pain</p>",
        "id": 270319791,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643765765
    },
    {
        "content": "<p>arm's reduce pseudocode:</p>\n<div class=\"codehilite\"><pre><span></span><code>// Reduce()\n// ========\n\nbits(esize) Reduce(ReduceOp op, bits(N) input, integer esize)\n    boolean altfp = HaveAltFP() &amp;&amp; !UsingAArch32() &amp;&amp; FPCR.AH == &#39;1&#39;;\n    return Reduce(op, input, esize, altfp);\n\n// Reduce()\n// ========\n// Perform the operation &#39;op&#39; on pairs of elements from the input vector,\n// reducing the vector to a scalar result. The &#39;altfp&#39; argument controls\n// alternative floating-point behaviour.\n\nbits(esize) Reduce(ReduceOp op, bits(N) input, integer esize, boolean altfp)\n    integer half;\n    bits(esize) hi;\n    bits(esize) lo;\n    bits(esize) result;\n\n    if N == esize then\n        return input&lt;esize-1:0&gt;;\n\n    half = N DIV 2;\n    hi = Reduce(op, input&lt;N-1:half&gt;, esize, altfp);\n    lo = Reduce(op, input&lt;half-1:0&gt;, esize, altfp);\n\n    case op of\n        when ReduceOp_FMINNUM\n            result = FPMinNum(lo, hi, FPCR[]);\n        when ReduceOp_FMAXNUM\n            result = FPMaxNum(lo, hi, FPCR[]);\n        when ReduceOp_FMIN\n            result = FPMin(lo, hi, FPCR[], altfp);\n        when ReduceOp_FMAX\n            result = FPMax(lo, hi, FPCR[], altfp);\n        when ReduceOp_FADD\n            result = FPAdd(lo, hi, FPCR[]);\n        when ReduceOp_ADD\n            result = lo + hi;\n\n    return result;\n</code></pre></div>",
        "id": 270320472,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643766232
    },
    {
        "content": "<p>addp just does one step of a reduction...addv does a full reduction</p>",
        "id": 270321073,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643766629
    },
    {
        "content": "<p>afaict addp matches the first step of addv</p>",
        "id": 270321096,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643766661
    },
    {
        "content": "<p>idk what arm's designers were thinking...that reduction algorithm sounds like hell to implement in hardware</p>",
        "id": 270321468,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643766908
    },
    {
        "content": "<p>Ah okay~</p>",
        "id": 270322467,
        "sender_full_name": "Jubilee",
        "timestamp": 1643767563
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"229517\">Jacob Lifshay</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/pairwise.20ops.20would.20be.20nice/near/270321468\">said</a>:</p>\n<blockquote>\n<p>idk what arm's designers were thinking...that reduction algorithm sounds like hell to implement in hardware</p>\n</blockquote>\n<p>possibly \"this seems like it would be most extensible to longer lane counts\"?</p>",
        "id": 270327793,
        "sender_full_name": "Jubilee",
        "timestamp": 1643772074
    },
    {
        "content": "<p>the algorithm i picked for SimpleV handles all vector sizes, including non-power-of-2, and always does transfers aligned to power-of-2 offsets, greatly improving efficiency and reducing the number of wires necessary to implement it and simplifying offset calculations in hardware</p>",
        "id": 270328035,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643772259
    },
    {
        "content": "<p>it seems like they just picked a random divide-and-conquer algorithm and put in arm-specific stuff, giving no thought to the difficulty of hardware implementation</p>",
        "id": 270328272,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643772504
    },
    {
        "content": "<p>Maybe it's a lie lol.</p>",
        "id": 270328281,
        "sender_full_name": "Jubilee",
        "timestamp": 1643772516
    },
    {
        "content": "<p>maybe they just have whatever in their pseudo-code and have a more reasonable hw implementation</p>",
        "id": 270328308,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643772561
    },
    {
        "content": "<p>Oh you know<br>\nArm is designing entirely for software cores anyways, right?</p>",
        "id": 270328309,
        "sender_full_name": "Jubilee",
        "timestamp": 1643772563
    },
    {
        "content": "<p>Like I know they actually get materialized as hardware but I wonder if it's not obvious in their builds... and yeah that's what I mean by \"Maybe it's a lie lol\".</p>",
        "id": 270328341,
        "sender_full_name": "Jubilee",
        "timestamp": 1643772596
    },
    {
        "content": "<p>well...if that's the best they can do, i feel sorry for their hw division</p>",
        "id": 270328403,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643772641
    },
    {
        "content": "<p>How do they diverge on hmm say f32x12 vectors?</p>",
        "id": 270328492,
        "sender_full_name": "Jubilee",
        "timestamp": 1643772737
    },
    {
        "content": "<p>lemme make a diagram...</p>",
        "id": 270328510,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643772773
    },
    {
        "content": "<p>since as you mentioned the diagram seems to be identical for f32x8 vectors.</p>",
        "id": 270328528,
        "sender_full_name": "Jubilee",
        "timestamp": 1643772797
    },
    {
        "content": "<p>diagrams showing why arm's algorithm is bad for hardware</p>\n<div class=\"codehilite\"><pre><span></span><code>@ is fadd.\n\narm reduce f32x12:\n\n0  1  2  3  4  5  6  7  8  9 10 11\n|  |  |  |  |  |  |  |  |  |  |  |\n|  @--/  |  @--/  |  @--/  |  @--/ &lt;- nonuniform\n|  |  .  |  |  .  |  |  .  |  |\n@--/  .  @--/  .  @--/  .  @--/\n|  .  .  |  .  .  |  .  .  |\n@--------/  .  .  @--------/\n|  .  .  .  .  .  |\n@-----------------/\n|\n\narm reduce f32x13 (notice the new element\neffectively gets inserted in index 10):\n\n0  1  2  3  4  5  6  7  8  9 10 11 12\n|  |  |  |  |  |  |  |  |  |  |  |  |\n|  @--/  |  @--/  |  @--/  @--/  @--/ &lt;- nonuniform\n|  |  .  |  |  .  |  |  .  |  .  |\n@--/  .  @--/  .  @--/  .  @-----/\n|  .  .  |  .  .  |  .  .  |\n@--------/  .  .  @--------/\n|  .  .  .  .  .  |\n@-----------------/\n|\n\nSimpleV original reduce f32x12:\n\n0  1  2  3  4  5  6  7  8  9 10 11\n|  |  |  |  |  |  |  |  |  |  |  |\n@--/  @--/  @--/  @--/  @--/  @--/ &lt;- uniform\n|  .  |  .  |  .  |  .  |  .  |\n@-----/  .  @-----/  .  @-----/\n|  .  .  .  |  .  .  .  |\n@-----------/  .  .  .  |\n|  .  .  .  .  .  .  .  |\n@-----------------------/\n|\n\nSimpleV original reduce f32x13 (new element\nis always at end):\n\n0  1  2  3  4  5  6  7  8  9 10 11 12\n|  |  |  |  |  |  |  |  |  |  |  |  |\n@--/  @--/  @--/  @--/  @--/  @--/  | &lt;- uniform\n|  .  |  .  |  .  |  .  |  .  |  .  |\n@-----/  .  @-----/  .  @-----/  .  |\n|  .  .  .  |  .  .  .  |  .  .  .  |\n@-----------/  .  .  .  @-----------/\n|  .  .  .  .  .  .  .  |\n@-----------------------/\n|\n</code></pre></div>",
        "id": 270330368,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643774377
    },
    {
        "content": "<p>Ahhh, I don't think the f32x13 case can happen on Arm, can it?</p>",
        "id": 270330892,
        "sender_full_name": "Jubilee",
        "timestamp": 1643774710
    },
    {
        "content": "<p>maybe? they definitely have similar issues on other non-power-of-2 lengths tho</p>",
        "id": 270330988,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643774783
    },
    {
        "content": "<p>(Nice to see that the SimpleV one is <em>exactly</em> the order I drew in ascii art for <a href=\"https://docs.rs/itertools/latest/itertools/trait.Itertools.html#method.tree_fold1\">https://docs.rs/itertools/latest/itertools/trait.Itertools.html#method.tree_fold1</a> , albeit formatted slightly differently.)</p>",
        "id": 270331043,
        "sender_full_name": "scottmcm",
        "timestamp": 1643774852
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"229517\">Jacob Lifshay</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/pairwise.20ops.20would.20be.20nice/near/270330988\">said</a>:</p>\n<blockquote>\n<p>maybe? they definitely have similar issues on other non-power-of-2 lengths tho</p>\n</blockquote>\n<p>Oh yeah, I am just saying that unless the mask changes things a lot instead of just being \"add zero\" (which is what I thought it was?), Arm SVE goes 128 bits at a time, so Arm f32 vectors have a factor of 4 going on.</p>",
        "id": 270333031,
        "sender_full_name": "Jubilee",
        "timestamp": 1643776777
    },
    {
        "content": "<p>arm sve can still have vector lengths of 128bits*5 iirc</p>",
        "id": 270333134,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643776836
    },
    {
        "content": "<p>I think jubilee meant there is always a factor of 4 from the 128 itself</p>",
        "id": 270333183,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1643776888
    },
    {
        "content": "<p>Yes, that's f32x(4 * 5).</p>",
        "id": 270333210,
        "sender_full_name": "Jubilee",
        "timestamp": 1643776920
    },
    {
        "content": "<p>I wouldn't mind committing to the SimpleV pattern as it... obviously seems the most intuitive, given that both  Arm, SimpleV, and semi-random Rust programmers have come up with it? but it seems to optimize poorly for LLVM.</p>",
        "id": 270334138,
        "sender_full_name": "Jubilee",
        "timestamp": 1643777702
    },
    {
        "content": "<p>maybe it's just the way I wrote it in that example that uses full-length vectors till the end, then takes the first element. llvm might do better if i rewrote it to delete unneeded elements</p>",
        "id": 270334384,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643777892
    },
    {
        "content": "<p>Seems plausible. Probably generating a lot of dead weight for LLVM to try to peer through.<br>\nIt's a dragon, not a psychic, and it's a Western one so it probably doesn't have the ability to magically disperse fog.</p>",
        "id": 270334439,
        "sender_full_name": "Jubilee",
        "timestamp": 1643777952
    },
    {
        "content": "<p>A fun fact about the SimpleV one: on item <code>i</code>, you call <code>f</code> exactly <code>i.trailing_ones()</code> times (except at the end when you need to collapse the remaining intermediaries).</p>",
        "id": 270337025,
        "sender_full_name": "scottmcm",
        "timestamp": 1643780114
    },
    {
        "content": "<p>well, llvm isn't better on non-full-length vectors: <a href=\"https://rust.godbolt.org/z/fxYE3Yvzb\">https://rust.godbolt.org/z/fxYE3Yvzb</a></p>",
        "id": 270338993,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643781705
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"229517\">Jacob Lifshay</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/pairwise.20ops.20would.20be.20nice/near/270338993\">said</a>:</p>\n<blockquote>\n<p>well, llvm isn't better on non-full-length vectors: <a href=\"https://rust.godbolt.org/z/fxYE3Yvzb\">https://rust.godbolt.org/z/fxYE3Yvzb</a></p>\n</blockquote>\n<p>Ah, but that  is a much better optimization of the SimpleV pattern it seems.</p>",
        "id": 270339718,
        "sender_full_name": "Jubilee",
        "timestamp": 1643782432
    },
    {
        "content": "<p>unless I am misreading?</p>",
        "id": 270339776,
        "sender_full_name": "Jubilee",
        "timestamp": 1643782480
    },
    {
        "content": "<p>iirc it was shorter with full vectors on x86 and maybe arm</p>",
        "id": 270340564,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643783234
    },
    {
        "content": "<p>shortening vector version of reduce with vector length 13 (and a few others): <a href=\"https://rust.godbolt.org/z/c51de7Gcq\">https://rust.godbolt.org/z/c51de7Gcq</a></p>",
        "id": 270340584,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643783278
    },
    {
        "content": "<p>when you reach for intrinsics cuz portable-simd doesn't let you do what you want :P</p>",
        "id": 270340669,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643783378
    },
    {
        "content": "<p>It'd be nice if <code>.reduce.fadd</code> accepted a \"tree\" argument where \"reassoc\" goes.</p>",
        "id": 270342920,
        "sender_full_name": "Jubilee",
        "timestamp": 1643785656
    },
    {
        "content": "<p>Just catching up, is the rationale for pairwise to have an algorithm for which bitwise results do not depend on optimization level or architecture? Because using several accumulators (native register length or small multiple) is faster and more accurate than sequential summation (and you get it automatically with <code>reassoc</code>). And working in blocks, you can be equivalent to pairwise summation modulo a permutation of the array entries.</p>",
        "id": 271018346,
        "sender_full_name": "Jed",
        "timestamp": 1644257101
    },
    {
        "content": "<p>It's one of the considerations. Right now we use pretty much the worst case scenario (sequential).  I'm not sure we're necessarily leaning in any direction regarding if it needs to be identical on every architecture</p>",
        "id": 271018728,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1644257249
    },
    {
        "content": "<p>My understanding is that accumulators also are more pessimistic in performance on small reductions, as opposed to what is sometimes a built-in hardware operation. Am I wrong?</p>",
        "id": 271018919,
        "sender_full_name": "Jubilee",
        "timestamp": 1644257307
    },
    {
        "content": "<p>Like if you have length 7, would it be optimized with <code>vhaddpd</code>? IIRC, the optimizer does a fine job with that if you allow <code>reassoc</code>. If you don't, then it'll depend on whether the associativity you choose maps to hardware.</p>",
        "id": 271019607,
        "sender_full_name": "Jed",
        "timestamp": 1644257584
    },
    {
        "content": "<p>Ah, yes, our problem is we don't fully trust the LLVM optimizer. :^)</p>",
        "id": 271019692,
        "sender_full_name": "Jubilee",
        "timestamp": 1644257633
    },
    {
        "content": "<p>Note that vhaddpd is latency 6/2 cycles-per-instruction on Icelake, while <code>vaddpd</code> is latency 4, 0.5 CPI.</p>",
        "id": 271019761,
        "sender_full_name": "Jed",
        "timestamp": 1644257651
    },
    {
        "content": "<p><em>nods</em></p>",
        "id": 271019798,
        "sender_full_name": "Jubilee",
        "timestamp": 1644257665
    },
    {
        "content": "<p>Yeah there might be more instructions but if LLVM is smart enough to remove data dependencies it can get more instructions per cycle</p>",
        "id": 271019936,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1644257734
    },
    {
        "content": "<p>Heh, that's fair. My experience has been that <code>#pragma omd simd reduce(+:sum)</code> or otherwise enabling <code>reassoc</code> (with C or Rust) gives good code on all architectures I've tested. It's more accurate than sequential summation, and good enough for my applications. It's not bitwise stable between platforms/optimization levels.</p>",
        "id": 271020131,
        "sender_full_name": "Jed",
        "timestamp": 1644257829
    },
    {
        "content": "<p>Jubilee mentioned that IEEE specifies order to not matter so I'm personally leaning towards <code>reassoc</code> now</p>",
        "id": 271020279,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1644257887
    },
    {
        "content": "<p>If we do, we should remove the <code>horizontal</code> specifier, IMO.</p>",
        "id": 271020341,
        "sender_full_name": "Jubilee",
        "timestamp": 1644257929
    },
    {
        "content": "<p>For yes just sum and product.</p>",
        "id": 271020400,
        "sender_full_name": "Jubilee",
        "timestamp": 1644257957
    },
    {
        "content": "<p>That's an option, though potentially inconsistent with other names</p>",
        "id": 271020434,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1644257979
    },
    {
        "content": "<p>I have heard a concern that <code>reassoc</code> may allow other reassociations as well, not just in that intrinsic.</p>",
        "id": 271021210,
        "sender_full_name": "Jubilee",
        "timestamp": 1644258329
    },
    {
        "content": "<p>If all it does is change input order I think that's allowable</p>",
        "id": 271021505,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1644258458
    },
    {
        "content": "<p>I think things with reassoc can be reassociated with other things with reassoc, rather than strictly allowing it to reassociate the operations within the single instruction. If it goes across expressions, I think it could in principal break stuff like kahan sum-likes, dekker's multiplication, etc (admittedly it's not 100% clear how you would build these out of <code>horizontal_sum</code>s)</p>\n<p>it is possible that I am misreading <a href=\"https://llvm.org/docs/LangRef.html\">https://llvm.org/docs/LangRef.html</a> though.</p>",
        "id": 271024998,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1644259978
    },
    {
        "content": "<p>Yeah, I am wary of bugs in LLVM at the very least around this that accidentally \"promote\" reassoc across everything in the context when running some specific opt pass.</p>\n<p>I am still somewhat in favor of the tree reduction because it does have a specific semantics, and while it's true \"whether or not it optimizes depends on whether the associativity maps to hardware\", it appears to be relatively trivial to design one that does.</p>",
        "id": 271027126,
        "sender_full_name": "Jubilee",
        "timestamp": 1644260791
    },
    {
        "content": "<p>At least, trivial compared to some of the other hills we have had to walk up both ways.</p>",
        "id": 271027205,
        "sender_full_name": "Jubilee",
        "timestamp": 1644260838
    },
    {
        "content": "<p>Ahhhh I just realized what uses <code>horizontal_sum</code> all day.<br>\nMatrix multiplication.</p>",
        "id": 271073695,
        "sender_full_name": "Jubilee",
        "timestamp": 1644288065
    },
    {
        "content": "<p>typically you would permute the values in such a way that you don't do any horizontal reductions</p>",
        "id": 271074037,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1644288378
    },
    {
        "content": "<p>Typically!</p>",
        "id": 271074736,
        "sender_full_name": "Jubilee",
        "timestamp": 1644289078
    },
    {
        "content": "<p>Yeah, for matrix-matrix multiplication, you're normally doing outer products with several packed registers of accumulators. <a href=\"/user_uploads/4715/PhSiub87k1u59WvigWiNqYAz/image.png\">image.png</a> <br>\n<a href=\"https://www.cs.utexas.edu/users/flame/pubs/TOMS-BLIS-Analytical.pdf\">https://www.cs.utexas.edu/users/flame/pubs/TOMS-BLIS-Analytical.pdf</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/4715/PhSiub87k1u59WvigWiNqYAz/image.png\" title=\"image.png\"><img src=\"/user_uploads/4715/PhSiub87k1u59WvigWiNqYAz/image.png\"></a></div>",
        "id": 271082516,
        "sender_full_name": "Jed",
        "timestamp": 1644297606
    },
    {
        "content": "<p><a href=\"/user_uploads/4715/dpGf3v5ZZVO5yps1ufdJ0Dxq/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/4715/dpGf3v5ZZVO5yps1ufdJ0Dxq/image.png\" title=\"image.png\"><img src=\"/user_uploads/4715/dpGf3v5ZZVO5yps1ufdJ0Dxq/image.png\"></a></div>",
        "id": 271082558,
        "sender_full_name": "Jed",
        "timestamp": 1644297671
    },
    {
        "content": "<p>hmm, what sizes of matrices are those?</p>",
        "id": 271083825,
        "sender_full_name": "Jubilee",
        "timestamp": 1644299026
    },
    {
        "content": "<p>from the way it worries about the cache hierarchy, i'd assume hundreds or more of rows and columns</p>",
        "id": 271083910,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1644299113
    },
    {
        "content": "<p>mmm, even if you maxed out the theoretical len for SVE2 it caps at f32x64</p>",
        "id": 271084370,
        "sender_full_name": "Jubilee",
        "timestamp": 1644299529
    },
    {
        "content": "<p>I am thinking more \"so small that we're hitting diminishing returns on chopping things up into submatrices.\"</p>",
        "id": 271084412,
        "sender_full_name": "Jubilee",
        "timestamp": 1644299606
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"322310\">Jed</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/pairwise.20ops.20would.20be.20nice/near/271020131\">said</a>:</p>\n<blockquote>\n<p>Heh, that's fair. My experience has been that <code>#pragma omd simd reduce(+:sum)</code> or otherwise enabling <code>reassoc</code> (with C or Rust) gives good code on all architectures I've tested. It's more accurate than sequential summation, and good enough for my applications. It's not bitwise stable between platforms/optimization levels.</p>\n</blockquote>\n<p>so here's a question: what lengths are you talking about here?</p>",
        "id": 271084497,
        "sender_full_name": "Jubilee",
        "timestamp": 1644299688
    },
    {
        "content": "<p>Well that makes me think of something, an obvious benefit to using <code>reassoc</code> instead of specifying an order is if your vector is say 4x the native width it can simply do 4 adds and then only 1 shuffling reduction</p>",
        "id": 271085022,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1644300197
    },
    {
        "content": "<p>well, it can do that anyway with the reduction tree I proposed, because the part of the tree that operates on offsets &gt;= native vector size turns into native vector size adds anyway</p>",
        "id": 271085467,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1644300688
    },
    {
        "content": "<p>example with a bunch of <code>vaddps</code> before the shuffles: <a href=\"https://rust.godbolt.org/z/zavn8x3xe\">https://rust.godbolt.org/z/zavn8x3xe</a></p>",
        "id": 271086106,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1644301340
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"GAS\"><pre><span></span><code><span class=\"nl\">example:</span><span class=\"err\">:</span><span class=\"nl\">tree_reduce_16:</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nf\">vmovaps</span><span class=\"w\"> </span><span class=\"no\">ymm0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"no\">ymmword</span><span class=\"w\"> </span><span class=\"no\">ptr</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"no\">rdi</span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nf\">vaddps</span><span class=\"w\">  </span><span class=\"no\">ymm0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"no\">ymm0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"no\">ymmword</span><span class=\"w\"> </span><span class=\"no\">ptr</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"no\">rdi</span><span class=\"w\"> </span><span class=\"err\">+</span><span class=\"w\"> </span><span class=\"mi\">32</span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nf\">vextractf128</span><span class=\"w\">    </span><span class=\"no\">xmm1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"no\">ymm0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nf\">vaddps</span><span class=\"w\">  </span><span class=\"no\">xmm0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"no\">xmm0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"no\">xmm1</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nf\">vpermilpd</span><span class=\"w\">       </span><span class=\"no\">xmm1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"no\">xmm0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nf\">vaddps</span><span class=\"w\">  </span><span class=\"no\">xmm0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"no\">xmm0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"no\">xmm1</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nf\">vmovshdup</span><span class=\"w\">       </span><span class=\"no\">xmm1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"no\">xmm0</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nf\">vaddss</span><span class=\"w\">  </span><span class=\"no\">xmm0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"no\">xmm0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"no\">xmm1</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nf\">vzeroupper</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nf\">ret</span><span class=\"w\"></span>\n\n<span class=\"nl\">unordered:</span><span class=\"w\">                              </span><span class=\"c1\"># @unordered</span>\n<span class=\"w\">        </span><span class=\"nf\">vextractf64x4</span><span class=\"w\">   </span><span class=\"no\">ymm1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"no\">zmm0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nf\">vaddps</span><span class=\"w\">  </span><span class=\"no\">zmm0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"no\">zmm0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"no\">zmm1</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nf\">vextractf128</span><span class=\"w\">    </span><span class=\"no\">xmm1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"no\">ymm0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nf\">vaddps</span><span class=\"w\">  </span><span class=\"no\">xmm0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"no\">xmm0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"no\">xmm1</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nf\">vpermilpd</span><span class=\"w\">       </span><span class=\"no\">xmm1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"no\">xmm0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\">           </span><span class=\"c1\"># xmm1 = xmm0[1,0]</span>\n<span class=\"w\">        </span><span class=\"nf\">vaddps</span><span class=\"w\">  </span><span class=\"no\">xmm0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"no\">xmm0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"no\">xmm1</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nf\">vmovshdup</span><span class=\"w\">       </span><span class=\"no\">xmm1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"no\">xmm0</span><span class=\"w\">              </span><span class=\"c1\"># xmm1 = xmm0[1,1,3,3]</span>\n<span class=\"w\">        </span><span class=\"nf\">vaddss</span><span class=\"w\">  </span><span class=\"no\">xmm0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"no\">xmm0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"no\">xmm1</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nf\">vzeroupper</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nf\">ret</span><span class=\"w\"></span>\n</code></pre></div>\n<p>...lol the tree reduction is almost <strong>exactly</strong> the same as the unordered version.</p>",
        "id": 271091149,
        "sender_full_name": "Jubilee",
        "timestamp": 1644306383
    },
    {
        "content": "<p>now that I look at it.</p>",
        "id": 271091157,
        "sender_full_name": "Jubilee",
        "timestamp": 1644306390
    },
    {
        "content": "<p>This reminds me of the \"implement pow by looking at the binary and squaring and multiplying\" trick -- which IIRC is usually optimal, but not quite <em>always</em> optimal.</p>\n<p>So maybe the <code>assoc</code> version just optimizes to the tree version usually, for the same reason.</p>",
        "id": 271093262,
        "sender_full_name": "scottmcm",
        "timestamp": 1644308016
    },
    {
        "content": "<p>mhm</p>",
        "id": 271094782,
        "sender_full_name": "Jubilee",
        "timestamp": 1644309063
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span> lkcl asked me to ping you about this zulip topic, he has some comments: <a href=\"https://libre-soc.org/irclog/%23libre-soc.2022-03-23.log.html#t2022-03-23T12:01:04\">https://libre-soc.org/irclog/%23libre-soc.2022-03-23.log.html#t2022-03-23T12:01:04</a></p>",
        "id": 276347793,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1648048237
    },
    {
        "content": "<p>huh.</p>",
        "id": 276366035,
        "sender_full_name": "Jubilee",
        "timestamp": 1648054628
    },
    {
        "content": "<p>I am not sure what my takeaway should be.</p>",
        "id": 276397675,
        "sender_full_name": "Jubilee",
        "timestamp": 1648068334
    },
    {
        "content": "<p>idk, it was mostly that he felt I had forgotten all about this topic but he wanted to continue the conversation...</p>",
        "id": 276397875,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1648068437
    },
    {
        "content": "<p>Looking back at this I feel like we should just use reassoc and let LLVM do whatever it feels like is optimal (and if it's not, fix that)</p>",
        "id": 276398066,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1648068521
    },
    {
        "content": "<p>imho we <em>need</em> something with reproducible results as an option, not just having the only option be llvm getting permission to mess up all the math however it likes</p>",
        "id": 276398367,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1648068666
    },
    {
        "content": "<p>otherwise inlining the same function in different places might cause llvm to have that function compute differing values</p>",
        "id": 276398648,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1648068780
    },
    {
        "content": "<p>I base that on the ieee spec (I think jubilee brought it up) which specifies order doesn't matter</p>",
        "id": 276398822,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1648068847
    },
    {
        "content": "<p>I think if we care about order for any reason then we should go so far as to order it sequentially as well</p>",
        "id": 276398862,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1648068866
    },
    {
        "content": "<p>(and provide both)</p>",
        "id": 276398893,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1648068883
    },
    {
        "content": "<p>If someone needs a particular consistent order that isn't sequential for whatever reason they can still write it with swizzle</p>",
        "id": 276398971,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1648068923
    },
    {
        "content": "<p>imho sequential is terrible...consistent results yes, but lets have consistent tree reduce as an option so we get consistent fast results</p>",
        "id": 276399033,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1648068951
    },
    {
        "content": "<p>My point is that there are potentially applications that care very strongly about the order, in which sequential matters. I'm having trouble thinking of an application that cares strongly about identical ordering on different architectures but doesn't care what that particular order is</p>",
        "id": 276399307,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1648069077
    },
    {
        "content": "<p>And if that application exists somewhere, they can implement their own very specific reduction</p>",
        "id": 276399436,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1648069123
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/pairwise.20ops.20would.20be.20nice/near/276399307\">said</a>:</p>\n<blockquote>\n<p>I'm having trouble thinking of an application that cares strongly about identical ordering on different architectures but doesn't care what that particular order is</p>\n</blockquote>\n<p>Anything that needs reproducibility but doesn't really care about error, like an RTS game engine, probably falls under that.</p>",
        "id": 276410326,
        "sender_full_name": "scottmcm",
        "timestamp": 1648074630
    },
    {
        "content": "<p>My concern is that it's based on a hypothetical application, in C++ it's been common to add something to the standard library only to deprecate it or make another variant of it because no real work application could actually make use of it due to incorrect assumptions</p>",
        "id": 276411203,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1648075178
    },
    {
        "content": "<p>In this case, I think reassoc has the least assumptions while being usable for most actual applications, and the remaining applications can build their own implementations with swizzle, and if one wins out it's a candidate to add to std</p>",
        "id": 276411551,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1648075309
    },
    {
        "content": "<p>but if we add a specific tree-reduce, then cpus such as libre-soc's can design their reduce to match, rather than leaving it up to every game programmer ever to come up with their own random reduction</p>",
        "id": 276412746,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1648076055
    },
    {
        "content": "<p>I think we should talk to LLVM about this.</p>",
        "id": 276412795,
        "sender_full_name": "Jubilee",
        "timestamp": 1648076094
    },
    {
        "content": "<p>That would be nice, but I definitely don't have any delusions of grandeur that Intel is going to build the rust SIMD instruction set</p>",
        "id": 276412836,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1648076123
    },
    {
        "content": "<p>Yeah, I'd be curious if anyone from LLVM has any opinion</p>",
        "id": 276412867,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1648076157
    },
    {
        "content": "<p>if a particular tree-reduction is popular enough, intel may add it</p>",
        "id": 276412920,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1648076170
    },
    {
        "content": "<p>since they care about retaining gamers on their platform</p>",
        "id": 276412974,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1648076220
    },
    {
        "content": "<p>So I think that's <strong>slightly</strong>... bluesky, but to be precise, I agree with Jacob that we should absolutely keep in mind programming languages can affect hardware.</p>",
        "id": 276413124,
        "sender_full_name": "Jubilee",
        "timestamp": 1648076321
    },
    {
        "content": "<p>I think IEEE not even committing to one is a good indication of who determines these things</p>",
        "id": 276413227,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1648076390
    },
    {
        "content": "<p>yeaaah.</p>",
        "id": 276413282,
        "sender_full_name": "Jubilee",
        "timestamp": 1648076405
    },
    {
        "content": "<p>i think ieee cares about fast but not reproducible there...</p>",
        "id": 276413310,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1648076419
    },
    {
        "content": "<p>Anyways, so, I think that basically, afaict<br>\n\"reassoc\" is very close to \"ordered tree reduce\" on smaller vectors</p>",
        "id": 276413414,
        "sender_full_name": "Jubilee",
        "timestamp": 1648076460
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"132920\">@gnzlbg</span> was counting on it being so, in fact, I think?</p>",
        "id": 276413493,
        "sender_full_name": "Jubilee",
        "timestamp": 1648076494
    },
    {
        "content": "<p>because until recently, x86-32 was popular enough that all your fp would give different results on different platforms so programmers assumed fp was non-reproducable in general</p>",
        "id": 276413525,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1648076521
    },
    {
        "content": "<p>so it would be reasonable IMO to say, \"hey, LLVM, can you canonize your existing behavior with a new tag?\" and if they say yes, then basically everyone gets what they want.</p>",
        "id": 276413634,
        "sender_full_name": "Jubilee",
        "timestamp": 1648076574
    },
    {
        "content": "<p>I think that I agree somewhat with \"we should be conservative about promises\" though.</p>",
        "id": 276413683,
        "sender_full_name": "Jubilee",
        "timestamp": 1648076605
    },
    {
        "content": "<p>except llvm's behavior is different on different architectures</p>",
        "id": 276413684,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1648076607
    },
    {
        "content": "<p>hmm.</p>",
        "id": 276413702,
        "sender_full_name": "Jubilee",
        "timestamp": 1648076613
    },
    {
        "content": "<p>Well, no, I'm still arguing I don't think we should commit to a particular ordering in std, until enough compelling real world uses come up</p>",
        "id": 276413705,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1648076614
    },
    {
        "content": "<p>right.</p>",
        "id": 276413726,
        "sender_full_name": "Jubilee",
        "timestamp": 1648076628
    },
    {
        "content": "<p>I think we can be somewhat ambivalent towards ordering promises while still pursuing a stable one.</p>",
        "id": 276413797,
        "sender_full_name": "Jubilee",
        "timestamp": 1648076654
    },
    {
        "content": "<p>just a TODO: \"make this a portable fast ordering? is that even possible?\" thing.</p>",
        "id": 276413814,
        "sender_full_name": "Jubilee",
        "timestamp": 1648076669
    },
    {
        "content": "<p>The problem is all it takes is a single cpu to come out with an incompatible reduction and it's now pessimistic on that architecture</p>",
        "id": 276413873,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1648076712
    },
    {
        "content": "<p>eh.</p>",
        "id": 276413883,
        "sender_full_name": "Jubilee",
        "timestamp": 1648076718
    },
    {
        "content": "<p>well...the earlier we decide, the more likely libre-soc won't pick something that doesn't match cuz we ran out of time and had to pick</p>",
        "id": 276413912,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1648076735
    },
    {
        "content": "<p>in practice these things tend to converge.</p>",
        "id": 276413921,
        "sender_full_name": "Jubilee",
        "timestamp": 1648076739
    },
    {
        "content": "<p>As much as I'm sympathetic to that, I'm not about to commit to an ordering strictly that libre soc picks the matching one, because we absolutely would retain the right to change that ordering at any point until the function is stable</p>",
        "id": 276414077,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1648076821
    },
    {
        "content": "<p>maybe pick the arm sve2 order (much as i dislike it -- it's pretty terrible) since it's already out and specified?</p>",
        "id": 276414146,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1648076855
    },
    {
        "content": "<p>I think that alone shows that it would be very easy for someone to come up with an ordering that doesn't match ours</p>",
        "id": 276414154,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1648076861
    },
    {
        "content": "<p>If libresoc could do it, someone who isn't concerned at all with the rust project easily could</p>",
        "id": 276414217,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1648076885
    },
    {
        "content": "<p>iirc risc-v doesn't specify</p>",
        "id": 276414229,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1648076894
    },
    {
        "content": "<p>I thought they specified linear.</p>",
        "id": 276414252,
        "sender_full_name": "Jubilee",
        "timestamp": 1648076907
    },
    {
        "content": "<p>that's for the ordered one, which we all agree is slow and terrible...hence the need for tree-reduce</p>",
        "id": 276414307,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1648076947
    },
    {
        "content": "<p>iirc riscv has 2 different reduce instructions, ordered and unordered</p>",
        "id": 276414323,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1648076961
    },
    {
        "content": "<p>Fwiw I have worked on software that requires sequential reductions, never personally on anything that requires a particular tree reduction</p>",
        "id": 276414355,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1648076993
    },
    {
        "content": "<p>i've written a physics engine...and i'm planning on writing a 100% reproducible physics engine</p>",
        "id": 276414500,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1648077080
    },
    {
        "content": "<p>those (assuming they are explicitly simd-ified and optimized) would want tree-reductions since serial reductions are soo slow</p>",
        "id": 276414606,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1648077148
    },
    {
        "content": "<p>Note I'm not suggesting sequential needs to be in std either, my point is that different software will have different requirements</p>",
        "id": 276414639,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1648077183
    },
    {
        "content": "<p>reproducible is needed for consistency across networked computers</p>",
        "id": 276414653,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1648077193
    },
    {
        "content": "<p>i agree different sw has different requirements, hence why i'm saying we should provide 3 reduce algorithms: serial, fast, and fast-enough-but-reproducible (specific tree reduce)</p>",
        "id": 276414795,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1648077291
    },
    {
        "content": "<p><code>reduce_ordered_*</code>, <code>reduce_*</code>, and <code>reduce_tree_*</code></p>",
        "id": 276414946,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1648077381
    },
    {
        "content": "<p>that is a lot of methods.</p>",
        "id": 276415039,
        "sender_full_name": "Jubilee",
        "timestamp": 1648077474
    },
    {
        "content": "<p>Yeah. If 90%+ of users are happy with just the unordered one, it's probably a net negative on the API to include the rest</p>",
        "id": 276415213,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1648077590
    },
    {
        "content": "<p>associative ops such as xor would only need 1 since all such reduce algorithms always give the same result</p>",
        "id": 276415245,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1648077602
    },
    {
        "content": "<p>And if something is repeatedly requested, of course it can be added</p>",
        "id": 276415295,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1648077615
    },
    {
        "content": "<p>imho the tree reduction is probably \"you didn't know you needed it till you saw it\" kind of thing</p>",
        "id": 276415368,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1648077685
    },
    {
        "content": "<p>instead doing reduction with scalar ops or something</p>",
        "id": 276415403,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1648077715
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/pairwise.20ops.20would.20be.20nice/near/276410326\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/pairwise.20ops.20would.20be.20nice/near/276399307\">said</a>:</p>\n<blockquote>\n<p>I'm having trouble thinking of an application that cares strongly about identical ordering on different architectures but doesn't care what that particular order is</p>\n</blockquote>\n<p>Anything that needs reproducibility but doesn't really care about error, like an RTS game engine, probably falls under that.</p>\n</blockquote>\n<p>also in practice game engines do care about reproducibility.</p>",
        "id": 276415538,
        "sender_full_name": "Jubilee",
        "timestamp": 1648077779
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/pairwise.20ops.20would.20be.20nice/near/276415538\">said</a>:</p>\n<blockquote>\n<p>also in practice game engines do care about reproducibility.</p>\n</blockquote>\n<p>Uh, yes?  That's what I intended to say.</p>\n<p>(They don't care about Â½ULP <em>accuracy</em>, just about <em>consistency</em>.)</p>",
        "id": 276415679,
        "sender_full_name": "scottmcm",
        "timestamp": 1648077861
    },
    {
        "content": "<p>ah.</p>",
        "id": 276415898,
        "sender_full_name": "Jubilee",
        "timestamp": 1648078031
    },
    {
        "content": "<p>whoops.</p>",
        "id": 276415908,
        "sender_full_name": "Jubilee",
        "timestamp": 1648078042
    }
]