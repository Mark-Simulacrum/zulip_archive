[
    {
        "content": "<p>Hi, given a slice <code>[i32; 8] = [0, 1, 2, 3, 4, 5, 6, 7]</code>, a mask <code>m8</code> <code>00000101u8</code> and a region <code>&amp;mut [i32]</code> with the correct number of entries (2 in this case), is there an API to write \"[0, 2]\" to it without iterating bit by bit? I.e. selecting the item at index <code>0</code> and <code>2</code> (because the bitmap is set for those).</p>",
        "id": 270888470,
        "sender_full_name": "Jorge Leitao",
        "timestamp": 1644151968
    },
    {
        "content": "<p>Is the mask constant, or that's just an example but unknown at runtime</p>",
        "id": 270893254,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1644158393
    },
    {
        "content": "<p>it is just an example. The general case is <code>values: &amp;[i32]</code> and <code>mask: &amp;[u8]</code> where <code>values.len() == mask.len() / 8</code> and we iterate over chunks of \"lanes\".</p>",
        "id": 270893682,
        "sender_full_name": "Jorge Leitao",
        "timestamp": 1644159033
    },
    {
        "content": "<p>I think the instruction is this one: <a href=\"https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_pext_u64&amp;ig_expand=5394\">https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_pext_u64&amp;ig_expand=5394</a></p>",
        "id": 270893686,
        "sender_full_name": "Jorge Leitao",
        "timestamp": 1644159044
    },
    {
        "content": "<p>If you're specifically trying to load the bits that way you'd need to use <code>from_bitmask</code> (not on nightly for arrays, yet) and then pass that mask to <code>scatter</code> to choose which lanes you want to write out.</p>",
        "id": 270893766,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1644159154
    },
    {
        "content": "<p>Neither of those functions are necessarily fast on most architectures, though, so I'm not sure this is something that can or should be vectorized</p>",
        "id": 270893795,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1644159219
    },
    {
        "content": "<p>As far as I can tell, that particular instruction you linked transfers bits between values and doesn't help with selecting a wider type such as i32 in this case. Also I definitely don't think there's a portable way to implement that instruction except maybe with a string of bitwise operations</p>",
        "id": 270893938,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1644159432
    },
    {
        "content": "<p>iirc, llvm has a special intrinsic for what you wanted: <a href=\"https://llvm.org/docs/LangRef.html#llvm-masked-compressstore-intrinsics\">https://llvm.org/docs/LangRef.html#llvm-masked-compressstore-intrinsics</a></p>",
        "id": 270896466,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1644162949
    },
    {
        "content": "<p>we don't expose it yet though</p>",
        "id": 270896504,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1644162963
    },
    {
        "content": "<p>there's also the reverse operation: <a href=\"https://llvm.org/docs/LangRef.html#llvm-masked-expandload-intrinsics\">https://llvm.org/docs/LangRef.html#llvm-masked-expandload-intrinsics</a></p>",
        "id": 270896522,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1644163018
    },
    {
        "content": "<p>x86 supports it with avx512f: <a href=\"https://llvm.godbolt.org/z/zanqn8xd4\">https://llvm.godbolt.org/z/zanqn8xd4</a></p>",
        "id": 270897359,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1644164013
    },
    {
        "content": "<p>Libre-SOC's SimpleV and RISC-V V also supports compress store and expand load, but by compressing/expanding in a register then loading/storing the compacted register</p>",
        "id": 270898271,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1644165298
    },
    {
        "content": "<p>icr for sure, but i think SimpleV may also support compress store and expanding load without going through a register</p>",
        "id": 270898353,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1644165399
    },
    {
        "content": "<p>ARM SVE also has compressing in a register</p>",
        "id": 270898421,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1644165487
    },
    {
        "content": "<p>tho afaict x86 is the only one wired up in llvm currently</p>",
        "id": 270898432,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1644165526
    },
    {
        "content": "<p>correct, I linked a wrong instruction for this. Yes, that is the one, <span class=\"user-mention\" data-user-id=\"229517\">@Jacob Lifshay</span>! Is it something that could make sense for portable-simd to support?</p>",
        "id": 270899545,
        "sender_full_name": "Jorge Leitao",
        "timestamp": 1644166922
    }
]