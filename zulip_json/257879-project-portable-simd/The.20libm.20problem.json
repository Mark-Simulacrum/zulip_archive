[
    {
        "content": "<p>oh no</p>\n<div class=\"codehilite\" data-code-language=\"GAS\"><pre><span></span><code>        <span class=\"nf\">movq</span>    <span class=\"no\">fmaf@GOTPCREL</span><span class=\"p\">(</span><span class=\"nv\">%rip</span><span class=\"p\">),</span> <span class=\"nv\">%rbx</span>\n        <span class=\"nf\">callq</span>   <span class=\"p\">*</span><span class=\"nv\">%rbx</span>\n</code></pre></div>\n<p>even <code>simd_fma</code> calls to libm</p>",
        "id": 226608971,
        "sender_full_name": "Jubilee",
        "timestamp": 1613532176
    },
    {
        "content": "<p>Thats... Odd</p>",
        "id": 226608988,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613532208
    },
    {
        "content": "<p>Maybe it's because of the rounding issue?</p>",
        "id": 226608997,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613532235
    },
    {
        "content": "<p><a href=\"https://rust.godbolt.org/z/hxxadY\">https://rust.godbolt.org/z/hxxadY</a></p>",
        "id": 226609069,
        "sender_full_name": "Jubilee",
        "timestamp": 1613532301
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"GAS\"><pre><span></span><code>        <span class=\"nf\">movq</span>    <span class=\"no\">ceilf@GOTPCREL</span><span class=\"p\">(</span><span class=\"nv\">%rip</span><span class=\"p\">),</span> <span class=\"nv\">%rbx</span>\n        <span class=\"nf\">callq</span>   <span class=\"p\">*</span><span class=\"nv\">%rbx</span>\n</code></pre></div>\n<p>oh nooooooo</p>",
        "id": 226609092,
        "sender_full_name": "Jubilee",
        "timestamp": 1613532358
    },
    {
        "content": "<p>hmm</p>",
        "id": 226609280,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613532603
    },
    {
        "content": "<p>how are they handled for <code>f32</code>?</p>",
        "id": 226609326,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613532626
    },
    {
        "content": "<p><a href=\"https://doc.rust-lang.org/core/intrinsics/fn.ceilf32.html\">https://doc.rust-lang.org/core/intrinsics/fn.ceilf32.html</a></p>",
        "id": 226609368,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613532712
    },
    {
        "content": "<p>whatever this lowers to</p>",
        "id": 226609372,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613532716
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/blob/bb587b1a1737738658d2eaecd4c8c1cab555257a/compiler/rustc_codegen_llvm/src/intrinsic.rs#L61\">https://github.com/rust-lang/rust/blob/bb587b1a1737738658d2eaecd4c8c1cab555257a/compiler/rustc_codegen_llvm/src/intrinsic.rs#L61</a></p>",
        "id": 226609477,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613532802
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/The.20libm.20problem/near/226608971\">said</a>:</p>\n<blockquote>\n<p>oh no</p>\n<div class=\"codehilite\" data-code-language=\"GAS\"><pre><span></span><code>        <span class=\"nf\">movq</span>    <span class=\"no\">fmaf@GOTPCREL</span><span class=\"p\">(</span><span class=\"nv\">%rip</span><span class=\"p\">),</span> <span class=\"nv\">%rbx</span>\n        <span class=\"nf\">callq</span>   <span class=\"p\">*</span><span class=\"nv\">%rbx</span>\n</code></pre></div>\n<p>even <code>simd_fma</code> calls to libm</p>\n</blockquote>\n<p>that's because you forgot to enable the fma instruction set:<br>\n<a href=\"https://rust.godbolt.org/z/r4j5Gv\">https://rust.godbolt.org/z/r4j5Gv</a></p>",
        "id": 226609480,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1613532814
    },
    {
        "content": "<p>it just lowers to llvm's <code>ceil</code> instruction</p>",
        "id": 226609484,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613532820
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"229517\">@Jacob Lifshay</span> the problem isn't that it called libm instead of an instruction, specifically, the problem is that it called libm which isn't available in core</p>",
        "id": 226609531,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613532847
    },
    {
        "content": "<p>rather than llvm generating an inline codelet</p>",
        "id": 226609547,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613532881
    },
    {
        "content": "<p>i'm curious why this is ok for <code>f32::ceil</code></p>",
        "id": 226609566,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613532909
    },
    {
        "content": "<p>well, you'll just have to leave fma out of core then -- fma requires library support on x86 without the fma instruction set</p>",
        "id": 226609571,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1613532928
    },
    {
        "content": "<p>My understanding is that floats are in fact split this way.</p>",
        "id": 226609579,
        "sender_full_name": "Jubilee",
        "timestamp": 1613532955
    },
    {
        "content": "<p>inside the compiler.</p>",
        "id": 226609582,
        "sender_full_name": "Jubilee",
        "timestamp": 1613532961
    },
    {
        "content": "<p>oh there's an intrinsics crate, isn't there</p>",
        "id": 226609637,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613533014
    },
    {
        "content": "<p>it's llvm that's generating the fma function calls, rustc is passing the vector instructions like it should</p>",
        "id": 226609643,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1613533031
    },
    {
        "content": "<p>compiler builtins or something</p>",
        "id": 226609644,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613533035
    },
    {
        "content": "<p>and yeah, the problem is that it's like</p>",
        "id": 226609653,
        "sender_full_name": "Jubilee",
        "timestamp": 1613533052
    },
    {
        "content": "<p>it complicates our life since now we have to split stuff between core and std lol</p>",
        "id": 226609661,
        "sender_full_name": "Jubilee",
        "timestamp": 1613533067
    },
    {
        "content": "<p>we should be able to do <code>SimdF32::ceil</code> identically to <code>f32::ceil</code></p>",
        "id": 226609662,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613533068
    },
    {
        "content": "<p>it seems pretty bad for these vector operations to lower to 4 function calls</p>",
        "id": 226609736,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1613533166
    },
    {
        "content": "<p>I think the idea behind the trig stuff also was that we'd provide a decent software vectorized impl. that should be possible for most of these too</p>",
        "id": 226609794,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1613533213
    },
    {
        "content": "<p>the logic of calling into libm since it can do better than we can doesn't necessarily apply if we can do it vectorized rather than multiple scalar ops</p>",
        "id": 226609839,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1613533275
    },
    {
        "content": "<p>well, if you wanted it to generate a mul+add or fma whichever's faster, there's a separate llvm operation for that. if you ask for fma and only fma, it has to use the only fma function available -- libm's</p>",
        "id": 226609850,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1613533296
    },
    {
        "content": "<p>also it shouldn't matter actually that I'm not flagging for vector features.<br>\ngodbolt is on an x64 machine, isn't it?</p>",
        "id": 226609858,
        "sender_full_name": "Jubilee",
        "timestamp": 1613533309
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"229517\">Jacob Lifshay</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/The.20libm.20problem/near/226609850\">said</a>:</p>\n<blockquote>\n<p>well, if you wanted it to generate a mul+add or fma whichever's faster</p>\n</blockquote>\n<p>i definitely didn't say that</p>",
        "id": 226609910,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1613533339
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/The.20libm.20problem/near/226609858\">said</a>:</p>\n<blockquote>\n<p>godbolt is on an x64 machine, isn't it?</p>\n</blockquote>\n<p>yup, though you can easily use <code>--target=...</code> to change it</p>",
        "id": 226609991,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1613533456
    },
    {
        "content": "<p>IMHO when rustc is asked to target x86_64-unknown-linux-gnu, it should be able to assume that libm is available, even when using no_std, after all, that's what the gnu part means -- use glibc</p>",
        "id": 226610211,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1613533737
    },
    {
        "content": "<p>unfortunately, there aren't any x86_64 rustc targets without a libm that I'm aware of, otherwise we could test and ensure that fma isn't called in those situations, it might have to abort compilation, but it shouldn't use a function llvm was told isn't available</p>",
        "id": 226610438,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1613533951
    },
    {
        "content": "<p>-elf</p>",
        "id": 226610488,
        "sender_full_name": "Jubilee",
        "timestamp": 1613534019
    },
    {
        "content": "<p>well, at least fabs and fsqrt compile to vector instructions always... on x64</p>",
        "id": 226610556,
        "sender_full_name": "Jubilee",
        "timestamp": 1613534067
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"229517\">@Jacob Lifshay</span> the reason I question that is because this exists: <a href=\"https://doc.rust-lang.org/core/intrinsics/fn.fmaf32.html\">https://doc.rust-lang.org/core/intrinsics/fn.fmaf32.html</a></p>",
        "id": 226611040,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613534615
    },
    {
        "content": "<p>unless this doesn't actually allow fma in core, just the intrinsic</p>",
        "id": 226611124,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613534679
    },
    {
        "content": "<p>oh that's it</p>",
        "id": 226611240,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613534796
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>error[E0599]: no method named `mul_add` found for type `{float}` in the current scope\n --&gt; src/main.rs:4:17\n  |\n4 |     let _ = 2.0.mul_add(3.0, 4.0);\n  |                 ^^^^^^^ method not found in `{float}`\n</code></pre></div>",
        "id": 226611247,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613534810
    },
    {
        "content": "<p>I think we should follow the same path and only provide them in <code>std</code>, then</p>",
        "id": 226611298,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613534862
    },
    {
        "content": "<p>getting things working in core that don't even work for <code>f32</code> core is probably out of the scope of this...</p>",
        "id": 226611352,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613534890
    },
    {
        "content": "<p>Yeah, I just wanted to raise this as a much more concrete problem.</p>",
        "id": 226611381,
        "sender_full_name": "Jubilee",
        "timestamp": 1613534940
    },
    {
        "content": "<p>since, uh,<br>\nputs a SLIGHT CRAMP<br>\ninto launching into nightly</p>",
        "id": 226611708,
        "sender_full_name": "Jubilee",
        "timestamp": 1613535266
    },
    {
        "content": "<p>Yeah a bit lol.</p>",
        "id": 226611723,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613535288
    },
    {
        "content": "<p>Though it should be pretty easy to identify which functions result in libm calls</p>",
        "id": 226611756,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613535318
    },
    {
        "content": "<p>I wonder if we just add a <code>std</code> (or <code>libm</code> to be more specific?) cargo feature and leave that to integration</p>",
        "id": 226611824,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613535367
    },
    {
        "content": "<p>Github issue: <a href=\"https://github.com/rust-lang/stdsimd/issues/76\">https://github.com/rust-lang/stdsimd/issues/76</a></p>",
        "id": 226613261,
        "sender_full_name": "Lokathor",
        "timestamp": 1613536919
    },
    {
        "content": "<p>basically we (the rust project) need to fix the \"floats in core\" issue eventually, but we (the simd-wg) could skip on it for now, but if we do that we also lose all of our cool points forever.</p>",
        "id": 226613423,
        "sender_full_name": "Lokathor",
        "timestamp": 1613537110
    },
    {
        "content": "<p>I kinda agree, at least somewhat.<br>\nCan you start sketching out how addressing that looks like? You don't have to make all the PRs, but you seem to have a better idea of what all the problems are, and we need action-items we can action on instead of <em>sweeping gesture</em></p>",
        "id": 226613534,
        "sender_full_name": "Jubilee",
        "timestamp": 1613537267
    },
    {
        "content": "<p>I think there's nothing we can do about it (right now).  Like rounding has specific instructions on some architectures and if we make our own implementation it will just be dramatically worse than those</p>",
        "id": 226613622,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613537364
    },
    {
        "content": "<p>So I guess my concern isn't so much that we need libm (we don't) but that we have no way of conditioning on target features</p>",
        "id": 226613728,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613537483
    },
    {
        "content": "<p>Like the trig functions are a good example, we should definitely make our own branchless implementations of all of those functions, but how do we get sin and cos in the first place?</p>",
        "id": 226613829,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613537567
    },
    {
        "content": "<p>Though perhaps there is an argument that if the function is small enough, losing the function call makes up for potentially not being as good as libm</p>",
        "id": 226613920,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613537663
    },
    {
        "content": "<p>sin and cos (just to pick some examples) can be performed in simd, and in fact you don't need advanced target features</p>",
        "id": 226613951,
        "sender_full_name": "Lokathor",
        "timestamp": 1613537717
    },
    {
        "content": "<p>using advanced target features would be problematic, that's for sure, because core is pre-compiled</p>",
        "id": 226613972,
        "sender_full_name": "Lokathor",
        "timestamp": 1613537751
    },
    {
        "content": "<p>It's also worth noting that all of these are tedious, one-by-one, scalar calls.</p>",
        "id": 226614045,
        "sender_full_name": "Jubilee",
        "timestamp": 1613537811
    },
    {
        "content": "<p>Sorry that's not a good example</p>",
        "id": 226614052,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613537823
    },
    {
        "content": "<p>Here's a more concrete example</p>",
        "id": 226614056,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613537830
    },
    {
        "content": "<p>SSE 4.1 introduces the <code>roundps</code> instruction, and AVX adds <code>vroundps</code></p>",
        "id": 226614136,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613537923
    },
    {
        "content": "<p>Since we are not the backend, there is no way for us to conditionally use those instructions for rounding when those features are available</p>",
        "id": 226614174,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613537979
    },
    {
        "content": "<p>you can use conditional compilation still. though, honestly i don't know how that interacts with inline attribute, if you only inline the already conditional computed code or what.</p>",
        "id": 226614261,
        "sender_full_name": "Lokathor",
        "timestamp": 1613538065
    },
    {
        "content": "<p>Any rounding implementation we can write will be significantly worse than that</p>",
        "id": 226614265,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613538068
    },
    {
        "content": "<p>Conditional compilation doesn't work for two reasons, one because core is compiled with no features, and two because it won't work with runtime dispatch</p>",
        "id": 226614283,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613538102
    },
    {
        "content": "<p>i don't know why runtime dispatch matters</p>",
        "id": 226614295,
        "sender_full_name": "Lokathor",
        "timestamp": 1613538121
    },
    {
        "content": "<p>Personally the only SIMD I have ever used professionally has been runtime dispatched</p>",
        "id": 226614349,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613538152
    },
    {
        "content": "<p>I've always seen it compile time dispatched ;P</p>",
        "id": 226614359,
        "sender_full_name": "Lokathor",
        "timestamp": 1613538184
    },
    {
        "content": "<p>though i only programmed professionally for a short time once 15 years ago</p>",
        "id": 226614385,
        "sender_full_name": "Lokathor",
        "timestamp": 1613538202
    },
    {
        "content": "<p>I've never downloaded a binary and it asked me if I had AVX lol</p>",
        "id": 226614398,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613538213
    },
    {
        "content": "<p>right, you'd just not get avx support</p>",
        "id": 226614455,
        "sender_full_name": "Lokathor",
        "timestamp": 1613538246
    },
    {
        "content": "<p>or the program would use multi-versioning</p>",
        "id": 226614462,
        "sender_full_name": "Lokathor",
        "timestamp": 1613538260
    },
    {
        "content": "<p>Yeah when I say runtime dispatch I mean multiversioning</p>",
        "id": 226614471,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613538276
    },
    {
        "content": "<p>but you wouldn't runtime dispatch <em>within</em> the call to the round function</p>",
        "id": 226614474,
        "sender_full_name": "Lokathor",
        "timestamp": 1613538279
    },
    {
        "content": "<p>Though it could be broader than multiversioning as well</p>",
        "id": 226614476,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613538288
    },
    {
        "content": "<p>Intel does their dispatch with the dynamic linker once at load time</p>",
        "id": 226614487,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613538311
    },
    {
        "content": "<p>I agree it wouldn't just be for the round function</p>",
        "id": 226614513,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613538342
    },
    {
        "content": "<p>Which is my point, it's not possible for us to write a round function that detects the target features it's being inlined into</p>",
        "id": 226614578,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613538373
    },
    {
        "content": "<p>Any implementation we write will be strictly bad on anything SSE4.1 or later (so almost everything)</p>",
        "id": 226614613,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613538468
    },
    {
        "content": "<p>well then we better give up on simd <em>at all</em> because llvm is gonna emit those four libm calls unless sse4.1 is on at compile time</p>",
        "id": 226614688,
        "sender_full_name": "Lokathor",
        "timestamp": 1613538528
    },
    {
        "content": "<p>so you won't be able to make a runtime dispatch</p>",
        "id": 226614703,
        "sender_full_name": "Lokathor",
        "timestamp": 1613538546
    },
    {
        "content": "<p>No, it will emit roundps if you inline into a function that has the SSE4.1 target feature</p>",
        "id": 226614714,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613538575
    },
    {
        "content": "<p>This is still worth it even if it is only integers.</p>",
        "id": 226614721,
        "sender_full_name": "Jubilee",
        "timestamp": 1613538591
    },
    {
        "content": "<p>I say, trying to convince myself.</p>",
        "id": 226614722,
        "sender_full_name": "Jubilee",
        "timestamp": 1613538598
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"312331\">@Caleb Zulawski</span> well then why can't we use conditional compilation and rely on it being inlined appropriately</p>",
        "id": 226614785,
        "sender_full_name": "Lokathor",
        "timestamp": 1613538649
    },
    {
        "content": "<p>Because conditional compilation happens before codegen</p>",
        "id": 226614794,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613538671
    },
    {
        "content": "<p>It's basically textual</p>",
        "id": 226614809,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613538687
    },
    {
        "content": "<p>I believe it happens before even lowering to HIR</p>",
        "id": 226614822,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613538714
    },
    {
        "content": "<p>then we're pretty effed</p>",
        "id": 226614866,
        "sender_full_name": "Lokathor",
        "timestamp": 1613538735
    },
    {
        "content": "<p>like you'd have to use build-std</p>",
        "id": 226614874,
        "sender_full_name": "Lokathor",
        "timestamp": 1613538765
    },
    {
        "content": "<p>No I think we just need to solve it the \"right\" way which is make a libm that can be linked statically into core</p>",
        "id": 226614876,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613538769
    },
    {
        "content": "<p>That's \"we\" as in rust generally</p>",
        "id": 226614899,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613538792
    },
    {
        "content": "<p>even if libm were in core, four calls to a scalar op is bad</p>",
        "id": 226614904,
        "sender_full_name": "Lokathor",
        "timestamp": 1613538802
    },
    {
        "content": "<p>Agreed but I don't think there's anything we can do short of making llvm better</p>",
        "id": 226614919,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613538828
    },
    {
        "content": "<p>Or alternatively</p>",
        "id": 226614922,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613538832
    },
    {
        "content": "<p>if you set the right -Ctarget-feature then stuff gets inlined.</p>",
        "id": 226614927,
        "sender_full_name": "Jubilee",
        "timestamp": 1613538840
    },
    {
        "content": "<p>but core is compiled before that</p>",
        "id": 226614983,
        "sender_full_name": "Lokathor",
        "timestamp": 1613538869
    },
    {
        "content": "<p>mm.</p>",
        "id": 226614988,
        "sender_full_name": "Jubilee",
        "timestamp": 1613538878
    },
    {
        "content": "<p>core is shipped with rustup by default</p>",
        "id": 226614989,
        "sender_full_name": "Lokathor",
        "timestamp": 1613538879
    },
    {
        "content": "<p>Since these functions are inlined they are just mir basically, afaik</p>",
        "id": 226614995,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613538890
    },
    {
        "content": "<p>I need a drink.</p>",
        "id": 226614999,
        "sender_full_name": "Jubilee",
        "timestamp": 1613538892
    },
    {
        "content": "<p>If they were not inlined then yes they'd all be SSE only</p>",
        "id": 226615008,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613538909
    },
    {
        "content": "<p>I do not have any whiskey in this house. Why do I have no whiskey in this house.</p>",
        "id": 226615014,
        "sender_full_name": "Jubilee",
        "timestamp": 1613538912
    },
    {
        "content": "<p>because it's tequila time</p>",
        "id": 226615019,
        "sender_full_name": "Lokathor",
        "timestamp": 1613538924
    },
    {
        "content": "<p>ha</p>",
        "id": 226615021,
        "sender_full_name": "Jubilee",
        "timestamp": 1613538928
    },
    {
        "content": "<p>tequila on tuesday, that's a thing</p>",
        "id": 226615036,
        "sender_full_name": "Lokathor",
        "timestamp": 1613538944
    },
    {
        "content": "<p>So the other way to solve this, which is also outside of our scope, is to improve #[target_feature] to allow detection of features based on the function you're inlining into (which may or may not even be possible)</p>",
        "id": 226615081,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613538965
    },
    {
        "content": "<p>fair enough</p>",
        "id": 226615091,
        "sender_full_name": "Jubilee",
        "timestamp": 1613538983
    },
    {
        "content": "<p>The other, <em>other</em> way of solving this would be to fix LLVM to produce better fallback vector code</p>",
        "id": 226615093,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613538986
    },
    {
        "content": "<p>that would certainly help the most people</p>",
        "id": 226615104,
        "sender_full_name": "Lokathor",
        "timestamp": 1613539017
    },
    {
        "content": "<p>but also would involve you writing c++</p>",
        "id": 226615110,
        "sender_full_name": "Lokathor",
        "timestamp": 1613539031
    },
    {
        "content": "<p>I do that everyday <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 226615125,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613539063
    },
    {
        "content": "<p>opinion: It's time to oxidize the dragon <span aria-label=\"smiling imp\" class=\"emoji emoji-1f608\" role=\"img\" title=\"smiling imp\">:smiling_imp:</span></p>",
        "id": 226615146,
        "sender_full_name": "Jubilee",
        "timestamp": 1613539083
    },
    {
        "content": "<p>just a small PR</p>",
        "id": 226615195,
        "sender_full_name": "Lokathor",
        "timestamp": 1613539136
    },
    {
        "content": "<p>I do wonder if it's possible in LLVM to detect the target features of the function you're inlined into</p>",
        "id": 226615203,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613539147
    },
    {
        "content": "<p>that's a feature that would desperately help multiversioning in general</p>",
        "id": 226615212,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613539166
    },
    {
        "content": "<p>anyways</p>",
        "id": 226615222,
        "sender_full_name": "Jubilee",
        "timestamp": 1613539179
    },
    {
        "content": "<p>I think it makes sense to just do what <code>f32</code> and <code>f64</code> do for now</p>",
        "id": 226615375,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613539326
    },
    {
        "content": "<p>since I think it will work \"correctly\" in the most cases</p>",
        "id": 226615382,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613539336
    },
    {
        "content": "<p>So looking into LLVM it is possible to query target features of a function so it should be possible to make them inherit (which would let us multiversion functions to avoid libm)</p>",
        "id": 226615617,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613539683
    },
    {
        "content": "<p>maybe we need an RFC for stdsimd 2.0</p>",
        "id": 226615646,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613539698
    },
    {
        "content": "<p>occasionally you go 2 steps forward and 10 steps back</p>",
        "id": 226616543,
        "sender_full_name": "Lokathor",
        "timestamp": 1613540931
    },
    {
        "content": "<p>Also note: <em>even if</em> we fix it all, then things where the simd form depends on having a particular feature level should still get fallback code from us, because we can round a lot better than 4 libm calls even with just sse2</p>",
        "id": 226617696,
        "sender_full_name": "Lokathor",
        "timestamp": 1613542360
    },
    {
        "content": "<p>You mean if we fix the problems that prevent us from providing the fallback code?</p>",
        "id": 226617783,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613542476
    },
    {
        "content": "<p>we are going to get to nightly before we RFC stdsimd 2.0 lol</p>",
        "id": 226617811,
        "sender_full_name": "Jubilee",
        "timestamp": 1613542530
    },
    {
        "content": "<p>Yeah that's kinda my point, I don't think there is any path to us providing the fallbacks</p>",
        "id": 226617823,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613542559
    },
    {
        "content": "<p>Not in this project group I mean</p>",
        "id": 226617877,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613542577
    },
    {
        "content": "<p>ehhh I think we kinda can, Lokathor seems to have an idea. It might be as \"simple\" as making a few PRs here and there.</p>",
        "id": 226617896,
        "sender_full_name": "Jubilee",
        "timestamp": 1613542601
    },
    {
        "content": "<p>or I should say:<br>\nI don't think we can fix this the most satisfactory way.</p>",
        "id": 226617927,
        "sender_full_name": "Jubilee",
        "timestamp": 1613542649
    },
    {
        "content": "<p>But I think we can actually make a certain amount of... let's call it <em>investigatory</em> progress.</p>",
        "id": 226617944,
        "sender_full_name": "Jubilee",
        "timestamp": 1613542670
    },
    {
        "content": "<p>I don't really see any way of doing it without a full multiversioning implementation of #[target_feature]</p>",
        "id": 226618009,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613542725
    },
    {
        "content": "<p>Otherwise we're optimizing for the low performance case, not high performance</p>",
        "id": 226618039,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613542783
    },
    {
        "content": "<p>I agree that dispatching to libm per element is probably something like 4x worse than a vector implementation for SSE, but the vector implementation is probably going to be orders of magnitude worse than the roundps instruction which only requires SSE4.1</p>",
        "id": 226618230,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613543030
    },
    {
        "content": "<p>Just masking out the sign bit is already the same order of magnitude!</p>",
        "id": 226618301,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613543089
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/The.20libm.20problem/near/226618039\">said</a>:</p>\n<blockquote>\n<p>Otherwise we're optimizing for the low performance case, not high performance</p>\n</blockquote>\n<p>Obligatory: Even if it is the low performance case, it's worth optimizing for code compiled under the default flags, since almost all code is compiled under the default flags.</p>",
        "id": 226620979,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1613546198
    },
    {
        "content": "<p>example: you can ceil / floor with just sse2</p>",
        "id": 226621022,
        "sender_full_name": "Lokathor",
        "timestamp": 1613546250
    },
    {
        "content": "<p>it's multi-step rather than one instruction, but even that will be way <em>way</em> more efficient than going out of simd, making four calls to libm, and going back in to simd</p>",
        "id": 226621090,
        "sender_full_name": "Lokathor",
        "timestamp": 1613546307
    },
    {
        "content": "<p>Is almost all SIMD code compiled under the default flags?</p>",
        "id": 226621138,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613546386
    },
    {
        "content": "<p>unless the entire compilation process is fixed, it seems we are incapable of shipping people a core lib with more than default flags enabled, so we should make the most of default flags</p>",
        "id": 226621200,
        "sender_full_name": "Lokathor",
        "timestamp": 1613546415
    },
    {
        "content": "<p>Since the functions are inline it doesn't matter</p>",
        "id": 226621220,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613546442
    },
    {
        "content": "<p>we should probably address this to T-compiler.</p>",
        "id": 226621226,
        "sender_full_name": "Jubilee",
        "timestamp": 1613546453
    },
    {
        "content": "<p>but I agree that honestly, I am OK with pessimizing perf somewhat on our first go-around.</p>",
        "id": 226621241,
        "sender_full_name": "Jubilee",
        "timestamp": 1613546474
    },
    {
        "content": "<p>it matters because inline doesn't fix the problem here</p>",
        "id": 226621250,
        "sender_full_name": "Lokathor",
        "timestamp": 1613546488
    },
    {
        "content": "<p>LLVM's round instruction ends up in the user codegen, not the core lib codegen</p>",
        "id": 226621254,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613546491
    },
    {
        "content": "<p>our goal is to beat scalar, not beat a hypothetical best</p>",
        "id": 226621255,
        "sender_full_name": "Jubilee",
        "timestamp": 1613546494
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/The.20libm.20problem/near/226621138\">said</a>:</p>\n<blockquote>\n<p>Is almost all SIMD code compiled under the default flags?</p>\n</blockquote>\n<p>Yes, almost certainly.</p>",
        "id": 226621257,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1613546497
    },
    {
        "content": "<p>That would imply no one writes AVX, which I think is definitely wrong</p>",
        "id": 226621311,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613546533
    },
    {
        "content": "<p>do you bother setting RUSTFLAGS=\"-Ctarget-cpu=native\" and such when you do <code>cargo install</code>? or <code>cargo build --release</code>? Most people don't</p>",
        "id": 226621321,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1613546542
    },
    {
        "content": "<p>if we need to tell people to -Zbuild-std to get best perf, then we'll do that.</p>",
        "id": 226621325,
        "sender_full_name": "Jubilee",
        "timestamp": 1613546546
    },
    {
        "content": "<p>imo</p>",
        "id": 226621330,
        "sender_full_name": "Jubilee",
        "timestamp": 1613546552
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"312331\">@Caleb Zulawski</span> but <em>we can't call the llvm round instruction</em> if we don't know that sse4.1 is there. If we do, that's 4 libm calls. So if we don't know it'll be sse4.1 for sure, we have to take the sse2 path and <em>not call the llvm round instruction at all</em> and just do it ourselves</p>",
        "id": 226621350,
        "sender_full_name": "Lokathor",
        "timestamp": 1613546577
    },
    {
        "content": "<p>it sounds stupid, but is true</p>",
        "id": 226621372,
        "sender_full_name": "Lokathor",
        "timestamp": 1613546620
    },
    {
        "content": "<p>We can call the LLVM round instruction, just only in std</p>",
        "id": 226621375,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613546626
    },
    {
        "content": "<p>no, in std without sse4.1 that's what turns into the libm calls</p>",
        "id": 226621430,
        "sender_full_name": "Lokathor",
        "timestamp": 1613546648
    },
    {
        "content": "<p>It doesn't make sense to me to optimize a potentially 4x speedup (2x for f64) at the cost of maybe 100x slowdown for AVX</p>",
        "id": 226621439,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613546663
    },
    {
        "content": "<p>let's bench it.</p>",
        "id": 226621442,
        "sender_full_name": "Jubilee",
        "timestamp": 1613546675
    },
    {
        "content": "<p>avx would be able to avoid a slow down by telling people to use build-std</p>",
        "id": 226621470,
        "sender_full_name": "Lokathor",
        "timestamp": 1613546712
    },
    {
        "content": "<p>I think that's an unacceptable solution honestly, you shouldn't have to build std yourself to use AVX in a SIMD module of std</p>",
        "id": 226621587,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613546814
    },
    {
        "content": "<p>But I will note this is basically a compiler issue.<br>\nIt's not an API issue.<br>\nWe should not try to bend our API around the compiler being bad at compilation in any meaningful sense.<br>\nWe use the tools that are available, but otherwise, we should, rather, slam our faces directly into the bad compilation.</p>",
        "id": 226621596,
        "sender_full_name": "Jubilee",
        "timestamp": 1613546822
    },
    {
        "content": "<p>I agree that it's really not our problem since it already exists for f32 and f64</p>",
        "id": 226621630,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613546870
    },
    {
        "content": "<p><strong>however</strong>, our goal is still to compile to SIMD instructions.</p>",
        "id": 226621681,
        "sender_full_name": "Jubilee",
        "timestamp": 1613546891
    },
    {
        "content": "<p>And on x86_64 we can always do so.<br>\nOptimizing beyond that is a compiler-level concern.</p>",
        "id": 226621700,
        "sender_full_name": "Jubilee",
        "timestamp": 1613546912
    },
    {
        "content": "<p>this is basically why we started talking to T-compiler about an MCP</p>",
        "id": 226621742,
        "sender_full_name": "Jubilee",
        "timestamp": 1613546963
    },
    {
        "content": "<p>:V</p>",
        "id": 226621746,
        "sender_full_name": "Jubilee",
        "timestamp": 1613546967
    },
    {
        "content": "<p>part of it anyways</p>",
        "id": 226621749,
        "sender_full_name": "Jubilee",
        "timestamp": 1613546974
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span> your very own example shows that we don't get simd instructions</p>",
        "id": 226621760,
        "sender_full_name": "Lokathor",
        "timestamp": 1613546987
    },
    {
        "content": "<p>exactly.</p>",
        "id": 226621764,
        "sender_full_name": "Jubilee",
        "timestamp": 1613546995
    },
    {
        "content": "<p>so what did you mean by \"we can always do so\" then? ?_?</p>",
        "id": 226621819,
        "sender_full_name": "Lokathor",
        "timestamp": 1613547021
    },
    {
        "content": "<p>is there any idea how we'd fix it in the compiler though? Without a plan to do that, I uh, think it won't get fixed there. it's also a problem that is worse for SIMD than it is for non-SIMD code</p>",
        "id": 226621820,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1613547022
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span>  I am basically saying that from my perspective it is better to default to SSE2 even if that pessimizes some other things a bit.</p>",
        "id": 226621843,
        "sender_full_name": "Jubilee",
        "timestamp": 1613547051
    },
    {
        "content": "<p>ah, yes i see</p>",
        "id": 226621857,
        "sender_full_name": "Lokathor",
        "timestamp": 1613547068
    },
    {
        "content": "<p>we should piss off our users until T-compiler fixes it, obviously. :^)</p>",
        "id": 226621882,
        "sender_full_name": "Jubilee",
        "timestamp": 1613547118
    },
    {
        "content": "<p>JOKING</p>",
        "id": 226621920,
        "sender_full_name": "Jubilee",
        "timestamp": 1613547126
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"312331\">@Caleb Zulawski</span> the problem is that people dont have avx flags on by default so most people will get the ultra-slow libm path anyway.</p>",
        "id": 226621921,
        "sender_full_name": "Lokathor",
        "timestamp": 1613547127
    },
    {
        "content": "<p>I don't think it makes sense to prioritize SSE2 at all</p>",
        "id": 226621925,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613547131
    },
    {
        "content": "<p>as long as it's the default simd level we have to focus on the common case</p>",
        "id": 226621938,
        "sender_full_name": "Lokathor",
        "timestamp": 1613547162
    },
    {
        "content": "<p>But #[target_feature] is available and has been for a long time</p>",
        "id": 226621985,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613547197
    },
    {
        "content": "<p>and anyone who knows enough to see that they want to set alternative rustflags will be able to also add a -Zbuild-std</p>",
        "id": 226621987,
        "sender_full_name": "Lokathor",
        "timestamp": 1613547199
    },
    {
        "content": "<p>Right but the problem is that bleeds into libraries then</p>",
        "id": 226622012,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613547240
    },
    {
        "content": "<p>...so?</p>",
        "id": 226622056,
        "sender_full_name": "Jubilee",
        "timestamp": 1613547250
    },
    {
        "content": "<p>bleads how?</p>",
        "id": 226622063,
        "sender_full_name": "Lokathor",
        "timestamp": 1613547258
    },
    {
        "content": "<p>If you want to write a performant library that uses SIMD now you also need to tell every user of your library to also build std</p>",
        "id": 226622073,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613547273
    },
    {
        "content": "<p>OK?</p>",
        "id": 226622118,
        "sender_full_name": "Jubilee",
        "timestamp": 1613547339
    },
    {
        "content": "<p>At that point it's easier to just use core::arch and makes stdsimd kind of useless, in my opinion</p>",
        "id": 226622123,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613547351
    },
    {
        "content": "<p>Well, so the entire promise of this part lf the api is that users don't have to mess with target_feature. it should literally \"just work\", and if <code>f32x4</code> doesn't work right when you try to use it on its own without any fancy attributes and multi-versioning and feature detection then we've given the users a lemon</p>",
        "id": 226622188,
        "sender_full_name": "Lokathor",
        "timestamp": 1613547388
    },
    {
        "content": "<p>a lot of people are out there writing <code>#![no_std]</code> projects, just saying that building std isn't that weird.</p>",
        "id": 226622192,
        "sender_full_name": "Jubilee",
        "timestamp": 1613547394
    },
    {
        "content": "<p>I don't see how building std is related to no_std? Isn't it the opposite?</p>",
        "id": 226622220,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613547433
    },
    {
        "content": "<p>exactly.</p>",
        "id": 226622243,
        "sender_full_name": "Jubilee",
        "timestamp": 1613547460
    },
    {
        "content": "<p>well, so hold on, build-std is also how you make cargo build core and alloc for you</p>",
        "id": 226622261,
        "sender_full_name": "Lokathor",
        "timestamp": 1613547477
    },
    {
        "content": "<p>build-std actually accepts a list of standard library crates to build</p>",
        "id": 226622332,
        "sender_full_name": "Lokathor",
        "timestamp": 1613547512
    },
    {
        "content": "<p>or i think just does them all if you leave off the list</p>",
        "id": 226622345,
        "sender_full_name": "Lokathor",
        "timestamp": 1613547528
    },
    {
        "content": "<p>I think we're getting way off in the weeds on this honestly</p>",
        "id": 226622370,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613547558
    },
    {
        "content": "<p>...could we make building with a target SIMD feature also imply Zbuild-std=simd?</p>",
        "id": 226622380,
        "sender_full_name": "Jubilee",
        "timestamp": 1613547576
    },
    {
        "content": "<p>it can't be that easy<br>\ncan it?</p>",
        "id": 226622398,
        "sender_full_name": "Jubilee",
        "timestamp": 1613547591
    },
    {
        "content": "<p>If we're only talking about supporting the base architecture why are we supporting anything other than x86-64 and aarch64? Nothing else afaik has SIMD in the base instruction set</p>",
        "id": 226622441,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613547609
    },
    {
        "content": "<p>telling cargo to build you your own <code>core</code> would make conditional compilation within <code>core</code> work right such that you could call the llvm simd_ceil (and friends) or not</p>",
        "id": 226622447,
        "sender_full_name": "Lokathor",
        "timestamp": 1613547614
    },
    {
        "content": "<p>armv7 certainly does not</p>",
        "id": 226622456,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613547624
    },
    {
        "content": "<p>Nor i386</p>",
        "id": 226622463,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613547636
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/The.20libm.20problem/near/226622398\">said</a>:</p>\n<blockquote>\n<p>it can't be that easy<br>\ncan it?</p>\n</blockquote>\n<p>i mean, i'm unsure that actually solves the problem. note that we probably dont want to tell people to say -Ctarget-feature or -Ctarget-cpu without solving <a href=\"https://github.com/rust-lang/rust/issues/64609\">https://github.com/rust-lang/rust/issues/64609</a>, which kinda seems unsolvable tbh</p>",
        "id": 226622509,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1613547691
    },
    {
        "content": "<p>I also think going entirely on compile-time features and just dismissing runtime feature selection is just a bad idea</p>",
        "id": 226622578,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613547741
    },
    {
        "content": "<p>well i misunderstood how inline and conditional compilation and inlining in a target crate interacted because i didn't think about it hard enough, also i didn't think about the core being pre-built well enough</p>",
        "id": 226622593,
        "sender_full_name": "Lokathor",
        "timestamp": 1613547755
    },
    {
        "content": "<p>Ripgrep is the tool that got me to learn rust in the first place...</p>",
        "id": 226622595,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613547756
    },
    {
        "content": "<p>none of this is an issue for <code>wide</code>, for example</p>",
        "id": 226622605,
        "sender_full_name": "Lokathor",
        "timestamp": 1613547765
    },
    {
        "content": "<p>ripgrep has a lot of conditional compilation tho'?</p>",
        "id": 226622643,
        "sender_full_name": "Jubilee",
        "timestamp": 1613547807
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/The.20libm.20problem/near/226622578\">said</a>:</p>\n<blockquote>\n<p>I also think going entirely on compile-time features and just dismissing runtime feature selection is just a bad idea</p>\n</blockquote>\n<p>both are important, but proper use of runtime feature selection will probably require unsafe code for quite a while, and so most users of the shiny new portable api will likely avoid it.</p>",
        "id": 226622646,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1613547820
    },
    {
        "content": "<p>Well maybe it does but the magic is runtime feature selection</p>",
        "id": 226622652,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613547826
    },
    {
        "content": "<p>A pure sse2 ripgrep is certainly not as fast</p>",
        "id": 226622661,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613547840
    },
    {
        "content": "<p>Or my <code>multiversion</code> crate which is a safe abstraction <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 226622713,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613547870
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"209168\">@Thom Chiovoloni</span> that issue is only a problem if you don't build-std</p>",
        "id": 226622718,
        "sender_full_name": "Lokathor",
        "timestamp": 1613547888
    },
    {
        "content": "<p>But yes, it requires one unsafe block</p>",
        "id": 226622720,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613547891
    },
    {
        "content": "<p>and a million hearts shattered</p>",
        "id": 226622742,
        "sender_full_name": "Lokathor",
        "timestamp": 1613547913
    },
    {
        "content": "<p>you realize that 1 unsafe block is still a big deal for a lot of crates.</p>",
        "id": 226622750,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1613547927
    },
    {
        "content": "<p>yeah most people would simply not do it</p>",
        "id": 226622779,
        "sender_full_name": "Lokathor",
        "timestamp": 1613547949
    },
    {
        "content": "<p>Properly vetted unsafe is correct rust</p>",
        "id": 226622793,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613547956
    },
    {
        "content": "<p>Which is why it's useful to have as an abstraction</p>",
        "id": 226622839,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613547968
    },
    {
        "content": "<p>I don't actually see how -Zbuild-std is more onerous than -Ctarget-feature. Like genuinely.</p>",
        "id": 226622901,
        "sender_full_name": "Jubilee",
        "timestamp": 1613548043
    },
    {
        "content": "<p>yes, i know, and I'm the kind of person who writes programs that start with <code>fn main() { unsafe {</code>, but most people are still very very uncomfortable with the idea of using unsafe themselves.</p>\n<p>they want \"only safe apis\", and they don't think about the fact that everything a slice or a vec does is all unsafe all over the place</p>",
        "id": 226622914,
        "sender_full_name": "Lokathor",
        "timestamp": 1613548063
    },
    {
        "content": "<p>er, that was to C not J</p>",
        "id": 226622971,
        "sender_full_name": "Lokathor",
        "timestamp": 1613548093
    },
    {
        "content": "<p>It's not, it's that it's more onerous than (and actually defeats) #[target_feature] which is already part of the language and should be supported</p>",
        "id": 226622985,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613548111
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/The.20libm.20problem/near/226622901\">said</a>:</p>\n<blockquote>\n<p>I don't actually see how -Zbuild-std is more onerous than -Ctarget-feature. Like genuinely.</p>\n</blockquote>\n<p>It's not, (aside from needing nightly, which I'm assuming we're imagining a world in which this is stable  ignoring for a fact that there are major problems with -Zbuild-std that need to be worked out before it <em>can</em> stabilize...) but nobody uses that anyway</p>",
        "id": 226623001,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1613548134
    },
    {
        "content": "<p>actually you need both</p>",
        "id": 226623008,
        "sender_full_name": "Lokathor",
        "timestamp": 1613548143
    },
    {
        "content": "<p>you'd need to build std with a higher feature level enabled</p>",
        "id": 226623027,
        "sender_full_name": "Lokathor",
        "timestamp": 1613548161
    },
    {
        "content": "<p>but then the whole binary would require that level, hm, which negates multi-versioning</p>",
        "id": 226623116,
        "sender_full_name": "Lokathor",
        "timestamp": 1613548231
    },
    {
        "content": "<p>I'm extremely concerned about effectively limiting ourselves to only two instruction sets, SSE2 and ASIMD</p>",
        "id": 226623175,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613548285
    },
    {
        "content": "<p>wait, no, because of target_feature_enable, it would, uh, i think all work</p>",
        "id": 226623188,
        "sender_full_name": "Lokathor",
        "timestamp": 1613548307
    },
    {
        "content": "<p>gonna huff some noble gases to get the inspiration to solve this problem (no)</p>",
        "id": 226623234,
        "sender_full_name": "Jubilee",
        "timestamp": 1613548324
    },
    {
        "content": "<p>I still think this is a codegen problem</p>",
        "id": 226623251,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613548343
    },
    {
        "content": "<p>well it's all a codegen problem</p>",
        "id": 226623267,
        "sender_full_name": "Lokathor",
        "timestamp": 1613548364
    },
    {
        "content": "<p>It's primarily an LLVM bug for poorly implementing vector rounding etc</p>",
        "id": 226623275,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613548374
    },
    {
        "content": "<p>going to WRITE MY OWN BACKEND AT THIS RATE</p>",
        "id": 226623295,
        "sender_full_name": "Jubilee",
        "timestamp": 1613548395
    },
    {
        "content": "<p>GO UTTERLY MAD</p>",
        "id": 226623300,
        "sender_full_name": "Jubilee",
        "timestamp": 1613548400
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/The.20libm.20problem/near/226623175\">said</a>:</p>\n<blockquote>\n<p>I'm extremely concerned about effectively limiting ourselves to only two instruction sets, SSE2 and ASIMD</p>\n</blockquote>\n<p>And I'm extremely concerned about optimizing for the case where people just use the library without:</p>\n<ul>\n<li>Adding target feature flags</li>\n<li>writing unsafe code</li>\n<li>using multiversioning</li>\n</ul>\n<p>Which seems like it would be very common</p>",
        "id": 226623312,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1613548409
    },
    {
        "content": "<p>Which other part of the stdlib requires that much work to \"use correctly\"?</p>",
        "id": 226623404,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1613548460
    },
    {
        "content": "<p>nada, basically, except on special platforms... which is why I think -Zbuild-std is actually relatively OK.</p>",
        "id": 226623448,
        "sender_full_name": "Jubilee",
        "timestamp": 1613548495
    },
    {
        "content": "<p>Maybe the fact that liballoc perf is harmed by not using a custom allocator? But it still optimizes for the default allocator case...</p>",
        "id": 226623466,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1613548506
    },
    {
        "content": "<p>since you kinda need to do that kinda thing for genuinely special platforms anyways</p>",
        "id": 226623487,
        "sender_full_name": "Jubilee",
        "timestamp": 1613548523
    },
    {
        "content": "<p>so, so, does cfg and multi-versioning interact right?</p>",
        "id": 226623507,
        "sender_full_name": "Lokathor",
        "timestamp": 1613548562
    },
    {
        "content": "<p>In that case we shouldn't even be very concerned about shuffles since extract, insert, movldup and blendv aren't part of SSE2</p>",
        "id": 226623551,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613548572
    },
    {
        "content": "<p>you can do a low cost blend with sse2</p>",
        "id": 226623569,
        "sender_full_name": "Lokathor",
        "timestamp": 1613548610
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> no they do not, cfg occurs textually before lowering, target feature operates at codegen</p>",
        "id": 226623575,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613548612
    },
    {
        "content": "<p>it's not so bad</p>",
        "id": 226623577,
        "sender_full_name": "Lokathor",
        "timestamp": 1613548614
    },
    {
        "content": "<p>pshufb!</p>",
        "id": 226623579,
        "sender_full_name": "Jubilee",
        "timestamp": 1613548614
    },
    {
        "content": "<p>wait that's sse3</p>",
        "id": 226623595,
        "sender_full_name": "Jubilee",
        "timestamp": 1613548631
    },
    {
        "content": "<p>Which is why I really do not thing cfg is appropriate for this</p>",
        "id": 226623596,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613548631
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"312331\">@Caleb Zulawski</span> well that's absolutely beyond the pale bad and stabs multi-versioning in the face</p>",
        "id": 226623627,
        "sender_full_name": "Lokathor",
        "timestamp": 1613548676
    },
    {
        "content": "<p>I think that's just not what cfg is for</p>",
        "id": 226623680,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613548708
    },
    {
        "content": "<p>so, but wait, if you target_feature(enable=sse3) on a function then the cfg of sse3 is still false inside that function?</p>",
        "id": 226623713,
        "sender_full_name": "Lokathor",
        "timestamp": 1613548748
    },
    {
        "content": "<p>You would need to delay lexing a function until you've finished codegen of another</p>",
        "id": 226623716,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613548751
    },
    {
        "content": "<p>Yes, because cfg is set before even lowering to HIR</p>",
        "id": 226623747,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613548779
    },
    {
        "content": "<p>that is utterly broken</p>",
        "id": 226623765,
        "sender_full_name": "Lokathor",
        "timestamp": 1613548796
    },
    {
        "content": "<p>cfg is purely a preprocessor</p>",
        "id": 226623766,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613548797
    },
    {
        "content": "<p>wait, you're answering questions about cfg, not target_feature(enable)</p>",
        "id": 226623963,
        "sender_full_name": "Jubilee",
        "timestamp": 1613548834
    },
    {
        "content": "<p>The target feature attribute purely affects codegen</p>",
        "id": 226624096,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613548876
    },
    {
        "content": "<p>ssso...</p>",
        "id": 226624207,
        "sender_full_name": "Jubilee",
        "timestamp": 1613548923
    },
    {
        "content": "<p>cfg is handled by rustc sometime around lexing, and the target feature attribute is hardly considered by rust at all and goes almost directly to LLVM</p>",
        "id": 226624243,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613548930
    },
    {
        "content": "<p>so you can't use <code>#[cfg(target_feature=\"sse3\")]</code>, but you <em>could</em> use the cfg! version, right?</p>",
        "id": 226624250,
        "sender_full_name": "Lokathor",
        "timestamp": 1613548936
    },
    {
        "content": "<p>You can't use either</p>",
        "id": 226624256,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613548944
    },
    {
        "content": "<p>cfg is set before you even start the compilation process</p>",
        "id": 226624267,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613548960
    },
    {
        "content": "<p>oh right that's the same problem</p>",
        "id": 226624287,
        "sender_full_name": "Lokathor",
        "timestamp": 1613548979
    },
    {
        "content": "<p>alright time for the portable simd 3.0 rfc</p>",
        "id": 226624320,
        "sender_full_name": "Lokathor",
        "timestamp": 1613548994
    },
    {
        "content": "<p>That's why I'm suggesting it's an LLVM bug</p>",
        "id": 226624338,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613549013
    },
    {
        "content": "<p>ok, I'm going to go to bed, we've had a nice winemaking session but tomorrow we're gonna squeeze these grapes of wrath and get a real write up.</p>",
        "id": 226624357,
        "sender_full_name": "Jubilee",
        "timestamp": 1613549027
    },
    {
        "content": "<p>Only LLVM is aware of the target features available at the codegen site, it's up to LLVM to produce good code for its own instructions</p>",
        "id": 226624412,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613549047
    },
    {
        "content": "<p>or something. maybe later this/next week.</p>",
        "id": 226624419,
        "sender_full_name": "Jubilee",
        "timestamp": 1613549052
    },
    {
        "content": "<p>i think llvm is at fault but also rustc is at fault on the target feature enabled thing</p>",
        "id": 226624426,
        "sender_full_name": "Lokathor",
        "timestamp": 1613549060
    },
    {
        "content": "<p>As a bystander, I just feel like noting that I'd rather not build the standard library to use SIMD. Compile times are already bad enough with Rust and that would just make it worse.</p>",
        "id": 226624430,
        "sender_full_name": "BlackHoleFox",
        "timestamp": 1613549068
    },
    {
        "content": "<p>oh we can get the time to build <code>core</code> back down under a few minutes if we just cut some avx512 stuff &gt;.&gt;</p>",
        "id": 226624493,
        "sender_full_name": "Lokathor",
        "timestamp": 1613549131
    },
    {
        "content": "<p>lol.</p>",
        "id": 226624510,
        "sender_full_name": "Jubilee",
        "timestamp": 1613549147
    },
    {
        "content": "<p>delete intel</p>",
        "id": 226624521,
        "sender_full_name": "Lokathor",
        "timestamp": 1613549162
    },
    {
        "content": "<p>sounds good to me.</p>",
        "id": 226624569,
        "sender_full_name": "Jubilee",
        "timestamp": 1613549170
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/issues/55107\">https://github.com/rust-lang/rust/issues/55107</a></p>",
        "id": 226625167,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613549546
    },
    {
        "content": "<p>Just found this issue of someone using #[target_feature] and roundps from 2018, so I really don't think I have a unique stance on #[target_feature]</p>",
        "id": 226625288,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613549627
    },
    {
        "content": "<p>(this issue also illustrates that the codegen issues here are definitely not new)</p>",
        "id": 226625367,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613549666
    },
    {
        "content": "<p>(unfortunately)</p>",
        "id": 226625389,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613549684
    },
    {
        "content": "<p>definitely going mad tho'</p>",
        "id": 226625399,
        "sender_full_name": "Jubilee",
        "timestamp": 1613549700
    },
    {
        "content": "<p>and considering writing my own backend</p>",
        "id": 226625411,
        "sender_full_name": "Jubilee",
        "timestamp": 1613549709
    },
    {
        "content": "<p>very \"programming as Lovecraftian horror\" project group, I like it.</p>",
        "id": 226625452,
        "sender_full_name": "Jubilee",
        "timestamp": 1613549747
    },
    {
        "content": "<p>( LET'S MULTIVERSION STD. no. maybe. )</p>",
        "id": 226625790,
        "sender_full_name": "Jubilee",
        "timestamp": 1613549986
    },
    {
        "content": "<p>If we had language level multiversioning that would possibly be the way to go</p>",
        "id": 226625900,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613550039
    },
    {
        "content": "<p>Though at that point you could just do it at codegen</p>",
        "id": 226625923,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613550062
    },
    {
        "content": "<p>hmm, it seems to me that the logical solution is to add code to LLVM that uses the Rust vector math library that is apparently going to be written since calling libm is unacceptable. This is just like clang's <code>-fvec-lib=...</code> option.<br>\n<a href=\"https://reviews.llvm.org/D88154\">https://reviews.llvm.org/D88154</a></p>",
        "id": 226634208,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1613555374
    },
    {
        "content": "<p>the thing about multi-versioning is that doing it at the individual op level is basically way too low level</p>",
        "id": 226659671,
        "sender_full_name": "Lokathor",
        "timestamp": 1613570547
    },
    {
        "content": "<p>That's exactly what codegen does, though</p>",
        "id": 226660366,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613570861
    },
    {
        "content": "<p>By multiversioning here I don't mean runtime dispatch</p>",
        "id": 226661440,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613571310
    },
    {
        "content": "<p>I mean multiple versions of the function, one of which is selected by the codegen features</p>",
        "id": 226661474,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613571330
    },
    {
        "content": "<p>I do think using libmvec looks like the best way to fix the immediate performance issue of libm, though</p>",
        "id": 226661647,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613571405
    },
    {
        "content": "<p>what is the likelihood that people have it installed though?</p>",
        "id": 226662528,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1613571754
    },
    {
        "content": "<p>True. I'm really hoping there's a way to static link it</p>",
        "id": 226662621,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613571799
    },
    {
        "content": "<p>It's also minimal enough that we can recreate it in rust</p>",
        "id": 226662789,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613571862
    },
    {
        "content": "<p>Much smaller than libm</p>",
        "id": 226662807,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613571869
    },
    {
        "content": "<p>We may be able to just add the symbol directly to core?  It would just be some FFI and the implementation itself could be done with stdsimd</p>",
        "id": 226663638,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613572238
    },
    {
        "content": "<p>The problem with multi-versioning at the per function level is that it's a branch per function call instead of like, once at the start of a lot of work and then not again</p>",
        "id": 226666258,
        "sender_full_name": "Lokathor",
        "timestamp": 1613573406
    },
    {
        "content": "<p>I don't mean runtime dispatch</p>",
        "id": 226666447,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613573482
    },
    {
        "content": "<p>I wonder how the <code>-Z build-std</code> work is going.  It might be ok to make the compile-time global feature detection dependent on that.  (Though that won't solve the local-per-function parts for when Lokathor wants to have basic and fancy versions of the program and do a runtime choice between them.)</p>",
        "id": 226666478,
        "sender_full_name": "scottmcm",
        "timestamp": 1613573493
    },
    {
        "content": "<p>I mean the exact same as what LLVM is doing--depending on the available features it chooses the correct codelet</p>",
        "id": 226666603,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613573528
    },
    {
        "content": "<p>but also here's a fun fact, just a little detail i thought I'd mention: libm is used in the standard library by a slightly round-about way. What happens is that compiler-builtins has a git sub-module for libm which it can compile in and it doesn't even compile the libm crate as a crate, it just compiles the individual modules that are deemed necessary.</p>",
        "id": 226666651,
        "sender_full_name": "Lokathor",
        "timestamp": 1613573547
    },
    {
        "content": "<p>Which brings me back to my point that I <em>really</em> think this is an LLVM issue</p>",
        "id": 226666676,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613573554
    },
    {
        "content": "<p>doesn't rust allow usage of an llvm like 2 versions behind the latest?</p>",
        "id": 226667030,
        "sender_full_name": "Lokathor",
        "timestamp": 1613573674
    },
    {
        "content": "<p>No clue</p>",
        "id": 226667108,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613573709
    },
    {
        "content": "<p>Seems likely</p>",
        "id": 226667132,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613573718
    },
    {
        "content": "<p>so like if you fixed it in LLVM <em>today</em> it'd be a year or whatever for that to be reflected in rustc?</p>",
        "id": 226667286,
        "sender_full_name": "Lokathor",
        "timestamp": 1613573774
    },
    {
        "content": "<p>Maybe</p>",
        "id": 226667373,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613573809
    },
    {
        "content": "<p>unfortunate</p>",
        "id": 226667400,
        "sender_full_name": "Lokathor",
        "timestamp": 1613573818
    },
    {
        "content": "<p>Though it seems there's libmvec support today</p>",
        "id": 226667618,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613573883
    },
    {
        "content": "<p>so we get llvm to emit libmvec calls instead of libm calls, and then we write any libmvec functions that aren't covered by the system libmvec?</p>",
        "id": 226667819,
        "sender_full_name": "Lokathor",
        "timestamp": 1613573955
    },
    {
        "content": "<p>Hopefully</p>",
        "id": 226667894,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613573989
    },
    {
        "content": "<p>well <em>that</em> sound quite doable</p>",
        "id": 226667972,
        "sender_full_name": "Lokathor",
        "timestamp": 1613574006
    },
    {
        "content": "<p>My only concern is that libmvec seems to be a specific gnu thing</p>",
        "id": 226668028,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613574029
    },
    {
        "content": "<p>Though I've seen at least one non-gnu implementation</p>",
        "id": 226668090,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613574054
    },
    {
        "content": "<p>we would need to write our own probably</p>",
        "id": 226668152,
        "sender_full_name": "Lokathor",
        "timestamp": 1613574074
    },
    {
        "content": "<p>Yeah</p>",
        "id": 226668184,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613574087
    },
    {
        "content": "<p>I still think our time is best spent elsewhere for now and just use the slower libm implementation</p>",
        "id": 226668358,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613574141
    },
    {
        "content": "<p>But we should at least check clang on godbolt to see what it actually emits</p>",
        "id": 226668402,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613574162
    },
    {
        "content": "<p>go for it. <span aria-label=\"eyes\" class=\"emoji emoji-1f440\" role=\"img\" title=\"eyes\">:eyes:</span></p>",
        "id": 226676207,
        "sender_full_name": "Jubilee",
        "timestamp": 1613576976
    },
    {
        "content": "<p>libmvec seems to be x86_64 only also</p>",
        "id": 226679183,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1613577816
    },
    {
        "content": "<p>but maybe the docs i see on it are outdated</p>",
        "id": 226679281,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1613577838
    },
    {
        "content": "<p>Yeah libmvec is x86_64 only apparently</p>",
        "id": 226682273,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613578800
    },
    {
        "content": "<p>The good news, though, is llvm actually lets us choose our vector library</p>",
        "id": 226682359,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613578819
    },
    {
        "content": "<p>It supports libmvec, Apple Accelerate, IBM MASS, and Intel SVML</p>",
        "id": 226682424,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613578855
    },
    {
        "content": "<p>And yes, it does produce function calls to those instead of libm</p>",
        "id": 226682506,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613578888
    },
    {
        "content": "<p>It appears right now only a subset of functions are supported (round is not one of them)</p>",
        "id": 226682550,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613578908
    },
    {
        "content": "<p>It supports sin, cos, exp, pow, and log which is a good start</p>",
        "id": 226682637,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613578934
    },
    {
        "content": "<p>But the thing that is most exciting to me is that if they support so many... Perhaps we can just write our own and add it as one of the many supported libraries?</p>",
        "id": 226682744,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613578977
    },
    {
        "content": "<p>(though if we're really just filling out an API we can do that too)</p>",
        "id": 226683025,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613579075
    },
    {
        "content": "<p><a href=\"https://gcc.godbolt.org/z/Tq43b4\">https://gcc.godbolt.org/z/Tq43b4</a></p>",
        "id": 226683280,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613579170
    },
    {
        "content": "<p>despite libmvec being x86_64, it appears to allow it to be used on aarch64!</p>",
        "id": 226683354,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613579201
    },
    {
        "content": "<p>so I think we can just fill out the libmvec API.</p>",
        "id": 226683391,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613579220
    },
    {
        "content": "<p>sounds promising.</p>",
        "id": 226683884,
        "sender_full_name": "Jubilee",
        "timestamp": 1613579393
    },
    {
        "content": "<p><a href=\"https://gcc.godbolt.org/z/xrsM84\">https://gcc.godbolt.org/z/xrsM84</a></p>",
        "id": 226684404,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613579540
    },
    {
        "content": "<p>and if you actually provide that symbol, it will use it!</p>",
        "id": 226684430,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613579553
    },
    {
        "content": "<p>obviously that's not actually a round function, but it's a good proof of concept that it can be overridden!</p>",
        "id": 226684489,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613579573
    },
    {
        "content": "<p>Uhhh, tourist question here - but do we have pros/cons of the different vector libraries? Does LLVM not support the Agner Fog one?</p>",
        "id": 226684643,
        "sender_full_name": "Miguel Raz Guzmn Macedo",
        "timestamp": 1613579624
    },
    {
        "content": "<p>these vector libraries are not intended for direct user access, really, they're intended for the compiler to call to implement things like libc</p>",
        "id": 226684848,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613579693
    },
    {
        "content": "<p>agner fog's library is something to help users, not compilers (and presumably builds on top of whatever the compiler does, which may include using these libraries)</p>",
        "id": 226684923,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613579732
    },
    {
        "content": "<p>in terms of different vector libraries svml is a very popular one</p>",
        "id": 226685039,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613579769
    },
    {
        "content": "<p>but it's a vendor library from Intel</p>",
        "id": 226685072,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613579780
    },
    {
        "content": "<p>libmvec is probably the most appropriate for us (though I think we could actually use Accelerate on macOS)</p>",
        "id": 226685147,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613579810
    },
    {
        "content": "<p>maybe I'm being too optimistic but I think we may be able to avoid a compiler PR altogether if there's a way to access that LLVM option from cargo! but if not we can PR the compiler to add it...</p>",
        "id": 226685370,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613579900
    },
    {
        "content": "<p>and we can start a libmvec crate in the stdsimd repo that we include to provide the intrinsics</p>",
        "id": 226685481,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613579945
    },
    {
        "content": "<p>cautiously optimistic</p>",
        "id": 226685529,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613579963
    },
    {
        "content": "<p>ooh there is in fact <code>-C llvm-args=</code> which we can add to a <code>.cargo/config</code></p>",
        "id": 226686308,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613580249
    },
    {
        "content": "<p>FWIW ... Julia did end up writing a julia version of libm because of similar issues</p>",
        "id": 226690972,
        "sender_full_name": "Miguel Raz Guzmn Macedo",
        "timestamp": 1613581933
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/The.20libm.20problem/near/226686308\">said</a>:</p>\n<blockquote>\n<p>ooh there is in fact <code>-C llvm-args=</code> which we can add to a <code>.cargo/config</code></p>\n</blockquote>\n<p>If it's required for good performance we should try to make it more automatic than .cargo/config. </p>\n<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/The.20libm.20problem/near/226685481\">said</a>:</p>\n<blockquote>\n<p>and we can start a libmvec crate in the stdsimd repo that we include to provide the intrinsics</p>\n</blockquote>\n<p>I'm in favor of this for several reasons, but largerly: it would help kick the tires using the API in a plausible setting that it should be complete enough to support.</p>",
        "id": 226691079,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1613581972
    },
    {
        "content": "<p>I agree it should maybe be marginally more automatic? But as it currently stands only stdsimd will really be capable of generating calls to libmvec in the first place.</p>",
        "id": 226691299,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613582047
    },
    {
        "content": "<p>those flags would need to be present in the <code>.cargo/config</code>/<code>RUSTFLAGS</code> of the builder, so the fact that we're the ones that generate the calls doesn't really make a difference.</p>",
        "id": 226691697,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1613582215
    },
    {
        "content": "<p>Does cargo not use that for dependencies?  In that case we will need to handle it when building core</p>",
        "id": 226691788,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613582254
    },
    {
        "content": "<p>yeah only the end-user (well, the builders) <code>.cargo/config</code> is used</p>",
        "id": 226691931,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1613582306
    },
    {
        "content": "<p>Gotcha</p>",
        "id": 226691964,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613582321
    },
    {
        "content": "<p>(its intentionally not supported to have dependencies modify it)</p>",
        "id": 226692025,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1613582349
    },
    {
        "content": "<p>On an unrelated topic, libmvec doesn't provide rounding, so rounding will use libm no matter what unless we bring our own vector lib to LLVM</p>",
        "id": 226692075,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613582375
    },
    {
        "content": "<p>So, problem 0:<br>\n  core must compile without any non-Rust dependencies</p>",
        "id": 226703630,
        "sender_full_name": "Jubilee",
        "timestamp": 1613586803
    },
    {
        "content": "<p>that's a \"minor\" code writing issue</p>",
        "id": 226703855,
        "sender_full_name": "Lokathor",
        "timestamp": 1613586885
    },
    {
        "content": "<p>1: core is precompiled for a target, and that code is then taken and inserted into Rust compilation, so if our crate gets pushed into core, we have to recompile it, effectively, in order to insert code for different features.</p>",
        "id": 226704520,
        "sender_full_name": "Jubilee",
        "timestamp": 1613587150
    },
    {
        "content": "<p>This code is only fallback code, it doesn't use any target features</p>",
        "id": 226704614,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613587195
    },
    {
        "content": "<p>LLVM will use the correct instruction instead of libm if it is possible</p>",
        "id": 226704690,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613587214
    },
    {
        "content": "<p>what is \"this\"</p>",
        "id": 226704694,
        "sender_full_name": "Jubilee",
        "timestamp": 1613587215
    },
    {
        "content": "<p>I am not an OO programmer</p>",
        "id": 226704700,
        "sender_full_name": "Jubilee",
        "timestamp": 1613587219
    },
    {
        "content": "<p>I do not remember what \"this\" is.</p>",
        "id": 226704706,
        "sender_full_name": "Jubilee",
        "timestamp": 1613587223
    },
    {
        "content": "<p>libm/libmvec</p>",
        "id": 226704711,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613587226
    },
    {
        "content": "<p>Also I think the intention is to write the ~5 libmvec functions in rust</p>",
        "id": 226704760,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613587258
    },
    {
        "content": "<p>I have no intentions yet.</p>",
        "id": 226704789,
        "sender_full_name": "Jubilee",
        "timestamp": 1613587276
    },
    {
        "content": "<p>The intention of my plan I am exploring, I mean</p>",
        "id": 226704814,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613587291
    },
    {
        "content": "<p>And I do not believe that is what is happening, I believe what LLVM is doing is taking rustc's emitted LLVM instructions which it then resolves to different compilations based on what options are available, and that one of those compilations is to resolve the LLVM instructions into libm calls.</p>",
        "id": 226704859,
        "sender_full_name": "Jubilee",
        "timestamp": 1613587318
    },
    {
        "content": "<p>I am, for the moment, setting aside libmvec.</p>",
        "id": 226704937,
        "sender_full_name": "Jubilee",
        "timestamp": 1613587333
    },
    {
        "content": "<p>Or well, I will get to it in a moment from now, I want to understand the problem fully before jumping into any solutions.</p>",
        "id": 226704975,
        "sender_full_name": "Jubilee",
        "timestamp": 1613587352
    },
    {
        "content": "<p>I don't believe that's what's happening</p>",
        "id": 226705041,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613587383
    },
    {
        "content": "<p>But go on</p>",
        "id": 226705075,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613587401
    },
    {
        "content": "<p>Please explain to me what you think the rustc+LLVM compilation model is for this, then.</p>",
        "id": 226705121,
        "sender_full_name": "Jubilee",
        "timestamp": 1613587423
    },
    {
        "content": "<p>I explored this entirely in llc from LLVM IR to asm, no rustc involved</p>",
        "id": 226705290,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613587484
    },
    {
        "content": "<p><em>nods</em></p>",
        "id": 226705315,
        "sender_full_name": "Jubilee",
        "timestamp": 1613587497
    },
    {
        "content": "<p>LLVM is lowering instructions to asm, let's choose sin as an example</p>",
        "id": 226705330,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613587502
    },
    {
        "content": "<p>If you have the appropriate feature it will use the hardware instruction for sin</p>",
        "id": 226705366,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613587519
    },
    {
        "content": "<p>If you do not it will use libm (or libmvec, if you have that enabled)</p>",
        "id": 226705399,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613587537
    },
    {
        "content": "<p>That is what I thought, where do you think my explanation differs?</p>",
        "id": 226705443,
        "sender_full_name": "Jubilee",
        "timestamp": 1613587552
    },
    {
        "content": "<p>Reading again I think I maybe misunderstood, you meant \"potential compilations\" not actual compilations?</p>",
        "id": 226705588,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613587602
    },
    {
        "content": "<p>Yes.</p>",
        "id": 226705601,
        "sender_full_name": "Jubilee",
        "timestamp": 1613587609
    },
    {
        "content": "<p>Okay then nevermind, yes I think we're on the same page</p>",
        "id": 226705641,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613587633
    },
    {
        "content": "<p>What do you mean by problem 1? 0 I understand</p>",
        "id": 226706225,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613587868
    },
    {
        "content": "<p>My understanding is that much of the problem is that when we ship std, we ship assembly code that can be reused during compile and link time, so if we ship core for x86_64, it will have been compiled for SSE2, and so an invocation using SSE4 as a target feature would either link SSE2 code or require rebuilding std.</p>",
        "id": 226706653,
        "sender_full_name": "Jubilee",
        "timestamp": 1613588041
    },
    {
        "content": "<p>And really I mean \"libstd\" which is the entirety of<br>\ncore<br>\nalloc<br>\nstd<br>\nand possibly other things.</p>",
        "id": 226706805,
        "sender_full_name": "Jubilee",
        "timestamp": 1613588100
    },
    {
        "content": "<p>I actually personally think that's not the problem. I think that's a problem with a particular workaround</p>",
        "id": 226706891,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613588136
    },
    {
        "content": "<p>std etc <em>should</em> only be built for the base features</p>",
        "id": 226706968,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613588163
    },
    {
        "content": "<p>Nonetheless, it is a <strong>constraint</strong></p>",
        "id": 226707029,
        "sender_full_name": "Jubilee",
        "timestamp": 1613588182
    },
    {
        "content": "<p>Agreed</p>",
        "id": 226707046,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613588190
    },
    {
        "content": "<p>Well</p>",
        "id": 226707059,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613588194
    },
    {
        "content": "<p>Many of these are problems that only defeat or require rerouting of \"naive\" solutions.</p>",
        "id": 226707110,
        "sender_full_name": "Jubilee",
        "timestamp": 1613588213
    },
    {
        "content": "<p>I would argue that it's only a constraint to certain types of code.  Inline intrinsics get passed to codegen and don't suffer from that</p>",
        "id": 226707130,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613588221
    },
    {
        "content": "<p>Go on?</p>",
        "id": 226707163,
        "sender_full_name": "Jubilee",
        "timestamp": 1613588238
    },
    {
        "content": "<p>Well it's everything we're already relying on. <code>simd_add</code> lowers to LLVM <code>fadd</code>, and we mark <code>Add::add</code> inline so codegen occurs outside of <code>core</code></p>",
        "id": 226707349,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613588308
    },
    {
        "content": "<p>Is that as simple as #[inline]?</p>",
        "id": 226707399,
        "sender_full_name": "Jubilee",
        "timestamp": 1613588329
    },
    {
        "content": "<p>So <code>fadd</code> is free to lower to the appropriate target features</p>",
        "id": 226707411,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613588334
    },
    {
        "content": "<p>Yep.</p>",
        "id": 226707423,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613588337
    },
    {
        "content": "<p>Inline basically says that MIR ends up in the crate instead of asm</p>",
        "id": 226707464,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613588349
    },
    {
        "content": "<p>...so this is not a problem at all except that it pushes us out of core?</p>",
        "id": 226707472,
        "sender_full_name": "Jubilee",
        "timestamp": 1613588351
    },
    {
        "content": "<p>Well, no, there are the issues Lokathor mentioned.</p>",
        "id": 226707542,
        "sender_full_name": "Jubilee",
        "timestamp": 1613588377
    },
    {
        "content": "<p>Well there's also the performance concern as well</p>",
        "id": 226707550,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613588383
    },
    {
        "content": "<p>Right, so, problem 2: this is suck-ass bullshit when it comes to speed of execution.</p>",
        "id": 226707738,
        "sender_full_name": "Jubilee",
        "timestamp": 1613588447
    },
    {
        "content": "<p>It's actually not <em>that</em> bad as far as I can tell</p>",
        "id": 226707966,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613588526
    },
    {
        "content": "<p>For f64 it's probably only 2x slower</p>",
        "id": 226708006,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613588543
    },
    {
        "content": "<p>and f32s?</p>",
        "id": 226708021,
        "sender_full_name": "Jubilee",
        "timestamp": 1613588551
    },
    {
        "content": "<p>Which of course I want fixed</p>",
        "id": 226708023,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613588552
    },
    {
        "content": "<p>Nonetheless, a \"pessimized\" SSE2 vector implementation for many things which <strong>do not</strong> have dedicated hardware instructions can still handily defeat the scalar libm calls in many cases.</p>",
        "id": 226708035,
        "sender_full_name": "Jubilee",
        "timestamp": 1613588556
    },
    {
        "content": "<p>4x for f32</p>",
        "id": 226708037,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613588557
    },
    {
        "content": "<p>4x is really bad.</p>",
        "id": 226708054,
        "sender_full_name": "Jubilee",
        "timestamp": 1613588565
    },
    {
        "content": "<p>It's not nearly as bad as the 100x+ worse performance you'll get using AVX</p>",
        "id": 226708102,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613588584
    },
    {
        "content": "<p>is it really 100x</p>",
        "id": 226708150,
        "sender_full_name": "Jubilee",
        "timestamp": 1613588594
    },
    {
        "content": "<p>have we benched it.</p>",
        "id": 226708162,
        "sender_full_name": "Jubilee",
        "timestamp": 1613588597
    },
    {
        "content": "<p>Fwiw I want both fixed and I think that's doable</p>",
        "id": 226708163,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613588597
    },
    {
        "content": "<p>Yes</p>",
        "id": 226708167,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613588599
    },
    {
        "content": "<p>Okay, you've benched it?</p>",
        "id": 226708182,
        "sender_full_name": "Jubilee",
        "timestamp": 1613588606
    },
    {
        "content": "<p>Can I see the code, please?</p>",
        "id": 226708190,
        "sender_full_name": "Jubilee",
        "timestamp": 1613588609
    },
    {
        "content": "<p>I am fully 100% prepared to believe you, I am not even doubting, I just want to be able to put all these ducks in a row.</p>",
        "id": 226708334,
        "sender_full_name": "Jubilee",
        "timestamp": 1613588646
    },
    {
        "content": "<p>No but I can explain it pretty simply I think.  roundps/vroundps is 1x throughput, 8 cycle latency which is pretty standard for a floating point instruction</p>",
        "id": 226708397,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613588672
    },
    {
        "content": "<p>About the same as a single addition</p>",
        "id": 226708443,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613588689
    },
    {
        "content": "<p>Okay okay no, sorry, I should be precise:<br>\nI believe <strong>you</strong>, and your experience, but I do not believe x86.</p>",
        "id": 226708492,
        "sender_full_name": "Jubilee",
        "timestamp": 1613588708
    },
    {
        "content": "<p>If you look at an implementation for libc round it's dramatically more instructions than a single float op</p>",
        "id": 226708549,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613588730
    },
    {
        "content": "<p>Well yes, but all those get shredded into micro-ops.</p>",
        "id": 226708597,
        "sender_full_name": "Jubilee",
        "timestamp": 1613588749
    },
    {
        "content": "<p>The numbers for throughput and latency are the microops actually</p>",
        "id": 226708621,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613588761
    },
    {
        "content": "<p>The throughput is related to the number of load ports and the latency is how long the microops take</p>",
        "id": 226708696,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613588780
    },
    {
        "content": "<p>And the latency thing varies from chip to chip, which is why I want benches so I can run them on my computer or someone else's computer.</p>",
        "id": 226708699,
        "sender_full_name": "Jubilee",
        "timestamp": 1613588782
    },
    {
        "content": "<p>note that libmvec can be used via llvm autovectorization, as in the following example:<br>\n<a href=\"https://gcc.godbolt.org/z/qPrW9v\">https://gcc.godbolt.org/z/qPrW9v</a></p>",
        "id": 226708809,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1613588824
    },
    {
        "content": "<p>Agreed but my point is even if the latency was like 30, which is ridiculous, it's still much much faster than an SSE2 implementation</p>",
        "id": 226708851,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613588838
    },
    {
        "content": "<p>I know, I just want to know actual proportions.</p>",
        "id": 226708928,
        "sender_full_name": "Jubilee",
        "timestamp": 1613588866
    },
    {
        "content": "<p>The throughput alone will limit you to dozens of cycles, discounting the latency</p>",
        "id": 226708938,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613588869
    },
    {
        "content": "<p>As opposed to \"x100, spitballing\"</p>",
        "id": 226708949,
        "sender_full_name": "Jubilee",
        "timestamp": 1613588872
    },
    {
        "content": "<p>Well I looked at the implementations of a few libcs and it's dozens of ops</p>",
        "id": 226709047,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613588896
    },
    {
        "content": "<p>And all float ops other than like sqrt are approximately the same</p>",
        "id": 226709201,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613588960
    },
    {
        "content": "<p>abs</p>",
        "id": 226709288,
        "sender_full_name": "Jubilee",
        "timestamp": 1613588993
    },
    {
        "content": "<p>I remember that one.</p>",
        "id": 226709309,
        "sender_full_name": "Jubilee",
        "timestamp": 1613589002
    },
    {
        "content": "<p>SSE doesn't have abs, you just mask off the sign bit</p>",
        "id": 226709463,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613589039
    },
    {
        "content": "<p>Unless that's what you mean</p>",
        "id": 226709478,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613589046
    },
    {
        "content": "<p>4x and 100x are both made up numbers until we bench. either number could be worse. i suspect in practice sse2 is actually worse than a 4x loss because there's a pipelining loss too, which incidentally won't show up in simple benchmarks that don't have a pipeline of work.</p>",
        "id": 226709653,
        "sender_full_name": "Lokathor",
        "timestamp": 1613589109
    },
    {
        "content": "<p>yes.</p>",
        "id": 226709761,
        "sender_full_name": "Jubilee",
        "timestamp": 1613589138
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"GAS\"><pre><span></span><code><span class=\"nl\">example:</span><span class=\"err\">:</span><span class=\"nl\">f32x4:</span><span class=\"err\">:</span><span class=\"nl\">abs:</span>\n        <span class=\"nf\">movq</span>    <span class=\"nv\">%rdi</span><span class=\"p\">,</span> <span class=\"nv\">%rax</span>\n        <span class=\"nf\">movaps</span>  <span class=\"p\">(</span><span class=\"nv\">%rsi</span><span class=\"p\">),</span> <span class=\"nv\">%xmm0</span>\n        <span class=\"nf\">andps</span>   <span class=\"no\">.LCPI13_0</span><span class=\"p\">(</span><span class=\"nv\">%rip</span><span class=\"p\">),</span> <span class=\"nv\">%xmm0</span>\n        <span class=\"nf\">movaps</span>  <span class=\"nv\">%xmm0</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"nv\">%rdi</span><span class=\"p\">)</span>\n        <span class=\"nf\">retq</span>\n</code></pre></div>",
        "id": 226709790,
        "sender_full_name": "Jubilee",
        "timestamp": 1613589152
    },
    {
        "content": "<p>Yeah, that's kind of why I didn't want to benchmark</p>",
        "id": 226709795,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613589155
    },
    {
        "content": "<p>It's exceptionally difficult to make a good one</p>",
        "id": 226709816,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613589165
    },
    {
        "content": "<p>Correct.<br>\nBut even an acceptable microbenchmark would put us on more solid footing.</p>",
        "id": 226709934,
        "sender_full_name": "Jubilee",
        "timestamp": 1613589207
    },
    {
        "content": "<p>Fwiw all float ops in SSE have a throughput of 1 so the number of operations is a lower bound on the performance, not an upper bound</p>",
        "id": 226710091,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613589269
    },
    {
        "content": "<p>The data dependencies will only increase it due to the latencies</p>",
        "id": 226710130,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613589286
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"229517\">@Jacob Lifshay</span> Interesting.</p>",
        "id": 226710358,
        "sender_full_name": "Jubilee",
        "timestamp": 1613589364
    },
    {
        "content": "<p>note that rounding is actually cheapish: <a href=\"https://github.com/Lokathor/wide/blob/main/src/f32x4_.rs#L473\">https://github.com/Lokathor/wide/blob/main/src/f32x4_.rs#L473</a></p>",
        "id": 226710452,
        "sender_full_name": "Lokathor",
        "timestamp": 1613589414
    },
    {
        "content": "<p>i mean it's not \"1\" but it's fairly cheap</p>",
        "id": 226710478,
        "sender_full_name": "Lokathor",
        "timestamp": 1613589425
    },
    {
        "content": "<p>All of those blends are fairly expensive with SSE2.</p>",
        "id": 226710676,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613589502
    },
    {
        "content": "<p>Lovely, it seems someone has built a library that we can conveniently use for testing at least a few of our theories about performance.</p>",
        "id": 226710686,
        "sender_full_name": "Jubilee",
        "timestamp": 1613589505
    },
    {
        "content": "<p>It is one blend ;p</p>",
        "id": 226710759,
        "sender_full_name": "Lokathor",
        "timestamp": 1613589540
    },
    {
        "content": "<p>Oh I misread, I was looking at the lower part</p>",
        "id": 226710821,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613589570
    },
    {
        "content": "<p>and it comes out to like 4 bit ops</p>",
        "id": 226710825,
        "sender_full_name": "Lokathor",
        "timestamp": 1613589571
    },
    {
        "content": "<p>You are converting to integer and back?</p>",
        "id": 226710853,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613589584
    },
    {
        "content": "<p>yes with that specific op it's specified to do the right thing</p>",
        "id": 226710962,
        "sender_full_name": "Lokathor",
        "timestamp": 1613589608
    },
    {
        "content": "<p>Even nans?</p>",
        "id": 226711299,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613589753
    },
    {
        "content": "<p>Also it definitely results in a pipeline stall</p>",
        "id": 226711330,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613589767
    },
    {
        "content": "<p>well, yeah some stalling</p>",
        "id": 226711596,
        "sender_full_name": "Lokathor",
        "timestamp": 1613589885
    },
    {
        "content": "<p>less though</p>",
        "id": 226711611,
        "sender_full_name": "Lokathor",
        "timestamp": 1613589893
    },
    {
        "content": "<p>nan i forget</p>",
        "id": 226711633,
        "sender_full_name": "Lokathor",
        "timestamp": 1613589902
    },
    {
        "content": "<p>there's probably tests in there that nan stays nan</p>",
        "id": 226711666,
        "sender_full_name": "Lokathor",
        "timestamp": 1613589916
    },
    {
        "content": "<p>maybe</p>",
        "id": 226711734,
        "sender_full_name": "Lokathor",
        "timestamp": 1613589945
    },
    {
        "content": "<p>i haven't worked on the lib actively in over a year since there wasn't much new to do with it</p>",
        "id": 226711818,
        "sender_full_name": "Lokathor",
        "timestamp": 1613589968
    },
    {
        "content": "<p>Okay looks like they throw a fpe, so it needs to be masked off and handled separately, perhaps</p>",
        "id": 226712172,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613590137
    },
    {
        "content": "<p>So the other issue I have with this is that AVX512 at least has merged add and round instructions that you lose access to</p>",
        "id": 226712373,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613590217
    },
    {
        "content": "<p>Not just add, various arithmetic ops</p>",
        "id": 226712521,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613590275
    },
    {
        "content": "<p>...Alright?</p>",
        "id": 226712646,
        "sender_full_name": "Jubilee",
        "timestamp": 1613590331
    },
    {
        "content": "<p>will LLVM even emit those if you give it a sequenced add and round?</p>",
        "id": 226712900,
        "sender_full_name": "Jubilee",
        "timestamp": 1613590460
    },
    {
        "content": "<p>I don't see why not, it already merges mask operations</p>",
        "id": 226712953,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613590497
    },
    {
        "content": "<p>regardless, any software solutions we'd want would only be emitted for cases where we don't have higher-level target features.</p>",
        "id": 226713254,
        "sender_full_name": "Jubilee",
        "timestamp": 1613590608
    },
    {
        "content": "<p>That's only if we use the intrinsic and fix it in LLVM, no?</p>",
        "id": 226713482,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613590702
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> Okay, can you explain as much as you know about how compiler-builtins and rustlibm works?</p>",
        "id": 226714358,
        "sender_full_name": "Jubilee",
        "timestamp": 1613591099
    },
    {
        "content": "<p>so compiler-builtins is built and linked as part of the core build process and it provides junk llvm expects you to have like memcpy and software division and whatever. it's deliberately conservative about what it offers so as to avoid clashing with other software you might link.</p>",
        "id": 226714610,
        "sender_full_name": "Lokathor",
        "timestamp": 1613591201
    },
    {
        "content": "<p>How do compiler builtins work, basically? I am realizing I have an inadequate knowledge of it.</p>",
        "id": 226714627,
        "sender_full_name": "Jubilee",
        "timestamp": 1613591210
    },
    {
        "content": "<p><em>nods</em></p>",
        "id": 226714635,
        "sender_full_name": "Jubilee",
        "timestamp": 1613591213
    },
    {
        "content": "<p>on some targets (eg: wasm) portions of the rust libm crate are built and linked</p>",
        "id": 226714675,
        "sender_full_name": "Lokathor",
        "timestamp": 1613591231
    },
    {
        "content": "<p>via git sub-module and direct inclusion of source files, not via building the whole crate and linking it \"normally\"</p>",
        "id": 226714728,
        "sender_full_name": "Lokathor",
        "timestamp": 1613591266
    },
    {
        "content": "<p>it's \"just a library\", but it provides some weird stuff that often has names starting with two underscores</p>",
        "id": 226714848,
        "sender_full_name": "Lokathor",
        "timestamp": 1613591305
    },
    {
        "content": "<p>@ketsuban and i once had to submit a division routine because you could sometimes have that emitted on the gba and compiler-builtins didn't already have it (we were \"luckily\" some of the first people to be building rust for a CPU without an integer division instruction)</p>",
        "id": 226715027,
        "sender_full_name": "Lokathor",
        "timestamp": 1613591391
    },
    {
        "content": "<p>amazing</p>",
        "id": 226715105,
        "sender_full_name": "Jubilee",
        "timestamp": 1613591415
    },
    {
        "content": "<p>so basically it does... text expansion?</p>",
        "id": 226715175,
        "sender_full_name": "Jubilee",
        "timestamp": 1613591446
    },
    {
        "content": "<p>it's... more like a macro than building in MIR or ASM?</p>",
        "id": 226715210,
        "sender_full_name": "Jubilee",
        "timestamp": 1613591462
    },
    {
        "content": "<p>it's rust functions</p>",
        "id": 226715221,
        "sender_full_name": "Lokathor",
        "timestamp": 1613591467
    },
    {
        "content": "<p>hm</p>",
        "id": 226715240,
        "sender_full_name": "Jubilee",
        "timestamp": 1613591476
    },
    {
        "content": "<p>like, just rust code basically</p>",
        "id": 226715249,
        "sender_full_name": "Lokathor",
        "timestamp": 1613591481
    },
    {
        "content": "<p>and it exposes unmangled symbols llvm expects will exist sometimes</p>",
        "id": 226715288,
        "sender_full_name": "Lokathor",
        "timestamp": 1613591500
    },
    {
        "content": "<p>(which for the record is more or less how we would handle libmvec, I think)</p>",
        "id": 226715392,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613591534
    },
    {
        "content": "<p>the two things to keep in mind are:<br>\n1) if you can show you really need it they're pretty cool with adding new stuff<br>\n2) you gotta be careful about not exporting an unmangled symbol too often because of possible clashes</p>",
        "id": 226715396,
        "sender_full_name": "Lokathor",
        "timestamp": 1613591536
    },
    {
        "content": "<p>well, <em>accepting</em> new stuff. you do the PR they merge it, they don't just make code for you ;p</p>",
        "id": 226715473,
        "sender_full_name": "Lokathor",
        "timestamp": 1613591571
    },
    {
        "content": "<p>Okay, and <span class=\"user-mention\" data-user-id=\"312331\">@Caleb Zulawski</span>, does libmvec address problem 0 or? I am not sure what it actually gives us.</p>",
        "id": 226715523,
        "sender_full_name": "Jubilee",
        "timestamp": 1613591597
    },
    {
        "content": "<p>lunch over, I'll check back later</p>",
        "id": 226715524,
        "sender_full_name": "Lokathor",
        "timestamp": 1613591597
    },
    {
        "content": "<p>It gives us two things, if we write it in pure rust it gives us those functions in core. It also gives us improved performance in the base case</p>",
        "id": 226715674,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613591657
    },
    {
        "content": "<p>I do think we need to consider those problems separately. I personally think performance is the much more important issue and the float-in-core problem is broader than just stdsimd</p>",
        "id": 226715753,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613591696
    },
    {
        "content": "<p>(i was secretly hoping we wouldn't hit this and we could just backdoor floats into core <em>via</em> stdsimd)</p>",
        "id": 226715870,
        "sender_full_name": "Lokathor",
        "timestamp": 1613591739
    },
    {
        "content": "<p>(also Problem 0 is a great indie game title if ever there was)</p>",
        "id": 226715981,
        "sender_full_name": "Lokathor",
        "timestamp": 1613591771
    },
    {
        "content": "<p>Also I just did a totally scientific survey of well known SIMD-using crates and all of the ones I saw (memchr, aho_corasick, ppv-lite86) used the target_feature attribute</p>",
        "id": 226716084,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613591816
    },
    {
        "content": "<p>Alright.<br>\nI just want to understand everything as much as possible at the moment, we have... a few problems, and we have a few solutions, and different members of the set of solutions address different members of the set of problems, often only actually doing so in concert (i.e. as multiple members of a subset).</p>",
        "id": 226716086,
        "sender_full_name": "Jubilee",
        "timestamp": 1613591816
    },
    {
        "content": "<p>Okay, so, my understanding is that target_feature is a couple things.<br>\nOne is <code>#[target_feature(enable)]</code>.<br>\nand one is <code>#[cfg(target_feature)]</code>.</p>",
        "id": 226716289,
        "sender_full_name": "Jubilee",
        "timestamp": 1613591896
    },
    {
        "content": "<p>So personally I would like to see an argument <em>against</em> using libmvec since that appears to be the direction llvm (and therefore clang) is going</p>",
        "id": 226716295,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613591900
    },
    {
        "content": "<p>here's one: we're not llvm! what about cranelift?</p>",
        "id": 226716351,
        "sender_full_name": "Jubilee",
        "timestamp": 1613591924
    },
    {
        "content": "<p>Sure I meant specifically the attribute, not the cfg value</p>",
        "id": 226716360,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613591927
    },
    {
        "content": "<p>Well frankly that's another reason to use libmvec imo, cranelift can call it as well and get the same performance</p>",
        "id": 226716435,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613591962
    },
    {
        "content": "<p>Well what we really want is to static link to libmvec, don't we?</p>",
        "id": 226716473,
        "sender_full_name": "Jubilee",
        "timestamp": 1613591983
    },
    {
        "content": "<p>Or are you including that.</p>",
        "id": 226716506,
        "sender_full_name": "Jubilee",
        "timestamp": 1613592000
    },
    {
        "content": "<p>Yes. Also to be clear I'm proposing writing our own libmvec, not using GNU</p>",
        "id": 226716579,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613592012
    },
    {
        "content": "<p>Okay.<br>\nYeah I figured.</p>",
        "id": 226716605,
        "sender_full_name": "Jubilee",
        "timestamp": 1613592025
    },
    {
        "content": "<p>It's literally like 5 functions</p>",
        "id": 226716612,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613592028
    },
    {
        "content": "<p>e-z p-z</p>",
        "id": 226716627,
        "sender_full_name": "Jubilee",
        "timestamp": 1613592034
    },
    {
        "content": "<p>Okay, so rustlibm grows up and includes rustlibmvec.</p>",
        "id": 226716788,
        "sender_full_name": "Jubilee",
        "timestamp": 1613592122
    },
    {
        "content": "<p>separate crate feel better</p>",
        "id": 226716854,
        "sender_full_name": "Lokathor",
        "timestamp": 1613592139
    },
    {
        "content": "<p>Yeah more or less. Though I think maybe it belongs in a separate crate</p>",
        "id": 226716863,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613592144
    },
    {
        "content": "<p>yeah probably.</p>",
        "id": 226716865,
        "sender_full_name": "Jubilee",
        "timestamp": 1613592146
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 226716868,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613592148
    },
    {
        "content": "<p>So this doesn't specifically fix round, but it fixes the transcendental functions</p>",
        "id": 226717057,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613592241
    },
    {
        "content": "<p>Only because that's currently what LLVM supports</p>",
        "id": 226717111,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613592256
    },
    {
        "content": "<p>amusing.</p>",
        "id": 226717113,
        "sender_full_name": "Jubilee",
        "timestamp": 1613592257
    },
    {
        "content": "<p>I believe Rust has maintained LLVM patches before.</p>",
        "id": 226717231,
        "sender_full_name": "Jubilee",
        "timestamp": 1613592333
    },
    {
        "content": "<p>I think this is something that could be upstreamed anyway</p>",
        "id": 226717276,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613592350
    },
    {
        "content": "<p>yes.<br>\nI mostly mean I do not think it would be unreasonable to fix something now and upstream the patch.</p>",
        "id": 226717308,
        "sender_full_name": "Jubilee",
        "timestamp": 1613592362
    },
    {
        "content": "<p>so we do not have to wait an aeon.</p>",
        "id": 226717362,
        "sender_full_name": "Jubilee",
        "timestamp": 1613592377
    },
    {
        "content": "<p>rust patches llvm but only in ways that allow using unpatched llvm still</p>",
        "id": 226717370,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1613592381
    },
    {
        "content": "<p>would this qualify?</p>",
        "id": 226717392,
        "sender_full_name": "Jubilee",
        "timestamp": 1613592391
    },
    {
        "content": "<p>technically yes</p>",
        "id": 226717427,
        "sender_full_name": "Lokathor",
        "timestamp": 1613592404
    },
    {
        "content": "<p>probably depends how we do it</p>",
        "id": 226717437,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1613592408
    },
    {
        "content": "<p>Though I'm not actually positive libmvec provides rounding at all? If it does were good but but if it doesn't we may need to make our own vector lib (which I imagine would also be ok)</p>",
        "id": 226717446,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613592412
    },
    {
        "content": "<p>We could make LLVM aware that libmvec could offer <strong>six</strong> whole functions!</p>",
        "id": 226717522,
        "sender_full_name": "Jubilee",
        "timestamp": 1613592450
    },
    {
        "content": "<p>core simd relies on a core lib for simd that can't use core simd without causing compilation loops. success.</p>",
        "id": 226717530,
        "sender_full_name": "Lokathor",
        "timestamp": 1613592454
    },
    {
        "content": "<p>lol</p>",
        "id": 226717580,
        "sender_full_name": "Jubilee",
        "timestamp": 1613592479
    },
    {
        "content": "<p>ah right hm</p>",
        "id": 226717587,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1613592481
    },
    {
        "content": "<p>that is tricky</p>",
        "id": 226717641,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1613592493
    },
    {
        "content": "<p>ideally this would use core_simd so we could have the benefit of ensuring our API is good enough to implement something like this.</p>",
        "id": 226717695,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1613592526
    },
    {
        "content": "<p>My silly-tier proposal: what if we were our own crate alongside core and alloc and std? or does that not make it go away.</p>",
        "id": 226717701,
        "sender_full_name": "Jubilee",
        "timestamp": 1613592527
    },
    {
        "content": "<p>Because really, I don't care about landing in core as much as I want to be in <strong>rustc</strong>.</p>",
        "id": 226717885,
        "sender_full_name": "Jubilee",
        "timestamp": 1613592607
    },
    {
        "content": "<p>I don't think anything makes this go away other than fixing codegen.</p>",
        "id": 226718148,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613592738
    },
    {
        "content": "<p>I personally think this is absolutely something we can ignore before going into nightly and perhaps even stable</p>",
        "id": 226718201,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613592766
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> what is the compilation loop you are envisioning exactly?</p>",
        "id": 226718418,
        "sender_full_name": "Jubilee",
        "timestamp": 1613592845
    },
    {
        "content": "<p>well rust-lib-vec-m can't call f32x4::round in its round implementation</p>",
        "id": 226718655,
        "sender_full_name": "Lokathor",
        "timestamp": 1613592955
    },
    {
        "content": "<p>I think you would just take musl libm's implementation and make it vectorized?</p>",
        "id": 226718858,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613593049
    },
    {
        "content": "<p>yeah whatever we want to do there</p>",
        "id": 226718882,
        "sender_full_name": "Lokathor",
        "timestamp": 1613593066
    },
    {
        "content": "<p>But yeah no intrinsic there</p>",
        "id": 226718903,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613593080
    },
    {
        "content": "<p>we just can't have the code that comes out of an intrinsic call be itself an intrinsic call</p>",
        "id": 226718947,
        "sender_full_name": "Lokathor",
        "timestamp": 1613593086
    },
    {
        "content": "<p>if a call actually reaches lib vec m then we know that llvm already tried it's best; so we do whatever dumb obvious thing is required for the given op, base features only, etc etc</p>",
        "id": 226719086,
        "sender_full_name": "Lokathor",
        "timestamp": 1613593169
    },
    {
        "content": "<p>Agreed, it doesn't need to be great, just better than libm calls</p>",
        "id": 226719273,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613593263
    },
    {
        "content": "<p>So one question</p>",
        "id": 226719309,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613593281
    },
    {
        "content": "<p>Since gnu libmvec doesn't cover all of the functions we need, do we try to make our own vector lib and get it upstreamed into LLVM?</p>",
        "id": 226719359,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613593315
    },
    {
        "content": "<p>Another reason to do that is we can maintain the rust calling convention</p>",
        "id": 226719541,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613593391
    },
    {
        "content": "<p>rust calling convention isn't stable</p>",
        "id": 226719791,
        "sender_full_name": "Lokathor",
        "timestamp": 1613593514
    },
    {
        "content": "<p>we can teach llvm to use our lib, but it'd be the C abi</p>",
        "id": 226719829,
        "sender_full_name": "Lokathor",
        "timestamp": 1613593537
    },
    {
        "content": "<p>Yeah true.</p>",
        "id": 226719936,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613593572
    },
    {
        "content": "<p>I'm not sure about the ABI implications of passing vectors</p>",
        "id": 226719967,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613593592
    },
    {
        "content": "<p>Especially on non-x86_64 platforms</p>",
        "id": 226720008,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613593607
    },
    {
        "content": "<p>System V AMD64 ABI we should be able to pass vectors in registers just fine.</p>",
        "id": 226720425,
        "sender_full_name": "Jubilee",
        "timestamp": 1613593789
    },
    {
        "content": "<p>and __vectorcall should support extensive register use on x64 as well.</p>",
        "id": 226720614,
        "sender_full_name": "Jubilee",
        "timestamp": 1613593859
    },
    {
        "content": "<p>I'm more concerned about arm, aarch64, ppc, etc mostly because I don't know much about the calling conventions</p>",
        "id": 226720684,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613593900
    },
    {
        "content": "<p>the way you pass larger vectors would depend on your target_feature level if we use the C abi</p>",
        "id": 226720697,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1613593905
    },
    {
        "content": "<p>Yeah that's why I thought we may need to pass them by reference</p>",
        "id": 226720749,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613593923
    },
    {
        "content": "<p>Actually wait, the function were calling into is always the base feature level</p>",
        "id": 226720836,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613593953
    },
    {
        "content": "<p>we should be able to basically always pass using xmm registers on AMD64 though.</p>",
        "id": 226720850,
        "sender_full_name": "Jubilee",
        "timestamp": 1613593960
    },
    {
        "content": "<p>Unless the source function features matter</p>",
        "id": 226720858,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613593965
    },
    {
        "content": "<p>might have to load a ymm or zmm into multiple xmm regs</p>",
        "id": 226720928,
        "sender_full_name": "Jubilee",
        "timestamp": 1613593990
    },
    {
        "content": "<p>basic Windows ABI supports some xmm register usage</p>",
        "id": 226720956,
        "sender_full_name": "Jubilee",
        "timestamp": 1613594001
    },
    {
        "content": "<p>Remember you only have a few of them</p>",
        "id": 226720960,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613594003
    },
    {
        "content": "<p>correct.</p>",
        "id": 226720978,
        "sender_full_name": "Jubilee",
        "timestamp": 1613594011
    },
    {
        "content": "<p>i mean passing a f32x8 will use ymm if you have <code>target_feature=\"+avx\"</code>. Note that this is exactly this soundness hole: <a href=\"https://github.com/rust-lang/rust/issues/64609\">https://github.com/rust-lang/rust/issues/64609</a></p>",
        "id": 226721037,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1613594038
    },
    {
        "content": "<p>mmmhm.</p>",
        "id": 226721084,
        "sender_full_name": "Jubilee",
        "timestamp": 1613594046
    },
    {
        "content": "<p>hmm.</p>",
        "id": 226721087,
        "sender_full_name": "Jubilee",
        "timestamp": 1613594047
    },
    {
        "content": "<p>i think even passing 2 f32x4s will differ</p>",
        "id": 226721141,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1613594075
    },
    {
        "content": "<p>i dont really remember though, its been a while</p>",
        "id": 226721171,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1613594087
    },
    {
        "content": "<p>lib vec m would have to assume default feature level per target</p>",
        "id": 226721215,
        "sender_full_name": "Lokathor",
        "timestamp": 1613594107
    },
    {
        "content": "<p>so that at least lets us predict the calling convention</p>",
        "id": 226721253,
        "sender_full_name": "Lokathor",
        "timestamp": 1613594134
    },
    {
        "content": "<p>Yeah, I think it's not an issue since the features can't change</p>",
        "id": 226721284,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613594147
    },
    {
        "content": "<p>but that doesn't fix the caller's side necessarily</p>",
        "id": 226721290,
        "sender_full_name": "Lokathor",
        "timestamp": 1613594149
    },
    {
        "content": "<p>aarch64 (Armv8-A) is specified to always have Neon, and its ABI uses those Neon registers, last I checked.</p>",
        "id": 226721293,
        "sender_full_name": "Jubilee",
        "timestamp": 1613594149
    },
    {
        "content": "<p>soundness hole maybe still bites us</p>",
        "id": 226721375,
        "sender_full_name": "Lokathor",
        "timestamp": 1613594174
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/The.20libm.20problem/near/226719967\">said</a>:</p>\n<blockquote>\n<p>I'm not sure about the ABI implications of passing vectors</p>\n</blockquote>\n<p>The rust abi always passes vectors by-ref, unless you are on wasm.</p>",
        "id": 226721499,
        "sender_full_name": "bjorn3",
        "timestamp": 1613594233
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/blob/bb587b1a1737738658d2eaecd4c8c1cab555257a/compiler/rustc_middle/src/ty/layout.rs#L2854-L2879\">https://github.com/rust-lang/rust/blob/bb587b1a1737738658d2eaecd4c8c1cab555257a/compiler/rustc_middle/src/ty/layout.rs#L2854-L2879</a></p>",
        "id": 226721567,
        "sender_full_name": "bjorn3",
        "timestamp": 1613594267
    },
    {
        "content": "<p>that is awful.</p>",
        "id": 226721584,
        "sender_full_name": "Jubilee",
        "timestamp": 1613594274
    },
    {
        "content": "<p>As a bystander I can refer <a href=\"https://github.com/xtensor-stack/xsimd/tree/master\">xsimd</a> as another source of inspirations besides musl libm</p>",
        "id": 226721683,
        "sender_full_name": "Darley Barreto",
        "timestamp": 1613594303
    },
    {
        "content": "<p>I don't know if we can reference a BSD3 library.</p>",
        "id": 226721773,
        "sender_full_name": "Jubilee",
        "timestamp": 1613594355
    },
    {
        "content": "<p>There's some MIT code in Agner's vectorcall2</p>",
        "id": 226721795,
        "sender_full_name": "Jubilee",
        "timestamp": 1613594365
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/The.20libm.20problem/near/226721141\">said</a>:</p>\n<blockquote>\n<p>i think even passing 2 f32x4s will differ</p>\n</blockquote>\n<p>It won't because the start of each is SSE and not SSEUP. However, this does impact passing the larger vectors as mentioned.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"372321\">Darley Barreto</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/The.20libm.20problem/near/226721683\">said</a>:</p>\n<blockquote>\n<p>As a bystander I can refer <a href=\"https://github.com/xtensor-stack/xsimd/tree/master\">xsimd</a> as another source of inspirations besides musl libm</p>\n</blockquote>\n<p>SLEEF also exists (BSL though, unsure if we can use it): <a href=\"https://sleef.org/\">https://sleef.org/</a></p>",
        "id": 226722191,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1613594543
    },
    {
        "content": "<p><a href=\"https://github.com/agenium-scale/nsimd\">nsimd</a> is MIT's. But I've never heard about it before.</p>",
        "id": 226722551,
        "sender_full_name": "Darley Barreto",
        "timestamp": 1613594720
    },
    {
        "content": "<p>not a lawyer, but the take from the debian repo folks is that if you translate C to Rust you've made a derivative work but that's not the original source code any more, so unless there's license restrictions on derivative works then it's all cool.</p>\n<p>source: there's an open issue about it in the libm repo actually.</p>",
        "id": 226723120,
        "sender_full_name": "Lokathor",
        "timestamp": 1613594976
    },
    {
        "content": "<p>Just one more: <a href=\"https://github.com/aff3ct/MIPP/tree/master\">MIPP</a>, also MIT's</p>",
        "id": 226723394,
        "sender_full_name": "Darley Barreto",
        "timestamp": 1613595081
    },
    {
        "content": "<blockquote>\n<p>so unless there's license restrictions on derivative works</p>\n</blockquote>\n<p>By default derivative works will inherit the copyright (and thus the license) of the thing they derive from unless it's explicitly granted.</p>",
        "id": 226725157,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1613595801
    },
    {
        "content": "<p>not a lawyer, but that's my understanding</p>",
        "id": 226725206,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1613595824
    },
    {
        "content": "<p>soorta.</p>",
        "id": 226725844,
        "sender_full_name": "Jubilee",
        "timestamp": 1613596099
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/libm/issues/215\">https://github.com/rust-lang/libm/issues/215</a> I'm going by what i read here</p>",
        "id": 226725902,
        "sender_full_name": "Lokathor",
        "timestamp": 1613596127
    },
    {
        "content": "<p>notably:<br>\n<a href=\"https://alioth-lists.debian.net/pipermail/pkg-rust-maintainers/2020-February/009954.html\">https://alioth-lists.debian.net/pipermail/pkg-rust-maintainers/2020-February/009954.html</a></p>\n<p><a href=\"https://github.com/rust-lang/compiler-builtins/issues/307#issuecomment-592007706\">https://github.com/rust-lang/compiler-builtins/issues/307#issuecomment-592007706</a></p>",
        "id": 226726122,
        "sender_full_name": "Lokathor",
        "timestamp": 1613596215
    },
    {
        "content": "<p>Even GPL has a lot of untested legal aspects</p>",
        "id": 226726821,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613596514
    },
    {
        "content": "<p>It's still extremely unclear if you can static link against GPL from non GPL and distribute it</p>",
        "id": 226726873,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613596540
    },
    {
        "content": "<p>I agree that anything derivative from MIT is fine</p>",
        "id": 226726919,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613596562
    },
    {
        "content": "<p>we need the rust foundation to pay a lawyer to tell us the truth (you can't handle the truth)</p>",
        "id": 226727893,
        "sender_full_name": "Lokathor",
        "timestamp": 1613597022
    },
    {
        "content": "<p>toy vector truncf implementation I just wrote: <a href=\"https://gcc.godbolt.org/z/d9Gz49\">https://gcc.godbolt.org/z/d9Gz49</a></p>",
        "id": 226728390,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1613597247
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/The.20libm.20problem/near/226727893\">said</a>:</p>\n<blockquote>\n<p>we need the rust foundation to pay a lawyer to tell us the truth (you can't handle the truth)</p>\n</blockquote>\n<p>meanwhile <a href=\"https://tldrlegal.com/\">tldrlegal</a></p>",
        "id": 226731813,
        "sender_full_name": "Darley Barreto",
        "timestamp": 1613598843
    },
    {
        "content": "<p>i think this issue is unfortunately more nuanced than tldr can deal with.</p>",
        "id": 226734956,
        "sender_full_name": "Lokathor",
        "timestamp": 1613599801
    },
    {
        "content": "<p><a href=\"https://rosenlaw.com/oslbook.htm\">https://rosenlaw.com/oslbook.htm</a></p>",
        "id": 226735331,
        "sender_full_name": "scottmcm",
        "timestamp": 1613599902
    },
    {
        "content": "<p>Okay ,so if I understand correctly, the rustcall ABI does not use xmm registers to pass vectors, correct?</p>",
        "id": 226735861,
        "sender_full_name": "Jubilee",
        "timestamp": 1613600041
    },
    {
        "content": "<p>even on x86_64?</p>",
        "id": 226736247,
        "sender_full_name": "Jubilee",
        "timestamp": 1613600118
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> you've linked that before... does it actually cover the question here?</p>",
        "id": 226736265,
        "sender_full_name": "Lokathor",
        "timestamp": 1613600135
    },
    {
        "content": "<p>It talks quite a bit about what creates a derivative work, about how the FSF's definition of linking creating derivative works is untested, requirements for use of reciprocal/academic licenses, etc.  Not at all a TLDR -- it's a full O'Reily book -- but definitely relevant for someone trying to get an understanding of the issues.</p>",
        "id": 226737194,
        "sender_full_name": "scottmcm",
        "timestamp": 1613600578
    },
    {
        "content": "<p>we just need one question answered by a lawyer speaking lawyerly ;_; not another non-lawyer (eg: me) reading stuff and making a  non-lawyer judgement call</p>",
        "id": 226737347,
        "sender_full_name": "Lokathor",
        "timestamp": 1613600656
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/The.20libm.20problem/near/226735861\">said</a>:</p>\n<blockquote>\n<p>Okay ,so if I understand correctly, the rustcall ABI does not use xmm registers to pass vectors, correct?</p>\n</blockquote>\n<p>this seems like a bug we'd eventually want to fix, so i think we should probably not rely on this being the case forever</p>",
        "id": 226737493,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1613600750
    },
    {
        "content": "<p>but yes afaict this is true.</p>",
        "id": 226737688,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1613600857
    },
    {
        "content": "<p>The only way to fix it is to give target feature functions their own abi, I think</p>",
        "id": 226737852,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613600926
    },
    {
        "content": "<p>hm, yeah, i see</p>",
        "id": 226738121,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1613601066
    },
    {
        "content": "<p>which brings us back to the <em>soundness hole</em></p>",
        "id": 226738802,
        "sender_full_name": "Lokathor",
        "timestamp": 1613601405
    },
    {
        "content": "<p>OK but do they need them for things compiled to x86_64-unknown-linux-gnu w/o target features?</p>",
        "id": 226740815,
        "sender_full_name": "Jubilee",
        "timestamp": 1613602644
    },
    {
        "content": "<p>I'm just picking on SysV64 because MS has their own ABI and vectorcall ABI.</p>",
        "id": 226740921,
        "sender_full_name": "Jubilee",
        "timestamp": 1613602707
    },
    {
        "content": "<p>Alright, so, \"target_feature(enable)\" allows unconditional code generation, but the functions must be unsafe unless called from a function that itself has the \"target_feature(enable)\" annotation.</p>\n<p>And we have cfg on target features as well.<br>\n...Is there a reason we can't implicitly annotate functions compiled with <code>-Ctarget-feature=\"sse2\"</code> with <code>#[target_feature(enable=\"sse2\")]</code></p>",
        "id": 226747285,
        "sender_full_name": "Jubilee",
        "timestamp": 1613606655
    },
    {
        "content": "<p>Actually right now they're always unsafe, until target-features 1.1 lands, at which point it will be how you describe</p>",
        "id": 226747398,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613606736
    },
    {
        "content": "<p>Oh OK.</p>",
        "id": 226747479,
        "sender_full_name": "Jubilee",
        "timestamp": 1613606769
    },
    {
        "content": "<p>Right, OK, not implemented. JOY.</p>",
        "id": 226747487,
        "sender_full_name": "Jubilee",
        "timestamp": 1613606776
    },
    {
        "content": "<p>It is actually implemented! Just not stable yet</p>",
        "id": 226747513,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613606794
    },
    {
        "content": "<p>ah</p>",
        "id": 226747522,
        "sender_full_name": "Jubilee",
        "timestamp": 1613606799
    },
    {
        "content": "<p>Okay well stabilizing it doesn't matter atm tbh.</p>",
        "id": 226747538,
        "sender_full_name": "Jubilee",
        "timestamp": 1613606811
    },
    {
        "content": "<p>We're on nightly.</p>",
        "id": 226747549,
        "sender_full_name": "Jubilee",
        "timestamp": 1613606816
    },
    {
        "content": "<p>So the functions kind of do implicitly gain the global target features</p>",
        "id": 226747592,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613606858
    },
    {
        "content": "<p>It just doesn't get you anything</p>",
        "id": 226747598,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613606863
    },
    {
        "content": "<p>Well the <code>unsafe</code> part is fine.</p>",
        "id": 226747755,
        "sender_full_name": "Jubilee",
        "timestamp": 1613606958
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span> if a given target feature level is enabled at the build level (eg: <code>-Ctarget-feature=\"+avx\"</code>) it is <em>as if</em> every function you're building suddenly had <code>#[target_feature(enable=\"avx\")]</code> applied to it.</p>",
        "id": 226768764,
        "sender_full_name": "Lokathor",
        "timestamp": 1613628048
    },
    {
        "content": "<p>target feature enable turns on a target feature that wouldn't have been in the function's feature set based on the global build settings</p>",
        "id": 226768792,
        "sender_full_name": "Lokathor",
        "timestamp": 1613628082
    },
    {
        "content": "<p>but if the whole build has a given feature on, then they already all have that feature</p>",
        "id": 226768803,
        "sender_full_name": "Lokathor",
        "timestamp": 1613628098
    },
    {
        "content": "<p>except of course the standard library which is pre-compiled at a given feature set (and feature set mismatches can cause the <del>soundness hole</del> bonus behavior)</p>",
        "id": 226768873,
        "sender_full_name": "Lokathor",
        "timestamp": 1613628139
    },
    {
        "content": "<p>hmm.</p>",
        "id": 226774520,
        "sender_full_name": "Jubilee",
        "timestamp": 1613634141
    },
    {
        "content": "<p>Well, I just followed that rabbithole and enumerated the combination of hardware and software quirks as they apply to the System V AMD64 ABI for about 1200 words, as a prelude to mocking up a design for attacking the soundness problem.</p>",
        "id": 226904525,
        "sender_full_name": "Jubilee",
        "timestamp": 1613694310
    },
    {
        "content": "<p>1200 words is a pleasant walk in the park of an essay.</p>",
        "id": 226915409,
        "sender_full_name": "Lokathor",
        "timestamp": 1613704416
    },
    {
        "content": "<p>The greatly abbreviated version of it became this comment. <a href=\"https://github.com/rust-lang/rust/issues/64609#issuecomment-781833026\">https://github.com/rust-lang/rust/issues/64609#issuecomment-781833026</a><br>\nI believe I need to expand on it further though in order to like... assemble an MCP or RFC, whichever.</p>",
        "id": 226937996,
        "sender_full_name": "Jubilee",
        "timestamp": 1613726345
    },
    {
        "content": "<p>Are ABI decisions a T-compiler or T-lang issue?</p>",
        "id": 227009006,
        "sender_full_name": "Jubilee",
        "timestamp": 1613760480
    },
    {
        "content": "<p>lang</p>",
        "id": 227010271,
        "sender_full_name": "Lokathor",
        "timestamp": 1613760999
    },
    {
        "content": "<p>well, lang first, then compiler implements it once it's ratified</p>",
        "id": 227010323,
        "sender_full_name": "Lokathor",
        "timestamp": 1613761023
    },
    {
        "content": "<p>basically, if an alternate rust compiler would also need to abide by something to still be a rust compiler, it's lang</p>",
        "id": 227010406,
        "sender_full_name": "Lokathor",
        "timestamp": 1613761059
    },
    {
        "content": "<p>Hmm, does it matter if the rustcall ABI is still perma-unstable?</p>",
        "id": 227010564,
        "sender_full_name": "Jubilee",
        "timestamp": 1613761109
    },
    {
        "content": "<p>or does it \"matter\" because it would permanently tilt the rustcall ABI towards a given set of possibilities.</p>",
        "id": 227010616,
        "sender_full_name": "Jubilee",
        "timestamp": 1613761134
    },
    {
        "content": "<p>second one</p>",
        "id": 227010971,
        "sender_full_name": "Lokathor",
        "timestamp": 1613761279
    },
    {
        "content": "<p>Fair enough.</p>",
        "id": 227011055,
        "sender_full_name": "Jubilee",
        "timestamp": 1613761313
    },
    {
        "content": "<p>we can just ping <span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> , who would  effectively be our lang team liason for this project. i mean technically this is a libs project, yada yada, but based on their interest areas if you had to pick a lang member for liason, you'd pick joshT for this one.</p>",
        "id": 227011990,
        "sender_full_name": "Lokathor",
        "timestamp": 1613761672
    },
    {
        "content": "<p>So as much as that's a bug I want to be fixed, why exactly is this relevant to stdsimd?  Passing by reference, as unfortunate as it is, fixes the soundness hole afaik.  And for libmvec we don't have this problem since it's not the rust call ABI anyway</p>",
        "id": 227013023,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613762068
    },
    {
        "content": "<p>best as i can tell, like the libm problem itself, this isn't required to proceed with building programs <em>at all</em>, it's required to proceed with building programs <em>that perform well</em></p>",
        "id": 227013321,
        "sender_full_name": "Lokathor",
        "timestamp": 1613762173
    },
    {
        "content": "<p>So, on one hand<br>\nMaybe it's not.<br>\nOn the other, the future of how this is handled directly impacts us.<br>\nAnd the easiest way to predict that future is simply to make it.</p>",
        "id": 227013402,
        "sender_full_name": "Jubilee",
        "timestamp": 1613762211
    },
    {
        "content": "<p>Sure. I just want to make sure we're all on the same page that it's probably not necessary</p>",
        "id": 227013538,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613762268
    },
    {
        "content": "<p>In my experience most SIMD functions end up inlined anyway so I haven't personally hit this problem in rust (though I was aware of it)</p>",
        "id": 227013714,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613762329
    },
    {
        "content": "<p>Basically, our library has to make less guesses about what is forward compatible with possible Rust code and Rust compilers if we just start describing what we are being compatible with.</p>",
        "id": 227013736,
        "sender_full_name": "Jubilee",
        "timestamp": 1613762339
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/The.20libm.20problem/near/227010564\">said</a>:</p>\n<blockquote>\n<p>Hmm, does it matter if the rustcall ABI is still perma-unstable?</p>\n</blockquote>\n<p>If something is explicitly perma-unstable, like the <code>rustc_whatever</code> attributes, then it's a compiler decision, not a lang one.  Lang doesn't need cook-in-the-kitchen implementation choices, only things that affect exposed surface area.</p>",
        "id": 227014353,
        "sender_full_name": "scottmcm",
        "timestamp": 1613762582
    },
    {
        "content": "<p>Hmm. Is <code>extern \"Rust\"</code> explicitly perma-unstable, or is it considered exposed surface API?</p>",
        "id": 227014610,
        "sender_full_name": "Jubilee",
        "timestamp": 1613762665
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"312331\">@Caleb Zulawski</span> there's always a limit to how much you can inline, so at some point this will hit you because you have to have a real function call eventually</p>",
        "id": 227014780,
        "sender_full_name": "Lokathor",
        "timestamp": 1613762733
    },
    {
        "content": "<p>I don't think it's permanently unstable so much as there is very little desire to stabilize it and a bunch of arguments not to do it _yet_</p>",
        "id": 227014907,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613762770
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> sure but usually you aren't passing vectors at that point. Not to say no one ever passes vectors, I'm just not sure it's the most critical problem to address.</p>",
        "id": 227015051,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613762835
    },
    {
        "content": "<p>Not to say we can't or shouldn't but maybe not as the direction of the project group itself</p>",
        "id": 227015110,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613762859
    },
    {
        "content": "<p>I am not going to block forward progress on this, obviously, I am keenly aware of our limited scope, we just also, as it happens, have a lot of the people relevant for discussing solutions to this problem in this \"room\" anyways. We wound up discussing <em>patches to LLVM</em>, after all, which is pretty far afield of our nominal mission.</p>",
        "id": 227015661,
        "sender_full_name": "Jubilee",
        "timestamp": 1613763046
    },
    {
        "content": "<p>For what it's worth, if it was up to just me I probably wouldn't address the libm problem either <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> at least not yet</p>",
        "id": 227015951,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613763146
    },
    {
        "content": "<p>But yeah, as long as we don't block any progress on anything because of it, that's all I wanted to make sure of</p>",
        "id": 227016027,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613763177
    },
    {
        "content": "<p>nope, totally bullying you into writing C++ (no)</p>",
        "id": 227016044,
        "sender_full_name": "Jubilee",
        "timestamp": 1613763184
    },
    {
        "content": "<p>caleb has to rewrite all of llvm in rust before we can land this in Nightly</p>",
        "id": 227016201,
        "sender_full_name": "Lokathor",
        "timestamp": 1613763231
    },
    {
        "content": "<p>Fwiw if we need to PR LLVM into supporting a rust math vec lib I don't really mind lol</p>",
        "id": 227016319,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613763255
    },
    {
        "content": "<p>CARCINIZE THE DRAGON!</p>",
        "id": 227016394,
        "sender_full_name": "Jubilee",
        "timestamp": 1613763281
    },
    {
        "content": "<p>Honestly rather do that than deal with some gnu interface</p>",
        "id": 227016406,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613763286
    },
    {
        "content": "<p><span aria-label=\"dragon\" class=\"emoji emoji-1f409\" role=\"img\" title=\"dragon\">:dragon:</span> <span aria-label=\"crab\" class=\"emoji emoji-1f980\" role=\"img\" title=\"crab\">:crab:</span></p>",
        "id": 227016425,
        "sender_full_name": "Jubilee",
        "timestamp": 1613763294
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> I would highly recommend treating anything Rosen says with many grains of salt; he has an agenda to push.</p>",
        "id": 227017127,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613763552
    },
    {
        "content": "<p>I just read through and caught up on something like 700 messages in this thread.</p>",
        "id": 227017189,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613763583
    },
    {
        "content": "<p>A few initial thoughts:</p>",
        "id": 227017217,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613763597
    },
    {
        "content": "<p>Oh hi! Sorry about that lol, we uh... do not do small discussions over here, obviously.</p>",
        "id": 227017290,
        "sender_full_name": "Jubilee",
        "timestamp": 1613763612
    },
    {
        "content": "<p>Not a problem. :)</p>",
        "id": 227017322,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613763630
    },
    {
        "content": "<p>Would it make sense to arrange to ship whole compiled versions of core/std for multiple target features? We don't have to do multiversioning quite yet (though we should), we could more easily just ship half a dozen versions of std and pick one to link to based on target features.</p>",
        "id": 227017490,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613763709
    },
    {
        "content": "<p>Bonus if we could pick a different one's MIR for inlining into a specific function based on target features.</p>",
        "id": 227017650,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613763753
    },
    {
        "content": "<p>All that said, function multiversioning probably isn't that hard to implement in rustc. But this could be a simpler stopgap.</p>",
        "id": 227017753,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613763801
    },
    {
        "content": "<p>Regarding licensing, in general if you copy from a work you need to preserve the license and copyright notices of that work. But all permissive licenses are pretty much compatible with each other. Copying from 3-clause BSD or MIT or various others is fine, as long as you attribute it properly.</p>",
        "id": 227017941,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613763891
    },
    {
        "content": "<p>The amount of features can get pretty combinatoric there with x86. I wouldn't sneeze at it if you meant aarch64 or something, but</p>",
        "id": 227018025,
        "sender_full_name": "Jubilee",
        "timestamp": 1613763929
    },
    {
        "content": "<p>I personally think that the libm problem is purely a codegen issue and needs to be fixed in LLVM (which is where the libmvec solution comes from). Though I would like multiversioning eventually, I don't think it necessarily solves this particular problem</p>",
        "id": 227018049,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613763945
    },
    {
        "content": "<p>It can, but have you seen the x86 architecture levels proposal, which glibc, gcc, and LLVM are all cooperating on?</p>",
        "id": 227018146,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613763976
    },
    {
        "content": "<p>I have glanced at it!</p>",
        "id": 227018171,
        "sender_full_name": "Jubilee",
        "timestamp": 1613763988
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span> We could have a version compiled for V2, V3, and V4.</p>",
        "id": 227018183,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613763998
    },
    {
        "content": "<p>That would give us a substantial fraction of the available performance on the table.</p>",
        "id": 227018226,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613764024
    },
    {
        "content": "<p>Sounds plausible, and would improve directing our users, since it would be \"just smack this and don't worry about it\".</p>",
        "id": 227018264,
        "sender_full_name": "Jubilee",
        "timestamp": 1613764037
    },
    {
        "content": "<p>I do think that would be useful, but my real concern is that every software I have personally needed to write needs to run everywhere (so either v1 or v2)</p>",
        "id": 227018307,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613764058
    },
    {
        "content": "<p>instead of \"so, about SSE3, SSSE3, and SSE4.1, SSE4.2, and SSE4a...\"</p>",
        "id": 227018319,
        "sender_full_name": "Jubilee",
        "timestamp": 1613764066
    },
    {
        "content": "<p>And I still don't want to preclude using AVX+ for things that fallback to libm</p>",
        "id": 227018434,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613764107
    },
    {
        "content": "<p>At the cost of shipping four copies of std, which really doesn't seem like an excessive cost. On the off chance people deeply cared about the additional size of three more copies of std in the rust tool chain, we could add an additional rustup component for the simd versions. but I would rather not, if we could get away with just shipping four copies.</p>",
        "id": 227018438,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613764109
    },
    {
        "content": "<p>I wonder how much extra weight it actually looks like</p>",
        "id": 227018710,
        "sender_full_name": "Jubilee",
        "timestamp": 1613764245
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"312331\">@Caleb Zulawski</span> if you have to run everywhere, then you probably want runtime detection and function multiversioning.</p>",
        "id": 227018722,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613764254
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span> If we do it in the most obvious way, it looks like four copies of std. If we narrow it to the subset that benefits most from optimization, we could decrease the weight, but at that point we're reinventing function multiversioning by another name and mechanism.</p>",
        "id": 227018907,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613764327
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span>  could we dedupe functions that literally compile to exactly the same at different levels at least?</p>",
        "id": 227018981,
        "sender_full_name": "Jubilee",
        "timestamp": 1613764361
    },
    {
        "content": "<p>std is currently 23.7 MB, so ballpark of +75MB.</p>",
        "id": 227019213,
        "sender_full_name": "Jubilee",
        "timestamp": 1613764456
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span>  That's what I'm referring to.  This conversation came up because certain functions (such as round, sin, exp) fall back to libm for vectors at the base feature level.  We have been discussing writing pure rust implementations of those functions, but I personally am opposed to that since it precludes codegen from generating more efficient implementations when using multiversioning</p>",
        "id": 227019239,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613764468
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/The.20libm.20problem/near/227018981\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span>  could we dedupe functions that literally compile to exactly the same at different levels at least?</p>\n</blockquote>\n<p>They'd also have to not want to call functions that differ by optimization level. But even if they're the same all the way down, it'd be tricky. Factoring those symbols out into a common library would be feasible, but again at that point you're reinventing multiversioning.</p>",
        "id": 227019530,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613764605
    },
    {
        "content": "<p>Even if we build rust std for various feature levels that allow more efficient implementations of those functions compiled into std, that would only work if you aren't multiversioning</p>",
        "id": 227019574,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613764629
    },
    {
        "content": "<p>licensing: this wouldn't be a copy this would be a translation, if that matters. and for example in the case of rust's libm crate this is no idle question. and whatever the answer is there, that's probably the same a answer for us here with vec libm</p>",
        "id": 227019575,
        "sender_full_name": "Lokathor",
        "timestamp": 1613764629
    },
    {
        "content": "<p>fair enough.</p>",
        "id": 227019636,
        "sender_full_name": "Jubilee",
        "timestamp": 1613764662
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/The.20libm.20problem/near/227019574\">said</a>:</p>\n<blockquote>\n<p>Even if we build rust std for various feature levels that allow more efficient implementations of those functions compiled into std, that would only work if you aren't multiversioning</p>\n</blockquote>\n<p>That wouldn't preclude multiversioning. We could, theoretically, do things like \"if you're in a function that has x86_64-v3 as its target feature set, you can inline functions from the x86_64-v3 std\".</p>",
        "id": 227019729,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613764694
    },
    {
        "content": "<p>That would take some work, but it would be easier than multiversioning.</p>",
        "id": 227019753,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613764710
    },
    {
        "content": "<p>You mean use a mixture of std implementations? That would be interesting and would potentially help. But I still think the most direct solution is to make codegen better</p>",
        "id": 227019821,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613764754
    },
    {
        "content": "<p>none of the fixes have to be done fully in place of also making llvm better</p>",
        "id": 227019905,
        "sender_full_name": "Lokathor",
        "timestamp": 1613764804
    },
    {
        "content": "<p>Also, it's worth pointing something out about multiversioning that would make the above approach <em>better</em> in some cases: multiversioning primarily works when you're calling exported symbols from a library, or similar. You have to be calling something that's actually interposed by the GOT. If you're making more efficient calls within a library that bypass the GOT, you don't get multiversioning unless you invent it yourself.</p>",
        "id": 227019933,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613764807
    },
    {
        "content": "<p>If we can do things like inlining decisions based on target features, that would give us something <em>better</em> than existing implementations of multiversioning.</p>",
        "id": 227020000,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613764841
    },
    {
        "content": "<p>GOT =&gt; Global... Object Table?</p>",
        "id": 227020003,
        "sender_full_name": "Lokathor",
        "timestamp": 1613764842
    },
    {
        "content": "<p>Global Offset Table.</p>",
        "id": 227020015,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613764849
    },
    {
        "content": "<p>I suppose all I am saying is we should try to decouple the problems.  Having multiple stds would be great, multiversioning would be great, but using those to bypass an LLVM codegen issue is still a hack in my opinion</p>",
        "id": 227020205,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613764927
    },
    {
        "content": "<p>Whenever you call a function from a shared library, it jumps to a location that jumps again to the target location. The first time you do so (or eagerly if you use <code>LD_BIND_NOW</code> or the compile-time equivalent) it resolves the function (including any multiversioning) and then overwrites its own GOT entry to make it faster the next time.</p>",
        "id": 227020254,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613764947
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/The.20libm.20problem/near/227020205\">said</a>:</p>\n<blockquote>\n<p>I suppose all I am saying is we should try to decouple the problems.  Having multiple stds would be great, multiversioning would be great, but using those to bypass an LLVM codegen issue is still a hack in my opinion</p>\n</blockquote>\n<p>I'm not disagreeing with that in any way.</p>",
        "id": 227020273,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613764958
    },
    {
        "content": "<p>We should make LLVM better, and/or do better ourselves if we need to bypass LLVM to do so. And if we need to do both to cover different cases, so be it.</p>",
        "id": 227020357,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613764997
    },
    {
        "content": "<p>If one of those can cover everything and we don't have to do the other, great, but we might need more than one solution for full coverage of the problem space.</p>",
        "id": 227020401,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613765020
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/The.20libm.20problem/near/227019575\">said</a>:</p>\n<blockquote>\n<p>licensing: this wouldn't be a copy this would be a translation, if that matters. and for example in the case of rust's libm crate this is no idle question. and whatever the answer is there, that's probably the same a answer for us here with vec libm</p>\n</blockquote>\n<p>Copy vs translation doesn't matter here; either way it's a derivative work.</p>",
        "id": 227020532,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613765070
    },
    {
        "content": "<p>I agree with Josh, and alluded to that earlier: this may look like \"one problem\" but it's actually multiple smaller problems composed of multiple smaller problems each of which requires probably multiple solutions in concert to address.</p>",
        "id": 227020537,
        "sender_full_name": "Jubilee",
        "timestamp": 1613765074
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> then the rust standard library is in a wee bit of a pickle, but I'll PM you or start another thread or something later when I've got more time</p>",
        "id": 227020645,
        "sender_full_name": "Lokathor",
        "timestamp": 1613765135
    },
    {
        "content": "<p>welp lol</p>",
        "id": 227020681,
        "sender_full_name": "Jubilee",
        "timestamp": 1613765156
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/The.20libm.20problem/near/227020645\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> then the rust standard library is in a wee bit of a pickle, but I'll PM you or start another thread or something later when I've got more time</p>\n</blockquote>\n<p>I'm aware that the licensing metadata hasn't been tracked as well as it should have been, if that's what you mean.</p>",
        "id": 227020731,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613765166
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span> so what I'm hearing from you is that we need to make all problems into a crab?</p>",
        "id": 227020749,
        "sender_full_name": "Lokathor",
        "timestamp": 1613765172
    },
    {
        "content": "<p>tbh I think all projects are in a wee bit of a pickle regarding that. :^)</p>",
        "id": 227020759,
        "sender_full_name": "Jubilee",
        "timestamp": 1613765176
    },
    {
        "content": "<p>YES.</p>",
        "id": 227020764,
        "sender_full_name": "Jubilee",
        "timestamp": 1613765178
    },
    {
        "content": "<p>carcinize all the things</p>",
        "id": 227020777,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613765189
    },
    {
        "content": "<p>THE CRAB CYCLE, THERE IS ONLY ONE PROBLEM AND ONE SOLUTION, AND IT IS CRAB</p>",
        "id": 227020784,
        "sender_full_name": "Jubilee",
        "timestamp": 1613765195
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> I believe Rust doesn't use a PLT due to the relro level being partial by default.</p>",
        "id": 227020886,
        "sender_full_name": "bjorn3",
        "timestamp": 1613765258
    },
    {
        "content": "<p>they were having trouble with rustdoc earlier and i asked if they should rewrite it in rust but somehow they didn't think that would help. shocking.</p>",
        "id": 227020890,
        "sender_full_name": "Lokathor",
        "timestamp": 1613765261
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/The.20libm.20problem/near/227020886\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> I believe Rust doesn't use a PLT due to the relro level being partial by default.</p>\n</blockquote>\n<p>Which means that we can't do multiversioning in quite the same way that C/GCC/etc does it.</p>",
        "id": 227021023,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613765309
    },
    {
        "content": "<p>You can always implement it the same way but do an indirect function call from an atomic pointer instead</p>",
        "id": 227021168,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613765394
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/The.20libm.20problem/near/227021168\">said</a>:</p>\n<blockquote>\n<p>You can always implement it the same way but do an indirect function call from an atomic pointer instead</p>\n</blockquote>\n<p>Indirect function calls are expensive these days.</p>",
        "id": 227021248,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613765414
    },
    {
        "content": "<p>Security mitigations.</p>",
        "id": 227021266,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613765424
    },
    {
        "content": "<p>That's fair</p>",
        "id": 227021293,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613765443
    },
    {
        "content": "<p>Not sure it's necessarily any different than a vtable though?</p>",
        "id": 227021355,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613765470
    },
    {
        "content": "<p>It's actually cheaper to do <code>match some_global_constant { THING1 =&gt; func1(a, b, c), THING2 =&gt; func2(a, b, c), ... }</code> and let branch prediction know which one to use.</p>",
        "id": 227021401,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613765483
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/The.20libm.20problem/near/227021355\">said</a>:</p>\n<blockquote>\n<p>Not sure it's necessarily any different than a vtable though?</p>\n</blockquote>\n<p>Right, and vtables have similar problems. Hence the devirtualization optimization: if you have a pretty good idea of which variant you'll actually have, optimize for that case by saying \"if it's this, call this, otherwise fall back to the indirect pointer\".</p>",
        "id": 227021527,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613765542
    },
    {
        "content": "<p>So in my <code>multiversion</code> crate I use static atomic pointers for normal functions and branch prediction for generics (since there's no way to make generic statics) and yeah, I've found virtually no performance difference between the two</p>",
        "id": 227021546,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613765555
    },
    {
        "content": "<p>Though I also wouldn't say I've found branch prediction to be noticeably faster either</p>",
        "id": 227021601,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613765585
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"312331\">@Caleb Zulawski</span> Is that with full security flags turned on, such as retpolines and similar?</p>",
        "id": 227021610,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613765589
    },
    {
        "content": "<p>Nope, I was just going to say I've only tested it in my own little world, so if you're convinced branch prediction is faster I may switch it!</p>",
        "id": 227021671,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613765624
    },
    {
        "content": "<p>Considering it also removes a bit of unsafe I'd consider that win-win</p>",
        "id": 227021769,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613765655
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"312331\">@Caleb Zulawski</span> I'm convinced that the answer is \"it's complicated, try benchmarking with security mitigations turned on and see\".</p>",
        "id": 227021781,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613765658
    },
    {
        "content": "<p>how does one do that with rust?</p>",
        "id": 227021851,
        "sender_full_name": "Lokathor",
        "timestamp": 1613765697
    },
    {
        "content": "<p>(Also worth noting, this is a transient state of affairs, and I'd expect the performance loss of mitigations to reduce over time. But in any case, branch prediction of branches that always go the same way is incredibly good, and basically free.)</p>",
        "id": 227021853,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613765699
    },
    {
        "content": "<p>My only hesitation was that maybe there is still some hardware out there with bad branch predictors</p>",
        "id": 227022078,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613765813
    },
    {
        "content": "<p>Or maybe microcontrollers with none</p>",
        "id": 227022126,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613765833
    },
    {
        "content": "<p>Though it's one of the simplest optimizations in a cpu, I think</p>",
        "id": 227022170,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613765864
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/The.20libm.20problem/near/227021851\">said</a>:</p>\n<blockquote>\n<p>how does one do that with rust?</p>\n</blockquote>\n<p>You'd turn on the appropriate compiler code-generation flags, which I'd have to dig up. Off the top of my head, <code>-C target-feature=retpoline</code> and several other related options; see <code>rustc --print target-features</code> and look up the set of things you would want to use in C to figure out the corresponding options. You don't want SESES though, it's a massive hammer that's an absurd performance hit. But most of the rest are used in much production code these days.</p>",
        "id": 227022270,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613765898
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/The.20libm.20problem/near/227022078\">said</a>:</p>\n<blockquote>\n<p>My only hesitation was that maybe there is still some hardware out there with bad branch predictors</p>\n</blockquote>\n<p>I think such hardware is going to be very sad performance-wise regardless, and this won't make it much sadder. ;)</p>",
        "id": 227022303,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613765915
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> it's not a simd question exactly but does all that apply to dynamically <em>loaded</em> libraries as well? eg: grabbing out a pile of vulkan functions form vulkan-1.dll or similar?</p>",
        "id": 227022330,
        "sender_full_name": "Lokathor",
        "timestamp": 1613765930
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/The.20libm.20problem/near/227022078\">said</a>:</p>\n<blockquote>\n<p>My only hesitation was that maybe there is still some hardware out there with bad branch predictors</p>\n</blockquote>\n<p>It's worth noting that \"bad\" is relative. x86 has ridiculously good branch prediction. It'd take many many years to get branch prediction that good. But you can get some decent improvements with well-known techniques.</p>",
        "id": 227022414,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613765979
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/The.20libm.20problem/near/227022330\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> it's not a simd question exactly but does all that apply to dynamically <em>loaded</em> libraries as well? eg: grabbing out a pile of vulkan functions form vulkan-1.dll or similar?</p>\n</blockquote>\n<p>You mean with respect to licensing?</p>",
        "id": 227022498,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613766009
    },
    {
        "content": "<p>I'm not too familiar with dynamic linkers specifically, but my understanding is that they do not result in indirect function calls.  The calls are rewritten in some sense which is why you need PIC in dynamic libraries</p>",
        "id": 227022523,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613766022
    },
    {
        "content": "<p>no no, for the branching and mitigation stuff</p>",
        "id": 227022526,
        "sender_full_name": "Lokathor",
        "timestamp": 1613766024
    },
    {
        "content": "<p>Hardware nowadays either has zero branch prediction and audaciously claims it can do better by simply going faster, or has pretty good branch prediction on even fairly tiny and unimportant CPUs.</p>",
        "id": 227022529,
        "sender_full_name": "Jubilee",
        "timestamp": 1613766025
    },
    {
        "content": "<p>One general comment, BTW: all else being equal, if we need to prioritize compile-time optimization versus runtime detection, I would <em>generally</em> tend to prioritize compile-time detection first, as long as we leave the door open for runtime detection. I realize that they address different use cases, but all else being equal, compile-time optimization tends to maximize performance for people who know their target, and it's always possible to ship multiple copies of something that are compiled differently and make a top-level choice of which one to install/run/link.</p>\n<p>A world in which compile-time optimization is done and we're working on runtime detection is one where people can get the fastest code and they might have to do a little more work to implement runtime detection themselves. (How much work you need to do depends on how much you want to deduplicate; if you don't care about binary size or duplicate binaries too much, it's <em>easy</em>.) A world in which runtime detection is done and compile-time optimization isn't available yet is one where people get less performance and larger binaries, and have no ability to avoid that for cases where they know their hardware target.</p>",
        "id": 227022626,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613766085
    },
    {
        "content": "<p>That's leaving aside that compile-time detection should be easier.</p>",
        "id": 227022642,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613766097
    },
    {
        "content": "<p>I think we're all on the same page with that for the most part, fortunately.  I think I may just be more biased towards runtime detection than some <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 227022806,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613766183
    },
    {
        "content": "<p>Our main problem with compile time detection is basically \"so, std\".</p>",
        "id": 227022836,
        "sender_full_name": "Jubilee",
        "timestamp": 1613766196
    },
    {
        "content": "<p>atm.</p>",
        "id": 227022842,
        "sender_full_name": "Jubilee",
        "timestamp": 1613766199
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/The.20libm.20problem/near/227022806\">said</a>:</p>\n<blockquote>\n<p>I think we're all on the same page with that for the most part, fortunately.  I think I may just be more biased towards runtime detection than some <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>\n</blockquote>\n<p>I <em>absolutely</em> want runtime detection too. I think I'm more or less saying \"if you have compile-time then runtime can be put together by hand without too much trouble; the reverse is not true\".</p>",
        "id": 227022877,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613766220
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/The.20libm.20problem/near/227022836\">said</a>:</p>\n<blockquote>\n<p>Our main problem with compile time detection is basically \"so, std\".</p>\n</blockquote>\n<p>Right, hence my suggestion for the quick-and-dirty approach of \"compile four copies of std\". :)</p>",
        "id": 227022954,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613766249
    },
    {
        "content": "<p>So in this particular scenario, optimizing compile time detection for round etc precludes runtime detection unless we fix LLVM, which is unusual I think</p>",
        "id": 227023009,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613766277
    },
    {
        "content": "<p>We could do much much better than multiple copies of std, but that'd be an <em>easy</em> approach to experiment with, and in the short term we could shove the optimized versions into a separate rustup component.</p>",
        "id": 227023016,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613766281
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/The.20libm.20problem/near/227023009\">said</a>:</p>\n<blockquote>\n<p>So in this particular scenarios, optimizing compile time detection for round etc precludes runtime detection unless we fix LLVM, which is unusual I think</p>\n</blockquote>\n<p>Can you summarize why, again? IIRC the problem was just that LLVM emits calls to libm, which is painful if you could have inlined something but on the other hand the libm call may go to an optimized version?</p>",
        "id": 227023097,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613766328
    },
    {
        "content": "<p>So the fundamental reason is that all of the functions in stdsimd are #[inline] to ensure codegen happens at the appropriate target feature level.  It plays nice with both compile and runtime detection.</p>\n<p>A few LLVM intrinsics generate exceptionally bad code via calls to libm at the base feature level, but because of the inlining they still lower to optimal instructions if you have the appropriate features (like SSE4.1 will generate <code>roundps</code> instead of repeated calls to libm)</p>\n<p>If we instead write a generic vector implementation of round we could produce good results on base x86-64, but once you hit SSE4.1 or higher it will do significantly worse because we are not emitting the correct instruction to LLVM to generate the platform round instructions</p>",
        "id": 227023556,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613766574
    },
    {
        "content": "<p>LLVM has very recently added support for calling vector math libraries instead of libm (like libmvec, Accelerate, or SVML) which would allow us to fix the problem at the root</p>",
        "id": 227023714,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613766641
    },
    {
        "content": "<p>Basically, the libm version is not \"SSE aware\" and so does not make good use of the baseline capabilities it has and what it can do.</p>",
        "id": 227023720,
        "sender_full_name": "Jubilee",
        "timestamp": 1613766644
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/The.20libm.20problem/near/227023556\">said</a>:</p>\n<blockquote>\n<p>So the fundamental reason is that all of the functions in stdsimd are #[inline] to ensure codegen happens at the appropriate target feature level.  It plays nice with both compile and runtime detection.</p>\n<p>A few LLVM intrinsics generate exceptionally bad code via calls to libm at the base feature level, but because of the inlining they still lower to optimal instructions if you have the appropriate features (like SSE4.1 will generate <code>roundps</code> instead of repeated calls to libm)</p>\n<p>If we instead write a generic vector implementation of round we could produce good results on base x86-64, but once you hit SSE4.1 or higher it will do significantly worse because we are not emitting the correct instruction to LLVM to generate the platform round instructions</p>\n</blockquote>\n<p>Would that still be an issue if we had multiple copies of <code>std</code>, such that base x86-64 uses one implementation, and x86-64 with SSE4.1 or higher uses a different implementation that <em>does</em> use the platform round instructions?</p>",
        "id": 227023761,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613766661
    },
    {
        "content": "<p>I think it would probably not be a problem necessarily, but there are machines that support <code>vroundps</code> but don't have AVX2 and therefore aren't x86-64-v3. Maybe not a super significant problem with that solution but that is why fixing it in codegen would be \"right\".</p>",
        "id": 227024073,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613766812
    },
    {
        "content": "<p>Not to mention LLVM already has the architecture in place for using math vector libraries</p>",
        "id": 227024190,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613766871
    },
    {
        "content": "<p>If rust already supported multiple stds it would probably be a \"good enough\" solution</p>",
        "id": 227024271,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613766919
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/The.20libm.20problem/near/227024073\">said</a>:</p>\n<blockquote>\n<p>I think it would probably not be a problem necessarily, but there are machines that support <code>vroundps</code> but don't have AVX2 and therefore aren't x86-64-v3. Maybe not a super significant problem with that solution but that is why fixing it in codegen would be \"right\".</p>\n</blockquote>\n<p>That's an argument that the microarchitecture feature levels (v2 vs v3) don't have enough granularity. It'd be helpful to know how many extant machines actually fall in that category, because I know the microarchitecture feature levels were fairly carefully designed.</p>",
        "id": 227024335,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613766958
    },
    {
        "content": "<p>I think it's less important to worry about the fine granularity of \"is this optimized as well as it could possibly be for 8-year-old processors\", and more important to handle \"does it run reasonably well on all processors going as far back as we want to support, and does it take advantage of major optimizations\".</p>",
        "id": 227024679,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613767097
    },
    {
        "content": "<p>If it's not <em>perfect</em> for systems with AVX-but-not-AVX2, that's not the end of the world; it's still better than it would have been.</p>",
        "id": 227024719,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613767119
    },
    {
        "content": "<p>Sandy Bridge and Ivy Bridge had AVX but not AVX2. Ivy Bridge is a 2012 processor. (Haswell is 2013, and has AVX2.). So, a CPU that this case would be optimizing for would be 8+ years old.</p>",
        "id": 227024949,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613767219
    },
    {
        "content": "<p>And we'd still be using a SSE4.1 implementation for that case, which is better than the SSE2 implementation we're using today.</p>",
        "id": 227024981,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613767243
    },
    {
        "content": "<p>I actually don't think it's an important argument about granularity, realistically the solution would be good enough for most processors. It was just an example of why fixing it in codegen is probably the most \"correct\" solution</p>",
        "id": 227025046,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613767273
    },
    {
        "content": "<p>No argument there. Though if you're doing multiversioning, that kind of granularity question determines how many different versions you need and thus how much extra code.</p>",
        "id": 227025087,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613767312
    },
    {
        "content": "<p>So even if you fix it in codegen, you might choose to just ship (for instance) x86-64-v3 and baseline.</p>",
        "id": 227025179,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613767338
    },
    {
        "content": "<p>Yeah agreed. I really like the idea of the architecture levels for multiversioning.</p>",
        "id": 227025184,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613767340
    },
    {
        "content": "<p>having multiple std libraries shipped effectively defeats this problem even with no llvm change</p>",
        "id": 227025255,
        "sender_full_name": "Lokathor",
        "timestamp": 1613767378
    },
    {
        "content": "<p>but it's maybe a bigger change overall than just a pr to llvm</p>",
        "id": 227025296,
        "sender_full_name": "Lokathor",
        "timestamp": 1613767399
    },
    {
        "content": "<p>But until we can actually ship multiple versions of std, fixing it by manually implementing these functions entirely precludes runtime detection</p>",
        "id": 227025300,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613767401
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"312331\">@Caleb Zulawski</span> wouldn't the level 2 version just emit <code>roundps</code> anyways instead of <code>vroundps</code>?</p>",
        "id": 227025344,
        "sender_full_name": "Jubilee",
        "timestamp": 1613767431
    },
    {
        "content": "<p>yeah, but like, thus would all be during the nightl-only period, so it's not a big deal</p>",
        "id": 227025411,
        "sender_full_name": "Lokathor",
        "timestamp": 1613767446
    },
    {
        "content": "<p>I say, having noodled around with compiler feature levels for a bit before asking this question and so already knowing the answer :^)</p>",
        "id": 227025422,
        "sender_full_name": "Jubilee",
        "timestamp": 1613767451
    },
    {
        "content": "<p>Sure. I'm wondering how much work it would be to skip the \"manually implementing\" step and just shipping multiple versions of std.</p>",
        "id": 227025435,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613767455
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span> Yes but I'm not aware of any processors that have SSE4.1 but not 4.2</p>",
        "id": 227025458,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613767469
    },
    {
        "content": "<p>Any hypotheses on the amount of work multiple versions of std would be?</p>",
        "id": 227025460,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613767469
    },
    {
        "content": "<p>I think that's a question for infra.</p>",
        "id": 227025476,
        "sender_full_name": "Jubilee",
        "timestamp": 1613767478
    },
    {
        "content": "<p>Yeah I think that's well outside of our scope lol</p>",
        "id": 227025496,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613767489
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span> It's partly an infra question, but that's not the part I'm poking at.</p>",
        "id": 227025516,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613767499
    },
    {
        "content": "<p>\"can we build and ship more stuff\" is an infra question.</p>",
        "id": 227025539,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613767509
    },
    {
        "content": "<p>the non sse4 version of what llvm naturally does is so extremely bad <span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> , we can't in good conscience ship that</p>",
        "id": 227025548,
        "sender_full_name": "Lokathor",
        "timestamp": 1613767511
    },
    {
        "content": "<p>The stdsimd end is the same exact amount of work as if we implement our own version of libmvec</p>",
        "id": 227025580,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613767524
    },
    {
        "content": "<p>\"can the compiler make the appropriate decisions about which std to link to\" is a compiler question.</p>",
        "id": 227025585,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613767526
    },
    {
        "content": "<p>It just changes where we implement it</p>",
        "id": 227025599,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613767534
    },
    {
        "content": "<p>hmm.</p>",
        "id": 227025616,
        "sender_full_name": "Jubilee",
        "timestamp": 1613767543
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"312331\">@Caleb Zulawski</span> questions are never outside of our scope, just actions</p>",
        "id": 227025716,
        "sender_full_name": "Lokathor",
        "timestamp": 1613767571
    },
    {
        "content": "<p>Oh yeah, I meant implementation would be</p>",
        "id": 227025753,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613767594
    },
    {
        "content": "<p>If folks here think that making rustc capable of deciding which library to link at compile time is reasonably feasible, I can ask infra what it'd take to actually do that. (It'd also help to have a sketch of how much build time that'd add.)</p>",
        "id": 227025763,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613767600
    },
    {
        "content": "<p>What fraction of a full rust toolchain build is the building of <code>std</code>?</p>",
        "id": 227025814,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613767630
    },
    {
        "content": "<p>In my experience not that much, rustc seems much longer, but that's anecdotal</p>",
        "id": 227025875,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613767663
    },
    {
        "content": "<p>My concern is more that the implementation is non-trivial. Wouldn't the symbols need to be mangled differently since they both end up in the binary?</p>",
        "id": 227025975,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613767703
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"312331\">@Caleb Zulawski</span> Penryn, VIA Nano, basically, lol?<br>\nOtherwise, most processors that support SSE4.1 also support SSE4.2, yes.<br>\nThat or they support just SSE4a (some of the earlier AMD processors!)</p>",
        "id": 227025992,
        "sender_full_name": "Jubilee",
        "timestamp": 1613767718
    },
    {
        "content": "<p>building core/std is so cheap you can do it with an experimental cargo feature. depends on the OS, but I'd guess \"a few minutes at most\"</p>",
        "id": 227026009,
        "sender_full_name": "Lokathor",
        "timestamp": 1613767731
    },
    {
        "content": "<p>building core for arm is like, seconds</p>",
        "id": 227026050,
        "sender_full_name": "Lokathor",
        "timestamp": 1613767750
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/The.20libm.20problem/near/227025975\">said</a>:</p>\n<blockquote>\n<p>My concern is more that the implementation is non-trivial. Wouldn't the symbols need to be mangled differently since they both end up in the binary?</p>\n</blockquote>\n<p>That depends. Ideally you'd only have one copy: the one for your target feature level. And every call into core/std would use that. But I can imagine scenarios where you might end up with more than one, in which case mangling might come into play.</p>",
        "id": 227026229,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613767820
    },
    {
        "content": "<p>rebuilding std is fast enough that I was fairly serious about my earlier proposal to just optimize for SSE2 and recommend people rebuild std.</p>",
        "id": 227026262,
        "sender_full_name": "Jubilee",
        "timestamp": 1613767836
    },
    {
        "content": "<p>I can imagine a simple implementation that just allows one copy of core/std based on target feature.</p>",
        "id": 227026293,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613767853
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/The.20libm.20problem/near/227026262\">said</a>:</p>\n<blockquote>\n<p>rebuilding std is fast enough that I was fairly serious about my earlier proposal to just optimize for SSE and recommend people rebuild std.</p>\n</blockquote>\n<p>I don't think you want the portable-simd project gated behind build-std becoming stable.</p>",
        "id": 227026319,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613767868
    },
    {
        "content": "<p>That'll be a while.</p>",
        "id": 227026328,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613767871
    },
    {
        "content": "<p>and everyone went \"nooooo!\" :^)</p>",
        "id": 227026343,
        "sender_full_name": "Jubilee",
        "timestamp": 1613767876
    },
    {
        "content": "<p>that's true.</p>",
        "id": 227026352,
        "sender_full_name": "Jubilee",
        "timestamp": 1613767879
    },
    {
        "content": "<p>no i also think that's the best plan, for real</p>",
        "id": 227026369,
        "sender_full_name": "Lokathor",
        "timestamp": 1613767889
    },
    {
        "content": "<p>because it's not gated behind, it all still works without build-std</p>",
        "id": 227026390,
        "sender_full_name": "Lokathor",
        "timestamp": 1613767904
    },
    {
        "content": "<p>it's just sub-optimal, which is ultimately fine</p>",
        "id": 227026421,
        "sender_full_name": "Lokathor",
        "timestamp": 1613767915
    },
    {
        "content": "<p>I think long term I would <em>love</em> to rely on build-std for this kind of thing.</p>",
        "id": 227026422,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613767916
    },
    {
        "content": "<p>zig does ;P</p>",
        "id": 227026474,
        "sender_full_name": "Lokathor",
        "timestamp": 1613767925
    },
    {
        "content": "<p>Short-term, it might be possible to simulate the use of build-std by shipping a few different stds.</p>",
        "id": 227026531,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613767951
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> do you mean compile time target feature? Because then that doesn't solve the libm problem</p>",
        "id": 227026542,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613767956
    },
    {
        "content": "<p>Which would change \"suboptimal\" to \"fairly good\".</p>",
        "id": 227026556,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613767967
    },
    {
        "content": "<p>(though it's still probably a desirable feature for other reasons)</p>",
        "id": 227026572,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613767973
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"312331\">@Caleb Zulawski</span> it does, because then the standard library can use cfg and it works right</p>",
        "id": 227026602,
        "sender_full_name": "Lokathor",
        "timestamp": 1613767992
    },
    {
        "content": "<p>No it doesn't, because if you enable AVX with #[target_feature] you still won't get <code>vroundps</code> if your base feature set is v1</p>",
        "id": 227026651,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613768023
    },
    {
        "content": "<p>oh right, because of that other garbage</p>",
        "id": 227026783,
        "sender_full_name": "Lokathor",
        "timestamp": 1613768083
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"312331\">@Caleb Zulawski</span> I'm talking about building the whole std with <code>-C target-feature=...</code>. Does <em>that</em> not emit <code>vroundps</code> if AVX2 is enabled? If not, we need to fix that, yeah.</p>",
        "id": 227026828,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613768111
    },
    {
        "content": "<p>That absolutely does.</p>",
        "id": 227026854,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613768122
    },
    {
        "content": "<p>That's what I'm proposing when I say \"multiple versions of std\".</p>",
        "id": 227026873,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613768133
    },
    {
        "content": "<p>Build it once for baseline, once for target-feature=x86-64-v2, etc.</p>",
        "id": 227026886,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613768144
    },
    {
        "content": "<p>it does, but caleb wants to make a binary that is portable with and without avx support</p>",
        "id": 227026899,
        "sender_full_name": "Lokathor",
        "timestamp": 1613768150
    },
    {
        "content": "<p>I understand that.</p>",
        "id": 227026977,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613768170
    },
    {
        "content": "<p>And there are still a few ways to do that once you have functioning compile-time support.</p>",
        "id": 227027023,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613768191
    },
    {
        "content": "<p>and basically as it is now, you have to use target_feature(enable) but that <em>doesn't</em> change the cfg settings within a function</p>",
        "id": 227027051,
        "sender_full_name": "Lokathor",
        "timestamp": 1613768205
    },
    {
        "content": "<p>In fact it can't, since cfg must be consistent across a crate</p>",
        "id": 227027112,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613768236
    },
    {
        "content": "<p>so if avx isn't on in a build cfg(avx) will be false, and target_feature_enavle(avx) doesn't make it true, it's still false</p>",
        "id": 227027127,
        "sender_full_name": "Lokathor",
        "timestamp": 1613768240
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"312331\">@Caleb Zulawski</span> in this case, I'm pressing X to doubt pretty hard</p>",
        "id": 227027182,
        "sender_full_name": "Lokathor",
        "timestamp": 1613768277
    },
    {
        "content": "<p>we <em>could</em> fix it for this probably, or introduce an alternative mechanism</p>",
        "id": 227027259,
        "sender_full_name": "Lokathor",
        "timestamp": 1613768300
    },
    {
        "content": "<p>Actually, I think it's almost nearly impossible to fix it that way, since you can't reason about what the feature set of a function you inline into will be</p>",
        "id": 227027513,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613768433
    },
    {
        "content": "<p>As far as I can tell <em>only</em> codegen is privy to that</p>",
        "id": 227027536,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613768448
    },
    {
        "content": "<p>If we want to fix the inline case, we <em>have</em> to fix it in codegen.</p>",
        "id": 227027539,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613768452
    },
    {
        "content": "<p>But if we want to handle simple runtime detection that's as capable as function multiversioning, we don't have to cover that.</p>",
        "id": 227027567,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613768470
    },
    {
        "content": "<p>You could have the equivalent of a <code>func_x86_64_v3</code> and a <code>func_x86_64</code> and call the right one at runtime, without fixing codegen. You just can't inline one or the other based on target features without fixing codegen.</p>",
        "id": 227027630,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613768509
    },
    {
        "content": "<p>I think it makes more sense to fix codegen than to make something like cfg(target_feature) that only works sometimes</p>",
        "id": 227027710,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613768528
    },
    {
        "content": "<p>/me is confused.</p>",
        "id": 227027762,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613768552
    },
    {
        "content": "<p>What would the latter be referring to?</p>",
        "id": 227027775,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613768560
    },
    {
        "content": "<p>I am also slightly confused.</p>",
        "id": 227027825,
        "sender_full_name": "Jubilee",
        "timestamp": 1613768586
    },
    {
        "content": "<p>Also I want to reiterate one thing that I think everyone knows but is important and underlines Lokathor's point:</p>\n<p>On processors with SIMD registers, especially <strong>older</strong> processors, moving between SIMD and scalar can be slow. So that's part of why we want to avoid calls to libm even on the baseline SSE2 feature level, because we have good reason to <strong>really doubt</strong> that libm will actually do better.</p>",
        "id": 227027848,
        "sender_full_name": "Jubilee",
        "timestamp": 1613768591
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> is suggesting you could make cfg work with the target feature attribute</p>",
        "id": 227027851,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613768592
    },
    {
        "content": "<p>But like you said it wouldn't work with inlining anyway</p>",
        "id": 227027895,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613768608
    },
    {
        "content": "<p>I don't think we should go that route rather than fixing codegen.</p>",
        "id": 227027904,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613768613
    },
    {
        "content": "<p>If we're going to try to fix the compiler to understand target features in this way, let's just fix codegen and be done with it.</p>",
        "id": 227027934,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613768630
    },
    {
        "content": "<p>Yeah agreed. I'd like the compiler to do that eventually but I think that's a very long way out.</p>",
        "id": 227028023,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613768654
    },
    {
        "content": "<p>The goal of compiling multiple versions of std (and letting people do the same with other libraries) would be to sidestep that, and also to avoid needing build-std to get optimized versions of std.</p>",
        "id": 227028049,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613768666
    },
    {
        "content": "<p><em>nods</em></p>",
        "id": 227028064,
        "sender_full_name": "Jubilee",
        "timestamp": 1613768674
    },
    {
        "content": "<p>It'd also be really helpful for distributions like Debian, which build std as a shared library; they could build multiple copies and ship them in the directories specific to architecture feature level libraries.</p>",
        "id": 227028106,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613768698
    },
    {
        "content": "<p>I guess I'm confused how building multiple versions of std fixes this particular problem since all of our functions are inline and therefore don't get distributed as compiled asm anyway</p>",
        "id": 227028172,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613768723
    },
    {
        "content": "<p>\"here's the std .so for baseline x86-64, here's the one for x86-64-v3, the dynamic linker will DTRT\".</p>",
        "id": 227028185,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613768733
    },
    {
        "content": "<p>I think it's worthwhile for other reasons but I still don't think it fixes this at all</p>",
        "id": 227028193,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613768737
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"312331\">@Caleb Zulawski</span> Multiple versions of std also means multiple rlibs and thus multiple versions of inline-able code too.</p>",
        "id": 227028261,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613768764
    },
    {
        "content": "<p>You'd inline the version that corresponds to how you're compiling your crate.</p>",
        "id": 227028326,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613768784
    },
    {
        "content": "<p>If you build your crate with <code>-C target-feature=x86-64-v3</code>, rustc would link you to the x86-64-v3 std, and also use that std for inlining.</p>",
        "id": 227028357,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613768803
    },
    {
        "content": "<p>Am I confused or would this still not work in the runtime detection case?</p>",
        "id": 227028361,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613768805
    },
    {
        "content": "<p>When I said there are ways to build that runtime detection yourself, I was suggesting that you could (for instance) build multiple copies of your crate and pick which one to install on the target system, or you could build the part of your crate that cares about such optimizations as a shared library and install multiple shared libraries, or you could compile several static objects with different symbols and different optimization levels and hand-roll multiversioning...</p>",
        "id": 227028552,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613768886
    },
    {
        "content": "<p>You wouldn't just be able to do <code>cfg</code> within your own crate and write several side-by-side functions with different feature levels, unless we fix enough of codegen to make that work.</p>",
        "id": 227028639,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613768925
    },
    {
        "content": "<p>Okay, so it <em>would not</em> be compatible with #[target_feature]</p>",
        "id": 227028642,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613768927
    },
    {
        "content": "<p>But you <em>could</em> still get runtime detection to work, by several other routes.</p>",
        "id": 227028664,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613768938
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/The.20libm.20problem/near/227028642\">said</a>:</p>\n<blockquote>\n<p>Okay, so it <em>would not</em> be compatible with #[target_feature]</p>\n</blockquote>\n<p>Right. It'd <em>only</em> be compatible with <code>-C target-feature</code>, unless we fixed that.</p>",
        "id": 227028695,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613768951
    },
    {
        "content": "<p>I personally think that's an acceptable trade-off for a very simple solution, while we're working on fixing codegen.</p>",
        "id": 227028730,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613768969
    },
    {
        "content": "<p>I think that's probably not a good solution because in general people should expect #[target_feature] to work</p>",
        "id": 227028757,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613768980
    },
    {
        "content": "<p>And it's also something we'll need even <em>after</em> we fix codegen, for other reasons.</p>",
        "id": 227028776,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613768986
    },
    {
        "content": "<p>Do we really think that's easier than fixing it in codegen? LLVM already has support for calling vector libraries</p>",
        "id": 227028843,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613769004
    },
    {
        "content": "<p>We don't want to call vector libraries, we want to generate inline code.</p>",
        "id": 227028905,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613769019
    },
    {
        "content": "<p>This has already gone in a circle.</p>",
        "id": 227028918,
        "sender_full_name": "Jubilee",
        "timestamp": 1613769023
    },
    {
        "content": "<p>Yeah, I don't think we need to rehash this further.</p>",
        "id": 227028955,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613769042
    },
    {
        "content": "<p>If you static link the vector library it can't inline that code?</p>",
        "id": 227028989,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613769056
    },
    {
        "content": "<p>I think there are a few possibilities available at this point, and it'd be reasonable to decide which one to go forward with first, as well as what the long-term plan is.</p>",
        "id": 227029009,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613769065
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/The.20libm.20problem/near/227028989\">said</a>:</p>\n<blockquote>\n<p>If you static link the vector library it can't inline that code?</p>\n</blockquote>\n<p>Only if the vector library were to ship LTO-capable bitcode using a compatible toolchain to allow cross-language inlining.</p>",
        "id": 227029126,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613769116
    },
    {
        "content": "<p>Otherwise, no.</p>",
        "id": 227029137,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613769121
    },
    {
        "content": "<p>I am suggesting we write the vector library ourselves in Rust</p>",
        "id": 227029199,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613769132
    },
    {
        "content": "<p>And compile it as part of stdsimd</p>",
        "id": 227029225,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613769145
    },
    {
        "content": "<p>I see. So you're talking about using LLVM's support for calling a vector math library, but shipping our own such library. Do we know that'll work with LLVM and produce appropriate inlined code that's just as efficient as using <code>-C target-feature=...</code> in the first place?</p>",
        "id": 227029268,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613769174
    },
    {
        "content": "<p>I do not know that it will inline efficiently, but I do know that it will still work with #[target_feature]</p>",
        "id": 227029390,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613769229
    },
    {
        "content": "<p>I'm more concerned about the former than the latter. I acknowledge that you may prioritize those differently.</p>",
        "id": 227029470,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613769254
    },
    {
        "content": "<p>(I tried an example further up in this thread with llc)</p>",
        "id": 227029497,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613769270
    },
    {
        "content": "<p>I think that's an especially important consideration for a potential long-term solution: if the optimized version using LLVM's vector math support and a Rust math library isn't as efficient as more direct codegen/inlining would be, then it isn't the right long term solution.</p>",
        "id": 227029614,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613769313
    },
    {
        "content": "<p>Right, well I would like to see if it inlines. To be honest I don't know how to mark a function as inlinable in LLVM IR (or would it have to be LTO at that point?)</p>",
        "id": 227029645,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613769326
    },
    {
        "content": "<p>Also I'm not convinced that these functions should be inlined?  They're very large</p>",
        "id": 227029704,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613769360
    },
    {
        "content": "<p>Some of the trig functions are extremely large</p>",
        "id": 227029778,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613769379
    },
    {
        "content": "<p>To answer a much earlier question:</p>\n<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/The.20libm.20problem/near/227022523\">said</a>:</p>\n<blockquote>\n<p>I'm not too familiar with dynamic linkers specifically, but my understanding is that they do not result in indirect function calls.  The calls are rewritten in some sense which is why you need PIC in dynamic libraries</p>\n</blockquote>\n<p>They don't end up doing indirect function calls in the common case. There are a couple of different approaches commonly used. Here's my understanding, off the top of my head:</p>\n<p>A long time ago, the standard approach was static relocations, where if you used <code>call xyz</code> in your code, the compiler would emit a call to a fixed address but add a relocation table entry noting the location of that fixed address in your code, and when dynamic linking it would patch in the address it put <code>xyz</code> at. That doesn't have an indirect call, but it means patching code at runtime, which also makes it harder to mark all the code segments read-only, and thus isn't quite as secure. It also means that on your system, in memory, every copy of a shared library in a different process may get a different address patched into its code, which means the code pages have different contents, so they can't actually be shared in virtual memory; so, if you had 30 programs using libc, you'd have 30 copies of libc in memory with different addresses patched in.</p>\n<p>To avoid those problems, current dynamic linkers (for many many years) make calls through the \"program load table\" (PLT), where calls look like <code>call xyz@PLT</code> in assembly. That's still a direct call (albeit typically a position-independent one). The first time it's called (or when the program is first run if doing <code>bindnow</code>/<code>LD_BIND_NOW</code>), the code in the PLT loads an index into a register and calls common code, which figures out the correct address for the symbol, patches the PLT entry into a direct call for the next call, and then makes that call. Subsequent times it's just a call-then-jmp. This allows position-independent code (as long as the PLT is at a known offset relative to the call instruction).</p>\n<p>Position-independent code used to be more expensive on baseline x86, because you needed to get the current instruction pointer to offset from, which caused more register pressure (you had to have a register to put the IP into and then offset from) but on x86-64 it's cheap and almost always used, because there's a <code>%rip</code> register you can reference for that. So, <em>most</em> code on x86-64 these days is built position-independent, including both binaries and shared libraries, both for deduplication in virtual memory and because position-independent code also allows for security improvements like ASLR.</p>\n<p>Multiversioning extends that use of the PLT to also check the equivalent of CPUID (it uses <code>AT_HWCAP</code>/<code>AT_HWCAP2</code> from the auxiliary vector, provided by the kernel), and make the PLT reference the appropriate symbol based on CPU features.</p>\n<p>The GOT is similar to the PLT, but for data symbols rather than function symbols, and it's always resolved at initial load time and doesn't need anything like multiversioning.</p>",
        "id": 227029817,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613769397
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/The.20libm.20problem/near/227029704\">said</a>:</p>\n<blockquote>\n<p>Also I'm not convinced that these functions should be inlined?  They're very large</p>\n</blockquote>\n<p>I would expect things as simple as <code>vroundps</code> to be an inline instruction, and a call would add overhead to that.</p>",
        "id": 227029991,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613769483
    },
    {
        "content": "<p>Oh let me clarify, when LLVM calls the vector math lib, it's only if it can't call vroundps etc</p>",
        "id": 227030101,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613769532
    },
    {
        "content": "<p>Ah, I see.</p>",
        "id": 227030140,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613769553
    },
    {
        "content": "<p>yeah, we'd be patching up the sub-sse4 case</p>",
        "id": 227030143,
        "sender_full_name": "Lokathor",
        "timestamp": 1613769555
    },
    {
        "content": "<p>If it generates to a codelet those are absolutely inlined.  The math lib fallbacks are not</p>",
        "id": 227030153,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613769558
    },
    {
        "content": "<p>\"codelet\"? (I can guess from context but would like clarification.)</p>",
        "id": 227030192,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613769580
    },
    {
        "content": "<p>I don't know if there's a better word. A specific string of instructions that implement an LLVM instruction</p>",
        "id": 227030303,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613769618
    },
    {
        "content": "<p>If it generates \"a string of instructions that don't call the vector math lib\" it doesn't result in a function call. If it calls the vector math lib as a fallback it does produce a single call (which is an improvement over the 4-8 calls to libm right now)</p>",
        "id": 227030447,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613769707
    },
    {
        "content": "<p>In a more specific example, if you are using SVML, it will generate <code>roundps</code> if you have sse4.1 but <code>call roundf32</code> (or whatever the function is called) if you don't</p>",
        "id": 227030781,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613769887
    },
    {
        "content": "<p>Actually that's not true, LLVM doesn't support it for <code>round</code> yet, which is where we would need to patch llvm.  This is true for other functions though</p>",
        "id": 227030957,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613769977
    },
    {
        "content": "<p>LLVM supports sin, cos, exp, log</p>",
        "id": 227030990,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613770008
    },
    {
        "content": "<p>Perhaps that's an argument for using multiple std as a stopgap for round specifically</p>",
        "id": 227031285,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613770169
    },
    {
        "content": "<p>But that's a lot of work for one function</p>",
        "id": 227031317,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613770186
    },
    {
        "content": "<p>My expectation is that having multiple versions of std would be about much more than just math functions.</p>",
        "id": 227031492,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613770258
    },
    {
        "content": "<p>Inlined versions of memcpy/memmove, for instance.</p>",
        "id": 227031522,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613770275
    },
    {
        "content": "<p>(Though the nice thing is that these days <code>rep movsb</code> is mostly the right answer.)</p>",
        "id": 227031564,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613770298
    },
    {
        "content": "<p>Definitely agreed there</p>",
        "id": 227031689,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1613770360
    },
    {
        "content": "<p>I'm hoping that letting the compiler casually use non-baseline instructions whenever it sees an opportunity will optimize substantial portions of the standard library.</p>",
        "id": 227031697,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613770364
    },
    {
        "content": "<p>BTW, I'm currently asking infra how feasible it'd be to ship multiple copies of std.</p>",
        "id": 227032454,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613770790
    }
]