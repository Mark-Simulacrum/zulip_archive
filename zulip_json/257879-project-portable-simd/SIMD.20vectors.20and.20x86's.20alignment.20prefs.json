[
    {
        "content": "<p>So, on x86, all vectors should be aligned to 16 at minimum.<br>\nCurrently, <code>Simd</code> aligns to 8 if it's a combination like <code>f32x2</code>.<br>\nIf we want <code>Simd</code> to always load into a vector register if available, which is what <a href=\"https://github.com/rust-lang/portable-simd/issues/94\">https://github.com/rust-lang/portable-simd/issues/94</a> implies, and for it to be sound to emit <code>movaps</code> to do that,  etc., we should consider making its alignment always be at least 16 on x86. However, that has other problems, obviously, starting with \"teaching Rust programmers how to use an architecture-dependent alignment\".<br>\nI think we can do this via <code>cfg_attr</code>, but even if we can't: compiler magic <strong>is</strong> available to us. We have already begun to  dictate the terms of <code>#[repr(simd)]</code>, so we should consider ourselves allowed to do that.<br>\nCue <span class=\"user-mention\" data-user-id=\"229517\">@Jacob Lifshay</span>'s remarks about alignment for SimpleV and other vector architectures. :^)</p>",
        "id": 271765121,
        "sender_full_name": "Jubilee",
        "timestamp": 1644785893
    },
    {
        "content": "<p>imho we should at least define that power-of-2 sized vector types never have padding, because of the expectation that transmuting <code>[f32x2; 2]</code> to <code>f32x4</code> should work -- that doesn't work with <code>f32x2</code> being aligned to 16 bytes since you need 8 bytes of padding to get align 16. also, x86 has instructions for loading/storing <code>f32x2</code> out of a xmm register.</p>",
        "id": 271772118,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1644795300
    },
    {
        "content": "<p>this means all power-of-2 types always have <code>align&lt;=LANES*sizeof(element)</code></p>",
        "id": 271772139,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1644795352
    },
    {
        "content": "<p>I think I agree, at worst a load or store could be implemented with scalars</p>",
        "id": 271772217,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1644795447
    },
    {
        "content": "<p>If a user wants to explicitly pad for performance they could for example do loads as f32x8 and then swizzle to f32x7</p>",
        "id": 271772283,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1644795536
    },
    {
        "content": "<p>Jubilee and I discovered a while ago that Rust's vector alignments today are... arbitrary</p>",
        "id": 271772355,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1644795631
    },
    {
        "content": "<p>Does LLVM care what the alignment is?</p>",
        "id": 271772598,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1644796051
    },
    {
        "content": "<blockquote>\n<p>Does LLVM care what the alignment is?</p>\n</blockquote>\n<p>afaict not really, basically anything that loads/stores vectors lets you set the alignment to any user-specified value</p>",
        "id": 271773358,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1644797072
    },
    {
        "content": "<p>I definitely want f32x4 to never have padding and for that to be a hard guarantee.</p>",
        "id": 271773522,
        "sender_full_name": "Jubilee",
        "timestamp": 1644797296
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"229517\">Jacob Lifshay</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/SIMD.20vectors.20and.20x86's.20alignment.20prefs/near/271773358\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>Does LLVM care what the alignment is?</p>\n</blockquote>\n<p>afaict not really, basically anything that loads/stores vectors lets you set the alignment to any user-specified value</p>\n</blockquote>\n<p>I guess a better question might be \"does LLVM care as in ruthlessly deoptimize your code if you break from this assumption?\"</p>",
        "id": 271774427,
        "sender_full_name": "Jubilee",
        "timestamp": 1644798547
    },
    {
        "content": "<p>Alignment should only affect optimization of loads and stores, which IMO is not the thing we should be optimizing</p>",
        "id": 271774504,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1644798654
    },
    {
        "content": "<p>Particularly for non-native vector sizes, I mean</p>",
        "id": 271774514,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1644798685
    },
    {
        "content": "<p>If f32x7 has the same alignment as f32x8 I could see that causing some unexpected behavior</p>",
        "id": 271774571,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1644798755
    },
    {
        "content": "<p>I would assume that doing any operations on <code>f32x7</code> would also hit the \"ruthless deoptimization\" stuff.</p>",
        "id": 271783921,
        "sender_full_name": "scottmcm",
        "timestamp": 1644813131
    },
    {
        "content": "<p>How does it lower, on popular platforms?  <code>f32x8</code> with an <code>undef</code>, two <code>f32x4</code>s with overlap, <code>f32x4</code> + <code>f32x2</code> + <code>f32x1</code>?</p>",
        "id": 271784081,
        "sender_full_name": "scottmcm",
        "timestamp": 1644813469
    },
    {
        "content": "<p>I've seen it do f32x8 with an undef lane</p>",
        "id": 271785320,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1644815168
    },
    {
        "content": "<p>hm, what does a dot product with f32x7s look like?</p>",
        "id": 271785496,
        "sender_full_name": "Jubilee",
        "timestamp": 1644815415
    },
    {
        "content": "<p>I'm not sure why it would be much different than with 8 lanes?</p>",
        "id": 271785511,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1644815452
    },
    {
        "content": "<p>Oh, I know, but I am just wondering how it handles the trailing lane.</p>",
        "id": 271785521,
        "sender_full_name": "Jubilee",
        "timestamp": 1644815480
    },
    {
        "content": "<p>I don't think it uses the hadd instruction on x86 anyway because it's too slow</p>",
        "id": 271785540,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1644815514
    },
    {
        "content": "<p>Oh yeah, that part is fine.</p>",
        "id": 271785581,
        "sender_full_name": "Jubilee",
        "timestamp": 1644815525
    },
    {
        "content": "<p>Do you just mean the order?</p>",
        "id": 271785589,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1644815537
    },
    {
        "content": "<p>yes, basically.</p>",
        "id": 271785592,
        "sender_full_name": "Jubilee",
        "timestamp": 1644815544
    },
    {
        "content": "<p>I think we basically have two reasonable choices:</p>\n<p>1) <code>sizeof(Simd&lt;T; N&gt;) == sizeof([T; N])</code>, and the alignment of the simd type is the highest possible value that divides the size evenly.  (<code>as_simd</code> wants this one, and it's pretty good for, say, N=24, but it's pretty poor for N=31.)</p>\n<p>2) <code>sizeof(Simd&lt;T; N&gt;) == alignof(Simd&lt;T; N&gt;) == (sizeof(T)*N).next_power_of_two()</code> (which is basically the \"stick <code>undef</code>s on the end\" solution)</p>\n<p>I think I lean towards (1), assuming that once they're in registers it doesn't matter, since one can always wrap them to get the padding version if so desired, but there's no way to remove it.  Of course, I guess the answer for avoiding storage could be to just store it as an array if you didn't want the possibility of padding off the end.</p>\n<p>(Both choices lead to <code>size == align == some_power_of_two</code> for power-of-two numbers of lanes, as expected.)</p>",
        "id": 271787642,
        "sender_full_name": "scottmcm",
        "timestamp": 1644818447
    },
    {
        "content": "<p>I hadn't considered the GCF as an option.</p>",
        "id": 271787685,
        "sender_full_name": "Jubilee",
        "timestamp": 1644818505
    },
    {
        "content": "<p>I should mention that when LLVM sticks undefs on the end, that's only in register, I don't believe loads and stores assume there are extra lanes</p>",
        "id": 271787797,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1644818655
    },
    {
        "content": "<p>Which should be compatible with 1</p>",
        "id": 271787829,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1644818727
    },
    {
        "content": "<p>GCF was inspired by the idea that <code>Simd&lt;f32, 12&gt;</code>  might end up lowered to <code>Simd&lt;f32, 4&gt;</code> anyway, so align=16 for it might be totally fine.</p>",
        "id": 271787830,
        "sender_full_name": "scottmcm",
        "timestamp": 1644818729
    },
    {
        "content": "<p>on risc-v, SimpleV, and a few other architectures (SVE?), there's also option 3: <code>sizeof(Simd&lt;T, N&gt;) == N * sizeof(T)</code> <code>alignof(Simd&lt;T, N&gt;) == alignof(T)</code> aka. layout is exactly the same as <code>[T; N]</code></p>",
        "id": 271787833,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1644818734
    },
    {
        "content": "<p>Yeah I was going to suggest the possibility of alignment being an implementation detail and we simply say it's a multiple of T but it's unspecified?</p>",
        "id": 271787887,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1644818792
    },
    {
        "content": "<p>I imagine on different architectures it could be wildly different</p>",
        "id": 271787892,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1644818809
    },
    {
        "content": "<p>imho we should pick option 1 on x86 and option 3 on risc-v and SimpleV, and 1 or 3 as needed on the other architectures</p>",
        "id": 271787898,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1644818823
    },
    {
        "content": "<p>I kinda wish we could use const generics to let users specify the alignment exactly for whatever arcane reason but have a default.</p>",
        "id": 271787913,
        "sender_full_name": "Jubilee",
        "timestamp": 1644818851
    },
    {
        "content": "<p>We do already even have u64 having different possible alignments, so it's not without precedent.</p>",
        "id": 271787914,
        "sender_full_name": "scottmcm",
        "timestamp": 1644818853
    },
    {
        "content": "<p>Yeah, on 32-bit machines, u64 has align 4, right?</p>",
        "id": 271787956,
        "sender_full_name": "Jubilee",
        "timestamp": 1644818883
    },
    {
        "content": "<p>I didn't know that, I think it would be great justification for vectors having arbitrary alignments.</p>",
        "id": 271787964,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1644818907
    },
    {
        "content": "<p>on i686 in particular...some other 32-bit archs have align 8 i64</p>",
        "id": 271787970,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1644818917
    },
    {
        "content": "<p>Mmm.</p>",
        "id": 271787973,
        "sender_full_name": "Jubilee",
        "timestamp": 1644818923
    },
    {
        "content": "<p>It's really the same principle</p>",
        "id": 271787974,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1644818923
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/SIMD.20vectors.20and.20x86's.20alignment.20prefs/near/271787956\">said</a>:</p>\n<blockquote>\n<p>Yeah, on 32-bit machines, u64 has align 4, right?</p>\n</blockquote>\n<p>That's my recollection, yeah.</p>",
        "id": 271787975,
        "sender_full_name": "scottmcm",
        "timestamp": 1644818926
    },
    {
        "content": "<p>So then the question is just whether we want to say anything about <code>sizeof(Simd&lt;T, N&gt;)</code>?</p>",
        "id": 271787985,
        "sender_full_name": "scottmcm",
        "timestamp": 1644818953
    },
    {
        "content": "<p>do any of these answers complicate the world from the UCG point of view?</p>",
        "id": 271787986,
        "sender_full_name": "Jubilee",
        "timestamp": 1644818955
    },
    {
        "content": "<p>I would prefer to specify the size is identical to that of an array</p>",
        "id": 271787996,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1644818996
    },
    {
        "content": "<p>Currently we specify that the alignment is based on T and N in some unspecified way, if I remember the docs I just wrote.</p>",
        "id": 271788033,
        "sender_full_name": "Jubilee",
        "timestamp": 1644819005
    },
    {
        "content": "<p>imho <code>sizeof(Simd&lt;T, N&gt;)</code> should always be exactly <code>sizeof([T; N])</code></p>",
        "id": 271788038,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1644819014
    },
    {
        "content": "<p>I think \"is it possible that there's padding\" is my far the most impactful choice, and it sounds like nobody wants that.</p>",
        "id": 271788047,
        "sender_full_name": "scottmcm",
        "timestamp": 1644819045
    },
    {
        "content": "<p><code>size_of</code> includes padding though.</p>",
        "id": 271788062,
        "sender_full_name": "Jubilee",
        "timestamp": 1644819081
    },
    {
        "content": "<p><a href=\"https://doc.rust-lang.org/stable/std/mem/fn.size_of.html\">https://doc.rust-lang.org/stable/std/mem/fn.size_of.html</a> is this table wrong?</p>",
        "id": 271788080,
        "sender_full_name": "Jubilee",
        "timestamp": 1644819107
    },
    {
        "content": "<p>So it seems quite reasonable to me to just say</p>\n<ul>\n<li><code>sizeof(Simd&lt;T, N&gt;) == sizeof([T; N])</code> and</li>\n<li><code>alignof(Simd&lt;T, N&gt;) &gt;= alignof([T; N])</code>.</li>\n</ul>\n<p>That allows <code>AsRef</code> as <code>as_simd</code>, but doesn't say anything more.  And thus it's compatible with (1) on x64 and (3) on risc-v</p>",
        "id": 271788127,
        "sender_full_name": "scottmcm",
        "timestamp": 1644819131
    },
    {
        "content": "<p>hm.</p>",
        "id": 271788128,
        "sender_full_name": "Jubilee",
        "timestamp": 1644819131
    },
    {
        "content": "<p>I think we're saying that vectors shouldn't have any padding</p>",
        "id": 271788130,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1644819136
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/SIMD.20vectors.20and.20x86's.20alignment.20prefs/near/271788080\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://doc.rust-lang.org/stable/std/mem/fn.size_of.html\">https://doc.rust-lang.org/stable/std/mem/fn.size_of.html</a> is this table wrong?</p>\n</blockquote>\n<p>No, but that's just size, not alignment.  (So I'm not sure what you mean by the reference.)</p>",
        "id": 271788156,
        "sender_full_name": "scottmcm",
        "timestamp": 1644819195
    },
    {
        "content": "<p>Ah.<br>\nHmm. Yeah, min align is definitely <code>[T; N]</code>.</p>",
        "id": 271788157,
        "sender_full_name": "Jubilee",
        "timestamp": 1644819205
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/SIMD.20vectors.20and.20x86's.20alignment.20prefs/near/271788156\">said</a>:</p>\n<blockquote>\n<p>No, but that's just size, not alignment.  (So I'm not sure what you mean by the reference.)</p>\n</blockquote>\n<p>No idea tbh.</p>",
        "id": 271788165,
        "sender_full_name": "Jubilee",
        "timestamp": 1644819231
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/SIMD.20vectors.20and.20x86's.20alignment.20prefs/near/271787913\">said</a>:</p>\n<blockquote>\n<p>I kinda wish we could use const generics to let users specify the alignment exactly for whatever arcane reason but have a default.</p>\n</blockquote>\n<p>Is there some reason that having it in the type itself would be better for codegen than just letting them wrap it in a newtype with <code>repr(align(whatever))</code> to over-align and add padding?</p>",
        "id": 271788225,
        "sender_full_name": "scottmcm",
        "timestamp": 1644819298
    },
    {
        "content": "<p>I'm reluctant to say vectors shouldn't have padding for the f32x3 case. I want to know more about some esoteric layout considerations in some existing machine APIs people want to program against first before committing to an answer.</p>",
        "id": 271788228,
        "sender_full_name": "Jubilee",
        "timestamp": 1644819305
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/SIMD.20vectors.20and.20x86's.20alignment.20prefs/near/271788225\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/SIMD.20vectors.20and.20x86's.20alignment.20prefs/near/271787913\">said</a>:</p>\n<blockquote>\n<p>I kinda wish we could use const generics to let users specify the alignment exactly for whatever arcane reason but have a default.</p>\n</blockquote>\n<p>Is there some reason that having it in the type itself would be better for codegen than just letting them wrap it in a newtype with <code>repr(align(whatever))</code> to over-align and add padding?</p>\n</blockquote>\n<p>I mean mostly I just want layout details controllable like it's an associated constant instead of an attribute period.</p>",
        "id": 271788289,
        "sender_full_name": "Jubilee",
        "timestamp": 1644819374
    },
    {
        "content": "<p>Fwiw if you need some exotic layout I think you shouldn't be using vectors as your API then, you should load with your required layout and transmute those to vectors</p>",
        "id": 271788298,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1644819385
    },
    {
        "content": "<p>Well I am thinking of things like Vec3s.</p>",
        "id": 271788308,
        "sender_full_name": "Jubilee",
        "timestamp": 1644819407
    },
    {
        "content": "<p>Vectors have the explicit purpose of doing vectory things and not memory things</p>",
        "id": 271788310,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1644819420
    },
    {
        "content": "<p>which cause great amounts of gnashing and wailing of teeth.</p>",
        "id": 271788313,
        "sender_full_name": "Jubilee",
        "timestamp": 1644819426
    },
    {
        "content": "<p>I definitely would like a way to set align that's not an attribute but something that can come from a const generic, <span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span></p>",
        "id": 271788319,
        "sender_full_name": "scottmcm",
        "timestamp": 1644819437
    },
    {
        "content": "<p>...that's backwards but you get the idea.</p>",
        "id": 271788321,
        "sender_full_name": "Jubilee",
        "timestamp": 1644819441
    },
    {
        "content": "<p>Clearly we just need everyone to use homogeneous coordinates in their vectors everywhere, so they're just Vec4s ;)</p>",
        "id": 271788376,
        "sender_full_name": "scottmcm",
        "timestamp": 1644819503
    },
    {
        "content": "<p>lmao</p>",
        "id": 271788380,
        "sender_full_name": "Jubilee",
        "timestamp": 1644819511
    },
    {
        "content": "<p>I am definitely currently inclined to the GCF solution as our preferred default answer, though.</p>",
        "id": 271788385,
        "sender_full_name": "Jubilee",
        "timestamp": 1644819519
    },
    {
        "content": "<p>but...i want homogeneous coordinates in my 2D graphics...vec3</p>",
        "id": 271788392,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1644819547
    },
    {
        "content": "<p>I'm okay with any solution really if we think it's okay to say it's unspecified (but compatible with arrays)</p>",
        "id": 271788393,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1644819548
    },
    {
        "content": "<p>define \"compatible with arrays\"</p>",
        "id": 271788459,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1644819611
    },
    {
        "content": "<p>As defined before I meant, same size and greater alignment</p>",
        "id": 271788471,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1644819640
    },
    {
        "content": "<p>I feel like the guarantee that people will really want is things like \"on x86, <code>Simd&lt;f32, 4&gt;</code> has the same size+align as <code>__m128</code>\", which should be fine, because there's a limited set of those platform types.</p>",
        "id": 271788474,
        "sender_full_name": "scottmcm",
        "timestamp": 1644819643
    },
    {
        "content": "<p>Basically can implement AsRef</p>",
        "id": 271788476,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1644819650
    },
    {
        "content": "<p>Yeah, I think we have some flexibility for non-vendor types</p>",
        "id": 271788498,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1644819704
    },
    {
        "content": "<p>cuz <code>&amp;mut &amp;mut [f32; 35] -&gt; &amp;mut &amp;mut Simd&lt;f32, 35&gt;</code> being valid means align must be same as f32</p>",
        "id": 271788501,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1644819717
    },
    {
        "content": "<p>Yeah I just meant compatible in the vector to array direction, not opposite of course</p>",
        "id": 271788547,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1644819752
    },
    {
        "content": "<p>yeah, I think we should always cough politely at people trying to turn arrays into vectors without using a dedicated function or <code>read_unaligned</code>.</p>",
        "id": 271788556,
        "sender_full_name": "Jubilee",
        "timestamp": 1644819799
    },
    {
        "content": "<p>which means we will want to provide functions to make sure all those use cases can happen.</p>",
        "id": 271788610,
        "sender_full_name": "Jubilee",
        "timestamp": 1644819851
    },
    {
        "content": "<p>so, we want to guarantee <code>&amp;mut [Simd&lt;T, N&gt;; M] -&gt; &amp;mut [[T; N]; M]</code> is valid?</p>",
        "id": 271788619,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1644819894
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/SIMD.20vectors.20and.20x86's.20alignment.20prefs/near/271787986\">said</a>:</p>\n<blockquote>\n<p>do any of these answers complicate the world from the UCG point of view?</p>\n</blockquote>\n<p>I don't think so, since it's largely not talked about ABIs.</p>\n<p>Different alignments and paddings just fall under the normal UCG rules, as far as I can foresee.</p>",
        "id": 271788631,
        "sender_full_name": "scottmcm",
        "timestamp": 1644819913
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"229517\">@Jacob Lifshay</span> isn't that only possible if the vector alignment is that of T and no higher?</p>",
        "id": 271788711,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1644820043
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"229517\">Jacob Lifshay</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/SIMD.20vectors.20and.20x86's.20alignment.20prefs/near/271788619\">said</a>:</p>\n<blockquote>\n<p>so, we want to guarantee <code>&amp;mut [Simd&lt;T, N&gt;; M] -&gt; &amp;mut [[T; N]; M]</code> is valid?</p>\n</blockquote>\n<p>There's already <code>&amp;mut Simd&lt;T, N&gt; -&gt; &amp;mut [T; N]</code> via <code>AsMut</code>, and I don't think the extra level of arrays matter -- array layout is specified to have no padding, and there's things like <a href=\"https://doc.rust-lang.org/nightly/std/array/fn.from_mut.html\">https://doc.rust-lang.org/nightly/std/array/fn.from_mut.html</a> for general <code>&amp;mut T -&gt; &amp;mut [T; 1]</code>.</p>",
        "id": 271788713,
        "sender_full_name": "scottmcm",
        "timestamp": 1644820048
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/SIMD.20vectors.20and.20x86's.20alignment.20prefs/near/271788711\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"229517\">Jacob Lifshay</span> isn't that only possible if the vector alignment is that of T and no higher?</p>\n</blockquote>\n<p>I think that's why the previous example had <code>&amp;mut &amp;mut</code> -- just one is fine, but if you have two then things get complicated.</p>\n<p>(<code>&amp;mut T -&gt; &amp;mut U</code> does not imply <code>&amp;mut &amp;mut T -&gt; &amp;mut &amp;mut U</code>.)</p>",
        "id": 271788787,
        "sender_full_name": "scottmcm",
        "timestamp": 1644820170
    },
    {
        "content": "<blockquote>\n<p>so, we want to guarantee <code>&amp;mut [Simd&lt;T, N&gt;; M] -&gt; &amp;mut [[T; N]; M]</code> is valid?</p>\n</blockquote>\n<p>that implies size is same as array, but align of Simd can be higher, so long as no padding is introduced. just <code>&amp;mut Simd&lt;T, N&gt; -&gt; &amp;mut [T; N]</code> doesn't guarantee Simd has no padding, the padding would just not be accessible through the array reference.</p>",
        "id": 271789125,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1644820617
    },
    {
        "content": "<p>damn, apparently there's already RVV designs that have VLEN = 16384 (bits).</p>",
        "id": 271789828,
        "sender_full_name": "Jubilee",
        "timestamp": 1644821561
    },
    {
        "content": "<p>Just in case</p>",
        "id": 271789843,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1644821583
    },
    {
        "content": "<p>apparently the biggest permitted by RISC-V V is <code>Simd&lt;u8, 65536&gt;</code></p>",
        "id": 271790748,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1644822605
    },
    {
        "content": "<p>indeed.</p>",
        "id": 271790873,
        "sender_full_name": "Jubilee",
        "timestamp": 1644822806
    },
    {
        "content": "<p>oh,<br>\n<span class=\"user-mention\" data-user-id=\"229517\">@Jacob Lifshay</span> it's apparently actually 2^(XLEN-1)</p>",
        "id": 271858171,
        "sender_full_name": "Jubilee",
        "timestamp": 1644858971
    },
    {
        "content": "<p>not according to the <a href=\"https://github.com/riscv/riscv-v-spec/blob/v1.0/v-spec.adoc#2-implementation-defined-constant-parameters\">risc-v v spec v1.0</a>:</p>\n<blockquote>\n<p>The upper limit on VLEN allows software to know that indices will fit into 16 bits (largest VLMAX of 65,536 occurs for LMUL=8 and SEW=8 with VLEN=65,536). Any future extension beyond 64Kib per vector register will require new configuration instructions such that software using the old configuration instructions does not see greater vector lengths.</p>\n</blockquote>",
        "id": 271864108,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1644861673
    },
    {
        "content": "<p>in other words the largest vector supported by a single instruction is 65536 elements</p>",
        "id": 271864262,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1644861727
    },
    {
        "content": "<p>hmm.</p>",
        "id": 271878120,
        "sender_full_name": "Jubilee",
        "timestamp": 1644867646
    },
    {
        "content": "<p>Okay I spotted the 2^(XLEN-1) bit here: <a href=\"https://github.com/riscv/riscv-v-spec/blob/v1.0/v-spec.adoc#153-vfirst-find-first-set-mask-bit\">https://github.com/riscv/riscv-v-spec/blob/v1.0/v-spec.adoc#153-vfirst-find-first-set-mask-bit</a></p>",
        "id": 271878187,
        "sender_full_name": "Jubilee",
        "timestamp": 1644867685
    },
    {
        "content": "<blockquote>\n<p>... as vector lengths will never exceed 2(XLEN-1) on any implementation.</p>\n</blockquote>",
        "id": 271879039,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1644868078
    },
    {
        "content": "<p>65536 never exceeds <code>2^(XLEN-1)</code></p>",
        "id": 271879109,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1644868100
    },
    {
        "content": "<p>Truuuuueeeee but this is phrased in a needlessly pedantic way.</p>",
        "id": 271879174,
        "sender_full_name": "Jubilee",
        "timestamp": 1644868147
    },
    {
        "content": "<p>:)</p>",
        "id": 271879215,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1644868168
    },
    {
        "content": "<p>Okay that phrasing came from this and predated the 64KiB limit. <a href=\"https://github.com/riscv/riscv-v-spec/issues/204\">https://github.com/riscv/riscv-v-spec/issues/204</a></p>",
        "id": 271880081,
        "sender_full_name": "Jubilee",
        "timestamp": 1644868595
    },
    {
        "content": "<p>Oh and speaking of eliminating padding:<br>\nI presume, without thinking about it too hard, we're basically in agreement that if <code>int&lt;N&gt;</code> becomes available, that <code>Simd&lt;int&lt;N&gt;, M&gt;</code> has the constraint that <code>N: N.is_power_of_two()</code>? At the very least?</p>",
        "id": 271891911,
        "sender_full_name": "Jubilee",
        "timestamp": 1644874421
    },
    {
        "content": "<p>uuh...it'd be very nice to have vectors of <code>i1</code> at least...other int types would likely be useful too</p>",
        "id": 271892138,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1644874539
    },
    {
        "content": "<p>i1 is a power of 2. it's 2^0. <span aria-label=\"relieved\" class=\"emoji emoji-1f60c\" role=\"img\" title=\"relieved\">:relieved:</span></p>",
        "id": 271892176,
        "sender_full_name": "Jubilee",
        "timestamp": 1644874561
    },
    {
        "content": "<p>it'd be nice to include non-power-of-2 types at some point, but not for a while</p>",
        "id": 271892289,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1644874615
    },
    {
        "content": "<p>e.g. unpacking r10g10b10a2 pixels where you'd likely want <code>u10</code> and <code>u2</code></p>",
        "id": 271892506,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1644874687
    },
    {
        "content": "<p>or r12g12b12a12</p>",
        "id": 271892719,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1644874735
    },
    {
        "content": "<p>unpacking into u16s?</p>",
        "id": 271892845,
        "sender_full_name": "Jubilee",
        "timestamp": 1644874762
    },
    {
        "content": "<p>maybe running through the sRGB transfer function to convert to f32</p>",
        "id": 271893197,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1644874832
    },
    {
        "content": "<p>Hmm, I could see potentially offering special functions for vector bit-packing and vector bit-unpacking instead.</p>",
        "id": 271893239,
        "sender_full_name": "Jubilee",
        "timestamp": 1644874844
    },
    {
        "content": "<p>well...imho we shouldn't rule out weird bit sizes, but can definitely put them on the back burner</p>",
        "id": 271893343,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1644874902
    },
    {
        "content": "<p>llvm <em>does</em> have defined semantics for what a <code>Simd&lt;int&lt;12&gt;, 14&gt;</code> means exactly</p>",
        "id": 271893491,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1644874981
    },
    {
        "content": "<p>I wouldn't rule them out <strong>entirely</strong>, I just wanted to temperature check while I work on something in the back of my head.<br>\nwhat lol seriously.</p>",
        "id": 271893534,
        "sender_full_name": "Jubilee",
        "timestamp": 1644875000
    },
    {
        "content": "<blockquote>\n<p>A bitcast from a vector type to a scalar integer type will see the elements being packed together (without padding). The order in which elements are inserted in the integer depends on endianess. For little endian element zero is put in the least significant bits of the integer, and for big endian element zero is put in the most significant bits.</p>\n</blockquote>",
        "id": 271893772,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1644875136
    },
    {
        "content": "<blockquote>\n<p>Using a vector such as <code>&lt;i4 1, i4 2, i4 3, i4 5&gt;</code> as an example, together with the analogy that we can replace a vector store by a bitcast followed by an integer store, we get this for big endian:</p>\n</blockquote>\n<blockquote>\n<p>```<br>\n%val = bitcast &lt;4 x i4&gt; &lt;i4 1, i4 2, i4 3, i4 5&gt; to i16</p>\n<p>; Bitcasting from a vector to an integral type can be seen as<br>\n; concatenating the values:<br>\n;   %val now has the hexadecimal value 0x1235.</p>\n<p>store i16 %val, i16* %ptr</p>\n<p>; In memory the content will be (8-bit addressing):<br>\n;<br>\n;    [%ptr + 0]: 00010010  (0x12)<br>\n;    [%ptr + 1]: 00110101  (0x35)<br>\n```<br>\nThe same example for little endian:</p>\n<p>```<br>\n%val = bitcast &lt;4 x i4&gt; &lt;i4 1, i4 2, i4 3, i4 5&gt; to i16</p>\n<p>; Bitcasting from a vector to an integral type can be seen as<br>\n; concatenating the values:<br>\n;   %val now has the hexadecimal value 0x5321.</p>\n<p>store i16 %val, i16* %ptr</p>\n<p>; In memory the content will be (8-bit addressing):<br>\n;<br>\n;    [%ptr + 0]: 01010011  (0x53)<br>\n;    [%ptr + 1]: 00100001  (0x21)<br>\n```</p>\n</blockquote>",
        "id": 271894314,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1644875406
    },
    {
        "content": "<p>sadness...multi-line code blocks in quoted sections don't work</p>",
        "id": 271894465,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1644875492
    },
    {
        "content": "<p>you can use ````quote</p>",
        "id": 271894499,
        "sender_full_name": "Jubilee",
        "timestamp": 1644875519
    },
    {
        "content": "<p>thanks! fixed</p>",
        "id": 271895012,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1644875770
    },
    {
        "content": "<p>Mmm, I can't manipulate the labels in the <a href=\"https://github.com/rust-lang/project-portable-simd\">https://github.com/rust-lang/project-portable-simd</a> repo.</p>",
        "id": 272195221,
        "sender_full_name": "Jubilee",
        "timestamp": 1645054813
    }
]