[
    {
        "content": "<p>There’s an accepted MCP to add a Cranelift backend to rustc and gate builds on it working. This will have some implications for us wanting to land portable SIMD based on LLVM intrinsics on <code>nightly</code>. We should look into what gaps might exist in <code>cg_clif</code>’s <code>simd_*</code> intrinsics that would prevent us from landing <code>core::simd</code>.</p>",
        "id": 213358864,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1602715025
    },
    {
        "content": "<p>Is Cranelift still just x86?</p>",
        "id": 213359076,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1602715159
    },
    {
        "content": "<p>one option is to temporarily disable some functions on non-LLVM backends</p>",
        "id": 213360234,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1602715945
    },
    {
        "content": "<p>I don't know about cg_clif, but cranelift itself also supports ARM (icr if it's aarch64 and/or armv7) and RISC-V</p>",
        "id": 213360300,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1602716000
    },
    {
        "content": "<p>Is the intention of cranelift still just for debug?  I think we could write equivalents too all llvm intrinsics with plain rust (not SIMD) if we must</p>",
        "id": 213360421,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1602716088
    },
    {
        "content": "<p>we'd need to have cfg available for codegen awareness</p>",
        "id": 213360467,
        "sender_full_name": "Lokathor",
        "timestamp": 1602716121
    },
    {
        "content": "<p>LLVM has a massive API surface area that I doubt we'll see replicated any time soon in cranelift</p>",
        "id": 213360481,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1602716135
    },
    {
        "content": "<p>Will rustc ship with a variant of std compiled for cranelift?</p>",
        "id": 213360561,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1602716172
    },
    {
        "content": "<p>that's not yet been decided, and certainly I don't expect that to be the case for some time on stable at least (nightly might be different)</p>",
        "id": 213360662,
        "sender_full_name": "simulacrum",
        "timestamp": 1602716264
    },
    {
        "content": "<p>I'm not sure that std needs to be compiled <em>for</em> cranelift though</p>",
        "id": 213360674,
        "sender_full_name": "simulacrum",
        "timestamp": 1602716280
    },
    {
        "content": "<p>afaik, abi wise llvm and cranelift should be compatible</p>",
        "id": 213360717,
        "sender_full_name": "simulacrum",
        "timestamp": 1602716289
    },
    {
        "content": "<p>iirc we don't currently ship llvm ir in std but I could be wrong</p>",
        "id": 213360745,
        "sender_full_name": "simulacrum",
        "timestamp": 1602716314
    },
    {
        "content": "<p>(maybe for LTO?)</p>",
        "id": 213360753,
        "sender_full_name": "simulacrum",
        "timestamp": 1602716320
    },
    {
        "content": "<p>Well, my thought is that we are using a large number of llvm intrinsics, and cfg won't help if it's only compiled once</p>",
        "id": 213360754,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1602716322
    },
    {
        "content": "<p>to my recollection, everyone has been pretty opposed to cfg's on codegen backend</p>",
        "id": 213360795,
        "sender_full_name": "simulacrum",
        "timestamp": 1602716367
    },
    {
        "content": "<p>I hope that we can have Rust-level intrinsics that are uniform regardless of backend</p>",
        "id": 213360808,
        "sender_full_name": "simulacrum",
        "timestamp": 1602716381
    },
    {
        "content": "<p>Interesting.  My understanding was that the goal was to move away from platform-intrinsics towards llvm intrinsics, but maybe I got that wrong</p>",
        "id": 213360912,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1602716415
    },
    {
        "content": "<p>well we're calling platform intrinsics that have llvm based names, so i sure don't expect cranelift to use those same names. And stdarch also has this issue.</p>",
        "id": 213360931,
        "sender_full_name": "Lokathor",
        "timestamp": 1602716429
    },
    {
        "content": "<p>That may have also predated cranelift entirely</p>",
        "id": 213360932,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1602716429
    },
    {
        "content": "<p>Reexporting vendor intrinsics through rustc instead of std seems monumental though maybe necessary</p>",
        "id": 213361098,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1602716544
    },
    {
        "content": "<p>i don't know what you mean by that</p>",
        "id": 213361157,
        "sender_full_name": "Lokathor",
        "timestamp": 1602716604
    },
    {
        "content": "<p>I think it doesn't really matter where you have the facade, whether that's in rustc or in std it seems like about the same amount of code/pain?</p>",
        "id": 213361198,
        "sender_full_name": "simulacrum",
        "timestamp": 1602716634
    },
    {
        "content": "<p>(presuming we have roughly 1:1 compat anyway)</p>",
        "id": 213361250,
        "sender_full_name": "simulacrum",
        "timestamp": 1602716648
    },
    {
        "content": "<p>Well in std it's super easy since you can just link to LLVM.  Maybe it can be done just as easily in the compiler</p>",
        "id": 213361276,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1602716673
    },
    {
        "content": "<p>not sure I follow, but it seems like it would be about equivalent</p>",
        "id": 213361318,
        "sender_full_name": "simulacrum",
        "timestamp": 1602716716
    },
    {
        "content": "<p>if it's in std, then std needs to have a cfg ability based on the codegen so that it knows what platform-intrinsics it can call or not. If letting people cfg based on codegen isn't something people want, then suddenly all of stdarch and stdsimd have to be based on work that's been injected to rustc, and then internally rustc needs to have the codegen cfg-ing happen there</p>",
        "id": 213361332,
        "sender_full_name": "Lokathor",
        "timestamp": 1602716739
    },
    {
        "content": "<p>but if we <em>do</em> just allow cfg based on codegenerator, then we don't need to move everything, we just need to add new versions of stuff in some places</p>",
        "id": 213361428,
        "sender_full_name": "Lokathor",
        "timestamp": 1602716795
    },
    {
        "content": "<p>One thing that makes the codegen in rustc a little non-trivial is that for cranelift it would need to do some codegen when lowering somewhere around HIR or MIR to generate implementations for things that LLVM provides in LLVM IR that cranelift might not</p>",
        "id": 213361598,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1602716919
    },
    {
        "content": "<p>Certainly possible just something to keep in mind I think</p>",
        "id": 213361631,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1602716948
    },
    {
        "content": "<p>Yeah, I agree that there's definitely tradeoffs between the two. I would be very hesitant in needing to cfg(cranelift) though, for correctness (rather than performance or \"cranelift just doesn't have atomics yet\" etc)</p>",
        "id": 213361852,
        "sender_full_name": "simulacrum",
        "timestamp": 1602717161
    },
    {
        "content": "<p>So for portable SIMD I think we're probably going to end up using hundreds  of llvm intrinsics so it's probably more individual functions than something like atomics, but I'm not really sure</p>",
        "id": 213362113,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1602717372
    },
    {
        "content": "<p>Well, for example, every single function <a href=\"https://github.com/rust-lang/stdarch/blob/master/crates/core_arch/src/x86/sse.rs#L1822\">here</a> in stdarch is calling an llvm specific intrinsic. So either you need to be able to cfg around that, or every one of those has to go into rustc for rustc to resolve. And then repeat for every other module in stdarch, and then repeat for even more content in stdsimd.</p>\n<p>For <code>stdarch</code> it's all in the \"correctness\" category. <code>stdsimd</code> could arguably make the case that it's a performance difference only.</p>",
        "id": 213362116,
        "sender_full_name": "Lokathor",
        "timestamp": 1602717375
    },
    {
        "content": "<p>I wonder if it would be possible to detect if you're using llvm intrinsics and only allow codegen to occur with llvm for that object file</p>",
        "id": 213362219,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1602717479
    },
    {
        "content": "<p>Yeah. It seems like most of this wouldn't really matter too much whether the cfg is explicit in stdarch/simd or in rustc; it's about the same code regardless. Maybe I'm wrongt hough.</p>",
        "id": 213362220,
        "sender_full_name": "simulacrum",
        "timestamp": 1602717481
    },
    {
        "content": "<p>I personally feel strongly that we want to put in the work to avoid splitting any Rust code into \"works on LLVM vs. works on cranelift\" (or any other backend)</p>",
        "id": 213362502,
        "sender_full_name": "simulacrum",
        "timestamp": 1602717547
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"312331\">@Caleb Zulawski</span> that \"already happens\", i'm assuming, because if you're on cranelift then it won't link</p>",
        "id": 213362508,
        "sender_full_name": "Lokathor",
        "timestamp": 1602717549
    },
    {
        "content": "<p>What I mean was even with a cranelift build, it would use llvm for stdarch and stdsimd, at least until cranelift supports those intrinsics</p>",
        "id": 213362614,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1602717618
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> we could make <code>target_codegen</code> be perma-unstable. This is one place where i'd be fine with it being unstable because anything you'd want to be calling based on that cfg you can just complain that there's not a normal non-cfg'd intrinsic for it</p>",
        "id": 213362619,
        "sender_full_name": "Lokathor",
        "timestamp": 1602717623
    },
    {
        "content": "<p>oh sure yeah</p>",
        "id": 213362658,
        "sender_full_name": "simulacrum",
        "timestamp": 1602717673
    },
    {
        "content": "<p>I just mean that I don't want \"stdsimd only works on LLVM\"</p>",
        "id": 213362662,
        "sender_full_name": "simulacrum",
        "timestamp": 1602717683
    },
    {
        "content": "<p>if it lowers to non-simd, for example, on cranelift that seems fine</p>",
        "id": 213362674,
        "sender_full_name": "simulacrum",
        "timestamp": 1602717698
    },
    {
        "content": "<p>one challenge there is the ABI of vector types</p>",
        "id": 213362758,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1602717740
    },
    {
        "content": "<p>that's a challenge with stdsimd implementing these vectors manually, i mean.</p>",
        "id": 213362829,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1602717803
    },
    {
        "content": "<p>Would it be possible to write a support library that only gets used with cranelift, similar to something like libgcc?  It seems odd to put what is effectively just a library inside codegen (then again this is sounding a lot like just using cfg)</p>",
        "id": 213362852,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1602717821
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"209168\">@Thom Chiovoloni</span> until cranelift has real simd, makeing it all just be literal arrays using the array abi is \"fine\"</p>",
        "id": 213362958,
        "sender_full_name": "Lokathor",
        "timestamp": 1602717879
    },
    {
        "content": "<p>assuming you dont need to call code that uses the right ABI...</p>",
        "id": 213363003,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1602717909
    },
    {
        "content": "<p>i don't think our stdsimd types are ffi safe in the general case. i agree it'd be a problem for stdarch though, so we should solve it once</p>",
        "id": 213363117,
        "sender_full_name": "Lokathor",
        "timestamp": 1602717973
    },
    {
        "content": "<p>Yeah, simd_ffi is an unstable feature</p>",
        "id": 213363151,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1602718006
    },
    {
        "content": "<p>also if we call code in libstd that has been compiled with LLVM</p>",
        "id": 213363189,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1602718047
    },
    {
        "content": "<p>would that... happen?</p>",
        "id": 213363239,
        "sender_full_name": "Lokathor",
        "timestamp": 1602718062
    },
    {
        "content": "<p>I think it is unclear at this point</p>",
        "id": 213363323,
        "sender_full_name": "simulacrum",
        "timestamp": 1602718082
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/cranelift.20backend/near/213360662\">said</a>:</p>\n<blockquote>\n<p>that's not yet been decided, and certainly I don't expect that to be the case for some time on stable at least (nightly might be different)</p>\n</blockquote>",
        "id": 213363382,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1602718089
    },
    {
        "content": "<p>It might be desirable, though, because e.g. you might want std to be super optimized and your end-user code to be compiled by cranelift for compile time wins</p>",
        "id": 213363405,
        "sender_full_name": "simulacrum",
        "timestamp": 1602718110
    },
    {
        "content": "<p>rip</p>",
        "id": 213363406,
        "sender_full_name": "Lokathor",
        "timestamp": 1602718110
    },
    {
        "content": "<p>realistically imo the solution space of \"use cranelift in rustc\" is pretty unexplored at least to my knowledge right now</p>",
        "id": 213363432,
        "sender_full_name": "simulacrum",
        "timestamp": 1602718137
    },
    {
        "content": "<p>i.e., most questions are not answered or really discussed in too much detail</p>",
        "id": 213363442,
        "sender_full_name": "simulacrum",
        "timestamp": 1602718151
    },
    {
        "content": "<p>i think a relatively small amont of stdlib content would work out getting an llvm benefit though, since a whole ton of stdlib is generic and codegen'd in the using module</p>",
        "id": 213363476,
        "sender_full_name": "Lokathor",
        "timestamp": 1602718179
    },
    {
        "content": "<p>yeah that sounds like what we'd want. that said it might be reasonable for cranelift to be able to support a type which is ABI-compatible with vector types even if it has to be transmuted to an array to work on it</p>",
        "id": 213363490,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1602718196
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> Yeah, sure. Though some of that might be mitigated by e.g. -Zshare-generics and (advanced) polymorphization that could e.g. intuit that Vec&lt;T&gt; is the same for all T of some size + alignment pairing or so</p>",
        "id": 213363575,
        "sender_full_name": "simulacrum",
        "timestamp": 1602718249
    },
    {
        "content": "<p>e.g. if they want to support vectorcall on windows they likely need that in some capacity (only up to sse2 though)</p>",
        "id": 213363585,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1602718253
    },
    {
        "content": "<p>til -Z share-generics — wanted that for ages</p>",
        "id": 213363695,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1602718324
    },
    {
        "content": "<p>i can't find the tracker for share-generics or why i wouldn't turn it on all the time</p>",
        "id": 213365052,
        "sender_full_name": "Lokathor",
        "timestamp": 1602719546
    },
    {
        "content": "<p>It's also not listed in the unstable book's doc section on flags <a href=\"https://doc.rust-lang.org/unstable-book/compiler-flags.html\">https://doc.rust-lang.org/unstable-book/compiler-flags.html</a></p>\n<p>EDIT: huh -Z help shows that essentially none of these are lol</p>",
        "id": 213365082,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1602719590
    },
    {
        "content": "<p>\"rust always has high quality documentation\"</p>",
        "id": 213365278,
        "sender_full_name": "Lokathor",
        "timestamp": 1602719799
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/131828-t-compiler/topic/cranelift.20backend.20work/near/213358101\">said</a>:</p>\n<blockquote>\n<p>I hope most if not all of the operations used by portable simd could use (newly introduced) <code>simd_*</code> platform intrinsics that are architecture and vector size independent. This would allow easy emulation of them implemented once per operation.</p>\n</blockquote>\n<p>Do these exist already, or are they an anticipated TODO?</p>",
        "id": 213366000,
        "sender_full_name": "Jubilee",
        "timestamp": 1602720493
    },
    {
        "content": "<p>I think shared generics can't be inlined or so? Not sure</p>",
        "id": 213366016,
        "sender_full_name": "simulacrum",
        "timestamp": 1602720514
    },
    {
        "content": "<p>Ah I didn't see that thread in t-compilers, didn't realize the plan is to go with platform-intrinsics.  We are definitely missing the majority of them</p>",
        "id": 213366281,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1602720787
    },
    {
        "content": "<p>I thought the idea was explicitly <em>not</em> to use platform-intrinsics</p>",
        "id": 213366384,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1602720874
    },
    {
        "content": "<p>Not sure if it's clear, platform-intrinsics is an ABI (?) provided by rustc, independent of LLVM</p>",
        "id": 213366422,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1602720927
    },
    {
        "content": "<p>I Also Have Many Questions.</p>",
        "id": 213366428,
        "sender_full_name": "Jubilee",
        "timestamp": 1602720936
    },
    {
        "content": "<p>Ah, sorry, i may have mixed up which extern \"...\" was which</p>",
        "id": 213366535,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1602721024
    },
    {
        "content": "<p>Yeah, it's definitely confusing</p>",
        "id": 213366551,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1602721047
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/stdsimd/blob/master/crates/core_simd/src/intrinsics.rs\">https://github.com/rust-lang/stdsimd/blob/master/crates/core_simd/src/intrinsics.rs</a></p>",
        "id": 213366556,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1602721052
    },
    {
        "content": "<p>I actually think moving to these would lower the complexity of stdsimd (and might actually be something rustc can do better than us)</p>",
        "id": 213366631,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1602721108
    },
    {
        "content": "<p>Yeah, I thought that was the plan.</p>",
        "id": 213366649,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1602721129
    },
    {
        "content": "<p>...OK,<br>\nwhat <strong>actually</strong> are platform intrinsics?</p>",
        "id": 213366675,
        "sender_full_name": "Jubilee",
        "timestamp": 1602721148
    },
    {
        "content": "<p>In that case we may need to submit a lot of code to the compiler <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 213366688,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1602721158
    },
    {
        "content": "<p>I think it's ironically the platform-independent ones, and not the platform-specific ones.</p>",
        "id": 213366695,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1602721169
    },
    {
        "content": "<p>Haha, yeah.</p>",
        "id": 213366701,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1602721177
    },
    {
        "content": "<p>They just lower to particular llvm instructions (and I guess cranelift in the future)</p>",
        "id": 213366763,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1602721206
    },
    {
        "content": "<p>That said I think its unrealistic for us to ship this on time if we have to wait for platform intrinsics for unsupported operations tbh. I'm hopeful we won't need to add much to the compiler.</p>",
        "id": 213366783,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1602721231
    },
    {
        "content": "<p>I tend to agree</p>",
        "id": 213366798,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1602721253
    },
    {
        "content": "<p>It does seem that way, but speculation is not an explanation, ultimately.<br>\nWe know they lower to LLVM instructions, but technically right now that does not actually differentiate them from <strong>all Rust code</strong> that is not literal inline assembly.</p>",
        "id": 213366804,
        "sender_full_name": "Jubilee",
        "timestamp": 1602721262
    },
    {
        "content": "<p>Well isn't that the point?</p>",
        "id": 213366830,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1602721297
    },
    {
        "content": "<p>They lower to plain llvm just like normal rust code</p>",
        "id": 213366847,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1602721310
    },
    {
        "content": "<p>They seem to be somewhat documented in RFC <a href=\"https://github.com/rust-lang/rust/issues/1199\">#1199</a></p>",
        "id": 213367024,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1602721479
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rfcs/blob/master/text/1199-simd-infrastructure.md\">https://github.com/rust-lang/rfcs/blob/master/text/1199-simd-infrastructure.md</a></p>",
        "id": 213367034,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1602721497
    },
    {
        "content": "<p>Is it? There is an<br>\n0) abstract purpose for <code>extern \"platform-intrinsics\"</code><br>\n1) technical design for <code>extern \"platform-intrinsics\"</code><br>\n2) observed behavior for <code>\"platform-intrinsics\"</code></p>\n<p>And also an<br>\n3) abstract purpose for ordinary Rust code<br>\n4) technical design for ordinary Rust code<br>\n5) observed behavior for ordinary Rust code</p>\n<p>In case 2 and 5, the behavior is to lower to LLVM instructions, but in case 4, the design is to lower to MIR and then output to \"a codegen backend\", and LLVM just happens to be the only one right now.</p>",
        "id": 213367038,
        "sender_full_name": "Jubilee",
        "timestamp": 1602721499
    },
    {
        "content": "<p>In case 1, we kiiinda mostly bypass MIR, as I understand it?</p>",
        "id": 213367065,
        "sender_full_name": "Jubilee",
        "timestamp": 1602721542
    },
    {
        "content": "<p>It appears to work that way</p>",
        "id": 213367081,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1602721558
    },
    {
        "content": "<p>The RFC doesn't really discuss it but it looks like it goes all the way to codegen</p>",
        "id": 213367135,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1602721585
    },
    {
        "content": "<p>I believe that's also how std::intrinsics works</p>",
        "id": 213367167,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1602721630
    },
    {
        "content": "<p>mmh.</p>",
        "id": 213367173,
        "sender_full_name": "Jubilee",
        "timestamp": 1602721635
    },
    {
        "content": "<p>I don't really understand how the generics work (they're not really bounded, it somehow interacts with repr simd)</p>",
        "id": 213367228,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1602721682
    },
    {
        "content": "<p>Also in case 3, I presumptively assume Rust's FE is mostly meant to be indifferent to LLVM: it's mostly a convenient optimizer.</p>",
        "id": 213367268,
        "sender_full_name": "Jubilee",
        "timestamp": 1602721687
    },
    {
        "content": "<p>It's definitely informed by llvm, but yeah I think so</p>",
        "id": 213367334,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1602721747
    },
    {
        "content": "<p>Right, we're dating but we're not exclusive. <span aria-label=\"crab\" class=\"emoji emoji-1f980\" role=\"img\" title=\"crab\">:crab:</span> <span aria-label=\"heart\" class=\"emoji emoji-2764\" role=\"img\" title=\"heart\">:heart:</span>  <span aria-label=\"dragon\" class=\"emoji emoji-1f409\" role=\"img\" title=\"dragon\">:dragon:</span></p>",
        "id": 213367450,
        "sender_full_name": "Jubilee",
        "timestamp": 1602721857
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/cranelift.20backend/near/213362674\">said</a>:</p>\n<blockquote>\n<p>if it lowers to non-simd, for example, on cranelift that seems fine</p>\n</blockquote>\n<p>Having non-simd lowering seems generally useful.  I could imagine some targets only using that, for example.</p>\n<p>(No idea what the best way to pick it for cranelift would be, though.)</p>",
        "id": 213368109,
        "sender_full_name": "scottmcm",
        "timestamp": 1602722534
    },
    {
        "content": "<p>So there was in fact originally a platform-intrinsics crate. In 2019 January, it was removed.</p>",
        "id": 213370608,
        "sender_full_name": "Jubilee",
        "timestamp": 1602725139
    },
    {
        "content": "<p>Because the abstraction layer for implementing against LLVM was, at the time, perceived as unnecessary.</p>",
        "id": 213370689,
        "sender_full_name": "Jubilee",
        "timestamp": 1602725210
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/pull/57416\">https://github.com/rust-lang/rust/pull/57416</a></p>",
        "id": 213370775,
        "sender_full_name": "Jubilee",
        "timestamp": 1602725298
    },
    {
        "content": "<p>sounds like whoever said that has egg on their face now</p>",
        "id": 213370799,
        "sender_full_name": "Lokathor",
        "timestamp": 1602725333
    },
    {
        "content": "<blockquote>\n<p>This was originally attempted in <a href=\"https://github.com/rust-lang/rust/issues/57048\">#57048</a> but it was realized that we<br>\ncould fully remove the crate via the \"unadjusted\" ABI on intrinsics.<br>\nThis means that all intrinsics in stdsimd are implemented directly<br>\nagainst LLVM rather than using the abstraction layer provided here. That<br>\nends up meaning that this crate is no longer used at all.</p>\n<p>This crate developed long ago to implement the SIMD intrinsics, but we<br>\ndidn't end up using it in the long run. In that case let's remove it!</p>\n</blockquote>\n<p><em>Technically</em> correct.</p>",
        "id": 213370913,
        "sender_full_name": "Jubilee",
        "timestamp": 1602725443
    },
    {
        "content": "<p>Opened an ish. <a href=\"https://github.com/rust-lang/stdsimd/issues/40\">https://github.com/rust-lang/stdsimd/issues/40</a></p>",
        "id": 213371397,
        "sender_full_name": "Jubilee",
        "timestamp": 1602726097
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/labels/A-cranelift\">rustc issues regarding Cranelift</a> includes a couple ones regarding refactoring rustc's codegen internals that will hopefully help inform this issue, like <a href=\"https://github.com/rust-lang/rust/issues/45274\">https://github.com/rust-lang/rust/issues/45274</a> and <a href=\"https://github.com/rust-lang/rust/issues/56108\">https://github.com/rust-lang/rust/issues/56108</a></p>",
        "id": 213376108,
        "sender_full_name": "Jubilee",
        "timestamp": 1602731580
    },
    {
        "content": "<p>Also this <a href=\"https://github.com/rust-lang/rust/issues/77933\">https://github.com/rust-lang/rust/issues/77933</a></p>",
        "id": 213376314,
        "sender_full_name": "Jubilee",
        "timestamp": 1602731856
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/cranelift.20backend/near/213360674\">said</a>:</p>\n<blockquote>\n<p>I'm not sure that std needs to be compiled <em>for</em> cranelift though</p>\n</blockquote>\n<p>Yes it needs to. There are abi incompatibilities that I need to fix.</p>",
        "id": 213382352,
        "sender_full_name": "bjorn3",
        "timestamp": 1602740694
    },
    {
        "content": "<p>It seems like a bad overall use of developer time to implement workarounds for cranelift in <code>core::simd</code>/<code>std::simd</code> as opposed to putting the work into implementing portable SIMD operations in cranelift (even if using ALU to begin with in order to have an ALU fallback on the cranelift side).</p>",
        "id": 213388650,
        "sender_full_name": "Henri Sivonen",
        "timestamp": 1602747084
    },
    {
        "content": "<p>It also seems bad not to be able to make progress on portable SIMD due to cranelift not being ready. For that reason, I think it would be preferable to make <code>std::simd</code> unavailable for cranelift for now and treat resolving that as a blocker for stabilizing using cranelift as a back end as opposed to treating it as a blocker for <code>std::simd</code>. Adding a cranelift back end doesn't expand the expressiveness of <code>std</code> but <code>std::simd</code> does. In that sense, I think it's more important to let <code>std::simd</code> be unblocked than to let cranelift be unblocked.</p>",
        "id": 213388891,
        "sender_full_name": "Henri Sivonen",
        "timestamp": 1602747271
    },
    {
        "content": "<p><em>Even if</em> cranelift had a full SIMD support suite, we'd still need to either cfg in the crate source level between llvm calls and cranelift calls, or have the crate call a consistent api within rustc itself and then rustc calls either llvm or cranelift.</p>",
        "id": 213388936,
        "sender_full_name": "Lokathor",
        "timestamp": 1602747310
    },
    {
        "content": "<p>But i agree, it should be a blocker to cranelift that it can't support <code>stdsimd</code>, not the other way around.</p>",
        "id": 213389025,
        "sender_full_name": "Lokathor",
        "timestamp": 1602747365
    },
    {
        "content": "<p>Right. Furthermore, a substantial part of the point of putting <code>std::simd</code> in the standard library is that it allows the implementation of <code>std::simd</code> to vary internally per back end. Creating a <code>rustc</code>-level abstraction over both LLVM and cranelift would just move where the abstraction layer is.</p>",
        "id": 213389124,
        "sender_full_name": "Henri Sivonen",
        "timestamp": 1602747470
    },
    {
        "content": "<p>Arguably, moving the abstraction layer to <code>rustc</code> would make the abstraction layer even lower level and, therefore, likely more constraining for future changes than letting <code>core::simd</code>/<code>std::simd</code> be the committed-to abstraction layer.</p>",
        "id": 213389264,
        "sender_full_name": "Henri Sivonen",
        "timestamp": 1602747589
    },
    {
        "content": "<p>I <em>think</em> everyone is on the same page about the public api of stdsimd being the same across all targets and codegens</p>",
        "id": 213390119,
        "sender_full_name": "Lokathor",
        "timestamp": 1602748279
    },
    {
        "content": "<p>The only part we're left to wonder about is if the llvm/cranelift split is crate internal or compiler internal</p>",
        "id": 213390142,
        "sender_full_name": "Lokathor",
        "timestamp": 1602748304
    },
    {
        "content": "<p>Most <code>simd_*</code> platform intrinsics are directly translated to llvm intrinsics like <code>llvm.ceil.v2f32</code> by cg_llvm. It only applies a little bit of validation and infers the correct string for the <code>v2f32</code> part from the input type. The only <code>simd_*</code> intrinsics where this is not the case are those that directly use llvm instructions I think. Adding more <code>simd_*</code> intrinsics should be really easy. Because stdsimd should only use the platform independent llvm intrinsics I think, this means that everything stdsimd needs could be solved using <code>simd_*</code> intrinsics I think.</p>",
        "id": 213391748,
        "sender_full_name": "bjorn3",
        "timestamp": 1602749378
    },
    {
        "content": "<p>I think we should still allow for compile-time branches on compiler back end to work around back end bugs. For example, last I checked, <code>packed_simd</code> implements boolean reductions for ARMv7+NEON manually, because LLVM generated bad code for the reduction intrinsic. (Sure, the right way to fix would be to fix in LLVM, but it's impractical sometimes to wait for such fixes to propagate to rustc.)</p>",
        "id": 213399988,
        "sender_full_name": "Henri Sivonen",
        "timestamp": 1602754364
    },
    {
        "content": "<p>Could that workaround be implemented in cg_llvm?</p>",
        "id": 213400066,
        "sender_full_name": "bjorn3",
        "timestamp": 1602754419
    },
    {
        "content": "<p>Possibly. I'm not familiar enough with cg_llvm to say.</p>",
        "id": 213400143,
        "sender_full_name": "Henri Sivonen",
        "timestamp": 1602754447
    },
    {
        "content": "<p>(The performance of boolean reductions on 32-bit ARM was the last blocker for Firefox to migrate from <code>simd</code> to <code>packed_simd</code>, which is why I happen to know about that hack.)</p>",
        "id": 213400285,
        "sender_full_name": "Henri Sivonen",
        "timestamp": 1602754545
    },
    {
        "content": "<p>While something like <code>#[cfg(codegen_backend)]</code> would work, it would require a PR to the respective project when cg_clif changes something, thus slowing down development.</p>",
        "id": 213400360,
        "sender_full_name": "bjorn3",
        "timestamp": 1602754572
    },
    {
        "content": "<p>i don't understand why that cfg would place requirements on cranelift</p>",
        "id": 213458309,
        "sender_full_name": "Lokathor",
        "timestamp": 1602782356
    },
    {
        "content": "<p>When using <code>#[cfg]</code> there would be a special code path for cg_clif. If I change cg_clif such that that code path doesn't work anymore I would have to wait for upstream to first change the code path before I can merge the cg_clif change.</p>",
        "id": 213458630,
        "sender_full_name": "bjorn3",
        "timestamp": 1602782513
    },
    {
        "content": "<p>Ah, you're saying that <code>cg_clif</code> is a module in the main <code>rustc</code> repo, and so it and the appropriate rustc changes can all be one PR. i see</p>",
        "id": 213458971,
        "sender_full_name": "Lokathor",
        "timestamp": 1602782659
    },
    {
        "content": "<p>No, that is not what I said.</p>",
        "id": 213459030,
        "sender_full_name": "bjorn3",
        "timestamp": 1602782688
    },
    {
        "content": "<p>well, <em>either</em> rustc internals or stdsimd need to cfg based on cranelift or llvm, that's unavoidable</p>",
        "id": 213459129,
        "sender_full_name": "Lokathor",
        "timestamp": 1602782735
    },
    {
        "content": "<p>so, given that, i'm not clear on what you're saying</p>",
        "id": 213459159,
        "sender_full_name": "Lokathor",
        "timestamp": 1602782753
    },
    {
        "content": "<p>In the ideal case there would be a codegen backend independent set of intrinsics used by stdsimd. (<code>extern \"platform-intrinsic\" fn simd_*();</code>) Both cg_llvm and cg_clif each can then lower it in their own way.</p>",
        "id": 213459382,
        "sender_full_name": "bjorn3",
        "timestamp": 1602782871
    },
    {
        "content": "<p>Ah, so cg_clif would actually get a message like \"and now do simd_add\", and it'd be a portable op name like that, then cg_clif would decide what to do with that internally? Okay, that makes sense</p>",
        "id": 213459586,
        "sender_full_name": "Lokathor",
        "timestamp": 1602782952
    },
    {
        "content": "<p>Yes. <code>simd_add</code> and a couple of others already exist, but there are some operations for which there isn't any \"platform-intrinsic\" yet.</p>",
        "id": 213459763,
        "sender_full_name": "bjorn3",
        "timestamp": 1602783013
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/stdarch/blob/master/crates/core_arch/src/simd_llvm.rs\">https://github.com/rust-lang/stdarch/blob/master/crates/core_arch/src/simd_llvm.rs</a></p>",
        "id": 213459809,
        "sender_full_name": "bjorn3",
        "timestamp": 1602783038
    },
    {
        "content": "<p>right, i just thought that they got converted to codegen-specific operations <em>before</em> sending the info to the codegen. that's where the confusion was</p>",
        "id": 213459931,
        "sender_full_name": "Lokathor",
        "timestamp": 1602783093
    },
    {
        "content": "<p>When stdsimd and cranelift are both in rustc but unstable, is it possible for them to be incompatible features?  Like you can use one but not both?  And then once both are mature enough they would be compatible (and eventually stable)</p>",
        "id": 213461851,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1602783877
    },
    {
        "content": "<p>I think that would help keep it from becoming a race to stabilization, because the compatibility would probably need to be resolved before it even gets to stabilization</p>",
        "id": 213462137,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1602783975
    },
    {
        "content": "<p>And could be done piecemeal</p>",
        "id": 213462169,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1602783990
    },
    {
        "content": "<p>That could work, but it would require me to patch libcore once again to remove the stdsimd include once stdsimd gets included in libcore.</p>",
        "id": 213462341,
        "sender_full_name": "bjorn3",
        "timestamp": 1602784052
    },
    {
        "content": "<p>well, i think that your bigger concern is <code>stdarch</code></p>",
        "id": 213462922,
        "sender_full_name": "Lokathor",
        "timestamp": 1602784269
    },
    {
        "content": "<p>because that's already stable</p>",
        "id": 213462956,
        "sender_full_name": "Lokathor",
        "timestamp": 1602784276
    },
    {
        "content": "<p>Yeah. Just getting enough support for regex and rand was a pain. My hope is that by having stdsimd build on a non-infinite set of \"platform-intrinsics\" it would be a lot easier to support it. If most crates then switch to stdsimd, that pretty much solves the problem for me. Even if it is still possible to use stdarch.</p>",
        "id": 213463398,
        "sender_full_name": "bjorn3",
        "timestamp": 1602784427
    },
    {
        "content": "<p>Right, I'm just suggesting we start with llvm intrinsics in stdsimd until we can PR all of the changes to rustc</p>",
        "id": 213464177,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1602784690
    },
    {
        "content": "<p>Sounds good!</p>",
        "id": 213468356,
        "sender_full_name": "bjorn3",
        "timestamp": 1602786688
    },
    {
        "content": "<p>I’ve started looking into this properly for the MCP and a lot of the prior discussion is starting to make a lot more sense now 🙂 It looks like we’ve been back and forth on LLVM intrinsics for a couple years now, thanks for your patience and persistence in driving the needs of alternative backends over all that time <span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span>! It seems like <code>extern “platform-intrinsic”</code> is already a base to build off, we’re just missing a few <code>simd_*</code> intrinsics, right? I imagine we’ll be considering getting <code>stdsimd</code> into <code>nightly</code> blocked on replacing all of our direct LLVM intrinsics with <code>simd_*</code> ones? I wonder if that will fix our RISC-V issue too 😄</p>",
        "id": 215190496,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1604148933
    },
    {
        "content": "<blockquote>\n<p>It seems like <code>extern “platform-intrinsic”</code> is already a base to build off, we’re just missing a few <code>simd_*</code> intrinsics, right?</p>\n</blockquote>\n<p>Yes. Over time I already have ported some of the vendor intrinsics in <code>core::arch</code> to use <code>extern \"platform-intrinsics\"</code>. Some of the remaining intrinsics either don't have a <code>platform-intrinsic</code> counterpart yet, are so specific to the respective arch that it likely won't ever get one, or for float intrinsics the <code>platform-intrinsic</code> counterpart behaves a bit differently in edge cases like NaN, denormals or negative zero. Except for the not yet existence of some <code>platform-intrinsic</code>s, none of the former problems should affect portable simd, as portable simd is roughly the common denominator between architectures and I expect won't guarantee that the behavior matches that of the native architecture.</p>",
        "id": 215190803,
        "sender_full_name": "bjorn3",
        "timestamp": 1604149375
    },
    {
        "content": "<p>Opened an MCP: <a href=\"https://github.com/rust-lang/compiler-team/issues/381\">https://github.com/rust-lang/compiler-team/issues/381</a></p>",
        "id": 215569663,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1604490005
    },
    {
        "content": "<p>Looks great to me!</p>",
        "id": 215571230,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1604491253
    },
    {
        "content": "<p>Discussion is happening over in <a class=\"stream-topic\" data-stream-id=\"233931\" href=\"/#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/MCP.3A.20More.20Cranelift-friendly.20portable.20SIM.E2.80.A6.20compiler-team.23381\">#t-compiler/major changes &gt; MCP: More Cranelift-friendly portable SIM… compiler-team#381</a></p>",
        "id": 215676011,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1604559059
    },
    {
        "content": "<p>As of <a href=\"https://github.com/bjorn3/rustc_codegen_cranelift/issues/1189\">bjorn3/rustc_codegen_cranelift#1189</a> all integer tests of stdsimd pass with cg_clif.</p>",
        "id": 247136313,
        "sender_full_name": "bjorn3",
        "timestamp": 1627234710
    },
    {
        "content": "<p>That is amazing news</p>",
        "id": 247136401,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627234857
    },
    {
        "content": "<p>Is there a good guide somewhere with the list of cranelift instrinsics? Similar to the LLVM language reference?</p>",
        "id": 247136621,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627235187
    },
    {
        "content": "<p>Cranelift doesn't have any intrinsics. It only has instructions. You can find the full list of instructions at <a href=\"https://docs.rs/cranelift-codegen/0.75.0/cranelift_codegen/ir/trait.InstBuilder.html\">https://docs.rs/cranelift-codegen/0.75.0/cranelift_codegen/ir/trait.InstBuilder.html</a>. Many (theoretically) work on both integers and vectors. I say theoretically as it isn't implemented yet for certain instructions.</p>",
        "id": 247136709,
        "sender_full_name": "bjorn3",
        "timestamp": 1627235287
    },
    {
        "content": "<p>That's exactly what I was looking for, thanks.  I was looking to add a byteswap intrinsic to rustc--at first glance doesn't look like there is one in cranelift (but of course it can be a shuffle).</p>",
        "id": 247136832,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627235500
    },
    {
        "content": "<p>I'd be curious to see which float tests do not have the same -0 or NaN results, I think most of the tests should be flexible enough to allow variations of the correct result</p>",
        "id": 247136951,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627235643
    },
    {
        "content": "<p>This is the cg_clif implementation of byteswap: <a href=\"https://github.com/bjorn3/rustc_codegen_cranelift/blob/356360836e128e1d1eb11caf6ff5186efb211960/src/intrinsics/mod.rs#L729-L807\">https://github.com/bjorn3/rustc_codegen_cranelift/blob/356360836e128e1d1eb11caf6ff5186efb211960/src/intrinsics/mod.rs#L729-L807</a></p>",
        "id": 247137293,
        "sender_full_name": "bjorn3",
        "timestamp": 1627236071
    },
    {
        "content": "<p>Sorry--I meant vector byteswap</p>",
        "id": 247137312,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627236114
    },
    {
        "content": "<p>I know</p>",
        "id": 247137381,
        "sender_full_name": "bjorn3",
        "timestamp": 1627236224
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/cranelift.20backend/near/247136951\">said</a>:</p>\n<blockquote>\n<p>I'd be curious to see which float tests do not have the same -0 or NaN results, I think most of the tests should be flexible enough to allow variations of the correct result</p>\n</blockquote>\n<p>I mean in the presence of NaN some operations do or don't return the NaN.</p>",
        "id": 247137544,
        "sender_full_name": "bjorn3",
        "timestamp": 1627236440
    }
]