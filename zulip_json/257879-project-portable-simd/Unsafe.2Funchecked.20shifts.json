[
    {
        "content": "<p>Heya! I was wondering if there's any ideas/plans to make an unsafe/unchecked shift. I have a pretty dense loop with a lot of shifts and the overshift checks are adding a lot of branches. Sadly a lot of the variables are provably constrained to &lt;word size, but I can't convince the compiler about that. Was maybe thinking of adding an unsafe/unchecked shift which requires the user to constrain the inputs themselves?</p>",
        "id": 268931392,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1642819668
    },
    {
        "content": "<p>It hasn't been synced to nightly yet, but soon shifts won't have any branches, and will instead wrap</p>",
        "id": 268931700,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1642820047
    },
    {
        "content": "<p>So it won't be quite as fast as completely unchecked necessarily, but should be much better</p>",
        "id": 268931711,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1642820069
    },
    {
        "content": "<p>I might like to have both wraps and overshifting. I know AVX-512 overshifts to zeros and I use some of those semantics.</p>",
        "id": 268931736,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1642820117
    },
    {
        "content": "<p>I think the only way to do this would be to have a wrapping (&amp; WORD-1) and overshifting implementation that maybe are specialized to do the cheap version on hardware? Like in my case I know I'm only really going to run compute on AVX, but it's still _nice_ to be able to share/use my code on different machines</p>",
        "id": 268931796,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1642820172
    },
    {
        "content": "<p>Idk if LLVM is smart enough to know that behavior and handle the specialization if you just write naive implementations for both</p>",
        "id": 268931810,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1642820200
    },
    {
        "content": "<p>Yeah I haven't looked into it to that extent</p>",
        "id": 268931825,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1642820240
    },
    {
        "content": "<p>Sadly the defined behavior varies so much by arch that without tuning I'd expect emulated wrapping on x86 would lead to an additional and for every single shift</p>",
        "id": 268931830,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1642820244
    },
    {
        "content": "<p>We could likely add functions for both, but it's also confusing because they're negligibly different and I'm not sure which should be the default</p>",
        "id": 268931847,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1642820277
    },
    {
        "content": "<p>Yeah, it's an additional and, which is at least an improvement over branching</p>",
        "id": 268931926,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1642820372
    },
    {
        "content": "<p>Yeah, it's kinda tough. I'd just do whatever Rust has done as default for scalar things, make the other one an option. It's tough cause I have some really dense integer and bitwise logic that I'm really keeping my eyes on the codegen right now</p>",
        "id": 268931931,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1642820383
    },
    {
        "content": "<p>absolutely</p>",
        "id": 268931934,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1642820386
    },
    {
        "content": "<p>I might just rearchitect my code such that LLVM sees the creation of the shift amount (and will provably know it's in bounds), but to get good code reuse I'd have to use macros for that</p>",
        "id": 268932041,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1642820426
    },
    {
        "content": "<p>I'm really pushing the limits here with codegen, I'm replacing some pretty specialized handwritten asm and so far the LLVM code is generically better (eg. better use of complex instructions and pipelining) but has some warts with checking things that I know are provable as a developer</p>",
        "id": 268932085,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1642820465
    },
    {
        "content": "<p>An assert before the loop might help hint to LLVM that it's within bounds too</p>",
        "id": 268932168,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1642820527
    },
    {
        "content": "<p>stdsimd is just so huge for me because I target some pretty heavy AVX-512 compute, but it sucks that I can't share my code with people. So I'm really trying to keep both the perf, but also portability</p>",
        "id": 268932171,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1642820531
    },
    {
        "content": "<p>Yeah, I wanted to do that but sadly the assert is then checked and adds the branch there. I really need like <code>unsafe_assert!()</code> that tells the compiler that the expression is true,</p>",
        "id": 268932195,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1642820560
    },
    {
        "content": "<p>The problem is the shift amount is computed in a function, then cached in a <code>Guard</code> variable, and when laundered through memory LLVM believes it to be unconstrained</p>",
        "id": 268932215,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1642820593
    },
    {
        "content": "<p>If you want to try something slightly silly,</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[repr(u32)]</span><span class=\"w\"></span>\n<span class=\"k\">enum</span> <span class=\"nc\">ShiftAmount32</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">_0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">_1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">_2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">_3</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.,</span><span class=\"w\"> </span><span class=\"n\">_31</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Dunno if it'd work, but rustc will put range metadata on the <code>load</code>.</p>",
        "id": 268932277,
        "sender_full_name": "scottmcm",
        "timestamp": 1642820662
    },
    {
        "content": "<p>Actually yeah, this might work really well. Should have lossless conversion into this at store time since the compiler will know the constraints when the variable is stored</p>",
        "id": 268932311,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1642820712
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"356799\">Brandon Falk</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/Unsafe.2Funchecked.20shifts/near/268932195\">said</a>:</p>\n<blockquote>\n<p>I really need like <code>unsafe_assert!()</code> that tells the compiler that the expression is true,</p>\n</blockquote>\n<p>For experimentation you could try <code>std::intrinsics::assume</code> on nightly.</p>\n<p>If that works, then you could consider <code>if !(whatever_you_expect) { unsafe { std::hint::unreachable_unchecked() } }</code> for <code>unsafe_assert!</code>.</p>",
        "id": 268932434,
        "sender_full_name": "scottmcm",
        "timestamp": 1642820850
    },
    {
        "content": "<p>For some reason I feel I remember that unreachable unchecked would sometimes throw in a ud2, but probably not in this case, I'll play with it<br>\nRight now I'm usually okay with a 10x inflation of code to get away without <code>unsafe</code> so I'll probably try the enum first</p>",
        "id": 268932523,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1642820927
    },
    {
        "content": "<p>I use <code>rg unsafe</code> when I audit my code, the fewer thigns to check during audits the better</p>",
        "id": 268932543,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1642820955
    },
    {
        "content": "<p>For experimenting, <code>-Z trap-unreachable=no</code> will make it not put the <code>ud2</code>s.</p>",
        "id": 268932644,
        "sender_full_name": "scottmcm",
        "timestamp": 1642821066
    },
    {
        "content": "<p>TIL, thanks!</p>",
        "id": 268932648,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1642821073
    },
    {
        "content": "<p>But kudos for sticking to safe code.  It's impressive what LLVM can do these days.  (My favourite example recently is removing the manual vectorization in favour of safe code, and it actually being faster in <a href=\"https://github.com/rust-lang/rust/issues/90821\">#90821</a> )</p>",
        "id": 268932995,
        "sender_full_name": "scottmcm",
        "timestamp": 1642821522
    },
    {
        "content": "<p>Yeah, I've spent most of the past ~10 years of dev looking at the codegen, I've gotten weirdly good at coercing the compiler to do things. That's what I think safe code is, just making things computable enough for the compiler and holding it's hand a bit.</p>",
        "id": 268933020,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1642821583
    },
    {
        "content": "<p>I wrote a md5 implementation with stdsimd using naive bitwise operations and LLVM correctly generates the <code>ternlogd</code> constants for the ternary ops and it feels so good</p>",
        "id": 268933074,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1642821613
    },
    {
        "content": "<p>This new project is effectively a generic emulator in stdsimd where you specify <code>IL&lt;word size, lanes&gt;</code> and so far there have been some hiccups but it's been expressible. That being said, it's some extremely dense/hard code. I have to use a lot of macros to keep code reuse up since the bug risk is so high I can't duplicate code like I might in some situations</p>",
        "id": 268933118,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1642821704
    },
    {
        "content": "<p>Definitely a lot of fun! Just wrote the memory manager last night and replaced my naive (testing) implementation, scalar assembly implementation, and vector assembly implementation with a single stdsimd implementation that can be either scalar or vector, and has the upside of being safe code and much easier to test/fix than handwritten asm</p>",
        "id": 268933179,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1642821777
    },
    {
        "content": "<p>This is the brainchild of about 3 years of thinking, just finally putting pen to paper. The time to write this is not a concern to me, so I'm trying to pull out all the coding stops :D</p>",
        "id": 268933196,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1642821810
    },
    {
        "content": "<p>Whoa, it kind of works<br>\n<a href=\"https://rust.godbolt.org/z/b5or3WGoh\">https://rust.godbolt.org/z/b5or3WGoh</a></p>",
        "id": 268934335,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1642823356
    },
    {
        "content": "<p>Weirdly, going to a wider lane size or smaller element size leads to really bad code gen. <code>u8,8</code> produces scalar code with branches it's absolutely terrible hmm</p>",
        "id": 268934355,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1642823392
    },
    {
        "content": "<p>Feels like it's probably expanding inside LLVM, hitting an unroll limit, and collapsing. OH. I think I know what this is. This is the way the bounds are checked I think</p>",
        "id": 268934409,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1642823417
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"#\"><pre><span></span><code>                    fn shl(self, rhs: Self) -&gt; Self::Output {\n                        // TODO there is probably a better way of doing this\n                        if rhs.as_array()\n                            .iter()\n                            .copied()\n                            .any(invalid_shift_rhs)\n                        {\n                            panic!(\"attempt to shift left with overflow\");\n                        }\n                        unsafe { intrinsics::simd_shl(self, rhs) }\n                    }```\n</code></pre></div>",
        "id": 268934441,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1642823489
    },
    {
        "content": "<p>Yeah, I'll look at the new code. The to_array() check I would imagine expands inside LLVM and probably puts some major pressure on some of the constant limits of unroll/optimization depths for certain things</p>",
        "id": 268934453,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1642823520
    },
    {
        "content": "<p>I'm surprised it can't do this for <code>u8, 8</code></p>",
        "id": 268934500,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1642823539
    },
    {
        "content": "<p><code>u16, 32</code> emits a call to core simd shift ops, oooof</p>",
        "id": 268934524,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1642823580
    },
    {
        "content": "<p>Oh wow yeah <code>u16, 32</code> is unusable codegen LOL</p>",
        "id": 268934614,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1642823669
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"example\"><pre><span></span><code>        push    rbp\n        mov     rbp, rsp\n        push    rbx\n        and     rsp, -64\n        sub     rsp, 128\n        mov     rbx, rdi\n        vmovaps zmm0, zmmword ptr [rdx]\n        movzx   eax, byte ptr [rsi]\n        vpbroadcastw    zmm1, eax\n        vmovdqa64       zmmword ptr [rsp], zmm1\n        mov     rsi, rsp\n        call    core::core_simd::ops::&lt;impl core::ops::bit::Shl for core::core_simd::vector::Simd&lt;u16,_&gt;&gt;::shl\n        mov     rax, rbx\n        lea     rsp, [rbp - 8]\n        pop     rbx\n        pop     rbp\n        vzeroupper\n        ret\n\ncore::core_simd::ops::&lt;impl core::ops::bit::Shl for core::core_simd::vector::Simd&lt;u16,_&gt;&gt;::shl:\n        sub     rsp, 56\n        cmp     word ptr [rsi], 15\n        ja      .LBB4_33\n        cmp     word ptr [rsi + 2], 15\n        ja      .LBB4_33\n        cmp     word ptr [rsi + 4], 15\n        ja      .LBB4_33\n        cmp     word ptr [rsi + 6], 15\n        ja      .LBB4_33\n        cmp     word ptr [rsi + 8], 15\n        ja      .LBB4_33\n        cmp     word ptr [rsi + 10], 15\n        ja      .LBB4_33\n        cmp     word ptr [rsi + 12], 15\n        ja      .LBB4_33\n        cmp     word ptr [rsi + 14], 15\n        ja      .LBB4_33\n        cmp     word ptr [rsi + 16], 15\n        ja      .LBB4_33\n        cmp     word ptr [rsi + 18], 15\n        ja      .LBB4_33\n        cmp     word ptr [rsi + 20], 15\n        ja      .LBB4_33\n        cmp     word ptr [rsi + 22], 15\n        ja      .LBB4_33\n        cmp     word ptr [rsi + 24], 15\n        ja      .LBB4_33\n        cmp     word ptr [rsi + 26], 15\n        ja      .LBB4_33\n        cmp     word ptr [rsi + 28], 15\n        ja      .LBB4_33\n        cmp     word ptr [rsi + 30], 15\n        ja      .LBB4_33\n        cmp     word ptr [rsi + 32], 15\n        ja      .LBB4_33\n        cmp     word ptr [rsi + 34], 15\n        ja      .LBB4_33\n        cmp     word ptr [rsi + 36], 15\n        ja      .LBB4_33\n        cmp     word ptr [rsi + 38], 15\n        ja      .LBB4_33\n        cmp     word ptr [rsi + 40], 15\n        ja      .LBB4_33\n        cmp     word ptr [rsi + 42], 15\n        ja      .LBB4_33\n        cmp     word ptr [rsi + 44], 15\n        ja      .LBB4_33\n        cmp     word ptr [rsi + 46], 15\n        ja      .LBB4_33\n        cmp     word ptr [rsi + 48], 15\n        ja      .LBB4_33\n        cmp     word ptr [rsi + 50], 15\n        ja      .LBB4_33\n        cmp     word ptr [rsi + 52], 15\n        ja      .LBB4_33\n        cmp     word ptr [rsi + 54], 15\n        ja      .LBB4_33\n        cmp     word ptr [rsi + 56], 15\n        ja      .LBB4_33\n        cmp     word ptr [rsi + 58], 15\n        ja      .LBB4_33\n        cmp     word ptr [rsi + 60], 15\n        ja      .LBB4_33\n        cmp     word ptr [rsi + 62], 15\n        ja      .LBB4_33\n        vpsllvw zmm0, zmm0, zmmword ptr [rsi]\n        vmovdqa64       zmmword ptr [rdi], zmm0\n        add     rsp, 56\n        vzeroupper\n        ret\n.LBB4_33:\n        lea     rax, [rip + .L__unnamed_1]\n        mov     qword ptr [rsp + 8], rax\n        mov     qword ptr [rsp + 16], 1\n        mov     qword ptr [rsp + 24], 0\n        lea     rax, [rip + .L__unnamed_2]\n        mov     qword ptr [rsp + 40], rax\n        mov     qword ptr [rsp + 48], 0\n        lea     rsi, [rip + .L__unnamed_3]\n        lea     rdi, [rsp + 8]\n        vzeroupper\n        call    qword ptr [rip + core::panicking::panic_fmt@GOTPCREL]\n        ud2\n</code></pre></div>",
        "id": 268934625,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1642823692
    },
    {
        "content": "<p>Looks like this is all fixed with the new semantics of masking with the git version of portable simd :D</p>",
        "id": 268937052,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1642827018
    },
    {
        "content": "<p>And gets removed with the <code>ShiftAmount</code> enum as well, so that's a reasonable workaround for removing the and</p>",
        "id": 268937150,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1642827165
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"356799\">Brandon Falk</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/Unsafe.2Funchecked.20shifts/near/268931736\">said</a>:</p>\n<blockquote>\n<p>I might like to have both wraps and overshifting. I know AVX-512 overshifts to zeros and I use some of those semantics.</p>\n</blockquote>\n<p>Well \"overshifting\" for <code>simd_shl</code> is just UB unforch.</p>",
        "id": 268942648,
        "sender_full_name": "Jubilee",
        "timestamp": 1642835382
    },
    {
        "content": "<p>We can offer unchecked shifts entirely, but those would be UB to shift also. There's no portable LLVM-level way to define the \"overshift specifically with the x86/Arm dynamic shift semantics (and ignoring the one weird case Arm allows)\".</p>",
        "id": 268942724,
        "sender_full_name": "Jubilee",
        "timestamp": 1642835473
    },
    {
        "content": "<p>Yeah, this is a tough one. I might try to implement both in a way that LLVM can optimize one of them into the native behaviors or something.</p>",
        "id": 268943288,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1642836302
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"356799\">Brandon Falk</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/Unsafe.2Funchecked.20shifts/near/268931830\">said</a>:</p>\n<blockquote>\n<p>Sadly the defined behavior varies so much by arch that without tuning I'd expect emulated wrapping on x86 would lead to an additional and for every single shift</p>\n</blockquote>\n<p>Our <strong>hope</strong> is at least that, in code with tight, repeated shifts, duplicate <code>AND</code>s get wiped away, and that in some cases, where the shift is constant, it actually guarantees the const folding into the assembly form with an immediate instead of the register operand.</p>",
        "id": 268943447,
        "sender_full_name": "Jubilee",
        "timestamp": 1642836586
    },
    {
        "content": "<p>But we're not against an <code>unchecked_shl</code>, it just was clearly unacceptable for the default shifts to be panicking <strong>or</strong> unsafe.</p>",
        "id": 268943523,
        "sender_full_name": "Jubilee",
        "timestamp": 1642836712
    },
    {
        "content": "<p>(also unrelated, is there a good way to go from <code>Simd&lt;u16, 32&gt;</code> to <code>Simd&lt;i16, 32&gt;</code> and vice versa)</p>",
        "id": 268943892,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1642837334
    },
    {
        "content": "<p><code>a.to_array().map(|x| x as Target).into()</code> seems to be acceptable</p>",
        "id": 268944035,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1642837615
    },
    {
        "content": "<p>if that's gonna compile to nothing, cool</p>",
        "id": 268944725,
        "sender_full_name": "Lokathor",
        "timestamp": 1642838542
    },
    {
        "content": "<p>Oh we have real casts now, we should add those.</p>",
        "id": 268945440,
        "sender_full_name": "Jubilee",
        "timestamp": 1642839708
    },
    {
        "content": "<p>Soon:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">uints</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Simd</span>::<span class=\"o\">&lt;</span><span class=\"kt\">u16</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">32</span><span class=\"o\">&gt;</span>::<span class=\"n\">splat</span><span class=\"p\">(</span><span class=\"kt\">u16</span>::<span class=\"n\">MAX</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ints</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">uints</span><span class=\"p\">.</span><span class=\"n\">cast</span>::<span class=\"o\">&lt;</span><span class=\"kt\">i16</span><span class=\"o\">&gt;</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"n\">ints</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Simd</span>::<span class=\"n\">splat</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"n\">uints</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">ints</span><span class=\"p\">.</span><span class=\"n\">cast</span><span class=\"p\">());</span><span class=\"w\"></span>\n</code></pre></div>\n<p>It turns out the <code>map</code> version is OK but not always optimal when it's e.g. float conversions (which can be costly), As Expected, so <code>cast</code> should always be the best LLVM can do (within Rust-like semantics), and is much more succinct besides.</p>",
        "id": 269648195,
        "sender_full_name": "Jubilee",
        "timestamp": 1643321733
    },
    {
        "content": "<p>(array::map is also sadly much less nice than it should be.  there's a bunch of codegen issues that currently LLVM can't remove.  hopefully we'll get through that eventually, but even once it's fixed it's good to have the cast API)</p>",
        "id": 269654169,
        "sender_full_name": "scottmcm",
        "timestamp": 1643324715
    },
    {
        "content": "<p>so is <code>cast</code> like \"as\" in that it attempts to give an approximately similar numeric value?</p>",
        "id": 269685392,
        "sender_full_name": "Lokathor",
        "timestamp": 1643344358
    },
    {
        "content": "<p>it's not a bit-preserving operation?</p>",
        "id": 269685395,
        "sender_full_name": "Lokathor",
        "timestamp": 1643344369
    },
    {
        "content": "<p>It's identical to calling <code>as</code> on each lane</p>",
        "id": 269685467,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1643344459
    },
    {
        "content": "<p>then can we please not call it <code>cast</code></p>",
        "id": 269685482,
        "sender_full_name": "Lokathor",
        "timestamp": 1643344476
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/Unsafe.2Funchecked.20shifts/near/269685482\">said</a>:</p>\n<blockquote>\n<p>then can we please not call it <code>cast</code></p>\n</blockquote>\n<p>Unfortunately Rust doesn't allow <code>as</code> for a method name.<br>\nWe really did beat that one around for a while and struggled to find a better name.</p>",
        "id": 269703610,
        "sender_full_name": "Jubilee",
        "timestamp": 1643359576
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/Unsafe.2Funchecked.20shifts/near/269685482\">said</a>:</p>\n<blockquote>\n<p>then can we please not call it <code>cast</code></p>\n</blockquote>\n<p>i think cast is a good name tbh. why do you think its bad?</p>",
        "id": 269704141,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1643359883
    },
    {
        "content": "<p>It also <strong>is</strong> a bit-preserving operation between signed and unsigned integers of the same width.</p>",
        "id": 269704793,
        "sender_full_name": "Jubilee",
        "timestamp": 1643360224
    },
    {
        "content": "<p>I actually already know about <code>as</code> not being allowed because I wanted to use it with <code>bytemuck</code> and then I unfortunately could not. Which is why I used <code>cast</code> there. That one is a pure bit-cast that can always be round-tripped. Also we have the pointer cast method, which can be round-tripped.</p>\n<p>While it's true that int/uint preserves bits and thus always round-trips, the int/float path does not.</p>\n<p>It's not a super big deal, but if there's any alternative word we could use (perhaps <code>convert</code>?) then I just feel that it would be better than cast.</p>",
        "id": 269758571,
        "sender_full_name": "Lokathor",
        "timestamp": 1643385805
    },
    {
        "content": "<p>I... think bytemuck is probably the one in the wrong about using <code>cast</code> for a pure bitcast. In most other languages casting is like <code>as</code>, in that its potentially lossy (for floats and such).</p>",
        "id": 269765017,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1643388544
    },
    {
        "content": "<p>could be the case</p>",
        "id": 269769702,
        "sender_full_name": "Lokathor",
        "timestamp": 1643390397
    },
    {
        "content": "<p><code>static_cast</code> in C++ is a terrible name, but <code>reinterpret_cast</code> for the \"always just preserves bits\" casts is a name I kinda like.</p>\n<p>I could go for the safe transmute stuff being <code>mem::reinterpret</code> or something.</p>",
        "id": 269786494,
        "sender_full_name": "scottmcm",
        "timestamp": 1643396829
    },
    {
        "content": "<p>reinterpret_cast is actually not bit-preserving for floats. bit_cast is the one that is.</p>",
        "id": 269787722,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1643397333
    },
    {
        "content": "<p>which is an example of the name being terrible again, yes.</p>",
        "id": 269787740,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1643397346
    },
    {
        "content": "<p>(reinterpret_cast is only actually reinterpretation for integers and pointers, but even then you're not actually allowed to look at the pointee bits after reinterpreting them. its just a bad scene)</p>",
        "id": 269787913,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1643397411
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/Unsafe.2Funchecked.20shifts/near/269787722\">said</a>:</p>\n<blockquote>\n<p>reinterpret_cast is actually not bit-preserving for floats. bit_cast is the one that is.</p>\n</blockquote>\n<p>Ah, C++.  Where even the new better things are still weird <span aria-label=\"cry\" class=\"emoji emoji-1f622\" role=\"img\" title=\"cry\">:cry:</span></p>",
        "id": 269788242,
        "sender_full_name": "scottmcm",
        "timestamp": 1643397567
    },
    {
        "content": "<p>Personally, my only concern with the name <code>cast</code> is whether it'd conflict with the same transmute work or similar future replacements for <code>as</code>, yeah. And in theory, if safe transmute <em>did</em> want to use that name, we could just make that handle this case too.</p>",
        "id": 269799616,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643402591
    },
    {
        "content": "<p>Mm, I'd rather split another method off for the saturating float conversions.</p>",
        "id": 269812305,
        "sender_full_name": "Jubilee",
        "timestamp": 1643409024
    },
    {
        "content": "<blockquote>\n<p>with the same transmute work</p>\n</blockquote>\n<p>Is \"same\" here a typo for safe?</p>",
        "id": 269817354,
        "sender_full_name": "Nick12",
        "timestamp": 1643412136
    },
    {
        "content": "<p>since \"safe transmute\" was written later in the same post, i assume so</p>",
        "id": 269828410,
        "sender_full_name": "Lokathor",
        "timestamp": 1643420363
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"356799\">Brandon Falk</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/Unsafe.2Funchecked.20shifts/near/268931392\">said</a>:</p>\n<blockquote>\n<p>Heya! I was wondering if there's any ideas/plans to make an unsafe/unchecked shift. I have a pretty dense loop with a lot of shifts and the overshift checks are adding a lot of branches. Sadly a lot of the variables are provably constrained to &lt;word size, but I can't convince the compiler about that. Was maybe thinking of adding an unsafe/unchecked shift which requires the user to constrain the inputs themselves?</p>\n</blockquote>\n<p>Have these branches been addressed by the latest versions in <code>std</code>?</p>",
        "id": 271896016,
        "sender_full_name": "Jubilee",
        "timestamp": 1644876250
    }
]