[
    {
        "content": "<p>So, re: the typedefs for the various Arm Neon types,<br>\nArm v7 doesn't necessarily include Neon, so we do allow runtime dispatch on Armv7.</p>",
        "id": 261200025,
        "sender_full_name": "Jubilee",
        "timestamp": 1636677260
    },
    {
        "content": "<p>Right, but you can't build it for example for arm v6. I'm not sure if that's maybe some other limitation I'm not thinking about</p>",
        "id": 261200176,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636677468
    },
    {
        "content": "<p>It doesn't really matter for std::simd since that's just type conversion code anyway</p>",
        "id": 261200246,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636677521
    },
    {
        "content": "<p>I am looking and it seems Arm v4 is not bincompat with Arm v5 in the first place, so I think we don't really get to have The Dream of software-driven dispatch across all Arm architecture versions.</p>",
        "id": 261200662,
        "sender_full_name": "Jubilee",
        "timestamp": 1636678025
    },
    {
        "content": "<p>They're different binaries, but they're backwards compatible</p>",
        "id": 261200738,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636678099
    },
    {
        "content": "<p>I mean it breaks ABI.</p>",
        "id": 261200750,
        "sender_full_name": "Jubilee",
        "timestamp": 1636678122
    },
    {
        "content": "<p>different alignments n'such.</p>",
        "id": 261200766,
        "sender_full_name": "Jubilee",
        "timestamp": 1636678141
    },
    {
        "content": "<p>There are different eabi versions, but that's baked into the binary</p>",
        "id": 261200773,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636678151
    },
    {
        "content": "<p>I think you can run v4 binaries on v7. I know for a fact you can run v5 on v7</p>",
        "id": 261200786,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636678177
    },
    {
        "content": "<p>Yeah rn I suspect it looks like<br>\nArm v4 (\"OABI\")<br>\nAArch32 (Arm v5-v7 \"EABI\")<br>\nAArch64</p>",
        "id": 261200858,
        "sender_full_name": "Jubilee",
        "timestamp": 1636678238
    },
    {
        "content": "<p>An equivalent that as far as I can tell isn't supported is that you're also allowed to use the v8 fpu from v7 if you detect it</p>",
        "id": 261200879,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636678288
    },
    {
        "content": "<p>That one is going to be a little less common because it implies you're running an aarch32 userspace or whatever, but it is possible</p>",
        "id": 261200957,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636678388
    },
    {
        "content": "<p>Oh our only Arm v4 target also is EABI, actually...<br>\nGood.</p>",
        "id": 261201638,
        "sender_full_name": "Jubilee",
        "timestamp": 1636679135
    },
    {
        "content": "<p>yeah, I could have sworn you can do armv4 gnueabi</p>",
        "id": 261201689,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636679168
    },
    {
        "content": "<p>Okay, so I will care about Arm v4 then. Alright.</p>",
        "id": 261201814,
        "sender_full_name": "Jubilee",
        "timestamp": 1636679290
    },
    {
        "content": "<p>Looks like we only have thumbv4t-none-eabi (ARMv4T T32) and armv4t-unknown-linux-gnueabi tho' (Armv4T... A32, I guess?)<br>\ncc <span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> since you added thumbv4t-none-eabi AKA the GBA. <a href=\"https://github.com/rust-lang/rust/pull/74419\">https://github.com/rust-lang/rust/pull/74419</a><br>\nAlso looks like armv4t was added with <a href=\"https://github.com/rust-lang/rust/pull/47018\">https://github.com/rust-lang/rust/pull/47018</a> with the justification of \"Debian targets it!\" following armv5te in <a href=\"https://github.com/rust-lang/rust/pull/37615\">https://github.com/rust-lang/rust/pull/37615</a></p>",
        "id": 261202523,
        "sender_full_name": "Jubilee",
        "timestamp": 1636680190
    },
    {
        "content": "<p>yeah, armel is where I was getting my information that armv4 was also supported</p>",
        "id": 261202715,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636680370
    },
    {
        "content": "<p>I think armhf is generally  armv7+vfp3v-d16 but I'm not positive</p>",
        "id": 261202742,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636680412
    },
    {
        "content": "<p>not sure about the debian version though</p>",
        "id": 261202749,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636680429
    },
    {
        "content": "<p>We have two different targets just named \"arm\" and it makes me kinda mad, tbh.</p>",
        "id": 261202829,
        "sender_full_name": "Jubilee",
        "timestamp": 1636680501
    },
    {
        "content": "<p>it's pretty standard (though confusing) for armv6 to be called just \"arm\"</p>",
        "id": 261202885,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636680592
    },
    {
        "content": "<p>not sure why</p>",
        "id": 261202886,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636680593
    },
    {
        "content": "<p>No no no,</p>\n<table>\n<thead>\n<tr>\n<th>Target</th>\n<th>std?</th>\n<th>Note</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>arm-unknown-linux-gnueabi</td>\n<td>✓</td>\n<td>ARMv6 Linux (kernel 3.2, glibc 2.17)</td>\n</tr>\n<tr>\n<td>arm-unknown-linux-gnueabihf</td>\n<td>✓</td>\n<td>ARMv6 Linux, hardfloat (kernel 3.2, glibc 2.17)</td>\n</tr>\n<tr>\n<td>arm-linux-androideabi</td>\n<td>✓</td>\n<td>ARMv7 Android</td>\n</tr>\n<tr>\n<td>arm-unknown-linux-musleabi</td>\n<td>✓</td>\n<td>ARMv6 Linux with MUSL</td>\n</tr>\n<tr>\n<td>arm-unknown-linux-musleabihf</td>\n<td>✓</td>\n<td>ARMv6 Linux with MUSL, hardfloat</td>\n</tr>\n</tbody>\n</table>\n<p>I mean we have both Arm v6 and Arm v7 there.</p>",
        "id": 261202936,
        "sender_full_name": "Jubilee",
        "timestamp": 1636680616
    },
    {
        "content": "<p>and we have other targets explicitly named \"armv6\" too.</p>",
        "id": 261202946,
        "sender_full_name": "Jubilee",
        "timestamp": 1636680633
    },
    {
        "content": "<p>If it was consistent, it wouldn't bother me.</p>",
        "id": 261202973,
        "sender_full_name": "Jubilee",
        "timestamp": 1636680685
    },
    {
        "content": "<p>lol, true</p>",
        "id": 261203030,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636680726
    },
    {
        "content": "<blockquote>\n<p><strong>ArmEabiPort</strong></p>\n<p>The ARM EABI port (armel) is the default port in Debian for ARM architecture versions 4T, 5T, and 6.</p>\n<p>From Debian 10 (buster), 4T is no longer supported and the armel baseline was updated to 5T. If you have 4T hardware, please use Debian stretch or upgrade your hardware. </p>\n</blockquote>\n<p>...Ah.</p>",
        "id": 261203666,
        "sender_full_name": "Jubilee",
        "timestamp": 1636681517
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/Arm.20type.20portability/near/261202523\">said</a>:</p>\n<blockquote>\n<p>Looks like we only have thumbv4t-none-eabi (ARMv4T T32) and armv4t-unknown-linux-gnueabi tho' (Armv4T... A32, I guess?)<br>\ncc <span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> since you added thumbv4t-none-eabi AKA the GBA. <a href=\"https://github.com/rust-lang/rust/pull/74419\">https://github.com/rust-lang/rust/pull/74419</a><br>\nAlso looks like armv4t was added with <a href=\"https://github.com/rust-lang/rust/pull/47018\">https://github.com/rust-lang/rust/pull/47018</a> with the justification of \"Debian targets it!\" following armv5te in <a href=\"https://github.com/rust-lang/rust/pull/37615\">https://github.com/rust-lang/rust/pull/37615</a></p>\n</blockquote>\n<p>v4 doesn't support SIMD as far as i'm aware.</p>",
        "id": 261206471,
        "sender_full_name": "Lokathor",
        "timestamp": 1636685094
    },
    {
        "content": "<p>SIMD was introduced in v6 afaik</p>",
        "id": 261206539,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636685194
    },
    {
        "content": "<p>sure.</p>\n<p>re-scanning the thread, was there a question i was supposed to answer?</p>",
        "id": 261206667,
        "sender_full_name": "Lokathor",
        "timestamp": 1636685364
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> I am mostly curious about, since you actually have an opinion, whether you think the typedefs in question should be available on earlier architectures than v7 or v6.</p>",
        "id": 261206918,
        "sender_full_name": "Jubilee",
        "timestamp": 1636685696
    },
    {
        "content": "<p>it would be handy if you could just do <code>cfg(target_feature = \"neon\")</code> or similar</p>",
        "id": 261206995,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636685791
    },
    {
        "content": "<p>I still don't think that's quite right</p>",
        "id": 261207004,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636685808
    },
    {
        "content": "<p>yeah i'm thinking it's fine if you cfg(target_feature=\"neon\")</p>",
        "id": 261207013,
        "sender_full_name": "Lokathor",
        "timestamp": 1636685824
    },
    {
        "content": "<p>v6 and v7 are the same other than thumb2 and neon</p>",
        "id": 261207020,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636685828
    },
    {
        "content": "<p>or, well, <code>if runtime_cfg_thing(\"neon\")</code> or however you phrase it</p>",
        "id": 261207029,
        "sender_full_name": "Lokathor",
        "timestamp": 1636685843
    },
    {
        "content": "<p>so you can make a v6 binary that then checks for neon</p>",
        "id": 261207030,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636685846
    },
    {
        "content": "<p>( Or basically just in general if you think we should support \"multi-generation\" Arm binaries. )</p>",
        "id": 261207036,
        "sender_full_name": "Jubilee",
        "timestamp": 1636685868
    },
    {
        "content": "<p>I think it doesn't make sense to not do so for like... 1 generation of crossover, so (Arm v7 | Arm v8), for instance.</p>",
        "id": 261207104,
        "sender_full_name": "Jubilee",
        "timestamp": 1636685939
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span> I think you're just putting too much weight into what the generations mean, it's not particularly different than like intel generations</p>",
        "id": 261207105,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636685941
    },
    {
        "content": "<p>I know.</p>",
        "id": 261207110,
        "sender_full_name": "Jubilee",
        "timestamp": 1636685947
    },
    {
        "content": "<p>Well.<br>\nNot entirely.</p>",
        "id": 261207117,
        "sender_full_name": "Jubilee",
        "timestamp": 1636685956
    },
    {
        "content": "<p>it's slightly more complicated, but not that much</p>",
        "id": 261207129,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636685971
    },
    {
        "content": "<p>or maybe the arm types should always be available, just that using them for more than just copying around is UB unless the required feature is enabled</p>",
        "id": 261207130,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636685973
    },
    {
        "content": "<p>Arm is way more inclined to drop instruction support.</p>",
        "id": 261207133,
        "sender_full_name": "Jubilee",
        "timestamp": 1636685978
    },
    {
        "content": "<p>yeah I think they should always be available, you just can't necessarily use them</p>",
        "id": 261207149,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636685997
    },
    {
        "content": "<p>And my concern basically is that somehow a typedef gets read into a way that uses an odd instruction for moving it that was dropped on a later version and then boom.</p>",
        "id": 261207257,
        "sender_full_name": "Jubilee",
        "timestamp": 1636686038
    },
    {
        "content": "<p>avx is available on i386 despite no such cpu ever existing, for example</p>",
        "id": 261207259,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636686040
    },
    {
        "content": "<p>au contraire.</p>",
        "id": 261207272,
        "sender_full_name": "Jubilee",
        "timestamp": 1636686061
    },
    {
        "content": "<p>That does exist.</p>",
        "id": 261207282,
        "sender_full_name": "Jubilee",
        "timestamp": 1636686066
    },
    {
        "content": "<p>a 32-bit cpu with avx?</p>",
        "id": 261207296,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636686091
    },
    {
        "content": "<p>It's named Every Single x86 Chip With AVX, because bootloading. :3<br>\nAnd in fact many of the SIMD instructions explicitly define what they do if they aren't in long mode yet.</p>",
        "id": 261207335,
        "sender_full_name": "Jubilee",
        "timestamp": 1636686116
    },
    {
        "content": "<p>but those are x86-64 cpus</p>",
        "id": 261207383,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636686136
    },
    {
        "content": "<p>Yes?</p>",
        "id": 261207388,
        "sender_full_name": "Jubilee",
        "timestamp": 1636686141
    },
    {
        "content": "<p>my point is that's no different than running an arm v4 binary with v8 asimd on a v8 cpu</p>",
        "id": 261207400,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636686171
    },
    {
        "content": "<p>i386 is just the name for an x86 chip which hasn't had a certain number of features turned on yet by the bootloader. &lt;_&lt;</p>",
        "id": 261207424,
        "sender_full_name": "Jubilee",
        "timestamp": 1636686207
    },
    {
        "content": "<p>i386 is also used for those who still use a 32-bit OS...iirc windows 10 has a 32-bit version</p>",
        "id": 261207488,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636686277
    },
    {
        "content": "<p>And on switchover to long mode, some instruction encodings actually change their interpretation significantly.<br>\nThe difference is that Arm allows instruction encodings to be dropped between generations.</p>",
        "id": 261207501,
        "sender_full_name": "Jubilee",
        "timestamp": 1636686304
    },
    {
        "content": "<p>32-bit cuz back compat with 16-bit programs or something</p>",
        "id": 261207517,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636686322
    },
    {
        "content": "<p>all I am saying is compiling for rust i386, you still get avx. compiling for arm v4 you should get v8 asimd</p>",
        "id": 261207522,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636686330
    },
    {
        "content": "<p>Welllllll</p>",
        "id": 261207532,
        "sender_full_name": "Jubilee",
        "timestamp": 1636686356
    },
    {
        "content": "<p>as the most extreme example, at least</p>",
        "id": 261207535,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636686359
    },
    {
        "content": "<p>on x86, all those nice compact 1-byte inc/dec instructions turned into rex prefixes</p>",
        "id": 261207606,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636686438
    },
    {
        "content": "<p>iirc</p>",
        "id": 261207609,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636686444
    },
    {
        "content": "<p>I mean Neon hits an inflection point where it changes entirely how it works between Arm v7 and AArch64...</p>",
        "id": 261207612,
        "sender_full_name": "Jubilee",
        "timestamp": 1636686456
    },
    {
        "content": "<p>aarch64 isn't compatible with 32-bit arm...those are completely separate operating modes</p>",
        "id": 261207669,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636686505
    },
    {
        "content": "<p>Yeaaaah.</p>",
        "id": 261207679,
        "sender_full_name": "Jubilee",
        "timestamp": 1636686514
    },
    {
        "content": "<p>so, for any arm 32-bit code, you'll never have to worry about compatibility with aarch64's semantics</p>",
        "id": 261207707,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636686585
    },
    {
        "content": "<p>it's generally compatible though</p>",
        "id": 261207761,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636686616
    },
    {
        "content": "<p>as in, you can run an armv4 binary on aarch32</p>",
        "id": 261207766,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636686633
    },
    {
        "content": "<p>in the general case</p>",
        "id": 261207780,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636686657
    },
    {
        "content": "<p>well, aarch32 isn't actually part of aarch64, it's a separate thing</p>",
        "id": 261207789,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636686666
    },
    {
        "content": "<p>afaict...</p>",
        "id": 261207807,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636686701
    },
    {
        "content": "<p>Yeah, people are making chips now with AArch64-only mode.</p>",
        "id": 261207809,
        "sender_full_name": "Jubilee",
        "timestamp": 1636686704
    },
    {
        "content": "<p>it's a state of v8 cpus</p>",
        "id": 261207810,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636686705
    },
    {
        "content": "<p>This is why I think \"Arm allows instruction encodings to be dropped\" is a more realistic concern than one might imagine, because people do.</p>",
        "id": 261207861,
        "sender_full_name": "Jubilee",
        "timestamp": 1636686742
    },
    {
        "content": "<p>yup, the cortex x2 only implements aarch64, not aarch32</p>",
        "id": 261207862,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636686743
    },
    {
        "content": "<p>there are also v8 cpus with only the aarch32 state</p>",
        "id": 261207866,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636686759
    },
    {
        "content": "<p>the fpu is the same in both cases</p>",
        "id": 261207877,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636686771
    },
    {
        "content": "<p>I am saying, generally, it is possible to run a hypothetical arm v4 binary on a hypothetical v8 cpu</p>",
        "id": 261207904,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636686815
    },
    {
        "content": "<p>cortex m55 -- aarch32 only iirc</p>",
        "id": 261207905,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636686818
    },
    {
        "content": "<p>Is it? I thought Arm v8 could still have two different FPUs.</p>",
        "id": 261207907,
        "sender_full_name": "Jubilee",
        "timestamp": 1636686819
    },
    {
        "content": "<p>and in fact that's true for most v8 cpus</p>",
        "id": 261207910,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636686829
    },
    {
        "content": "<p>Jubilee as the ward of the v4T targets, i officially defer to your simd opinion</p>",
        "id": 261207995,
        "sender_full_name": "Lokathor",
        "timestamp": 1636686921
    },
    {
        "content": "<p>lol okay.</p>",
        "id": 261207999,
        "sender_full_name": "Jubilee",
        "timestamp": 1636686935
    },
    {
        "content": "<p>I guess my question is, \"when LLVM emits code for an earlier Arm target, does it emit now-deprecated instructions?\"</p>",
        "id": 261208095,
        "sender_full_name": "Jubilee",
        "timestamp": 1636687081
    },
    {
        "content": "<p>If the answer is no, then my concerns are moot.</p>",
        "id": 261208160,
        "sender_full_name": "Jubilee",
        "timestamp": 1636687163
    },
    {
        "content": "<p>idk</p>",
        "id": 261208219,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636687206
    },
    {
        "content": "<p>If the answer is no, then supporting an \"Arm v4 to Arm v9???\" binary should be \"free\".<br>\nIf the answer is yes, I don't think we want to eff ourselves to support that use case, even if it offends my own sense of doing things \"correctly\".</p>",
        "id": 261208345,
        "sender_full_name": "Jubilee",
        "timestamp": 1636687383
    },
    {
        "content": "<p>And we still have to convince std::arch to allow the typedefs in earlier gens, also.</p>",
        "id": 261208406,
        "sender_full_name": "Jubilee",
        "timestamp": 1636687478
    },
    {
        "content": "<p>well, no instructions were deprecated from v6 to v7 as far as I know</p>",
        "id": 261208573,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636687686
    },
    {
        "content": "<p>and that's probably by far the most common case for running neon on older generations that didn't have it</p>",
        "id": 261208585,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636687706
    },
    {
        "content": "<p>ironically, trying to produce what I'm talking about in C, clang doesn't allow multiversioning neon at all in any form</p>",
        "id": 261209401,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636688945
    },
    {
        "content": "<p>so we actually have a leg up allowing it in armv7 without neon <span aria-label=\"disappointed\" class=\"emoji emoji-1f61e\" role=\"img\" title=\"disappointed\">:disappointed:</span></p>",
        "id": 261209411,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636688977
    },
    {
        "content": "<p>Oof.</p>",
        "id": 261209542,
        "sender_full_name": "Jubilee",
        "timestamp": 1636689139
    },
    {
        "content": "<p>hmm, if clang doesn't allow multiversioning, maybe they have a good reason, we should probably ask one of the arm experts</p>",
        "id": 261209555,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636689194
    },
    {
        "content": "<p>I think to detect neon you need to query the OS</p>",
        "id": 261209576,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636689242
    },
    {
        "content": "<p>llvm could assume neon/non-neon code won't ever be mixed...cuz clang apparently won't let you...</p>",
        "id": 261209643,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1636689327
    },
    {
        "content": "<p>I'm not sure that's true, because rustc allows it</p>",
        "id": 261209651,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636689353
    },
    {
        "content": "<p>I didn't play around with what happens if you write llvm ir instead of C, but it seems like the limitation is in the frontend</p>",
        "id": 261209702,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636689388
    },
    {
        "content": "<p><code>swp</code>, <code>swpb</code>, and CP15 barriers are some of the instructions I was thinking of.<br>\n<a href=\"https://github.com/rust-lang/rust/issues/60605\">https://github.com/rust-lang/rust/issues/60605</a> whew.</p>",
        "id": 261210015,
        "sender_full_name": "Jubilee",
        "timestamp": 1636689787
    },
    {
        "content": "<p>Okay so this is basically what I'm saying <em>is</em> possible: <a href=\"https://rust.godbolt.org/z/qnKf9MaEE\">https://rust.godbolt.org/z/qnKf9MaEE</a></p>",
        "id": 261210255,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636690147
    },
    {
        "content": "<p>this is a binary for an armv5, soft float, that detects if neon is present and dispatches to that function instead</p>",
        "id": 261210267,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636690176
    },
    {
        "content": "<p>presumably it'll work just fine for portable-simd, since it's basically doing the same thing as the autovectorizer, it's just weird that you can't actually explicitly write that same neon, because the overall target isn't armv7</p>",
        "id": 261210486,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636690514
    },
    {
        "content": "<p>Apparently it's always at least two steps.<br>\nDeprecate for one gen, then obsolete.</p>",
        "id": 261210656,
        "sender_full_name": "Jubilee",
        "timestamp": 1636690803
    },
    {
        "content": "<p>So, it would at least prooobably make sense to make v7 types available to v6 binaries.</p>",
        "id": 261210712,
        "sender_full_name": "Jubilee",
        "timestamp": 1636690923
    },
    {
        "content": "<p>I don't see why they shouldn't be available to all of arm, and then it's up to you to know your cpu etc</p>",
        "id": 261210769,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636690985
    },
    {
        "content": "<p>banning neon from rust armv5 targets doesn't prevent you from using armv5 binaries on your armv7 cpu</p>",
        "id": 261210869,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636691129
    },
    {
        "content": "<p>also worth noting that if you do call a swp instruction, linux will trap it and emulate it on armv7+</p>",
        "id": 261210927,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636691207
    },
    {
        "content": "<p>We don't get to make that choice, the OS does.</p>",
        "id": 261210939,
        "sender_full_name": "Jubilee",
        "timestamp": 1636691254
    },
    {
        "content": "<p>what choice?</p>",
        "id": 261210944,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636691271
    },
    {
        "content": "<p>I can make an armv5 binary with a swp instruction right now on rust, it has nothing to do with the availability of the neon types... it has nothing to do with neon at all</p>",
        "id": 261211006,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1636691380
    },
    {
        "content": "<p>It doesn't matter because apparently everything about the way std::arch has structured things for Arm seems to be the most narrow possible interpretation of things.</p>",
        "id": 261325390,
        "sender_full_name": "Jubilee",
        "timestamp": 1636760388
    }
]