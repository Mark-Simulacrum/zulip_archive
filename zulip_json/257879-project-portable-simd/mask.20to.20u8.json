[
    {
        "content": "<p>Is there a way to safely convert <code>std::simd::Mask&lt;i8, 8_usize&gt;</code> to <code>u8</code>? I imagine that they have the same in-memory repr, but can't find a method for this</p>",
        "id": 267373598,
        "sender_full_name": "Jorge Leitao",
        "timestamp": 1641756930
    },
    {
        "content": "<p>yes, use <code>Mask::to_bitmask</code>. Also, <code>Mask</code> isn't necessarily a bitmask, on some architectures (such as x86 non-avx512 and arm neon) it is a vector of integers where each lane has all bits set/clear for true/false values.</p>",
        "id": 267373919,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641757353
    },
    {
        "content": "<p>is that documented? In <a href=\"https://doc.rust-lang.org/nightly/std/simd/struct.Mask.html\">https://doc.rust-lang.org/nightly/std/simd/struct.Mask.html</a> I can't find <code>to_bitmask</code></p>",
        "id": 267374010,
        "sender_full_name": "Jorge Leitao",
        "timestamp": 1641757464
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/portable-simd/blob/65cb2c90a0688c110d983a2dbb9932900cd6b5d9/crates/core_simd/src/masks/full_masks.rs#L115\">https://github.com/rust-lang/portable-simd/blob/65cb2c90a0688c110d983a2dbb9932900cd6b5d9/crates/core_simd/src/masks/full_masks.rs#L115</a></p>",
        "id": 267374016,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641757482
    },
    {
        "content": "<p>it may need an additional feature enabled when building std, so it may not work by default</p>",
        "id": 267374037,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641757525
    },
    {
        "content": "<p>to understand, when an additional feature is required, is there a way to activate it at the dependency level, or it basically requires re-compiling the std with that feature?</p>",
        "id": 267374173,
        "sender_full_name": "Jorge Leitao",
        "timestamp": 1641757743
    },
    {
        "content": "<p>idk, <span class=\"user-mention\" data-user-id=\"312331\">@Caleb Zulawski</span> may know since he's worked on the code more recently...</p>",
        "id": 267374245,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641757838
    },
    {
        "content": "<p>wrt to the vector of integers in some archs: thanks for the info. I am porting an Apache Arrow implementation, and Apache Arrow uses bitmaps as its Vec&lt;bool&gt; container, so it is not an option to optimize for different arches - the format itself is designed to hit avx512 and other archs are penalized</p>",
        "id": 267374279,
        "sender_full_name": "Jorge Leitao",
        "timestamp": 1641757913
    },
    {
        "content": "<p>It's not available on std right now because it requires an incomplete feature</p>",
        "id": 267374324,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641757945
    },
    {
        "content": "<p>I'm planning on adding conversion to basic ints to nightly without the incomplete feature</p>",
        "id": 267374359,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641758011
    },
    {
        "content": "<p>The masks actually often do not have the same representation in memory</p>",
        "id": 267374415,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641758057
    },
    {
        "content": "<p>got it. Yeah, the ability to convert to bitmask is a requirement for us (packed_simd supports it), so thanks a lot for taking it on.</p>\n<p>For context, I am a maintainer of arrow2 and I am trying to port it to <code>std::simd</code> (<a href=\"https://github.com/jorgecarleitao/arrow2/pull/747\">https://github.com/jorgecarleitao/arrow2/pull/747</a>). We make some use of packed_simd atm, so these are just questions coming from this exercise. I am trying to have a compiling code so that we can MIRI our tests against portable simd, which should provide useful data.</p>",
        "id": 267374913,
        "sender_full_name": "Jorge Leitao",
        "timestamp": 1641758637
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"229517\">@Jacob Lifshay</span> I'm trying to figure out a good API for handling this, I think at a minimum we should support both conversions to an integer and a conversion to <code>[u8; N]</code></p>",
        "id": 267378657,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641763714
    },
    {
        "content": "<p>Do you think it would be an oversimplification to only support conversion to <code>u64</code> for all masks with &lt;=64 lanes as far as integers go?</p>",
        "id": 267378685,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641763751
    },
    {
        "content": "<p>We would still eventually support conversion to <code>[u8; N]</code>, in addition</p>",
        "id": 267378782,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641763884
    },
    {
        "content": "<p>This would mean, for example, that a future <code>Mask&lt;_, 128&gt;</code> would not have conversion to <code>u128</code> without passing through an array of <code>[u8, 16]</code> first</p>",
        "id": 267378857,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641763988
    },
    {
        "content": "<p>hmm, i would have just picked changing it to:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// no #[cfg(feature)] needed cuz generic const expressions aren't needed when expressing it this way</span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">to_bitmask</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">LaneCount</span>::<span class=\"o\">&lt;</span><span class=\"n\">LANES</span><span class=\"o\">&gt;</span>::<span class=\"n\">BitMask</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 267379247,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641764552
    },
    {
        "content": "<p>where <code>BitMask</code> is <code>[u8; N]</code></p>",
        "id": 267379256,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641764593
    },
    {
        "content": "<p>I think enough people have been confused about something returning an integer that we should provide something that gives an integer directly</p>",
        "id": 267379304,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641764645
    },
    {
        "content": "<p>k, <code>to_int_bitmask</code></p>",
        "id": 267379316,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641764684
    },
    {
        "content": "<p>I was thinking <code>to_u64_bitmask</code>, but yeah</p>",
        "id": 267379318,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641764701
    },
    {
        "content": "<p>maybe just define it for <code>LANES &lt;= 64</code> and also have variants for <code>u8</code>, <code>u16</code>, <code>u32</code>, and <code>u128</code> with <code>LANES &lt;= 8/16/32/128</code></p>",
        "id": 267379385,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641764810
    },
    {
        "content": "<p>well, that's what I was really wondering, is it worth it to define the other variants?</p>",
        "id": 267379398,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641764853
    },
    {
        "content": "<p>you could always do <code>mask.to_u64_bitmask().into()</code>, which would support all of those except <code>u128</code>, but I'm less confident about <code>u128</code> ever being as optimal as the other integer sizes</p>",
        "id": 267379448,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641764898
    },
    {
        "content": "<p>imho yes, cuz we want users to think \"oh, what happens when i want 128 or more lanes? will <code>u64</code> (or whatever) be big enough?\"</p>",
        "id": 267379457,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641764922
    },
    {
        "content": "<p>I guess I'm looking at it as there are two different ways of using it, one converts to \"normal\" integers, and the other converts to an array that you can do whatever you want with</p>",
        "id": 267379473,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641764965
    },
    {
        "content": "<p>otherwise they'll just assume u64 must always be big enough and design inflexible code</p>",
        "id": 267379480,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641764991
    },
    {
        "content": "<p>I'm also trying to minimize the API a bit</p>",
        "id": 267379482,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641764997
    },
    {
        "content": "<p><code>fn to_int_bitmask(self) -&gt; LaneCount::&lt;LANES&gt;::BitMask</code> is definitely a lot more confusing than <code>fn to_u64_bitmask(self) -&gt; u64</code></p>",
        "id": 267379539,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641765049
    },
    {
        "content": "<p>also now that I think about it, it can't be on <code>LaneCount</code>, because it's only supported on 128 or smaller, and the max supported lane count in the future could be larger</p>",
        "id": 267379560,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641765112
    },
    {
        "content": "<p>yup, it's soo confusing that you were just now confused...<code>BitMask</code> is currently always an <code>[u8; N]</code></p>",
        "id": 267379604,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641765143
    },
    {
        "content": "<p>I thought that variable is gone now?</p>",
        "id": 267379616,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641765169
    },
    {
        "content": "<p>but yeah, lol</p>",
        "id": 267379621,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641765172
    },
    {
        "content": "<p>I'm just suggesting that if you're doing anything larger than 64, you'll have to pass through the array of <code>u8</code> instead of an integer, drawing a line at <code>u64</code> since that's the most \"portable\"</p>",
        "id": 267379641,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641765225
    },
    {
        "content": "<p>I meant more like <code>fn to_int_bitmask(self) -&gt; LaneCount::&lt;LANES&gt;::BitMaskInt</code> where <code>LANES &lt;= 8</code> gives <code>u8</code>, <code>8 &lt; LANES &lt;= 16</code> gives <code>u16</code>, etc.</p>",
        "id": 267379698,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641765312
    },
    {
        "content": "<p>and above u128 it gives what?</p>",
        "id": 267379709,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641765357
    },
    {
        "content": "<p>tho if we were ever to get generic int types, i'd want it to give <code>uint::&lt;LANES&gt;</code></p>",
        "id": 267379750,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641765385
    },
    {
        "content": "<p>idk, a library type?</p>",
        "id": 267379760,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641765417
    },
    {
        "content": "<p>fall back to <code>[u8; N]</code>?</p>",
        "id": 267379772,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641765440
    },
    {
        "content": "<p>still seems confusing to me, I think I'm just hoping to implement two functions with concrete types</p>",
        "id": 267379776,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641765453
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>fn to_u64_bitmask(self) -&gt; u64;\nfn to_bitmask(self) -&gt; [u8; LaneCount::&lt;LANES&gt;::BITMASK_LEN];\n</code></pre></div>",
        "id": 267379822,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641765504
    },
    {
        "content": "<p><code>to_bitmask</code> will still have the scaling API</p>",
        "id": 267379826,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641765520
    },
    {
        "content": "<p>how about just calling it <code>fn trunc_to_u64_bitmask(self) -&gt; u64</code>, if it has <code>trunc</code> in the name, then i think it's obvious enough that your code won't work with &gt; 64 lanes</p>",
        "id": 267379844,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641765573
    },
    {
        "content": "<p>or <code>wrapping</code>, tho <code>trunc</code> seems better to me</p>",
        "id": 267379915,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641765610
    },
    {
        "content": "<p>oh, I was going to only implement the function on masks with &lt;=64 lanes</p>",
        "id": 267379966,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641765653
    },
    {
        "content": "<p>we can reserve <code>to_int_bitmask</code> for the generic int version</p>",
        "id": 267379972,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641765664
    },
    {
        "content": "<p>so no truncation</p>",
        "id": 267379975,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641765680
    },
    {
        "content": "<p><code>to_short_int</code>?</p>",
        "id": 267379992,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641765708
    },
    {
        "content": "<p>not sure what short means here?</p>",
        "id": 267380035,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641765739
    },
    {
        "content": "<p>short == only works when LANES &lt;= 64</p>",
        "id": 267380049,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641765767
    },
    {
        "content": "<p><code>short int</code> to me means <code>i16</code> :)</p>",
        "id": 267380051,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641765773
    },
    {
        "content": "<p>s/short/small/</p>",
        "id": 267380062,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641765801
    },
    {
        "content": "<p>limited?</p>",
        "id": 267380114,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641765869
    },
    {
        "content": "<p>also somewhat separate from the naming, I'm still not sure if we should or shouldn't be implementing <code>Into</code> instead?</p>",
        "id": 267380116,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641765873
    },
    {
        "content": "<p>I'm not sure if the conversion is self-explanatory or not?</p>",
        "id": 267380123,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641765897
    },
    {
        "content": "<p>imho we shouldn't implement <code>into</code> cuz conversion can be quite expensive</p>",
        "id": 267380129,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641765907
    },
    {
        "content": "<p>that's fair</p>",
        "id": 267380142,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641765928
    },
    {
        "content": "<p>another option I had considered is <code>trait ToBitMask&lt;T&gt;</code> which mirrors <code>Into</code>, which would allow us to implement it for whatever arbitrary types make sense for a mask</p>",
        "id": 267380214,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641766019
    },
    {
        "content": "<p>like if we ever got generic integers, just implement it over that</p>",
        "id": 267380244,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641766077
    },
    {
        "content": "<p>if we get better const generics, we can improve the trait impl for <code>[u8; N]</code></p>",
        "id": 267380292,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641766105
    },
    {
        "content": "<p>etc</p>",
        "id": 267380293,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641766106
    },
    {
        "content": "<p>then you could make a generic function that arbitrarily uses either an array or an integer too, just do <code>T: ToBitMask</code></p>",
        "id": 267380337,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641766193
    },
    {
        "content": "<p>hmm, that may be a good idea, tho i really wish we could just hold out for generic ints</p>",
        "id": 267380387,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641766243
    },
    {
        "content": "<p>actually, I just realized if we got generic ints we could just do <code>fn to_bitmask(self) -&gt; uint&lt;LANES&gt;</code> directly on masks, and deprecate the trait</p>",
        "id": 267380406,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641766293
    },
    {
        "content": "<p>how about having a <code>BitMask&lt;LANES&gt;</code> type that implements the appropriate <code>into</code> conversions from/to all integer types? just expose our existing bitmask type?</p>",
        "id": 267380485,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641766423
    },
    {
        "content": "<p>I think that type wouldn't have any methods, only conversions, so I'm not sure it would buy us anything</p>",
        "id": 267380548,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641766500
    },
    {
        "content": "<p>it would buy us having a centralized place for all bitmask-specific operations -- e.g. popcount and int conversions</p>",
        "id": 267380625,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641766610
    },
    {
        "content": "<p>and conversions to avx512 bitmask types</p>",
        "id": 267380635,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641766629
    },
    {
        "content": "<p>also it's useful if you want to store masks in memory and you want density over speed</p>",
        "id": 267380650,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641766678
    },
    {
        "content": "<p>I'm not sure it makes sense for popcount to exist on the bitmask, vs having a <code>count_set</code> fn on masks proper</p>",
        "id": 267380710,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641766743
    },
    {
        "content": "<p>which I'm sure could be implemented much better than a bitmask and popcount on most architectures</p>",
        "id": 267380720,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641766779
    },
    {
        "content": "<p>idk, just trying to think of something that would go...</p>",
        "id": 267380734,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641766798
    },
    {
        "content": "<p>lol</p>",
        "id": 267380779,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641766822
    },
    {
        "content": "<p>yeah it's possible</p>",
        "id": 267380781,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641766824
    },
    {
        "content": "<p>also, bitmask + popcount is the most efficient on a decent pile of archs</p>",
        "id": 267380782,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641766826
    },
    {
        "content": "<p>I guess I'm just thinking if you want to do anything with bitmasks, you manage it yourself as an integer or an array or whatever</p>",
        "id": 267380790,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641766844
    },
    {
        "content": "<p>x86, arm sve, risc-v, simplev</p>",
        "id": 267380798,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641766857
    },
    {
        "content": "<p>doesn't popcount take like 10+ cycles? wouldn't <code>mask.select(ones, zeros).horizontal_sum()</code> be faster even on x86?</p>",
        "id": 267380863,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641766929
    },
    {
        "content": "<p>nevermind, it's plenty fast on most cpus, but terrible on some</p>",
        "id": 267380952,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641767095
    },
    {
        "content": "<p>anyway i think it would make more sense to put most functions on regular masks so you don't have to know how fast bitmasks are on your target</p>",
        "id": 267380965,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641767125
    },
    {
        "content": "<p>yeah, that may be a good idea, tho I still think exposing the <code>BitMask</code> type is a good idea</p>",
        "id": 267381026,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641767215
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// eventually</span>\n<span class=\"cp\">#[repr(transparent)]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">BitMask</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">LANES</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">uint</span>::<span class=\"o\">&lt;</span><span class=\"n\">LANES</span><span class=\"o\">&gt;</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 267381085,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641767300
    },
    {
        "content": "<p>I think fundamentally my problem with it is that it's not a simd type, and it doesn't have anything to do with simd at that point</p>",
        "id": 267381113,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641767360
    },
    {
        "content": "<p>like ints have popcount etc</p>",
        "id": 267381116,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641767371
    },
    {
        "content": "<p>it's simd cuz it can be used for bitmasks, and cuz it still works with LANES &gt; 128</p>",
        "id": 267381143,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641767416
    },
    {
        "content": "<p>unlike <code>u128/64</code></p>",
        "id": 267381145,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641767432
    },
    {
        "content": "<p>and it might trick you into thinking using <code>BitMask</code> is fast(er) and not look for <code>mask.all_set()</code> or whatever</p>",
        "id": 267381146,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641767432
    },
    {
        "content": "<p>yeah, that's why I was leaning for the trait instead though, still supporting all types that make sense</p>",
        "id": 267381159,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641767456
    },
    {
        "content": "<p>those'd be supported by <code>From/Into</code> impls on <code>BitMask</code></p>",
        "id": 267381179,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641767518
    },
    {
        "content": "<p>yeah at this point I think it's just confusing having a bitmask type, I still don't see anything that it offers over the regular mask type with conversions directly on that</p>",
        "id": 267381239,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641767598
    },
    {
        "content": "<p>also the bitmask type inherently wouldn't work without the incomplete rust feature, which is part of the benefit of the trait</p>",
        "id": 267381291,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641767650
    },
    {
        "content": "<p>uuh, it'd work just fine:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">BitMask</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">LANES</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">bytes</span>: <span class=\"nc\">LaneCount</span>::<span class=\"o\">&lt;</span><span class=\"n\">LANES</span><span class=\"o\">&gt;</span>::<span class=\"n\">BitMask</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"c1\">// to be replaced with uint&lt;LANES&gt;</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 267381376,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641767787
    },
    {
        "content": "<p>hmmm</p>",
        "id": 267381382,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641767806
    },
    {
        "content": "<p>that's true</p>",
        "id": 267381398,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641767862
    },
    {
        "content": "<p>benefits include dense storage of masks even with &gt;128 lanes</p>",
        "id": 267381403,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641767880
    },
    {
        "content": "<p>any reason that couldn't just be a <code>[u8; _]</code>?</p>",
        "id": 267381449,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641767899
    },
    {
        "content": "<p>which would also be much more explicit</p>",
        "id": 267381454,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641767911
    },
    {
        "content": "<p>cuz we want to replace its guts with <code>uint&lt;LANES&gt;</code> later, you can't easily replace explicit <code>[u8; _]</code> API types as easily</p>",
        "id": 267381482,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641767986
    },
    {
        "content": "<p>well I was suggesting that if we ever actually got generic integers, we can just implement a function directly on <code>Mask</code>, which would be better than <code>BitMask</code> too</p>",
        "id": 267381537,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641768023
    },
    {
        "content": "<p>though I'm not particularly optimistic about ever getting generic ints</p>",
        "id": 267381551,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641768049
    },
    {
        "content": "<p>idk that I'd want to implement <code>select</code> directly on integer types, hence <code>BitMask</code></p>",
        "id": 267381616,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641768155
    },
    {
        "content": "<p>I didn't think we should implement <code>select</code> on <code>BitMask</code> either though?</p>",
        "id": 267381624,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641768178
    },
    {
        "content": "<p>why not?</p>",
        "id": 267381630,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641768190
    },
    {
        "content": "<p>well why would we?</p>",
        "id": 267381633,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641768196
    },
    {
        "content": "<p>it's implemented on <code>Mask</code></p>",
        "id": 267381634,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641768199
    },
    {
        "content": "<p>cuz you may want to <code>select</code> w/o conversion to a full-mask, e.g. on avx512</p>",
        "id": 267381647,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641768233
    },
    {
        "content": "<p>where we'd probably have to have Mask be full-width due to compat with &lt;= AVX2</p>",
        "id": 267381691,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641768277
    },
    {
        "content": "<p>on avx512 it actually optimizes to using the masked instructions, even with the full-width masks</p>",
        "id": 267381696,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641768297
    },
    {
        "content": "<p>I am not simd expert, but people will need to have <em>some</em> form of to_bitmask with an array of u8 or a u8/u16/u32/u64 to make it practical.<br>\nOtherwise there are a lot of algorithm you cannot implement with std::simd right now and it kind of defeats the purpose</p>",
        "id": 267381698,
        "sender_full_name": "marmeladema",
        "timestamp": 1641768299
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281572\">@marmeladema</span> we are definitely implementing it in some form, we're just bikeshedding the specifics</p>",
        "id": 267381709,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641768329
    },
    {
        "content": "<p>(it's implemented already in some way, but isn't usable on nightly yet)</p>",
        "id": 267381715,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641768348
    },
    {
        "content": "<p>What I meant is that there can be multiple solution to this. and we don't have to implement the perfect solution right now. if we had at least int or array methods right now that'd be sufficient to let people experiment with it</p>",
        "id": 267381761,
        "sender_full_name": "marmeladema",
        "timestamp": 1641768398
    },
    {
        "content": "<p>ie: available in nightly</p>",
        "id": 267381766,
        "sender_full_name": "marmeladema",
        "timestamp": 1641768422
    },
    {
        "content": "<p>yeah, the plan is to have at least the integer versions available asap</p>",
        "id": 267381777,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641768443
    },
    {
        "content": "<p>because I don't believe there are any workarounds at the moment right?</p>",
        "id": 267381779,
        "sender_full_name": "marmeladema",
        "timestamp": 1641768455
    },
    {
        "content": "<p>at the moment, nope</p>",
        "id": 267381830,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641768520
    },
    {
        "content": "<p>call rustc's simd intrinsics directly?</p>",
        "id": 267381853,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641768584
    },
    {
        "content": "<p>well, yeah, technically that, but no workarounds I would consider recommended...</p>",
        "id": 267381905,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641768643
    },
    {
        "content": "<p>I finished the migration to portable simd, but I am getting some performance regressions (+950% in masks of 8 to u8, +25% in horizontal_sum). See <a href=\"https://github.com/jorgecarleitao/arrow2/pull/747\">https://github.com/jorgecarleitao/arrow2/pull/747</a>. Could someone guide me into understanding what am I doing wrong?</p>",
        "id": 267396289,
        "sender_full_name": "Jorge Leitao",
        "timestamp": 1641791027
    },
    {
        "content": "<p>the bitmasks make sense, but I'm not sure why <code>horizontal_min</code> would be any different</p>",
        "id": 267396450,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641791222
    },
    {
        "content": "<p>could that perhaps just be noise in the benchmark?</p>",
        "id": 267396455,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641791231
    },
    {
        "content": "<p>after quickly scanning the code i only noticed 1 thing that looked weird, i left a comment on the PR</p>",
        "id": 267397169,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641792232
    },
    {
        "content": "<p>(other than the stuff already covered in this thread, of course)</p>",
        "id": 267397214,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641792266
    },
    {
        "content": "<p>idea for faster <code>to_bitmask</code> than what <span class=\"user-mention\" data-user-id=\"399416\">@Jorge Leitao</span> has:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">to_bitmask</span><span class=\"p\">(</span><span class=\"n\">m</span>: <span class=\"nc\">mask8x8</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">u8</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">m</span><span class=\"p\">.</span><span class=\"n\">select</span><span class=\"p\">(</span><span class=\"n\">Simd</span>::<span class=\"n\">from_array</span><span class=\"p\">([</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mh\">0x10</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mh\">0x20</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mh\">0x40</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mh\">0x80</span><span class=\"p\">]),</span><span class=\"w\"> </span><span class=\"n\">Simd</span>::<span class=\"n\">splat</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)).</span><span class=\"n\">horizontal_or</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 267397467,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641792686
    },
    {
        "content": "<p>tho it may generate the same assembly after all...</p>",
        "id": 267397518,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641792755
    },
    {
        "content": "<p>apparently <code>horizontal_sum</code> is better on x86: <a href=\"https://rust.godbolt.org/z/75q1Yx3ba\">https://rust.godbolt.org/z/75q1Yx3ba</a></p>",
        "id": 267397938,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641793369
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/mask.20to.20u8/near/267396455\">said</a>:</p>\n<blockquote>\n<p>could that perhaps just be noise in the benchmark?</p>\n</blockquote>\n<p>fwiw, I do not think it is noise in the bench. I can reproduce it systematically. There is something else going on as +25% is significant. Also, note that this is for f32; I will try to get an i32 bench, to see if there is any difference</p>",
        "id": 267399404,
        "sender_full_name": "Jorge Leitao",
        "timestamp": 1641795341
    },
    {
        "content": "<p>here's the <code>from/to_bitmask</code> implemented in terms of the rustc intrinsics, <span class=\"user-mention\" data-user-id=\"399416\">@Jorge Leitao</span> would you mind trying them out? <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=release&amp;edition=2021&amp;gist=4b915815a3db64f49721f1979fff1c17\">https://play.rust-lang.org/?version=nightly&amp;mode=release&amp;edition=2021&amp;gist=4b915815a3db64f49721f1979fff1c17</a></p>",
        "id": 267400209,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641796333
    },
    {
        "content": "<p>they should work with miri and be cross-platform (they're what portable-simd calls internally)</p>",
        "id": 267400239,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641796415
    },
    {
        "content": "<p>Note that the 25% is on an horizontal min, which does not use the from/to_bitmask. The bitmask issue is +900%. For the bitmask issue, we need an implementation for <code>Mask&lt;T, 8&gt;</code> for <code>T: i8...i64,u8..u64,f32,f64</code> (which is a pain to write by hand, right?)</p>",
        "id": 267400466,
        "sender_full_name": "Jorge Leitao",
        "timestamp": 1641796706
    },
    {
        "content": "<p>portable-simd's <code>Mask&lt;T, N&gt;</code> should convert to all other <code>Mask&lt;U, N&gt;</code> using <code>into</code>, iirc</p>",
        "id": 267400537,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641796803
    },
    {
        "content": "<p>llvm should be able to trivially optimize that out</p>",
        "id": 267400552,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641796825
    },
    {
        "content": "<p>I will try to come up with a minimal example that reproduces the issue, so that we can get away from arrow2's code and just work our way out directly from std.</p>",
        "id": 267400570,
        "sender_full_name": "Jorge Leitao",
        "timestamp": 1641796883
    },
    {
        "content": "<p>for floats horizontal_min (min/max in any capacity, really) would be expected to be slower, sadly, due to our IEEE754-compatible handling of edge cases (NaN/-0), which requires a few more instructions. I've seen a ~1.5x slowdown from this, sadly, but it depends how critical it is to your loop ofc.</p>",
        "id": 267470525,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1641835412
    },
    {
        "content": "<p>(which is enough that I'll end up keeping separate x86 and std::simd routes for cases where I know it can't impact the output that use those operations heavily.... Thankfully, it should only be that way for float simd. Unfortunately, the most obvious fix, assume some kind of eventual \"allow incorrect math optimizations\" (a la -ffast-math) feature solves it, is tricky, as it would likely require some equivalent to the \"finite math only\" fast math flag, which is the... dangerous one, which we'll quite possibly never get stably)</p>",
        "id": 267471422,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1641835818
    },
    {
        "content": "<p>x86 also has different min/max behavior than ieee for signed zeros</p>",
        "id": 267472365,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641836239
    },
    {
        "content": "<p>yeah</p>",
        "id": 267473164,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1641836544
    },
    {
        "content": "<p>wait, packed_simd is not compatible with IEEE754??</p>",
        "id": 267473274,
        "sender_full_name": "Jorge Leitao",
        "timestamp": 1641836599
    },
    {
        "content": "<p>x86 min/max with portable_simd: <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=release&amp;edition=2021&amp;gist=3978cd74b4ec1200bd3e69a8b2f3a35f\">https://play.rust-lang.org/?version=nightly&amp;mode=release&amp;edition=2021&amp;gist=3978cd74b4ec1200bd3e69a8b2f3a35f</a></p>",
        "id": 267473522,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641836714
    },
    {
        "content": "<p>i'd expect packed_simd is ieee compatible for most ops, just not min/max cuz they're slower on x86</p>",
        "id": 267473672,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641836773
    },
    {
        "content": "<p>tho i haven't checked for sure</p>",
        "id": 267473701,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641836791
    },
    {
        "content": "<p>Maybe I'm wrong, but I'd expect packed_simd to use the same intrinsic as std::simd?</p>",
        "id": 267473924,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641836883
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"229517\">Jacob Lifshay</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/mask.20to.20u8/near/267473672\">said</a>:</p>\n<blockquote>\n<p>i'd expect packed_simd is ieee compatible for most ops, just not min/max cuz they're slower on x86</p>\n</blockquote>\n<p>sorry, yes, I meant for min/max</p>",
        "id": 267474144,
        "sender_full_name": "Jorge Leitao",
        "timestamp": 1641836995
    },
    {
        "content": "<p>ah, yeah, packed_simd seems to just call the rustc intrinsic...</p>",
        "id": 267474968,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641837304
    },
    {
        "content": "<p>portable_simd tries to do ieee-compatible min/max, but misses signed zeros</p>",
        "id": 267475084,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641837343
    },
    {
        "content": "<p>actually, they use minnum/maxnum which explicitly doesn't specify which signed zero is chosen, so portable-simd and packed_simd are ieee compatible</p>",
        "id": 267477390,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641838170
    },
    {
        "content": "<p>i was thinking of minimum/maximum which specify <code>-0.0 &lt; 0.0</code></p>",
        "id": 267477509,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1641838211
    },
    {
        "content": "<p>comparing packed_simd to std::simd, both simply call the <code>simd_reduce_{min,max}</code> intrinsics, so I don't see any good reason why performance would change by 25%</p>",
        "id": 267513648,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641855386
    },
    {
        "content": "<p>if it were an inlining issue, I'd expect the performance difference to be much more dramatic than that, so I expect them to be identical</p>",
        "id": 267513681,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641855417
    },
    {
        "content": "<p>which is why i'm inclined towards it being a problem with the benchmark itself</p>",
        "id": 267513712,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1641855438
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/mask.20to.20u8/near/267513712\">said</a>:</p>\n<blockquote>\n<p>which is why i'm inclined towards it being a problem with the benchmark itself</p>\n</blockquote>\n<p>I was able to reproduce it on a small setup and continue to see difference in perf:</p>\n<div class=\"codehilite\"><pre><span></span><code>core_simd_min 2^20 f32     [286.86 us 289.22 us 292.03 us]\npacked_simd_min 2^20 f32   [230.50 us 234.12 us 238.86 us]\nnonsimd_min 2^20 f32       [245.75 us 249.19 us 254.00 us]\nnaive_min 2^20 f32         [2.8560 ms 2.8721 ms 2.8885 ms]\n</code></pre></div>\n<p>i.e. it is faster to _not_ use std::simd than using std::simd atm. Code here: <a href=\"https://github.com/DataEngineeringLabs/simd-benches\">https://github.com/DataEngineeringLabs/simd-benches</a> with the implementation of each of the functions here: <a href=\"https://github.com/DataEngineeringLabs/simd-benches/blob/main/src/min.rs#L12\">https://github.com/DataEngineeringLabs/simd-benches/blob/main/src/min.rs#L12</a></p>",
        "id": 267906987,
        "sender_full_name": "Jorge Leitao",
        "timestamp": 1642096838
    },
    {
        "content": "<p>Okay, that's what I suspected, the difference here is certainly not on the horizontal minimum, but on the lanewise minimum</p>",
        "id": 267909408,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1642097995
    },
    {
        "content": "<p>The horizontal minimum in std::simd and packed_simd are identical, but the lanewise minimum in packed_simd does not account for NANs, while std::simd's does</p>",
        "id": 267909582,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1642098056
    },
    {
        "content": "<p>ok, so the difference is expected because they have different semantics?</p>",
        "id": 267909694,
        "sender_full_name": "Jorge Leitao",
        "timestamp": 1642098118
    },
    {
        "content": "<p>I am surprised that the SIMD and scalar implementations are nearly identical, but I suspect that's because of autovectorization since you're using native target features</p>",
        "id": 267909766,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1642098145
    },
    {
        "content": "<p>Yeah, I think that's expected.</p>",
        "id": 267909786,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1642098156
    },
    {
        "content": "<p>On architectures that already account for NANs (avx512, I think?) I believe there would be no difference in performance</p>",
        "id": 267909849,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1642098190
    },
    {
        "content": "<p>(and if there is, that's a bug)</p>",
        "id": 267909878,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1642098207
    },
    {
        "content": "<p>those results were not on native; on native we have:</p>\n<div class=\"codehilite\"><pre><span></span><code>core_simd_min 2^20 f32     [376.98 us 378.40 us 379.72 us]\npacked_simd_min 2^20 f32   [181.77 us 182.95 us 185.05 us]\nnonsimd_min 2^20 f32       [185.89 us 186.35 us 186.83 us]\nnaive_min 2^20 f32         [2.0208 ms 2.0274 ms 2.0341 ms]\n</code></pre></div>\n<p>which is even worse (and the computer has avx512 (it is sky something (lane, line?)))</p>",
        "id": 267911819,
        "sender_full_name": "Jorge Leitao",
        "timestamp": 1642099163
    },
    {
        "content": "<p>That's definitely unexpected, I'll have to look at the assembly</p>",
        "id": 267913226,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1642099862
    },
    {
        "content": "<p>thanks! I filled it here <a href=\"https://github.com/rust-lang/portable-simd/issues/222\">https://github.com/rust-lang/portable-simd/issues/222</a> so that I can track it on github</p>",
        "id": 267914046,
        "sender_full_name": "Jorge Leitao",
        "timestamp": 1642100230
    },
    {
        "content": "<p>avx512 doesn't change <code>vmaxps</code>'s behavior around nans/zeros, so it still follows pre-existing x86 behavior, not <code>maxnum</code>, <code>maximum</code>, or any other ieee max function.</p>",
        "id": 267916803,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1642101402
    },
    {
        "content": "<p>unless avx512 added some other new max/min instructions (i'm not aware of any), x86 doesn't have ieee-compliant min/max, so it always needs emulation</p>",
        "id": 267917050,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1642101498
    },
    {
        "content": "<p>it is still unexpected imo because the nonsimd_min uses native Rust (i.e. just core), which has the same semantics (and it is 2x faster)</p>",
        "id": 267917271,
        "sender_full_name": "Jorge Leitao",
        "timestamp": 1642101613
    },
    {
        "content": "<p>It's just an issue of poor optimization: <a href=\"https://rust.godbolt.org/z/eqc46ao68\">https://rust.godbolt.org/z/eqc46ao68</a></p>",
        "id": 267917530,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1642101730
    },
    {
        "content": "<p>We don't use min/max intrinsics (yet) but I assume that would solve it</p>",
        "id": 267917599,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1642101768
    },
    {
        "content": "<p>all the <code>min</code>s: <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=release&amp;edition=2021&amp;gist=67838ab49be7b267d10f2bd48aaae596\">https://play.rust-lang.org/?version=nightly&amp;mode=release&amp;edition=2021&amp;gist=67838ab49be7b267d10f2bd48aaae596</a></p>",
        "id": 267917840,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1642101886
    },
    {
        "content": "<p>look at x86 assembly</p>",
        "id": 267917869,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1642101901
    },
    {
        "content": "<p>The scalar vectorizes well because llvm is pretty good at widening intrinsics</p>",
        "id": 267917887,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1642101908
    },
    {
        "content": "<p>When I get a chance, I'll add min/max intrinsics... and probably do ieee754-2018 rounding since I think that's generally desirable</p>",
        "id": 267917925,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1642101945
    },
    {
        "content": "<p>Wait--is that indicating that <code>simd_fmin</code> does check NANs?</p>",
        "id": 267918058,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1642102004
    },
    {
        "content": "<p>also cuz scalar min uses the same llvm intrinsic as the simd_min intrinsic provided by rustc (that std::simd doesn't use, but packed_simd does)</p>",
        "id": 267918081,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1642102016
    },
    {
        "content": "<blockquote>\n<p>Wait--is that indicating that <code>simd_fmin</code> does check NANs?</p>\n</blockquote>\n<p>yes</p>",
        "id": 267918138,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1642102048
    },
    {
        "content": "<p>My understanding was that <code>simd_fmin</code> didn't check NANs, but now that I think about it, that likely refers back to when rustc was broken and applying fast-math to all intrinsics.</p>",
        "id": 267918143,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1642102051
    },
    {
        "content": "<p>It looks like we can trivially use the <code>simd_fmin</code> intrinsic now</p>",
        "id": 267918249,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1642102086
    },
    {
        "content": "<p>I'll draft that PR later, it shouldn't be a big deal at all.  I need to finish up the one for improving bitmasks too.</p>",
        "id": 267918427,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1642102185
    },
    {
        "content": "<p>oh, and really sorry for writing <code>horizontal_min</code>. I am implementing an horizontal min, but the API is <code>min</code> :/</p>",
        "id": 267918492,
        "sender_full_name": "Jorge Leitao",
        "timestamp": 1642102203
    },
    {
        "content": "<p>No problem, it's good to dig into everything to make sure we're actually implementing everything right</p>",
        "id": 267918533,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1642102225
    },
    {
        "content": "<p>I have also filled <a href=\"https://github.com/rust-lang/portable-simd/issues/223\">https://github.com/rust-lang/portable-simd/issues/223</a> to see if it is possible to re-write from_bitmap/to_bitmap without const generics expr, so they are generally available in <code>std::simd</code></p>",
        "id": 267919156,
        "sender_full_name": "Jorge Leitao",
        "timestamp": 1642102519
    },
    {
        "content": "<p>i think you mean bitmask, not bitmap?</p>",
        "id": 267920273,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1642103070
    },
    {
        "content": "<p><span aria-label=\"face palm\" class=\"emoji emoji-1f926\" role=\"img\" title=\"face palm\">:face_palm:</span>  sorry yes</p>",
        "id": 267920509,
        "sender_full_name": "Jorge Leitao",
        "timestamp": 1642103186
    }
]