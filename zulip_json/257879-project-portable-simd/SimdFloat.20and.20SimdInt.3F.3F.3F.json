[
    {
        "content": "<p>So vaguely related, but I've been meaning to propose separating our types into SimdFloat, SimdInt, or whatever</p>",
        "id": 272630106,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1645406665
    },
    {
        "content": "<p>With the implication that we don't use any traits at all, everything would be inherent functions</p>",
        "id": 272630114,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1645406685
    },
    {
        "content": "<p>I have been thinking about that idea but I think that removing all traits whatsoever runs into the lack of genericity over vector types.</p>",
        "id": 272630146,
        "sender_full_name": "Jubilee",
        "timestamp": 1645406729
    },
    {
        "content": "<p>I have also been thinking about how it would make the current pattern used by <code>to_int_unchecked</code> more annoying to express, and how that would be more annoying for user code as well. So  I think that chucking trait-driven genericity out the door entirely is a bad idea.</p>",
        "id": 272630238,
        "sender_full_name": "Jubilee",
        "timestamp": 1645406872
    },
    {
        "content": "<p>Well a little off topic down that rabbit hole, but anything that doesn't just use Self gets really nasty</p>",
        "id": 272630333,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1645406990
    },
    {
        "content": "<p>But the overlap with the function naming is then we wouldn't really have to worry much about disambiguating names of functions</p>",
        "id": 272630397,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1645407043
    },
    {
        "content": "<p>&lt;_&lt;</p>",
        "id": 272630497,
        "sender_full_name": "Jubilee",
        "timestamp": 1645407214
    },
    {
        "content": "<p>As far as genericity goes, you would then do something like SimdFloat&lt;T&gt; and make T generic. If you wanted to do something generic over ALL simd types you're really going to be pretty limited with what you can do anyway</p>",
        "id": 272630499,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1645407217
    },
    {
        "content": "<p>(of course we can make traits for those at some point in the future, either in std or a crate)</p>",
        "id": 272630548,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1645407252
    },
    {
        "content": "<p>Well, I am talking about the question of genericity over SimdInt and SimdUInt.</p>",
        "id": 272630556,
        "sender_full_name": "Jubilee",
        "timestamp": 1645407262
    },
    {
        "content": "<p>Yeah, I really think we ought to wait until we figure out that story for scalars too. We're not exactly generic over them right now either</p>",
        "id": 272630579,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1645407304
    },
    {
        "content": "<p>er</p>",
        "id": 272630589,
        "sender_full_name": "Jubilee",
        "timestamp": 1645407323
    },
    {
        "content": "<p>The problem is that for the current <code>Simd&lt;T, N&gt;</code> pattern, if you want to implement a method that is generic over various kinds of T, then if the T you want implements a trait, then you can bound on that, and <code>Simd</code> is transparent.</p>",
        "id": 272630665,
        "sender_full_name": "Jubilee",
        "timestamp": 1645407432
    },
    {
        "content": "<p>The reason that doesn't quite work is if you have functions with the same name but different signatures for different Ts</p>",
        "id": 272630728,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1645407488
    },
    {
        "content": "<p>That doesn't necessarily matter.</p>",
        "id": 272630747,
        "sender_full_name": "Jubilee",
        "timestamp": 1645407531
    },
    {
        "content": "<p>I'm not sure what you mean</p>",
        "id": 272630756,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1645407547
    },
    {
        "content": "<p>You can't implement conflicting functions with the same name</p>",
        "id": 272630764,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1645407571
    },
    {
        "content": "<p>Trait bounds are not sufficient to deconflict the functions because rustc has no way of marking two traits as exclusively implemented</p>",
        "id": 272630832,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1645407621
    },
    {
        "content": "<p>I mean negative coherence was actually implemented recently...</p>",
        "id": 272630951,
        "sender_full_name": "Jubilee",
        "timestamp": 1645407787
    },
    {
        "content": "<p>But aside from that, I am talking about situations where a single T becomes many U which do not all fit nicely into the SimdFloat or SimdInt or SimdUint categories, but rather are split across them.</p>",
        "id": 272631014,
        "sender_full_name": "Jubilee",
        "timestamp": 1645407852
    },
    {
        "content": "<p>What do you mean by that?</p>",
        "id": 272631027,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1645407880
    },
    {
        "content": "<p>My proposal is that f32 and f64 are SimdFloat, u* is SimdUint, etc</p>",
        "id": 272631043,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1645407917
    },
    {
        "content": "<p>maybe have a trait <code>SimdMyOp</code> for <code>fn my_op</code> and the inherent <code>fn my_op</code> forwards to that trait, and the trait is implemented for whatever <code>SimdFloat</code> or other traits are needed. specialization can be used there to force rustc to allow what it thinks are overlapping impls</p>",
        "id": 272631138,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1645408041
    },
    {
        "content": "<p>Currently, <code>Simd&lt;T&gt; -&gt; Simd&lt;U&gt;</code> is easy.<br>\n<code>SimdInt&lt;T&gt; -&gt; SimdInt&lt;U&gt; OR SimdUint&lt;U&gt;</code> is not.</p>",
        "id": 272631196,
        "sender_full_name": "Jubilee",
        "timestamp": 1645408088
    },
    {
        "content": "<p>Those are pretty trivial if you use a marker trait</p>",
        "id": 272631225,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1645408144
    },
    {
        "content": "<p>Defining an individual trait for each operation becomes ridiculous IMO</p>",
        "id": 272631307,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1645408215
    },
    {
        "content": "<p>We couldn't even come to an agreement on SimdPartialEq and we're looking at tons more functions beyond that, which aren't anywhere near as uniform between types</p>",
        "id": 272631422,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1645408365
    },
    {
        "content": "<p>As a comparison--would it make sense to make f32 and u32 the same generic type?</p>",
        "id": 272631464,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1645408437
    },
    {
        "content": "<p>Bits&lt;32&gt;, let's roll. <span aria-label=\"sunglasses\" class=\"emoji emoji-1f60e\" role=\"img\" title=\"sunglasses\">:sunglasses:</span></p>",
        "id": 272631510,
        "sender_full_name": "Jubilee",
        "timestamp": 1645408457
    },
    {
        "content": "<p>The issue for <code>SimdInt&lt;T&gt; -&gt; SimdInt&lt;U&gt; OR SimdUint&lt;U&gt;</code> can be solved by offering <code>V, W: Vector</code> and going from <code>V&lt;T&gt; -&gt; W&lt;U&gt;</code></p>",
        "id": 272631731,
        "sender_full_name": "Jubilee",
        "timestamp": 1645408720
    },
    {
        "content": "<p>Well or T: SimdConvert&lt;U&gt; or something</p>",
        "id": 272631778,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1645408799
    },
    {
        "content": "<p>Alternatively, because now the vector is embedded with some type semantics, SimdFloat could have <code>to_int</code>, <code>to_uint</code>, etc</p>",
        "id": 272632004,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1645408945
    },
    {
        "content": "<p>I'm not sure there's necessarily any justification for doing all conversions under one function other than that's what <code>as</code> already does</p>",
        "id": 272632028,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1645408995
    },
    {
        "content": "<p>Mostly I want to be sure that people can still write whatever functions they need to in general, the only sense of conversion I mean per se is the sense that all functions apply conversions, sometimes into booleans.</p>",
        "id": 272632099,
        "sender_full_name": "Jubilee",
        "timestamp": 1645409056
    },
    {
        "content": "<p>So to clarify my main objection is against throwing out all traits, rather than against splitting Simd up. A single trait can handle the way Simd manages the concept of genericity.</p>",
        "id": 272632148,
        "sender_full_name": "Jubilee",
        "timestamp": 1645409115
    },
    {
        "content": "<p>Oh yeah, I'm not saying \"no traits\"</p>",
        "id": 272632216,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1645409171
    },
    {
        "content": "<p>I'd also like to coerce rustc into allowing all the functions that we <strong>do</strong> implement over all SIMD types to in fact be on a single trait and not have to be repetitively reimplemented on types.</p>",
        "id": 272632265,
        "sender_full_name": "Jubilee",
        "timestamp": 1645409265
    },
    {
        "content": "<p>Like splat etc?</p>",
        "id": 272632340,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1645409329
    },
    {
        "content": "<p>Yeah.</p>",
        "id": 272632351,
        "sender_full_name": "Jubilee",
        "timestamp": 1645409343
    },
    {
        "content": "<p>That might work. Though there's some precedent with doing things slightly different with masks vs Simd</p>",
        "id": 272632371,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1645409379
    },
    {
        "content": "<p>Probably would just need to evaluate what makes sense, what doesn't</p>",
        "id": 272632385,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1645409402
    },
    {
        "content": "<p>Yeah, it has been feeling inevitable that Mask will mutate into its own weird thing and not be \"just another SIMD type\".</p>",
        "id": 272632447,
        "sender_full_name": "Jubilee",
        "timestamp": 1645409443
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"312331\">@Caleb Zulawski</span> Speaking of this, I just discovered we can do something very interesting as of recently:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"k\">crate</span>::<span class=\"n\">simd</span>::<span class=\"p\">{</span><span class=\"n\">LaneCount</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Simd</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">SupportedLaneCount</span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Vectorize</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Vector</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">splat</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span>::<span class=\"n\">Vector</span><span class=\"o\">&lt;</span><span class=\"n\">N</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">struct</span> <span class=\"nc\">SimdFloat</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">Simd</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">SupportedLaneCount</span>: <span class=\"nc\">LaneCount</span><span class=\"o\">&lt;</span><span class=\"n\">N</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Vectorize</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"kt\">f32</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Vector</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">SimdFloat</span><span class=\"o\">&lt;</span><span class=\"kt\">f32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">splat</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span>::<span class=\"n\">Vector</span><span class=\"o\">&lt;</span><span class=\"n\">N</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">Simd</span>::<span class=\"n\">splat</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 273013390,
        "sender_full_name": "Jubilee",
        "timestamp": 1645651529
    },
    {
        "content": "<p>That's... An interesting idea</p>",
        "id": 273014884,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1645652311
    },
    {
        "content": "<p>That's vaguely the direction my PartialEq PR was going in, I really like this</p>",
        "id": 273014932,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1645652342
    },
    {
        "content": "<p>There's no reason splat really needs to be a member of the vector itself at all...</p>",
        "id": 273015000,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1645652387
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"k\">crate</span>::<span class=\"n\">simd</span>::<span class=\"o\">*</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">use</span><span class=\"w\"> </span><span class=\"k\">crate</span>::<span class=\"n\">simd</span>::<span class=\"p\">{</span><span class=\"n\">LaneCount</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Simd</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">SupportedLaneCount</span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Vectorize</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Vector</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">LaneCount</span><span class=\"o\">&lt;</span><span class=\"n\">N</span><span class=\"o\">&gt;</span>: <span class=\"nc\">SupportedLaneCount</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">splat</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span>::<span class=\"n\">Vector</span><span class=\"o\">&lt;</span><span class=\"n\">N</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">LaneCount</span><span class=\"o\">&lt;</span><span class=\"n\">N</span><span class=\"o\">&gt;</span>: <span class=\"nc\">SupportedLaneCount</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"cp\">#[derive(Debug, PartialEq)]</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">SimdFloat</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">Simd</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">LaneCount</span><span class=\"o\">&lt;</span><span class=\"n\">N</span><span class=\"o\">&gt;</span>: <span class=\"nc\">SupportedLaneCount</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">T</span>: <span class=\"nc\">SimdElement</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Vectorize</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"kt\">f32</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Vector</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">LaneCount</span><span class=\"o\">&lt;</span><span class=\"n\">N</span><span class=\"o\">&gt;</span>: <span class=\"nc\">SupportedLaneCount</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">SimdFloat</span><span class=\"o\">&lt;</span><span class=\"kt\">f32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">splat</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span>::<span class=\"n\">Vector</span><span class=\"o\">&lt;</span><span class=\"n\">N</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">LaneCount</span><span class=\"o\">&lt;</span><span class=\"n\">N</span><span class=\"o\">&gt;</span>: <span class=\"nc\">SupportedLaneCount</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">SimdFloat</span><span class=\"p\">(</span><span class=\"n\">Simd</span>::<span class=\"n\">splat</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">))</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"cp\">#[cfg(test)]</span><span class=\"w\"></span>\n<span class=\"k\">mod</span> <span class=\"nn\">tests</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"k\">super</span>::<span class=\"o\">*</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"cp\">#[test]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">test_gat</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"kt\">f32</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">Vectorize</span><span class=\"o\">&gt;</span>::<span class=\"n\">splat</span>::<span class=\"o\">&lt;</span><span class=\"mi\">4</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"mf\">1.0</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">SimdFloat</span><span class=\"p\">(</span><span class=\"n\">f32x4</span>::<span class=\"n\">splat</span><span class=\"p\">(</span><span class=\"mf\">1.0</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Okay with the current architecture re: bounds and such it gets a bit messier once I actually try to make a test compile, but it <strong>does</strong> compile. :D</p>",
        "id": 273016219,
        "sender_full_name": "Jubilee",
        "timestamp": 1645653135
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/SimdFloat.20and.20SimdInt.3F.3F.3F/near/273015000\">said</a>:</p>\n<blockquote>\n<p>There's no reason splat really needs to be a member of the vector itself at all...</p>\n</blockquote>\n<p>Going even further (perhaps too far),</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">Splat</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Add</span><span class=\"o\">&lt;</span><span class=\"n\">Splat</span><span class=\"o\">&lt;</span><span class=\"kt\">f32</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Simd</span><span class=\"o\">&lt;</span><span class=\"kt\">f32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"nb\">From</span><span class=\"o\">&lt;</span><span class=\"n\">Splat</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Simd</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 273016372,
        "sender_full_name": "scottmcm",
        "timestamp": 1645653241
    },
    {
        "content": "<p>( I am pretty sure with rearchitecting it this can be made less... <em>vague gesture</em> )</p>",
        "id": 273016378,
        "sender_full_name": "Jubilee",
        "timestamp": 1645653242
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> interesting...</p>",
        "id": 273016546,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1645653337
    },
    {
        "content": "<p>Yes!</p>",
        "id": 273016559,
        "sender_full_name": "Jubilee",
        "timestamp": 1645653349
    },
    {
        "content": "<p>And I might as well add</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"nb\">From</span><span class=\"o\">&lt;</span><span class=\"n\">Splat</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">T</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 273016644,
        "sender_full_name": "scottmcm",
        "timestamp": 1645653387
    },
    {
        "content": "<p>That kind of \"this library should be expressing type relationships\" is what I was thinking of, essentially.</p>",
        "id": 273016651,
        "sender_full_name": "Jubilee",
        "timestamp": 1645653392
    },
    {
        "content": "<p>So I was thinking more about this and the biggest issue I see are things like select and swizzles becoming much more complicated</p>",
        "id": 275115091,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1647116137
    },
    {
        "content": "<p>Those really make use of <code>Simd</code> being effectively a container</p>",
        "id": 275115141,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1647116176
    },
    {
        "content": "<p>Yeaaaah.</p>",
        "id": 275115172,
        "sender_full_name": "Jubilee",
        "timestamp": 1647116246
    },
    {
        "content": "<p>I'm now leaning more towards SimdFloat, SimdInt, etc traits</p>",
        "id": 275115248,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1647116371
    },
    {
        "content": "<p>I think it might be a good idea to not attempt to deduplicate functions across those, e.g. SimdFloat and SimdInt would both have <code>abs</code> which is fine</p>",
        "id": 275115334,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1647116485
    },
    {
        "content": "<p>Which is probably an improvement from what we have now, where the documentation for the behavior of each is lumped together</p>",
        "id": 275115352,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1647116522
    },
    {
        "content": "<p>I'm also considering the possiblity that <code>eq</code> and friends can be in those traits rather than something attempting to generalize across all PartialEq types etc</p>",
        "id": 275115409,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1647116588
    },
    {
        "content": "<p>This is still pretty extensible I think, we can add SimdPointer etc traits in the future for example</p>",
        "id": 275115481,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1647116663
    },
    {
        "content": "<p>The <em>only</em> downside is that if you do this people will ask for a ScalarFloat and ScalarInt deal as well</p>",
        "id": 275116741,
        "sender_full_name": "Lokathor",
        "timestamp": 1647118526
    },
    {
        "content": "<p>Maybe, the justification here is different though. The trait is necessary because all vectors share a single container type, which isn't true for scalars</p>",
        "id": 275116795,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1647118585
    },
    {
        "content": "<p>Not to say it wouldn't be nice but you can always use the num crate, here it's a necessity</p>",
        "id": 275116804,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1647118617
    },
    {
        "content": "<p>Yeah, while I would like that symmetry personally and still have plans to make that closer to reality, the reason I proposed a heavily trait-oriented solution is that essentially, no matter what we do, <strong>something</strong> has to be a trait in order to make this make sense.</p>",
        "id": 275117375,
        "sender_full_name": "Jubilee",
        "timestamp": 1647119393
    },
    {
        "content": "<p>One thing I just realized is that if <code>eq</code> etc are part of the traits, we can't simply use the same name because it won't have priority (and if our traits aren't in the prelude, they won't be in scope at all by default)</p>",
        "id": 275118023,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1647120467
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/SimdFloat.20and.20SimdInt.3F.3F.3F/near/275115334\">said</a>:</p>\n<blockquote>\n<p>I think it might be a good idea to not attempt to deduplicate functions across those, e.g. SimdFloat and SimdInt would both have <code>abs</code> which is fine</p>\n</blockquote>\n<p>Hmm, is name resolution happy to have two same-name trait methods in scope?</p>",
        "id": 275118523,
        "sender_full_name": "scottmcm",
        "timestamp": 1647121240
    },
    {
        "content": "<p>I think it should be fine simply because no vector will implement both SimdFloat and SimdInt</p>",
        "id": 275118679,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1647121523
    },
    {
        "content": "<p>Of course we can't actually embed that in the trait bounds (yet?)</p>",
        "id": 275118684,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1647121544
    },
    {
        "content": "<p>Well, while i agree that the trait is good, it's not <em>necessary</em> because you really can have each method const generic over a lane count and a particular element type (because that's how it is now).</p>\n<p>So i still anticipate that being a discussion you have to walk people through.</p>",
        "id": 275118727,
        "sender_full_name": "Lokathor",
        "timestamp": 1647121591
    },
    {
        "content": "<p>Negative coherence almost exists.</p>",
        "id": 275118875,
        "sender_full_name": "Jubilee",
        "timestamp": 1647121843
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/SimdFloat.20and.20SimdInt.3F.3F.3F/near/275118727\">said</a>:</p>\n<blockquote>\n<p>Well, while i agree that the trait is good, it's not <em>necessary</em> because you really can have each method const generic over a lane count and a particular element type (because that's how it is now).</p>\n<p>So i still anticipate that being a discussion you have to walk people through.</p>\n</blockquote>\n<p>Yep true, we can always just point someone to an old revision of the docs as justification <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 275119000,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1647122047
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/SimdFloat.20and.20SimdInt.3F.3F.3F/near/275118875\">said</a>:</p>\n<blockquote>\n<p>Negative coherence almost exists.</p>\n</blockquote>\n<p>Yeah, I was hinting at this, though I really don't think we need it anyway</p>",
        "id": 275119005,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1647122071
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/SimdFloat.20and.20SimdInt.3F.3F.3F/near/275118023\">said</a>:</p>\n<blockquote>\n<p>One thing I just realized is that if <code>eq</code> etc are part of the traits, we can't simply use the same name because it won't have priority (and if our traits aren't in the prelude, they won't be in scope at all by default)</p>\n</blockquote>\n<p>I think we could get around this though.</p>",
        "id": 275129644,
        "sender_full_name": "Jubilee",
        "timestamp": 1647140633
    },
    {
        "content": "<p>But it relies on hax.</p>",
        "id": 275129689,
        "sender_full_name": "Jubilee",
        "timestamp": 1647140651
    },
    {
        "content": "<p>I guess we could always just duplicate the function on Simd</p>",
        "id": 275129708,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1647140715
    },
    {
        "content": "<p>Oh I meant by Breaking Reality.</p>",
        "id": 275129716,
        "sender_full_name": "Jubilee",
        "timestamp": 1647140731
    },
    {
        "content": "<p>Go on</p>",
        "id": 275129724,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1647140752
    },
    {
        "content": "<p>Ah, so it requires someone to crab up and do the thing that I dodged via StdFloat as a workaround, but you have heard me mention \"inherent traits\" a few times, i.e. traits that are always in scope for a type (and that have overriding priority for name resolution). It turns out the functionality in the compiler already exists to make that happen, if it's a lang item, because it's actually the mechanism used to allow e.g. <code>f32::sin</code> to work at all.</p>",
        "id": 275129859,
        "sender_full_name": "Jubilee",
        "timestamp": 1647140977
    },
    {
        "content": "<p>Ah I see</p>",
        "id": 275129912,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1647141051
    },
    {
        "content": "<p>Is it done with a trait?</p>",
        "id": 275129927,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1647141096
    },
    {
        "content": "<p>More specifically it would just be saying name resolution works differently for these types to the compiler, which complicates the compiler slightly with our implementation, but we can make it work kind of arbitrarily.</p>",
        "id": 275129973,
        "sender_full_name": "Jubilee",
        "timestamp": 1647141148
    },
    {
        "content": "<p>I should clarify that saying this is possible does not necessarily mean I think it is the best solution, rather, I think it is best to be aware of all of our options.</p>",
        "id": 275130055,
        "sender_full_name": "Jubilee",
        "timestamp": 1647141286
    },
    {
        "content": "<p>Do we think there's any harm making a <code>SimdPartialOrd</code> trait that also contains <code>min</code>,<code>max</code>, <code>clamp</code> like <code>Ord</code> but doesn't require <code>Ord</code>'s symmetry, meaning we can implement it on floats too?</p>",
        "id": 275162036,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1647187857
    },
    {
        "content": "<p>SIMD comparisons by definition are going to be a little less strict... no <code>partial_cmp</code> equivalent function</p>",
        "id": 275162106,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1647187946
    },
    {
        "content": "<p>sounds like a good idea, you'd want <code>SimdPartialOrd</code> to also have <code>lt</code>/<code>le</code>/<code>gt</code>/<code>ge</code> members that return <code>Mask</code>. or, you could cram <code>eq</code>/<code>ne</code> in there too and name it <code>SimdCmp</code> instead -- though we may want to not add <code>eq</code>/<code>ne</code> there since we might want <code>Simd&lt;EqOnly, ...&gt;</code> sometime in the future?</p>",
        "id": 275173282,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1647203212
    },
    {
        "content": "<p>For now I opened <a href=\"https://github.com/rust-lang/portable-simd/issues/265\">portable-simd#265</a> which matches scalars exactly, but I think we have the option of condensing it in the future</p>",
        "id": 275173396,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1647203361
    },
    {
        "content": "<p>I kinda feel like Rust should have MinMax as a separate trait that Ord implies.</p>",
        "id": 275176300,
        "sender_full_name": "Jubilee",
        "timestamp": 1647207511
    },
    {
        "content": "<p>That would still have the problem of whether <code>max(None, Some(3))</code> is <code>None</code> or <code>Some(3)</code>.</p>\n<p>I'd like it as a separate trait, but it can't be implied by <code>Ord</code> without inheriting <code>Option</code>'s mistakes.</p>",
        "id": 275176875,
        "sender_full_name": "scottmcm",
        "timestamp": 1647208401
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/SimdFloat.20and.20SimdInt.3F.3F.3F/near/275176875\">said</a>:</p>\n<blockquote>\n<p>That would still have the problem of whether <code>max(None, Some(3))</code> is <code>None</code> or <code>Some(3)</code>.</p>\n<p>I'd like it as a separate trait, but it can't be implied by <code>Ord</code> without inheriting <code>Option</code>'s mistakes.</p>\n</blockquote>\n<p>I wasn't thinking about  it as a way to \"fix\" Option implementing Ord.</p>",
        "id": 275268545,
        "sender_full_name": "Jubilee",
        "timestamp": 1647277966
    },
    {
        "content": "<p>What about a clippy lint that warns if you use any Ord functions directly on Simd?</p>",
        "id": 275302638,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1647294517
    },
    {
        "content": "<p>You can still pass it into a data structure that requires Ord, but warn that you probably mean something else if you're calling it directly</p>",
        "id": 275302682,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1647294554
    }
]