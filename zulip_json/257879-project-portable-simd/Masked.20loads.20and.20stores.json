[
    {
        "content": "<p>Should these methods be offered on <code>ptr</code>, as equivalents to <code>ptr::read</code> and <code>ptr::write</code>?</p>",
        "id": 271049352,
        "sender_full_name": "Jubilee",
        "timestamp": 1644271551
    },
    {
        "content": "<p>sure, but also on  references to arrays/slices</p>",
        "id": 271050399,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1644272023
    },
    {
        "content": "<p>we'd also want unaligned variants</p>",
        "id": 271050880,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1644272160
    },
    {
        "content": "<p>I think we probably want the unaligned variants to be the defaults, since we generally think of arrays as aligned to the element type</p>",
        "id": 271050987,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1644272208
    },
    {
        "content": "<p>Default meaning having the shortest function name</p>",
        "id": 271051034,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1644272235
    },
    {
        "content": "<p>maybe we'd want masked read/write to ptr to Simd so we can get full alignof(Simd) alignment</p>",
        "id": 271051062,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1644272252
    },
    {
        "content": "<p>masked read/write to ptr to element or array/slice of element should have element align</p>",
        "id": 271051187,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1644272294
    },
    {
        "content": "<p>unaligned read/write shouldn't be default -- it means align=1</p>",
        "id": 271051238,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1644272322
    },
    {
        "content": "<p>Yeah, the pointers could be different to indicate alignment</p>",
        "id": 271051248,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1644272325
    },
    {
        "content": "<p>I don't mean completely unaligned, I mean scalar aligned</p>",
        "id": 271051307,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1644272355
    },
    {
        "content": "<p><a href=\"https://llvm.org/docs/LangRef.html#llvm-masked-load-intrinsics\">https://llvm.org/docs/LangRef.html#llvm-masked-load-intrinsics</a></p>",
        "id": 271051422,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1644272414
    },
    {
        "content": "<p>^ has align parameter</p>",
        "id": 271051441,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1644272426
    },
    {
        "content": "<p>( I wonder if a const generic parameter would work... )</p>",
        "id": 271051697,
        "sender_full_name": "Jubilee",
        "timestamp": 1644272567
    },
    {
        "content": "<p>maybe, i was thinking we'd just provide byte/element/full-simd-type aligns and call it a day...<code>ptr::write[_unaligned]</code> seems to get away with something similar</p>",
        "id": 271051980,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1644272689
    },
    {
        "content": "<p>I was wondering the same, though I think there are only two possible values we would ever want...</p>",
        "id": 271051990,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1644272694
    },
    {
        "content": "<p>Yeah, I was thinking that it'd be a param with a default.</p>",
        "id": 271052053,
        "sender_full_name": "Jubilee",
        "timestamp": 1644272724
    },
    {
        "content": "<p>if that's even possible.</p>",
        "id": 271052066,
        "sender_full_name": "Jubilee",
        "timestamp": 1644272731
    },
    {
        "content": "<p>we'd specifically want element align as an option, cuz risc-v/SimpleV/maybe-SVE all like that better than full-simd-align</p>",
        "id": 271052181,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1644272766
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/Masked.20loads.20and.20stores/near/271052066\">said</a>:</p>\n<blockquote>\n<p>if that's even possible.</p>\n</blockquote>\n<p>No defaults on generic functions, right now.</p>",
        "id": 271052262,
        "sender_full_name": "scottmcm",
        "timestamp": 1644272801
    },
    {
        "content": "<p>Aw okay.</p>",
        "id": 271052276,
        "sender_full_name": "Jubilee",
        "timestamp": 1644272810
    },
    {
        "content": "<p>And on other architectures it generally hardly makes a difference, and it's way easier to program against</p>",
        "id": 271052303,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1644272829
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"229517\">Jacob Lifshay</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/Masked.20loads.20and.20stores/near/271052181\">said</a>:</p>\n<blockquote>\n<p>we'd specifically want element align as an option, cuz risc-v/SimpleV/maybe-SVE all like that better than full-simd-align</p>\n</blockquote>\n<p>Yeah, my thought is that element alignment would be the default.</p>",
        "id": 271052330,
        "sender_full_name": "Jubilee",
        "timestamp": 1644272839
    },
    {
        "content": "<p>Note that LLVM is actually pretty good at flowing alignment.  If you do a <code>ptr::read_unaligned</code> from something that came from a reference, my recollection is that it'll actually use a higher one.</p>",
        "id": 271052371,
        "sender_full_name": "scottmcm",
        "timestamp": 1644272859
    },
    {
        "content": "<p>Ah nice.</p>",
        "id": 271052534,
        "sender_full_name": "Jubilee",
        "timestamp": 1644272920
    },
    {
        "content": "<p>( I actually suspect that using read with full alignment is better for AVX512 specifically. )</p>",
        "id": 271052697,
        "sender_full_name": "Jubilee",
        "timestamp": 1644273000
    },
    {
        "content": "<p>because you avoid the cache tearing penalty... &lt;_&lt;</p>",
        "id": 271052762,
        "sender_full_name": "Jubilee",
        "timestamp": 1644273011
    },
    {
        "content": "<p>\"if your vector happens to be the size of one entire cache line, try to read it aligned.\"</p>",
        "id": 271052877,
        "sender_full_name": "Jubilee",
        "timestamp": 1644273072
    },
    {
        "content": "<p>usually x86 does a dynamic address alignment check, so you only pay the penalty if it's unaligned at runtime, rather than paying the penalty if you use the unaligned instruction</p>",
        "id": 271052960,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1644273109
    },
    {
        "content": "<p>yeah.</p>",
        "id": 271053035,
        "sender_full_name": "Jubilee",
        "timestamp": 1644273127
    },
    {
        "content": "<p>tho i could be wrong for avx512</p>",
        "id": 271053050,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1644273135
    },
    {
        "content": "<p>I believe you are completely correct. The cache tearing penalty is just another penalty.</p>",
        "id": 271053347,
        "sender_full_name": "Jubilee",
        "timestamp": 1644273276
    },
    {
        "content": "<p>I think the element-aligned things might be handled sufficiently well with just <code>from_array</code>.</p>",
        "id": 271053440,
        "sender_full_name": "scottmcm",
        "timestamp": 1644273328
    },
    {
        "content": "<p>Since you can always get a <code>*const [f32; 4]</code> and read that, for example.</p>",
        "id": 271053476,
        "sender_full_name": "scottmcm",
        "timestamp": 1644273350
    },
    {
        "content": "<p>(And if you have slices it's even easier, since <code>as_chunks</code> will give you <code>&amp;[f32; 4]</code>s and such.)</p>",
        "id": 271053557,
        "sender_full_name": "scottmcm",
        "timestamp": 1644273381
    },
    {
        "content": "<p>i don't think <code>from_array</code> does what we want here, we want llvm to use <code>llvm.masked.load.*</code></p>",
        "id": 271053785,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1644273497
    },
    {
        "content": "<p>or maybe i misunderstood what you meant</p>",
        "id": 271053872,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1644273560
    },
    {
        "content": "<p>Oh, my mistake -- I forgot to check the topic.</p>",
        "id": 271053879,
        "sender_full_name": "scottmcm",
        "timestamp": 1644273564
    },
    {
        "content": "<p>I was briefly considering saying we could make the Rust-side intrinsic straight-up accept arrays but then I remembered that we can just expose an API that casts arrays to vectors so... lol?</p>",
        "id": 272186522,
        "sender_full_name": "Jubilee",
        "timestamp": 1645049578
    },
    {
        "content": "<p>vectors may have more strict alignment, so masked load/store to <code>&amp;mut [T; N]</code> would still be useful</p>",
        "id": 272187165,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1645049765
    },
    {
        "content": "<p>Oh I mean as the input to store or the output of load.</p>",
        "id": 272187356,
        "sender_full_name": "Jubilee",
        "timestamp": 1645049892
    },
    {
        "content": "<p>ah, yeah that should totally just be a vector</p>",
        "id": 272187393,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1645049926
    },
    {
        "content": "<p>though we will probably want a <code>Simd::&lt;MaybeUninit&lt;T&gt;, N&gt;::masked_store(self, dest: *mut [MaybeUninit&lt;T&gt;; N], mask: Mask&lt;i32, N&gt;)</code> for the extra flexibility</p>",
        "id": 272188073,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1645050336
    }
]