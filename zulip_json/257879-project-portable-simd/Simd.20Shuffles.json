[
    {
        "content": "<p>I can't believe this monstrosity compiles.<br>\n<a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=b1bbc71a0c61234d977475dfa88de73d\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=b1bbc71a0c61234d977475dfa88de73d</a></p>",
        "id": 224978828,
        "sender_full_name": "Jubilee",
        "timestamp": 1612334013
    },
    {
        "content": "<p><span aria-label=\"grimacing\" class=\"emoji emoji-1f62c\" role=\"img\" title=\"grimacing\">:grimacing:</span></p>",
        "id": 224978896,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612334088
    },
    {
        "content": "<p>...anyways... I have been poking at SIMD shuffles all night. Const generics aren't entirely there yet for a \"straight\" <code>pub const fn shuffle&lt;const M: usize, const Idx: [usize; M]&gt;(self, other: Self) -&gt; Self&lt;M&gt;</code> signature yet, I think.</p>",
        "id": 224978986,
        "sender_full_name": "Jubilee",
        "timestamp": 1612334179
    },
    {
        "content": "<p>this is because</p>\n<div class=\"codehilite\"><pre><span></span><code>error[E0770]: the type of const parameters must not depend on other generic parameters\n  --&gt; crates/core_simd/src/macros.rs:84:69\n   |\n84 |             pub const fn shuffle&lt;const M: usize, const Idx: [usize; M]&gt;(self, other: Self) -&gt; Self {\n   |                                                                     ^ the type must not depend on the parameter `M`\n</code></pre></div>",
        "id": 224979036,
        "sender_full_name": "Jubilee",
        "timestamp": 1612334269
    },
    {
        "content": "<p>What about if we took an entirely different approach</p>",
        "id": 224979114,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612334342
    },
    {
        "content": "<p>What if we exposed a ShuffleIndex trait that's implemented for all arrays of usize</p>",
        "id": 224979143,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612334380
    },
    {
        "content": "<p>I have been thinking about that!</p>",
        "id": 224979206,
        "sender_full_name": "Jubilee",
        "timestamp": 1612334410
    },
    {
        "content": "<p>Oh nice</p>",
        "id": 224979211,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612334417
    },
    {
        "content": "<p>I know traits aren't supported in const fn yet either, but there may be an unstable feature for it</p>",
        "id": 224979224,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612334439
    },
    {
        "content": "<p>Actually you may still end up with the same error. I think the const parameter would still end up depending on another generic parameter</p>",
        "id": 224979396,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612334639
    },
    {
        "content": "<p>Is there a reason for the shuffle index length to be different than the size of the vector?</p>",
        "id": 224979589,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612334813
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">error</span><span class=\"p\">[</span><span class=\"n\">E0770</span><span class=\"p\">]</span>: <span class=\"nc\">the</span><span class=\"w\"> </span><span class=\"k\">type</span> <span class=\"nc\">of</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">parameters</span><span class=\"w\"> </span><span class=\"n\">must</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">depend</span><span class=\"w\"> </span><span class=\"n\">on</span><span class=\"w\"> </span><span class=\"n\">other</span><span class=\"w\"> </span><span class=\"n\">generic</span><span class=\"w\"> </span><span class=\"n\">parameters</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"o\">-</span>-&gt; <span class=\"nc\">crates</span><span class=\"o\">/</span><span class=\"n\">core_simd</span><span class=\"o\">/</span><span class=\"n\">src</span><span class=\"o\">/</span><span class=\"n\">macros</span><span class=\"p\">.</span><span class=\"n\">rs</span>:<span class=\"mi\">85</span>:<span class=\"mi\">45</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"o\">|</span><span class=\"w\"></span>\n<span class=\"mi\">85</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\">             </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">shuffle</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">I</span>: <span class=\"p\">[</span><span class=\"kt\">usize</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">LANES</span><span class=\"p\">]</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">other</span>: <span class=\"nc\">Self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"o\">|</span><span class=\"w\">                                             </span><span class=\"o\">^^^^^</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"k\">type</span> <span class=\"nc\">must</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">depend</span><span class=\"w\"> </span><span class=\"n\">on</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">parameter</span><span class=\"w\"> </span><span class=\"err\">`</span><span class=\"n\">LANES</span><span class=\"err\">`</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Are you trying to squirm out that way? :^)<br>\nI already checked, that gate is sealed shut.</p>",
        "id": 224980516,
        "sender_full_name": "Jubilee",
        "timestamp": 1612335679
    },
    {
        "content": "<p>Yeah I guess that's still a generic parameter</p>",
        "id": 224980576,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612335727
    },
    {
        "content": "<p>Worst case we can still go the const argument route <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span>‍♂️</p>",
        "id": 224980693,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612335844
    },
    {
        "content": "<p>What happens if you add an associated constant equal to the number of lanes? And use that</p>",
        "id": 224980803,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612335981
    },
    {
        "content": "<p>realistically, the bigger issue is that the intrinsics in Rust are <code>simd_shuffle{N}</code> where N is a number that is actually part of the function name. :D</p>",
        "id": 224983030,
        "sender_full_name": "Jubilee",
        "timestamp": 1612338226
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">            </span><span class=\"sd\">/// const fn shuffle</span>\n<span class=\"w\">            </span><span class=\"cp\">#[inline]</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">shuffle2</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">W</span>: <span class=\"kt\">u32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">X</span>: <span class=\"kt\">u32</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">other</span>: <span class=\"nc\">Self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"cp\">$name</span><span class=\"o\">&lt;</span><span class=\"mi\">2</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">crate</span>::<span class=\"n\">intrinsics</span>::<span class=\"n\">simd_shuffle2</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">other</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">W</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"p\">])</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">            </span><span class=\"sd\">/// const fn shuffle</span>\n<span class=\"w\">            </span><span class=\"cp\">#[inline]</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">shuffle4</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">W</span>: <span class=\"kt\">u32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">X</span>: <span class=\"kt\">u32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">Y</span>: <span class=\"kt\">u32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">Z</span>: <span class=\"kt\">u32</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">other</span>: <span class=\"nc\">Self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"cp\">$name</span><span class=\"o\">&lt;</span><span class=\"mi\">4</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">crate</span>::<span class=\"n\">intrinsics</span>::<span class=\"n\">simd_shuffle4</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">other</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">W</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"p\">])</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>so like, this works ofc</p>",
        "id": 224983631,
        "sender_full_name": "Jubilee",
        "timestamp": 1612338799
    },
    {
        "content": "<p>..wow I may have found something hilarious.</p>",
        "id": 224984763,
        "sender_full_name": "Jubilee",
        "timestamp": 1612339734
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">error</span><span class=\"p\">[</span><span class=\"n\">E0747</span><span class=\"p\">]</span>: <span class=\"nc\">type</span><span class=\"w\"> </span><span class=\"n\">provided</span><span class=\"w\"> </span><span class=\"n\">when</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">constant</span><span class=\"w\"> </span><span class=\"n\">was</span><span class=\"w\"> </span><span class=\"n\">expected</span><span class=\"w\"></span>\n<span class=\"w\"> </span><span class=\"o\">-</span>-&gt; <span class=\"nc\">crates</span><span class=\"o\">/</span><span class=\"n\">core_simd</span><span class=\"o\">/</span><span class=\"n\">tests</span><span class=\"o\">/</span><span class=\"n\">permute</span><span class=\"p\">.</span><span class=\"n\">rs</span>:<span class=\"mi\">9</span>:<span class=\"mi\">26</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"o\">|</span><span class=\"w\"></span>\n<span class=\"mi\">9</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\">     </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">shuffle2</span>::<span class=\"o\">&lt;</span><span class=\"p\">[</span><span class=\"kt\">u32</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">]</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"o\">|</span><span class=\"w\">                          </span><span class=\"o\">^^^^^^^^</span><span class=\"w\"></span>\n\n<span class=\"n\">error</span>: <span class=\"nc\">aborting</span><span class=\"w\"> </span><span class=\"n\">due</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">previous</span><span class=\"w\"> </span><span class=\"n\">error</span><span class=\"w\"></span>\n\n<span class=\"n\">For</span><span class=\"w\"> </span><span class=\"n\">more</span><span class=\"w\"> </span><span class=\"n\">information</span><span class=\"w\"> </span><span class=\"n\">about</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"n\">error</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kr\">try</span><span class=\"w\"> </span><span class=\"err\">`</span><span class=\"n\">rustc</span><span class=\"w\"> </span><span class=\"o\">--</span><span class=\"n\">explain</span><span class=\"w\"> </span><span class=\"n\">E0747</span><span class=\"err\">`</span><span class=\"p\">.</span><span class=\"w\"></span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">error</span>: <span class=\"nc\">unmatched</span><span class=\"w\"> </span><span class=\"n\">angle</span><span class=\"w\"> </span><span class=\"n\">bracket</span><span class=\"w\"></span>\n<span class=\"w\"> </span><span class=\"o\">-</span>-&gt; <span class=\"nc\">crates</span><span class=\"o\">/</span><span class=\"n\">core_simd</span><span class=\"o\">/</span><span class=\"n\">tests</span><span class=\"o\">/</span><span class=\"n\">permute</span><span class=\"p\">.</span><span class=\"n\">rs</span>:<span class=\"mi\">9</span>:<span class=\"mi\">25</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"o\">|</span><span class=\"w\"></span>\n<span class=\"mi\">9</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\">     </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">shuffle2</span>::<span class=\"o\">&lt;</span><span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">]</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"o\">|</span><span class=\"w\">                         </span><span class=\"o\">^</span><span class=\"w\"> </span><span class=\"n\">help</span>: <span class=\"nc\">remove</span><span class=\"w\"> </span><span class=\"n\">extra</span><span class=\"w\"> </span><span class=\"n\">angle</span><span class=\"w\"> </span><span class=\"n\">bracket</span><span class=\"w\"></span>\n\n<span class=\"n\">error</span>: <span class=\"nc\">expected</span><span class=\"w\"> </span><span class=\"k\">type</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">found</span><span class=\"w\"> </span><span class=\"err\">`</span><span class=\"mi\">3</span><span class=\"err\">`</span><span class=\"w\"></span>\n<span class=\"w\"> </span><span class=\"o\">-</span>-&gt; <span class=\"nc\">crates</span><span class=\"o\">/</span><span class=\"n\">core_simd</span><span class=\"o\">/</span><span class=\"n\">tests</span><span class=\"o\">/</span><span class=\"n\">permute</span><span class=\"p\">.</span><span class=\"n\">rs</span>:<span class=\"mi\">9</span>:<span class=\"mi\">27</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"o\">|</span><span class=\"w\"></span>\n<span class=\"mi\">9</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\">     </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">shuffle2</span>::<span class=\"o\">&lt;</span><span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">]</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"o\">|</span><span class=\"w\">                           </span><span class=\"o\">^</span><span class=\"w\"> </span><span class=\"n\">expected</span><span class=\"w\"> </span><span class=\"k\">type</span>\n\n<span class=\"nc\">error</span>: <span class=\"nc\">aborting</span><span class=\"w\"> </span><span class=\"n\">due</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"n\">previous</span><span class=\"w\"> </span><span class=\"n\">errors</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Is this as busted as I think it is? <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 224984986,
        "sender_full_name": "Jubilee",
        "timestamp": 1612339926
    },
    {
        "content": "<p>Filed this I guess. rustc go home, you're drunk. <a href=\"https://github.com/rust-lang/rust/issues/81698\">https://github.com/rust-lang/rust/issues/81698</a></p>",
        "id": 224986555,
        "sender_full_name": "Jubilee",
        "timestamp": 1612341231
    },
    {
        "content": "<p>And I have mulled it over from a few directions but afaict the problem with using [array].shuffle(v1, v2) -&gt; v3 is that [array] is not guaranteed to be statically known.</p>",
        "id": 224988576,
        "sender_full_name": "Jubilee",
        "timestamp": 1612342651
    },
    {
        "content": "<p>We could always change/improve the intrinsic to not require a number in the name</p>",
        "id": 225034226,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612367364
    },
    {
        "content": "<p>we still have to guarantee it type checks tho'.</p>",
        "id": 225035803,
        "sender_full_name": "Jubilee",
        "timestamp": 1612367927
    },
    {
        "content": "<p>Agreed. Still thinking about that one</p>",
        "id": 225035888,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612367956
    },
    {
        "content": "<p>strictly speaking, all the information is there and can \"obviously\" be applied to generate the correct inputs and outputs, so I'm not too worried.</p>",
        "id": 225036031,
        "sender_full_name": "Jubilee",
        "timestamp": 1612368002
    },
    {
        "content": "<p>since what we know is going to be the case is that we have a statically-known array as an input and that the array length will be the length of the output.</p>",
        "id": 225036554,
        "sender_full_name": "Jubilee",
        "timestamp": 1612368157
    },
    {
        "content": "<p>...macro expansion, maybe?</p>",
        "id": 225123400,
        "sender_full_name": "Jubilee",
        "timestamp": 1612419868
    },
    {
        "content": "<p>nope! I'm not good enough yet at least.</p>",
        "id": 225124278,
        "sender_full_name": "Jubilee",
        "timestamp": 1612420842
    },
    {
        "content": "<p>OK, this is what I was able to pull together for an API for SIMD shuffles with the compiler intrinsics and const generics as they currently stand. It is neither pretty nor great, and also suffers from the 64-lane limitation (highly relative \"suffers\" since that covers most silicon in existence, but servers with SVE are shipping <strong>this</strong> year).<br>\n<a href=\"https://github.com/rust-lang/stdsimd/commit/3e88fb339891d868ce8e12675b87195b4855382a\">https://github.com/rust-lang/stdsimd/commit/3e88fb339891d868ce8e12675b87195b4855382a</a></p>",
        "id": 225126509,
        "sender_full_name": "Jubilee",
        "timestamp": 1612423397
    },
    {
        "content": "<p>Hmm. So my only thought, does it even make sense to simultaneously shuffle and shrink vectors?</p>",
        "id": 225127990,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612424722
    },
    {
        "content": "<p>Ive definitely never done that before. I think on x86 that's probably a bad thing to do</p>",
        "id": 225128100,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612424856
    },
    {
        "content": "<p>NEON's tbl and tbx instructions can compose a new vector from <strong>four</strong> different vectors.<br>\nand in general, the way the intrinsic is set up, T and U are separately defined.</p>",
        "id": 225128426,
        "sender_full_name": "Jubilee",
        "timestamp": 1612425190
    },
    {
        "content": "<p>and I couldn't really find a way to smoothly get shuffle working in a \"lane dependent\" way. I guess I could impl shuffle as shuffle2 for SimdType&lt;2&gt;, is that what you're thinking of?</p>",
        "id": 225128521,
        "sender_full_name": "Jubilee",
        "timestamp": 1612425258
    },
    {
        "content": "<p>Sorry, what I mean is does it make sense to take a 32 lane vector and make a 4 lane vector from it, etc</p>",
        "id": 225128529,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612425265
    },
    {
        "content": "<p>Yeah that's what I meant</p>",
        "id": 225128537,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612425276
    },
    {
        "content": "<p>hmm.</p>",
        "id": 225128542,
        "sender_full_name": "Jubilee",
        "timestamp": 1612425285
    },
    {
        "content": "<p>I suppose it may be useful somewhere to someone, especially if you're using vectors much larger than your native vector length</p>",
        "id": 225128593,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612425358
    },
    {
        "content": "<p>yeah, that's probably the best way to go about this if we're stuck writing out a bunch of implementations anyways. <span aria-label=\"weary\" class=\"emoji emoji-1f629\" role=\"img\" title=\"weary\">:weary:</span></p>",
        "id": 225128631,
        "sender_full_name": "Jubilee",
        "timestamp": 1612425364
    },
    {
        "content": "<p>But it's not really typical I think</p>",
        "id": 225128636,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612425367
    },
    {
        "content": "<p>Lol</p>",
        "id": 225128640,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612425376
    },
    {
        "content": "<p>I agree it's not very typical so I'm not opposed to unifying T and U, at least, for now.</p>",
        "id": 225128664,
        "sender_full_name": "Jubilee",
        "timestamp": 1612425406
    },
    {
        "content": "<p>at the end of the day I expect the major types that see the most use are going to be like<br>\n{f, i, u}32x4 and u8x16</p>",
        "id": 225128953,
        "sender_full_name": "Jubilee",
        "timestamp": 1612425634
    },
    {
        "content": "<p>agreed</p>",
        "id": 225128986,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612425668
    },
    {
        "content": "<p>I push for flexibility mostly because, that said, I still don't know exactly what people are going to do, so I eagerly await the horrors that will be inflicted on this language, such as, say, seeing someone run the Rust compiler on a GPU or something. :P</p>\n<p>after all, they can run Crysis <a href=\"https://www.tomshardware.com/news/gamer-installs-crysis-3-on-geforce-rtx-3090s-vram-and-it-runs\">https://www.tomshardware.com/news/gamer-installs-crysis-3-on-geforce-rtx-3090s-vram-and-it-runs</a></p>",
        "id": 225129338,
        "sender_full_name": "Jubilee",
        "timestamp": 1612425965
    },
    {
        "content": "<p>anyways, will sleep on it~ and hopefully review PRs between tomorrow~Sunday</p>",
        "id": 225129797,
        "sender_full_name": "Jubilee",
        "timestamp": 1612426403
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/Simd.20Shuffles/near/225128529\">said</a>:</p>\n<blockquote>\n<p>Sorry, what I mean is does it make sense to take a 32 lane vector and make a 4 lane vector from it, etc</p>\n</blockquote>\n<p>That happens all the time in GPU shaders, even to the point that glsl has special syntax support for it: <code>v.xzw</code> means take lane 0, 2, and 3 and make a 3 lane vector. you can use any combination of x, y, z, and w. there are also aliases for rgba and for texture coordinates.</p>\n<p>Also, shrinking shuffles are used in divide/conquer simd reduction algorithms.</p>",
        "id": 225131893,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1612428046
    },
    {
        "content": "<p>hmm.</p>",
        "id": 225162641,
        "sender_full_name": "Jubilee",
        "timestamp": 1612447362
    },
    {
        "content": "<p>Is there a single architecture other than a GPU that supports shrinking shuffles though?</p>",
        "id": 225172345,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612451648
    },
    {
        "content": "<p>My concern is if this is truly a portable operation</p>",
        "id": 225172399,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612451672
    },
    {
        "content": "<p>how _does_ <code>shufflevector</code> get lowered from LLVM IR?</p>",
        "id": 225186260,
        "sender_full_name": "Jubilee",
        "timestamp": 1612456809
    },
    {
        "content": "<p>I believe there is a special LLVM function for building shuffles (there isn't a particular representation in IR)</p>",
        "id": 225186997,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612457068
    },
    {
        "content": "<p>Oh nevermind, I was wrong</p>",
        "id": 225187090,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612457107
    },
    {
        "content": "<p>There is just an LLVM instruction</p>",
        "id": 225187123,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612457119
    },
    {
        "content": "<p>Do you mean lowered from IR to asm?</p>",
        "id": 225187186,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612457147
    },
    {
        "content": "<p>yes.</p>",
        "id": 225187391,
        "sender_full_name": "Jubilee",
        "timestamp": 1612457225
    },
    {
        "content": "<p><a href=\"https://github.com/WebAssembly/simd/issues/8\">https://github.com/WebAssembly/simd/issues/8</a> hm.</p>",
        "id": 225187441,
        "sender_full_name": "Jubilee",
        "timestamp": 1612457254
    },
    {
        "content": "<p>Hm. I definitely agree with the conclusions that \"general shuffles\" are usually possible, though not always super efficient</p>",
        "id": 225188005,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612457503
    },
    {
        "content": "<p>So wasm only has one vector length, so it doesn't provide shuffles that resize the vector</p>",
        "id": 225188512,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612457688
    },
    {
        "content": "<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0214r0.pdf\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0214r0.pdf</a> <span aria-label=\"pirate\" class=\"emoji emoji-2620\" role=\"img\" title=\"pirate\">:pirate:</span> <span aria-label=\"black flag\" class=\"emoji emoji-1f3f4\" role=\"img\" title=\"black flag\">:black_flag:</span> activating.</p>",
        "id": 225189177,
        "sender_full_name": "Jubilee",
        "timestamp": 1612457975
    },
    {
        "content": "<p>Also, figure it's worth pointing out, if we went the constant argument route (like stdarch) rather than full const generics the API could both be stabilized sooner and wouldn't have the 64 lane limitation</p>",
        "id": 225189262,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612458003
    },
    {
        "content": "<p>Using a const generic parameter is definitely more satisfying but there is precedent for doing it that way</p>",
        "id": 225189349,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612458038
    },
    {
        "content": "<p>Hmm, that doc only refers to permutations and blends</p>",
        "id": 225189616,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612458143
    },
    {
        "content": "<p>so<br>\nthe const argument thing? that was actually NEVER EVER meant to be exposed</p>",
        "id": 225189646,
        "sender_full_name": "Jubilee",
        "timestamp": 1612458155
    },
    {
        "content": "<p>Lol</p>",
        "id": 225189705,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612458177
    },
    {
        "content": "<p>That's reasonable</p>",
        "id": 225189769,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612458199
    },
    {
        "content": "<p>I am stiffly against using that again to perpetuate that original mistake because it was a mistake, those exposed intrinsics should die in a fire, and there is a palpable argument they should have never ever been stabilized.</p>",
        "id": 225189844,
        "sender_full_name": "Jubilee",
        "timestamp": 1612458230
    },
    {
        "content": "<p>and I should note that \"oh, we did something that genuinely should never have been stabilized\" is one of the few cases where the Rust teams are allowed to reconsider and back out, if it is demonstrated to be sufficiently unsound.</p>",
        "id": 225189997,
        "sender_full_name": "Jubilee",
        "timestamp": 1612458286
    },
    {
        "content": "<p>That's fair, so we stick to const generics</p>",
        "id": 225190028,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612458300
    },
    {
        "content": "<p>basically rustc_const_args was supposed to be for compiler-internal usage only, because... well, precisely because it doesn't have the same kind of rigorous const-qualification work behind it.</p>",
        "id": 225191315,
        "sender_full_name": "Jubilee",
        "timestamp": 1612458853
    },
    {
        "content": "<p>That makes sense</p>",
        "id": 225191601,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612458963
    },
    {
        "content": "<p>So my concern is that generics explicitly can't depend on other generics</p>",
        "id": 225191656,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612458983
    },
    {
        "content": "<p>So we'd be limited to non-generic shuffles</p>",
        "id": 225191732,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612459026
    },
    {
        "content": "<p>(generic size, I mean)</p>",
        "id": 225191759,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612459037
    },
    {
        "content": "<p>It won't be possible to make a function \"shuffle this vector into another vector of the same size\" which is also the most common type of shuffle</p>",
        "id": 225191830,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612459075
    },
    {
        "content": "<p>I think since actually we only need to depend on \"one\" thing, which is the input array, it's actually possible.</p>",
        "id": 225192153,
        "sender_full_name": "Jubilee",
        "timestamp": 1612459204
    },
    {
        "content": "<p>though I suppose I should actually ask.</p>",
        "id": 225192202,
        "sender_full_name": "Jubilee",
        "timestamp": 1612459238
    },
    {
        "content": "<p>Hmm</p>",
        "id": 225192267,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612459277
    },
    {
        "content": "<p>lcnr <a href=\"#narrow/stream/260443-project-const-generics/topic/generic.20data.20dependency.20vs.2E.20arrays/near/225192727\">said</a>:</p>\n<blockquote>\n<p>yeah, we're working on this under the <code>const_evaluatable_checked</code> feature gate</p>\n</blockquote>\n<p>so yes.</p>",
        "id": 225192846,
        "sender_full_name": "Jubilee",
        "timestamp": 1612459555
    },
    {
        "content": "<p>...implementing shuffles as having the same array length right now and loosening it up later seems p. doable actually yeah.</p>",
        "id": 225193083,
        "sender_full_name": "Jubilee",
        "timestamp": 1612459670
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/Simd.20Shuffles/near/225172345\">said</a>:</p>\n<blockquote>\n<p>Is there a single architecture other than a GPU that supports shrinking shuffles though?</p>\n</blockquote>\n<p>yes, x86 supports getting 64/128/256-bit vectors from 128/256/512-bit vectors</p>",
        "id": 225202044,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1612463498
    },
    {
        "content": "<p>also, SimpleV supports a very general shuffle instruction</p>",
        "id": 225202175,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1612463542
    },
    {
        "content": "<p>see <a href=\"https://gcc.godbolt.org/z/nn51x3\">https://gcc.godbolt.org/z/nn51x3</a></p>",
        "id": 225203356,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1612464057
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"229517\">@Jacob Lifshay</span> on x86 isn't that unrelated to shuffling though?</p>",
        "id": 225203824,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612464301
    },
    {
        "content": "<p>Is there any instruction set that says ok take these 4 random elements of an 8 lane vector and produce a 4 lane vector</p>",
        "id": 225204047,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612464421
    },
    {
        "content": "<p>Not to say we can't/shouldn't support that, but I do want to make sure that permuting a vector is ergonomic</p>",
        "id": 225204131,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612464460
    },
    {
        "content": "<p>And should probably prioritize that, I think</p>",
        "id": 225204154,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612464475
    },
    {
        "content": "<p>x86 has a pile of instructions for specific shuffles and a general instruction for 128-bit shuffles, but no general wider shuffle</p>",
        "id": 225204321,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1612464555
    },
    {
        "content": "<p>vextractf128 <em>is</em> a shuffle -- a specific one that picks either the low 128 bits or the high 128 bits for 256-bit vectors</p>",
        "id": 225204558,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1612464651
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"312331\">@Caleb Zulawski</span> from an abstract consideration, \"take 4 vectors of 128 bits with, say, f32x4s in them, and then construct an f32x4 from them\" is in fact equivalent, and that's the NEON tbl instruction.</p>",
        "id": 225204591,
        "sender_full_name": "Jubilee",
        "timestamp": 1612464668
    },
    {
        "content": "<p>because as opposed to taking f32x4 and f32x4 and extracting an f32x4 from between their elements, you're taking an \"f32x8\" and \"f32x8\" (REALLY you're taking an f32x4 and f32x4 and f32x4 and f32x4, but there's no <em>discernible difference</em>) and extracting an f32x4.</p>",
        "id": 225204777,
        "sender_full_name": "Jubilee",
        "timestamp": 1612464759
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"229517\">@Jacob Lifshay</span> fair, I suppose it's a very specific shuffle</p>",
        "id": 225205568,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612465118
    },
    {
        "content": "<p>And can be combined with other shuffles and blends</p>",
        "id": 225205644,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612465153
    },
    {
        "content": "<p>ok, after looking, x86 does have a fully generic shuffle, it was added in avx512</p>",
        "id": 225205834,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1612465224
    },
    {
        "content": "<p>Interesting. That's useful. AVX shuffles were always frustrating</p>",
        "id": 225206126,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612465345
    },
    {
        "content": "<p>lol AVX512 tho'</p>",
        "id": 225208636,
        "sender_full_name": "Jubilee",
        "timestamp": 1612466462
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span> shall I suggest maybe the initial set of shuffles should be the type that aren't parameterized? Like interleaving, reversing, etc</p>",
        "id": 225208916,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612466585
    },
    {
        "content": "<p>hm.</p>",
        "id": 225208953,
        "sender_full_name": "Jubilee",
        "timestamp": 1612466603
    },
    {
        "content": "<p>And once supported by the compiler we move on to generic shuffles?</p>",
        "id": 225208989,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612466621
    },
    {
        "content": "<p>so, after your idea of implementation based on size, I actually think we can have <code>v1.shuffle&lt;[w, x, y, z]&gt;(v2)</code> from day one and say that the semantics of <code>shuffle</code> are in fact \"take two, make one of similar size\", with later extension to indefinite length once const generics supports it.</p>",
        "id": 225209299,
        "sender_full_name": "Jubilee",
        "timestamp": 1612466757
    },
    {
        "content": "<p>and also look at more-specific versions where it makes sense in our API overall?</p>",
        "id": 225209411,
        "sender_full_name": "Jubilee",
        "timestamp": 1612466791
    },
    {
        "content": "<p>You think you can do that with the current state of const generics?</p>",
        "id": 225209466,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612466814
    },
    {
        "content": "<p>I would like to try, at least.</p>",
        "id": 225209521,
        "sender_full_name": "Jubilee",
        "timestamp": 1612466837
    },
    {
        "content": "<p>That API is definitely desirable I think</p>",
        "id": 225209533,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612466840
    },
    {
        "content": "<p>I will be accepting similar limitations as our current version mind.</p>",
        "id": 225209578,
        "sender_full_name": "Jubilee",
        "timestamp": 1612466862
    },
    {
        "content": "<p>Right, only implementing for specific sizes</p>",
        "id": 225209675,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612466886
    },
    {
        "content": "<p>I assume you mean with <code>impl SimdU8&lt;16&gt;</code> etc?</p>",
        "id": 225209758,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612466921
    },
    {
        "content": "<p>Rather than generic sizes</p>",
        "id": 225209832,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612466952
    },
    {
        "content": "<p>yeah.</p>",
        "id": 225209928,
        "sender_full_name": "Jubilee",
        "timestamp": 1612466995
    },
    {
        "content": "<p>I'm not 100% sure thats API compatible with the generic version but it seems to be</p>",
        "id": 225210079,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612467035
    },
    {
        "content": "<p>The only reason it might not be is if we want to support resizing shuffles, the function is generic on array size too</p>",
        "id": 225210261,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612467104
    },
    {
        "content": "<p>Otherwise sounds good though</p>",
        "id": 225210284,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612467114
    },
    {
        "content": "<p>Right, I think we can add the const generic array parameter for array size later. This maaay preclude stabilization until we are sure this won't affect forward compat.</p>",
        "id": 225211163,
        "sender_full_name": "Jubilee",
        "timestamp": 1612467483
    },
    {
        "content": "<p>but that's part of why I figured this would be a separately feature flagged API</p>",
        "id": 225211222,
        "sender_full_name": "Jubilee",
        "timestamp": 1612467513
    },
    {
        "content": "<p>Works for me</p>",
        "id": 225211356,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612467582
    },
    {
        "content": "<p>Something I'm also curious about is if dynamic shuffles const-propagate and produce static shuffles when possible</p>",
        "id": 225211712,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612467747
    },
    {
        "content": "<p>Since that API is much simpler, I think</p>",
        "id": 225211739,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612467758
    },
    {
        "content": "<p>May be possible to stabilize that first</p>",
        "id": 225211755,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612467771
    },
    {
        "content": "<p>the answer is... maybe. And that's kind of why I am increasingly interested in just generating some forward motion, because compilation properties are something we'll mostly see after actual usage.</p>",
        "id": 225212080,
        "sender_full_name": "Jubilee",
        "timestamp": 1612467920
    },
    {
        "content": "<p>Maybe a silly question, do the static and dynamic shuffles both just lower to <code>shufflevector</code>?</p>",
        "id": 225212453,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612468088
    },
    {
        "content": "<p>I am... not sure! :D</p>",
        "id": 225212732,
        "sender_full_name": "Jubilee",
        "timestamp": 1612468207
    },
    {
        "content": "<p>... if they do, perhaps we don't even <em>need</em> explicitly const shuffles?</p>",
        "id": 225212865,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612468272
    },
    {
        "content": "<p>shufflevector specifies \"shuffle mask vector constant, whose values are const integers or undef\"</p>",
        "id": 225212889,
        "sender_full_name": "Jubilee",
        "timestamp": 1612468286
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/Simd.20Shuffles/near/225211739\">said</a>:</p>\n<blockquote>\n<p>Since that API is much simpler, I think</p>\n</blockquote>\n<p>Strong, strong <span aria-label=\"thumbs down\" class=\"emoji emoji-1f44e\" role=\"img\" title=\"thumbs down\">:thumbs_down:</span> as a user here. The API for constant shuffles guaranteeing that they are constant is a feature worth keeping.</p>",
        "id": 225212890,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1612468287
    },
    {
        "content": "<p>Sorry, when I said simpler I meant in terms of const generics</p>",
        "id": 225213015,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612468337
    },
    {
        "content": "<p>As in, can be written with rustc today</p>",
        "id": 225213036,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612468347
    },
    {
        "content": "<p>also cranelift can wind up having different lowering. <del>supposedly some people are already using cranelift for narrow compilation cases because it's better in terms of loop optimization?</del> no I just misunderstood something, lol.</p>",
        "id": 225213120,
        "sender_full_name": "Jubilee",
        "timestamp": 1612468391
    },
    {
        "content": "<p>Yeah, I just mean that having a single api for dynamic shuffles that only generates constant shuffles if const prop to kicks in is bad. Even if it is very reliable, this would be unfortunate and will almost certainly bite people who will be surprised that e.g. rustc didn't const eval shuffle returned <code>const fn</code> argument</p>",
        "id": 225213866,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1612468697
    },
    {
        "content": "<p>yeah, people already misunderstand that const fn is not actually itself sufficient to create a const context a LOT</p>",
        "id": 225213993,
        "sender_full_name": "Jubilee",
        "timestamp": 1612468749
    },
    {
        "content": "<p>yeah. even if somehow this function had some hint that \"really try to const eval the argument\"... in the <em>best</em> case it would people would need to  periodically verify assembly... also concerns like bounds checking and stuff could crop up.</p>\n<p>i honestly would wonder if the dynamic shuffle and more general permutation stuff belong together more than const/dynamic shuffle, if we're talkign about api structure... not certain about that ofc</p>",
        "id": 225214533,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1612468961
    },
    {
        "content": "<p>i think encoding stuff often uses dynamic shuffles (and more powerful permutations as well), so perhaps <span class=\"user-mention\" data-user-id=\"314350\">@Henri Sivonen</span> has some insight there.</p>",
        "id": 225214623,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1612469011
    },
    {
        "content": "<p>I suppose my general point is that dynamic shuffles and non-parameterized shuffles are fairly trivial to implement and can definitely be implemented in an API-stable way, so we can potentially stabilize those while the others are still in flux</p>",
        "id": 225216718,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612469935
    },
    {
        "content": "<p>Anything else was just musings <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 225216753,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612469958
    },
    {
        "content": "<p>I think having just interleaving etc will be sufficient for most people, you can always convert to the std::arch type if necessary, and getting the fully generic interface will be the icing on the cake</p>",
        "id": 225217111,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1612470127
    },
    {
        "content": "<p>also apparently the paper I posted earlier got updated since then and is on <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0214r9.pdf\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0214r9.pdf</a><br>\nand here's the primary author's blog I guess? <a href=\"https://mattkretz.github.io/\">https://mattkretz.github.io/</a> nice.</p>",
        "id": 225217707,
        "sender_full_name": "Jubilee",
        "timestamp": 1612470424
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span> you posted about const generics shuffles that it'd be v1.shuffle(v2) where v2 could have a different length. Are there functions like that which can shuffle two different sized vectors together? I've always seen shuffles with both sides being the same length.</p>",
        "id": 225220118,
        "sender_full_name": "Lokathor",
        "timestamp": 1612471681
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> oh no, no, I didn't mean to say that if I did! what I meant that for anything using <code>fn simd_shuffle{N}</code>, the signature required by rustc is effectively <code>shuffle&lt;IDX&gt;(T, T) -&gt; U</code></p>",
        "id": 225220506,
        "sender_full_name": "Jubilee",
        "timestamp": 1612471846
    },
    {
        "content": "<p>your example in the const eval thread had an additional input length on the shuffle separate from the &amp;self length</p>",
        "id": 225220598,
        "sender_full_name": "Lokathor",
        "timestamp": 1612471895
    },
    {
        "content": "<p>const S only affects U, not T, and is actually part of the parameterization of M.</p>",
        "id": 225220710,
        "sender_full_name": "Jubilee",
        "timestamp": 1612471942
    },
    {
        "content": "<p>( M for mask because that's what the shufflevector input is called, S arbitrarily for Size because I didn't want to use LEN and L in the same example for some reason )</p>",
        "id": 225220797,
        "sender_full_name": "Jubilee",
        "timestamp": 1612471998
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"k\">crate</span>::<span class=\"n\">SimdU32</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"fm\">macro_rules!</span><span class=\"w\"> </span><span class=\"n\">impl_shuffle_lane</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"cp\">$t</span>:<span class=\"nc\">ident</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"cp\">$fn</span>:<span class=\"nc\">ident</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"cp\">$n</span>:<span class=\"nc\">literal</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"cp\">$t</span><span class=\"o\">&lt;</span><span class=\"cp\">$n</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">shuffle</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">M</span>: <span class=\"p\">[</span><span class=\"kt\">u32</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"cp\">$n</span><span class=\"p\">]</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">other</span>: <span class=\"nc\">Self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">crate</span>::<span class=\"n\">intrinsics</span>::<span class=\"cp\">$fn</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">other</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"n\">expand_shuffle</span><span class=\"o\">!</span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">SimdU32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">simd_shuffle4</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>aaand we're in business! ^_^</p>",
        "id": 225229908,
        "sender_full_name": "Jubilee",
        "timestamp": 1612476017
    },
    {
        "content": "<p>Okay~!</p>",
        "id": 225236047,
        "sender_full_name": "Jubilee",
        "timestamp": 1612479084
    },
    {
        "content": "<p>PR open this time.</p>",
        "id": 225236060,
        "sender_full_name": "Jubilee",
        "timestamp": 1612479092
    },
    {
        "content": "<blockquote>\n<p>I was about to ask about the \"reverse\" (trait bounds depending on const parameters), I see that this already works, even by mentioning a const param that's declared after (tested that because of the ordering restriction on stable):</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"o\">&lt;</span><span class=\"n\">T</span>: <span class=\"nc\">X</span><span class=\"o\">&lt;</span><span class=\"n\">N</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Is it intentional that that compiles?</p>\n</blockquote>\n<p>someone brought this up in const parameter pull @ <a href=\"https://github.com/rust-lang/project-const-generics/pull/3\">https://github.com/rust-lang/project-const-generics/pull/3</a> as an example of code that <em>does</em> compile. Interesting.</p>",
        "id": 225593204,
        "sender_full_name": "Jubilee",
        "timestamp": 1612811666
    }
]