[
    {
        "content": "<p>Hmm.<br>\nI was going to say \"cptr and mptr are unnecessary, we could have one monomorphized SIMD pointer type\" but then I saw the differing impls of their actual types, and realized that we'd want to enable SIMD gather/scatter for replace, which requires <code>*mut</code> pointers, so yeah. Definitely going to have two SIMD pointer types. Oh well! No problem, honestly.</p>",
        "id": 237711063,
        "sender_full_name": "Jubilee",
        "timestamp": 1620327398
    },
    {
        "content": "<p>Do any scatter/gather instructions actually take pointers via simd registers?</p>",
        "id": 237711555,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620327600
    },
    {
        "content": "<p>x86-64 uses a GP register for the pointer and then specifies offsets via the SIMD type (and that simd type has the element width, not pointer width)</p>",
        "id": 237711737,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620327644
    },
    {
        "content": "<p>ooh, good question.</p>",
        "id": 237712000,
        "sender_full_name": "Jubilee",
        "timestamp": 1620327740
    },
    {
        "content": "<p>I would hazard a guess that the answer is no since SIMD doesn't really interact with memory?</p>",
        "id": 237712158,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620327797
    },
    {
        "content": "<p>At least not in any regular way</p>",
        "id": 237712254,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620327844
    },
    {
        "content": "<p>what does the \"vm32x\" here in the operands mean?<br>\n<a href=\"https://www.felixcloutier.com/x86/vgatherdps:vgatherqps\">https://www.felixcloutier.com/x86/vgatherdps:vgatherqps</a><br>\nI usually can puzzle things out but my brain is stalling.<br>\nAnd then the AVX512 instructions look like they're subtly different...</p>",
        "id": 237712982,
        "sender_full_name": "Jubilee",
        "timestamp": 1620328121
    },
    {
        "content": "<p>vector mask, 32 bits, {x,y}mm register?</p>",
        "id": 237713072,
        "sender_full_name": "Jubilee",
        "timestamp": 1620328166
    },
    {
        "content": "<p>I'm not sure where that terminology comes from, but that's the GP register</p>",
        "id": 237713100,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620328177
    },
    {
        "content": "<p>Pretty sure</p>",
        "id": 237713110,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620328182
    },
    {
        "content": "<blockquote>\n<p>There's a note in Codegen.hs about how I didn't know what vm32x vm32y vm64x vm64y are.</p>\n<p>They're 32 and 64-bit memory operands. We can finally support vgatherpd. Woo.</p>\n</blockquote>\n<p>aha, you're right.</p>",
        "id": 237713383,
        "sender_full_name": "Jubilee",
        "timestamp": 1620328314
    },
    {
        "content": "<p>I... think?</p>",
        "id": 237713485,
        "sender_full_name": "Jubilee",
        "timestamp": 1620328354
    },
    {
        "content": "<blockquote>\n<div class=\"codehilite\"><pre><span></span><code>&quot;vm32x&quot;\n   A vector of memory addresses using VSIB with 32-bit indices in XMM register.\n</code></pre></div>\n\n</blockquote>\n<p>oh no!<br>\n<a href=\"https://pkg.go.dev/github.com/mmcloughlin/avo/internal/opcodesxml?utm_source=godoc\">https://pkg.go.dev/github.com/mmcloughlin/avo/internal/opcodesxml?utm_source=godoc</a><br>\nthank you Go, I can at least appreciate your fondness for documentation.</p>",
        "id": 237713791,
        "sender_full_name": "Jubilee",
        "timestamp": 1620328511
    },
    {
        "content": "<p>Hmm</p>",
        "id": 237713819,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620328523
    },
    {
        "content": "<p>yeah, it basically is just \"a vector of pointers\"</p>",
        "id": 237713834,
        "sender_full_name": "Jubilee",
        "timestamp": 1620328528
    },
    {
        "content": "<p>the <em>intrinsics</em> do happen to work like \"offsets from a base, potentially masked\".</p>",
        "id": 237713973,
        "sender_full_name": "Jubilee",
        "timestamp": 1620328578
    },
    {
        "content": "<p>I'm very confused what vm64x is for example</p>",
        "id": 237714133,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620328657
    },
    {
        "content": "<p>Wouldn't you need two xmm registers for that?</p>",
        "id": 237714165,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620328670
    },
    {
        "content": "<p>For vgatherqps</p>",
        "id": 237714245,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620328689
    },
    {
        "content": "<p>Oh no, it just loads half as many</p>",
        "id": 237714447,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620328789
    },
    {
        "content": "<blockquote>\n<p>VEX.128 version: For dword indices, the instruction will gather four single-precision floating-point values. For qword indices, the instruction will gather two values and zero the upper 64 bits of the destination.</p>\n</blockquote>",
        "id": 237714448,
        "sender_full_name": "Jubilee",
        "timestamp": 1620328789
    },
    {
        "content": "<p>Yeah.</p>",
        "id": 237714461,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620328796
    },
    {
        "content": "<p>yep</p>",
        "id": 237714472,
        "sender_full_name": "Jubilee",
        "timestamp": 1620328800
    },
    {
        "content": "<p>So the thing that gets weird here is 32-bit pointers</p>",
        "id": 237714583,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620328835
    },
    {
        "content": "<p>yeeeeeeeeeeeeeEEEP</p>",
        "id": 237714605,
        "sender_full_name": "Jubilee",
        "timestamp": 1620328842
    },
    {
        "content": "<p>Which certainly explains why the intrinsic uses a base pointer only</p>",
        "id": 237714640,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620328862
    },
    {
        "content": "<p>I am slowly materializing a design in my head but there is a reason why I wanted to open the floor for banter, which is \"lol, this is gonna be weird no matter how we do it\".</p>",
        "id": 237714771,
        "sender_full_name": "Jubilee",
        "timestamp": 1620328921
    },
    {
        "content": "<p>I'm pretty sure we just ignore the concept of the 32-bit pointers and hope llvm optimizes it</p>",
        "id": 237714963,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620329004
    },
    {
        "content": "<p>Looks like llvm ignores it</p>",
        "id": 237714989,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620329019
    },
    {
        "content": "<p>They just take pointer vectors directly</p>",
        "id": 237715007,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620329028
    },
    {
        "content": "<p>Okay, LLVM thinks of this as pointer vectors? Cool, then yeah, I think we should angle for basically using SIMD pointer types as a result. I want to talk to wg-unsafe-code-guidelines though, thinking about it, because I want to know if we're gonna break the world if e.g. we enable easily using SIMD gather on, say, multiple slices in memory.</p>",
        "id": 237715157,
        "sender_full_name": "Jubilee",
        "timestamp": 1620329105
    },
    {
        "content": "<p>multiple slices in memory that may not be part of the same superstructure.</p>",
        "id": 237715231,
        "sender_full_name": "Jubilee",
        "timestamp": 1620329135
    },
    {
        "content": "<p>Hm you've lost me there</p>",
        "id": 237715248,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620329147
    },
    {
        "content": "<p>Basically the question is:<br>\n\"does the entire gather have to be 'in-bounds' for some memory object?\"</p>",
        "id": 237715326,
        "sender_full_name": "Jubilee",
        "timestamp": 1620329172
    },
    {
        "content": "<p>What's a \"memory object\"?</p>",
        "id": 237715366,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620329188
    },
    {
        "content": "<p>\"or can it be 'in-bounds' for multiple <em>different</em> memory objects?\"</p>",
        "id": 237715368,
        "sender_full_name": "Jubilee",
        "timestamp": 1620329190
    },
    {
        "content": "<p>a struct, slice of bytes, etc.</p>",
        "id": 237715403,
        "sender_full_name": "Jubilee",
        "timestamp": 1620329208
    },
    {
        "content": "<p>Basically, what kind of provenance does a vector of pointers need.</p>",
        "id": 237715471,
        "sender_full_name": "Jubilee",
        "timestamp": 1620329248
    },
    {
        "content": "<p>Well they're just pointers</p>",
        "id": 237715503,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620329266
    },
    {
        "content": "<p>The function is unsafe inherently</p>",
        "id": 237715523,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620329275
    },
    {
        "content": "<p>But for a gather the pointers need to be readable and for scatter they need to be writable</p>",
        "id": 237715621,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620329314
    },
    {
        "content": "<p>That's it</p>",
        "id": 237715640,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620329324
    },
    {
        "content": "<p>yep! which is why, before I provide such a function, I want to be able to say <em>something</em> about what gathers and scatters are UB, with relative confidence.</p>",
        "id": 237715664,
        "sender_full_name": "Jubilee",
        "timestamp": 1620329338
    },
    {
        "content": "<p>You need to hold all of the pointers uniquely for a scatter</p>",
        "id": 237715674,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620329343
    },
    {
        "content": "<p>And you need to hold all of them immutably for a gather</p>",
        "id": 237715704,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620329364
    },
    {
        "content": "<p>I don't think it's any different than ptr read/write</p>",
        "id": 237715726,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620329377
    },
    {
        "content": "<p>sure it is.</p>",
        "id": 237715739,
        "sender_full_name": "Jubilee",
        "timestamp": 1620329385
    },
    {
        "content": "<p>Why?</p>",
        "id": 237715748,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620329393
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">ManyValues</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"cm\">/*  A facade for an array, maybe allocated somewhere, of initialized values. At least 2. */</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">ManyValues</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">fn</span> <span class=\"nf\">new</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"cm\">/* does the obvious */</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">fn</span> <span class=\"nf\">as_ptr</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"cm\">/* does the obvious */</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">aa</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ManyValues</span>::<span class=\"n\">new</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ab</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ManyValues</span>::<span class=\"n\">new</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ac</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ManyValues</span>::<span class=\"n\">new</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ad</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ManyValues</span>::<span class=\"n\">new</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">all</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">aa</span><span class=\"p\">.</span><span class=\"n\">as_ptr</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">ab</span><span class=\"p\">.</span><span class=\"n\">as_ptr</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">ac</span><span class=\"p\">.</span><span class=\"n\">as_ptr</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">ad</span><span class=\"p\">.</span><span class=\"n\">as_ptr</span><span class=\"p\">()];</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">vals</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">SimdPtr</span>::<span class=\"n\">from_array</span><span class=\"p\">(</span><span class=\"n\">all</span><span class=\"p\">).</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">).</span><span class=\"n\">gather</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>\n<p>So the question is if <em>this</em> is UB or not, because individually those reads are valid, but only because they are each in-bounds of their original object.</p>",
        "id": 237716999,
        "sender_full_name": "Jubilee",
        "timestamp": 1620329895
    },
    {
        "content": "<p>I don't understand what in-bounds means</p>",
        "id": 237717084,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620329940
    },
    {
        "content": "<p>a read is in-bounds if it's actually reading data from the memory object.</p>",
        "id": 237717141,
        "sender_full_name": "Jubilee",
        "timestamp": 1620329977
    },
    {
        "content": "<p>to simplify.</p>",
        "id": 237717157,
        "sender_full_name": "Jubilee",
        "timestamp": 1620329990
    },
    {
        "content": "<p>\"a valid index\", basically.</p>",
        "id": 237717238,
        "sender_full_name": "Jubilee",
        "timestamp": 1620330016
    },
    {
        "content": "<p>\"a read that does not contain Bonus Data\" per <a href=\"https://twitter.com/dril_rs/status/1230334918560890882\">https://twitter.com/dril_rs/status/1230334918560890882</a></p>\n<div class=\"inline-preview-twitter\"><div class=\"twitter-tweet\"><a href=\"https://twitter.com/dril_rs/status/1230334918560890882\"><img class=\"twitter-avatar\" src=\"https://uploads.zulipusercontent.net/041916194bb410af5ffe571160cb872b3c2ace27/68747470733a2f2f7062732e7477696d672e636f6d2f70726f66696c655f696d616765732f313033343935363333343930353631303234312f357071686c69655f5f6e6f726d616c2e6a7067\"></a><p>one of the things i dont “get” about rustc is why can’t you index out of bounds. c gives me “bonus data” but no. rustc always jsut gives me shit</p><span>- wint32_t (@dril_rs)</span></div></div>",
        "id": 237717298,
        "sender_full_name": "Jubilee",
        "timestamp": 1620330055
    },
    {
        "content": "<p>You can do <code>array.as_ptr().add(1).read()</code> as long as the pointer is valid to read under the mutability rules</p>",
        "id": 237717351,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620330083
    },
    {
        "content": "<p>Where the pointer \"came from\" doesn't matter</p>",
        "id": 237717382,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620330100
    },
    {
        "content": "<p>If you allocate two entirely different objects adjacent in memory with mmap and index off of one mapping into the other it's still valid as long as you treat mutability of that address correctly</p>",
        "id": 237717545,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620330174
    },
    {
        "content": "<p>I do not think that is entirely correct, due to the implications of provenance:<br>\n<a href=\"https://www.ralfj.de/blog/2020/12/14/provenance.html\">https://www.ralfj.de/blog/2020/12/14/provenance.html</a><br>\n<a href=\"https://www.ralfj.de/blog/2018/07/24/pointers-and-bytes.html\">https://www.ralfj.de/blog/2018/07/24/pointers-and-bytes.html</a></p>\n<blockquote>\n<p>Just because two pointers point to the same address, does not mean they are equal and can be used interchangeably.</p>\n</blockquote>",
        "id": 237718841,
        "sender_full_name": "Jubilee",
        "timestamp": 1620330807
    },
    {
        "content": "<p>That's in the context of optimization, though.  Not at the language level</p>",
        "id": 237721442,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620332070
    },
    {
        "content": "<p>Otherwise you wouldn't be able to do things like use the high pointer bit for short string optimization</p>",
        "id": 237721590,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620332136
    },
    {
        "content": "<p>A huge number of Linux APIs involve conditionally casting extra elements to structs that sometimes contain pointers</p>",
        "id": 237721822,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620332255
    },
    {
        "content": "<p>I have a <em>reasonable</em> confidence that the example code is <em>probably</em> valid, but can you see why I want to run it by WUCG first, now? :^)</p>",
        "id": 237722255,
        "sender_full_name": "Jubilee",
        "timestamp": 1620332466
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/SIMD.20Pointers/near/237717351\">said</a>:</p>\n<blockquote>\n<p>You can do <code>array.as_ptr().add(1).read()</code> as long as the pointer is valid to read under the mutability rules</p>\n</blockquote>\n<p>that's wrong: from the <code>add</code> docs:</p>\n<blockquote>\n<p>If any of the following conditions are violated, the result is Undefined Behavior:</p>\n<p>Both the starting and resulting pointer must be either in bounds or one byte past the end of the same allocated object. Note that in Rust, every (stack-allocated) variable is considered a separate allocated object.</p>\n</blockquote>",
        "id": 237722808,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1620332723
    },
    {
        "content": "<p>if you want to go from 1 allocated object to another, you have to use <code>wrapping_add</code></p>",
        "id": 237722940,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1620332781
    },
    {
        "content": "<p>Hmm yeah I suppose I meant wrapping add, yeah</p>",
        "id": 237723453,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620333045
    },
    {
        "content": "<p>But my point in general stands that you can cross objects</p>",
        "id": 237723489,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620333062
    },
    {
        "content": "<p>So, for some reason llvm doesn't compile  a gather load from a vector of pointers to <code>i32</code> into one or more AVX2<code>vgatherqps</code> even though it should...<code>vgatherqps</code> with zero put in the base reg and the pointer vector as the index reg should work just fine.<br>\n<a href=\"https://llvm.godbolt.org/z/WsT3xPrME\">https://llvm.godbolt.org/z/WsT3xPrME</a></p>",
        "id": 237723515,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1620333077
    },
    {
        "content": "<p>Linux isn't yet written in Rust, so don't assume it's rules always apply for us</p>",
        "id": 237724545,
        "sender_full_name": "Lokathor",
        "timestamp": 1620333487
    },
    {
        "content": "<p>So it's UB to call Linux syscalls?</p>",
        "id": 237724610,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620333516
    },
    {
        "content": "<p>Well, particularly: you <strong>cannot</strong> use wrapping add to cross object boundaries. You can use wrapping add to go out of bounds but you have to go back in bounds again before using the pointer, or it's UB.</p>",
        "id": 237724690,
        "sender_full_name": "Lokathor",
        "timestamp": 1620333562
    },
    {
        "content": "<p>It would also be impossible to write a C frontend in LLVM if that's the case, since two identical pointers _are_ the same and are frequently converted through integers</p>",
        "id": 237724702,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620333571
    },
    {
        "content": "<p>FFI is written very carefully. <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 237724707,
        "sender_full_name": "Jubilee",
        "timestamp": 1620333573
    },
    {
        "content": "<p>pointer/int casts are like an entire RalfJ blog post just to introduce the problem, i cannot solve it right here on my phone XD</p>",
        "id": 237724835,
        "sender_full_name": "Lokathor",
        "timestamp": 1620333625
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/SIMD.20Pointers/near/237724702\">said</a>:</p>\n<blockquote>\n<p>It would also be impossible to write a C frontend in LLVM if that's the case, since two identical pointers _are_ the same and are frequently converted through integers</p>\n</blockquote>\n<p>I mean... I consider the proposition that it is possible to write a correct C compiler to be currently unproven, and the proposition that LLVM is one doubly so. It implements <strong>a</strong> behavior, that doesn't mean it's a correct one.</p>",
        "id": 237724942,
        "sender_full_name": "Jubilee",
        "timestamp": 1620333678
    },
    {
        "content": "<p><a href=\"https://www.ralfj.de/blog/2018/07/24/pointers-and-bytes.html\">https://www.ralfj.de/blog/2018/07/24/pointers-and-bytes.html</a></p>\n<p><a href=\"https://www.ralfj.de/blog/2020/12/14/provenance.html\">https://www.ralfj.de/blog/2020/12/14/provenance.html</a></p>\n<p>whoops did i say one post? i meant two blog posts</p>",
        "id": 237724958,
        "sender_full_name": "Lokathor",
        "timestamp": 1620333691
    },
    {
        "content": "<p>Yeah I already linked those~</p>",
        "id": 237725143,
        "sender_full_name": "Jubilee",
        "timestamp": 1620333790
    },
    {
        "content": "<p>So following those optimization rules I still don't see how that affects scatter/gather</p>",
        "id": 237725190,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620333820
    },
    {
        "content": "<p>If your pointers are created properly you can use them</p>",
        "id": 237725263,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620333847
    },
    {
        "content": "<p>oh my gosh you did link them</p>",
        "id": 237725485,
        "sender_full_name": "Lokathor",
        "timestamp": 1620333961
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"312331\">@Caleb Zulawski</span> correct: if you do it carefully you can use the pointer</p>",
        "id": 237725598,
        "sender_full_name": "Lokathor",
        "timestamp": 1620333998
    },
    {
        "content": "<p>note that, for example, I don't have wrappers for these ops in safe_arch because making a good interface for it was, at the time, \"more trouble than i wanted to deal with\"</p>",
        "id": 237725732,
        "sender_full_name": "Lokathor",
        "timestamp": 1620334045
    },
    {
        "content": "<p>Got it to generate <code>vgatherqps</code>, turns out I needed to use <code>-O3 -march=skylake</code>:<br>\n<a href=\"https://llvm.godbolt.org/z/MParP6Ys4\">https://llvm.godbolt.org/z/MParP6Ys4</a></p>",
        "id": 237729425,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1620335199
    },
    {
        "content": "<p>My understanding is that gather on most x86 uarches actually does nothing</p>",
        "id": 237732340,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620336011
    },
    {
        "content": "<p>really? that sucks.</p>",
        "id": 237735245,
        "sender_full_name": "Jubilee",
        "timestamp": 1620337357
    },
    {
        "content": "<p>it also works on risc-v v (and SimpleV and probably ARM SVE):<br>\n<a href=\"https://llvm.godbolt.org/z/WejPcoxro\">https://llvm.godbolt.org/z/WejPcoxro</a></p>",
        "id": 237735809,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1620337646
    },
    {
        "content": "<p>Yeah except for a few cpus it just does normal sequential loads</p>",
        "id": 237736867,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620338265
    },
    {
        "content": "<p>Reduces your number of instructions but that's it</p>",
        "id": 237736926,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620338285
    },
    {
        "content": "<p>Eh, I guess that's worth it, tbh.</p>",
        "id": 237736969,
        "sender_full_name": "Jubilee",
        "timestamp": 1620338310
    },
    {
        "content": "<p>Maybe slightly but hardly</p>",
        "id": 237737007,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620338331
    },
    {
        "content": "<blockquote>\n<p>2.3.12  Vector SIB (VSIB) Memory Addressing</p>\n</blockquote>\n<p>wow I was wrong, it's a totally wild <strong>exotic memory encoding</strong>.</p>",
        "id": 237737826,
        "sender_full_name": "Jubilee",
        "timestamp": 1620338742
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/SIMD.20Pointers/near/237737007\">said</a>:</p>\n<blockquote>\n<p>Maybe slightly but hardly</p>\n</blockquote>\n<p>I should note that I was just sort of assuming that generating a vector gather will allow for graceful acceleration here as arches improve, assuming it's a correct instruction to lower to. However, it's actually slower to lower to a gather in the simple case!<br>\n<a href=\"https://stackoverflow.com/questions/24756534/in-what-situation-would-the-avx2-gather-instructions-be-faster-than-individually\">https://stackoverflow.com/questions/24756534/in-what-situation-would-the-avx2-gather-instructions-be-faster-than-individually</a><br>\nwhich sucks.</p>",
        "id": 237741071,
        "sender_full_name": "Jubilee",
        "timestamp": 1620340487
    },
    {
        "content": "<p>Great lol</p>",
        "id": 237741422,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620340737
    },
    {
        "content": "<p>though I actually didn't bench it against compiler output, this is being measured against hand-assembler, and while compilers <em>say</em> they provide zero cost abstractions... well, Uhmmm, Not Always.</p>",
        "id": 237741671,
        "sender_full_name": "Jubilee",
        "timestamp": 1620340927
    },
    {
        "content": "<p>it greatly depends on the cpu, which is why llvm will scalarize a vector gather on haswell (since that's faster there) and generate a <code>vgather*</code> on skylake (since that's faster there).</p>",
        "id": 237742467,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1620341484
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/SIMD.20Pointers/near/237716999\">said</a>:</p>\n<blockquote>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">ManyValues</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"cm\">/*  A facade for an array, maybe allocated somewhere, of initialized values. At least 2. */</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">ManyValues</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">fn</span> <span class=\"nf\">new</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"cm\">/* does the obvious */</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">fn</span> <span class=\"nf\">as_ptr</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"cm\">/* does the obvious */</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">aa</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ManyValues</span>::<span class=\"n\">new</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ab</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ManyValues</span>::<span class=\"n\">new</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ac</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ManyValues</span>::<span class=\"n\">new</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ad</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ManyValues</span>::<span class=\"n\">new</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">all</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">aa</span><span class=\"p\">.</span><span class=\"n\">as_ptr</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">ab</span><span class=\"p\">.</span><span class=\"n\">as_ptr</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">ac</span><span class=\"p\">.</span><span class=\"n\">as_ptr</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">ad</span><span class=\"p\">.</span><span class=\"n\">as_ptr</span><span class=\"p\">()];</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">vals</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">SimdPtr</span>::<span class=\"n\">from_array</span><span class=\"p\">(</span><span class=\"n\">all</span><span class=\"p\">).</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">).</span><span class=\"n\">gather</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>\n<p>So the question is if <em>this</em> is UB or not, because individually those reads are valid, but only because they are each in-bounds of their original object.</p>\n</blockquote>\n<p>What does this <code>SimdPtr::from_array(all).add(1).gather()</code> line do? (I googled <code>SimdPtr</code> but it seems this is psuedocode.) Is it reading from the four pointers as in <code>let vals = [*all[0], *all[1], *all[2], *all[3]];</code>? Because that is not UB, it's just four loads. If you are making some assumptions about <code>aa, ab, ac, ad</code> being adjacent in memory though that's a no-no</p>",
        "id": 237761785,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620356900
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/SIMD.20Pointers/near/237724702\">said</a>:</p>\n<blockquote>\n<p>It would also be impossible to write a C frontend in LLVM if that's the case, since two identical pointers _are_ the same and are frequently converted through integers</p>\n</blockquote>\n<p>This is very misleading. At the end of the day pointers are represented as integers in hardware, but the day is long and has many compiler optimizations in it that treat two bitwise identical pointers as distinct</p>",
        "id": 237762019,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620357149
    },
    {
        "content": "<p>At the language level, there is more to a pointer than just the bits. I'm not entirely convinced that the overall model is sound but the fact of the matter is that the abstract rust machine has a bunch of auxiliary extra data stuck on to the actual bits</p>",
        "id": 237762058,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620357240
    },
    {
        "content": "<p>It is perfectly valid, for example, for an operating system to define certain addresses to have certain meanings and you can pull those pointers out of thin air</p>",
        "id": 237762157,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620357343
    },
    {
        "content": "<p>I understand that pointer _arithmetic_ might make certain assumptions, but even then things like SSO are valid</p>",
        "id": 237762207,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620357380
    },
    {
        "content": "<p>The reason I was concerned about thinking this would relate to scatter/gather at all is because there's simply no arithmetic involved</p>",
        "id": 237762266,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620357470
    },
    {
        "content": "<p>well i suspect that it's ill defined but i also suspect you can't scatter to a place you don't have write permission to and you can't gather from a place you don't have read permission from</p>",
        "id": 237762337,
        "sender_full_name": "Lokathor",
        "timestamp": 1620357512
    },
    {
        "content": "<p>Yeah, I expect it has identical semantics to regular pointer read/write</p>",
        "id": 237762378,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620357579
    },
    {
        "content": "<p>I will say that you can do this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">array_here_at_least_2_elements</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">as_ptr</span><span class=\"p\">().</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>\n<p>but that's because  the <code>as_ptr</code> value can access to \"the whole array\", so when you add by 1 you're just indexing to element 1 more verbosely.</p>",
        "id": 237762488,
        "sender_full_name": "Lokathor",
        "timestamp": 1620357659
    },
    {
        "content": "<p>so if we understand scatter/gather as being \"weirdly compact indexing\", then it's easy to understand the rules</p>",
        "id": 237762597,
        "sender_full_name": "Lokathor",
        "timestamp": 1620357730
    },
    {
        "content": "<p>Looking more into this, getelementptr absolutely allows pointers to be willed out of thin air</p>",
        "id": 237762828,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620357949
    },
    {
        "content": "<p>If you use the \"inbounds\" optimization it will track the pointer through arithmetic</p>",
        "id": 237762911,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620357997
    },
    {
        "content": "<p>Which looks like what <span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span> was referencing</p>",
        "id": 237762916,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620358013
    },
    {
        "content": "<p>But there's no overall assumption that you need to follow rules like that</p>",
        "id": 237762928,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620358030
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/SIMD.20Pointers/near/237762157\">said</a>:</p>\n<blockquote>\n<p>It is perfectly valid, for example, for an operating system to define certain addresses to have certain meanings and you can pull those pointers out of thin air</p>\n</blockquote>\n<p>Pointers which are created directly from integers have a provenance of their own, different from the provenance of pointers created by (the equivalent of) malloc which is \"magic\"</p>",
        "id": 237762958,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620358076
    },
    {
        "content": "<p>Yeah that's what I was trying to get at--if you don't use the \"inbounds\" optimization it doesn't particularly care about provenance</p>",
        "id": 237763042,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620358148
    },
    {
        "content": "<p>A language like C does not have that concept so if it's using that optimization it better be careful to assert the programmer didn't intentionally cross an object boundary</p>",
        "id": 237763074,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620358185
    },
    {
        "content": "<p>The semantics of scatter/gather is underdetermined by the hardware, which doesn't operate on provenance. It is compiler developers and language folks who fill in the story around how the extra ghost state is manipulated, and the obvious thing is to make it act like a read</p>",
        "id": 237763082,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620358197
    },
    {
        "content": "<p>But it is important that say LLVM and Rust agree on how that extra state is handled</p>",
        "id": 237763172,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620358234
    },
    {
        "content": "<p>Again since it's a read/write I don't see how provenance is relevant.  The UB would be an improper use of <code>pointer::add</code>, not scatter/gather</p>",
        "id": 237763293,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620358334
    },
    {
        "content": "<p>I admit I don't know what these simd operations actually do, but it sounds like gather is just 4 reads at once</p>",
        "id": 237763382,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620358410
    },
    {
        "content": "<p>Yeah that's all it is</p>",
        "id": 237763393,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620358425
    },
    {
        "content": "<p>in which case it would be UB if you read out of an allocation</p>",
        "id": 237763395,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620358427
    },
    {
        "content": "<p>although maybe there is some way to limit that to just producing <code>poison</code></p>",
        "id": 237763447,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620358454
    },
    {
        "content": "<p>Yeah, same as <code>pointer::read</code> as far as I can tell</p>",
        "id": 237763475,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620358466
    },
    {
        "content": "<p>As to whether simd <code>add</code> acts like <code>wrapping_add</code> or <code>add</code> (i.e. does it assert that the target is inbounds) I would lean towards <code>wrapping_add</code></p>",
        "id": 237763506,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620358512
    },
    {
        "content": "<p>but LLVM is the first mover here so we have to follow what they do</p>",
        "id": 237763541,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620358546
    },
    {
        "content": "<p>If it's implemented with simd add, yes it would be like wrapping_add</p>",
        "id": 237763605,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620358585
    },
    {
        "content": "<p>The underlying type is just an integer</p>",
        "id": 237763634,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620358614
    },
    {
        "content": "<p>Whether the hardware wraps is independent of whether it is UB</p>",
        "id": 237763663,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620358634
    },
    {
        "content": "<p><code>pointer::add</code> is special because it's not implemented with addition at all, it's implemented with getelementptr</p>",
        "id": 237763672,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620358650
    },
    {
        "content": "<p>The UB question can only be decided by consulting the LLVM spec (such as it is) or whether there are any optimizations that make assumptions in violation of the spec we want</p>",
        "id": 237763701,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620358683
    },
    {
        "content": "<p>getelementptr is also \"just an add\" in hardware</p>",
        "id": 237763763,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620358709
    },
    {
        "content": "<p>but LLVM will translate adds to geps <em>and vice versa</em> so it's not as simple as you think</p>",
        "id": 237763787,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620358731
    },
    {
        "content": "<p>Agreed, but it has the option of the \"inbounds\" optimization, which is where the whole provenance question comes from</p>",
        "id": 237763791,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620358738
    },
    {
        "content": "<p>If you do not use that optimization it's not relevant</p>",
        "id": 237763800,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620358748
    },
    {
        "content": "<p>It's specifically only if you specifically <code>getelementptr inbounds</code></p>",
        "id": 237763829,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620358779
    },
    {
        "content": "<p>I'm inclined to agree with you here, I doubt simd add in LLVM has any kind of inbounds option</p>",
        "id": 237763843,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620358792
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/SIMD.20Pointers/near/237761785\">said</a>:</p>\n<blockquote>\n<p>What does this <code>SimdPtr::from_array(all).add(1).gather()</code> line do? (I googled <code>SimdPtr</code> but it seems this is psuedocode.) Is it reading from the four pointers as in <code>let vals = [*all[0], *all[1], *all[2], *all[3]];</code>? Because that is not UB, it's just four loads. If you are making some assumptions about <code>aa, ab, ac, ad</code> being adjacent in memory though that's a no-no</p>\n</blockquote>\n<p>Yeah that is just pseudocode for a hypothetical SimdPtr type and yeah, <code>fn gather(self)</code> would just be \"turn this from a vector of pointers into a vector of elements from those locations\".</p>",
        "id": 237763898,
        "sender_full_name": "Jubilee",
        "timestamp": 1620358813
    },
    {
        "content": "<p>and I can only hope that if they see a simd add and unvectorize it they wouldn't be so foolish as to transform it into a gepi</p>",
        "id": 237763918,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620358833
    },
    {
        "content": "<p>There is no vector getelementptr in general</p>",
        "id": 237763941,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620358855
    },
    {
        "content": "<p>You can only use regular arithmetic on vectors in LLVM</p>",
        "id": 237763965,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620358886
    },
    {
        "content": "<p>Though I do think we should consider adopting Intel's scatter/gather API to both avoid a simd pointer type, and to make it easy to work with smaller width pointers</p>",
        "id": 237764082,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620359006
    },
    {
        "content": "<p>luv 2 do raw pointer arithmetic.</p>",
        "id": 237764087,
        "sender_full_name": "Jubilee",
        "timestamp": 1620359008
    },
    {
        "content": "<p>Working with 2 64-bit pointer vectors to load a single vector of f32s doesn't seem practical</p>",
        "id": 237764146,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620359056
    },
    {
        "content": "<p>hmm? you mean basically taking a vector of indices into an alloc?</p>",
        "id": 237764188,
        "sender_full_name": "Jubilee",
        "timestamp": 1620359090
    },
    {
        "content": "<p>is there a version of gather that does <code>*(a+x_i)</code> where <code>a</code> is a GPR?</p>",
        "id": 237764247,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620359129
    },
    {
        "content": "<p>That's Intel's API</p>",
        "id": 237764320,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620359167
    },
    {
        "content": "<p>Yeah, that's basically how the intrinsic functions work.</p>",
        "id": 237764321,
        "sender_full_name": "Jubilee",
        "timestamp": 1620359167
    },
    {
        "content": "<p>but I guess the downside is that they all have the same base pointer, so if you want to gather from many different arrays you are in trouble</p>",
        "id": 237764358,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620359213
    },
    {
        "content": "<p>unless you get lucky and the arrays are not too far apart in address space, and then you have to make accesses to multiple allocations from a single base pointer <span aria-label=\"grimacing\" class=\"emoji emoji-1f62c\" role=\"img\" title=\"grimacing\">:grimacing:</span></p>",
        "id": 237764500,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620359325
    },
    {
        "content": "<p>Ah, I thought this one was gonna be a problem eventually.</p>\n<p>So, IMO <code>V&lt;[*const T; N]&gt;</code> being the basis for scatter/gather isn't ideal. Doing it as (possibly masked) indexed offsets from a pointer (e.g. <code>unsafe fn gather(*const T, V&lt;[Int; N]&gt;)</code>) -&gt; V&lt;[T; N]&gt;` is much more natural most of the time. If there's hardware that needs it to be a vec of pointers, it's likely going to be easier to convert pointer + offsets into that, than vice versa too, I suspect. This also allows both checked and unchecked versions, where the checked version would gather from a slice. I think the bounds check should be relatively easy to write as simd, too (but we definitely need an unchecked version as well).</p>\n<p>a big hassle though is that indexes on at least x86 are often based on i32, not usize <span aria-label=\"coffin\" class=\"emoji emoji-26b0\" role=\"img\" title=\"coffin\">:coffin:</span> (well, you have both i32 and 64 bit loads, but you kind of need both)</p>",
        "id": 237849716,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1620404216
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/SIMD.20Pointers/near/237713834\">said</a>:</p>\n<blockquote>\n<p>yeah, it basically is just \"a vector of pointers\"</p>\n</blockquote>\n<p>i think you've been hit by the confusion inherent in x86's many addressing modes. in practice this is still base address and 32 bit indices (for the v32x).</p>",
        "id": 237850685,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1620404576
    },
    {
        "content": "<p>another nice thing about doing it based on 1 pointer (or slice) and offsets of that pointer is that i think the problems of provenance become way more natural to answer too</p>",
        "id": 237850868,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1620404645
    },
    {
        "content": "<p>I think we should have pointer vectors, and gather/scatter based on pointer vectors, since some algorithms require that in order to not be compiler-level UB:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[repr(C)]</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">LinkedListNode</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">value</span>: <span class=\"kt\">u64</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">next</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">LinkedListNode</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"sd\">/// vector version</span>\n<span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">next_vec</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">LANES</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">node_ptrs</span>: <span class=\"nc\">SimdPtr</span><span class=\"o\">&lt;</span><span class=\"n\">LinkedListNode</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">LANES</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">mask</span>: <span class=\"nc\">MaskSize</span><span class=\"o\">&lt;</span><span class=\"n\">LANES</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">SimdPtr</span><span class=\"o\">&lt;</span><span class=\"n\">LinkedListNode</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">LANES</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">next_field_ptrs</span>: <span class=\"nc\">SimdPtr</span><span class=\"o\">&lt;*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">LinkedListNode</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">LANES</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">node_ptrs</span><span class=\"p\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">offset_of</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">LinkedListNode</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">next</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">passthru</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">SimdPtr</span>::<span class=\"o\">&lt;</span><span class=\"n\">LinkedListNode</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">LANES</span><span class=\"o\">&gt;</span>::<span class=\"n\">splat</span><span class=\"p\">(</span><span class=\"n\">ptr</span>::<span class=\"n\">null_mut</span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// important: every lane can point to a completely different node object.</span>\n<span class=\"w\">        </span><span class=\"c1\">// mask is required since some node pointers could be null, and dereferencing a null ptr is UB</span>\n<span class=\"w\">        </span><span class=\"n\">node_ptrs</span><span class=\"p\">.</span><span class=\"n\">gather_masked</span><span class=\"p\">(</span><span class=\"n\">mask</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">passthru</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// should compile to:</span>\n<span class=\"w\">        </span><span class=\"c1\">// %ymm0 = passthru</span>\n<span class=\"w\">        </span><span class=\"c1\">// %ymm1 = node_ptrs</span>\n<span class=\"w\">        </span><span class=\"c1\">// %ymm2 = mask</span>\n<span class=\"w\">        </span><span class=\"c1\">// vpgatherqq %ymm0, [%ymm1 + 8], %ymm2</span>\n<span class=\"w\">        </span><span class=\"c1\">// return %ymm0</span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"sd\">/// equivalent array version</span>\n<span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">next_array</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">LANES</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">node_ptrs</span>: <span class=\"p\">[</span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">LinkedListNode</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">LANES</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"n\">masks</span>: <span class=\"p\">[</span><span class=\"kt\">bool</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">LANES</span><span class=\"p\">])</span><span class=\"w\"> </span>-&gt; <span class=\"p\">[</span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">LinkedListNode</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">LANES</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">next_field_ptrs</span>: <span class=\"p\">[</span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">LinkedListNode</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">LANES</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">node_ptrs</span><span class=\"p\">.</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">v</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">addr_of_mut</span><span class=\"o\">!</span><span class=\"p\">((</span><span class=\"o\">*</span><span class=\"n\">v</span><span class=\"p\">).</span><span class=\"n\">next</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">passthru</span>: <span class=\"p\">[</span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">LinkedListNode</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">LANES</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">ptr</span>::<span class=\"n\">null_mut</span><span class=\"p\">();</span><span class=\"w\"> </span><span class=\"n\">LANES</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">node_ptrs</span><span class=\"p\">.</span><span class=\"n\">zip</span><span class=\"p\">(</span><span class=\"n\">mask</span><span class=\"p\">).</span><span class=\"n\">zip</span><span class=\"p\">(</span><span class=\"n\">passthru</span><span class=\"p\">).</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"p\">((</span><span class=\"n\">v</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">mask</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">passthru</span><span class=\"p\">)</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">mask</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">passthru</span><span class=\"w\"> </span><span class=\"p\">})</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Do note that at the x86 assembler level, for <code>vgatherqps %xmm0, [%rax + %ymm1], %xmm2</code>, it is valid for either the vector <code>%ymm1</code> or the base register <code>%rax</code> to be pointers, x86 doesn't have any of the compiler-only UB around address calculation or crossing allocations or wrapping, all it sees are 64-bit integers that it adds together then uses as addresses to load from.</p>\n<p>I do think Intel made a mistake when they omitted gather-using-vector-of-pointers from their list of compiler intrinsics.</p>\n<p>That said, I won't object to also having:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">LANES</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">SimdI32</span><span class=\"o\">&lt;</span><span class=\"n\">LANES</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">gather_indexed_masked_f32</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">base</span>: <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">f32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">mask</span>: <span class=\"nc\">Mask32</span><span class=\"o\">&lt;</span><span class=\"n\">LANES</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">passthru</span>: <span class=\"nc\">SimdF32</span><span class=\"o\">&lt;</span><span class=\"n\">LANES</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">SimdF32</span><span class=\"o\">&lt;</span><span class=\"n\">LANES</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"fm\">todo!</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 237876129,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1620415058
    },
    {
        "content": "<p>the LLVM IR for a gather: <a href=\"https://llvm.org/docs/LangRef.html#llvm-masked-gather-intrinsics\">https://llvm.org/docs/LangRef.html#llvm-masked-gather-intrinsics</a></p>",
        "id": 237876849,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1620415352
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/SIMD.20Pointers/near/237850685\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/SIMD.20Pointers/near/237713834\">said</a>:</p>\n<blockquote>\n<p>yeah, it basically is just \"a vector of pointers\"</p>\n</blockquote>\n<p>i think you've been hit by the confusion inherent in x86's many addressing modes. in practice this is still base address and 32 bit indices (for the v32x).</p>\n</blockquote>\n<p>Yeah I noticed that after I stared at it for a bit.</p>",
        "id": 237882875,
        "sender_full_name": "Jubilee",
        "timestamp": 1620417949
    },
    {
        "content": "<p>That was what the \"totally exotic memory encoding!\" remark was.</p>\n<p>At the moment, I believe we should provide safe, yes, checked <code>gather</code> and <code>scatter</code> functions that take <code>&amp;[T]</code> | <code>&amp;mut [T]</code> and a vector of indices, and think more about the \"vector of pointers\" thing and mb work towards providing an API for that <em>eventually</em>.</p>",
        "id": 237883680,
        "sender_full_name": "Jubilee",
        "timestamp": 1620418383
    },
    {
        "content": "<p>I agree. As cools as scatter/gather are they are fairly niche</p>",
        "id": 237883972,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620418533
    },
    {
        "content": "<p>I think the only architecture that we support that even has it is AVX</p>",
        "id": 237884259,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620418650
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/SIMD.20Pointers/near/237884259\">said</a>:</p>\n<blockquote>\n<p>I think the only architecture that we support that even has it is AVX</p>\n</blockquote>\n<p>all of AVX2 (gather only), AVX512, ARM SVE, RVV, and SimpleV support gather/scatter</p>",
        "id": 237889735,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1620421396
    },
    {
        "content": "<p>Well, we can't support SVE</p>",
        "id": 237890330,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620421683
    },
    {
        "content": "<p>hmm.</p>",
        "id": 237895764,
        "sender_full_name": "Jubilee",
        "timestamp": 1620424533
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"312331\">@Caleb Zulawski</span> I am not so sure. I think we can, actually. I think we might enjoy a situation where the way our API is defined, it favors fixed-width \"strip-mining\" slightly more, but it aligns somewhat with the LLVM understanding of what the RVV/SVE vectors are, which is, as I understand it, \"a possibly dynamic entity, but fixed-width during actual invocation\". So I think on Arm and RISC-V, if LLVM thinks we're going to benefit from going SVE or RVV, we could probably generate \"dynamic\" vectors.</p>",
        "id": 237897657,
        "sender_full_name": "Jubilee",
        "timestamp": 1620425407
    },
    {
        "content": "<p>Yeah I should have clarified that I was referring to fixed-width vectors</p>",
        "id": 237897972,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620425558
    },
    {
        "content": "<p>We could do something with vscale but it will look very different</p>",
        "id": 237898008,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620425586
    },
    {
        "content": "<p>Well yeah, I mostly mean that I think our stuff is actually in a kinda good spot for VScale stuff.</p>",
        "id": 237898177,
        "sender_full_name": "Jubilee",
        "timestamp": 1620425666
    },
    {
        "content": "<p>Generally yes, but it doesn't replace it</p>",
        "id": 237898368,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620425765
    },
    {
        "content": "<p>The vscale scatter/gather is definitely not the same as a fixed vector</p>",
        "id": 237898388,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620425788
    },
    {
        "content": "<p>well yeah.</p>",
        "id": 237898418,
        "sender_full_name": "Jubilee",
        "timestamp": 1620425810
    },
    {
        "content": "<p>Though it's similar in many ways</p>",
        "id": 237898425,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620425815
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/SIMD.20Pointers/near/237897972\">said</a>:</p>\n<blockquote>\n<p>Yeah I should have clarified that I was referring to fixed-width vectors</p>\n</blockquote>\n<p>I think we probably can get SVE to work with fixed-length vectors, LLVM currently gets RVV to work with fixed-length vectors (if you pass the flag allowing it to assume RVV supports at least 128-bit vectors): <a href=\"https://llvm.godbolt.org/z/WejPcoxro\">https://llvm.godbolt.org/z/WejPcoxro</a></p>",
        "id": 237898529,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1620425888
    },
    {
        "content": "<p>My point was more that if you're using for example f32x4 most architectures don't have scatter/gather anyway</p>",
        "id": 237898546,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620425902
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"229517\">@Jacob Lifshay</span> how would that work without multiversioning?</p>",
        "id": 237898600,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620425947
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/SIMD.20Pointers/near/237898600\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"229517\">Jacob Lifshay</span> how would that work without multiversioning?</p>\n</blockquote>\n<p>just like enabling AVX2 works without multiversioning -- the code just assumes the vectors are long enough and crashes if they aren't</p>",
        "id": 237898708,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1620426006
    },
    {
        "content": "<p>Or is it assuming the vscale is 1</p>",
        "id": 237898715,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620426010
    },
    {
        "content": "<p>Oh, so it is multiversioning, but you can specify a specific vscale as a \"feature\"?</p>",
        "id": 237898804,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620426073
    },
    {
        "content": "<p>In that case I'm more excited for SVE.</p>",
        "id": 237898830,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620426098
    },
    {
        "content": "<p>yeah iirc (though that's not all implemented for SVE yet)</p>",
        "id": 237898838,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1620426103
    },
    {
        "content": "<p>So you might have say sve1, sve2, sve4 or whatever you want to call them</p>",
        "id": 237898911,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620426131
    },
    {
        "content": "<p>for RVV you just pass <code>-riscv-v-vector-bits-min=128</code> to llvm</p>",
        "id": 237898936,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1620426144
    },
    {
        "content": "<p>Hmm interesting.</p>",
        "id": 237898970,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620426178
    },
    {
        "content": "<p>yeah, kinda...now that I look, llvm ir has a function annotation <code>vscale_range(min, [max])</code> which tells llvm it can assume <code>vscale</code> is in that range</p>",
        "id": 237899049,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1620426238
    },
    {
        "content": "<p>So might take some work but it could be treated effectively like a target feature</p>",
        "id": 237899157,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620426293
    },
    {
        "content": "<p>yup!</p>",
        "id": 237899172,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1620426303
    },
    {
        "content": "<p>Yeah, basically it seems to me that our vectors can exploit dynamic lengths, basically, in spite of having a static size. And SVE implies Neon, so you definitely have at least 128 bits on Arm.</p>",
        "id": 237899244,
        "sender_full_name": "Jubilee",
        "timestamp": 1620426350
    },
    {
        "content": "<p>That's definitely interesting</p>",
        "id": 237899255,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620426360
    },
    {
        "content": "<p>I think we probably want dynamic vectors, too (which on static platforms would just be the native size, I think)</p>",
        "id": 237899320,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620426385
    },
    {
        "content": "<p>But generally I think static vectors are more useful</p>",
        "id": 237899345,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620426405
    },
    {
        "content": "<p>Yeah, that can be figured out as things go along.<br>\nI think having static but architecture-neutral sizes is the Right Choice.</p>",
        "id": 237899390,
        "sender_full_name": "Jubilee",
        "timestamp": 1620426443
    },
    {
        "content": "<p>Hi!  I was looking at <code>core_simd</code>, as I'm trying to vectorize some parts of <code>uu_factor</code>, but I cannot find any documentation on how to use that library.  There's <a href=\"https://rust-lang.github.io/stdsimd/core_simd\">the reference docs</a> but it doesn't really help  &gt;_&gt;'</p>\n<p>In particular, I'm trying to find how to do masked point-wise wrapping multiplications (against a single scalar) and comparisons, combining masks with logical operators, etc.</p>",
        "id": 238039336,
        "sender_full_name": "nicoo",
        "timestamp": 1620570457
    },
    {
        "content": "<p>The docs on <code>docs.rs</code> are for an old unrelated library, not for the current stdsimd as found in <a href=\"https://github.com/rust-lang/stdsimd\">https://github.com/rust-lang/stdsimd</a>.</p>",
        "id": 238039407,
        "sender_full_name": "bjorn3",
        "timestamp": 1620570508
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/SIMD.20Pointers/near/238039407\">said</a>:</p>\n<blockquote>\n<p>The docs on <code>docs.rs</code> are for an old unrelated library</p>\n</blockquote>\n<p>Oops, sorry, I was looking at <a href=\"https://rust-lang.github.io/stdsimd/core_simd\">https://rust-lang.github.io/stdsimd/core_simd</a></p>",
        "id": 238039447,
        "sender_full_name": "nicoo",
        "timestamp": 1620570583
    },
    {
        "content": "<p>Wrapping multiplication is implemented with the plain <code>*</code> operator. To do anything masked you need to use the <code>select</code> function</p>",
        "id": 238039569,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620570680
    },
    {
        "content": "<p>Thanks!  Where is <code>select</code> documented?  I saw the <code>Select</code> trait but nothing about the actual method</p>",
        "id": 238039640,
        "sender_full_name": "nicoo",
        "timestamp": 1620570750
    },
    {
        "content": "<p>It's a method on all masks, you use it like <code>mask.select(true_values, false_values)</code></p>",
        "id": 238039697,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620570796
    }
]