[
    {
        "content": "<p>Hello! In ~141 minutes. Please feel free to add whatever, etc.!<br>\n<a href=\"https://hackmd.io/sNJHu0kXSe6s-PY8ymi95Q?both\">https://hackmd.io/sNJHu0kXSe6s-PY8ymi95Q?both</a></p>",
        "id": 270081947,
        "sender_full_name": "Jubilee",
        "timestamp": 1643654329
    },
    {
        "content": "<p>I added a considerable amount of background detail that leapt to mind. ^^;</p>",
        "id": 270099263,
        "sender_full_name": "Jubilee",
        "timestamp": 1643660698
    },
    {
        "content": "<p>it's not that ieee transcendental functions don't specify down to the last bit, but that common implementations aren't accurate to the last bit. there are implementations that are 100% rounded correctly down to the last bit: crlibm, mpfr, and a few others</p>",
        "id": 270100435,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643661238
    },
    {
        "content": "<p>sqrt in particular is commonly accurate to the last bit because it's commonly a hw instruction and hw has to be accurate to the last bit to claim ieee 754 compliance</p>",
        "id": 270100619,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643661320
    },
    {
        "content": "<p>I thought efficient ½ULP implementations for the complicated stuff were still open problems?  (Though <code>sqrt</code> is not one of those, as it's strictly monotonic increasing and differentiable and such.)</p>",
        "id": 270104772,
        "sender_full_name": "scottmcm",
        "timestamp": 1643663211
    },
    {
        "content": "<p>Also hello!</p>",
        "id": 270104831,
        "sender_full_name": "Jubilee",
        "timestamp": 1643663237
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/Meeting.202022-01-31/near/270104772\">said</a>:</p>\n<blockquote>\n<p>I thought efficient ½ULP implementations for the complicated stuff were still open problems?  (Though <code>sqrt</code> is not one of those, as it's strictly monotonic increasing and differentiable and such.)</p>\n</blockquote>\n<p>I think the implementations in question are not \"efficient\".</p>",
        "id": 270105045,
        "sender_full_name": "Jubilee",
        "timestamp": 1643663308
    },
    {
        "content": "<p>So yes.<br>\nI just pushed most of my remarks on The Libm Story and the latest sync PR into the agenda directly. I am just waiting on review for it and...<br>\n...oh, Mark left a comment!</p>",
        "id": 270106799,
        "sender_full_name": "Jubilee",
        "timestamp": 1643664031
    },
    {
        "content": "<p>Oh okay that is getting merged then! huzzah.</p>",
        "id": 270107228,
        "sender_full_name": "Jubilee",
        "timestamp": 1643664226
    },
    {
        "content": "<p>There is the question of re-adding autosplats, we received a request to do so specifically for Shl and Shr, that just requires someone to knuckle up and commit to doing the work and making sure we don't break anything. I believe we were inclined to add them but without the auto-deref versions?</p>",
        "id": 270108106,
        "sender_full_name": "Jubilee",
        "timestamp": 1643664585
    },
    {
        "content": "<p>Should we incrementally add things like, e.g., Shl/Shr in a batch?</p>",
        "id": 270108313,
        "sender_full_name": "Jubilee",
        "timestamp": 1643664668
    },
    {
        "content": "<p>The argument for them with Shl/Shr was about optimization, though, and that change wouldn't actually affect optimization</p>",
        "id": 270108379,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1643664707
    },
    {
        "content": "<p>Yeah, I think the only reason to do so for Shl/Shr is to make it easier for users to \"do the right thing\".</p>",
        "id": 270108475,
        "sender_full_name": "Jubilee",
        "timestamp": 1643664739
    },
    {
        "content": "<p>IMO there are definitely some cases where you need to shift by varying amounts by lane, and that's definitely not inefficient because at worst it's blending per lane</p>",
        "id": 270108596,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1643664789
    },
    {
        "content": "<p>Oh yes.</p>",
        "id": 270108657,
        "sender_full_name": "Jubilee",
        "timestamp": 1643664823
    },
    {
        "content": "<p>It's not <strong>bad</strong>, it's just if you want to shift by a scalar for each lane, you ideally actually just write that and then you don't risk somehow putting the variable in a way that perturbs the butterfly wing next to LLVM's optimization patterns.</p>",
        "id": 270108838,
        "sender_full_name": "Jubilee",
        "timestamp": 1643664899
    },
    {
        "content": "<p>But, I think I am hearing a lack of enthusiasm for incrementalism. :^)<br>\nwell, insofar as I am hearing...? reading...?</p>",
        "id": 270108906,
        "sender_full_name": "Jubilee",
        "timestamp": 1643664937
    },
    {
        "content": "<p>I don't think shifts are special in that regard, so I think we should be consistent and either have all or none</p>",
        "id": 270109001,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1643664964
    },
    {
        "content": "<p>tru.</p>",
        "id": 270109064,
        "sender_full_name": "Jubilee",
        "timestamp": 1643664991
    },
    {
        "content": "<p>We're still aiming for adding the \"normal\" (not auto-deref-ing) versions, yeah?</p>",
        "id": 270109134,
        "sender_full_name": "Jubilee",
        "timestamp": 1643665025
    },
    {
        "content": "<p>Can you remind me what you mean be that?</p>",
        "id": 270109180,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1643665047
    },
    {
        "content": "<p>oh, the ambiguity only came up in the case of &amp;T $op &amp;U, where it wasn't clear if &amp;U was &amp;T.</p>",
        "id": 270109225,
        "sender_full_name": "Jubilee",
        "timestamp": 1643665080
    },
    {
        "content": "<p>so the idea would be to only impl T $op U.</p>",
        "id": 270109312,
        "sender_full_name": "Jubilee",
        "timestamp": 1643665109
    },
    {
        "content": "<p>I'm still confused--aren't those the same?</p>",
        "id": 270109378,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1643665145
    },
    {
        "content": "<p>Ah</p>",
        "id": 270109383,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1643665149
    },
    {
        "content": "<p>cough.</p>",
        "id": 270109387,
        "sender_full_name": "Jubilee",
        "timestamp": 1643665150
    },
    {
        "content": "<p>I'm not sure it's worth doing that, at that point I would consider skipping references entirely since the vectors are copy anyway</p>",
        "id": 270109471,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1643665187
    },
    {
        "content": "<p>Ah, so removing &amp;T $op &amp;T impls for vectors period?</p>",
        "id": 270109638,
        "sender_full_name": "Jubilee",
        "timestamp": 1643665245
    },
    {
        "content": "<p>I personally don't have a strong opinion other than I only want it if it's consistent across all operations, and commutitive</p>",
        "id": 270109671,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1643665267
    },
    {
        "content": "<p>But that might be one way, yeah</p>",
        "id": 270109688,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1643665273
    },
    {
        "content": "<p>Alrighty~!</p>",
        "id": 270109696,
        "sender_full_name": "Jubilee",
        "timestamp": 1643665276
    },
    {
        "content": "<p>I think auto-splatting is v important considering ideally deref is one <code>*</code>.</p>",
        "id": 270109846,
        "sender_full_name": "Jubilee",
        "timestamp": 1643665324
    },
    {
        "content": "<p>imho &amp;T $op &amp;U is a little too \"magical\" for my taste...just let rust add autoderef to the operators rather than relying on $Op&lt;&amp;U&gt; for &amp;T impls</p>",
        "id": 270109899,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643665355
    },
    {
        "content": "<p>what do we feel about <code>T $op &amp;T</code>?</p>",
        "id": 270110037,
        "sender_full_name": "Jubilee",
        "timestamp": 1643665440
    },
    {
        "content": "<p>Not sure, but I would probably just skip references entirely</p>",
        "id": 270110163,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1643665494
    },
    {
        "content": "<p>kk~</p>",
        "id": 270110174,
        "sender_full_name": "Jubilee",
        "timestamp": 1643665499
    },
    {
        "content": "<p>Being copy I assume it hardly makes a difference</p>",
        "id": 270110217,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1643665515
    },
    {
        "content": "<p>yeah, this is mostly about ~ergonomics~</p>",
        "id": 270110280,
        "sender_full_name": "Jubilee",
        "timestamp": 1643665555
    },
    {
        "content": "<p>well...i'd say we shouldn't encourage references to vectors...passing by copy is often faster</p>",
        "id": 270110435,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643665616
    },
    {
        "content": "<p>so a slight ergonomic hit is fine</p>",
        "id": 270110493,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643665642
    },
    {
        "content": "<p>I will take a shot at mangling the autosplats back into existence and see what I discover.<br>\nanyone have time for reviewing  <a href=\"https://github.com/rust-lang/portable-simd/pull/203\">https://github.com/rust-lang/portable-simd/pull/203</a> ?</p>",
        "id": 270110876,
        "sender_full_name": "Jubilee",
        "timestamp": 1643665822
    },
    {
        "content": "<p>reviewed</p>",
        "id": 270111422,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643666092
    },
    {
        "content": "<p>ah!</p>",
        "id": 270111443,
        "sender_full_name": "Jubilee",
        "timestamp": 1643666107
    },
    {
        "content": "<p>Thank you!</p>",
        "id": 270111500,
        "sender_full_name": "Jubilee",
        "timestamp": 1643666142
    },
    {
        "content": "<p>Annnd probably last thinger for today: right now we implemented <code>fn cast</code>, do we have any strong sentiment on whether we would want to split that into functions for specifically the float ops versus the bitcasts?</p>",
        "id": 270111669,
        "sender_full_name": "Jubilee",
        "timestamp": 1643666222
    },
    {
        "content": "<p>imho <code>cast</code> is <em>all</em> about value conversions, just some of those happen to also be bitcasts. we should rely on safe transmute for bitcasts</p>",
        "id": 270111856,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643666307
    },
    {
        "content": "<p>so we shouldn't just split out <code>i32</code>-&gt;<code>u32</code> and claim that it is somehow more bitcast-y than what it actually is: a modular integer value-preserving conversion</p>",
        "id": 270112060,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643666402
    },
    {
        "content": "<p>heheh.</p>",
        "id": 270112175,
        "sender_full_name": "Jubilee",
        "timestamp": 1643666422
    },
    {
        "content": "<p>Agreed that for now it's basically just an overloaded function, it's never just reinterpreting bits</p>",
        "id": 270112468,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1643666523
    },
    {
        "content": "<p>I suppose, but most people don't look at i32/u32 and see ℤ/2³²ℤ.</p>",
        "id": 270112531,
        "sender_full_name": "Jubilee",
        "timestamp": 1643666554
    },
    {
        "content": "<p>:3</p>",
        "id": 270112578,
        "sender_full_name": "Jubilee",
        "timestamp": 1643666573
    },
    {
        "content": "<p>They probably should, but...!</p>",
        "id": 270112630,
        "sender_full_name": "Jubilee",
        "timestamp": 1643666600
    },
    {
        "content": "<p>well...wrapping integers are modular integers.</p>",
        "id": 270112681,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643666615
    },
    {
        "content": "<p>if they don't think so, tell them otherwise. :)</p>",
        "id": 270112745,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643666643
    },
    {
        "content": "<p><code>iN/uN</code> -&gt; <code>iM/uM</code> is always picking the unique value of <code>iM/uM</code> that is in the same modular equivalence class as the integer value of the source.</p>",
        "id": 270113170,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643666844
    },
    {
        "content": "<p>And wheeeeeeee thank you for <del>playing</del> coming!</p>",
        "id": 270113201,
        "sender_full_name": "Jubilee",
        "timestamp": 1643666865
    },
    {
        "content": "<p>Right.</p>",
        "id": 270113227,
        "sender_full_name": "Jubilee",
        "timestamp": 1643666877
    },
    {
        "content": "<p>now, if the integers were saturating or trapping on overflow, that'd be different.</p>",
        "id": 270113503,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643666987
    },
    {
        "content": "<p>We can get to the other questions later~ I need to do... an entire pile of work.<br>\nHave a good day~!</p>",
        "id": 270113834,
        "sender_full_name": "Jubilee",
        "timestamp": 1643667118
    },
    {
        "content": "<p>Shifts already take arbitrary RHS types for scalars, so hopefully adding autosplatting just for shift wouldn't create any new inference issues.</p>",
        "id": 270126051,
        "sender_full_name": "scottmcm",
        "timestamp": 1643672718
    }
]