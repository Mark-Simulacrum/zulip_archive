[
    {
        "content": "<p>At the moment, we don't actually have anything that allows for partially initialized vectors without them being immediately UB. Nonetheless, it's not implausible for us to consider them, and <code>Simd&lt;MaybeUninit&lt;u8&gt;, N&gt;</code> actually raises a lot <strong>less</strong> questions than other extensions. It also is important to define what is UB so that e.g. Miri can actually detect it if we do mess it up, and also what could be safely done on e.g. a <code>MaybeUninit&lt;Simd&lt;u8, N&gt;&gt;</code> which one can definitely already write today, and \"when can I read <code>[MaybeUninit&lt;T&gt;; N]</code> into <code>Simd&lt;T, N&gt;</code>?\"</p>",
        "id": 273757952,
        "sender_full_name": "Jubilee",
        "timestamp": 1646198862
    },
    {
        "content": "<p>This also matters to the intrinsics we are using, as e.g. we basically just decided \"it's UB to use <code>simd_bitmask</code> on a vector of values that aren't <code>simd::true</code> and <code>simd::false</code>.\" <a href=\"https://github.com/rust-lang/portable-simd/pull/250\">https://github.com/rust-lang/portable-simd/pull/250</a></p>",
        "id": 273758222,
        "sender_full_name": "Jubilee",
        "timestamp": 1646199071
    },
    {
        "content": "<p>imho we definitely need <code>Simd&lt;MaybeUninit&lt;T&gt;, N&gt;</code></p>",
        "id": 273758242,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1646199106
    },
    {
        "content": "<p>maybe also <code>MaybeUninitMask&lt;...&gt;</code> since we assume <code>Mask</code> is fully initialized/valid</p>",
        "id": 273758331,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1646199216
    },
    {
        "content": "<p>Selecting on a Mask atm generally needs to be on an initialized mask, yes, or it risks exploding the operation in Rust terms, and a Mask will usually explode if you try to leave it uninit, so it can only <strong>really</strong> be fully init or fully maybeuninit, yes.</p>",
        "id": 273758502,
        "sender_full_name": "Jubilee",
        "timestamp": 1646199394
    },
    {
        "content": "<p>well...llvm supports uninit lanes in a bit vector</p>",
        "id": 273758539,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1646199439
    },
    {
        "content": "<p>yes but I don't think Rust does. :^)</p>",
        "id": 273758558,
        "sender_full_name": "Jubilee",
        "timestamp": 1646199461
    },
    {
        "content": "<p>Yeah, we store it as an integer...</p>",
        "id": 273758573,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1646199474
    },
    {
        "content": "<p>And currently we're leaning hard away from \"partially init bytes\".</p>",
        "id": 273758636,
        "sender_full_name": "Jubilee",
        "timestamp": 1646199509
    },
    {
        "content": "<p>However, I should say:<br>\nI don't think that has to mean we aren't allowed to ever have a Mask that is ambiguously initialized on a bit by bit basis, it just means it has to be a bit weirder than a \"standard\" integer.</p>",
        "id": 273758721,
        "sender_full_name": "Jubilee",
        "timestamp": 1646199574
    },
    {
        "content": "<p>well...<code>MaybeUninitMask</code> is the compiler magic way to support uninit lanes in a bit vector. i'd expect that there will be optimizations that can only be done by llvm if some lanes are uninit</p>",
        "id": 273758738,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1646199586
    },
    {
        "content": "<p>Yeah, in rust an integer cannot be partially-uninit.</p>\n<p><code>MaybeUninit&lt;integer&gt;</code> being partial is ok, but apparently MIRI doesn't actually implement that right now, which I learned in <a href=\"https://github.com/rust-lang/rust/issues/94371\">https://github.com/rust-lang/rust/issues/94371</a></p>",
        "id": 273758754,
        "sender_full_name": "scottmcm",
        "timestamp": 1646199599
    },
    {
        "content": "<p>Oh right, we can MaybeUninit the whole integer, didn't even think of that</p>",
        "id": 273758834,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1646199641
    },
    {
        "content": "<p>yes.</p>",
        "id": 273758863,
        "sender_full_name": "Jubilee",
        "timestamp": 1646199671
    },
    {
        "content": "<p>I'd be curious what the LLVM rules even are these days -- integers used to be partially-uninit-safe, but now that more things are <code>poison</code> instead I don't really know how things work with that.</p>",
        "id": 273758870,
        "sender_full_name": "scottmcm",
        "timestamp": 1646199684
    },
    {
        "content": "<p>probably:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">MaybeUninitBitMask</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">MaybeUninit</span><span class=\"o\">&lt;</span><span class=\"n\">uint</span><span class=\"o\">&lt;</span><span class=\"n\">N</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 273758871,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1646199686
    },
    {
        "content": "<p>yeah that looks about right.</p>",
        "id": 273758878,
        "sender_full_name": "Jubilee",
        "timestamp": 1646199699
    },
    {
        "content": "<p>Very optimistic throwing the generic int around lol</p>",
        "id": 273758882,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1646199710
    },
    {
        "content": "<p>In general I think functionally for most purposes we should think of any kind of Mask type and any kind of Simd type as being cousins rather than siblings, in terms of types. It's fine if Masks behave more weirdly by comparison. They either have an invariant that normal integers don't have to maintain or they have a much different relationship to size.</p>",
        "id": 273759043,
        "sender_full_name": "Jubilee",
        "timestamp": 1646199885
    }
]