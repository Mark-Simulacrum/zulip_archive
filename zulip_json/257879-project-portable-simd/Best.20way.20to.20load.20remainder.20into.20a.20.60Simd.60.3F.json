[
    {
        "content": "<p>I was making <a href=\"https://github.com/rust-lang/portable-simd/pull/128/files#r835809892\">a dot product example</a>, and the hardest part was actually loading the remainder efficiently.</p>\n<p>I first tried this</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">sums</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mf\">0.0</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">LANES</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">zip</span><span class=\"p\">(</span><span class=\"n\">a_extra</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b_extra</span><span class=\"p\">).</span><span class=\"n\">enumerate</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">sums</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">sums</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Simd</span>::<span class=\"n\">from_array</span><span class=\"p\">(</span><span class=\"n\">sums</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n<p>but it's horrible, emitting an unrolled sequence of scalar multiplications &lt;<a href=\"https://rust.godbolt.org/z/z1Yre4871\">https://rust.godbolt.org/z/z1Yre4871</a>&gt;</p>\n<p>On the other hand, this one works much better:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">sums</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mf\">0.0</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">LANES</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"p\">((</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">zip</span><span class=\"p\">(</span><span class=\"n\">a_extra</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b_extra</span><span class=\"p\">).</span><span class=\"n\">zip</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">sums</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">*</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">sums</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Simd</span>::<span class=\"n\">from_array</span><span class=\"p\">(</span><span class=\"n\">sums</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n<p>emitting some complicated rearranging logic and a <code>vmulps</code> <a href=\"https://rust.godbolt.org/z/eMPEnc9or\">https://rust.godbolt.org/z/eMPEnc9or</a></p>\n<p>So in addition to <a href=\"https://doc.rust-lang.org/nightly/std/simd/struct.Simd.html#method.from_slice\">https://doc.rust-lang.org/nightly/std/simd/struct.Simd.html#method.from_slice</a>, I think it would be nice to have something like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">sums</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Simd</span>::<span class=\"n\">from_slice_or</span><span class=\"p\">(</span><span class=\"n\">a_extra</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mf\">0.0</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">Simd</span>::<span class=\"n\">from_slice_or</span><span class=\"p\">(</span><span class=\"n\">b_extra</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mf\">0.0</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n<p>That does the load in whatever the best way actually is -- I assume there's some instruction I don't know about which can do it smarter.</p>",
        "id": 276745198,
        "sender_full_name": "scottmcm",
        "timestamp": 1648327996
    },
    {
        "content": "<p>I think emulating _mm256_maskload_ps is the most idiomatic solution for now. I'd do PR but no github account.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#![feature(array_chunks)]</span><span class=\"w\"></span>\n<span class=\"cp\">#![feature(portable_simd)]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">dot_prod_simd</span><span class=\"p\">(</span><span class=\"n\">a</span>: <span class=\"kp\">&amp;</span><span class=\"p\">[</span><span class=\"kt\">f32</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"n\">b</span>: <span class=\"kp\">&amp;</span><span class=\"p\">[</span><span class=\"kt\">f32</span><span class=\"p\">])</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">f32</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">simd</span>::<span class=\"n\">f32x8</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">lane</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">simd</span>::<span class=\"n\">i32x8</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">intlane</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">is_empty</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"mf\">0.0</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"w\"> </span><span class=\"n\">lane</span>::<span class=\"n\">LANES</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"cm\">/*</span>\n<span class=\"cm\">        // For simple calculation such as dot product, scalar is faster than copying inputs to use simd.</span>\n<span class=\"cm\">        let mut smol_a = [0.0; lane::LANES];</span>\n<span class=\"cm\">        smol_a[..a.len()].copy_from_slice(a);</span>\n<span class=\"cm\">        let mut smol_b = [0.0; lane::LANES];</span>\n<span class=\"cm\">        smol_b[..b.len()].copy_from_slice(b);</span>\n\n<span class=\"cm\">        let sums = lane::from_array(smol_a) * lane::from_array(smol_b);</span>\n<span class=\"cm\">        return sums.reduce_sum();</span>\n<span class=\"cm\">        */</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// Use scalar instead:</span>\n<span class=\"w\">        </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">iter</span><span class=\"p\">().</span><span class=\"n\">zip</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">.</span><span class=\"n\">iter</span><span class=\"p\">()).</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"n\">b</span><span class=\"p\">)</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">).</span><span class=\"n\">sum</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">sums</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">array_chunks</span>::<span class=\"o\">&lt;</span><span class=\"p\">{</span><span class=\"n\">lane</span>::<span class=\"n\">LANES</span><span class=\"p\">}</span><span class=\"o\">&gt;</span><span class=\"p\">().</span><span class=\"n\">zip</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">.</span><span class=\"n\">array_chunks</span>::<span class=\"o\">&lt;</span><span class=\"p\">{</span><span class=\"n\">lane</span>::<span class=\"n\">LANES</span><span class=\"p\">}</span><span class=\"o\">&gt;</span><span class=\"p\">()).</span><span class=\"n\">fold</span><span class=\"p\">(</span><span class=\"n\">std</span>::<span class=\"n\">simd</span>::<span class=\"n\">Simd</span>::<span class=\"n\">from_array</span><span class=\"p\">([</span><span class=\"mf\">0.0</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">lane</span>::<span class=\"n\">LANES</span><span class=\"p\">]),</span><span class=\"o\">|</span><span class=\"n\">sums</span><span class=\"p\">,(</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"n\">b</span><span class=\"p\">)</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">lane</span>::<span class=\"n\">from_array</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">a</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">lane</span>::<span class=\"n\">from_array</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">b</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">sums</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">});</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">remaining</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"w\"> </span><span class=\"n\">lane</span>::<span class=\"n\">LANES</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"c1\">// When inputs are guaranteed to contain at least one chunk, emulate a masked load.</span>\n<span class=\"w\">    </span><span class=\"c1\">// sum += 0*0 sounds redundant but avoids nasty branches :)</span>\n<span class=\"w\">    </span><span class=\"c1\">// Perform unaligned load from end, and mask it.</span>\n\n<span class=\"w\">    </span><span class=\"c1\">// If remaining &gt; mask[i], retain that value</span>\n<span class=\"w\">    </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">MASK_GT</span>: <span class=\"nc\">intlane</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">temp</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">intlane</span>::<span class=\"n\">LANES</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">temp</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">loop</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">temp</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">-=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">temp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"k\">break</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// [7, 6, 5, 4, 3, 2, 1, 0]</span>\n<span class=\"w\">        </span><span class=\"n\">intlane</span>::<span class=\"n\">from_array</span><span class=\"p\">(</span><span class=\"n\">temp</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">mask</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">intlane</span>::<span class=\"n\">splat</span><span class=\"p\">(</span><span class=\"n\">remaining</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">).</span><span class=\"n\">lanes_gt</span><span class=\"p\">(</span><span class=\"n\">MASK_GT</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"c1\">// Emulate _mm256_maskload_ps</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">remainder_a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">lane</span>::<span class=\"n\">from_slice</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">()</span><span class=\"o\">-</span><span class=\"n\">lane</span>::<span class=\"n\">LANES</span><span class=\"o\">..</span><span class=\"p\">).</span><span class=\"n\">expect</span><span class=\"p\">(</span><span class=\"s\">\"Remainder\"</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">remainder_b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">lane</span>::<span class=\"n\">from_slice</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">()</span><span class=\"o\">-</span><span class=\"n\">lane</span>::<span class=\"n\">LANES</span><span class=\"o\">..</span><span class=\"p\">).</span><span class=\"n\">expect</span><span class=\"p\">(</span><span class=\"s\">\"Remainder\"</span><span class=\"p\">));</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"c1\">// Transmute to bits</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">remainder_a</span>: <span class=\"nc\">intlane</span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">transmute</span><span class=\"p\">(</span><span class=\"n\">remainder_a</span><span class=\"p\">)};</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">remainder_b</span>: <span class=\"nc\">intlane</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">transmute</span><span class=\"p\">(</span><span class=\"n\">remainder_b</span><span class=\"p\">)};</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"c1\">// Turn values that do not belong to remainder into 0</span>\n<span class=\"w\">    </span><span class=\"n\">remainder_a</span><span class=\"w\"> </span><span class=\"o\">&amp;=</span><span class=\"w\"> </span><span class=\"n\">mask</span><span class=\"p\">.</span><span class=\"n\">to_int</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">remainder_b</span><span class=\"w\"> </span><span class=\"o\">&amp;=</span><span class=\"w\"> </span><span class=\"n\">mask</span><span class=\"p\">.</span><span class=\"n\">to_int</span><span class=\"p\">();</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"c1\">// Back to float</span>\n<span class=\"w\">    </span><span class=\"c1\">// SAFETY: 0u32 == 0f32, other bits remain untouched.</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">remainder_a</span>: <span class=\"nc\">lane</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">transmute</span><span class=\"p\">(</span><span class=\"n\">remainder_a</span><span class=\"p\">)};</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">remainder_b</span>: <span class=\"nc\">lane</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">transmute</span><span class=\"p\">(</span><span class=\"n\">remainder_b</span><span class=\"p\">)};</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"n\">sums</span><span class=\"w\"> </span><span class=\"o\">+=</span><span class=\"w\"> </span><span class=\"n\">remainder_a</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">remainder_b</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">sums</span><span class=\"p\">.</span><span class=\"n\">reduce_sum</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 276803126,
        "sender_full_name": "Bot+",
        "timestamp": 1648408611
    },
    {
        "content": "<p>I've hit some performance issues with masked loads in the past, another possibility is to load the entire vector with some overlap, and mask the unused elements to zero</p>",
        "id": 276803616,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1648409304
    },
    {
        "content": "<p>IIRC that happens when the masked out bits are not inside valid slice but retained bits are? So masked load is fine for remainder of a long slice but not for full short slice.</p>",
        "id": 276804113,
        "sender_full_name": "Bot+",
        "timestamp": 1648410083
    },
    {
        "content": "<p>What I mean is that the masked load instruction itself is relatively slow on some hardware</p>",
        "id": 276805111,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1648411500
    },
    {
        "content": "<p>Well after looking up instruction costs I admit you're right that VPAND (YMM, YMM, M256) is marginally faster. (I only micro-benched against fused-multiply-add but tossed it when fma lost by ~20% thanks to loop unrolling)</p>",
        "id": 276805714,
        "sender_full_name": "Bot+",
        "timestamp": 1648412385
    },
    {
        "content": "<p>do note that reading out-of-bounds and then masking off the read values still produces UB</p>",
        "id": 276805860,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1648412536
    },
    {
        "content": "<p>Yes, that is big no no unless done with a hardware gather instruction that specifically permits it.</p>",
        "id": 276806088,
        "sender_full_name": "Bot+",
        "timestamp": 1648412819
    },
    {
        "content": "<p>Hmm, the out-of-bounds part is annoying.  It means to be not <code>unsafe</code> it'd need to take the full slice and the length separately, rather than use a pre-shortened slice.</p>\n<p>Is there a good way to set <code>i..</code> in a vector to zero?  Or I guess for dot_product I don't care where they are in the vector, so shifting the lanes over <code>N - i</code> might work too, if that exists?</p>",
        "id": 276806358,
        "sender_full_name": "scottmcm",
        "timestamp": 1648413162
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"229517\">@Jacob Lifshay</span> yeah, I was more suggesting to do a read that overlaps with previous reads (doesn't help with anything less than a vector length total)</p>",
        "id": 276806836,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1648413828
    },
    {
        "content": "<blockquote>\n<p>I was more suggesting to do a read that overlaps with previous reads</p>\n</blockquote>\n<p>This is what I ended up implementing. Too bad Mask&lt;i32&gt; cannot BitAnd with Simd&lt;f32&gt;, that way I could get rid of transmutes.</p>",
        "id": 276806991,
        "sender_full_name": "Bot+",
        "timestamp": 1648414079
    },
    {
        "content": "<p>You should use <code>select</code> rather than BitAnd</p>",
        "id": 276807059,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1648414163
    },
    {
        "content": "<p>Thanks, now it's much better:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#![feature(array_chunks)]</span><span class=\"w\"></span>\n<span class=\"cp\">#![feature(portable_simd)]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">dot_prod_simd</span><span class=\"p\">(</span><span class=\"n\">a</span>: <span class=\"kp\">&amp;</span><span class=\"p\">[</span><span class=\"kt\">f32</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"n\">b</span>: <span class=\"kp\">&amp;</span><span class=\"p\">[</span><span class=\"kt\">f32</span><span class=\"p\">])</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">f32</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">simd</span>::<span class=\"n\">f32x8</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">lane</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">simd</span>::<span class=\"n\">i32x8</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">intlane</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">is_empty</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"mf\">0.0</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"w\"> </span><span class=\"n\">lane</span>::<span class=\"n\">LANES</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"cm\">/*</span>\n<span class=\"cm\">        // For simple calculation such as dot product, scalar is faster than copying inputs to use simd.</span>\n<span class=\"cm\">        let mut smol_a = [0.0; lane::LANES];</span>\n<span class=\"cm\">        smol_a[..a.len()].copy_from_slice(a);</span>\n<span class=\"cm\">        let mut smol_b = [0.0; lane::LANES];</span>\n<span class=\"cm\">        smol_b[..b.len()].copy_from_slice(b);</span>\n\n<span class=\"cm\">        let sums = lane::from_array(smol_a) * lane::from_array(smol_b);</span>\n<span class=\"cm\">        return sums.reduce_sum();</span>\n<span class=\"cm\">        */</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// Use scalar instead:</span>\n<span class=\"w\">        </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">iter</span><span class=\"p\">().</span><span class=\"n\">zip</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">.</span><span class=\"n\">iter</span><span class=\"p\">()).</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">)</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">).</span><span class=\"n\">sum</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">sums</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">.</span><span class=\"n\">array_chunks</span>::<span class=\"o\">&lt;</span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">lane</span>::<span class=\"n\">LANES</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">.</span><span class=\"n\">zip</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">.</span><span class=\"n\">array_chunks</span>::<span class=\"o\">&lt;</span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">lane</span>::<span class=\"n\">LANES</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"o\">&gt;</span><span class=\"p\">())</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">.</span><span class=\"n\">fold</span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">std</span>::<span class=\"n\">simd</span>::<span class=\"n\">Simd</span>::<span class=\"n\">from_array</span><span class=\"p\">([</span><span class=\"mf\">0.0</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">lane</span>::<span class=\"n\">LANES</span><span class=\"p\">]),</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"o\">|</span><span class=\"n\">sums</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">)</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">lane</span>::<span class=\"n\">from_array</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">a</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">lane</span>::<span class=\"n\">from_array</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">b</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"n\">sums</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">},</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">remaining</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"w\"> </span><span class=\"n\">lane</span>::<span class=\"n\">LANES</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"c1\">// When inputs are guaranteed to contain at least one chunk, emulate a masked load.</span>\n<span class=\"w\">    </span><span class=\"c1\">// sum += 0*0 sounds redundant but avoids nasty branches :)</span>\n<span class=\"w\">    </span><span class=\"c1\">// Perform unaligned load from end, and mask it.</span>\n\n<span class=\"w\">    </span><span class=\"c1\">// If remaining &gt; mask[i], retain that value</span>\n<span class=\"w\">    </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">MASK_GT</span>: <span class=\"nc\">intlane</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">temp</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">intlane</span>::<span class=\"n\">LANES</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">temp</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">loop</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">temp</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">-=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">temp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"k\">break</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// [7, 6, 5, 4, 3, 2, 1, 0]</span>\n<span class=\"w\">        </span><span class=\"n\">intlane</span>::<span class=\"n\">from_array</span><span class=\"p\">(</span><span class=\"n\">temp</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">mask</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">intlane</span>::<span class=\"n\">splat</span><span class=\"p\">(</span><span class=\"n\">remaining</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">).</span><span class=\"n\">lanes_gt</span><span class=\"p\">(</span><span class=\"n\">MASK_GT</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// Emulate _mm256_maskload_ps by reading &amp;input[input.len()-lane::LANES] and masking out already read values to 0.0.</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">remainder_a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">lane</span>::<span class=\"n\">from_slice</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"n\">lane</span>::<span class=\"n\">LANES</span><span class=\"o\">..</span><span class=\"p\">).</span><span class=\"n\">expect</span><span class=\"p\">(</span><span class=\"s\">\"Remainder\"</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">remainder_b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">lane</span>::<span class=\"n\">from_slice</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"n\">lane</span>::<span class=\"n\">LANES</span><span class=\"o\">..</span><span class=\"p\">).</span><span class=\"n\">expect</span><span class=\"p\">(</span><span class=\"s\">\"Remainder\"</span><span class=\"p\">));</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"n\">remainder_a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">mask</span><span class=\"p\">.</span><span class=\"n\">select</span><span class=\"p\">(</span><span class=\"n\">remainder_a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">lane</span>::<span class=\"n\">splat</span><span class=\"p\">(</span><span class=\"mf\">0.0</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">remainder_b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">mask</span><span class=\"p\">.</span><span class=\"n\">select</span><span class=\"p\">(</span><span class=\"n\">remainder_b</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">lane</span>::<span class=\"n\">splat</span><span class=\"p\">(</span><span class=\"mf\">0.0</span><span class=\"p\">));</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"n\">sums</span><span class=\"w\"> </span><span class=\"o\">+=</span><span class=\"w\"> </span><span class=\"n\">remainder_a</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">remainder_b</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">sums</span><span class=\"p\">.</span><span class=\"n\">reduce_sum</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>I'd still prefer <code>input &amp;= mask</code> to <code>input = mask.select(input, lane::splat(0.0));</code> though.</p>",
        "id": 276807975,
        "sender_full_name": "Bot+",
        "timestamp": 1648415347
    }
]