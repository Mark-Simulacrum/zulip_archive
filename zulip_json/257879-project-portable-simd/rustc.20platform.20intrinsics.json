[
    {
        "content": "<p>Whats the process if i want to add a platform intrinsic such as <a href=\"https://llvm.org/docs/LangRef.html#llvm-umax-intrinsic\"><code>umax/smax</code></a> to rustc? To implement min and max for non-float vectors</p>",
        "id": 236937888,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619844867
    },
    {
        "content": "<p>i found the intrinsics file, would it be something like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">simd_max</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">validate_simd_type</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">fx</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">intrinsic</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">span</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">layout</span><span class=\"p\">().</span><span class=\"n\">ty</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">simd_int_binop</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">fx</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">umax</span><span class=\"o\">|</span><span class=\"n\">smax</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">ret</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>?</p>",
        "id": 236938013,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619844997
    },
    {
        "content": "<p>im assuming its not <code>simd_int_flt_binop</code> because floats have <code>fmax</code> and <code>fmin</code></p>",
        "id": 236938059,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619845061
    },
    {
        "content": "<p>Yeah, you can basically just copy what is done for other binops</p>",
        "id": 236938134,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619845122
    },
    {
        "content": "<p>alright awesome, im assuming theres tests for this somewhere, right?</p>",
        "id": 236938157,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619845149
    },
    {
        "content": "<p>There's a whole directory of simd tests for the compiler, yes</p>",
        "id": 236938170,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619845175
    },
    {
        "content": "<p>I forget where exactly</p>",
        "id": 236938176,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619845188
    },
    {
        "content": "<p>But it's in the test directory</p>",
        "id": 236938181,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619845198
    },
    {
        "content": "<p>ill just grep it and see</p>",
        "id": 236938182,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619845199
    },
    {
        "content": "<p>I'll PR umax/smax and umin/smin to rustc and then submit a draft relying on that to stdsimd, that sound good?</p>",
        "id": 236938317,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619845243
    },
    {
        "content": "<p>?</p>",
        "id": 236942995,
        "sender_full_name": "Jubilee",
        "timestamp": 1619850220
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276242\">Riccardo D'Ambrosio</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/rustc.20platform.20intrinsics/near/236938317\">said</a>:</p>\n<blockquote>\n<p>I'll PR umax/smax and umin/smin to rustc and then submit a draft relying on that to stdsimd, that sound good?</p>\n</blockquote>\n<p>Is this for vector or vector reduce?</p>",
        "id": 236943061,
        "sender_full_name": "Jubilee",
        "timestamp": 1619850278
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span> for vector, to add min and max for int vectors too, instead of just float vectors with fmin and fmax</p>",
        "id": 236989490,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619894024
    },
    {
        "content": "<p>Yeah, <span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span> not reduction. Just normal min/max</p>",
        "id": 236989589,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619894094
    },
    {
        "content": "<p>this intrinsic here <a href=\"https://llvm.org/docs/LangRef.html#llvm-umax-intrinsic\">https://llvm.org/docs/LangRef.html#llvm-umax-intrinsic</a></p>",
        "id": 236989598,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619894106
    },
    {
        "content": "<p>It could be implemented with select but might as well use the intrinsic</p>",
        "id": 236989603,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619894113
    },
    {
        "content": "<p>as well as the smax and smin equivalents</p>",
        "id": 236989621,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619894128
    },
    {
        "content": "<p>Im not sure what tests i should add when i PR this, are the kind of tests you added with <a href=\"https://github.com/rust-lang/rust/commit/003b8eadd7a476c51956fe447894532d6e21937e\">simd_floor and others</a> enough?</p>",
        "id": 236989697,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619894196
    },
    {
        "content": "<p>should also probably document these intrinsics somewhere <span aria-label=\"stuck out tongue\" class=\"emoji emoji-1f61b\" role=\"img\" title=\"stuck out tongue\">:stuck_out_tongue:</span></p>",
        "id": 236989705,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619894221
    },
    {
        "content": "<p>esepcially since they don't show up in <code>std::intrinsics</code>, probably for a good reason i don't know about</p>",
        "id": 236989738,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619894263
    },
    {
        "content": "<p>Yeah, I think you can mirror tests like those</p>",
        "id": 236989792,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619894287
    },
    {
        "content": "<p>Will platform intrinsics eventually show up in docs somewhere or are they permanently cryptic?</p>",
        "id": 236989919,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619894426
    },
    {
        "content": "<p>Likely no doc</p>",
        "id": 236990061,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619894569
    },
    {
        "content": "<p>The intention is for them to only be consumed by the standard library</p>",
        "id": 236990067,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619894581
    },
    {
        "content": "<p>They probably could be exposed in <code>std::intrinsics</code> but it's not really necessary</p>",
        "id": 236990150,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619894652
    },
    {
        "content": "<p>i think it wouldnt hurt to have an unstable way to call them raw just like normal intrinsics and to document them</p>",
        "id": 236990241,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619894753
    },
    {
        "content": "<p>Definitely a possibility</p>",
        "id": 236990448,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619894893
    },
    {
        "content": "<p>The downside is that adding a new intrinsic becomes both a compiler and library change</p>",
        "id": 236990464,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619894914
    },
    {
        "content": "<p>Not a big problem, just something to consider</p>",
        "id": 236990485,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619894939
    },
    {
        "content": "<p>well, it still kind of is, since adding an intrinsic usually is for adding a function to core simd</p>",
        "id": 236990488,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619894942
    },
    {
        "content": "<p>i think exposing an intrinsic then not using it in the library would be kind of useless dont you think?</p>",
        "id": 236990504,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619894965
    },
    {
        "content": "<p>Yep, true</p>",
        "id": 236990510,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619894973
    },
    {
        "content": "<p>How would this work? just expose the intrinsics module in coresimd?</p>",
        "id": 236990820,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619895296
    },
    {
        "content": "<p>Actually, would it make sense to remove <code>fmin</code> and <code>fmax</code> and merge <code>umin, smin, and fmin</code> into just <code>min</code>? i dont see why they should be separate when add, sub, etc are unified</p>",
        "id": 236992166,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619896686
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span> is there a reason that simd_fmin and simd_fmax are separate and not generalized in cranelift and others? do they have weird semantics that can't be transfered to a generic function?</p>",
        "id": 236993706,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619898366
    },
    {
        "content": "<p>I have no idea. They were introduced way before cg_clif was a thing.</p>",
        "id": 236993727,
        "sender_full_name": "bjorn3",
        "timestamp": 1619898394
    },
    {
        "content": "<p>ah ok, sorry to bother <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span></p>",
        "id": 236993752,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619898436
    },
    {
        "content": "<p>i saw you said on another PR to set you as a reviewer over petrochenkov if its small, is that still the case?</p>",
        "id": 236993798,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619898474
    },
    {
        "content": "<p>I believe it was petrochenkov who said that. I am personally fine with reviewing small changes.</p>",
        "id": 236993867,
        "sender_full_name": "bjorn3",
        "timestamp": 1619898517
    },
    {
        "content": "<p>alright <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 236993879,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619898545
    },
    {
        "content": "<p>They are separate in libc. Not sure if that's a satisfying answer, but likely why</p>",
        "id": 236993900,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619898575
    },
    {
        "content": "<p>yeah they're called <code>maxnum</code> and <code>minnum</code>, not <code>fmax</code> and <code>fmin</code> in llvm</p>",
        "id": 236993965,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619898621
    },
    {
        "content": "<p>although i dont think it should matter what they codegen to if they do the same thing</p>",
        "id": 236993981,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619898640
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276242\">Riccardo D'Ambrosio</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/rustc.20platform.20intrinsics/near/236990241\">said</a>:</p>\n<blockquote>\n<p>i think it wouldnt hurt to have an unstable way to call them raw just like normal intrinsics and to document them</p>\n</blockquote>\n<p>There already is, effectively.</p>",
        "id": 236995648,
        "sender_full_name": "Jubilee",
        "timestamp": 1619900349
    },
    {
        "content": "<p>right, but its really hard to find what intrinsics actually exist since its not documented anywhere</p>",
        "id": 236995667,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619900376
    },
    {
        "content": "<p>Well... they are not <em>really</em> meant to be used externally at the moment. Originally they were planned for an exposure to external consumers, but then that went away.</p>",
        "id": 236995726,
        "sender_full_name": "Jubilee",
        "timestamp": 1619900408
    },
    {
        "content": "<p>rustc has lots of poorly documented things that are not meant to be consumed externally.</p>",
        "id": 236995750,
        "sender_full_name": "Jubilee",
        "timestamp": 1619900433
    },
    {
        "content": "<p>that's true</p>",
        "id": 236995755,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619900440
    },
    {
        "content": "<p>This is intended to be <em>the</em> API that actually exposes them, in effect.</p>",
        "id": 236995779,
        "sender_full_name": "Jubilee",
        "timestamp": 1619900465
    },
    {
        "content": "<p>behind something actually sane and type-safe, instead of</p>",
        "id": 236995806,
        "sender_full_name": "Jubilee",
        "timestamp": 1619900483
    },
    {
        "content": "<p>the madness.</p>",
        "id": 236995808,
        "sender_full_name": "Jubilee",
        "timestamp": 1619900485
    },
    {
        "content": "<p>haha yeah</p>",
        "id": 236995811,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619900490
    },
    {
        "content": "<p>do you agree with removing fmin and fmax and generalizing it?</p>",
        "id": 236995818,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619900501
    },
    {
        "content": "<p>Uh don't remove them, just add an additional set.</p>",
        "id": 236995882,
        "sender_full_name": "Jubilee",
        "timestamp": 1619900538
    },
    {
        "content": "<p>Float min/max are more complex than they seem and there will probably be two eventually.</p>",
        "id": 236995894,
        "sender_full_name": "Jubilee",
        "timestamp": 1619900561
    },
    {
        "content": "<p>This is because there's a NaN-silencing one introduced in 2008 and then there's a NaN-propagating one specified in 2019. :D</p>",
        "id": 236995911,
        "sender_full_name": "Jubilee",
        "timestamp": 1619900584
    },
    {
        "content": "<p>yikes</p>",
        "id": 236995932,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619900610
    },
    {
        "content": "<p>the joys of float math :D</p>",
        "id": 236995936,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619900620
    },
    {
        "content": "<p>So, while it might make sense for one to be \"synonymous\" with normal min/max, uh</p>",
        "id": 236995943,
        "sender_full_name": "Jubilee",
        "timestamp": 1619900638
    },
    {
        "content": "<p>let's... think about that later.</p>",
        "id": 236995985,
        "sender_full_name": "Jubilee",
        "timestamp": 1619900645
    },
    {
        "content": "<p>so i should just add <code>simd_min</code> and <code>simd_max</code> for uint and int?</p>",
        "id": 236995990,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619900649
    },
    {
        "content": "<p>yeah.</p>",
        "id": 236995993,
        "sender_full_name": "Jubilee",
        "timestamp": 1619900652
    },
    {
        "content": "<p>alright, what kind of tests should i add? are stderr tests needed for this?</p>",
        "id": 236996017,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619900677
    },
    {
        "content": "<p>Such simple functional tests to make sure it works are fine.</p>",
        "id": 236996148,
        "sender_full_name": "Jubilee",
        "timestamp": 1619900795
    },
    {
        "content": "<p>have a test that guarantees it emits an error if it's used with a float.</p>",
        "id": 236996160,
        "sender_full_name": "Jubilee",
        "timestamp": 1619900823
    },
    {
        "content": "<p>okay, RA is formatting codegen files wrong for some reason <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 236996170,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619900832
    },
    {
        "content": "<p>stdarch and stdsimd will always be doing more extensive testing to make sure these things work.</p>",
        "id": 236996246,
        "sender_full_name": "Jubilee",
        "timestamp": 1619900901
    },
    {
        "content": "<p>yeah</p>",
        "id": 236996262,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619900921
    },
    {
        "content": "<p>what is stdarch btw? is it just <code>core::arch</code>?</p>",
        "id": 236996393,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619901081
    },
    {
        "content": "<p>yup.</p>",
        "id": 236996651,
        "sender_full_name": "Jubilee",
        "timestamp": 1619901298
    },
    {
        "content": "<p>i hope that llvm's fallback code for min/max is branchless</p>",
        "id": 236997100,
        "sender_full_name": "Lokathor",
        "timestamp": 1619901731
    },
    {
        "content": "<p>what would branchless min/max look like? <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 236997122,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619901761
    },
    {
        "content": "<p><a href=\"https://graphics.stanford.edu/~seander/bithacks.html#IntegerMinOrMax\">https://graphics.stanford.edu/~seander/bithacks.html#IntegerMinOrMax</a></p>",
        "id": 236997166,
        "sender_full_name": "Lokathor",
        "timestamp": 1619901841
    },
    {
        "content": "<p>thats pretty cursed but smart</p>",
        "id": 236997231,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619901874
    },
    {
        "content": "<p>most of the stuff on that page is \"pretty cursed, but smart\"</p>",
        "id": 236997238,
        "sender_full_name": "Lokathor",
        "timestamp": 1619901894
    },
    {
        "content": "<p>tbf all of this is cursed</p>",
        "id": 236997251,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619901904
    },
    {
        "content": "<p>Yeah, do you have enough power to rebuild rustc? It'd be useful to run the patch and see what the assembly actually looks like.</p>",
        "id": 236997546,
        "sender_full_name": "Jubilee",
        "timestamp": 1619902171
    },
    {
        "content": "<p>which patch? I can rebuild rustc in a couple minutes (from clean)</p>",
        "id": 236997686,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619902321
    },
    {
        "content": "<p>Aha, yeah. The simd_min/max one, and see what the code actually looks like without optimizations on.</p>",
        "id": 236997757,
        "sender_full_name": "Jubilee",
        "timestamp": 1619902365
    },
    {
        "content": "<p>does no-opts make it always fall back?</p>",
        "id": 236997795,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619902417
    },
    {
        "content": "<p>we're more interested in post-optimization fallbacks. it's about target features.<br>\nif you run your locally built rustc without target features on it will use whatever is baseline on your system, which is likely SSE2, which may trigger the fallback on its own. otherwise you can set RUSTFLAGS to disable SSE/SSE2.</p>",
        "id": 236998038,
        "sender_full_name": "Jubilee",
        "timestamp": 1619902672
    },
    {
        "content": "<p>Whats the flag to give it no target features? Just target-features without anything?</p>",
        "id": 236998106,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619902737
    },
    {
        "content": "<p>You can't actually disable all target features without doing some very strange things to the code rustc emits.</p>",
        "id": 236998484,
        "sender_full_name": "Jubilee",
        "timestamp": 1619902876
    },
    {
        "content": "<p>You disable a feature by passing e.g. <code>-sse</code></p>",
        "id": 236998568,
        "sender_full_name": "Jubilee",
        "timestamp": 1619902899
    },
    {
        "content": "<p>i see</p>",
        "id": 236998587,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619902904
    },
    {
        "content": "<p>passing no target features does nothing to the set of target features specified.</p>",
        "id": 236998723,
        "sender_full_name": "Jubilee",
        "timestamp": 1619902933
    },
    {
        "content": "<p>A target implies certain features on by default.</p>",
        "id": 236998753,
        "sender_full_name": "Jubilee",
        "timestamp": 1619902941
    },
    {
        "content": "<p>Is there a reason rustc doesnt compile with the “max” features it can use? Like avx2</p>",
        "id": 236998820,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619902959
    },
    {
        "content": "<p>Portability?</p>",
        "id": 236998837,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619902963
    },
    {
        "content": "<p>rustc is shipped to millions of computers worldwide.</p>",
        "id": 236998976,
        "sender_full_name": "Jubilee",
        "timestamp": 1619902994
    },
    {
        "content": "<p>Sorry i mean the binaries it makes, not rustc itself</p>",
        "id": 236999035,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619903011
    },
    {
        "content": "<p>If those were compiled with the max features available, and those were AVX512, what would that do to people with even top of the line AMD machines?</p>",
        "id": 236999045,
        "sender_full_name": "Jubilee",
        "timestamp": 1619903014
    },
    {
        "content": "<p>rustc <em>is</em> just another binary that rustc makes.</p>",
        "id": 236999089,
        "sender_full_name": "Jubilee",
        "timestamp": 1619903026
    },
    {
        "content": "<p>yeah true</p>",
        "id": 236999333,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619903100
    },
    {
        "content": "<p>Rust has no reason to believe that a binary you build on your machine will be used only for that given machine.</p>",
        "id": 236999430,
        "sender_full_name": "Jubilee",
        "timestamp": 1619903139
    },
    {
        "content": "<p>Hmm yeah, i understand, so its better to just assume no features</p>",
        "id": 236999497,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619903163
    },
    {
        "content": "<p>Is there/will there be an easy way to monomorphize simd functions with coresimd? Like make a function for avx, avx2, and avx512 and dispatch the right one dynamically</p>",
        "id": 237000207,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619903435
    },
    {
        "content": "<p>No, that is out of scope.</p>",
        "id": 237001457,
        "sender_full_name": "Jubilee",
        "timestamp": 1619903959
    },
    {
        "content": "<p>The first thing I did when I was invited to sit down here was I gathered up all the RFCs and issues from the past of Rust... and found out how terribly, incredibly long an effort it has been, and how many times it has come relatively close only to slide back.</p>\n<p>This  project group may have been formed in 2020 but the overall endeavor to get a portable SIMD API represents 6 years of labor.</p>",
        "id": 237002048,
        "sender_full_name": "Jubilee",
        "timestamp": 1619904306
    },
    {
        "content": "<p>Thus, I argue relentlessly for the sword-logic.<br>\nCut, lest we be cut.<br>\nThis endeavor has devoured better programmers than you or I.</p>",
        "id": 237002170,
        "sender_full_name": "Jubilee",
        "timestamp": 1619904409
    },
    {
        "content": "<p>haha</p>",
        "id": 237002204,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619904460
    },
    {
        "content": "<p>Good simd support is <a href=\"https://github.com/rust-lang/rust/issues/1\">#1</a> on my list of things id like rust to have, i make a ton of high performance tools, we have rayon but no good stable simd library, which hurts, which is why id like to help</p>",
        "id": 237002274,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619904508
    },
    {
        "content": "<p>Im making a fluid engine and good simd would help an absolute ton in performance</p>",
        "id": 237002314,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619904570
    },
    {
        "content": "<p>Multiversioning is the kind of thing that can be sorted out later and people already have crates for it.</p>",
        "id": 237002321,
        "sender_full_name": "Jubilee",
        "timestamp": 1619904578
    },
    {
        "content": "<p><a href=\"https://crates.io/crates/multiversion\">https://crates.io/crates/multiversion</a> some mysterious guy named Caleb made this one and it seems pretty good. :^)</p>",
        "id": 237002401,
        "sender_full_name": "Jubilee",
        "timestamp": 1619904628
    },
    {
        "content": "<p>Looks great</p>",
        "id": 237002419,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619904647
    },
    {
        "content": "<p>Yeah it can be something similar to rayon where rust provides the low level tools like thread spawning and crates build upon it</p>",
        "id": 237002446,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619904672
    },
    {
        "content": "<p>What are the major hurdles in getting simd support done? Is it making sure stuff works consistently across architectures and stuff? Or just bikeshedding an API and stuff to add?</p>",
        "id": 237002540,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619904756
    },
    {
        "content": "<p>architectural consistency, expanding the backend's capabilities, the paper-shuffling that is introducing a feature, writing the RFC, writing the guides... and oh yeah, some bikeshedding. :^)</p>",
        "id": 237002660,
        "sender_full_name": "Jubilee",
        "timestamp": 1619904847
    },
    {
        "content": "<p>ADVENTURES like finding out about the SPIRV backend, haha.</p>",
        "id": 237002703,
        "sender_full_name": "Jubilee",
        "timestamp": 1619904885
    },
    {
        "content": "<p>i suck at rustc related stuff, so id rather focus on stuff like guides and core</p>",
        "id": 237002732,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619904921
    },
    {
        "content": "<p>Mostly because i find working on the rustc codebase painful</p>",
        "id": 237002819,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619905003
    },
    {
        "content": "<p>there's a reason I like... recently did the stabilization process for a bunch of unrelated, non-SIMD features. So I could figure out how the flow actually works, y'see.</p>",
        "id": 237004599,
        "sender_full_name": "Jubilee",
        "timestamp": 1619906890
    },
    {
        "content": "<p>I just don't like working on such a gigantic codebase i dont understand that has a bunch of codebase-specific things it needs (x.py)</p>",
        "id": 237004694,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619906981
    },
    {
        "content": "<p>yeah, that's why I did all the practice runs. <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 237004751,
        "sender_full_name": "Jubilee",
        "timestamp": 1619907018
    },
    {
        "content": "<p>someone needs to know, might as well be me.</p>",
        "id": 237004754,
        "sender_full_name": "Jubilee",
        "timestamp": 1619907024
    },
    {
        "content": "<p>think ill let you figure out the painful rustc stuff then <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 237004779,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619907047
    },
    {
        "content": "<p>~</p>",
        "id": 237004782,
        "sender_full_name": "Jubilee",
        "timestamp": 1619907059
    },
    {
        "content": "<p>mostly just need to add the intrinsics to add stuff like clamp, min, max, abs, etc</p>",
        "id": 237004874,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619907128
    },
    {
        "content": "<p>clamp is not an intrinsic, mostly.</p>",
        "id": 237004937,
        "sender_full_name": "Jubilee",
        "timestamp": 1619907232
    },
    {
        "content": "<p>yeah, clamp is just min + max</p>",
        "id": 237004973,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619907244
    },
    {
        "content": "<p>not sure if any arches have specific intrinsics for it</p>",
        "id": 237004982,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619907253
    },
    {
        "content": "<p>we already have simd_fabs.</p>",
        "id": 237004988,
        "sender_full_name": "Jubilee",
        "timestamp": 1619907254
    },
    {
        "content": "<p>abs sometimes has a faster instruction, but our current version is 3 ops, it's not exactly a huge speed gain to go to 1 when it's a somewhat uncommon op.</p>",
        "id": 237005047,
        "sender_full_name": "Jubilee",
        "timestamp": 1619907328
    },
    {
        "content": "<p>should i compile a list of the intrinsics that need to be added for <a href=\"https://github.com/rust-lang/stdsimd/issues/14\">#14</a> ?</p>",
        "id": 237005069,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619907362
    },
    {
        "content": "<p>like for <a href=\"https://github.com/rust-lang/stdsimd/issues/46\">https://github.com/rust-lang/stdsimd/issues/46</a> sure</p>",
        "id": 237005134,
        "sender_full_name": "Jubilee",
        "timestamp": 1619907402
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"276242\">@Riccardo D'Ambrosio</span> If you look into <code>std</code>, you'll find that a lot of mathematical operations are implemented \"in software\", so it's fine if ours are as well. We mostly need the comparatively primitive operations.</p>",
        "id": 237005236,
        "sender_full_name": "Jubilee",
        "timestamp": 1619907497
    },
    {
        "content": "<p>as in, clamp as min + max? i think llvm will make it into one if it makes sense</p>",
        "id": 237005268,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619907548
    },
    {
        "content": "<p>abs isn't even written like ours is, it's literally a branch, because it's just assumed LLVM will optimize that.</p>",
        "id": 237005899,
        "sender_full_name": "Jubilee",
        "timestamp": 1619908130
    },
    {
        "content": "<p>is there no integer power intrinsic?</p>",
        "id": 237005931,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619908194
    },
    {
        "content": "<p>oh apparently everyone just uses <code>exp(y * log(x))</code></p>",
        "id": 237006019,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619908251
    },
    {
        "content": "<p>should this be implemented at the library level or should it codegen to this at the rustc level?</p>",
        "id": 237006041,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619908286
    },
    {
        "content": "<p>You can think of <code>core</code> as the rust-to-rust codegen layer of rustc</p>",
        "id": 237006116,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619908366
    },
    {
        "content": "<p>i see</p>",
        "id": 237006247,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619908450
    },
    {
        "content": "<p>SSE2 has a function for the reciprocal of a float, but only for 32 bit floats, and i found an odd algorithm using newton-raphson to do it for 64 bits</p>\n<div class=\"codehilite\"><pre><span></span><code> __m128 nr = _mm_rsqrt_ps( x );\n __m128 muls = _mm_mul_ps( _mm_mul_ps( x, nr ), nr );\n result = _mm_mul_ps( _mm_mul_ps( half, nr ), _mm_sub_ps( three, muls ) );\n</code></pre></div>",
        "id": 237006307,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619908535
    },
    {
        "content": "<p>i dont think llvm has an intrinsic for rcpps though, at least i cant find one</p>",
        "id": 237006380,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619908581
    },
    {
        "content": "<p>So the problem is we need to make sure it's IEEE 754</p>",
        "id": 237006400,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619908609
    },
    {
        "content": "<p>yeah <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 237006405,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619908623
    },
    {
        "content": "<p>And I'm guessing that's an approximation</p>",
        "id": 237006406,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619908624
    },
    {
        "content": "<p>yeah it is</p>",
        "id": 237006417,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619908646
    },
    {
        "content": "<p>Approximate functions is probably outside of our scope (since they apply to scalar std as well)</p>",
        "id": 237006425,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619908661
    },
    {
        "content": "<p>i believe rsqrt has 23 bits of accuracy</p>",
        "id": 237006435,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619908679
    },
    {
        "content": "<p>maybe just implement it as a simple division and hope llvm finds a way to optimize it if it can?</p>",
        "id": 237006488,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619908709
    },
    {
        "content": "<p>LLVM is extremely good at optimizing as long as you don't do something very weird</p>",
        "id": 237006500,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619908749
    },
    {
        "content": "<p>yeah, this is pretty common so i would be surprised if llvm didnt find a way to optimize it</p>",
        "id": 237006520,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619908777
    },
    {
        "content": "<p>So yeah, I'd expect it to be able to handle it ok. If it doesn't then we can go from there, but the order of priority is probably something like API and then performance generally</p>",
        "id": 237006526,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619908787
    },
    {
        "content": "<p>power is going to be really weird to implement</p>",
        "id": 237006728,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619908990
    },
    {
        "content": "<p>from what i can tell there is no straight forward way to cleanly implement it</p>",
        "id": 237006735,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619909013
    },
    {
        "content": "<p>pow for integers that is</p>",
        "id": 237006800,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619909077
    },
    {
        "content": "<p>there are ways of abusing float to int conversions to do it but that might get wrong real quick for imprecision</p>",
        "id": 237006880,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619909134
    },
    {
        "content": "<p>We absolutely cannot convert a float to an integer and then back again unless we can then verify that every single platform's floats are going to handle the conversion correctly.</p>",
        "id": 237007452,
        "sender_full_name": "Jubilee",
        "timestamp": 1619909759
    },
    {
        "content": "<p>and even then no.</p>",
        "id": 237007495,
        "sender_full_name": "Jubilee",
        "timestamp": 1619909767
    },
    {
        "content": "<p>not everyone has floating point operations.</p>",
        "id": 237007503,
        "sender_full_name": "Jubilee",
        "timestamp": 1619909780
    },
    {
        "content": "<p>yeah, then we need to find another algorithm for doing this since afaik intrinsics for it dont exist</p>",
        "id": 237007511,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619909791
    },
    {
        "content": "<p>which is wonderful <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 237007519,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619909801
    },
    {
        "content": "<p>power is not that hard.</p>",
        "id": 237007525,
        "sender_full_name": "Jubilee",
        "timestamp": 1619909816
    },
    {
        "content": "<p>you might be right, i only researched it a tiny bit</p>",
        "id": 237007566,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619909873
    },
    {
        "content": "<p>So first, we don't support negative pow, so that helps.</p>",
        "id": 237008127,
        "sender_full_name": "Jubilee",
        "timestamp": 1619910336
    },
    {
        "content": "<p>for x pow y where y = 0, we return 1</p>",
        "id": 237008189,
        "sender_full_name": "Jubilee",
        "timestamp": 1619910391
    },
    {
        "content": "<p>for x pow y where y = 1, we return x</p>",
        "id": 237008218,
        "sender_full_name": "Jubilee",
        "timestamp": 1619910432
    },
    {
        "content": "<p>for x pow y where y = 2.., we return (x * x) * etc.</p>",
        "id": 237008306,
        "sender_full_name": "Jubilee",
        "timestamp": 1619910518
    },
    {
        "content": "<p>so for xs pow ys,<br>\nstart with zs = splat(1)<br>\nset xs to 1 in all lanes where ys is 0<br>\nzs = zs mul xs<br>\nys = ys - 1<br>\nloop until end</p>",
        "id": 237008354,
        "sender_full_name": "Jubilee",
        "timestamp": 1619910552
    },
    {
        "content": "<p>i see</p>",
        "id": 237008738,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619910917
    },
    {
        "content": "<p>i wonder if llvm will optimize it into something else</p>",
        "id": 237008752,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619910936
    },
    {
        "content": "<p>If you don't think it will be very fast, then there is no particular reason to implement it. I do not know of any architectures that offer such an accelerated function.</p>",
        "id": 237008959,
        "sender_full_name": "Jubilee",
        "timestamp": 1619911196
    },
    {
        "content": "<p>i think it's fast enough, i dont think most pow operations will use a large power</p>",
        "id": 237009278,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619911472
    },
    {
        "content": "<p>but knowing llvm, it has a lot of hacks for optimizing trivial things</p>",
        "id": 237009284,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619911488
    },
    {
        "content": "<p>In fact... I can't find anything accelerating this on integers for Intel or Arm, so I am just striking it from the lists.</p>",
        "id": 237009389,
        "sender_full_name": "Jubilee",
        "timestamp": 1619911616
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"276242\">@Riccardo D'Ambrosio</span> clamp is actually a little more complicated than simple max and min when nan is involved (yay!)</p>",
        "id": 237029511,
        "sender_full_name": "Lokathor",
        "timestamp": 1619934823
    },
    {
        "content": "<p>oh of course, who doesnt love NaN!</p>",
        "id": 237029566,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619934854
    },
    {
        "content": "<p>you get to pick if you want to carry the nan up or suppress the nan</p>",
        "id": 237029627,
        "sender_full_name": "Lokathor",
        "timestamp": 1619934948
    },
    {
        "content": "<p>what do the IEEE gods say?</p>",
        "id": 237029675,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619934966
    },
    {
        "content": "<p>dunno</p>",
        "id": 237029692,
        "sender_full_name": "Lokathor",
        "timestamp": 1619934991
    },
    {
        "content": "<p>nan is yummy! :P</p>",
        "id": 237029700,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1619935004
    },
    {
        "content": "<p>honestly we probably want both styles</p>",
        "id": 237029720,
        "sender_full_name": "Lokathor",
        "timestamp": 1619935033
    },
    {
        "content": "<p>nan tastes like pain</p>",
        "id": 237029722,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619935037
    },
    {
        "content": "<p>oh wonderful, two versions of clamp <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 237029731,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619935051
    },
    {
        "content": "<p><a href=\"https://en.wikipedia.org/wiki/Naan\">https://en.wikipedia.org/wiki/Naan</a></p>",
        "id": 237029744,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1619935079
    },
    {
        "content": "<p>iirc there's 3 different versions of min/max functions across the different IEEE 754 versions</p>",
        "id": 237029951,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1619935309
    },
    {
        "content": "<p>oh man, that is actual pain</p>",
        "id": 237030828,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1619936335
    },
    {
        "content": "<p>No, there's only one clamp in Rust.<br>\nfor clamp(min, max, val)<br>\nif val is Nan,<br>\nthen return Nan,<br>\nand min and max <strong>cannot</strong> be Nan.</p>",
        "id": 237055744,
        "sender_full_name": "Jubilee",
        "timestamp": 1619965145
    },
    {
        "content": "<p>thus this version would use the 2019 version of min/max, which is the \"NaN-propagating\" version</p>",
        "id": 237055812,
        "sender_full_name": "Jubilee",
        "timestamp": 1619965208
    },
    {
        "content": "<p>I think this is the only reasonable option for clamp, because <code>NAN.clamp(1, 2)</code> picking either <code>1</code> or <code>2</code> seems wrong.</p>\n<p>(In other words, the <code>min</code>/<code>max</code> that ignore NAN are treating it like a monadic identity, but that interpretation doesn't make sense with <code>clamp</code>.)</p>",
        "id": 237070760,
        "sender_full_name": "scottmcm",
        "timestamp": 1619979316
    },
    {
        "content": "<p>We really should follow pre-existing specs for clamp:<br>\n<a href=\"https://www.khronos.org/registry/spir-v/specs/unified1/OpenCL.ExtendedInstructionSet.100.html#_a_id_common_a_common_instructions\">https://www.khronos.org/registry/spir-v/specs/unified1/OpenCL.ExtendedInstructionSet.100.html#_a_id_common_a_common_instructions</a></p>\n<blockquote>\n<p>fclamp</p>\n<p>Returns fmin(fmax(x, minval), maxval). Results are undefined if minval &gt; maxval.</p>\n</blockquote>\n<blockquote>\n<p>fmax</p>\n<p>Returns y if x &lt; y, otherwise it returns x. If one argument is a NaN, fmax returns the other argument. If both arguments are NaNs, fmax returns a NaN.</p>\n<p>Result Type, x and y must be floating-point or vector(2,3,4,8,16) of floating-point values.</p>\n<p>All of the operands, including the Result Type operand, must be of the same type.</p>\n<p>Note: fmax behaves as defined by C99 and may not match the IEEE 754-2008 definition for maxNum with regard to signaling NaNs. Specifically, signaling NaNs may behave as quiet NaNs</p>\n</blockquote>\n<blockquote>\n<p>fmin</p>\n<p>Returns y if y &lt; x, otherwise it returns x. If one argument is a NaN, fmin returns the other argument. If both arguments are NaNs, fmin returns a NaN.</p>\n<p>Result Type, x and y must be floating-point or vector(2,3,4,8,16) of floating-point values.</p>\n<p>All of the operands, including the Result Type operand, must be of the same type.</p>\n<p>Note: fmin behaves as defined by C99 and may not match the IEEE 754-2008 definition for minNum with regard to signaling NaNs. Specifically, signaling NaNs may behave as quiet NaNs</p>\n</blockquote>",
        "id": 237071671,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1619980137
    },
    {
        "content": "<p>in particular this means <code>NAN.clamp(1.0, 2.0) == 1.0</code></p>",
        "id": 237071692,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1619980197
    },
    {
        "content": "<p>Frankly, I care more about conformance with existing Rust and IEEE754 semantics than I care about Khronos' opinions, and where I care about IEEE754, I care more about the most recent specification. 2008's maxNum and minNum were largely mistakes.</p>",
        "id": 237073466,
        "sender_full_name": "Jubilee",
        "timestamp": 1619981941
    },
    {
        "content": "<p>I tend to agree that we should follow IEEE more closely than anything else</p>",
        "id": 237074001,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619982383
    },
    {
        "content": "<p>Khronos' clampMin is fine. It's not like a sin against God or whatever. It's not going to eat my babies. I just don't really see any particular reason to inflict it on our codebase here. I'm already knives-out for basic mathematical functions like <code>pow</code> just because I can't find a hardware accelerated version. :P</p>",
        "id": 237074009,
        "sender_full_name": "Jubilee",
        "timestamp": 1619982400
    },
    {
        "content": "<p>I feel like for any comparisons, if you put a NaN in you should get a NaN out? Which I think is the direction the latest IEEE 754 went?</p>",
        "id": 237074113,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619982492
    },
    {
        "content": "<p>yeah</p>",
        "id": 237074146,
        "sender_full_name": "Jubilee",
        "timestamp": 1619982498
    },
    {
        "content": "<p>they didn't specify which NaN, tho', which they should've (anything, even \"the left one\" is fine) but like, whatever</p>",
        "id": 237074214,
        "sender_full_name": "Jubilee",
        "timestamp": 1619982573
    },
    {
        "content": "<p>In general that's more useful because then you can just let your nans propagate and check at the end of an operation</p>",
        "id": 237074332,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619982646
    },
    {
        "content": "<p>yeah, that's basically The Argument.</p>",
        "id": 237074883,
        "sender_full_name": "Jubilee",
        "timestamp": 1619982991
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"229517\">Jacob Lifshay</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/rustc.20platform.20intrinsics/near/237071692\">said</a>:</p>\n<blockquote>\n<p>in particular this means <code>NAN.clamp(1.0, 2.0) == 1.0</code></p>\n</blockquote>\n<p>Yeah, that's just so arbitrary.  There's no reason for the definition to be that instead of <code>fmax(fmin(x, maxval), minval)</code>.</p>\n<p>If they're going to make it undefined for <code>minval &gt; maxval</code> anyway, they should have just let it be an unspecified value meeting the postcondition if they don't want it returning NAN for NAN inputs.</p>",
        "id": 237078409,
        "sender_full_name": "scottmcm",
        "timestamp": 1619985998
    },
    {
        "content": "<p>I don't dislike the semantics of clampMin there — I think a clamp that's guaranteed to produce a result inside the provided bounds is actually what you want a lot of the time... But I think it's more important that we follow the semantics of f32::clamp and such</p>",
        "id": 237160111,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1620048439
    },
    {
        "content": "<p>yeah i want a \"clamp into this range\" that <em>always</em> actually gets into that range.</p>",
        "id": 237187616,
        "sender_full_name": "Lokathor",
        "timestamp": 1620058770
    },
    {
        "content": "<p>but i don't care if it has an alternate name like <code>clamp_strict</code> and then NaN propagation is the normal <code>clamp</code></p>",
        "id": 237187971,
        "sender_full_name": "Lokathor",
        "timestamp": 1620058909
    },
    {
        "content": "<p>Maybe I'm being intentionally dense, but why is clamp special and shouldn't propagate nans unlike everything else?</p>\n<p>I feel like <code>x.eq(x).select(x, default).clamp(min, max)</code> is the appropriate way to implement that</p>",
        "id": 237188385,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620059109
    },
    {
        "content": "<p>because clamp is already doing some comparisons and if you simply order the comparisons properly you can clamp out the nans \"for free\", and then you can do things like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">math_here</span><span class=\"p\">().</span><span class=\"n\">clamp_strict</span><span class=\"p\">(</span><span class=\"mf\">0.0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mf\">1.0</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"mf\">255.0</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"c1\">// safety: `f` is known to be within the range 0.0 to 255.0 because of the strict clamp</span>\n<span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"p\">.</span><span class=\"n\">to_int_unchecked</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 237190108,
        "sender_full_name": "Lokathor",
        "timestamp": 1620059915
    },
    {
        "content": "<p>I'd be curious to see how LLVM optimizes my example</p>",
        "id": 237190208,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620059985
    },
    {
        "content": "<p>Not at a desktop, but I'll try to remember to investigate later today if you haven't looked in to it by then</p>",
        "id": 237190409,
        "sender_full_name": "Lokathor",
        "timestamp": 1620060077
    },
    {
        "content": "<p>oh wait we don't have the lib in nightly so godbolt isn't available for it. that'd be a big pain</p>",
        "id": 237190457,
        "sender_full_name": "Lokathor",
        "timestamp": 1620060114
    },
    {
        "content": "<p>Yeah it wouldn't be trivial</p>",
        "id": 237190711,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620060241
    },
    {
        "content": "<p>I can do it with stdarch it'd just be kinda more tedious</p>",
        "id": 237190835,
        "sender_full_name": "Lokathor",
        "timestamp": 1620060297
    },
    {
        "content": "<p>I know that AVX will return the non-nan value by default, but I don't think we should assume that's the \"default\" behavior. NEON returns nan for example</p>",
        "id": 237190921,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620060332
    },
    {
        "content": "<p>big \"thanks, i hate it\" vibes</p>",
        "id": 237191212,
        "sender_full_name": "Lokathor",
        "timestamp": 1620060467
    },
    {
        "content": "<p>Neon is correct :^)</p>",
        "id": 237194614,
        "sender_full_name": "Jubilee",
        "timestamp": 1620061902
    },
    {
        "content": "<p>anyways like I said, I don't hate Khronos' choice of a clampMin, it's mostly just that the choice is arbitrary i m o.<br>\nIf you would rather use the upper bound or the lower bound always, that's something I think a programmer knows and we kinda don't.</p>",
        "id": 237195109,
        "sender_full_name": "Jubilee",
        "timestamp": 1620062144
    },
    {
        "content": "<p>and having three functions for clamp is like \"really?\"</p>",
        "id": 237195230,
        "sender_full_name": "Jubilee",
        "timestamp": 1620062185
    },
    {
        "content": "<p>Not to mention you may want something else entirely, like 0</p>",
        "id": 237195425,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620062278
    },
    {
        "content": "<p>oh yes, \"NaN is 0\" is a common alternative choice.</p>",
        "id": 237195876,
        "sender_full_name": "Jubilee",
        "timestamp": 1620062485
    },
    {
        "content": "<p>In fact the real thing we should do is make it easy to substitute all the values in a float vector where the value is NaN with some other value.</p>",
        "id": 237196268,
        "sender_full_name": "Jubilee",
        "timestamp": 1620062651
    },
    {
        "content": "<p>Oh whoops, I remembered there's an easier way to do that</p>",
        "id": 237196381,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620062710
    },
    {
        "content": "<p>Oh?</p>",
        "id": 237196439,
        "sender_full_name": "Jubilee",
        "timestamp": 1620062731
    },
    {
        "content": "<p><code>x.is_nan().select(default, x)</code></p>",
        "id": 237196446,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620062733
    },
    {
        "content": "<p>Ah! Then we've already done that.</p>",
        "id": 237196469,
        "sender_full_name": "Jubilee",
        "timestamp": 1620062741
    },
    {
        "content": "<p>I'm extremely happy with this select interface, honestly.  Everything comes out so clean</p>",
        "id": 237196563,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620062764
    },
    {
        "content": "<p>I'm not sure we need to provide all sorts of weird special selects</p>",
        "id": 237196644,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620062791
    },
    {
        "content": "<p>yeah no, that's good enough.</p>",
        "id": 237196781,
        "sender_full_name": "Jubilee",
        "timestamp": 1620062847
    },
    {
        "content": "<p>alright if everyone else is voting for nan-pass-up clamp I'll defer this to later.</p>",
        "id": 237214671,
        "sender_full_name": "Lokathor",
        "timestamp": 1620069848
    },
    {
        "content": "<p>I do think there'd be value in a version that forces to the minimum. If there's a big performance hit in doing so, or if people want to propagate NaN to detect it as an error, I can also imagine having a version that doesn't.</p>",
        "id": 237215846,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620070353
    },
    {
        "content": "<p>I think the question is if that's really necessary over <code>x.is_nan().select(min, x).clamp(min, max)</code></p>",
        "id": 237216291,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620070531
    },
    {
        "content": "<p>It's admittedly more verbose, but it's still relatively concise and there's no question as to what it's doing</p>",
        "id": 237216414,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620070574
    },
    {
        "content": "<p>I just can't think of a function name that relays the same amount of information</p>",
        "id": 237216772,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620070714
    },
    {
        "content": "<p>Yes, not handling NaNs but having an explicit NaN-handling step tends to be faster.</p>",
        "id": 237217703,
        "sender_full_name": "Jubilee",
        "timestamp": 1620071144
    },
    {
        "content": "<p>And yeah, we should teach people to use the library and then I think after we see patterns we might produce a simpler library helper function, much like many popular conventions for Rust were proposed as std helper functions like 5 years later.</p>",
        "id": 237217848,
        "sender_full_name": "Jubilee",
        "timestamp": 1620071194
    },
    {
        "content": "<p>If I'm understanding select properly, I believe <code>clamp_strict</code> would be: </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">gt</span><span class=\"p\">(</span><span class=\"n\">min</span><span class=\"p\">).</span><span class=\"n\">select</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">lt_eq</span><span class=\"p\">(</span><span class=\"n\">max</span><span class=\"p\">).</span><span class=\"n\">select</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">max</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">min</span><span class=\"p\">)</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 237217996,
        "sender_full_name": "Lokathor",
        "timestamp": 1620071263
    },
    {
        "content": "<p>I was making the assumption that LLVM would be able to better optimize an explicit nan check step</p>",
        "id": 237218379,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620071413
    },
    {
        "content": "<p>Since it can assume the clamp that follows is nanless</p>",
        "id": 237218478,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620071451
    },
    {
        "content": "<p>i would like if that were the case but i don't assume that's the case</p>",
        "id": 237218601,
        "sender_full_name": "Lokathor",
        "timestamp": 1620071513
    },
    {
        "content": "<p>Well I'd like to check, but llvm has a specific nanless optimization</p>",
        "id": 237218719,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620071552
    },
    {
        "content": "<p><a href=\"https://llvm.org/docs/LangRef.html#id1340\">https://llvm.org/docs/LangRef.html#id1340</a></p>",
        "id": 237218804,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620071596
    },
    {
        "content": "<p><code>nnan</code></p>",
        "id": 237218813,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620071601
    },
    {
        "content": "<p>the internals of a strict clamp i'm not concerned about, the practical effect that i want is that if you call strict clamp to a finite min and max, the output value is a finite value <em>somewhere</em> in that range</p>",
        "id": 237218834,
        "sender_full_name": "Lokathor",
        "timestamp": 1620071616
    },
    {
        "content": "<p>So one of my concerns is that if we start adding functions that arbitrarily discard nans you can no longer assume that functions pass nans and you need to learn the behavior of every particular function</p>",
        "id": 237219025,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620071695
    },
    {
        "content": "<p>well it has an extra long name and stuff :P</p>",
        "id": 237219095,
        "sender_full_name": "Lokathor",
        "timestamp": 1620071735
    },
    {
        "content": "<p>Haha yeah my thought is at that point it's more verbose than just using <code>is_nan</code> and <code>select</code></p>",
        "id": 237219215,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620071787
    },
    {
        "content": "<p>yeah but then everyone has to think of it and write it out that way every time instead of getting a shorthand.</p>",
        "id": 237219556,
        "sender_full_name": "Lokathor",
        "timestamp": 1620071943
    },
    {
        "content": "<p>Well then that brings us to <span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span>'s idea of a <code>replace_nan</code> function which is probably unnecessary but a compromise there</p>",
        "id": 237219764,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620072016
    },
    {
        "content": "<p>But I think learning about select is a one time experience</p>",
        "id": 237219855,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620072053
    },
    {
        "content": "<p>And probably necessary to using stdsimd</p>",
        "id": 237219896,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620072067
    },
    {
        "content": "<p>but you have to read the code and then process out \"okay so if i have this mask, now i select, and then i have these inputs... okay so that means now all the lanes are non-nan, okay\"</p>",
        "id": 237220039,
        "sender_full_name": "Lokathor",
        "timestamp": 1620072132
    },
    {
        "content": "<p>and even if you're seeing the same phrase over and over, <em>you learned that magic phrase</em>, and even if you learn the magic phrase you have to look each time to see \"oh is this exactly the one i'm used to?\"</p>",
        "id": 237220119,
        "sender_full_name": "Lokathor",
        "timestamp": 1620072177
    },
    {
        "content": "<p>i mean there's a reason we have clamp at all to begin within, and not just a chain of max and min calls</p>",
        "id": 237220194,
        "sender_full_name": "Lokathor",
        "timestamp": 1620072195
    },
    {
        "content": "<p>IMO, if we give it time to bake, the obvious solution will just kind of jump on us.</p>",
        "id": 237220321,
        "sender_full_name": "Jubilee",
        "timestamp": 1620072250
    },
    {
        "content": "<p>Maybe. I'm just concerned were going to end up with <code>clamp_nan_to_min</code>, <code>clamp_nan_to_max</code>, <code>clamp_nan_to_zero</code>... And that's just clamp</p>",
        "id": 237220695,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620072427
    },
    {
        "content": "<p>Yeaaah, that's why I am against prematurely adding anything.</p>",
        "id": 237220742,
        "sender_full_name": "Jubilee",
        "timestamp": 1620072456
    },
    {
        "content": "<p>I'm not sure we should be adding anything that doesn't exist for scalar primitives because if there wasn't a compelling reason to add them there I don't see why SIMD is special</p>",
        "id": 237220847,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620072492
    },
    {
        "content": "<p>Unless it's something that's unique to SIMD (which this isn't)</p>",
        "id": 237220922,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1620072522
    }
]