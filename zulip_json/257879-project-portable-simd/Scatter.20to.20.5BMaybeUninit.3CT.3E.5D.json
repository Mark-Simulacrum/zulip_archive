[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"312331\">@Caleb Zulawski</span> Nah it's not unsound to scatter to <code>[MaybeUninit&lt;T&gt;]</code>, it's only unsound to treat <code>&amp;mut [MaybeUninit&lt;T&gt;]</code> as <code>&amp;mut [T]</code>.</p>",
        "id": 263636386,
        "sender_full_name": "Jubilee",
        "timestamp": 1638564698
    },
    {
        "content": "<p>Agreed</p>",
        "id": 263636419,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1638564717
    },
    {
        "content": "<p>I'm guessing there is a function to go the other way? But I'm not sure</p>",
        "id": 263636485,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1638564737
    },
    {
        "content": "<p>I thought there was, but I couldn't find it</p>",
        "id": 263636542,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1638564754
    },
    {
        "content": "<p>You can convert the <code>[MaybeUninit&lt;T&gt;]</code> to <code>[T]</code> if it's completely initialized.</p>",
        "id": 263637584,
        "sender_full_name": "Jubilee",
        "timestamp": 1638565108
    },
    {
        "content": "<p>I meant if you still want to scatter to a plain slice</p>",
        "id": 263637651,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1638565143
    },
    {
        "content": "<p>Oh.</p>",
        "id": 263638033,
        "sender_full_name": "Jubilee",
        "timestamp": 1638565288
    },
    {
        "content": "<p>What I am confused now <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 263638058,
        "sender_full_name": "Jubilee",
        "timestamp": 1638565303
    },
    {
        "content": "<p>scatter to <code>[T]</code> by calling scatter to <code>[MaybeUninit&lt;T&gt;]</code></p>",
        "id": 263638199,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1638565371
    },
    {
        "content": "<p>Uhhh I think it would be an unacceptable ergonomics loss to have to call a function on a slice to pretend it is MaybeUninit and then write to it, even if it existed.</p>",
        "id": 263638396,
        "sender_full_name": "Jubilee",
        "timestamp": 1638565485
    },
    {
        "content": "<p>I think changing <code>scatter_select_unchecked</code> to use a base <code>*mut T</code> is fine, since that's basically already happening.</p>",
        "id": 263652945,
        "sender_full_name": "Jubilee",
        "timestamp": 1638565533
    },
    {
        "content": "<p>Though that requires people who want to manually mask also call <code>.len()</code> in the right order.</p>",
        "id": 263653030,
        "sender_full_name": "Jubilee",
        "timestamp": 1638565576
    },
    {
        "content": "<p>ugh.</p>",
        "id": 263653034,
        "sender_full_name": "Jubilee",
        "timestamp": 1638565580
    },
    {
        "content": "<p>Yeah no even as an <code>unsafe</code> function that's too many invariants to expose.</p>",
        "id": 263657097,
        "sender_full_name": "Jubilee",
        "timestamp": 1638567887
    },
    {
        "content": "<p>Like what?</p>",
        "id": 263657170,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1638567934
    },
    {
        "content": "<p>Uh, \"if you so much as looked at the <code>*mut T</code> wrong it breaks\".</p>",
        "id": 263657277,
        "sender_full_name": "Jubilee",
        "timestamp": 1638567986
    },
    {
        "content": "<p>I'm not sure what you mean</p>",
        "id": 263657304,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1638568007
    },
    {
        "content": "<p>If I changed it to accept <code>*mut T</code> the only safe way to use the unsafe <code>scatter_select_unchecked</code> would be in fact to write</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">simd</span><span class=\"p\">.</span><span class=\"n\">scatter_select_unchecked</span><span class=\"p\">(</span><span class=\"n\">slice</span><span class=\"p\">.</span><span class=\"n\">as_mut_ptr</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">mask</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">idxs</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"c1\">// or</span>\n<span class=\"n\">simd</span><span class=\"p\">.</span><span class=\"n\">scatter_select_unchecked</span><span class=\"p\">(</span><span class=\"n\">MaybeUninit</span>::<span class=\"n\">slice_as_mut_ptr</span><span class=\"p\">(</span><span class=\"n\">slice</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">mask</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">idxs</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 263657398,
        "sender_full_name": "Jubilee",
        "timestamp": 1638568079
    },
    {
        "content": "<p>yeah...that's not much different than trying to copy a slice by calling <code>memcpy</code> directly...i don't see how that's \"too unsafe\"</p>",
        "id": 263657573,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1638568165
    },
    {
        "content": "<p>the problem is that</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">slice</span><span class=\"p\">.</span><span class=\"n\">as_mut_ptr</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">mask</span>: <span class=\"nc\">Mask</span><span class=\"o\">&lt;</span><span class=\"kt\">isize</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">LANES</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">idxs</span><span class=\"p\">.</span><span class=\"n\">lanes_lt</span><span class=\"p\">(</span><span class=\"n\">Simd</span>::<span class=\"n\">splat</span><span class=\"p\">(</span><span class=\"n\">slice</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">()));</span><span class=\"w\"></span>\n<span class=\"n\">simd</span><span class=\"p\">.</span><span class=\"n\">scatter_select_unchecked</span><span class=\"p\">(</span><span class=\"n\">ptr</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">mask</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">idxs</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n<p>is wrong.</p>",
        "id": 263657803,
        "sender_full_name": "Jubilee",
        "timestamp": 1638568270
    },
    {
        "content": "<p>Why?</p>",
        "id": 263657959,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1638568351
    },
    {
        "content": "<p>that's exactly like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">slice</span><span class=\"p\">.</span><span class=\"n\">as_mut_ptr</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">bytes</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">slice</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"n\">memcpy</span><span class=\"p\">(</span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">c_void</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">src</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">bytes</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 263658097,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1638568432
    },
    {
        "content": "<p>which is also wrong, but <code>memcpy</code> is not declared \"too unsafe\" to include in the libc crate</p>",
        "id": 263658213,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1638568477
    },
    {
        "content": "<p>it's wrong cuz the slice being borrowed immutably for <code>len</code> invalidates the mutable borrow for <code>ptr</code></p>",
        "id": 263658282,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1638568520
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/Scatter.20to.20.5BMaybeUninit.3CT.3E.5D/near/263657959\">said</a>:</p>\n<blockquote>\n<p>Why?</p>\n</blockquote>\n<p>The <code>.len()</code> call interacts with the <code>&amp;mut [T]</code> when it creates the <code>&amp;[T]</code> reference and basically reasserts the uniqueness assumptions.</p>",
        "id": 263658286,
        "sender_full_name": "Jubilee",
        "timestamp": 1638568521
    },
    {
        "content": "<p>yeah.</p>",
        "id": 263658324,
        "sender_full_name": "Jubilee",
        "timestamp": 1638568541
    },
    {
        "content": "<p>hmm, how about we just leave out unchecked_scatter and instead tell people to use vectors of pointers?</p>",
        "id": 263658771,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1638568771
    },
    {
        "content": "<p>though otoh maybe we need unchecked_scatter anyway</p>",
        "id": 263658883,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1638568811
    },
    {
        "content": "<p>Is there a reference on not being able to hold a mutable pointer to something while accessing it? Miri doesn't complain</p>",
        "id": 263659217,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1638568985
    },
    {
        "content": "<p>What exactly are you running past Miri?</p>",
        "id": 263659423,
        "sender_full_name": "Jubilee",
        "timestamp": 1638569107
    },
    {
        "content": "<p>And \"Miri doesn't complain\" isn't \"it's not UB\" or \"it's a good idea\".</p>",
        "id": 263659441,
        "sender_full_name": "Jubilee",
        "timestamp": 1638569119
    },
    {
        "content": "<p>Yeah, that's why I was looking for a reference</p>",
        "id": 263659472,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1638569142
    },
    {
        "content": "<p>I did basically this, I get a pointer, then check the length, then write to the pointer</p>",
        "id": 263659539,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1638569166
    },
    {
        "content": "<blockquote>\n<p>Finding live shared references propagates recursively through references, but not through raw pointers.<br>\n<a href=\"https://rust-lang.github.io/unsafe-code-guidelines/glossary.html\">https://rust-lang.github.io/unsafe-code-guidelines/glossary.html</a></p>\n</blockquote>\n<p>This is basically the opposite case</p>",
        "id": 263661196,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1638570052
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> Hey did you ever document the no-transitive-reference thing?</p>",
        "id": 263664674,
        "sender_full_name": "Jubilee",
        "timestamp": 1638572431
    },
    {
        "content": "<p>so i might be a little lost here but aren't there just gonna be <em>two</em> functions? one for a normal slice and one for the maybeuninit slice?</p>\n<p>heck if the target to scatter to is an arg to the scatter function we can even make one generic function with some sort of unsafe trait for the target and users could extend it to their own types that way if they absolutely need to.</p>",
        "id": 263666608,
        "sender_full_name": "Lokathor",
        "timestamp": 1638573888
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/Scatter.20to.20.5BMaybeUninit.3CT.3E.5D/near/263666608\">said</a>:</p>\n<blockquote>\n<p>so i might be a little lost here but aren't there just gonna be <em>two</em> functions? one for a normal slice and one for the maybeuninit slice?</p>\n</blockquote>\n<p>yup, that's what I'd expect</p>",
        "id": 263666739,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1638574008
    },
    {
        "content": "<p>ohgod lol</p>",
        "id": 263666776,
        "sender_full_name": "Jubilee",
        "timestamp": 1638574050
    },
    {
        "content": "<p>yeah, I think there would be a second function. there will probably be several variations once we have vectors of pointers, too</p>",
        "id": 263666778,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1638574054
    },
    {
        "content": "<p>yes that was my initial intention.</p>",
        "id": 263666784,
        "sender_full_name": "Jubilee",
        "timestamp": 1638574058
    },
    {
        "content": "<p>I'm still not sure which one we want to consider the fundamental \"scatter\" function</p>",
        "id": 263666840,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1638574084
    },
    {
        "content": "<p>the intrinsic, of course!</p>",
        "id": 263666856,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1638574106
    },
    {
        "content": "<p>i'd pick the pointer vector scatter</p>",
        "id": 263666872,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1638574136
    },
    {
        "content": "<p>I think I agree</p>",
        "id": 263666903,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1638574177
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/Scatter.20to.20.5BMaybeUninit.3CT.3E.5D/near/263664674\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> Hey did you ever document the no-other-reference-while-<code>*mut T</code>-is-live thing?</p>\n</blockquote>\n<p>it's \"documented\" in all my Stacked Borrows description, but I guess that is not what you mean?</p>",
        "id": 264538141,
        "sender_full_name": "RalfJ",
        "timestamp": 1639193217
    },
    {
        "content": "<p>There is no RFC deciding that these are actually the final rules we will go with, so there isn't much \"official\" documentation either</p>",
        "id": 264538152,
        "sender_full_name": "RalfJ",
        "timestamp": 1639193243
    },
    {
        "content": "<p>Is it unsound today? I wouldn't be surprised if there aren't many instances of this floating around...</p>",
        "id": 264538322,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1639193497
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/Scatter.20to.20.5BMaybeUninit.3CT.3E.5D/near/264538141\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/Scatter.20to.20.5BMaybeUninit.3CT.3E.5D/near/263664674\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> Hey did you ever document the no-other-reference-while-<code>*mut T</code>-is-live thing?</p>\n</blockquote>\n<p>it's \"documented\" in all my Stacked Borrows description, but I guess that is not what you mean?</p>\n</blockquote>\n<p>I think we were hoping for something in the UCG or something.</p>",
        "id": 264539153,
        "sender_full_name": "Jubilee",
        "timestamp": 1639194833
    },
    {
        "content": "<blockquote>\n<p>However, be aware that Miri will not catch all cases of undefined behavior in your program, and cannot run all programs:<br>\n   There are still plenty of open questions around the basic invariants for some types and when these invariants even have to hold. Miri tries to avoid false positives here, so if your program runs fine in Miri right now that is by no means a guarantee that it is UB-free when these questions get answered.</p>\n</blockquote>",
        "id": 264658234,
        "sender_full_name": "Jubilee",
        "timestamp": 1639363470
    },
    {
        "content": "<p>the only official thing is that it is UB to \"Breaking the pointer aliasing rules. &amp;mut T and &amp;T follow LLVM’s scoped noalias model, except if the &amp;T contains an UnsafeCell&lt;U&gt;.\" (<a href=\"https://doc.rust-lang.org/reference/behavior-considered-undefined.html\">https://doc.rust-lang.org/reference/behavior-considered-undefined.html</a>)</p>",
        "id": 265030141,
        "sender_full_name": "RalfJ",
        "timestamp": 1639583683
    },
    {
        "content": "<p>everything else is Stacked Borrows, which is my experiment but not RFC'd or ratified in any way -- so it's not documented outside the resources collected at <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md\">https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md</a> (and its <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues?q=is%3Aissue+is%3Aopen+label%3AT-stacked-borrows\">list of issues</a>)</p>",
        "id": 265030272,
        "sender_full_name": "RalfJ",
        "timestamp": 1639583729
    },
    {
        "content": "<p>and your issue is specifically <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/133\">https://github.com/rust-lang/unsafe-code-guidelines/issues/133</a>, I think, which I hope we can fix in the future</p>",
        "id": 265030797,
        "sender_full_name": "RalfJ",
        "timestamp": 1639583901
    },
    {
        "content": "<p>I don't see anyone else with a competing model, and all I am getting out of this conversation is \"we can't promise we break it, but we shouldn't document that we can't promise we won't break it because what if we make the model more permissive?\"<br>\nWhen it is precisely the opposite direction that is forward compatible.</p>",
        "id": 265040188,
        "sender_full_name": "Jubilee",
        "timestamp": 1639587600
    },
    {
        "content": "<p>My argument is that it's entirely outside of the scope of this project group, we should specify that we follow the same model as regular pointers, and if those are not documented correctly or need a more accurate model that should be done, but not as part of this group</p>",
        "id": 265041015,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1639587884
    },
    {
        "content": "<p>Partially because of the scope of this group, and partially because doing it as part of std::simd implies that we handle pointers _differently_ than the rest of rust, which is misleading</p>",
        "id": 265041293,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1639587983
    },
    {
        "content": "<p>I don't care <strong>where</strong> in the compiler the documentation is, I just care that the documentation for a function is as complete and correct as possible for the most obvious use-case. And the most obvious use case has to do with mutable slices and pointers to them. And apparently no one is allowed to document how to interact with mutable slices completely, so we're not going to add an unsafe function that would interact with one.</p>",
        "id": 265042068,
        "sender_full_name": "Jubilee",
        "timestamp": 1639588301
    },
    {
        "content": "<p>And just because you didn't know Stacked Borrows may not allow certain things doesn't mean that we handle pointers differently from the rest of Rust. That is a simply fallacious accusation and I have nowhere implied it.</p>",
        "id": 265042598,
        "sender_full_name": "Jubilee",
        "timestamp": 1639588507
    },
    {
        "content": "<p>I don't see how something along the lines of \"scatter is equivalent to calling ptr::write sequentially\" is not as correct as possible?</p>",
        "id": 265042657,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1639588538
    },
    {
        "content": "<p>That's not documenting the actual example.</p>",
        "id": 265042709,
        "sender_full_name": "Jubilee",
        "timestamp": 1639588557
    },
    {
        "content": "<p>Which is what I wanted to do after drafting all that.</p>",
        "id": 265042780,
        "sender_full_name": "Jubilee",
        "timestamp": 1639588575
    },
    {
        "content": "<p>Stacked borrows is not the current aliasing rule for rust, so if we say we use it, that is handling it differently than the rest of rust.</p>",
        "id": 265042783,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1639588576
    },
    {
        "content": "<p>That is because THERE IS NO ALIASING RULE.</p>",
        "id": 265042810,
        "sender_full_name": "Jubilee",
        "timestamp": 1639588591
    },
    {
        "content": "<p>yes unfortunately :(</p>",
        "id": 265042842,
        "sender_full_name": "RalfJ",
        "timestamp": 1639588610
    },
    {
        "content": "<p>but also Stacked Borrows isnt ready for an RFC yet</p>",
        "id": 265042868,
        "sender_full_name": "RalfJ",
        "timestamp": 1639588625
    },
    {
        "content": "<p>Yes, which still means it's incorrect for us to say we use it.</p>",
        "id": 265042878,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1639588629
    },
    {
        "content": "<p>I feel like whether the stdlib docs should use stacked borrows to give guidance is up to t-libs or t-libs-api</p>",
        "id": 265042914,
        "sender_full_name": "RalfJ",
        "timestamp": 1639588645
    },
    {
        "content": "<p>Then we will not add anything to do with aliasing.</p>",
        "id": 265042943,
        "sender_full_name": "Jubilee",
        "timestamp": 1639588660
    },
    {
        "content": "<p>I would be totally fine with this but I think Id way overstep my competence by making such a decision</p>",
        "id": 265042951,
        "sender_full_name": "RalfJ",
        "timestamp": 1639588665
    },
    {
        "content": "<p>It is absolutely correct to say it's equivalent to sequential scalar pointer writes, and if those aren't well documented or established, they should be, but that isn't SIMD specific</p>",
        "id": 265043067,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1639588705
    },
    {
        "content": "<p>Any function would make it a lot easier to do a lot more of them.</p>",
        "id": 265043147,
        "sender_full_name": "Jubilee",
        "timestamp": 1639588740
    },
    {
        "content": "<p>I'm not saying there shouldn't be a rule, I'm just saying scatter isn't the place to define it</p>",
        "id": 265043161,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1639588746
    },
    {
        "content": "<p>there are some carefully places aliasing-related things in the docs where everyone agreed that whatever the eventual model will be, its likely going to require this. maybe something like that is possible here, not sure. this mostly has to do with converting &amp;T to raw ptrs, casting, and then doing a <code>write</code> though, which is a much clearer situation</p>",
        "id": 265043178,
        "sender_full_name": "RalfJ",
        "timestamp": 1639588752
    },
    {
        "content": "<p>Which is why I want to include a carefully worked example.</p>",
        "id": 265043209,
        "sender_full_name": "Jubilee",
        "timestamp": 1639588765
    },
    {
        "content": "<p>maybe this can be solved with different framing? \"the aliasing rules arent clear yet, and when naively calling this function it is easy to write code whose well-definedness is ambiguous, so here is some guidance for how to stay clear of such ambiguity\"</p>",
        "id": 265043368,
        "sender_full_name": "RalfJ",
        "timestamp": 1639588824
    },
    {
        "content": "<p>Because it's exposing oneself to the risks of UB 4 times faster.</p>",
        "id": 265043369,
        "sender_full_name": "Jubilee",
        "timestamp": 1639588824
    },
    {
        "content": "<p>that sounds very different from \"do this or else UB\" but could still nudge people into the safe(r) corners of the design space</p>",
        "id": 265043422,
        "sender_full_name": "RalfJ",
        "timestamp": 1639588855
    },
    {
        "content": "<p>I... genuinely don't parse that differently but if that reads differently to everyone else then okay.</p>",
        "id": 265043541,
        "sender_full_name": "Jubilee",
        "timestamp": 1639588914
    },
    {
        "content": "<p>not sure if scatter is the right place or some module-level docs somewhere, but that seems easy to adjust later</p>",
        "id": 265043545,
        "sender_full_name": "RalfJ",
        "timestamp": 1639588915
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/Scatter.20to.20.5BMaybeUninit.3CT.3E.5D/near/265043541\">said</a>:</p>\n<blockquote>\n<p>I... genuinely don't parse that differently but if that reads differently to everyone else then okay.</p>\n</blockquote>\n<p>it avoids claerly saying that something is UB, and instead says it is insufficiently defined... yeah our terminology sucks but I blame C. :/<br>\n\"UB\" doesnt mean \"it has not been defined\", it means \"it has been carefully defined to not be allowed\".</p>",
        "id": 265043792,
        "sender_full_name": "RalfJ",
        "timestamp": 1639589017
    },
    {
        "content": "<p>To me, the absence of an aliasing rule means that all documentation is equally correct regarding the rule and the only preference is aesthetic, because the only aliasing rule is \"false\" et ex falso quodlibet. <span aria-label=\"relaxed\" class=\"emoji emoji-263a\" role=\"img\" title=\"relaxed\">:relaxed:</span></p>",
        "id": 265044056,
        "sender_full_name": "Jubilee",
        "timestamp": 1639589125
    },
    {
        "content": "<p>arent docs mostly about getting the aesthetics right?^^ it's not like they are mathematical formula...</p>",
        "id": 265044543,
        "sender_full_name": "RalfJ",
        "timestamp": 1639589325
    },
    {
        "content": "<p>i'd argue that the closer they are to specifying exact requirements/guarantees while still being readily understandable the better</p>",
        "id": 265044852,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1639589457
    },
    {
        "content": "<p>cuz vagueness is a good way to cause misunderstandings/bugs</p>",
        "id": 265044926,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1639589487
    },
    {
        "content": "<p>Well yes, basically. The entire API surface is mostly a matter of aesthetics. We are writing all this code because writing a bunch of assembly is ugly (and thus tedious, hard to maintain, etc.)</p>\n<p>But genuinely from a strict, validity-oriented \"is this correct?\" perspective, I think \"colorless green dreams sleep furiously\" is valid documentation on what the semantics of the aliasing rules in Rust are.</p>\n<p>But I have strong preferences regarding making the documentation helpful to users and making the functions easy to use, and that's why I approached writing the most correct thing from a probabilistic frame.</p>",
        "id": 265045108,
        "sender_full_name": "Jubilee",
        "timestamp": 1639589555
    },
    {
        "content": "<p>so specifying that scatter is a sequence of <code>if mask { ptr::write(ptr.wrapping_add(index), value) }</code> is a good idea</p>",
        "id": 265045125,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1639589564
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/Scatter.20to.20.5BMaybeUninit.3CT.3E.5D/near/265045108\">said</a>:</p>\n<blockquote>\n<p>But I have strong preferences regarding making the documentation helpful to users and making the functions easy to use, and that's why I approached writing the most correct thing from a probabilistic frame.</p>\n</blockquote>\n<p>This is also why I don't really care what the documentation of <code>core::ptr</code> is, really, because a lot of users will not follow the outbound link to <code>core::ptr</code>, and most will not care to internalize all that just to call <code>scatter</code>, because of course they \"know it's safe\", they've done it a thousand times <strong>in assembly, which has fewer constraints by design</strong>.</p>",
        "id": 265046274,
        "sender_full_name": "Jubilee",
        "timestamp": 1639590047
    },
    {
        "content": "<p>I dont disagre with any of that, as long as the docs do not state that certain things \"are (definitely) UB\" when that decision has not been made yet. for me this is all about careful wording, and I think the docs can be helpful and precise without saying incorrect things.</p>",
        "id": 265046818,
        "sender_full_name": "RalfJ",
        "timestamp": 1639590301
    },
    {
        "content": "<p>And yes, I have already literally gotten the objection (and verbal abuse! that was great!) that we shouldn't document scatter as following a sequential left-to-right rule, but should instead in fact say that it works in such a way that it allows a processor to follow any order, so it's UB to write to the same index twice, because optimizations or \"that's not how it works in <code>${asm_lang}</code>\" or something. <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 265047061,
        "sender_full_name": "Jubilee",
        "timestamp": 1639590382
    },
    {
        "content": "<p>Did we decide that LLVM scatter is left-to-right, but can technically ignore duplicate writes?</p>",
        "id": 265048897,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1639591064
    },
    {
        "content": "<p>Yes, that matches the AVX semantics. I am not sure if Arm SVE differs, matching semantics is certainly what their pseudocode implies. I think RVV doesn't either.</p>",
        "id": 265049204,
        "sender_full_name": "Jubilee",
        "timestamp": 1639591176
    },
    {
        "content": "<p>Unless you're dealing with virtual memory with protection etc I feel like the order doesn't really matter anyway <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 265049214,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1639591180
    },
    {
        "content": "<p>It only matters if you have a duplicate index.</p>",
        "id": 265049261,
        "sender_full_name": "Jubilee",
        "timestamp": 1639591200
    },
    {
        "content": "<p>Arm actually allows the processor itself to discard duplicate writes, lol</p>",
        "id": 265049369,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1639591215
    },
    {
        "content": "<p>iirc llvm only has to have the final written values be correct, if scatter writes multiple times to the same byte it may elide previous stores -- just like any non-atomic llvm store instruction (simd or not)</p>",
        "id": 265049411,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1639591220
    },
    {
        "content": "<p>Though I assume none do that</p>",
        "id": 265049442,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1639591228
    },
    {
        "content": "<p>who knows?</p>",
        "id": 265049475,
        "sender_full_name": "Jubilee",
        "timestamp": 1639591242
    },
    {
        "content": "<p>The Cortex-X2 isn't out yet.<br>\nOh btw that's happening.</p>",
        "id": 265049518,
        "sender_full_name": "Jubilee",
        "timestamp": 1639591255
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"312331\">@Caleb Zulawski</span> Consumer hardware with Arm SVE next year, on the fanciest phones.</p>",
        "id": 265049585,
        "sender_full_name": "Jubilee",
        "timestamp": 1639591280
    },
    {
        "content": "<p>yeah, sorry about my contributions to verbal abuse...</p>",
        "id": 265049673,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1639591310
    },
    {
        "content": "<p>eh I have had arguments with people but the person who was just insulting was someone else, that fellow followed up by explicitly denigrating my... lack of HPC experience?</p>",
        "id": 265049865,
        "sender_full_name": "Jubilee",
        "timestamp": 1639591385
    },
    {
        "content": "<p>llvm removing stores: <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2021&amp;gist=0c07586cc6e608442fa6d3cc97857b6e\">https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2021&amp;gist=0c07586cc6e608442fa6d3cc97857b6e</a></p>",
        "id": 265050238,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1639591547
    },
    {
        "content": "<p>But yes according to THAT jerk we should in fact not document scatter as equivalent to a for loop of writes, even though afaict no processor implements a different behavior. <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 265050721,
        "sender_full_name": "Jubilee",
        "timestamp": 1639591725
    },
    {
        "content": "<p>OH apparently RVV implements indexed-unordered AND index-ordered.</p>",
        "id": 265051045,
        "sender_full_name": "Jubilee",
        "timestamp": 1639591874
    },
    {
        "content": "<p>Yeah, even if it's handled in one uop or whatever, it's still sequentially executed...</p>",
        "id": 265051055,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1639591878
    },
    {
        "content": "<p>But LLVM still has <code>llvm.masked.scatter</code> use the \"AVX-y\" reasoning.</p>",
        "id": 265051306,
        "sender_full_name": "Jubilee",
        "timestamp": 1639591975
    },
    {
        "content": "<p>Not to go all \"cut the baby in half\" on you two, But I think that you're both mostly correct at the same time.</p>\n<ul>\n<li>The scatter rules should explain in one sentence that it works as if a series of individual pointer writes indivisibly happened (I'm very carefully not saying \"atomic\" here). The point of portable simd is to be consistent regardless of hardware so if that's the simple semantics (it is) and that's what LLVM offers (seems that way), then that's what we do</li>\n<li><strong>next paragraph:</strong> that's right, this is one of those big multi-paragraph doc comments. After saying the semantic meaning of the function we give an example of using the function and explain why it works and so on.</li>\n<li><strong>next paragraph:</strong> we finish out with the thing a lot of description documents do where we explain that the docs are intended to elaborate on how this function interacts with other rules, but that any divergence from the normal rules is fully accidental and unintentional.</li>\n</ul>",
        "id": 265055653,
        "sender_full_name": "Lokathor",
        "timestamp": 1639593785
    },
    {
        "content": "<p>i think we should include in the docs that the pointer written to comes from <code>wrapping_add</code>, cuz that allows setting the pointer to null and the index to a pointer casted to int</p>",
        "id": 265055988,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1639593947
    },
    {
        "content": "<p>oh, sure, precisely which method and if null is allowed i don't have much of an opinion on</p>",
        "id": 265056454,
        "sender_full_name": "Lokathor",
        "timestamp": 1639594155
    },
    {
        "content": "<p>That is an implementation detail and likely to change.</p>",
        "id": 265056877,
        "sender_full_name": "Jubilee",
        "timestamp": 1639594325
    },
    {
        "content": "<p>I very strongly want it to be guaranteed that setting ptr to null and index to a pointer casted to an int will work, so I think it shouldn't just be an implementation detail</p>",
        "id": 265058231,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1639594840
    },
    {
        "content": "<p>that would allow writing to null, which I am pretty sure is UB no matter what way we slice it.</p>",
        "id": 265058510,
        "sender_full_name": "Jubilee",
        "timestamp": 1639594961
    },
    {
        "content": "<p>I actually looked through the LLVM docs and pointer provenance seems to see through bitcasts too, so I'm not 100% sure it's okay to do that</p>",
        "id": 265058756,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1639595062
    },
    {
        "content": "<p>Regarding adds etc</p>",
        "id": 265058807,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1639595088
    },
    {
        "content": "<p>yes, sometimes unsoundly, if memory serves.</p>",
        "id": 265058860,
        "sender_full_name": "Jubilee",
        "timestamp": 1639595111
    },
    {
        "content": "<p>writing to null is always UB, <code>*null_mut().wrapping_add(&amp;mut a as *mut _ as isize) = 1</code>, is always defined</p>",
        "id": 265058906,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1639595139
    },
    {
        "content": "<p>This method is supposed to be a convenience for writing to a slice, basically, so while I won't stop you from using it improperly, I won't promise you I won't change it to bite your nose off later, esp. if that would allow picking up missing opts compared to <code>Simd&lt;*mut T&gt;</code></p>",
        "id": 265059387,
        "sender_full_name": "Jubilee",
        "timestamp": 1639595364
    },
    {
        "content": "<p>i can't imagine why you'd want to offset from null to begin with</p>",
        "id": 265059905,
        "sender_full_name": "Lokathor",
        "timestamp": 1639595573
    },
    {
        "content": "<p>cuz that lets you construct a poor-man's scatter to vector of pointers</p>",
        "id": 265059964,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1639595603
    },
    {
        "content": "<p>It would allow you to store your pointers as a Simd&lt;usize, N&gt;</p>",
        "id": 265059969,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1639595609
    },
    {
        "content": "<p>i think we should just... support that properly, the normal way</p>",
        "id": 265060005,
        "sender_full_name": "Lokathor",
        "timestamp": 1639595625
    },
    {
        "content": "<p>Agreed</p>",
        "id": 265060029,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1639595634
    },
    {
        "content": "<p>yes, we will.</p>",
        "id": 265060037,
        "sender_full_name": "Jubilee",
        "timestamp": 1639595639
    },
    {
        "content": "<p>though, now that i look at the ir, <code>&lt;*mut T&gt;::wrapping_add</code> won't do what I want, what I want is actually <code>(ptr as usize).wrapping_add(idx) as *mut T</code></p>",
        "id": 265060256,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1639595724
    },
    {
        "content": "<p>luckily Simd wrapping_add does what I want: <a href=\"https://github.com/rust-lang/portable-simd/blob/a8385522ade6f67853edac730b5bf164ddb298fd/crates/core_simd/src/vector/ptr.rs#L49\">https://github.com/rust-lang/portable-simd/blob/a8385522ade6f67853edac730b5bf164ddb298fd/crates/core_simd/src/vector/ptr.rs#L49</a></p>",
        "id": 265060550,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1639595857
    },
    {
        "content": "<p>Yes, that's an impl detail, don't count on it lasting forever. :P<br>\nI am okay with changing this fn to accept \"a ptr to arbitrary slicelike data structures\" for obviously legitimate reasons, but I might change it to use vector gep inbounds.</p>",
        "id": 265060745,
        "sender_full_name": "Jubilee",
        "timestamp": 1639595958
    },
    {
        "content": "<p>but that requires adding vector gep to the compiler.</p>",
        "id": 265060774,
        "sender_full_name": "Jubilee",
        "timestamp": 1639595975
    },
    {
        "content": "<p>hm, maybe this is the wrong interface. Scatter should probably be more like Write.</p>",
        "id": 265063274,
        "sender_full_name": "Jubilee",
        "timestamp": 1639597064
    },
    {
        "content": "<p>Meaning?</p>",
        "id": 265063506,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1639597153
    },
    {
        "content": "<p>Not actually sure yet.</p>",
        "id": 265064633,
        "sender_full_name": "Jubilee",
        "timestamp": 1639597558
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/Scatter.20to.20.5BMaybeUninit.3CT.3E.5D/near/265060774\">said</a>:</p>\n<blockquote>\n<p>but that requires adding vector gep to the compiler.</p>\n</blockquote>\n<p>llvm actually has that:<br>\n<a href=\"https://llvm.org/docs/LangRef.html#getelementptr-instruction\">https://llvm.org/docs/LangRef.html#getelementptr-instruction</a></p>\n<div class=\"codehilite\"><pre><span></span><code>&lt;result&gt; = getelementptr &lt;ty&gt;, &lt;ptr vector&gt; &lt;ptrval&gt;, [inrange] &lt;vector index type&gt; &lt;idx&gt;\n</code></pre></div>",
        "id": 265067586,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1639598678
    },
    {
        "content": "<p>yeah, we just gotta emit it.</p>",
        "id": 265075069,
        "sender_full_name": "Jubilee",
        "timestamp": 1639602395
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/Scatter.20to.20.5BMaybeUninit.3CT.3E.5D/near/265063506\">said</a>:</p>\n<blockquote>\n<p>Meaning?</p>\n</blockquote>\n<p>it means that it must start and end in the same allocated object (so the example using ptr::null_mut() would be ub)</p>",
        "id": 265244186,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1639705291
    },
    {
        "content": "<p>That may have been about my \"maybe Scatter should be more like the Write trait...\" thing.</p>",
        "id": 265360574,
        "sender_full_name": "Jubilee",
        "timestamp": 1639775260
    },
    {
        "content": "<p>Yeah, that lol</p>",
        "id": 265362310,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1639776136
    },
    {
        "content": "<p>Basically what the whispering in my ear said is that Scatter should be a trait for various types and user-implementable, and basically be <code>std::simd::Write</code>, and that <code>std::simd</code> should offer a couple of low-level implementation primitives for implementing Scatter with.</p>",
        "id": 265362740,
        "sender_full_name": "Jubilee",
        "timestamp": 1639776367
    },
    {
        "content": "<p>So that <code>container.scatter(indices, vector)</code> could correctly hit indices in like, B-Trees or linked lists.</p>",
        "id": 265362848,
        "sender_full_name": "Jubilee",
        "timestamp": 1639776430
    },
    {
        "content": "<p>neat idea!</p>",
        "id": 265363052,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1639776564
    },
    {
        "content": "<p>And the implementation for slices would be incredibly obvious and we'd just <strong>do it</strong> for [T], [MaybeUninit&lt;T&gt;], etc.</p>",
        "id": 265363952,
        "sender_full_name": "Jubilee",
        "timestamp": 1639777060
    },
    {
        "content": "<p>hmm, what would you do for scatter to vector of pointers? just have a separate method?</p>",
        "id": 265364249,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1639777249
    },
    {
        "content": "<p>hmm?</p>",
        "id": 265364299,
        "sender_full_name": "Jubilee",
        "timestamp": 1639777282
    },
    {
        "content": "<p><code>impl&lt;...&gt; Simd&lt;*mut T, N&gt; { pub unsafe fn scatter(self, values: Simd&lt;T, N&gt;, mask: Mask&lt;isize, N&gt;) {...} }</code></p>",
        "id": 265364473,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1639777398
    },
    {
        "content": "<p>would be the only exception, cuz it doesn't really fit into your fancy scatter trait</p>",
        "id": 265364591,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1639777456
    }
]