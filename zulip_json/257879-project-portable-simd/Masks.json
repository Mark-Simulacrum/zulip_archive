[
    {
        "content": "<p>Is there a way to use the masks in stdsimd? I see that I can generate them with comparisons, but I don't see any way that I can do conditional operations with them, or even mask things off. Perhaps I missed the intended use of them.<br>\nIn my case I'm a strong AVX-512 user so I'd want a way to express it that coerces the mask into the correct operation, but I'd suspect LLVM would be smart enough if there was a BitAnd implementation against SimdU and Masks.<br>\nI think the ideal way to express would probably be <code>Simd::choose(mask, foo + bar, baz) -&gt; Simd</code>. I feel like years ago these was a choose (or otherwise named) API that allowed this. But I don't see it in the current iteration?</p>",
        "id": 236563994,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1619637883
    },
    {
        "content": "<p>There's  branch that offers selects, <span class=\"user-mention\" data-user-id=\"356799\">@Brandon Falk</span>.</p>",
        "id": 236564641,
        "sender_full_name": "Jubilee",
        "timestamp": 1619638179
    },
    {
        "content": "<p>Ooh! That's super fresh. I'm gonna play around with the codegen for this a bit. Thanks! Anything I could do to help to push this to stabilization or testing? I do a lot of HPC on AVX-512 machines.</p>",
        "id": 236564820,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1619638250
    },
    {
        "content": "<p>By which I mean: there's a reason we haven't actually published the crate. :D There's still a bit more in-progress than we'd like to try to launch with.<br>\nI also would like to offer my sympathies to you as a future prospective user of the std::simd mask API as we are definitely going to break this several times on nightly, heh.</p>",
        "id": 236565016,
        "sender_full_name": "Jubilee",
        "timestamp": 1619638355
    },
    {
        "content": "<p>It's become something of a meme that we keep rewriting the masks design at this point.</p>",
        "id": 236565136,
        "sender_full_name": "Jubilee",
        "timestamp": 1619638406
    },
    {
        "content": "<p>all for good reasons ofc <span aria-label=\"like\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"like\">:like:</span></p>",
        "id": 236565385,
        "sender_full_name": "oliver",
        "timestamp": 1619638491
    },
    {
        "content": "<p>I probably rewrite my core code more frequently than this will change so I'm not too worred. I used stdsimd with select ~2-3 years ago and it was really amazing. For most of my day-to-day projects select is the only feature I'm missing. But for some of my more complex projects I'll definitely need scatter gather support and the like.</p>",
        "id": 236565400,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1619638495
    },
    {
        "content": "<p>As long as I have select, a way to do signed/unsigned comparisons into masks, and support for all variants of AVX-512 lanes (u8 through u64, with 512-bit vectors) I can express pretty much everything I need. LLVM codegen looks good enough at creating ternlogs and FMAs that I don't need to directly express those. I wrote an MD5 implementation in stdsimd recently and it correctly coerced everything to ternlog and was at parity with my hand-written assembly! I absolutely love this stuff. Great part is the code is still usable on some random architecture if I absolutely need it to run somewhere else.<br>\n(for people who care: <a href=\"https://gist.github.com/gamozolabs/a3940b28ced4dcfeafb94b11632307c5\">https://gist.github.com/gamozolabs/a3940b28ced4dcfeafb94b11632307c5</a>)</p>",
        "id": 236565664,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1619638603
    },
    {
        "content": "<p>Yes, for good reasons, just...!<br>\nAnd ahh, this is basically a different crate now. :D<br>\nSome... reorganization of SIMD stuff happened.</p>\n<p>There's <code>std::arch</code>, there will be <code>std::simd</code> on nightly when we get all the nightly feature guards into our code and launched into rust-lang/rust, and there was <code>packed_simd</code>, now <code>packed_simd_2</code>.</p>",
        "id": 236565728,
        "sender_full_name": "Jubilee",
        "timestamp": 1619638628
    },
    {
        "content": "<p>We've been working on this for the past ~6 months or so.</p>",
        "id": 236565777,
        "sender_full_name": "Jubilee",
        "timestamp": 1619638656
    },
    {
        "content": "<p>Oh nice, that is definitely using <code>core_simd</code>, cool.</p>",
        "id": 236566005,
        "sender_full_name": "Jubilee",
        "timestamp": 1619638747
    },
    {
        "content": "<p>Gonna write some of my... very... important WoW theorycrafting tools in simd + select branch, I'll keep an eye on how the codegen looks. I suspect since LLVM can convert some pretty convoluted manual bitmasking into the correct mask instructions, it'll easily do it with select.</p>",
        "id": 236566011,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1619638751
    },
    {
        "content": "<p>the only select instruction I can recall off the top of my head is <code>setvl</code></p>",
        "id": 236566173,
        "sender_full_name": "oliver",
        "timestamp": 1619638815
    },
    {
        "content": "<p>I'm not positive yet, but I'm pretty sure select is the only operation we need to implement for masks</p>",
        "id": 236566205,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619638829
    },
    {
        "content": "<p>I love seeing that there's horizontal adds, maxes, etc. I always manually implement that. Rotates might be nice (probably in some branch). I had no idea this was so actively developed that I should probably poke around branches.</p>",
        "id": 236566220,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1619638833
    },
    {
        "content": "<p>Part of our issue has been \"how to handle masks and how much we trust LLVM codegen to paper over architectural differences\" so your continued feedback on this and just \"yeah, this is what I expect good codegen to look like <code>${snippet_of_disasm}</code>\" is good.</p>",
        "id": 236566273,
        "sender_full_name": "Jubilee",
        "timestamp": 1619638858
    },
    {
        "content": "<p>AVX-512 has a million mask instructions but they all seem to boil down to select + another operation</p>",
        "id": 236566279,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619638860
    },
    {
        "content": "<p>I would suspect it should be, and should also have some pretty clean code <code>(a + b).select(mask, a - b)</code> sort of thing. I'd expect LLVM to correctly emit a <code>vpadd</code> and <code>vpsub</code> instruction with inverted masks. Or more specifically, one unconditonal, and one conditional.</p>",
        "id": 236566281,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1619638860
    },
    {
        "content": "<p>In my branch right now it would be <code>mask.select(a + b, a - b)</code> because of some trait magic!</p>",
        "id": 236566381,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619638917
    },
    {
        "content": "<p>Y'all are amazing!! &lt;3</p>",
        "id": 236566481,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1619638943
    },
    {
        "content": "<p>Awhhh. Definitely no coercing to what it should by LLVM :( <a href=\"https://gist.github.com/gamozolabs/ad053c98707017d33e8b81f6227d374a\">https://gist.github.com/gamozolabs/ad053c98707017d33e8b81f6227d374a</a></p>",
        "id": 236567699,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1619639484
    },
    {
        "content": "<p>This is AVX-512 right? I'm actually not surprised</p>",
        "id": 236567989,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619639614
    },
    {
        "content": "<p>Yeah. It should be able to generate 2 instructions. The old stdsimd from ~2017 or 2018 would generate correctly. Not sure how they implemented it, or if LLVM changed</p>",
        "id": 236568078,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1619639644
    },
    {
        "content": "<p>I have a pretty gross hack for architectures that use compressed bit masks that I think I'm seeing there</p>",
        "id": 236568086,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619639647
    },
    {
        "content": "<p>Because rustc is currently missing an intrinsic I need.</p>",
        "id": 236568119,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619639661
    },
    {
        "content": "<p>Once I add that I believe it should work as expected</p>",
        "id": 236568144,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619639675
    },
    {
        "content": "<p>What's the hack? I could try it out if I could kludge it in quick. I've got a relatively large project I plan to write today using select so it'd be a good stress test</p>",
        "id": 236568272,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1619639744
    },
    {
        "content": "<p>Alternatively I could just change the default AVX-512 mask representation and it would probably work</p>",
        "id": 236568279,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619639748
    },
    {
        "content": "<p><code>MaskX</code> are I'd imagine <code>[0xff, 0x0, 0xff]</code> sorts of things? Where <code>BitMask</code> is the AVX-512 style?</p>",
        "id": 236568394,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1619639787
    },
    {
        "content": "<p>So unlike packed_simd I use the k-register style mask instead of the SSE/AVX style</p>",
        "id": 236568399,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619639789
    },
    {
        "content": "<p>But because of the way our intrinsics work it needs to do a sign extension up to the lane width to actually use the mask, but we don't have a sign extension intrinsic yet</p>",
        "id": 236568492,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619639834
    },
    {
        "content": "<p>I see, that's why it's getting shifted over I'd imagine. LLVM I think can figure out how to generates k masks from masked operations</p>",
        "id": 236568497,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1619639836
    },
    {
        "content": "<p>So what you are seeing is LLVM can't see through my manual sign extension</p>",
        "id": 236568529,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619639852
    },
    {
        "content": "<p>Exactly</p>",
        "id": 236568566,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619639869
    },
    {
        "content": "<p>Where's the sign extension done? I see the call to the select intrinsic.</p>",
        "id": 236568724,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1619639929
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/stdsimd/blob/676956d1c650e8b27d3e9311af6ae3d28c3ba327/crates/core_simd/src/masks/bitmask.rs#L33\">https://github.com/rust-lang/stdsimd/blob/676956d1c650e8b27d3e9311af6ae3d28c3ba327/crates/core_simd/src/masks/bitmask.rs#L33</a></p>",
        "id": 236568977,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619640022
    },
    {
        "content": "<p>I see, so this takes in a mask int 0x5 and produces <code>[0xf, 0, 0xf]</code> for a 3-vector of 4-bit values</p>",
        "id": 236569149,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1619640087
    },
    {
        "content": "<p>Yeah exactly</p>",
        "id": 236569175,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619640100
    },
    {
        "content": "<p>It should just use the LLVM <code>sext</code> instruction to do that, which would allow optimization</p>",
        "id": 236569242,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619640124
    },
    {
        "content": "<p>Select directly generates the LLVM simd select which expects the mask format? It's not generic over kmask-style?</p>",
        "id": 236569501,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1619640231
    },
    {
        "content": "<p>LLVM select takes &lt;i1 x N&gt; which doesn't really have a particular layout.  But the rustc intrinsics take &lt;iM x N&gt; where M is the bit width of the lane</p>",
        "id": 236570356,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619640621
    },
    {
        "content": "<p>We could expose a whole secondary set of intrinsics that use a single integer as a k-style mask, but it would be easier to just expose a function that sign extends</p>",
        "id": 236570538,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619640696
    },
    {
        "content": "<p>And let LLVM optimize out the back-to-back sign extension and truncation</p>",
        "id": 236570585,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619640722
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/Masks/near/236568119\">said</a>:</p>\n<blockquote>\n<p>Because rustc is currently missing an intrinsic I need.</p>\n</blockquote>\n<p>what intrinsic are you missing?</p>",
        "id": 236572024,
        "sender_full_name": "Jubilee",
        "timestamp": 1619641312
    },
    {
        "content": "<p><code>simd_sext</code>?</p>",
        "id": 236572071,
        "sender_full_name": "Jubilee",
        "timestamp": 1619641324
    },
    {
        "content": "<p>OK~</p>",
        "id": 236572145,
        "sender_full_name": "Jubilee",
        "timestamp": 1619641350
    },
    {
        "content": "<p>It's a little more specific than that. Right now we have <code>simd_bitmask</code>, which takes a mask and creates an integer</p>",
        "id": 236572172,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619641361
    },
    {
        "content": "<p>We need something that takes an integer and creates a mask</p>",
        "id": 236572191,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619641372
    },
    {
        "content": "<p>So it's a <code>bitcast</code> followed by a <code>sext</code></p>",
        "id": 236572231,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619641388
    },
    {
        "content": "<p>ahh OK.</p>",
        "id": 236572244,
        "sender_full_name": "Jubilee",
        "timestamp": 1619641392
    },
    {
        "content": "<p><code>simd_expand_bitmask</code>? Idk</p>",
        "id": 236572312,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619641424
    },
    {
        "content": "<p>Hmm I might be able to persuade it to do sext properly without an intrinsic.<br>\nBut I noted it in <a href=\"https://github.com/rust-lang/stdsimd/issues/46\">https://github.com/rust-lang/stdsimd/issues/46</a> anyways</p>",
        "id": 236572667,
        "sender_full_name": "Jubilee",
        "timestamp": 1619641565
    },
    {
        "content": "<p>I don't think it's possible because we don't have any i1 type in rust</p>",
        "id": 236572735,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619641597
    },
    {
        "content": "<p>Hmm, I think it's the loop or just, the multiple sets it can't get past. Might be really hard without a kmask simd select intrinsic</p>",
        "id": 236574219,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1619642287
    },
    {
        "content": "<p>yeah internally LLVM uses an <code>i1</code> type for a lot of things like this.</p>",
        "id": 236574311,
        "sender_full_name": "Jubilee",
        "timestamp": 1619642335
    },
    {
        "content": "<p>Hmm, I'm scared that LLVM is not quite understanding the bit extraction. I wrote a different version with much better code generation, but it's still bad.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">mask</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"k\">crate</span>::<span class=\"n\">SimdI32</span><span class=\"o\">&lt;</span><span class=\"mi\">16</span><span class=\"o\">&gt;&gt;</span>::<span class=\"n\">from_array</span><span class=\"p\">([</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">(</span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"mi\">31</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"mi\">31</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">(</span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"mi\">31</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"mi\">31</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">(</span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"mi\">31</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"mi\">31</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">(</span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"mi\">31</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"mi\">31</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">(</span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"mi\">31</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"mi\">31</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">(</span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"mi\">31</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"mi\">31</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">(</span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"mi\">31</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"mi\">31</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">(</span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"mi\">31</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"mi\">7</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"mi\">31</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">(</span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"mi\">31</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"mi\">31</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">(</span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"mi\">31</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"mi\">9</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"mi\">31</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">(</span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"mi\">31</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"mi\">31</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">(</span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"mi\">31</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"mi\">11</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"mi\">31</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">(</span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"mi\">31</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"mi\">12</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"mi\">31</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">(</span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"mi\">31</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"mi\">13</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"mi\">31</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">(</span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"mi\">31</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"mi\">14</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"mi\">31</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">(</span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"mi\">31</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"mi\">15</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"mi\">31</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">])};</span><span class=\"w\"></span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"objdump-nasm\"><pre><span></span><code><span class=\"mh\">0000000000000000</span> <span class=\"p\">&lt;</span><span class=\"nf\">stdsimd_test::add_or_sub</span><span class=\"p\">&gt;:</span>\n<span class=\"x\">   0:   48 81 ec b8 00 00 00    sub    rsp,0xb8</span>\n<span class=\"x\">   7:   62 f1 fe 48 7f 0c 24    vmovdqu64 ZMMWORD PTR [rsp],zmm1</span>\n<span class=\"x\">   e:   62 f1 7c 48 11 44 24    vmovups ZMMWORD PTR [rsp+0x40],zmm0</span>\n<span class=\"x\">  15:   01</span>\n<span class=\"x\">  16:   c5 f8 77                vzeroupper</span>\n<span class=\"x\">  19:   e8 00 00 00 00          call   1e &lt;stdsimd_test::add_or_sub+0x1e&gt;</span>\n<span class=\"x\">  1e:   62 f2 7d 48 7c c0       vpbroadcastd zmm0,eax</span>\n<span class=\"x\">  24:   62 f2 7d 48 47 05 00    vpsllvd zmm0,zmm0,ZMMWORD PTR [rip+0x0]        # 2e &lt;stdsimd_test::add_or_sub+0x2e&gt;</span>\n<span class=\"x\">  2b:   00 00 00</span>\n<span class=\"x\">  2e:   62 f3 75 48 25 c9 ff    vpternlogd zmm1,zmm1,zmm1,0xff</span>\n<span class=\"x\">  35:   62 f1 7d 48 66 c9       vpcmpgtd k1,zmm0,zmm1</span>\n<span class=\"x\">  3b:   c5 f9 ef c0             vpxor  xmm0,xmm0,xmm0</span>\n<span class=\"x\">  3f:   62 f1 fe 48 6f 0c 24    vmovdqu64 zmm1,ZMMWORD PTR [rsp]</span>\n<span class=\"x\">  46:   62 f1 7d 49 fa c9       vpsubd zmm1{k1},zmm0,zmm1</span>\n<span class=\"x\">  4c:   62 f1 75 48 fe 44 24    vpaddd zmm0,zmm1,ZMMWORD PTR [rsp+0x40]</span>\n<span class=\"x\">  53:   01</span>\n<span class=\"x\">  54:   48 81 c4 b8 00 00 00    add    rsp,0xb8</span>\n<span class=\"x\">  5b:   c3                      ret</span>\n</code></pre></div>",
        "id": 236583253,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1619645052
    },
    {
        "content": "<p>It effectively now is a broadcast of the mask into a register, then a parallel sign extension of each lane... lol</p>",
        "id": 236583337,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1619645082
    },
    {
        "content": "<p>There really is no workaround until we get the sign extension intrinsic into rustc (which isn't really a big deal)</p>",
        "id": 236583487,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619645122
    },
    {
        "content": "<p>Would LLVM understand the bit extraction at that point? Because I think for these levels of unrolling it starts being a bit unreasonable. I'm a bit afraid that the issue is not just the sign extension, but also the bit extraction.</p>",
        "id": 236583615,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1619645167
    },
    {
        "content": "<p>LLVM will understand it because it won't be a \"bit extraction\" it will be a conversion of i1 to i16 and back to i1, which is trivial to optimize</p>",
        "id": 236583704,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619645216
    },
    {
        "content": "<p>A relatively simply (but a bit boilerplatey) workaround for now would be to use <code>_m512_mask_set1_epi32(mask, !0)</code> to convert a mask into a vector of i32s</p>",
        "id": 236583773,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1619645249
    },
    {
        "content": "<p>Wait a minute, am I missing something really obvious?</p>",
        "id": 236584891,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1619645703
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"c1\">// select</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"p\">(</span><span class=\"k\">crate</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">simd_select</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">m</span>: <span class=\"nc\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">a</span>: <span class=\"nc\">U</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span>: <span class=\"nc\">U</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">U</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"p\">(</span><span class=\"k\">crate</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">simd_select_bitmask</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">m</span>: <span class=\"nc\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">a</span>: <span class=\"nc\">U</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span>: <span class=\"nc\">U</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">U</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"cp\">#[inline]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">select</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">true_values</span>: <span class=\"nc\">crate</span>::<span class=\"n\">SimdU32</span><span class=\"o\">&lt;</span><span class=\"mi\">16</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">false_values</span>: <span class=\"nc\">crate</span>::<span class=\"n\">SimdU32</span><span class=\"o\">&lt;</span><span class=\"mi\">16</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">crate</span>::<span class=\"n\">SimdU32</span><span class=\"o\">&lt;</span><span class=\"mi\">16</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"k\">crate</span>::<span class=\"n\">masks</span>::<span class=\"n\">ToBitMask</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">crate</span>::<span class=\"n\">intrinsics</span>::<span class=\"n\">simd_select_bitmask</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">to_bitmask</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">u16</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">true_values</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">false_values</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>This works on <code>rustc 1.53.0-nightly (42816d61e 2021-04-24)</code><br>\nIdk how new this intrinsic is, but there's just a straight up <code>simd_select_bitmask</code> intrinsic which is intererpreted perfectly by LLVM.</p>\n<div class=\"codehilite\" data-code-language=\"objdump-nasm\"><pre><span></span><code><span class=\"mh\">0000000000000000</span> <span class=\"p\">&lt;</span><span class=\"nf\">stdsimd_test::add_or_sub</span><span class=\"p\">&gt;:</span>\n<span class=\"x\">   0:   48 81 ec b8 00 00 00    sub    rsp,0xb8</span>\n<span class=\"x\">   7:   62 f1 7c 48 11 0c 24    vmovups ZMMWORD PTR [rsp],zmm1</span>\n<span class=\"x\">   e:   62 f1 fe 48 7f 44 24    vmovdqu64 ZMMWORD PTR [rsp+0x40],zmm0</span>\n<span class=\"x\">  15:   01</span>\n<span class=\"x\">  16:   c5 f8 77                vzeroupper</span>\n<span class=\"x\">  19:   e8 00 00 00 00          call   1e &lt;stdsimd_test::add_or_sub+0x1e&gt;</span>\n<span class=\"x\">  1e:   c5 fb 92 c8             kmovd  k1,eax</span>\n<span class=\"x\">  22:   c5 f9 ef c0             vpxor  xmm0,xmm0,xmm0</span>\n<span class=\"x\">  26:   62 f1 fe 48 6f 0c 24    vmovdqu64 zmm1,ZMMWORD PTR [rsp]</span>\n<span class=\"x\">  2d:   62 f1 7d 48 fa c1       vpsubd zmm0,zmm0,zmm1</span>\n<span class=\"x\">  33:   62 f1 7d 49 6f c1       vmovdqa32 zmm0{k1},zmm1</span>\n<span class=\"x\">  39:   62 f1 7d 48 fe 44 24    vpaddd zmm0,zmm0,ZMMWORD PTR [rsp+0x40]</span>\n<span class=\"x\">  40:   01</span>\n<span class=\"x\">  41:   48 81 c4 b8 00 00 00    add    rsp,0xb8</span>\n<span class=\"x\">  48:   c3                      ret</span>\n</code></pre></div>",
        "id": 236584955,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1619645735
    },
    {
        "content": "<p>That's a good point, there is that one, we might be able to use it in the meantime, though I don't personally want to use it to perform the select in the end</p>",
        "id": 236585327,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619645954
    },
    {
        "content": "<p>Just for code cleanliness/uniformity?</p>",
        "id": 236585494,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1619646051
    },
    {
        "content": "<p>Yeah, more or less.  Though I'd have to look to see what else we actually use masks for, it might actually be fine.</p>",
        "id": 236585595,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619646123
    },
    {
        "content": "<p>Optionally it could be used in only one place for <code>to_int()</code> and it could be used to bitmask select between !0 and 0, generating the standard SSE-style mask. I would imagine LLVM would trivially optimize that. I'm gonna test it</p>",
        "id": 236585707,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1619646185
    },
    {
        "content": "<p>Wow, yeah, look at this codegen.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"cp\">#[inline]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">to_int</span><span class=\"o\">&lt;</span><span class=\"n\">V</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">V</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">V</span>: <span class=\"nb\">Default</span> <span class=\"o\">+</span><span class=\"w\"> </span><span class=\"nb\">AsMut</span><span class=\"o\">&lt;</span><span class=\"p\">[</span><span class=\"n\">T</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">LANES</span><span class=\"p\">]</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">T</span>: <span class=\"nb\">From</span><span class=\"o\">&lt;</span><span class=\"kt\">i8</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">ones</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">V</span>::<span class=\"n\">default</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">ones</span><span class=\"p\">.</span><span class=\"n\">as_mut</span><span class=\"p\">().</span><span class=\"n\">iter_mut</span><span class=\"p\">().</span><span class=\"n\">for_each</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">x</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">T</span>::<span class=\"n\">from</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">));</span><span class=\"w\"></span>\n\n<span class=\"w\">        </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"k\">crate</span>::<span class=\"n\">intrinsics</span>::<span class=\"n\">simd_select_bitmask</span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">u16</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">ones</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">V</span>::<span class=\"n\">default</span><span class=\"p\">())</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"objdump-nasm\"><pre><span></span><code><span class=\"mh\">0000000000000000</span> <span class=\"p\">&lt;</span><span class=\"nf\">stdsimd_test::add_or_sub</span><span class=\"p\">&gt;:</span>\n<span class=\"x\">   0:   c5 fb 92 cf             kmovd  k1,edi</span>\n<span class=\"x\">   4:   c5 e9 ef d2             vpxor  xmm2,xmm2,xmm2</span>\n<span class=\"x\">   8:   62 f1 6d 48 fa d1       vpsubd zmm2,zmm2,zmm1</span>\n<span class=\"x\">   e:   62 f1 7d 49 6f d1       vmovdqa32 zmm2{k1},zmm1</span>\n<span class=\"x\">  14:   62 f1 6d 48 fe c0       vpaddd zmm0,zmm2,zmm0</span>\n<span class=\"x\">  1a:   c3                      ret</span>\n</code></pre></div>\n<p>Gonna be hard to beat that!</p>",
        "id": 236586645,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1619646742
    },
    {
        "content": "<p>Good call on using <code>simd_select_bitmask</code>, that's basically what the intrinsic needs to do (the intrinsic will be slightly cleaner, but this is a good stopgap)</p>",
        "id": 236586735,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619646820
    },
    {
        "content": "<p>The only hard part will be plumbing the <code>u16</code>, as <code>simd_select_bitmask</code> has strict width requirements that must match the vector, and the <code>self.0</code> must be cast to it. The current code doesn't have the information I don't think (this would compiler panic outside of my <code>u32x16</code> test, as the <code>u16</code> only matches <code>XXXx16</code> right now</p>",
        "id": 236586838,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1619646867
    },
    {
        "content": "<p>I just now realize that when you mean sign extend, you mean the vectorized version. For some reason I thought you meant a scalar sign extension intrinsic, combined with the loop that was used prior in <code>to_int</code>. The loop and scalar shifts was where I was scared.</p>",
        "id": 236587009,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1619646975
    },
    {
        "content": "<p>Oh gotcha, yeah, definitely on vectors</p>",
        "id": 236587100,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619647032
    },
    {
        "content": "<p>How would you hazard I best get the <code>u&lt;LANES&gt;</code> type for this function?</p>",
        "id": 236587224,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1619647113
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">        </span><span class=\"n\">require</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"c1\">// Allow masks for vectors with fewer than 8 elements to be</span>\n<span class=\"w\">            </span><span class=\"c1\">// represented with a u8 or i8.</span>\n<span class=\"w\">            </span><span class=\"n\">m_len</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"n\">v_len</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">m_len</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">v_len</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"s\">\"mismatched lengths: mask length `{}` != other vector length `{}`\"</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">m_len</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">v_len</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Looks like we need to provide a bitmask of &lt;=8 bits for &lt;=LANES, but for all other LANES it must be _exact_</p>",
        "id": 236587473,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1619647252
    },
    {
        "content": "<p>Yeah, that's actually a bit of a problem now that I think about it</p>",
        "id": 236588313,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619647733
    },
    {
        "content": "<p>Part of the problem is that rustc is unnecessarily strict</p>",
        "id": 236588366,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619647765
    },
    {
        "content": "<p>about what?</p>",
        "id": 236588867,
        "sender_full_name": "Jubilee",
        "timestamp": 1619648053
    },
    {
        "content": "<p>requiring the bitmask to be the exact same width as the number of lanes</p>",
        "id": 236588913,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619648084
    },
    {
        "content": "<p>ahh.</p>",
        "id": 236588925,
        "sender_full_name": "Jubilee",
        "timestamp": 1619648093
    },
    {
        "content": "<p>but also, there's the overarching problem of not being able to specify the bitmask type generically, anyway</p>",
        "id": 236588962,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619648110
    },
    {
        "content": "<p>right.</p>",
        "id": 236588989,
        "sender_full_name": "Jubilee",
        "timestamp": 1619648119
    },
    {
        "content": "<p>okay I think I can go back and change how <code>ToBitMask</code> is implemented to fix all of this</p>",
        "id": 236590270,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619648929
    },
    {
        "content": "<p>ahaha</p>",
        "id": 236590279,
        "sender_full_name": "Jubilee",
        "timestamp": 1619648939
    },
    {
        "content": "<p>Oooo</p>",
        "id": 236590288,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1619648946
    },
    {
        "content": "<p>(sorry for the big bother, but I have a project I wanted to start today and I realllllly want to be done writing AVX-512 specific code, as it's not the most user-friendly :D)</p>",
        "id": 236590333,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1619648980
    },
    {
        "content": "<p>and if we change the publicly exposed bitmasks to arrays of <code>u8</code>s we can potentially keep this \"stable\" by changing the implementation in the long term to implement over all bit masks and not just our select few</p>",
        "id": 236590405,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619649006
    },
    {
        "content": "<p>if const generics makes progress in that direction</p>",
        "id": 236590426,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619649024
    },
    {
        "content": "<p>I have a specialized implementation if you want me to PR it. Kinda nasty though</p>",
        "id": 236591123,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1619649453
    },
    {
        "content": "<p>So what exactly are you thinking of doing, Caleb?</p>",
        "id": 236591125,
        "sender_full_name": "Jubilee",
        "timestamp": 1619649454
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"356799\">Brandon Falk</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/Masks/near/236591123\">said</a>:</p>\n<blockquote>\n<p>I have a specialized implementation if you want me to PR it. Kinda nasty though</p>\n</blockquote>\n<p>Oh?</p>",
        "id": 236591225,
        "sender_full_name": "Jubilee",
        "timestamp": 1619649504
    },
    {
        "content": "<p>Added <code>to_int()</code> and <code>select()</code> specialization for 2, 4, 8, 16, 32</p>",
        "id": 236591244,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1619649521
    },
    {
        "content": "<p>Well let me play around a bit, I want to perhaps try to work this into the mask PR</p>",
        "id": 236591266,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619649540
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"fm\">macro_rules!</span><span class=\"w\"> </span><span class=\"n\">impl_to_int</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"cp\">$bits</span>:<span class=\"nc\">expr</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"cp\">$vecmaskty</span>:<span class=\"nc\">ty</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">BitMask</span><span class=\"o\">&lt;</span><span class=\"cp\">$bits</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"cp\">#[inline]</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">to_int</span><span class=\"o\">&lt;</span><span class=\"n\">V</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">V</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"n\">V</span>: <span class=\"nb\">Default</span> <span class=\"o\">+</span><span class=\"w\"> </span><span class=\"nb\">AsMut</span><span class=\"o\">&lt;</span><span class=\"p\">[</span><span class=\"n\">T</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"cp\">$bits</span><span class=\"p\">]</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"n\">T</span>: <span class=\"nb\">From</span><span class=\"o\">&lt;</span><span class=\"kt\">i8</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">ones</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">V</span>::<span class=\"n\">default</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"n\">ones</span><span class=\"p\">.</span><span class=\"n\">as_mut</span><span class=\"p\">().</span><span class=\"n\">iter_mut</span><span class=\"p\">().</span><span class=\"n\">for_each</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">x</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">T</span>::<span class=\"n\">from</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">));</span><span class=\"w\"></span>\n\n<span class=\"w\">                </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"k\">crate</span>::<span class=\"n\">intrinsics</span>::<span class=\"n\">simd_select_bitmask</span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">                        </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"cp\">$vecmaskty</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">ones</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">V</span>::<span class=\"n\">default</span><span class=\"p\">())</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"n\">impl_to_int</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"n\">impl_to_int</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"n\">impl_to_int</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"n\">impl_to_int</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"mi\">16</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">u16</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"n\">impl_to_int</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"mi\">32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n<p>It's this at the core, and then this bubbles up to <code>select()</code> and <code>to_int()</code> which have to be specialized to invoke these. I used macros at each level</p>",
        "id": 236591294,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1619649563
    },
    {
        "content": "<p>I was definitely hoping to avoid specializing select (and was thinking about doing the same for shuffle)</p>",
        "id": 236591295,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619649563
    },
    {
        "content": "<p>For sure!</p>",
        "id": 236591301,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1619649573
    },
    {
        "content": "<p>Oh yeah, also having select marked <code>#[inline]</code> helped a bit during some tests, which it currently is not. I had the code hacked up a lot when I was doing early testing and it was necessary to avoid a call to select. Since we implement it directly on the <code>$mask</code> I think it's necessary.</p>",
        "id": 236591421,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1619649637
    },
    {
        "content": "<p>Whoops that's definitely a bug</p>",
        "id": 236591547,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619649725
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"356799\">Brandon Falk</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/Masks/near/236591421\">said</a>:</p>\n<blockquote>\n<p>Oh yeah, also having select marked <code>#[inline]</code> helped a bit during some tests, which it currently is not. I had the code hacked up a lot when I was doing early testing and it was necessary to avoid a call to select. Since we implement it directly on the <code>$mask</code> I think it's necessary.</p>\n</blockquote>\n<p>Yeah, Rust needs you to use <code>#[inline]</code> everywhere right now for good results inside a SIMD function because uhhh the compiler doesn't understand registers.</p>",
        "id": 236592448,
        "sender_full_name": "Jubilee",
        "timestamp": 1619650289
    },
    {
        "content": "<p>Lol! Yeah, that definitely seems to be the case. Anything with a generic automatically includes the IR information for it to treat it as if it's inline thought right?</p>",
        "id": 236592716,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1619650451
    },
    {
        "content": "<p>That's true but if that helps codegen is a different story</p>",
        "id": 236593300,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619650856
    },
    {
        "content": "<p>The inline attribute tells llvm that you'd rather it inline the function than not as well</p>",
        "id": 236593345,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619650891
    },
    {
        "content": "<p>So the plan is to change the internals of the bitmask to a <code>[u8; X]</code>? Which will also solve the future &gt;512-bit concerns? Or did I misread</p>",
        "id": 236597172,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1619653388
    },
    {
        "content": "<p>Yeah, that is the plan</p>",
        "id": 236599156,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619654761
    },
    {
        "content": "<p>I'm going to take a look right now</p>",
        "id": 236599224,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619654785
    },
    {
        "content": "<p>You think this fixes the <code>to_int()</code> stuff? What's the advantage to the array?</p>",
        "id": 236599930,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1619655316
    },
    {
        "content": "<p>The reasoning for the array is that it supports much larger lane counts</p>",
        "id": 236600348,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619655630
    },
    {
        "content": "<p>an array also supports non-power-of-2 lane counts</p>",
        "id": 236606667,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1619660758
    },
    {
        "content": "<p>though, for SimpleV at the ISA level, we just throw everything in a 64-bit integer (or a vector of condition registers)</p>",
        "id": 236606831,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1619660860
    },
    {
        "content": "<p>I got bitmasks \"working\" with a suggestion that looked similar to <span class=\"user-mention\" data-user-id=\"229517\">@Jacob Lifshay</span>'s suggestion.  It uses a <code>Mask</code> trait that has an associated type.  Fortunately that associated type can be generated with <code>const_evaluatable_unchecked</code> in the future, so only the <code>Mask</code> trait bleeds into the interface, which isn't too bad</p>",
        "id": 236609758,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619663214
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"356799\">@Brandon Falk</span> I just updated the <code>feature/select</code> branch if you want to give it a shot and let me know how well it optimizes.  It uses your <code>simd_select_bitmask</code> trick, but it has a few <code>transmute_copy</code> to workaround some of our intrinsic limitations.  I'm hoping they don't get in the way of any optimizations.</p>",
        "id": 236613267,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619666619
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"312331\">@Caleb Zulawski</span> Code gen looks fantastic! I am getting a few build warnings with my basic setup.</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>pleb@polar ~/stdsimd_test $ cargo build --release\nwarning: unused macro definition\n   --&gt; /home/pleb/stdsimd/crates/core_simd/src/reduction.rs:105:1\n    |\n105 | / macro_rules! impl_full_mask_reductions {\n106 | |     { $name:ident, $bits_ty:ident } =&gt; {\n107 | |         impl&lt;T: crate::Mask, const LANES: usize&gt; $name&lt;T, LANES&gt;\n108 | |         where\n...   |\n121 | |     }\n122 | | }\n    | |_^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: function is never used: `simd_reduce_all`\n  --&gt; /home/pleb/stdsimd/crates/core_simd/src/intrinsics.rs:72:5\n   |\n72 |     pub(crate) fn simd_reduce_all&lt;T&gt;(x: T) -&gt; bool;\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: function is never used: `simd_reduce_any`\n  --&gt; /home/pleb/stdsimd/crates/core_simd/src/intrinsics.rs:73:5\n   |\n73 |     pub(crate) fn simd_reduce_any&lt;T&gt;(x: T) -&gt; bool;\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: 3 warnings emitted\n\n   Compiling stdsimd_test v0.1.0 (/home/pleb/stdsimd_test)\n    Finished release [optimized] target(s) in 0.14s\n</code></pre></div>",
        "id": 236732475,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1619725008
    },
    {
        "content": "<p>well those are just unused warnings</p>",
        "id": 236732581,
        "sender_full_name": "Lokathor",
        "timestamp": 1619725055
    },
    {
        "content": "<p>Yeah, the logic on when they're used is relatively complicated too, I should probably just slap allow(unused) on those</p>",
        "id": 236732698,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619725095
    },
    {
        "content": "<p>Glad the codegen looks good</p>",
        "id": 236732714,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619725105
    },
    {
        "content": "<p>I was slightly concerned the transmute_copys would turn into memcpys</p>",
        "id": 236732758,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619725125
    },
    {
        "content": "<p>Yeah, those look like they come through clean. I hopefully will have time today to work on my more complex use of stdsimd which will stress some of these things. The only place where I start to get concerned about things like transmute copy is when they affect the thresholds for inlining, or other unrolling optimizations. (Eg. by having more stuff going on, the compiler might not inline enough stuff to DCE it out). But, I suspect the copies will never be a problem</p>",
        "id": 236736050,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1619726555
    },
    {
        "content": "<p>Definitely going to play around a lot with it and give feedback. stdsimd is arguably the best way to write vectorized code, especially arch agnostic, so I hope to put a decent amount of time into it (eg. scatters and gathers), as I think it'll be my standard HPC dev env in a few months!</p>",
        "id": 236736219,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1619726610
    },
    {
        "content": "<p>Also, slight side note. Does anyone understand how Rust calling conventions work with SIMD (specifically 512-bit). The code generation is so bad compared to <code>extern</code>. <a href=\"https://rust.godbolt.org/z/WMhrrT834\">https://rust.godbolt.org/z/WMhrrT834</a> . It seems Rust calling convention requires them to be passed in memory? :(</p>",
        "id": 236736838,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1619726860
    },
    {
        "content": "<p>They are passed by reference for safety.  The reason is because the caller and callee may have different target feature sets which could result in different calling conventions</p>",
        "id": 236739963,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619728158
    },
    {
        "content": "<p>The idea of including the feature set in the ABI has been floated around but I think it's a large change without much support behind it</p>",
        "id": 236740231,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1619728259
    },
    {
        "content": "<p>Ah I see. Probably not a huge issue as with inlining and LTO prologues and epiloges shoudln't be a major issue anyways</p>",
        "id": 236741297,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1619728703
    }
]