[
    {
        "content": "<p>Opened SimdArray::gather PR. <a href=\"https://github.com/rust-lang/stdsimd/pull/139\">https://github.com/rust-lang/stdsimd/pull/139</a></p>",
        "id": 242804117,
        "sender_full_name": "Jubilee",
        "timestamp": 1623793652
    },
    {
        "content": "<p>interesting.</p>",
        "id": 242805363,
        "sender_full_name": "Jubilee",
        "timestamp": 1623794424
    },
    {
        "content": "<p><strong>some</strong> monomorphization failures. Fixed.</p>",
        "id": 242805672,
        "sender_full_name": "Jubilee",
        "timestamp": 1623794598
    },
    {
        "content": "<p>Cool stuff <span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span></p>",
        "id": 242819236,
        "sender_full_name": "Miguel Raz Guzmán Macedo",
        "timestamp": 1623805861
    },
    {
        "content": "<p>Question: will we now only have <code>SimdArray</code> and stop talking about SIMD vectors?</p>",
        "id": 242819258,
        "sender_full_name": "Miguel Raz Guzmán Macedo",
        "timestamp": 1623805891
    },
    {
        "content": "<p>I'm assuming that Rust does not make meaningful distinctions at the type level between a vector and an array.</p>",
        "id": 242819278,
        "sender_full_name": "Miguel Raz Guzmán Macedo",
        "timestamp": 1623805922
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246783\">Miguel Raz Guzmán Macedo</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/Scatter.2FGathers/near/242819278\">said</a>:</p>\n<blockquote>\n<p>I'm assuming that Rust does not make meaningful distinctions at the type level between a vector and an array.</p>\n</blockquote>\n<p>So, for our purposes: vector is still meaningful, because they're still using vector registers. ^^;<br>\nAnd we aren't manipulating true \"arrays\", because a SimdArray violates a specific rule about arrays: alignment. In a way that makes it safe to always turn a SimdArray into an array of the relevant type, mind, and easy to derive SimdArrays from regular arrays, but it's still overaligned.</p>\n<p>So there's no real way to talk about SIMD types without double-qualifying them, because in Rust, the native \"vector\" for which people will pattern-match in their head is Vec, so we have to say \"SIMD vector\" or \"SIMD array\" or w/e.<br>\nI chose the name SimdArray because arrays <strong>are</strong> our closest comparison point.</p>",
        "id": 242820981,
        "sender_full_name": "Jubilee",
        "timestamp": 1623807761
    },
    {
        "content": "<p>one example difference: arrays are aligned to their element alignment regardless of total size, while simd values are generally aligned to their entire size.</p>",
        "id": 242822221,
        "sender_full_name": "Lokathor",
        "timestamp": 1623809133
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246783\">Miguel Raz Guzmán Macedo</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/Scatter.2FGathers/near/242819278\">said</a>:</p>\n<blockquote>\n<p>I'm assuming that Rust does not make meaningful distinctions at the type level between a vector and an array.</p>\n</blockquote>\n<p>It absolutely does.  <a href=\"https://doc.rust-lang.org/nightly/nightly-rustc/rustc_target/abi/enum.Abi.html#variant.Vector\">Different ABIs</a>, at the very least.  And <code>Array</code> is a specific thing in <a href=\"https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/sty/enum.TyKind.html#variant.Array\"><code>TyS</code></a>, but vectors aren't.</p>",
        "id": 242832329,
        "sender_full_name": "scottmcm",
        "timestamp": 1623822362
    },
    {
        "content": "<p>Does the <code>Vector</code> ABI correspond to SIMD arrays or <code>[T; N]</code>? I assume it has nothing to do with <code>Vec&lt;T&gt;</code>...?</p>",
        "id": 242833007,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1623823307
    },
    {
        "content": "<p>SIMD arrays</p>",
        "id": 242833431,
        "sender_full_name": "bjorn3",
        "timestamp": 1623823788
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/Scatter.2FGathers/near/242832329\">said</a>:</p>\n<blockquote>\n<p>And <code>Array</code> is a specific thing in <a href=\"https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/sty/enum.TyKind.html#variant.Array\"><code>TyS</code></a>, but vectors aren't.</p>\n</blockquote>\n<p>How does that work? Is <code>SimdArray</code> a lang item, or is there some attribute magic to change the ABI of the type?</p>",
        "id": 242833728,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1623824114
    },
    {
        "content": "<p>it's just <code>#[repr(simd)]</code>, heh.</p>",
        "id": 242836055,
        "sender_full_name": "Jubilee",
        "timestamp": 1623825524
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/Scatter.2FGathers/near/242833728\">said</a>:</p>\n<blockquote>\n<p>How does that work? Is <code>SimdArray</code> a lang item, or is there some attribute magic to change the ABI of the type?</p>\n</blockquote>\n<p>Attribute magic, <a href=\"https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.ReprFlags.html#associatedconstant.IS_SIMD\">via <code>ReprFlags</code></a>.</p>",
        "id": 242838442,
        "sender_full_name": "scottmcm",
        "timestamp": 1623827428
    },
    {
        "content": "<p>(One could certainly consider having it no longer be a <code>repr</code>, though, if the way forward ends up being that there's just one const-generic type in core that's the only way for something to be a simd vector.  I don't think there's a <em>need</em> for it to be a <code>repr</code> when people could do that as a <code>repr(transparent)</code> wrapper around a type in core if they want a custom vector type, just like they do for arrays.)</p>",
        "id": 242838569,
        "sender_full_name": "scottmcm",
        "timestamp": 1623827574
    },
    {
        "content": "<p>Something I may want to explore once your PR is in is putting <code>select</code> on the <code>Mask</code> trait, and somehow using <code>Vector</code> to indicate what can be <code>select</code>ed (not super different from how it works right now)</p>",
        "id": 243461041,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624322757
    },
    {
        "content": "<p>Dragged some discussion/comments into a single topic here. This trait was discussed a fair amount in <a href=\"#narrow/stream/257879-project-portable-simd/topic/Meeting.202021-06-21\">https://rust-lang.zulipchat.com/#narrow/stream/257879-project-portable-simd/topic/Meeting.202021-06-21</a><br>\nWe talked about using Vector as an alternate name. I'm in favor of \"document the bikeshed\", so at this point I'm happy with either tbh, as long as both names are in the commit history in case anyone sifts through git blame. :^)</p>",
        "id": 243703310,
        "sender_full_name": "Jubilee",
        "timestamp": 1624477836
    },
    {
        "content": "<p>is SimdVector on the table?</p>",
        "id": 243703654,
        "sender_full_name": "Lokathor",
        "timestamp": 1624478009
    },
    {
        "content": "<p>I think so.</p>",
        "id": 243704058,
        "sender_full_name": "Jubilee",
        "timestamp": 1624478188
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> Vector would be consistent with Mask (which we already have and may need to expand)</p>",
        "id": 243705230,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624478744
    },
    {
        "content": "<p>Which I think is part of the justification for dropping the \"Simd\"</p>",
        "id": 243705270,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624478760
    },
    {
        "content": "<p>what i absolutely dont want is for people to start calling things <code>simd::Vector</code> or some nonsense like that</p>",
        "id": 243708357,
        "sender_full_name": "Lokathor",
        "timestamp": 1624480238
    },
    {
        "content": "<p>I think people would use <code>Vector</code> unqualified, actually.</p>",
        "id": 243709788,
        "sender_full_name": "Jubilee",
        "timestamp": 1624480885
    },
    {
        "content": "<p>Agreed</p>",
        "id": 243710300,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624481121
    },
    {
        "content": "<p>Particularly because SIMD would usually only exist in specific parts of a program and not spread through the interfaces, probably</p>",
        "id": 243710373,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624481157
    },
    {
        "content": "<p>I think I <strong>would</strong> see <code>simd::Vector</code> but I think we're going to see that anyways, imo, because some people just write all their code like that, no matter what, so we'd have to choose between <code>simd::SimdVector</code> and <code>simd::Vector</code>.</p>",
        "id": 243711438,
        "sender_full_name": "Jubilee",
        "timestamp": 1624481565
    },
    {
        "content": "<p>i think SimdVector/Vector would be more common, given that that's what stuff like r-a autoimport will give you. i also think having to type it as simd::SimdVector would discourage that approach</p>",
        "id": 243712872,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1624482327
    },
    {
        "content": "<p>right. It's also not like <code>io::Error</code> where there's a bunch of different <code>Error</code> types and the path is particularly relevant, rather it would be an eccentric but unique name for std.</p>",
        "id": 243714615,
        "sender_full_name": "Jubilee",
        "timestamp": 1624483222
    },
    {
        "content": "<p>Thoughts on removing <code>LanesAtMost32</code> and using <code>Vector</code> for that?</p>",
        "id": 243736131,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624502707
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span> I'm playing around with your implementation and I'm pretty sure the cycles come from using default implementations for all of the functions</p>",
        "id": 243736217,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624502793
    },
    {
        "content": "<p>And from having various <code>where</code> clauses on the trait itself rather than on the implementations</p>",
        "id": 243736235,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624502842
    },
    {
        "content": "<p>I kinda wanted to be able to use that re: defaults. <span aria-label=\"weary\" class=\"emoji emoji-1f629\" role=\"img\" title=\"weary\">:weary:</span><br>\nActually I suppose it's fine if we just require scatter_select and gather_select to be implemented.</p>",
        "id": 243737006,
        "sender_full_name": "Jubilee",
        "timestamp": 1624504060
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/SimdArray.20.2F.20Vector/near/243736131\">said</a>:</p>\n<blockquote>\n<p>Thoughts on removing <code>LanesAtMost32</code> and using <code>Vector</code> for that?</p>\n</blockquote>\n<p>I'm a little wary of doing this outright, since we want some kind of sealing trait period, but it'd depend on the thing in question.</p>",
        "id": 243737331,
        "sender_full_name": "Jubilee",
        "timestamp": 1624504541
    },
    {
        "content": "<p>I don't think we need one top level public sealing trait?</p>",
        "id": 243737387,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624504603
    },
    {
        "content": "<p>but in this case I'm suggesting <code>Vector</code> would be sealed directly</p>",
        "id": 243737403,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624504634
    },
    {
        "content": "<p>Oh okay.<br>\nSounds plausible.</p>",
        "id": 243737408,
        "sender_full_name": "Jubilee",
        "timestamp": 1624504647
    },
    {
        "content": "<p>The benefit of not using default implementations is you can then check the conditions (bounds, really) at implementation time and not have it as part of the trait at all</p>",
        "id": 243737616,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624504934
    },
    {
        "content": "<p>Still need a supertrait bounding <code>{SimdArray,Vector}</code> internally so as to prevent external implementers, but I suppose we're solid there.</p>",
        "id": 243737707,
        "sender_full_name": "Jubilee",
        "timestamp": 1624505115
    },
    {
        "content": "<p>yes, that's why I'm suggesting it's sealed directly</p>",
        "id": 243737719,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624505148
    },
    {
        "content": "<p>Maybe I work that out after merge because it's a fairly big change with its own set of implications?</p>",
        "id": 243737978,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624505467
    },
    {
        "content": "<p>Sounds good. I'm interested in larger refactorings based on this but I wanted to have the current diff be something contained.</p>",
        "id": 243738178,
        "sender_full_name": "Jubilee",
        "timestamp": 1624505745
    },
    {
        "content": "<p>Ok I approved the branch as-is then</p>",
        "id": 243738491,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624506137
    },
    {
        "content": "<p>( also it lets those refactorings be pursued out-of-order. )</p>",
        "id": 243738776,
        "sender_full_name": "Jubilee",
        "timestamp": 1624506514
    },
    {
        "content": "<p>or superscalar if you prefer <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 243738792,
        "sender_full_name": "Jubilee",
        "timestamp": 1624506557
    },
    {
        "content": "<p>So I was able to solve the problems using <code>const_evaluatable_checked</code> and bounds on the functions themselves, but that doesn't necessarily seem like the best option (right now, at least)</p>",
        "id": 243853814,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624573162
    },
    {
        "content": "<p>there's the option of doing this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Index</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">gather</span><span class=\"p\">(</span><span class=\"o\">..</span><span class=\"p\">.,</span><span class=\"w\"> </span><span class=\"n\">idx</span>: <span class=\"nc\">Index</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 243853905,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624573223
    },
    {
        "content": "<p>(which is how <code>to_bits</code>, etc are already handled</p>",
        "id": 243853931,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624573248
    },
    {
        "content": "<p>It seems like without <code>const_evaluatable_checked</code> there's simply no way of representing relationships between const generics :)</p>",
        "id": 243853995,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624573322
    },
    {
        "content": "<p>the trait would probably end up looking something like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Scalar</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Index</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Bits</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 243854084,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624573409
    },
    {
        "content": "<p>In some ways this might actually be better than using the types directly, IMO, because there are no bounds at all (on the trait) and they're all embedded in the fact that the trait is implemented.  So if you have <code>fn (_: impl Vector)</code> everything \"just works\" once you prove your type actually implements <code>Vector</code>, which is convenient</p>",
        "id": 243854345,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624573576
    },
    {
        "content": "<p>sorry could you explain what the different index types are? An array of usize value with a length equal to the vector length i take it?</p>",
        "id": 243854395,
        "sender_full_name": "Lokathor",
        "timestamp": 1624573630
    },
    {
        "content": "<p>Then with a <code>num-traits</code>-style crate you can write something like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"o\">&lt;</span><span class=\"n\">V</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"nc\">V</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"n\">Vector</span>::<span class=\"n\">Index</span>: <span class=\"nc\">simd_traits</span>::<span class=\"n\">Usize</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 243854445,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624573676
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> exactly, it's just <code>SimdUsize&lt;LANES&gt;</code></p>",
        "id": 243854493,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624573692
    },
    {
        "content": "<p>it would be something like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">LANES</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">SimdF32</span><span class=\"o\">&lt;</span><span class=\"n\">LANES</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Scalar</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kt\">f32</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">LANES</span>: <span class=\"kt\">usize</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">LANES</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Index</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">SimdUsize</span><span class=\"o\">&lt;</span><span class=\"n\">LANES</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 243854656,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624573825
    },
    {
        "content": "<p>The downside of this is that it doesn't embed at all that <code>Index</code> is always a <code>SimdUsize&lt;...&gt;</code></p>",
        "id": 243854806,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624573948
    },
    {
        "content": "<p>As a comparison, the \"right\" way with <code>const_evaluatable_checked</code> would be:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Scalar</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">LANES</span>: <span class=\"kt\">usize</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">gather</span><span class=\"p\">(</span><span class=\"o\">..</span><span class=\"p\">.,</span><span class=\"w\"> </span><span class=\"n\">idx</span>: <span class=\"nc\">SimdUsize</span><span class=\"o\">&lt;</span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"bp\">Self</span>::<span class=\"n\">LANES</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"n\">SimdUsize</span><span class=\"o\">&lt;</span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"bp\">Self</span>::<span class=\"n\">LANES</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"o\">&gt;</span>: <span class=\"nc\">Vector</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 243854987,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624574096
    },
    {
        "content": "<p>(alternatively I think you can put that <code>where</code> clause on the entire trait, not just the fn, but not sure it makes a big difference)</p>",
        "id": 243855049,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624574158
    },
    {
        "content": "<p>Personally I think the <code>const_evaluatable_checked</code> way is the right way to go but it's not really clear how the timeline of that feature lines up with us going stable</p>",
        "id": 243855172,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624574231
    },
    {
        "content": "<p>Do consumers need it?</p>",
        "id": 243855183,
        "sender_full_name": "Jubilee",
        "timestamp": 1624574248
    },
    {
        "content": "<p>well, hard to say, it ends up in the bounds</p>",
        "id": 243855196,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624574267
    },
    {
        "content": "<p>even if it was allowed in core I don't think you could prove the bounds without it</p>",
        "id": 243855285,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624574317
    },
    {
        "content": "<p>so it would prevent it being used in generics, defeating the purpose, lol</p>",
        "id": 243855299,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624574335
    },
    {
        "content": "<p>hmm.</p>",
        "id": 243855314,
        "sender_full_name": "Jubilee",
        "timestamp": 1624574357
    },
    {
        "content": "<p>one option that's on the table is implement the trait, implement the functions directly on the types as well, and decide later whether the trait can be stabilized, should be changed, etc</p>",
        "id": 243855394,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624574407
    },
    {
        "content": "<p>I wouldn't mind inconveniencing some consumers.</p>",
        "id": 243855399,
        "sender_full_name": "Jubilee",
        "timestamp": 1624574414
    },
    {
        "content": "<p>but</p>",
        "id": 243855403,
        "sender_full_name": "Jubilee",
        "timestamp": 1624574419
    },
    {
        "content": "<p>if we needed to get this out the door _today_ I feel like the best option would be to implement the fns directly on the types and then expose this trait in a crate and just update it to use <code>const_evaluatable_checked</code> when that becomes available</p>",
        "id": 243855458,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624574486
    },
    {
        "content": "<p>yeah, \"don't use a trait initially\" seems forward compatible</p>",
        "id": 243856119,
        "sender_full_name": "Lokathor",
        "timestamp": 1624575070
    },
    {
        "content": "<p>the only problem with that is right now <code>{to,from}_bitmask</code> is using a trait for the same problem (but it's confined to one relatively niche function)</p>",
        "id": 243856295,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624575227
    },
    {
        "content": "<p>and it's also something that would be solved by <code>const_evaluatable_checked</code>, as far as I can tell</p>",
        "id": 243856353,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624575248
    },
    {
        "content": "<p>and there's no way to implement it <em>at all</em> without either that or the hacky trait we have now</p>",
        "id": 243856385,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624575284
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/SimdArray.20.2F.20Vector/near/243855172\">said</a>:</p>\n<blockquote>\n<p>Personally I think the <code>const_evaluatable_checked</code> way is the right way to go but it's not really clear how the timeline of that feature lines up with us going stable</p>\n</blockquote>\n<p>when do you wanna go stable <span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span></p>",
        "id": 243856429,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1624575324
    },
    {
        "content": "<p>sometime this year? feature wont be ready<br>\nsometime next year? if a miracle happens maybe</p>",
        "id": 243856525,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1624575382
    },
    {
        "content": "<p>relaxing bounds is also forward compatible and we are on nightly, so</p>",
        "id": 243856571,
        "sender_full_name": "Jubilee",
        "timestamp": 1624575417
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"326176\">@Boxy [she/her]</span> this year would be extremely optimistic <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span> next year is actually possible (likely?), I think</p>",
        "id": 243856787,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624575570
    },
    {
        "content": "<p>yeah, agreed that we can relax bounds no problem</p>",
        "id": 243856822,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624575599
    },
    {
        "content": "<p>There's nothing particularly wrong with the hacky trait we can do now, it's the only way to do it on stable right now, but it requires treating the dependent types (the bitmasks, index types, etc) as generics as well</p>",
        "id": 243857010,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624575723
    },
    {
        "content": "<p>(in a function where the vector is generic, I mean)</p>",
        "id": 243857056,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624575753
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/SimdArray.20.2F.20Vector/near/243856787\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"326176\">Boxy [she/her]</span> this year would be extremely optimistic <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span> next year is actually possible (likely?), I think</p>\n</blockquote>\n<p>ah well guess you're wanting a miracle if you want const evaluatable checked on stable in next year :P</p>",
        "id": 243857201,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1624575850
    },
    {
        "content": "<p><a href=\"https://www.youtube.com/watch?v=_-agl0pOQfs\">https://www.youtube.com/watch?v=_-agl0pOQfs</a></p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"_-agl0pOQfs\" href=\"https://www.youtube.com/watch?v=_-agl0pOQfs\"><img src=\"https://uploads.zulipusercontent.net/e54a8206ac1932b0b95394e3cf29fa576cea1726/68747470733a2f2f692e7974696d672e636f6d2f76692f5f2d61676c30704f5166732f64656661756c742e6a7067\"></a></div>",
        "id": 243857275,
        "sender_full_name": "Jubilee",
        "timestamp": 1624575918
    },
    {
        "content": "<p>lol, yeah I'm thinking we probably should not rely on const eval checked</p>",
        "id": 243857276,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624575919
    },
    {
        "content": "<p>the \"hacky\" trait solution is actually pretty good, since it's what we're already using for bitmasks</p>",
        "id": 243857376,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624575970
    },
    {
        "content": "<p>the problem is are we going to feel like we painted ourselves into a corner in say 3 years</p>",
        "id": 243857433,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624576023
    },
    {
        "content": "<p>Just gonna channel Boxy if we need to break all our nightly users.</p>",
        "id": 243857472,
        "sender_full_name": "Jubilee",
        "timestamp": 1624576067
    },
    {
        "content": "<p>vs. are we going to stymie adoption completely by not just getting something out the door that works...</p>",
        "id": 243857473,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624576068
    },
    {
        "content": "<p>is this a \"put something in std that cant ever have a breaking change\" kind of situation<br>\nor a<br>\n\"we have a library that we'd rather not release a massive breaking change in\" kind of situation</p>",
        "id": 243857547,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1624576095
    },
    {
        "content": "<p>yeah sort of the first</p>",
        "id": 243857573,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624576113
    },
    {
        "content": "<p>we're going to be on nightly for a while, so.</p>",
        "id": 243857613,
        "sender_full_name": "Jubilee",
        "timestamp": 1624576147
    },
    {
        "content": "<p>and we can leave certain elements unstable for quite a while.</p>",
        "id": 243857618,
        "sender_full_name": "Jubilee",
        "timestamp": 1624576156
    },
    {
        "content": "<p>with const eval checked there is a decent quality-of-life improvement we can do (but the other option we have is definitely usable)</p>",
        "id": 243857624,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624576159
    },
    {
        "content": "<p>We can figure things out as we go.</p>",
        "id": 243857625,
        "sender_full_name": "Jubilee",
        "timestamp": 1624576162
    },
    {
        "content": "<p>agreed, we can also just decide to leave gather perma-unstable until that's sorted out, if we're ok with that</p>",
        "id": 243857642,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624576188
    },
    {
        "content": "<p>same goes for <code>{to,from}_bitmask</code></p>",
        "id": 243857699,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624576206
    },
    {
        "content": "<p>I guess it's also true for shuffles though that's probably going to be usable sooner</p>",
        "id": 243857725,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624576228
    },
    {
        "content": "<p><code>packed_simd</code> had some pretty strong adoption in spite of being a highly unstable and experimental nightly crate, so I think we'll also see some significant adoption imo.</p>",
        "id": 243858065,
        "sender_full_name": "Jubilee",
        "timestamp": 1624576527
    },
    {
        "content": "<p>the real problem is not maintaining some forward momentum, I think.</p>",
        "id": 243858079,
        "sender_full_name": "Jubilee",
        "timestamp": 1624576544
    },
    {
        "content": "<p>Even if it's only a little momentum.</p>",
        "id": 243858095,
        "sender_full_name": "Jubilee",
        "timestamp": 1624576557
    },
    {
        "content": "<p>I think you're right, which makes me think we should make as much as possible \"correct\" enough that we'd be confident stabilizing it relatively quickly</p>",
        "id": 243858193,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624576622
    },
    {
        "content": "<p>but I suppose if this only affects a few things like gather it's probably not a big deal</p>",
        "id": 243858216,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624576636
    },
    {
        "content": "<p>is there any major issue putting the functions directly on the types, then providing the best trait we believe we can write currently, so at least in the future the regular fns can be stabilized?</p>",
        "id": 243858315,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624576717
    },
    {
        "content": "<p>there is the inherent fns issue but that's just another big unknown</p>",
        "id": 243858349,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624576748
    },
    {
        "content": "<p>Breaks less code if people are already importing the trait.</p>",
        "id": 243858370,
        "sender_full_name": "Jubilee",
        "timestamp": 1624576780
    },
    {
        "content": "<p>only if we make the assumption that the code using the traits have no intention on going to stable when possible</p>",
        "id": 243858442,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624576812
    },
    {
        "content": "<p>but also i'm suggesting that the regular fns we design from the start to go to stable, so there's no code breaking at all</p>",
        "id": 243858499,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624576862
    },
    {
        "content": "<p>when the regular fns go stable we can still keep the trait around, it just won't be stable (yet)</p>",
        "id": 243858519,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624576890
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/SimdArray.20.2F.20Vector/near/243858442\">said</a>:</p>\n<blockquote>\n<p>only if we make the assumption that the code using the traits have no intention on going to stable when possible</p>\n</blockquote>\n<p>That's still an active choice on their part, though.</p>",
        "id": 243858681,
        "sender_full_name": "Jubilee",
        "timestamp": 1624577021
    },
    {
        "content": "<p>Maybe we aren't on the same page</p>",
        "id": 243858764,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624577052
    },
    {
        "content": "<p>Saying \"if we stabilize N, then we must also stabilize M, because the users of N want to move to stable and also use M\" means that there is no option but a single stabilization, period.</p>",
        "id": 243858794,
        "sender_full_name": "Jubilee",
        "timestamp": 1624577069
    },
    {
        "content": "<p>I'm suggesting we do both:</p>\n<ul>\n<li>Write inherent fns that have no technical barriers blocking their stability</li>\n<li>Write the trait as you imagined with the current technical limitations we have, and reevaluate it in the future</li>\n</ul>",
        "id": 243858872,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624577154
    },
    {
        "content": "<p>I think that would look quite a bit like inherent traits, but manual</p>",
        "id": 243858955,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624577208
    },
    {
        "content": "<p>I don't actually care about inherent traits, I already went over my stance independent of those, and I regret bringing them up.</p>",
        "id": 243858997,
        "sender_full_name": "Jubilee",
        "timestamp": 1624577252
    },
    {
        "content": "<p>Haha okay we can ignore them</p>",
        "id": 243859015,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624577267
    },
    {
        "content": "<p>All I am saying is that I think it's a minor inconvenience to provide regular fns <em>also</em></p>",
        "id": 243859132,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624577354
    },
    {
        "content": "<p>Because I don't see any reason to stop at scatter/gather, array conversion for example should be part of the trait as well</p>",
        "id": 243859218,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624577409
    },
    {
        "content": "<p>I'm just fairly confused at this point about what is being discussed, since I feel like we are rehashing the discussion from Monday, so I will pick up this conversation a bit later.</p>",
        "id": 243859308,
        "sender_full_name": "Jubilee",
        "timestamp": 1624577501
    },
    {
        "content": "<p>I am saying that no matter what there is a compromise in the trait, and suggesting that if we provide regular functions along with the trait that gives us an option for stabilization that doesn't rely on const eval checked</p>",
        "id": 243860843,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624578580
    },
    {
        "content": "<p>The revelation since Monday is that removing the generic parameter from SimdArray requires that compromise</p>",
        "id": 243861496,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624579012
    },
    {
        "content": "<p>We should take the longest term view with design and then stabilization.</p>\n<p>I think if we have direct methods (including ops methods) that <em>alone</em> is enough to stabilize even if a trait is added later, even if later is years later while const eval builds up.</p>",
        "id": 243866121,
        "sender_full_name": "Lokathor",
        "timestamp": 1624583796
    },
    {
        "content": "<p>The <code>wide</code> crate gets reasonable usage adoption without any ability to be generic over simd lane count or anything of that sort.</p>",
        "id": 243866221,
        "sender_full_name": "Lokathor",
        "timestamp": 1624583931
    },
    {
        "content": "<blockquote>\n<p>Breaks less code if people are already importing the trait.</p>\n</blockquote>\n<p>I think one thing here is that (if i understand right!) additional trait stuff later doesn't break old code at all, it just makes the old code not as great as it could be. But that's always going to happen anyway because the alternative is that our standard library never gets better.</p>",
        "id": 243866285,
        "sender_full_name": "Lokathor",
        "timestamp": 1624584021
    },
    {
        "content": "<p>Yeah, that's basically what I was getting at. I don't want to compromise on the trait because we're using a half complete feature, but we don't have to compromise on the regular fns at all, and we can always add more trait features in the future but we can't fix how we implemented a trait in the past</p>",
        "id": 243866474,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624584265
    },
    {
        "content": "<p>And maybe I'm being optimistic but I can see stdsimd being stabilized in a year or so because it's useful as is, but the features required for the trait could take years I think</p>",
        "id": 243866512,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624584351
    },
    {
        "content": "<p>just pointing out: historically the fact that the trait would cause compromises is why theres no trait for the numeric types. iiuc, anyway</p>",
        "id": 243866566,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1624584399
    },
    {
        "content": "<p>Yeah I agree with that.  Though we fundamentally need a trait regardless because we need to limit our lane counts</p>",
        "id": 243866592,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624584441
    },
    {
        "content": "<p>yeah, minimalism there might be for the best, though</p>",
        "id": 243866597,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1624584460
    },
    {
        "content": "<p>Everything shows up slower than expected, but the relative scale of things is often broadly correct. Likely const_eval_checked will show up several times farther in the future than stdsimd alone without it.</p>",
        "id": 243866601,
        "sender_full_name": "Lokathor",
        "timestamp": 1624584463
    },
    {
        "content": "<p>So basically the question I was asking is where do we draw the line?  I think we can trivially put things like splat or array conversions on the trait no problem</p>",
        "id": 243866732,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624584604
    },
    {
        "content": "<p>Gather requires some compromise somewhere</p>",
        "id": 243866751,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624584633
    },
    {
        "content": "<p>I think the bare minimum the trait should have the lane count and scalar type</p>",
        "id": 243866762,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624584659
    },
    {
        "content": "<p>how harmful would it be to just have GatherScatter be a separate additional trait later on?</p>",
        "id": 243866781,
        "sender_full_name": "Lokathor",
        "timestamp": 1624584698
    },
    {
        "content": "<p>like, sub-trait i think the term is</p>",
        "id": 243866792,
        "sender_full_name": "Lokathor",
        "timestamp": 1624584710
    },
    {
        "content": "<p>Well our trait is sealed so we can also just add functions in the future, no problem</p>",
        "id": 243866819,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624584723
    },
    {
        "content": "<p>fair enough</p>",
        "id": 243866845,
        "sender_full_name": "Lokathor",
        "timestamp": 1624584742
    },
    {
        "content": "<p>I didn't want to just remove scatter/gather from the trait entirely since I think that's the opposite of jubilee's intention</p>",
        "id": 243866921,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624584854
    },
    {
        "content": "<p>But I think regular fns is the safe path to stabilization at least</p>",
        "id": 243866954,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624584919
    },
    {
        "content": "<p>well even if they are on the trait they can be stabilized separately, i suppose?</p>",
        "id": 243867007,
        "sender_full_name": "Lokathor",
        "timestamp": 1624584966
    },
    {
        "content": "<p>Yeah I think so</p>",
        "id": 243867037,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624585039
    },
    {
        "content": "<p>A little update, without <code>const_evaluatable_checked</code> we can't actually even implement <code>{to,from}_array</code> in the trait:</p>\n<div class=\"codehilite\"><pre><span></span><code>error: constant expression depends on a generic parameter\n  --&gt; crates/core_simd/src/array.rs:25:26\n   |\n25 |     fn to_array(self) -&gt; [Self::Scalar; Self::LANES];\n   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: this may fail depending on what value the parameter takes\n</code></pre></div>",
        "id": 243872754,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624592630
    },
    {
        "content": "<p>Again it could be done with something like</p>\n<div class=\"codehilite\"><pre><span></span><code>pub trait Vector {\n    type Array;\n    fn to_array(self) -&gt; Array;\n}\n</code></pre></div>\n<p>but that doesn't really feel like a permanent solution</p>",
        "id": 243872832,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624592720
    },
    {
        "content": "<p>You don't actually need it at all, it's just Into/From. The entire method can be dropped.</p>",
        "id": 243873016,
        "sender_full_name": "Jubilee",
        "timestamp": 1624593009
    },
    {
        "content": "<p>Agreed, I thought it was common enough that we thought it deserved a proper name</p>",
        "id": 243873026,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624593035
    },
    {
        "content": "<p>That breaks with existing conventions.</p>",
        "id": 243873047,
        "sender_full_name": "Jubilee",
        "timestamp": 1624593121
    },
    {
        "content": "<p>e.g. String::from(str) has no special function, it is expected you use <code>from</code>.</p>",
        "id": 243873093,
        "sender_full_name": "Jubilee",
        "timestamp": 1624593167
    },
    {
        "content": "<p>well, there is also <code>ToString::to_string</code> and <code>ToOwned::to_owned</code>, that's a little different</p>",
        "id": 243873147,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624593245
    },
    {
        "content": "<p>Yes, those exist but for somewhat more Particular reasons.<br>\nAlso they take the \"Into\" form.</p>",
        "id": 243873155,
        "sender_full_name": "Jubilee",
        "timestamp": 1624593280
    },
    {
        "content": "<p>but generally I think I agree</p>",
        "id": 243873156,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624593280
    },
    {
        "content": "<p>There's FromIterator but \"special Into but not special From\" for certain \"baked into the language\" types is relatively common in <code>std</code>.</p>",
        "id": 243873183,
        "sender_full_name": "Jubilee",
        "timestamp": 1624593342
    },
    {
        "content": "<p>using <code>from_str</code>/<code>to_string</code> generally helps with type induction, which is what's special about it, I think</p>",
        "id": 243873185,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624593348
    },
    {
        "content": "<p>FromStr is a helper for <code>fn parse</code>.</p>",
        "id": 243873235,
        "sender_full_name": "Jubilee",
        "timestamp": 1624593380
    },
    {
        "content": "<p>midwife, almost.</p>",
        "id": 243873242,
        "sender_full_name": "Jubilee",
        "timestamp": 1624593414
    },
    {
        "content": "<p>that's true</p>",
        "id": 243873251,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624593430
    },
    {
        "content": "<p>ok so we can strike those fns entirely, agreed</p>",
        "id": 243873314,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624593533
    },
    {
        "content": "<p>Iterator is a trait I have looked to for inspiration on a few points but it has absolutely a ton of special casing because it's the grounding of <code>for</code> loops, likewise w/ strings and <code>fmt</code> in general having a lot of compiler help.</p>",
        "id": 243873603,
        "sender_full_name": "Jubilee",
        "timestamp": 1624593991
    },
    {
        "content": "<p>though I don't want to particularly belabor that point, this is one more library that will have a lot of compiler help <strong>also</strong>.</p>",
        "id": 243873653,
        "sender_full_name": "Jubilee",
        "timestamp": 1624594039
    },
    {
        "content": "<p>But I expect on subtly different details.</p>",
        "id": 243873659,
        "sender_full_name": "Jubilee",
        "timestamp": 1624594049
    },
    {
        "content": "<p>I think it is worth noting that <code>Iterator</code> only has one required fn</p>",
        "id": 243873724,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624594142
    },
    {
        "content": "<p>indeed.</p>",
        "id": 243873728,
        "sender_full_name": "Jubilee",
        "timestamp": 1624594147
    },
    {
        "content": "<p>I'm sure the others are non-defaulted for various iterators but they can all be derived from just <code>next</code></p>",
        "id": 243873738,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624594182
    },
    {
        "content": "<p><code>io::Write</code> requires <code>write</code> and <code>flush</code>, interestingly.</p>",
        "id": 243873796,
        "sender_full_name": "Jubilee",
        "timestamp": 1624594229
    },
    {
        "content": "<p>( I'm not going anywhere with that, I just wondered. )</p>",
        "id": 243873872,
        "sender_full_name": "Jubilee",
        "timestamp": 1624594342
    },
    {
        "content": "<p>Good news, replacing <code>LanesAtMost32</code> entirely with this trait worked just fine as expected</p>",
        "id": 243874249,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624595019
    },
    {
        "content": "<p>and this way is reasonably extensible in the future, I think, when we add more vector widths</p>",
        "id": 243874295,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624595057
    },
    {
        "content": "<p>fwiw, I took a shot at it and using the const generic LANES parameter w/ SimdArray&lt;LANES&gt; seems to make implementing <code>to_array</code> and making it return <code>[Self::Scalar; LANES]</code> possible. I don't think that const generics are meant to mesh with using associated constants/associated types. Or at least, they don't make it easy.</p>",
        "id": 243877114,
        "sender_full_name": "Jubilee",
        "timestamp": 1624598900
    },
    {
        "content": "<p>basically any use of const generics that involves using some non-concrete constant as a const param is gated behind <code>const_evaluatable_checked</code></p>",
        "id": 243877487,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1624599433
    },
    {
        "content": "<p>which.. yeah, includes assoc consts :(</p>",
        "id": 243877498,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1624599458
    },
    {
        "content": "<p>that isn't a problem if you ask me but I kinda view the selection of which things to draw bounds on as at least somewhat arbitrary</p>",
        "id": 243879210,
        "sender_full_name": "Jubilee",
        "timestamp": 1624601619
    },
    {
        "content": "<p>min_const_evaluable_checked when</p>",
        "id": 243879279,
        "sender_full_name": "Lokathor",
        "timestamp": 1624601679
    },
    {
        "content": "<p>lul</p>",
        "id": 243879390,
        "sender_full_name": "Jubilee",
        "timestamp": 1624601808
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span> I don't think it's correct to have the lanes as a generic parameter to the trait, since you should only implement the trait once per vector, and you shouldn't have to know the vector width to use it</p>",
        "id": 243879413,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624601839
    },
    {
        "content": "<p>mmm, I defer on correctness here to the compiler but I do understand the sentiment at least. isn't eliminating a single bound essentially invisible to consumers tho?</p>",
        "id": 243879548,
        "sender_full_name": "Jubilee",
        "timestamp": 1624602015
    },
    {
        "content": "<p>Well when I say correct I don't mean defined behavior, I mean is that you for example can't do <code>impl Vector</code>, you need to know the width to use it</p>",
        "id": 243879590,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624602115
    },
    {
        "content": "<p>oohhhhhhhhhhhhhh.</p>",
        "id": 243879678,
        "sender_full_name": "Jubilee",
        "timestamp": 1624602204
    },
    {
        "content": "<p>Regarding <code>{to,from}_array</code>, one thing I did notice is that <code>Vec</code> has both <code>as_slice</code> and <code>AsRef&lt;[T]&gt;</code> so it's not completely unheard of to repeat these things for type inference, I think</p>",
        "id": 244085869,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624829319
    },
    {
        "content": "<p>In my attempt to remove <code>to_array</code> I ended up with <code>AsRef::&lt;[Self::Scalar; LANES]&gt;::as_ref(*self)</code> in two separate places which is pretty nasty</p>",
        "id": 244085957,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624829423
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/SimdArray.20.2F.20Vector/near/244085869\">said</a>:</p>\n<blockquote>\n<p>Regarding <code>{to,from}_array</code>, one thing I did notice is that <code>Vec</code> has both <code>as_slice</code> and <code>AsRef&lt;[T]&gt;</code> so it's not completely unheard of to repeat these things for type inference, I think</p>\n</blockquote>\n<p>Basically all the advantages of being inherent, yeah.</p>",
        "id": 244090528,
        "sender_full_name": "scottmcm",
        "timestamp": 1624836736
    },
    {
        "content": "<p>I wonder if perhaps we should have <code>as_array</code> instead?  Since arrays implement <code>Deref&lt;[T]&gt;</code> it's probably strictly better?</p>",
        "id": 244091531,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624838475
    },
    {
        "content": "<p>yes, since we know we have the length info, we should preserve it as long as possible</p>",
        "id": 244092011,
        "sender_full_name": "Lokathor",
        "timestamp": 1624839362
    },
    {
        "content": "<p>it makes you spend an extra 60 seconds when you first learn the API, but then you get to preserve the length info all the time, so it's a net win</p>",
        "id": 244092054,
        "sender_full_name": "Lokathor",
        "timestamp": 1624839389
    },
    {
        "content": "<p>unless your long term plans are to use the API for less than 60 seconds total, in which case i care much less about your use case</p>",
        "id": 244092055,
        "sender_full_name": "Lokathor",
        "timestamp": 1624839409
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/SimdArray.20.2F.20Vector/near/244091531\">said</a>:</p>\n<blockquote>\n<p>I wonder if perhaps we should have <code>as_array</code> instead?  Since arrays implement <code>Deref&lt;[T]&gt;</code> it's probably strictly better?</p>\n</blockquote>\n<p>Nitpick: arrays implement <a href=\"https://doc.rust-lang.org/nightly/std/marker/trait.Unsize.html\">https://doc.rust-lang.org/nightly/std/marker/trait.Unsize.html</a> not Deref.  (Yes, this distinction is annoying.)</p>",
        "id": 244106884,
        "sender_full_name": "scottmcm",
        "timestamp": 1624862661
    },
    {
        "content": "<p>Well the SIMD types can just impl both directly then.</p>",
        "id": 244109314,
        "sender_full_name": "Lokathor",
        "timestamp": 1624864823
    },
    {
        "content": "<p>The difference being <code>Unsize</code> directly coerces at the type level and <code>Deref</code> by repeatedly adding <code>*</code>?</p>",
        "id": 244135039,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1624882473
    },
    {
        "content": "<p>i feel like arrays either implement deref also, or have other magic. i remember when playing around with ArrayVec (sample code is linked here <a href=\"https://github.com/rust-lang/rfcs/pull/2990#issuecomment-848962572\">https://github.com/rust-lang/rfcs/pull/2990#issuecomment-848962572</a>), the unsize coersion wasn't enough to allow calling methods of <code>ArrayVec&lt;[T]&gt;</code> on <code>ArrayVec&lt;[T; N]&gt;</code> — it needed a dummy deref coersion, that just returned the argument</p>",
        "id": 244135799,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1624882929
    },
    {
        "content": "<p>hm</p>",
        "id": 244322529,
        "sender_full_name": "Jubilee",
        "timestamp": 1624989868
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/SimdArray.20.2F.20Vector/near/244085869\">said</a>:</p>\n<blockquote>\n<p>Regarding <code>{to,from}_array</code>, one thing I did notice is that <code>Vec</code> has both <code>as_slice</code> and <code>AsRef&lt;[T]&gt;</code> so it's not completely unheard of to repeat these things for type inference, I think</p>\n</blockquote>\n<p>Makes me grumpy, honestly, but I won't yell too hard about keeping them. I guess my real conceit there is \"these are functions which exist only for type inference, it's fine if they have an unpretty implementation.\"</p>",
        "id": 244328372,
        "sender_full_name": "Jubilee",
        "timestamp": 1624992330
    },
    {
        "content": "<p>So let me be more direct: I consider the current documentation for <code>u32</code> for Rust to be borderline unreadable, and if SimdU32 has twice the number of functions on the types because it has both SIMD and u32 functions on it, I will consider it to be geometrically worse. \"doesn't require imports\" is not very meaningful if the consequence is that you have to sift through an undifferentiated mess of functions in order to find anything.  And at the point we will get to, we will have to realistically consider \"page load times\" to be an obstacle. They are already for other large types with large API surfaces.</p>\n<p>At the start I did not consider this to be an issue because I didn't use a lot of numerical code, but I was already aware of different forms of the problem. I hadn't really processed it though. It became more and more glaring as I had to frequently return to the documentation for those types and it started to sink in just how bad the problem was going to get. I introduced this abstraction to make it tenable to mitigate that.</p>",
        "id": 244348897,
        "sender_full_name": "Jubilee",
        "timestamp": 1625001370
    },
    {
        "content": "<p>The median Rust programmer sees 100 functions and then they close the page, basically. They only interact via programmatic search, and trivial obstacles to search become impossible to defeat. That is to say, they no longer use \"search PLUS human reasoning\", I mean they stop doing logical things like \"check the next function\". I know because I have walked people through this for comparatively small types like <code>Option&lt;T&gt;</code> and watched it happen again and again. I know because I have become overwhelmed myself.</p>",
        "id": 244349779,
        "sender_full_name": "Jubilee",
        "timestamp": 1625001772
    },
    {
        "content": "<p>I think making documentation worse by two functions is better than peppering code with UFCS.  I want to remind you that I originally wanted to support reading directly from pointers/slices to which you pointed out that reading from arrays is better (which is perhaps true).</p>\n<p>But now in generic code we have gone from <code>V::load(slice)</code> to <code>V::from_array(slice.try_into().unwrap())</code> to <code>&lt;V as From&lt;&amp;[&lt;V as Vector&gt;::Scalar]&gt;&gt;::from(slice.try_into().unwrap())</code> for something that is so exceptionally common that any simd program will have many instances.</p>",
        "id": 244350348,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1625002069
    },
    {
        "content": "<p>Actually, I made a typo, that inner type in From should be an array, not a slice, which you can't even specify in rust today without const eval checked</p>",
        "id": 244351221,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1625002565
    },
    {
        "content": "<p>I agree UFCS is bad which is why I am not really arguing for it, we can have to/from_array, it's vaguely undesirable on some level to me but Fine, and I don't really care where that is implemented, exactly. Likewise I am actually fine with a generic \"load\" function. I just don't really want to even suggest exposing the details of registers to users in an API.</p>",
        "id": 244351297,
        "sender_full_name": "Jubilee",
        "timestamp": 1625002618
    },
    {
        "content": "<p>Hmm what do you mean by that last part</p>",
        "id": 244351351,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1625002652
    },
    {
        "content": "<p>I don't think you can avoid registers.  If you write SSE and use more than 8 vectors at once you will quickly (slowly actually <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span>) be very aware of registers</p>",
        "id": 244351479,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1625002722
    },
    {
        "content": "<p>Literally I think \"load\" is a naughty word, in essence. That gets us complaints that our \"load\" function immediately spills to memory, omg!!! how dare you suggest you are LOADING from memory into a REGISTER! but I used 17 loads on an x86-64 system and for some reason it spills to memory!</p>",
        "id": 244351501,
        "sender_full_name": "Jubilee",
        "timestamp": 1625002736
    },
    {
        "content": "<p>( note to the audience: x86-64 systems only have 16 vector registers except with certain very late extensions )</p>",
        "id": 244351546,
        "sender_full_name": "Jubilee",
        "timestamp": 1625002778
    },
    {
        "content": "<p>Oh sure we can bikeshed naming, could be <code>copy_from_slice</code> to be consistent</p>",
        "id": 244351618,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1625002807
    },
    {
        "content": "<p>I was basically going to circle back at some point to this and suggest simply <code>from_slice</code> if I didn't come up with a better idea (I didn't).</p>",
        "id": 244351691,
        "sender_full_name": "Jubilee",
        "timestamp": 1625002869
    },
    {
        "content": "<p>Loading from slices is less important to me as long as we still have some sort of non-generic function for type inference</p>",
        "id": 244351694,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1625002871
    },
    {
        "content": "<p>yeah.</p>",
        "id": 244351706,
        "sender_full_name": "Jubilee",
        "timestamp": 1625002878
    },
    {
        "content": "<p>I think \"constructors\" in particular can largely be somewhere-else than the Vector trait.</p>",
        "id": 244351747,
        "sender_full_name": "Jubilee",
        "timestamp": 1625002918
    },
    {
        "content": "<p>gather is a bit of a special case here.</p>",
        "id": 244351796,
        "sender_full_name": "Jubilee",
        "timestamp": 1625002935
    },
    {
        "content": "<p>Slices are trivially convertible to array references relatively recently so it's not a big deal really</p>",
        "id": 244351798,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1625002937
    },
    {
        "content": "<p>I actually don't think gather is any more special than splat other than being more cognitively draining</p>",
        "id": 244351893,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1625002995
    },
    {
        "content": "<p>I agree, oddly enough? hmm I didn't mean constructor, I meant...</p>",
        "id": 244352048,
        "sender_full_name": "Jubilee",
        "timestamp": 1625003085
    },
    {
        "content": "<p>something like Direct Translation?</p>",
        "id": 244352094,
        "sender_full_name": "Jubilee",
        "timestamp": 1625003115
    },
    {
        "content": "<p><code>safe_transmute</code> lol</p>",
        "id": 244352122,
        "sender_full_name": "Jubilee",
        "timestamp": 1625003134
    },
    {
        "content": "<p>splat and gather are both non-transmutations.</p>",
        "id": 244352253,
        "sender_full_name": "Jubilee",
        "timestamp": 1625003207
    },
    {
        "content": "<p>Ah yeah</p>",
        "id": 244352281,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1625003224
    },
    {
        "content": "<p>BITCASTS</p>",
        "id": 244352300,
        "sender_full_name": "Jubilee",
        "timestamp": 1625003233
    },
    {
        "content": "<p>Even then I think array conversions are a little special only because arrays are a built in type</p>",
        "id": 244352349,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1625003271
    },
    {
        "content": "<p>Just like anything with slices are a little special</p>",
        "id": 244352398,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1625003284
    },
    {
        "content": "<p>A little.</p>",
        "id": 244353026,
        "sender_full_name": "Jubilee",
        "timestamp": 1625003663
    },
    {
        "content": "<p>to_array / from_array are just putting a clear label on a particular bitcast we expect people to frequently do. In other words: If we didn't provide them as methods you'd still be able to do it on your own anyway.</p>\n<p>We could have just into/from for arrays, which would be non-generic as caleb asks, and also would be stuffed far down in the docs as you want jubilee, but I think the idea was to have the visibility of extra methods with a special name for learnability reasons.</p>",
        "id": 244371546,
        "sender_full_name": "Lokathor",
        "timestamp": 1625020700
    },
    {
        "content": "<p>So, re: not being able to use <code>dyn Vector</code>:<br>\nThat doesn't matter because <code>Vector</code> isn't object-safe.</p>",
        "id": 245487275,
        "sender_full_name": "Jubilee",
        "timestamp": 1625859222
    },
    {
        "content": "<p>What about <code>fn foo&lt;V: Vector&gt;(v: V)</code>?</p>",
        "id": 245487438,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1625859297
    },
    {
        "content": "<p>So I believe we are restricted to considering the ergonomics of... yeah that.</p>",
        "id": 245487475,
        "sender_full_name": "Jubilee",
        "timestamp": 1625859312
    },
    {
        "content": "<p>Also it would be object safe without splat right?  Which I think is perhaps still questionable</p>",
        "id": 245487631,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1625859398
    },
    {
        "content": "<p>Not that we need to address that now, but I don't think it's a given what <code>Vector</code> should and shouldn't have yet</p>",
        "id": 245487987,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1625859602
    },
    {
        "content": "<p>Vector without an element type has very few operations, but still a few operations.</p>",
        "id": 245491682,
        "sender_full_name": "Lokathor",
        "timestamp": 1625861482
    },
    {
        "content": "<p>If we just had to/from [T;N] and also load/store using &amp;[T;N] and &amp;mut [T;N], that seems fine. I think the \"good code\" there would be to cast the slice once at the start and then you don't need to try_into().unwrap() on a per element basis.</p>",
        "id": 245492912,
        "sender_full_name": "Lokathor",
        "timestamp": 1625862092
    },
    {
        "content": "<p>Do you mean on the trait? Or just generally on vector types</p>",
        "id": 245493351,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1625862334
    },
    {
        "content": "<p>i mean \"what methods does the trait have\"</p>",
        "id": 245493428,
        "sender_full_name": "Lokathor",
        "timestamp": 1625862367
    },
    {
        "content": "<p>But I think the real problem to a vector trait is that if scalar numbers don't get a trait, and arrays don't get a trait, why does simd get a trait? It seems like a political willpower issue rather than a strictly technical problem.</p>",
        "id": 245493459,
        "sender_full_name": "Lokathor",
        "timestamp": 1625862388
    },
    {
        "content": "<p>The trait can't have anything referencing arrays, since we can't have the lane count in a type</p>",
        "id": 245493500,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1625862422
    },
    {
        "content": "<blockquote>\n<h2>Object Safety</h2>\n<p>Object safe traits can be the base trait of a [trait object]. A trait is<br>\n<em>object safe</em> if it has the following qualities (defined in [RFC 255]):</p>\n<ul>\n<li>All [supertraits] must also be object safe.</li>\n<li><code>Sized</code> must not be a [supertrait][supertraits]. In other words, it must not require <code>Self: Sized</code>.</li>\n<li>It must not have any associated constants.</li>\n<li>All associated functions must either be dispatchable from a trait object or be explicitly non-dispatchable:<br>\n    * Dispatchable functions require:<br>\n        * Not have any type parameters (although lifetime parameters are allowed),<br>\n        * Be a [method] that does not use <code>Self</code> except in the type of the receiver.<br>\n        * Have a receiver with one of the following types:<br>\n            * <code>&amp;Self</code> (i.e. <code>&amp;self</code>)<br>\n            * <code>&amp;mut Self</code> (i.e <code>&amp;mut self</code>)<br>\n            * [<code>Box&lt;Self&gt;</code>]<br>\n            * [<code>Rc&lt;Self&gt;</code>]<br>\n            * [<code>Arc&lt;Self&gt;</code>]<br>\n            * [<code>Pin&lt;P&gt;</code>] where <code>P</code> is one of the types above<br>\n        * Does not have a <code>where Self: Sized</code> bound (receiver type of <code>Self</code> (i.e. <code>self</code>) implies this).<br>\n    * Explicitly non-dispatchable functions require:<br>\n        * Have a <code>where Self: Sized</code> bound (receiver type of <code>Self</code> (i.e. <code>self</code>) implies this).</li>\n</ul>\n</blockquote>",
        "id": 245493563,
        "sender_full_name": "Jubilee",
        "timestamp": 1625862458
    },
    {
        "content": "<p>oh is that a limit we have to still live by? poop</p>",
        "id": 245493566,
        "sender_full_name": "Lokathor",
        "timestamp": 1625862459
    },
    {
        "content": "<p>Yup</p>",
        "id": 245493574,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1625862464
    },
    {
        "content": "<p>Const generics are good enough to get us generic types and impls and it ends about there</p>",
        "id": 245493651,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1625862489
    },
    {
        "content": "<p>well get with it const generics folks, just pull out  another rabbit already</p>",
        "id": 245493694,
        "sender_full_name": "Lokathor",
        "timestamp": 1625862520
    },
    {
        "content": "<p>Array is formally a type lol.</p>",
        "id": 245493713,
        "sender_full_name": "Jubilee",
        "timestamp": 1625862530
    },
    {
        "content": "<p>yeah we can make the array type an associated type and not be generic over the lanes</p>",
        "id": 245493759,
        "sender_full_name": "Lokathor",
        "timestamp": 1625862559
    },
    {
        "content": "<p>Sorry, by types I meant type definitions</p>",
        "id": 245493764,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1625862562
    },
    {
        "content": "<p>but that's probably not helpful to not be generic over the lane count</p>",
        "id": 245493792,
        "sender_full_name": "Lokathor",
        "timestamp": 1625862584
    },
    {
        "content": "<p>It is very hard, I would argue even impossible, to make Vector do anything vaguely like what we want and also be object safe. I would support having an object-safe supertrait (or subtrait?) of Vector, if we wanted to do that.</p>",
        "id": 245493804,
        "sender_full_name": "Jubilee",
        "timestamp": 1625862591
    },
    {
        "content": "<p>You can't reference types with dependent const generics</p>",
        "id": 245493820,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1625862600
    },
    {
        "content": "<p>I would have no idea what it was for, mind.</p>",
        "id": 245493908,
        "sender_full_name": "Jubilee",
        "timestamp": 1625862641
    },
    {
        "content": "<p>Well that's what I'm wondering, for now do we just want the element type and the lane count since there is absolutely no other way to get that?</p>",
        "id": 245493945,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1625862663
    },
    {
        "content": "<p>My main goal was to embed the element type relationship and use it to produce nicer looking code, yes.</p>",
        "id": 245493988,
        "sender_full_name": "Jubilee",
        "timestamp": 1625862691
    },
    {
        "content": "<p>like... I assume that eventually this will become useful to external users, but I want to see what they do with a somewhat messy version first before I leap to assumptions.</p>",
        "id": 245494077,
        "sender_full_name": "Jubilee",
        "timestamp": 1625862726
    },
    {
        "content": "<p>That's kind of why I wanted to elevate things into the trait where plausible.</p>",
        "id": 245494127,
        "sender_full_name": "Jubilee",
        "timestamp": 1625862761
    },
    {
        "content": "<p>I also cannot imagine what object-safe simd would even usefully do</p>",
        "id": 245494132,
        "sender_full_name": "Lokathor",
        "timestamp": 1625862764
    },
    {
        "content": "<p>I also personally started a simd-traits crate which should fill the useful-but-not-std-simple gap</p>",
        "id": 245494177,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1625862798
    },
    {
        "content": "<p>I also figure that \"it's hard to write generics over the trait and requires additional nightly unstable features\" would be... fine? Not great but fine.</p>",
        "id": 245494182,
        "sender_full_name": "Jubilee",
        "timestamp": 1625862802
    },
    {
        "content": "<p>I think people mostly want to be generic over lane count</p>",
        "id": 245494224,
        "sender_full_name": "Lokathor",
        "timestamp": 1625862834
    },
    {
        "content": "<p>but not element type</p>",
        "id": 245494271,
        "sender_full_name": "Lokathor",
        "timestamp": 1625862845
    },
    {
        "content": "<p>So the thing is... You can be generic over lane count without using const generics</p>",
        "id": 245494306,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1625862867
    },
    {
        "content": "<p>And that I would be happy with demolishing the trait if it is shown to not provide anything terribly useful in terms of writing generics later.</p>",
        "id": 245494314,
        "sender_full_name": "Jubilee",
        "timestamp": 1625862872
    },
    {
        "content": "<p>CURRENTLY.</p>",
        "id": 245494320,
        "sender_full_name": "Jubilee",
        "timestamp": 1625862876
    },
    {
        "content": "<p>I swear to Ferris if I have to fucking fix the compiler myself to make it work I'll fucking do it. <span aria-label=\"crab\" class=\"emoji emoji-1f980\" role=\"img\" title=\"crab\">:crab:</span></p>",
        "id": 245494363,
        "sender_full_name": "Jubilee",
        "timestamp": 1625862904
    },
    {
        "content": "<p>I've only ever talked to people that had some float op lib function they wanted to have happen at whatever lane count the user was ready to use. But ive never once heard someone seriously ask to do something on both u32 simd and also u16 simd, for example</p>",
        "id": 245494516,
        "sender_full_name": "Lokathor",
        "timestamp": 1625862966
    },
    {
        "content": "<p>Ahem.<br>\nExcusez mon français.<br>\nThere was no other language that could convey the sentiment adequately.</p>",
        "id": 245494524,
        "sender_full_name": "Jubilee",
        "timestamp": 1625862969
    },
    {
        "content": "<p>As long as you know what the lane count is inside your generic you usually don't actually need const generics, so for now I don't think we need to worry about if it's usable without const eval checked</p>",
        "id": 245494529,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1625862970
    },
    {
        "content": "<p>but maybe that's because standard rust doesn't have u16/u32 generics so rust programmers just don't think like that to begin with.</p>",
        "id": 245494571,
        "sender_full_name": "Lokathor",
        "timestamp": 1625863001
    },
    {
        "content": "<p>I think people are going to be more interested, imo, in writing things that hit both scalar and vector versions.</p>",
        "id": 245494577,
        "sender_full_name": "Jubilee",
        "timestamp": 1625863005
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> generic over element is definitely useful, in a num-traits kind of way</p>",
        "id": 245494605,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1625863023
    },
    {
        "content": "<p>But it's probably useful somewhat less frequently</p>",
        "id": 245494633,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1625863036
    },
    {
        "content": "<p>right but most people dont yet think that way. if our design is open to having that later after a scalar version of int generics then that's probably enough</p>",
        "id": 245494678,
        "sender_full_name": "Lokathor",
        "timestamp": 1625863073
    },
    {
        "content": "<p>which is why I focused on the assoc type.</p>",
        "id": 245494679,
        "sender_full_name": "Jubilee",
        "timestamp": 1625863074
    },
    {
        "content": "<p>But! going async. Will update later.</p>",
        "id": 245494757,
        "sender_full_name": "Jubilee",
        "timestamp": 1625863105
    },
    {
        "content": "<p>On the generic numerics point: there's applications where numerical codes see 3x speedups from switxhig to Float16 from Float32 in a region that they know requires less precision. And then other gnarlier algos can happen ny also accepting BigFloats, but that's for another day.</p>",
        "id": 245734698,
        "sender_full_name": "Miguel Raz Guzmán Macedo",
        "timestamp": 1626117557
    },
    {
        "content": "<p>I'm pretty happy with the direction of <a href=\"https://github.com/rust-lang/stdsimd/issues/124\">stdsimd#124</a> but I wonder if there's something we can do better for enforcing the lane count that doesn't result in leaking implementation details of which specific vector types are used by a generic function (for example <code>where SimdU32&lt;LANES&gt;: Vector</code>)</p>\n<div class=\"codehilite\"><pre><span></span><code>struct LaneCount&lt;N&gt;([(); N]);\ntrait SupportedLaneCount: Sealed {}\n\n...\n\nfn foo&lt;const LANES: usize&gt;(...) where LaneCount&lt;LANES&gt;: SupportedLaneCount { ... }\n</code></pre></div>",
        "id": 247033340,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627074754
    },
    {
        "content": "<p>If we happen to get const bounds before stabilization we can change it to that--but I think this is more or less as close as we can get for now</p>",
        "id": 247033510,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627074829
    },
    {
        "content": "<p>Hmm.</p>",
        "id": 247044910,
        "sender_full_name": "Jubilee",
        "timestamp": 1627084069
    },
    {
        "content": "<p>couldn't you just use <code>pub struct LaneCount&lt;const LANES: usize&gt;;</code> instead of needing an array?</p>",
        "id": 247045973,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1627085243
    },
    {
        "content": "<p>Hmm, I think it will complain about the unused const, but perhaps</p>",
        "id": 247046511,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627085997
    },
    {
        "content": "<p>Though, having an internal member also prevents it from being initialized (no idea if that matters at all)</p>",
        "id": 247046592,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627086069
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/SimdArray.20.2F.20Vector/near/247046511\">said</a>:</p>\n<blockquote>\n<p>Hmm, I think it will complain about the unused const, but perhaps</p>\n</blockquote>\n<p>no complaints from rustc or clippy:<br>\n<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=4e23ed21ded12a2da8ce6e9b232cd8c6\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=4e23ed21ded12a2da8ce6e9b232cd8c6</a></p>",
        "id": 247047475,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1627087359
    },
    {
        "content": "<p>Interesting that you need phantom data for types</p>",
        "id": 247047492,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627087427
    },
    {
        "content": "<p>Some type astronaut could probably explain the difference</p>",
        "id": 247047533,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627087463
    },
    {
        "content": "<p>that's because types need to handle variance, const generics don't have that</p>",
        "id": 247047536,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1627087473
    },
    {
        "content": "<p>Hmm</p>",
        "id": 247047539,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627087489
    },
    {
        "content": "<p>yep, basically const generics dont have subtyping but lifetimes and types do so you need a phantom data <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 247047546,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1627087512
    },
    {
        "content": "<p>Ah that makes sense</p>",
        "id": 247047616,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627087621
    },
    {
        "content": "<p>So the implication here is that all vector types have the same valid lane counts</p>",
        "id": 247047667,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627087691
    },
    {
        "content": "<p>Which is not just reasonable but probably convenient (like not leaking specific vector types in generic bounds)</p>",
        "id": 247047691,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627087741
    },
    {
        "content": "<p>If anyone is curious I implemented this and added it to <a href=\"https://github.com/rust-lang/stdsimd/issues/124\">stdsimd#124</a>.  It actually simplified a lot--there were a bunch of places where we had 2+ bounds (sometimes 4!) that all got replaced with the single lane count bound.  But an unexpected benefit is how much it simplified the mask implementation, they used to be generic on both the public mask type and the lane count, but now they are only generic over the lane count</p>",
        "id": 247056446,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627102962
    },
    {
        "content": "<p>This is a good example: <a href=\"https://github.com/rust-lang/stdsimd/pull/142/files#diff-a7db8455cfa81269184255b74165bb95f946da7ce60045418517347d846c3fd4L79-L85\">https://github.com/rust-lang/stdsimd/pull/142/files#diff-a7db8455cfa81269184255b74165bb95f946da7ce60045418517347d846c3fd4L79-L85</a></p>\n<p>Some of the float functions have </p>\n<div class=\"codehilite\"><pre><span></span><code>        impl&lt;const LANES: usize&gt; $name&lt;LANES&gt;\n        where\n            Self: crate::LanesAtMost32,\n            crate::$bits_ty&lt;LANES&gt;: crate::LanesAtMost32,\n            crate::$mask_impl_ty&lt;LANES&gt;: crate::LanesAtMost32,\n            crate::$mask_ty&lt;LANES&gt;: crate::Mask,\n</code></pre></div>\n<p>which are now replaced with just the single <code>LaneCount&lt;LANES&gt;: SupportedLaneCount</code> bound</p>",
        "id": 247056522,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627103136
    },
    {
        "content": "<p>That's important if we want to change the implementation in the future in such a way that uses new types, because we can't add more bounds</p>",
        "id": 247056574,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627103193
    },
    {
        "content": "<p>(after stabilization, I mean)</p>",
        "id": 247056579,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627103212
    },
    {
        "content": "<p>oh wow.</p>",
        "id": 247061041,
        "sender_full_name": "Jubilee",
        "timestamp": 1627111285
    },
    {
        "content": "<p>Lemme play with this for a sec now that it's rebased.</p>",
        "id": 247091838,
        "sender_full_name": "Jubilee",
        "timestamp": 1627158758
    },
    {
        "content": "<p>hmmm why can't I reelevate this back to the assoc const or bound the assoc const... ugh!</p>",
        "id": 247094103,
        "sender_full_name": "Jubilee",
        "timestamp": 1627161179
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"326176\">@Boxy [she/her]</span> Is this just unsupported semantics? I am not even getting \"did you want to enable a feature?\" alerts.</p>",
        "id": 247094196,
        "sender_full_name": "Jubilee",
        "timestamp": 1627161329
    },
    {
        "content": "<p>can you elaborate a bit? Im not sure exactly what you're trying to do</p>",
        "id": 247094254,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1627161397
    },
    {
        "content": "<p>I think this is just<code>const_evaluatable_checked</code> but: associated types accept bounds, I would expect associated constants also do.</p>",
        "id": 247094327,
        "sender_full_name": "Jubilee",
        "timestamp": 1627161530
    },
    {
        "content": "<p>ah you want to do <code>T: Trait&lt;ASSOC = 10&gt;</code> like you can with types?</p>",
        "id": 247094387,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1627161625
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">LANES</span>: <span class=\"kt\">usize</span> <span class=\"nc\">where</span><span class=\"w\"> </span><span class=\"bp\">Self</span>::<span class=\"n\">LANES</span>: <span class=\"nc\">crate</span>::<span class=\"n\">SupportedLaneCount</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 247094470,
        "sender_full_name": "Jubilee",
        "timestamp": 1627161748
    },
    {
        "content": "<p>or something like that</p>",
        "id": 247094474,
        "sender_full_name": "Jubilee",
        "timestamp": 1627161762
    },
    {
        "content": "<p>I think that won't work because there actually are no const bounds at all yet</p>",
        "id": 247094488,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627161782
    },
    {
        "content": "<p>aha.</p>",
        "id": 247094496,
        "sender_full_name": "Jubilee",
        "timestamp": 1627161791
    },
    {
        "content": "<p>It just happens to be that we can use type bounds to do some const bounds</p>",
        "id": 247094498,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627161798
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/SimdArray.20.2F.20Vector/near/247094470\">said</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">LANES</span>: <span class=\"kt\">usize</span> <span class=\"nc\">where</span><span class=\"w\"> </span><span class=\"bp\">Self</span>::<span class=\"n\">LANES</span>: <span class=\"nc\">crate</span>::<span class=\"n\">SupportedLaneCount</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>ah right yeah that isnt supported <span aria-label=\"frown\" class=\"emoji emoji-1f641\" role=\"img\" title=\"frown\">:frown:</span></p>",
        "id": 247094570,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1627161893
    },
    {
        "content": "<p>i think that's not even supported on types without GATs?</p>",
        "id": 247094571,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1627161901
    },
    {
        "content": "<p>where clauses I mean</p>",
        "id": 247094576,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1627161906
    },
    {
        "content": "<p>Yeah I don't think you can require it on assoc types, you can do them on implementations but not require it for a trait, I think</p>",
        "id": 247094590,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627161938
    },
    {
        "content": "<p>i am a bit confused by you putting a trait bound on an associated const though</p>",
        "id": 247094594,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1627161959
    },
    {
        "content": "<p>Not full where clauses I mean. You can of course do the more limited type of just listing traits</p>",
        "id": 247094634,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627161966
    },
    {
        "content": "<p>You know how you can do <code>type Foo: Bar</code>? I think jubilee basically wants that but for a const value</p>",
        "id": 247094646,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627162005
    },
    {
        "content": "<p>yeah.</p>",
        "id": 247094652,
        "sender_full_name": "Jubilee",
        "timestamp": 1627162013
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Scalar</span>: <span class=\"nb\">Copy</span> <span class=\"o\">+</span><span class=\"w\"> </span><span class=\"nb\">Sized</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 247094666,
        "sender_full_name": "Jubilee",
        "timestamp": 1627162024
    },
    {
        "content": "<p>right but consts dont implement traits</p>",
        "id": 247094735,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1627162120
    },
    {
        "content": "<p>^^; That is a good point but eh</p>",
        "id": 247094755,
        "sender_full_name": "Jubilee",
        "timestamp": 1627162165
    },
    {
        "content": "<p>I'm not sure what you're actually trying to express with <code>Self::LANES: Trait</code> (was it a typo?)</p>",
        "id": 247094763,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1627162196
    },
    {
        "content": "<p>poking at finding a way to inject this bound in other ways:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"n\">LaneCount</span><span class=\"o\">&lt;</span><span class=\"n\">LANES</span><span class=\"o\">&gt;</span>: <span class=\"nc\">SupportedLaneCount</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 247094875,
        "sender_full_name": "Jubilee",
        "timestamp": 1627162328
    },
    {
        "content": "<p>Ah yes, that's the intention of my changes. Since you can't actually specify const bounds yet, wrap it in a type</p>",
        "id": 247095020,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627162614
    },
    {
        "content": "<p>yuh. Pondering... hm.</p>",
        "id": 247095210,
        "sender_full_name": "Jubilee",
        "timestamp": 1627163014
    },
    {
        "content": "<p>Well this works with <code>#![feature(const_evaluatable_checked)]</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Vector</span>: <span class=\"nc\">sealed</span>::<span class=\"n\">Sealed</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"sd\">/// The scalar type in every lane of this vector type.</span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Scalar</span>: <span class=\"nb\">Copy</span> <span class=\"o\">+</span><span class=\"w\"> </span><span class=\"nb\">Sized</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"sd\">/// The number of lanes for this vector.</span>\n<span class=\"w\">    </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">LANES</span>: <span class=\"kt\">usize</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"sd\">/// Generates a SIMD vector with the same value in every lane.</span>\n<span class=\"w\">    </span><span class=\"cp\">#[must_use]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">splat</span><span class=\"p\">(</span><span class=\"n\">val</span>: <span class=\"nc\">Self</span>::<span class=\"n\">Scalar</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"cp\">#[must_use]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"cp\">#[inline]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">gather_select</span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">slice</span>: <span class=\"kp\">&amp;</span><span class=\"p\">[</span><span class=\"bp\">Self</span>::<span class=\"n\">Scalar</span><span class=\"p\">],</span><span class=\"n\">yyyy</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">mask</span>: <span class=\"nc\">crate</span>::<span class=\"n\">MaskSize</span><span class=\"o\">&lt;</span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"bp\">Self</span>::<span class=\"n\">LANES</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">idxs</span>: <span class=\"nc\">crate</span>::<span class=\"n\">SimdUsize</span><span class=\"o\">&lt;</span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"bp\">Self</span>::<span class=\"n\">LANES</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">or</span>: <span class=\"nc\">Self</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">crate</span>::<span class=\"n\">LaneCount</span><span class=\"o\">&lt;</span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"bp\">Self</span>::<span class=\"n\">LANES</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"o\">&gt;</span>: <span class=\"nc\">crate</span>::<span class=\"n\">SupportedLaneCount</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"bp\">Self</span>: <span class=\"nb\">Sized</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">mask</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">mask</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"w\"> </span><span class=\"n\">idxs</span><span class=\"p\">.</span><span class=\"n\">lanes_lt</span><span class=\"p\">(</span><span class=\"k\">crate</span>::<span class=\"n\">SimdUsize</span>::<span class=\"n\">splat</span><span class=\"p\">(</span><span class=\"n\">slice</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">()))).</span><span class=\"n\">to_int</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">base_ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">crate</span>::<span class=\"n\">vector</span>::<span class=\"n\">ptr</span>::<span class=\"n\">SimdConstPtr</span>::<span class=\"n\">splat</span><span class=\"p\">(</span><span class=\"n\">slice</span><span class=\"p\">.</span><span class=\"n\">as_ptr</span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// Ferris forgive me, I have done pointer arithmetic here.</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptrs</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">base_ptr</span><span class=\"p\">.</span><span class=\"n\">wrapping_add</span><span class=\"p\">(</span><span class=\"n\">idxs</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// SAFETY: The ptrs have been bounds-masked to prevent memory-unsafe reads insha'allah</span>\n<span class=\"w\">        </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">crate</span>::<span class=\"n\">intrinsics</span>::<span class=\"n\">simd_gather</span><span class=\"p\">(</span><span class=\"n\">or</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">ptrs</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">mask</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 247096433,
        "sender_full_name": "Jubilee",
        "timestamp": 1627165223
    },
    {
        "content": "<p>Oh good, then we're closer to something workable there than I thought</p>",
        "id": 247096495,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627165328
    },
    {
        "content": "<p>Though I think the lane count change helped because you don't have a generic type dependence anymore</p>",
        "id": 247096504,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627165357
    },
    {
        "content": "<p>yup!</p>",
        "id": 247096508,
        "sender_full_name": "Jubilee",
        "timestamp": 1627165368
    },
    {
        "content": "<p>I still don't think we should be using const eval checked, but I'm glad we're close</p>",
        "id": 247096513,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627165391
    },
    {
        "content": "<p>That's what motivated me to take a swing at it.</p>",
        "id": 247096515,
        "sender_full_name": "Jubilee",
        "timestamp": 1627165397
    },
    {
        "content": "<p>Good idea, didn't even click for me when I did it</p>",
        "id": 247096521,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627165429
    },
    {
        "content": "<p>I wonder if this has any implications for <code>to_bits</code> or <code>to_bitmask</code> since they have similar issues</p>",
        "id": 247096640,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627165565
    },
    {
        "content": "<p>I'd be tempted to enable const eval checked if we could somehow only allow it on select functions that require it</p>",
        "id": 247096675,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627165658
    },
    {
        "content": "<p>You're concerned about it \"leaking\" out of Vector?</p>",
        "id": 247096780,
        "sender_full_name": "Jubilee",
        "timestamp": 1627165809
    },
    {
        "content": "<p>Actually I'm just concerned that we may accidentally use it somewhere we didn't realize</p>",
        "id": 247096786,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627165839
    },
    {
        "content": "<p>( I am not saying that is not a valid concern. )</p>",
        "id": 247096791,
        "sender_full_name": "Jubilee",
        "timestamp": 1627165847
    },
    {
        "content": "<p>aha.</p>",
        "id": 247096793,
        "sender_full_name": "Jubilee",
        "timestamp": 1627165851
    },
    {
        "content": "<p>We could add a const eval checked cargo feature?</p>",
        "id": 247096806,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627165878
    },
    {
        "content": "<p>how would that help, exactly?</p>",
        "id": 247096814,
        "sender_full_name": "Jubilee",
        "timestamp": 1627165903
    },
    {
        "content": "<p>Oh, if we test both versions in CI?</p>",
        "id": 247096823,
        "sender_full_name": "Jubilee",
        "timestamp": 1627165918
    },
    {
        "content": "<p>Yep!</p>",
        "id": 247096936,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627166081
    },
    {
        "content": "<p>Sounds good to me! ^^</p>",
        "id": 247097189,
        "sender_full_name": "Jubilee",
        "timestamp": 1627166537
    },
    {
        "content": "<p>Perhaps that should be a separate PR</p>",
        "id": 247097197,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627166631
    },
    {
        "content": "<p>yes. :P</p>",
        "id": 247097198,
        "sender_full_name": "Jubilee",
        "timestamp": 1627166640
    },
    {
        "content": "<p>The back and forth might look a little silly but looking a little silly is better than uh whatever that unholy pile-on would turn into.</p>",
        "id": 247097308,
        "sender_full_name": "Jubilee",
        "timestamp": 1627166772
    },
    {
        "content": "<p>Merged!</p>",
        "id": 247097814,
        "sender_full_name": "Jubilee",
        "timestamp": 1627167736
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 247097972,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627168082
    },
    {
        "content": "<p>An interesting thing to note about const eval checked... I tested changing <code>{to,from}_bitmask</code> to use const eval checked and I was able to compile the core_simd crate, but when I attempted to actually call the function for some reason it failed during type inference.  I'm guessing this could also occur with scatter/gather</p>",
        "id": 247414437,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627437618
    },
    {
        "content": "<p>what error are you getting?</p>",
        "id": 247414488,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1627437662
    },
    {
        "content": "<p>(and do you ahve const eval checked enabled in the calling crate?)</p>",
        "id": 247414499,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1627437672
    },
    {
        "content": "<p>I did try that as well. Let me pull it up</p>",
        "id": 247414513,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627437693
    },
    {
        "content": "<p>Maybe I can make a smaller example</p>",
        "id": 247414528,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627437700
    },
    {
        "content": "<p>So actually, first problem I run into is:</p>\n<div class=\"codehilite\"><pre><span></span><code>macro_rules! impl_to_bytes {\n    { $name:ident, $size:literal } =&gt; {\n        impl&lt;const LANES: usize&gt; crate::$name&lt;LANES&gt;\n        where\n            crate::LaneCount&lt;LANES&gt;: crate::SupportedLaneCount,\n            crate::LaneCount&lt;{{ $size * LANES }}&gt;: crate::SupportedLaneCount,\n        {\n            /// Return the memory representation of this integer as a byte array in native byte\n            /// order.\n            pub fn to_ne_bytes(self) -&gt; crate::SimdU8&lt;{{ $size * LANES }}&gt; {\n                unsafe { core::mem::transmute_copy(&amp;self) }\n            }\n\n            /// Create a native endian integer value from its memory representation as a byte array\n            /// in native endianness.\n            pub fn from_ne_bytes(bytes: crate::SimdU8&lt;{{ $size * LANES }}&gt;) -&gt; Self {\n                unsafe { core::mem::transmute_copy(&amp;bytes) }\n            }\n        }\n    }\n}\n</code></pre></div>",
        "id": 247415281,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627438745
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>error: constant expression depends on a generic parameter\n  --&gt; crates/core_simd/src/to_bytes.rs:6:52\n   |\n6  |             crate::LaneCount&lt;{{ $size * LANES }}&gt;: crate::SupportedLaneCount,\n   |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n23 | impl_to_bytes! { SimdU8, 1 }\n   | ---------------------------- in this macro invocation\n   |\n   = note: this may fail depending on what value the parameter takes                                                                                                                                                                                                                                                            = note: this error originates in the macro `impl_to_bytes` (in Nightly builds, run with -Z macro-backtrace for more info)\n</code></pre></div>",
        "id": 247415302,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627438777
    },
    {
        "content": "<p>oh wait</p>",
        "id": 247415363,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627438834
    },
    {
        "content": "<p>Ignore that :)</p>",
        "id": 247415366,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627438840
    },
    {
        "content": "<p>:3</p>",
        "id": 247415368,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1627438846
    },
    {
        "content": "<p>(with the feature actually properly enabled this does compile!)</p>",
        "id": 247415387,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627438877
    },
    {
        "content": "<p>This is the test:</p>\n<div class=\"codehilite\"><pre><span></span><code>#![feature(portable_simd, const_evaluatable_checked)]\n\nuse core_simd::SimdU32;\n\n#[test]\nfn byte_convert() {\n    let int = SimdU32::from_array([0xdeadbeef, 0x8badf00d]);\n    let bytes = int.to_ne_bytes();\n    assert_eq!(int[0].to_ne_bytes(), bytes[..4]);\n    assert_eq!(int[1].to_ne_bytes(), bytes[4..]);\n    assert_eq!(SimdU32::from_ne_bytes(bytes), int);\n}\n</code></pre></div>",
        "id": 247415456,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627438978
    },
    {
        "content": "<p>And the error:</p>\n<div class=\"codehilite\"><pre><span></span><code>error[E0599]: the function or associated item `from_ne_bytes` exists for struct `SimdU32&lt;{_: usize}&gt;`, but its trait bounds were not satisfied\n  --&gt; crates/core_simd/tests/to_bytes.rs:11:25\n   |\n11 |     assert_eq!(SimdU32::from_ne_bytes(bytes), int);\n   |                         ^^^^^^^^^^^^^ function or associated item cannot be called on `SimdU32&lt;{_: usize}&gt;` due to unsatisfied trait bounds\n   |\n  ::: /home/caleb/stdsimd/crates/core_simd/src/lane_count.rs:7:1\n   |\n7  | pub struct LaneCount&lt;const LANES: usize&gt;;\n   | ----------------------------------------- doesn&#39;t satisfy `LaneCount&lt;{_: usize}&gt;: SupportedLaneCount`\n   |\n   = note: the following trait bounds were not satisfied:\n           `LaneCount&lt;{_: usize}&gt;: SupportedLaneCount`\n</code></pre></div>",
        "id": 247415467,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627439005
    },
    {
        "content": "<p>im not sure how well <code>const_evaluatable_checked</code> works without <code>const_generics</code> i usually enable both</p>",
        "id": 247415506,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1627439044
    },
    {
        "content": "<p>That is a good point.</p>",
        "id": 247415524,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627439055
    },
    {
        "content": "<p>...and there you have it, it works with <code>const_generics</code></p>",
        "id": 247415613,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627439195
    },
    {
        "content": "<p>thank you for your insight, I would never have figured that out</p>",
        "id": 247415617,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627439212
    },
    {
        "content": "<p>ah <span aria-label=\"fire\" class=\"emoji emoji-1f525\" role=\"img\" title=\"fire\">:fire:</span></p>",
        "id": 247415625,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1627439225
    },
    {
        "content": "<p>glad that worked out <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 247415627,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1627439229
    },
    {
        "content": "<p>I wonder if the <code>const_evaluatable_checked</code> can require <code>const_generics</code> since it doesn't seem to make sense to enable one without the other</p>",
        "id": 247415629,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627439260
    },
    {
        "content": "<p>I don't actually know if features can require other features...</p>",
        "id": 247415636,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1627439282
    },
    {
        "content": "<p>I dont know either <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 247415737,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1627439414
    },
    {
        "content": "<p>Wondering if GATs help here, hm.</p>",
        "id": 248295064,
        "sender_full_name": "Jubilee",
        "timestamp": 1628035054
    }
]