[
    {
        "content": "<p>I was reading the docs for the pointer scatter operation, and they say that if two writes conflict, the writes are applied in order. Any ideas where this come from? I'd expect that to be UB.</p>",
        "id": 252775406,
        "sender_full_name": "hannahE2",
        "timestamp": 1631275442
    },
    {
        "content": "<p><a href=\"https://llvm.org/docs/LangRef.html#llvm-masked-scatter-intrinsics\">https://llvm.org/docs/LangRef.html#llvm-masked-scatter-intrinsics</a></p>",
        "id": 252775810,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631275643
    },
    {
        "content": "<p>The LLVM documentation seems to indicate it is ordered</p>",
        "id": 252775853,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631275662
    },
    {
        "content": "<p>Right, but why does the Rust exposure needs to be ordered?</p>",
        "id": 252782350,
        "sender_full_name": "hannahE2",
        "timestamp": 1631278697
    },
    {
        "content": "<p>Which hardware has an ordered instruction for this ?</p>",
        "id": 252782373,
        "sender_full_name": "hannahE2",
        "timestamp": 1631278711
    },
    {
        "content": "<p>if you think of each SIMD lane as doing independent operations in parallel, then two parallel writes to some memory without synchronization looks like a data-race to me</p>",
        "id": 252782501,
        "sender_full_name": "hannahE2",
        "timestamp": 1631278789
    },
    {
        "content": "<p>you can always provide an API on top that adds synchronization to, e.g., perform writes in order to avoid data-races, but you can't build an unsynchronized API on top of a synchronized one</p>",
        "id": 252782656,
        "sender_full_name": "hannahE2",
        "timestamp": 1631278836
    },
    {
        "content": "<blockquote>\n<p>Scatter with overlapping addresses is guaranteed to be ordered from least-significant to most-significant element.</p>\n</blockquote>\n<p>I think it is only ordered within a single instruction, not between instructions.</p>",
        "id": 252782766,
        "sender_full_name": "bjorn3",
        "timestamp": 1631278904
    },
    {
        "content": "<p>So two concurrent scatters to the same element would be a data-race, but within a single scatter two writes to the same element have a guaranteed ordering.</p>",
        "id": 252782923,
        "sender_full_name": "bjorn3",
        "timestamp": 1631278949
    },
    {
        "content": "<p>Yeah, this is just a guarantee if you have duplicate pointers in a single scatter.  It isn't UB, otherwise we couldn't allow it behind a safe interface at all</p>",
        "id": 252783208,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631279087
    },
    {
        "content": "<p>It is not a safe interface since it does (multiple) raw pointer writes.</p>",
        "id": 252787796,
        "sender_full_name": "hannahE2",
        "timestamp": 1631281014
    },
    {
        "content": "<p>If the rationale is \"because llvm.scatter provides this guarantee\", then my question turns into two:</p>\n<ul>\n<li>why does llvm.scatter provide this guarantee?</li>\n<li>why does rust has to provide the same guarantee?</li>\n</ul>",
        "id": 252787915,
        "sender_full_name": "hannahE2",
        "timestamp": 1631281060
    },
    {
        "content": "<p>I meant more the interface that operates over a slice</p>",
        "id": 252787924,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631281063
    },
    {
        "content": "<p>Are there architectures where that isn't the case?</p>",
        "id": 252789626,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631281809
    },
    {
        "content": "<p>i don't know any arch with scatters wher that is the case. All gpus come to mind as architectures where scatters race with themselves.</p>",
        "id": 252791992,
        "sender_full_name": "hannahE2",
        "timestamp": 1631282691
    },
    {
        "content": "<p>arm scatters don't say what happen in this case (i suppose its undefined)</p>",
        "id": 252794225,
        "sender_full_name": "hannahE2",
        "timestamp": 1631283582
    },
    {
        "content": "<p>AVX scatters are ordered</p>",
        "id": 252794264,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631283599
    },
    {
        "content": "<p>I just looked through the SVE reference and agreed, it doesn't seem to say. Though I am guessing there is an implied behavior based on the memory model</p>",
        "id": 252794363,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631283629
    },
    {
        "content": "<p>I don't know much about GPUs, but I couldn't find an nvptx reference at all</p>",
        "id": 252794443,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631283670
    },
    {
        "content": "<p>Arm loads and stores are always atomic so at worst it would be unspecified, and not UB</p>",
        "id": 252794692,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631283782
    },
    {
        "content": "<blockquote>\n<p>AVX scatters are ordered</p>\n</blockquote>\n<p>Do you have a link to the scatter that you are referring to?</p>\n<blockquote>\n<p>[..] GPUs</p>\n</blockquote>\n<p>For amdgpu and nvptx each thread of a group would execute one of the writes of the scatter, so writes from two threads without sync race. IIUC, that's HW UB for amdgpu, but for nvptx data-races are not HW ub (you see one of the writes, but it can be different each time).</p>",
        "id": 252795167,
        "sender_full_name": "hannahE2",
        "timestamp": 1631283995
    },
    {
        "content": "<blockquote>\n<p>Arm loads and stores are always atomic so at worst it would be unspecified, and not UB</p>\n</blockquote>\n<p>Yes, you could see a different result each time. If we require sequential ordering though, we can't use ARM instructions, and have to lower this to a scalar loop there.</p>",
        "id": 252795290,
        "sender_full_name": "hannahE2",
        "timestamp": 1631284061
    },
    {
        "content": "<p><a href=\"https://www.felixcloutier.com/x86/vpscatterdd:vpscatterdq:vpscatterqd:vpscatterqq\">https://www.felixcloutier.com/x86/vpscatterdd:vpscatterdq:vpscatterqd:vpscatterqq</a></p>",
        "id": 252795384,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631284089
    },
    {
        "content": "<blockquote>\n<p>Only writes to overlapping vector indices are guaranteed to be ordered with respect to each other (from LSB to MSB of the source registers). Note that this also include partially overlapping vector indices. Writes that are not overlapped may happen in any order. Memory ordering with other instructions follows the Intel-64 memory ordering model. Note that this does not account for non-overlapping indices that map into the same physical address locations.</p>\n</blockquote>",
        "id": 252795551,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631284160
    },
    {
        "content": "<p>That's indeed ordered.</p>",
        "id": 252795977,
        "sender_full_name": "hannahE2",
        "timestamp": 1631284344
    },
    {
        "content": "<p><a href=\"https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm512_i32extscatter_epi32&amp;expand=3848\">https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm512_i32extscatter_epi32&amp;expand=3848</a></p>\n<p>shows the \"operational semantics\" of this</p>",
        "id": 252796015,
        "sender_full_name": "hannahE2",
        "timestamp": 1631284364
    },
    {
        "content": "<p>is an ordered loop</p>",
        "id": 252796029,
        "sender_full_name": "hannahE2",
        "timestamp": 1631284370
    },
    {
        "content": "<p>Reading through the arm memory model, I interpret this as the last value (MSB) will be returned but the processor is allowed to entirely drop the first access</p>",
        "id": 252796458,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631284540
    },
    {
        "content": "<p><a href=\"https://github.com/riscv/riscv-v-spec/blob/ba75fb7c72160bb6030f126eb476cf575089fc8c/v-spec.adoc#76-vector-indexed-instructions\">https://github.com/riscv/riscv-v-spec/blob/ba75fb7c72160bb6030f126eb476cf575089fc8c/v-spec.adoc#76-vector-indexed-instructions</a> RISC-V supports both</p>",
        "id": 252796705,
        "sender_full_name": "hannahE2",
        "timestamp": 1631284635
    },
    {
        "content": "<blockquote>\n<p>The vector indexed load and store memory operations have two forms, ordered and unordered. The indexed-ordered variants preserve element ordering on memory accesses.</p>\n<p>For unordered instructions (mop!=11) there is no guarantee on element access order. If the accesses are to a strongly ordered IO region, the element accesses can be initiated in any order.</p>\n</blockquote>",
        "id": 252796851,
        "sender_full_name": "hannahE2",
        "timestamp": 1631284689
    },
    {
        "content": "<p>So the ARM spec says that their writes are ordered in chapter 4 (memory order section).</p>",
        "id": 252799549,
        "sender_full_name": "hannahE2",
        "timestamp": 1631285778
    },
    {
        "content": "<p>I tend to think that the scatter should be split into an <code>_ordered</code> and an <code>_unordered</code> variant, similar to how RISC-V instructions work</p>",
        "id": 252801516,
        "sender_full_name": "hannahE2",
        "timestamp": 1631286571
    },
    {
        "content": "<p>So, at least as far as portable-simd is concerned, we're not really interested in supporting every possible configuration (that's what vendor intrinsics are for), but rather the most useful and universal configuration, which does appear to be ordered in this case</p>",
        "id": 252801901,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631286735
    },
    {
        "content": "<p>unordered is more universal, since it allows more hardware implementations</p>",
        "id": 252802027,
        "sender_full_name": "hannahE2",
        "timestamp": 1631286805
    },
    {
        "content": "<p>by definition ordering is more restrictive</p>",
        "id": 252802085,
        "sender_full_name": "hannahE2",
        "timestamp": 1631286836
    },
    {
        "content": "<p>from the usefulness point of view, the scatters are masked, so I don't see what's the point of requiring an order</p>",
        "id": 252802311,
        "sender_full_name": "hannahE2",
        "timestamp": 1631286918
    },
    {
        "content": "<p>if you have multiple writes to the same location, the mask allows you to specify which one you want to \"happen\"</p>",
        "id": 252802351,
        "sender_full_name": "hannahE2",
        "timestamp": 1631286940
    },
    {
        "content": "<p>At least in what's currently supported by LLVM, it seems they're pretty much equivalently universal</p>",
        "id": 252802557,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631287025
    },
    {
        "content": "<p>what do you mean by universal ?</p>",
        "id": 252802599,
        "sender_full_name": "hannahE2",
        "timestamp": 1631287046
    },
    {
        "content": "<p>Not having a guaranteed ordering prevents the safe implementation we already have: <a href=\"https://rust-lang.github.io/portable-simd/core_simd/struct.Simd.html#method.scatter\">https://rust-lang.github.io/portable-simd/core_simd/struct.Simd.html#method.scatter</a></p>",
        "id": 252802615,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631287054
    },
    {
        "content": "<p>why?</p>",
        "id": 252802641,
        "sender_full_name": "hannahE2",
        "timestamp": 1631287065
    },
    {
        "content": "<p>Well, it wouldn't prevent it, but it would make it useless because you would need to check that there are no duplicate indices</p>",
        "id": 252802788,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631287116
    },
    {
        "content": "<p>??</p>",
        "id": 252802809,
        "sender_full_name": "hannahE2",
        "timestamp": 1631287128
    },
    {
        "content": "<p>this is safe <code>array[random()] = 42;</code></p>",
        "id": 252802828,
        "sender_full_name": "hannahE2",
        "timestamp": 1631287139
    },
    {
        "content": "<p>if you do multiple writes from a single thread to the location, in a random order, that's safe</p>",
        "id": 252802868,
        "sender_full_name": "hannahE2",
        "timestamp": 1631287159
    },
    {
        "content": "<p>is there an RFC discussion of the rationale of the scatter semantics ?</p>",
        "id": 252802934,
        "sender_full_name": "hannahE2",
        "timestamp": 1631287195
    },
    {
        "content": "<p>i think the only way for the unordered constraint to impact safety would be if, from a memory model perspective, we say that SIMD operations fork the thread into number of lanes threads, perform a small program, and then join them back</p>",
        "id": 252803140,
        "sender_full_name": "hannahE2",
        "timestamp": 1631287283
    },
    {
        "content": "<p>its not clear to me that we want to do this</p>",
        "id": 252803190,
        "sender_full_name": "hannahE2",
        "timestamp": 1631287312
    },
    {
        "content": "<p>but even then, we can just say that the writes are atomic relaxed, and get a safe API for scatter</p>",
        "id": 252803264,
        "sender_full_name": "hannahE2",
        "timestamp": 1631287327
    },
    {
        "content": "<p>Do you mean an LLVM RFC?</p>",
        "id": 252803303,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631287345
    },
    {
        "content": "<p>We have not produced the portable simd RFC yet</p>",
        "id": 252803330,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631287357
    },
    {
        "content": "<p>i mean a rust rfc explaining why these semantics were given to the scatter intrinsics</p>",
        "id": 252803346,
        "sender_full_name": "hannahE2",
        "timestamp": 1631287364
    },
    {
        "content": "<p>or any document that explains why from all possible options, this option was picked</p>",
        "id": 252803380,
        "sender_full_name": "hannahE2",
        "timestamp": 1631287378
    },
    {
        "content": "<p>Well, a simple answer is that it's the only thing available in our backend.</p>",
        "id": 252803425,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631287398
    },
    {
        "content": "<p>our backend also supports generating unordered intrinsics for riscv by calling the corresponding arch-specific version there</p>",
        "id": 252803602,
        "sender_full_name": "hannahE2",
        "timestamp": 1631287486
    },
    {
        "content": "<p>anyways i don't have anything else to say about this, good luck</p>",
        "id": 252803693,
        "sender_full_name": "hannahE2",
        "timestamp": 1631287536
    },
    {
        "content": "<p>you have clarified my question about why you want to expose it like this</p>",
        "id": 252803707,
        "sender_full_name": "hannahE2",
        "timestamp": 1631287547
    },
    {
        "content": "<p>Yes, and that's what vendor intrinsics are for, but there is no corresponding generic instruction</p>",
        "id": 252803717,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631287551
    },
    {
        "content": "<p>so?</p>",
        "id": 252803776,
        "sender_full_name": "hannahE2",
        "timestamp": 1631287568
    },
    {
        "content": "<p>there were not electric cars 20 years ago therefore electric cars should not be pursued</p>",
        "id": 252803825,
        "sender_full_name": "hannahE2",
        "timestamp": 1631287594
    },
    {
        "content": "<p>if that's your only rationale, it's illogical</p>",
        "id": 252803876,
        "sender_full_name": "hannahE2",
        "timestamp": 1631287617
    },
    {
        "content": "<p>repeating the argument does not make it better</p>",
        "id": 252803974,
        "sender_full_name": "hannahE2",
        "timestamp": 1631287665
    },
    {
        "content": "<p>Well, if someone wants to add unordered scatter/gather to LLVM we may choose to expose that instead, but until then we are all volunteers, and only some of us write C++ and I'd hazard none of us have the bandwidth to contribute something like that to LLVM, so it's really outside of the scope of this project group.</p>",
        "id": 252804294,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631287803
    },
    {
        "content": "<p>We can also just not expose scatter if we can't explain why we expose it this way.</p>",
        "id": 252808878,
        "sender_full_name": "hannahE2",
        "timestamp": 1631289589
    },
    {
        "content": "<p>But \"this is how it works in LLVM\" is just like \"this is how it works in C\", and there are many things that we do very differently than C for good reason.</p>",
        "id": 252809053,
        "sender_full_name": "hannahE2",
        "timestamp": 1631289627
    },
    {
        "content": "<p>I find the operation useful, and if the only issue is that we don't know whether it should be ordered or unordered, we can just say its unordered, and we can always make it ordered later (that's a forward compatible change).</p>",
        "id": 252809511,
        "sender_full_name": "hannahE2",
        "timestamp": 1631289809
    },
    {
        "content": "<p>i think both operations are different and both make sense</p>",
        "id": 252809546,
        "sender_full_name": "hannahE2",
        "timestamp": 1631289826
    },
    {
        "content": "<p>Well, LLVM is our backend, so that's a very good reason to do what LLVM does.    We don't have any other choice.</p>",
        "id": 252810046,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631290040
    },
    {
        "content": "<p>I would assume that the unordered variant has LLVM level UB when an index is used more than once. In this case the safe scatter version has to be ordered.</p>",
        "id": 252810051,
        "sender_full_name": "bjorn3",
        "timestamp": 1631290041
    },
    {
        "content": "<p>Could the order of the scatter be documented as \"unspecified\", somewhat similarly as <a href=\"https://doc.rust-lang.org/std/primitive.slice.html#method.binary_search\"><code>binary_search</code></a> documents \"The index is chosen deterministically, but is subject to change in future versions of Rust.\"? On the platforms where it is cheap to do ordered scatter, this would be according to the documentation, and on the platforms where the order is undefined, but not UB, this would also be according to the documentation? Even if LLVM doesn't support this currently, it might in the future, and if Rust uses it in this way, LLVM developers might be tempted to declare their operation as \"unspecified\" instead of UB if they ever rework their scatter intrinsics. And in the meanwhile, it would be perfectly fine to just compile to the ordered variant.</p>",
        "id": 252821094,
        "sender_full_name": "Henrik Lievonen",
        "timestamp": 1631294891
    },
    {
        "content": "<p>Unspecified seems fine at first glance, since the important thing is really just having a strict order.  Not sure this addresses the original concern, but it may be something we want to change.</p>",
        "id": 252827210,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631297631
    },
    {
        "content": "<blockquote>\n<p>We don't have any other choice.</p>\n</blockquote>\n<p>Of course we have.</p>",
        "id": 252859129,
        "sender_full_name": "hannahE2",
        "timestamp": 1631312838
    },
    {
        "content": "<p>You seem to claim that LLVM is immutable, immodifiable, out of reach, only for .... gods?</p>",
        "id": 252859224,
        "sender_full_name": "hannahE2",
        "timestamp": 1631312893
    },
    {
        "content": "<p>Yet... dozens of diffs are merged per day.</p>",
        "id": 252859257,
        "sender_full_name": "hannahE2",
        "timestamp": 1631312915
    },
    {
        "content": "<p>Written by people, the same people that added <code>llvm.masked.scatter</code>, when there was none.</p>",
        "id": 252859282,
        "sender_full_name": "hannahE2",
        "timestamp": 1631312939
    },
    {
        "content": "<p>And the same people that added all the portable simd intrinsics to llvm, where there only used to be arch specific ones.</p>",
        "id": 252859317,
        "sender_full_name": "hannahE2",
        "timestamp": 1631312968
    },
    {
        "content": "<p>What you seem to try to say is that \"for you\" there is no other choice.</p>",
        "id": 252859332,
        "sender_full_name": "hannahE2",
        "timestamp": 1631312981
    },
    {
        "content": "<p>But somehow you are extrapolating that to Rust.</p>",
        "id": 252859343,
        "sender_full_name": "hannahE2",
        "timestamp": 1631312995
    },
    {
        "content": "<p>Please stop doing that.</p>",
        "id": 252859410,
        "sender_full_name": "hannahE2",
        "timestamp": 1631313015
    },
    {
        "content": "<p>LLVM has tousands of bugs open and hundreds of things that make no sense.</p>",
        "id": 252859457,
        "sender_full_name": "hannahE2",
        "timestamp": 1631313067
    },
    {
        "content": "<p>The question is what semantics make sense for Rust here, and whether it makes sense to expose two semantics, or one.</p>",
        "id": 252859476,
        "sender_full_name": "hannahE2",
        "timestamp": 1631313086
    },
    {
        "content": "<p>Whatever LLVM does or doesn't do, particularly for something like scatter which is ~100 LOC of C++... doesn't matter much. If we need an unordered scatter in LLVM we can just add it, or add an \"order\" argument to the scatter intrinsic, or... many other things.</p>",
        "id": 252859581,
        "sender_full_name": "hannahE2",
        "timestamp": 1631313147
    },
    {
        "content": "<blockquote>\n<p>I would assume that the unordered variant has LLVM level UB when an index is used more than once. In this case the safe scatter version has to be ordered.</p>\n</blockquote>\n<p>Why?</p>",
        "id": 252859621,
        "sender_full_name": "hannahE2",
        "timestamp": 1631313189
    },
    {
        "content": "<p>say I have a \"vector\" a[N] with N elements and a pointer to the memory <code>ptr</code>, and do <code>*ptr = a[random(0, N)]</code></p>",
        "id": 252859668,
        "sender_full_name": "hannahE2",
        "timestamp": 1631313233
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"409057\">hannahE2</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/Why.20is.20scatter.20ordered.3F/near/252859621\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>I would assume that the unordered variant has LLVM level UB when an index is used more than once. In this case the safe scatter version has to be ordered.</p>\n</blockquote>\n<p>Why?</p>\n</blockquote>\n<p>I think what this means is that if <code>llvm.scatter.unordered</code> has LLVM level UB, then it can't be used by Rust's unordered scatter operation, even if Rust specifies that the choice is arbitrary / unspecified (but still safe)</p>",
        "id": 252860130,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631313559
    },
    {
        "content": "<p>i'm out of this discussion</p>",
        "id": 252860215,
        "sender_full_name": "hannahE2",
        "timestamp": 1631313608
    },
    {
        "content": "<p>If you have the time to make the changes to LLVM I'd be happy to review the subsequent changes to core_simd.  It would be nice if our implementation could be constrained only by what we want Rust to be, but every technical decision since the inception of this project group has been constrained by the fact that we are only a few people donating our time, and we would like this project to be complete before the obsoletion of Rust as a language, which involves some conpromises.</p>",
        "id": 252860222,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631313614
    },
    {
        "content": "<p>if you don't have time to work on this, that's ok</p>",
        "id": 252860274,
        "sender_full_name": "hannahE2",
        "timestamp": 1631313657
    },
    {
        "content": "<p>I'm still open to the idea of an unordered scatter, but there doesn't seem to be a critical difference between the two, particularly because I haven't yet seen a technical specification for an architecture that only has unordered scatters.</p>",
        "id": 252860322,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631313709
    },
    {
        "content": "<p>i'm not going to continue this discussion</p>",
        "id": 252860375,
        "sender_full_name": "hannahE2",
        "timestamp": 1631313732
    },
    {
        "content": "<p>I agree with the general sentiment that one shouldn't feel too constrained to make the API exactly match LLVM, even if that means there is some mismatch or slowness as a result. An API mistake is much harder to roll back after the fact than a performance issue</p>",
        "id": 252860377,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631313734
    },
    {
        "content": "<p>it makes me super uncofortable that you want to ship something that you don't have time to ship</p>",
        "id": 252860400,
        "sender_full_name": "hannahE2",
        "timestamp": 1631313750
    },
    {
        "content": "<p>and also how you extrapolate from you to me</p>",
        "id": 252860428,
        "sender_full_name": "hannahE2",
        "timestamp": 1631313782
    },
    {
        "content": "<p>i wanted to have a discussion about why the semantics for scatter in rust</p>",
        "id": 252860450,
        "sender_full_name": "hannahE2",
        "timestamp": 1631313803
    },
    {
        "content": "<p>and what semantics make sense</p>",
        "id": 252860540,
        "sender_full_name": "hannahE2",
        "timestamp": 1631313856
    },
    {
        "content": "<p>\"most platforms supply or can guarantee ordered scatter\" seems like a good reason to prioritize it. The most logical spec for unordered scatter involves UB, so it's not an option for rust without <code>unsafe</code>. The second most logical spec for unordered scatter (unspecified clobbering) might be useful but there is apparently not much demand for it</p>",
        "id": 252860661,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631313957
    },
    {
        "content": "<p>which scatter apis are safe?</p>",
        "id": 252860752,
        "sender_full_name": "hannahE2",
        "timestamp": 1631314011
    },
    {
        "content": "<p>Regarding semantics, the only technical spec with unordered semantics I have seen is the RISC-V scatter, which would be inappropriate for the current interface that we have due to not checking for duplicate indices</p>",
        "id": 252860761,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631314025
    },
    {
        "content": "<p>its <code>simd&lt;T*&gt;::write_to_slice</code></p>",
        "id": 252860770,
        "sender_full_name": "hannahE2",
        "timestamp": 1631314033
    },
    {
        "content": "<blockquote>\n<p>Not having a guaranteed ordering prevents the safe implementation we already have: <a href=\"https://rust-lang.github.io/portable-simd/core_simd/struct.Simd.html#method.scatter\">https://rust-lang.github.io/portable-simd/core_simd/struct.Simd.html#method.scatter</a></p>\n</blockquote>",
        "id": 252860805,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631314072
    },
    {
        "content": "<p>From an earlier message</p>",
        "id": 252860811,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631314078
    },
    {
        "content": "<p>The lowest effort way to address this issue is to add <code>scatter_unordered</code> as a synonym of <code>scatter</code> with a weaker API promise</p>",
        "id": 252860969,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631314182
    },
    {
        "content": "<p>and then ask LLVM kindly to add another intrinsic</p>",
        "id": 252861036,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631314207
    },
    {
        "content": "<p>that's going to have to do two reductions of the offsets, and then compare the slice bounds</p>",
        "id": 252861053,
        "sender_full_name": "hannahE2",
        "timestamp": 1631314216
    },
    {
        "content": "<p>This is the initial portable scatter that we have decided on after much discussion on the topic (somewhere else in this channel).  Different architectures handle the arguments, particularly the offsets/pointers, fairly differently (particularly x86).</p>",
        "id": 252861075,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631314233
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"312331\">@Caleb Zulawski</span> Do you know if <code>scatter_unordered</code> as proposed would be able to get any immediate benefits over <code>scatter</code> on some platforms in the current implementation?</p>",
        "id": 252861152,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631314303
    },
    {
        "content": "<p>What's the % of the theoretical peak perf of x86 that this scatter achieves ?</p>",
        "id": 252861231,
        "sender_full_name": "hannahE2",
        "timestamp": 1631314355
    },
    {
        "content": "<p>On x86 I imagine there would be no benefit since the intrinsic is ordered</p>",
        "id": 252861265,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631314382
    },
    {
        "content": "<p>not really, the x86 hardware does the ordering in the load-store unit</p>",
        "id": 252861285,
        "sender_full_name": "hannahE2",
        "timestamp": 1631314399
    },
    {
        "content": "<p>Considering all architectures I am aware of support ordered scatter, no I am not aware of any performance difference.  Arm and x86 are already free to reorder the non-overlapping memory access</p>",
        "id": 252861299,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631314418
    },
    {
        "content": "<p>so it basically sends all writes \"combined\" and the LSU just cancels the las</p>",
        "id": 252861305,
        "sender_full_name": "hannahE2",
        "timestamp": 1631314425
    },
    {
        "content": "<p>is there an example of this on godbolt? one can run MCA there and compare with the raw scatter instruction</p>",
        "id": 252861380,
        "sender_full_name": "hannahE2",
        "timestamp": 1631314473
    },
    {
        "content": "<p>without the masking, the compare, the wrapping adds, etc.</p>",
        "id": 252861392,
        "sender_full_name": "hannahE2",
        "timestamp": 1631314483
    },
    {
        "content": "<p>I'm not sure what you mean by without all of that--in that case it maps directly to a single scatter instruction</p>",
        "id": 252861459,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631314549
    },
    {
        "content": "<p>right</p>",
        "id": 252861507,
        "sender_full_name": "hannahE2",
        "timestamp": 1631314564
    },
    {
        "content": "<p>when I want to do a scatter, I already know that the indices are in bounds, don't need the length mask, etc.</p>",
        "id": 252861540,
        "sender_full_name": "hannahE2",
        "timestamp": 1631314596
    },
    {
        "content": "<p>the library i'm using has a different unsafe write scatter which is what i've been using until now and works quite well</p>",
        "id": 252861602,
        "sender_full_name": "hannahE2",
        "timestamp": 1631314641
    },
    {
        "content": "<p>Well, our API does not support vectors-of-pointers yet, so for now you would at a minimum have the offsets converted to pointers still</p>",
        "id": 252861685,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631314688
    },
    {
        "content": "<p><a href=\"https://rust-lang.github.io/packed_simd/packed_simd_2/type.mptrx8.html#method.write\">https://rust-lang.github.io/packed_simd/packed_simd_2/type.mptrx8.html#method.write</a> that's the one i'm using</p>",
        "id": 252861706,
        "sender_full_name": "hannahE2",
        "timestamp": 1631314709
    },
    {
        "content": "<p>i found vectors of pointers odd to be honest, i prefer the offsets that your API uses with a base address</p>",
        "id": 252861743,
        "sender_full_name": "hannahE2",
        "timestamp": 1631314740
    },
    {
        "content": "<p>or at least, for my use cases, i always splat the vector of pointers anyways</p>",
        "id": 252861760,
        "sender_full_name": "hannahE2",
        "timestamp": 1631314757
    },
    {
        "content": "<p>this api is already unsafe, so i don't understand what value it being ordered adds</p>",
        "id": 252861898,
        "sender_full_name": "hannahE2",
        "timestamp": 1631314807
    },
    {
        "content": "<p>i also don't understand why your api would become unsafe if it was unordered</p>",
        "id": 252861951,
        "sender_full_name": "hannahE2",
        "timestamp": 1631314829
    },
    {
        "content": "<p>we have lots of unordered safe apis in rust</p>",
        "id": 252861983,
        "sender_full_name": "hannahE2",
        "timestamp": 1631314851
    },
    {
        "content": "<p>Such as?</p>",
        "id": 252862193,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631315006
    },
    {
        "content": "<p>It would depend on the semantics of the LLVM intrinsic and the underlying instructions, but writing to the same pointer twice would likely be UB</p>",
        "id": 252862274,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631315068
    },
    {
        "content": "<p>on HW that doesn't guarantee ordering, each pointer write probably is pessimized. :D</p>",
        "id": 252897287,
        "sender_full_name": "Jubilee",
        "timestamp": 1631353404
    },
    {
        "content": "<p>packed_simd's version is functionally the same API and lowers to the same things, it is just capable of issuing erroneous writes to out-of-range indices. We just formally documented that here. There is no difference.</p>",
        "id": 252897471,
        "sender_full_name": "Jubilee",
        "timestamp": 1631353604
    },
    {
        "content": "<p>If you are happy with the packed_simd version, and you typically just want to write to the same slice, then you will basically get all benefits, no drawbacks, here. Remember, the writes are <strong>only</strong> \"ordered\" with respect to the ones that would touch the same index. All others are allowed to race.</p>",
        "id": 252897866,
        "sender_full_name": "Jubilee",
        "timestamp": 1631354076
    },
    {
        "content": "<p>We likely will offer a more packed_simd-like interface at some point that lets you do maximal monstrosity to memory safety with all the limiters off and not even the guarantees the current packed_simd or portable-simd interfaces do, but we would want even the rough draft of that API to be better designed than we currently have bandwidth for.</p>",
        "id": 252899397,
        "sender_full_name": "Jubilee",
        "timestamp": 1631355742
    },
    {
        "content": "<blockquote>\n<p>It would depend on the semantics of the LLVM intrinsic and the underlying instructions, but writing to the same pointer twice would likely be UB</p>\n</blockquote>\n<div class=\"codehilite\"><pre><span></span><code>let ptr: *mut i32 = ...;\nunsafe {\n    ptr.write(42);\n    ptr.write(13);\n}\n</code></pre></div>\n<p>That snippet contains two writes to a pointer. How is the behavior of that undefined?</p>",
        "id": 253222575,
        "sender_full_name": "hannahE2",
        "timestamp": 1631611956
    },
    {
        "content": "<p>This snippet contains two unordered writes to a ptr:</p>\n<div class=\"codehilite\"><pre><span></span><code>let ptr: *mut i32 = ...;\nlet perm = [13, 42].random_permutation();\nunsafe {\n    ptr.write(perm.next().unwrap());  // 13 or 42\n    ptr.write(perm.next().uwnrap());  // the other one\n}\n</code></pre></div>\n<p>How is the behavior of this undefined?</p>",
        "id": 253222852,
        "sender_full_name": "hannahE2",
        "timestamp": 1631612135
    },
    {
        "content": "<p>In case of an unordered write, it may happen that two such unordered writes use a different order. If LLVM duplicates such a write (which it may for normal writes if it can prove that no other thread can access it due to data races being UB), this would cause UB.</p>",
        "id": 253225143,
        "sender_full_name": "bjorn3",
        "timestamp": 1631613558
    },
    {
        "content": "<p>Say LLVM transforms the following pseudo code</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">write_unordered</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">]);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">flag</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">flag2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">flag</span><span class=\"w\"> </span><span class=\"o\">!=</span><span class=\"w\"> </span><span class=\"n\">flag2</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">unreachable</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>into</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">write_unordered</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">]);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">flag</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"n\">write_unordered</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">]);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">flag2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">flag</span><span class=\"w\"> </span><span class=\"o\">!=</span><span class=\"w\"> </span><span class=\"n\">flag2</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">unreachable</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p><code>unreachable()</code> may suddenly become reachable.</p>",
        "id": 253225597,
        "sender_full_name": "bjorn3",
        "timestamp": 1631613729
    },
    {
        "content": "<p>For genuinely unordered writes, LLVM is allowed to sequence them however it sees fit.</p>",
        "id": 253291588,
        "sender_full_name": "Jubilee",
        "timestamp": 1631641100
    },
    {
        "content": "<p>Because that's the definition of an unordered write.</p>",
        "id": 253291638,
        "sender_full_name": "Jubilee",
        "timestamp": 1631641124
    },
    {
        "content": "<p>a scatter can fault in a way that causes it to write zero times to a given memory location while writing to other locations. this means that the assumption you give, that all writes happen, is incorrect on a material hardware level. thus, the ordering of writes is somewhat important.</p>",
        "id": 253294333,
        "sender_full_name": "Jubilee",
        "timestamp": 1631642221
    },
    {
        "content": "<p>So on top of what bjorn has shown: in the presence of a truly undefined order and possible faults that interrupt the scatter, a valid interpretation of multiple writes to a given pointer would be to write zero times.</p>",
        "id": 253294851,
        "sender_full_name": "Jubilee",
        "timestamp": 1631642406
    },
    {
        "content": "<p>umm, if a scatter store faults, isn't that a SIGSEGV? why would llvm's semantics have to take out-of-bounds stores into account (I'm assuming the only way to cause a SIGSEGV ignoring alignment)? or can it fault from an in-bounds store?</p>",
        "id": 253298437,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1631643701
    },
    {
        "content": "<p>You could fault by accessing protected memory, too</p>",
        "id": 253298922,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631643872
    },
    {
        "content": "<p>if it's protected, it's kinda by-definition out-of-bounds</p>",
        "id": 253299034,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1631643916
    },
    {
        "content": "<p>The benefit of ordering is for example if your vector is larger than a hardware vector</p>",
        "id": 253299295,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631644007
    },
    {
        "content": "<p>also, I didn't see an unordered scatter intrinsic in llvm's LangRef</p>",
        "id": 253299304,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1631644012
    },
    {
        "content": "<p>It can change instruction scheduling if it knows it's ordered</p>",
        "id": 253299368,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631644035
    },
    {
        "content": "<p>Yeah, there is none, which is my point as to why that's not something we're probably going to address</p>",
        "id": 253299423,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631644062
    },
    {
        "content": "<p>I guess I wasn't paying too much attention, but I understood Jubilee to be making the argument that unordered scatters were necessary (they are useful, but not necessary imho), and that they could be UB if executed twice where the original code only ran once (llvm does know how to avoid duplicating stuff like that imho)</p>",
        "id": 253300034,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1631644273
    },
    {
        "content": "<blockquote>\n<p>I guess I wasn't paying too much attention, but I understood Jubilee to be making the argument that unordered scatters were necessary (they are useful, but not necessary imho), <br>\nI was not.</p>\n</blockquote>",
        "id": 253302645,
        "sender_full_name": "Jubilee",
        "timestamp": 1631645331
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"229517\">Jacob Lifshay</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/Why.20is.20scatter.20ordered.3F/near/253298437\">said</a>:</p>\n<blockquote>\n<p>umm, if a scatter store faults, isn't that a SIGSEGV? why would llvm's semantics have to take out-of-bounds stores into account (I'm assuming the only way to cause a SIGSEGV ignoring alignment)? or can it fault from an in-bounds store?</p>\n</blockquote>\n<p>Scatters are allowed to suppress normal fault behavior. You may now begin screaming.</p>",
        "id": 253302797,
        "sender_full_name": "Jubilee",
        "timestamp": 1631645399
    },
    {
        "content": "<p>By suppress, do you mean it can fault before retiring the entire instruction?</p>",
        "id": 253303121,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631645507
    },
    {
        "content": "<p>I mean that the OS does not terminate the program.</p>",
        "id": 253303457,
        "sender_full_name": "Jubilee",
        "timestamp": 1631645636
    },
    {
        "content": "<p>It can entirely suppress the signal???</p>",
        "id": 253303615,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631645691
    },
    {
        "content": "<p>well, normal stores are also technically allowed to not terminate the program by installing a handler on SIGSEGV, that's how a JVM usually produces a NullReferenceException (or whatever that's called)</p>",
        "id": 253303824,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1631645776
    },
    {
        "content": "<p>The instruction itself basically winks at the OS and says \"you see that fault? no I didn't.\"<br>\nAnd then it pretends the attempt to write did not happen.</p>",
        "id": 253304003,
        "sender_full_name": "Jubilee",
        "timestamp": 1631645839
    },
    {
        "content": "<p>i heard that can happen for vector loads on RVV and SVE, didn't know it could happen on stores</p>",
        "id": 253304162,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1631645891
    },
    {
        "content": "<p>which instruction?</p>",
        "id": 253304232,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1631645918
    },
    {
        "content": "<p>as I understand it, all the EVEX (AVX512) scatter/gathers.</p>",
        "id": 253304421,
        "sender_full_name": "Jubilee",
        "timestamp": 1631645999
    },
    {
        "content": "<p>looking at: <a href=\"https://www.felixcloutier.com/x86/vpscatterdd:vpscatterdq:vpscatterqd:vpscatterqq\">https://www.felixcloutier.com/x86/vpscatterdd:vpscatterdq:vpscatterqd:vpscatterqq</a></p>",
        "id": 253305159,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1631646233
    },
    {
        "content": "<p>from what I understand, in x86 lingo, a fault and an exception both cause an interrupt to OS, the OS can either send a signal/abort, or handle it as a transparent page fault (the instruction will resume storing after the OS finishes, eventually all stores will be completed)</p>",
        "id": 253305648,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1631646387
    },
    {
        "content": "<p>the mere fact that llvm uses x86 scatter stores when compiling llvm's ordered scatter means it must not have that crazy store-skipping behavior</p>",
        "id": 253305783,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1631646454
    },
    {
        "content": "<p><a href=\"https://llvm.godbolt.org/z/6Pb6xnEf5\">https://llvm.godbolt.org/z/6Pb6xnEf5</a></p>",
        "id": 253306943,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1631646958
    },
    {
        "content": "<p>A fault is a kind of exception together with trap and abort.</p>\n<p><a href=\"https://wiki.osdev.org/Exceptions\">https://wiki.osdev.org/Exceptions</a></p>\n<blockquote>\n<p>Exceptions are classified as:</p>\n<ul>\n<li>Faults: These can be corrected and the program may continue as if nothing happened.</li>\n<li>Traps: Traps are reported immediately after the execution of the trapping instruction.</li>\n<li>Aborts: Some severe unrecoverable error.</li>\n</ul>\n</blockquote>\n<p>Basically a fault resumes at the same instruction, a trap at the next instruction and an abort is a hardware or OS problem and the instruction pointer may often point anywhere.</p>",
        "id": 253307008,
        "sender_full_name": "bjorn3",
        "timestamp": 1631646966
    },
    {
        "content": "<p>my point is they all go to the OS, and the OS (if it doesn't divert control-flow/abort) will resume the scatter store where it left off, such that when the scatter store completes, all elements will have been stored successfully to memory</p>",
        "id": 253309079,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1631647707
    },
    {
        "content": "<p>It has been a bit since I read this insane detail of the architecture, but my understanding is that the entire \"thing\" is here:</p>\n<blockquote>\n<p>Faults are delivered in a right-to-left manner. That is, if a fault is triggered by an element and delivered, all elements closer to the LSB of the destination ZMM will be completed (and non-faulting). Individual elements closer to the MSB <strong>may or may not</strong> be completed.</p>\n</blockquote>",
        "id": 253311395,
        "sender_full_name": "Jubilee",
        "timestamp": 1631648441
    },
    {
        "content": "<p>That is, it is valid for the architecture to continue writing to all valid addresses and only issue the faults after completing all viable writes.</p>",
        "id": 253311556,
        "sender_full_name": "Jubilee",
        "timestamp": 1631648519
    },
    {
        "content": "<p>This is what I mean by pretending it didn't happen. <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span> <br>\nThis... probably doesn't explode anything, but really this is still very close to \"spooky action at a distance\".</p>\n<p>And at the end of the day, no one is buying me a sufficiently large bottle of painkillers to work through all the ramifications of even an unrestricted version of the EVEX scatters yet.</p>",
        "id": 253312217,
        "sender_full_name": "Jubilee",
        "timestamp": 1631648786
    },
    {
        "content": "<p>those elements closer to the msb if completed will clear their corresponding mask bit, leaving the incompleted elements to store again when the OS resumes the instruction. no elements end up getting skipped completely</p>",
        "id": 253312583,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1631648951
    },
    {
        "content": "<p>Right.</p>",
        "id": 253312642,
        "sender_full_name": "Jubilee",
        "timestamp": 1631648978
    },
    {
        "content": "<p>so, it isn't always ordered</p>",
        "id": 253312649,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1631648981
    },
    {
        "content": "<p>but doesn't skip elements</p>",
        "id": 253312675,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1631648994
    },
    {
        "content": "<p>But it has to not write an element to the same location before handling a fault.</p>",
        "id": 253312803,
        "sender_full_name": "Jubilee",
        "timestamp": 1631649032
    },
    {
        "content": "<p>I have no idea why one write would fault and not the second.</p>",
        "id": 253312840,
        "sender_full_name": "Jubilee",
        "timestamp": 1631649054
    },
    {
        "content": "<p>I am just assuming that in the wild, wooly world of Turing machines, it's possible.</p>",
        "id": 253312886,
        "sender_full_name": "Jubilee",
        "timestamp": 1631649070
    },
    {
        "content": "<p>Possibly the fault handler itself changes machine state enough to legalize the second write.</p>",
        "id": 253312946,
        "sender_full_name": "Jubilee",
        "timestamp": 1631649100
    },
    {
        "content": "<p>because the OS changed the page tables when it handled the fault...that's how a page fault works</p>",
        "id": 253312980,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1631649112
    },
    {
        "content": "<p>so, i guess technically x86 scatters aren't a correct compilation of llvm scatters because they're not always ordered</p>",
        "id": 253313210,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1631649178
    },
    {
        "content": "<p>I think they are \"as-if\" valid.</p>",
        "id": 253313283,
        "sender_full_name": "Jubilee",
        "timestamp": 1631649202
    },
    {
        "content": "<p>unless i missed something in the x86 docs</p>",
        "id": 253313295,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1631649207
    },
    {
        "content": "<p>Like, as I understand it, basically the ordering guarantees are JUST strict enough to validate the LLVM scatter.</p>",
        "id": 253313438,
        "sender_full_name": "Jubilee",
        "timestamp": 1631649250
    },
    {
        "content": "<p>And that is basically why I don't want to deal with a truly racy unrestricted write yet unless someone is paying me for the therapy bills, at least.</p>",
        "id": 253313542,
        "sender_full_name": "Jubilee",
        "timestamp": 1631649294
    },
    {
        "content": "<p>ah, in the x86 docs:</p>\n<blockquote>\n<p>Only writes to overlapping vector indices are guaranteed to be ordered with respect to each other (from LSB to MSB of the source registers). Note that this also include partially overlapping vector indices. Writes that are not overlapped may happen in any order. Memory ordering with other instructions follows the Intel-64 memory ordering model. Note that this does not account for non-overlapping indices that map into the same physical address locations.</p>\n</blockquote>",
        "id": 253313641,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1631649346
    },
    {
        "content": "<p>I'm an American and not a particularly rich one, I don't have good healthcare like people in so-called \"third world communist countries\" do!</p>",
        "id": 253313646,
        "sender_full_name": "Jubilee",
        "timestamp": 1631649350
    },
    {
        "content": "<p>oh, so am I</p>",
        "id": 253313715,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1631649367
    },
    {
        "content": "<p>I think we could provide an unsafe pointer interface with the caveat of you're not allowed to do anything that faults</p>",
        "id": 253313745,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631649384
    },
    {
        "content": "<p>Or more like fault at your own risk</p>",
        "id": 253313770,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631649399
    },
    {
        "content": "<p>well, technically page faults are supposed to be program transparent, where the OS can change  any page to fault at any time (swapping out) as long as the program acts like it's there when accessed (swapping back in)</p>",
        "id": 253313994,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1631649494
    },
    {
        "content": "<p>I'm pretty sure the slice one could technically fault if you ran out of ram and the slice swapped out</p>",
        "id": 253314017,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631649502
    },
    {
        "content": "<p>Yep</p>",
        "id": 253314098,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631649533
    },
    {
        "content": "<p>Right, I think saying \"don't write to the same location twice in our <code>unsafe</code> scatter\" is fine.</p>",
        "id": 253314171,
        "sender_full_name": "Jubilee",
        "timestamp": 1631649565
    },
    {
        "content": "<p>If you can't swap back in youll probably get similarly weird behavior as if you had an access violation</p>",
        "id": 253314186,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631649573
    },
    {
        "content": "<p>I actually think it's probably fine as long as you're not doing anything particularly weird</p>",
        "id": 253314309,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631649608
    },
    {
        "content": "<p>hmm, well I'd say as long as a loop of scalar stores to each pointer in the vector is valid, a ordered scatter should be just as valid, hence a store to a vector of shared references to cells doesn't need to be unsafe</p>",
        "id": 253314634,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1631649709
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"229517\">Jacob Lifshay</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/Why.20is.20scatter.20ordered.3F/near/253313715\">said</a>:</p>\n<blockquote>\n<p>oh, so am I</p>\n</blockquote>\n<p>Oh yes I expected as much. I am just emphasizing that we have limited bandwidth and  the cost of even maintaining spicy unordered scatter code is pretty high, nevermind developing it. It's a nontrivial ask.</p>",
        "id": 253314833,
        "sender_full_name": "Jubilee",
        "timestamp": 1631649771
    },
    {
        "content": "<p>You mean a vector of &amp;mut?  I didn't even consider the possibility of reference vectors <span aria-label=\"eyes\" class=\"emoji emoji-1f440\" role=\"img\" title=\"eyes\">:eyes:</span></p>",
        "id": 253314891,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631649793
    },
    {
        "content": "<p>That does sound plausible too.</p>",
        "id": 253314900,
        "sender_full_name": "Jubilee",
        "timestamp": 1631649796
    },
    {
        "content": "<p>I actually like the idea of an unsafe function on pointer vectors casting it to references</p>",
        "id": 253315065,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631649851
    },
    {
        "content": "<p>yeah actually.<br>\nA bunch of &amp;mut locations should be safe.</p>",
        "id": 253315072,
        "sender_full_name": "Jubilee",
        "timestamp": 1631649854
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">safe_scatter</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">ptrs</span>: <span class=\"nc\">Simd</span><span class=\"o\">&lt;&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"n\">Cell</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">values</span>: <span class=\"nc\">Simd</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">mask</span>: <span class=\"nc\">SimdMask</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">ordered_scatter</span><span class=\"p\">(</span><span class=\"n\">ptrs</span><span class=\"p\">.</span><span class=\"n\">to_ptrs</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">values</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">mask</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 253315118,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1631649871
    },
    {
        "content": "<p>spicy.</p>",
        "id": 253315132,
        "sender_full_name": "Jubilee",
        "timestamp": 1631649877
    },
    {
        "content": "<p>Why cell, and not &amp;mut?</p>",
        "id": 253315214,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631649905
    },
    {
        "content": "<p>I used a vector of <code>&amp;Cell&lt;T&gt;</code> since that allows duplicates</p>",
        "id": 253315252,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1631649923
    },
    {
        "content": "<p>Oh, like duplicates</p>",
        "id": 253315283,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631649939
    },
    {
        "content": "<p>Good point</p>",
        "id": 253315286,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631649941
    },
    {
        "content": "<p>Either would be valid</p>",
        "id": 253315322,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631649962
    },
    {
        "content": "<p>I feel some strange apis brewing, but I like them</p>",
        "id": 253315410,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631649986
    },
    {
        "content": "<p>scatter to <code>&amp;mut T</code> allows using scatter unordered, since there won't ever be duplicates</p>",
        "id": 253315475,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1631650012
    },
    {
        "content": "<p>yeah.</p>",
        "id": 253315522,
        "sender_full_name": "Jubilee",
        "timestamp": 1631650030
    },
    {
        "content": "<p>vectors + references + lifetimes = awesome superpowers + headache</p>",
        "id": 253315732,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1631650110
    },
    {
        "content": "<p>Now I am imagining scattering to refcells.  Which I think could be done with a sequence of checks followed by two scatters</p>",
        "id": 253315873,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631650177
    },
    {
        "content": "<p>Actually, a gather and then a scatter</p>",
        "id": 253315912,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631650193
    },
    {
        "content": "<p>well...refcells are only useful for non-copy <code>T</code>, all currently supported <code>T</code> are <code>Copy</code> ... though if we add <code>&amp;mut T</code>, that's non-copy.</p>",
        "id": 253316275,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1631650339
    },
    {
        "content": "<p>I'd be inclined to require <code>T: Copy</code> and make users use <code>&amp;Cell&lt;T&gt;</code></p>",
        "id": 253316436,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1631650409
    },
    {
        "content": "<p>Anyways hannah if you want to have unordered scatters we would probably have to see the documentation for the unordered scatter APIs you are mentioning (again, not the <code>packed_simd</code> one, as it is secretly ordered), and you would probably have to show them to LLVM too because I don't see us doing so hot at supporting something like that when our upstream does not.</p>",
        "id": 253317765,
        "sender_full_name": "Jubilee",
        "timestamp": 1631650960
    },
    {
        "content": "<blockquote>\n<p>umm, if a scatter store faults, isn't that a SIGSEGV?</p>\n</blockquote>\n<p>No, if that faults, its UB, and LLVM requires the user to make sure it never happens.</p>\n<p>AVX-512 hardware says that the writes are ordered, so the first one will fault. But the faulting does not matter from LLVM's point of view because it can never happen in a valid program.</p>",
        "id": 253423880,
        "sender_full_name": "hannahE2",
        "timestamp": 1631716308
    },
    {
        "content": "<blockquote>\n<p>For genuinely unordered writes, LLVM is allowed to sequence them however it sees fit.</p>\n</blockquote>\n<p>We are talking here about the writes being \"unordered\" for the scatter instruction. The scatter itself has to happen in coherence order, and there exists a coherence order for the writes within the scatter in the memory model, even if we say that this order can be different each time. </p>\n<p>\"Truly unordered\" is not a thing. Basically, what scatter can say is that it generates a random permutation of writes to the same index, and writes in the order given by that random permutation, but that's pretty much it. LLVM can lower this to whatever is most efficient, and LLVM optimizations only can assume the value written if LLVM lowers the scatter to a hw specific LLVM intrinsic that guarantees the order. Otherwise they can at most assume that one of the values passed will be written, and if they are all the same, well then they can assume that this value was written.</p>",
        "id": 253424595,
        "sender_full_name": "hannahE2",
        "timestamp": 1631716550
    },
    {
        "content": "<p>I am happy with <code>packed_simd2</code> so that's what I'll continue using.</p>",
        "id": 253424800,
        "sender_full_name": "hannahE2",
        "timestamp": 1631716626
    },
    {
        "content": "<p>I tried the new APIs on my app but the perf was ~60% slower due to all the stuff the safe scatter API is doing.</p>",
        "id": 253424934,
        "sender_full_name": "hannahE2",
        "timestamp": 1631716669
    },
    {
        "content": "<p>And there appears to be other issues like way worse instructions being generated for the different shuffles :/</p>",
        "id": 253425084,
        "sender_full_name": "hannahE2",
        "timestamp": 1631716717
    },
    {
        "content": "<p>But I really don't have time to look into any of this much.</p>",
        "id": 253425129,
        "sender_full_name": "hannahE2",
        "timestamp": 1631716731
    },
    {
        "content": "<p>Can you explain what the difference is in your usage? That has nothing to do with ordering, packed-simd lowers to the exact same LLVM intrinsic.</p>",
        "id": 253425138,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631716733
    },
    {
        "content": "<p>It is true that we simply haven't gotten around to an entirely unchecked API yet, but we do plan on it.</p>",
        "id": 253425208,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631716758
    },
    {
        "content": "<p>packed-simd doesn't do bounds check, nor masks checks, etc. its a raw pointer write. the new simd api lowers to 3x more hw instructions</p>",
        "id": 253425276,
        "sender_full_name": "hannahE2",
        "timestamp": 1631716780
    },
    {
        "content": "<p>API-wise, i'd be in general against making Rust do what intel does just because intel implemented llvm.masked.scatter in LLVM upstream</p>",
        "id": 253425459,
        "sender_full_name": "hannahE2",
        "timestamp": 1631716829
    },
    {
        "content": "<p>i want portable SIMD to work on RISC-V well, and what works there best is the unordered scatter</p>",
        "id": 253425503,
        "sender_full_name": "hannahE2",
        "timestamp": 1631716855
    },
    {
        "content": "<p>i am fine with providing both versions, ordered and unordered, but someone arguing that the default should be ordered should have an argument about \"why is ordered better for applications that will use this API, and which apps, etc.\"</p>",
        "id": 253425599,
        "sender_full_name": "hannahE2",
        "timestamp": 1631716905
    },
    {
        "content": "<p>like, \"which apps need the ordering\"</p>",
        "id": 253425611,
        "sender_full_name": "hannahE2",
        "timestamp": 1631716913
    },
    {
        "content": "<p>the argument \"intel gave llvm.masked.scatter ordered semantics therefore we do so for rust\" is weak, i'd rather not have the intrinsic as portable than have it without good motivation</p>",
        "id": 253425791,
        "sender_full_name": "hannahE2",
        "timestamp": 1631716975
    },
    {
        "content": "<p>The LLVM intrinsic isn't Intel specific, it also matches the SVE ST1 instruction</p>",
        "id": 253426129,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631717104
    },
    {
        "content": "<p>Does the portable simd support SVE?</p>",
        "id": 253426449,
        "sender_full_name": "hannahE2",
        "timestamp": 1631717224
    },
    {
        "content": "<p>the LLVM intrinsic does not support it</p>",
        "id": 253426518,
        "sender_full_name": "hannahE2",
        "timestamp": 1631717251
    },
    {
        "content": "<p>(it requires a \"packed\" SIMD vector, while SVE vectors are \"scalable\")</p>",
        "id": 253426561,
        "sender_full_name": "hannahE2",
        "timestamp": 1631717269
    },
    {
        "content": "<p>It would need rustc support, but it would work with the <code>sve-vector-bits</code> option</p>",
        "id": 253426708,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631717327
    },
    {
        "content": "<p>LLVM can absolutely treat SVE vectors as regular sized vectors</p>",
        "id": 253426966,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631717417
    },
    {
        "content": "<p>can you show a godbolt example ?</p>",
        "id": 253427736,
        "sender_full_name": "hannahE2",
        "timestamp": 1631717699
    },
    {
        "content": "<p>what does <code>mem::size_of::&lt;V&gt;</code> return when <code>V</code> is a scalable vector ?</p>",
        "id": 253427954,
        "sender_full_name": "hannahE2",
        "timestamp": 1631717774
    },
    {
        "content": "<p>It would return the value determined by the current target features</p>",
        "id": 253428126,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631717838
    },
    {
        "content": "<p>?</p>",
        "id": 253428146,
        "sender_full_name": "hannahE2",
        "timestamp": 1631717849
    },
    {
        "content": "<p>You embed the SVE vector size in the ABI (or the entire program)</p>",
        "id": 253428219,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631717880
    },
    {
        "content": "<p>the code must run well on CPU0 with 128-bit SIMD vectors and CPU1 with 1024-bit vectors</p>",
        "id": 253428261,
        "sender_full_name": "hannahE2",
        "timestamp": 1631717883
    },
    {
        "content": "<p>if you have to pick 128-bit, then your code will run very poorly on a CPU with 1024-bit vectors</p>",
        "id": 253428326,
        "sender_full_name": "hannahE2",
        "timestamp": 1631717909
    },
    {
        "content": "<p>Yes, so you would multiversion the ABI just as you would with regular instruction sets</p>",
        "id": 253428341,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631717917
    },
    {
        "content": "<p>the whole point of SVE is not having to hardcode the vector length in your program</p>",
        "id": 253428353,
        "sender_full_name": "hannahE2",
        "timestamp": 1631717922
    },
    {
        "content": "<p>compile once, run everywhere, reasonably well</p>",
        "id": 253428374,
        "sender_full_name": "hannahE2",
        "timestamp": 1631717932
    },
    {
        "content": "<p>like, not having to multiversion the ABI is literally the main and only feature of SVE</p>",
        "id": 253428562,
        "sender_full_name": "hannahE2",
        "timestamp": 1631717999
    },
    {
        "content": "<p>when using C I don't have to do that, so I don't see why an API that forces you to do that would be acceptable for Rust</p>",
        "id": 253428714,
        "sender_full_name": "hannahE2",
        "timestamp": 1631718026
    },
    {
        "content": "<p>Well, you can write code that way, but then you can't for example pass vectors on the stack</p>",
        "id": 253428838,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631718072
    },
    {
        "content": "<p>can you show a godbolt example of the code that <code>core::simd</code> generates for this ?</p>",
        "id": 253428949,
        "sender_full_name": "hannahE2",
        "timestamp": 1631718117
    },
    {
        "content": "<p>I already said I believe it still needs rustc support, but LLVM supports it.</p>",
        "id": 253429069,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631718144
    },
    {
        "content": "<p>i'd expect a good api for scalable vectors and the fixed-size vectors to be relatively different</p>",
        "id": 253429092,
        "sender_full_name": "hannahE2",
        "timestamp": 1631718152
    },
    {
        "content": "<p>If you are looking to use them as unsized types, then you'll have to use the vendor intrinsics whenever those are available</p>",
        "id": 253429881,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631718418
    },
    {
        "content": "<p>An inherent limitation on std::simd being portable is that the vectors are sized</p>",
        "id": 253429957,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631718448
    },
    {
        "content": "<p>the only reason people would use a explicit simd api is perf</p>",
        "id": 253429972,
        "sender_full_name": "hannahE2",
        "timestamp": 1631718452
    },
    {
        "content": "<p>better to not support sve, than to support it with horrible perf</p>",
        "id": 253430020,
        "sender_full_name": "hannahE2",
        "timestamp": 1631718469
    },
    {
        "content": "<p>The performance would not be horrible? It would likely actually be more performant, since you can pass vectors on the stack, at the cost of a larger binary</p>",
        "id": 253430208,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631718517
    },
    {
        "content": "<p>if you have to pick 128-bit SVE for portability, perf on a 1024-bit wide SVE unit would be horrible</p>",
        "id": 253430277,
        "sender_full_name": "hannahE2",
        "timestamp": 1631718544
    },
    {
        "content": "<p>if that were even possible</p>",
        "id": 253430321,
        "sender_full_name": "hannahE2",
        "timestamp": 1631718563
    },
    {
        "content": "<p>Like I said, you would multiversion, just as you need to multiversion for the various Intel vector sizes</p>",
        "id": 253430359,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631718579
    },
    {
        "content": "<p>but for SVE the vector size is fixed and the user can't change it, so if you have to pick a length at compile time and multi version, your code would only work on that version</p>",
        "id": 253430386,
        "sender_full_name": "hannahE2",
        "timestamp": 1631718594
    },
    {
        "content": "<p>because at runtime its value is only controlled by the hardware</p>",
        "id": 253430450,
        "sender_full_name": "hannahE2",
        "timestamp": 1631718604
    },
    {
        "content": "<p>so you'd need to multi-version for all powers of 2 in range[128, 4096) which would blow up your binary size</p>",
        "id": 253430496,
        "sender_full_name": "hannahE2",
        "timestamp": 1631718625
    },
    {
        "content": "<p>the only problem SVE solves is this one</p>",
        "id": 253430520,
        "sender_full_name": "hannahE2",
        "timestamp": 1631718637
    },
    {
        "content": "<p>so might as well just use NEON, which is supported on all SVE hardware</p>",
        "id": 253430551,
        "sender_full_name": "hannahE2",
        "timestamp": 1631718648
    },
    {
        "content": "<p>Yes, that is your choice as the user</p>",
        "id": 253430590,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631718666
    },
    {
        "content": "<p>at least on A64FX you can't pick a vector length different from 512</p>",
        "id": 253430599,
        "sender_full_name": "hannahE2",
        "timestamp": 1631718669
    },
    {
        "content": "<p>so if you allow people to generate code for 128-bit using target features, that would have UB at runtime on A64FX</p>",
        "id": 253430647,
        "sender_full_name": "hannahE2",
        "timestamp": 1631718689
    },
    {
        "content": "<p>because all hardware instructions will try to read 512-bits from your 128-bit data types</p>",
        "id": 253430683,
        "sender_full_name": "hannahE2",
        "timestamp": 1631718705
    },
    {
        "content": "<p>have you ever used SVE?</p>",
        "id": 253430717,
        "sender_full_name": "hannahE2",
        "timestamp": 1631718720
    },
    {
        "content": "<p>No, I have not yet encountered a device with it</p>",
        "id": 253430926,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631718788
    },
    {
        "content": "<p>ok, i'm out of this group now</p>",
        "id": 253430960,
        "sender_full_name": "hannahE2",
        "timestamp": 1631718805
    },
    {
        "content": "<p>this was all a waste of time</p>",
        "id": 253430973,
        "sender_full_name": "hannahE2",
        "timestamp": 1631718810
    },
    {
        "content": "<p>Look, like I have said before, we are all volunteers.  We test dozens of architectures--of course I don't own one of each.</p>",
        "id": 253431441,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1631718976
    },
    {
        "content": "<p>do note that llvm's <code>llvm.masked.scatter.*</code> intrinsic totally supports scalable vectors: <a href=\"https://github.com/llvm/llvm-project/blob/3852b8c70fbf5ad55e87ab5ccb0bd2f0a5c65977/llvm/test/CodeGen/RISCV/rvv/mscatter-sdnode.ll\">https://github.com/llvm/llvm-project/blob/3852b8c70fbf5ad55e87ab5ccb0bd2f0a5c65977/llvm/test/CodeGen/RISCV/rvv/mscatter-sdnode.ll</a></p>",
        "id": 253456564,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1631727560
    }
]