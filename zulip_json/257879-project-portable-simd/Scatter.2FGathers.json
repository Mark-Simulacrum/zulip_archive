[
    {
        "content": "<p>I know this a big one, but has there been talk on how to implement and handle scatter/gather instructions. I suspect with masks and selects that LLVM might already output them, but I don't know how much I would trust them.</p>",
        "id": 242482002,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1623546318
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span> is in the process of putting together a PR for that!</p>",
        "id": 242482048,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1623546369
    },
    {
        "content": "<p>Awesome, probably the last thing I think I need to have direct control over to write pretty much anything. LLVM already trivially uses ternlog instructions and FMAs when it detects that pattern. Scatters and gathers will make this usable for all my SIMD code I think!</p>",
        "id": 242482062,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1623546458
    },
    {
        "content": "<p>Hmm, LLVM generates FMA?  I think more recent versions of nightly shouldn't since that was probably a bug.</p>",
        "id": 242482104,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1623546519
    },
    {
        "content": "<p>One thing that'll be kinda tricky is doing scatter/gathers on u16s and stuff, where you don't actually have usize indicies. But it'd also be nice to be able to somehow do scatter/gathers on SimdU16 values, but with usizes (where LLVM/Rust would break it down into the larger pieces, and then join the vectors back)</p>",
        "id": 242482105,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1623546532
    },
    {
        "content": "<p>Though we will have an FMA function eventually</p>",
        "id": 242482109,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1623546544
    },
    {
        "content": "<p>Hmmm, maybe it doesnt? I know it makes ternlog.</p>",
        "id": 242482111,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1623546550
    },
    {
        "content": "<p>That's good, I'd expect ternlog to be generated from selects</p>",
        "id": 242482174,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1623546621
    },
    {
        "content": "<p>Yeah, doesn't look like it generates FMA. What's the reason for that? The internal precision of FMA not matching explicit multiply and add?</p>",
        "id": 242482200,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1623546722
    },
    {
        "content": "<p>Yeah, we want every operation to be completely compliant with IEEE 754 (not just vector ops, but scalar too)</p>",
        "id": 242482291,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1623546893
    },
    {
        "content": "<p>Makes sense!</p>",
        "id": 242482349,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1623546974
    },
    {
        "content": "<p>Yeah, the ideal we've wound up angling for is to just have everything be in principle a properly-aligned version of [T; N] that has some syntax sugar and some special parallel ops.</p>",
        "id": 242483990,
        "sender_full_name": "Jubilee",
        "timestamp": 1623549789
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"356799\">Brandon Falk</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/Scatter.2FGathers/near/242482105\">said</a>:</p>\n<blockquote>\n<p>One thing that'll be kinda tricky is doing scatter/gathers on u16s and stuff, where you don't actually have usize indicies. But it'd also be nice to be able to somehow do scatter/gathers on SimdU16 values, but with usizes (where LLVM/Rust would break it down into the larger pieces, and then join the vectors back)</p>\n</blockquote>\n<p>I am... mildly perplexed by what you mean by \"don't have usize indices\" here?</p>",
        "id": 242484078,
        "sender_full_name": "Jubilee",
        "timestamp": 1623549921
    },
    {
        "content": "<p>Internally, LLVM takes the stance that scatter/gather is a vector of pointers with a vector mask and a base vector (so it's always actually a <code>select + gather</code> or <code>select + scatter</code>).</p>",
        "id": 242484183,
        "sender_full_name": "Jubilee",
        "timestamp": 1623550083
    },
    {
        "content": "<p>So unfortunately Rust's portable SIMD API pushes the limits of what rustc and LLVM are capable of understanding. If you wanted LLVM to use an instruction that doesn't use full pointer-width indices, then it might compile to that incidentally but we don't have a meaningful way of expressing that.</p>",
        "id": 242484220,
        "sender_full_name": "Jubilee",
        "timestamp": 1623550168
    },
    {
        "content": "<p>Hmm yeah, this is tough. There's a <code>vpscatterdd</code> which is <code>*(base + [signextend(index32); 16])</code>. Which is strange, 64-bit base, 32-bit indicies. But for a lot of data (&lt;4 GiB) it's usually what you want, especially if you're working with <code>f32</code>s and <code>u32</code>s, which is kinda most of the time for some heavy compute loops</p>",
        "id": 242485296,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1623551811
    },
    {
        "content": "<p>And you can kinda work around some limitations as you can do <code>vpgatherdd zmm0, [rax + zmm1*8]</code>, where the scalar can be 1, 2, 4, or 8, so you can actually index beyond 4 GiB with a 32-bit int, which is often more than sufficient for indexing even a large data set, without having to break it into 2 instructions to use 64-bit indicies. It's definitely a bit strange</p>",
        "id": 242485566,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1623552124
    },
    {
        "content": "<p>The actual op for x86 scatter/gathers is <code>base + signextend(index) * scale</code>, where scale is <code>1, 2, 4, 8</code> and index may be 32-bit or 64-bit. There is also <code>dq</code> and <code>qd</code> variants which use 32-bit indicies and fill into 64-bit vectors, and the opposite (conversion + scatter/gather)<br>\n<code>vpgatherdq</code></p>\n<blockquote>\n<p>Gather 64-bit integers from memory using 32-bit indices. 64-bit elements are loaded from addresses starting at base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst. scale should be 1, 2, 4 or 8.</p>\n</blockquote>\n<p><code>vpgatherqd</code></p>\n<blockquote>\n<p>Gather 32-bit integers from memory using 64-bit indices. 32-bit elements are loaded from addresses starting at base_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst. scale should be 1, 2, 4 or 8.</p>\n</blockquote>",
        "id": 242485802,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1623552394
    },
    {
        "content": "<p>Are they worth engineering around? Hard to say, but there are pretty valid uses for this, especially if you want to potentially eliminate two data sets and use one where the conversion is done in the instruction</p>",
        "id": 242485818,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1623552473
    },
    {
        "content": "<p>Mmm. If the SIMD gather/scatter using the portable intrinsics doesn't compile to using those instructions ever, then likely it'd be more productive to file a bug against upstream, honestly, because \"base pointer + offsets\" isn't so wild an idea.</p>",
        "id": 242490316,
        "sender_full_name": "Jubilee",
        "timestamp": 1623560083
    },
    {
        "content": "<p>Is FMA just fused multiply add but in SIMD vectors?</p>",
        "id": 242493170,
        "sender_full_name": "Miguel Raz Guzmán Macedo",
        "timestamp": 1623565029
    },
    {
        "content": "<p>yes.</p>",
        "id": 242493245,
        "sender_full_name": "Jubilee",
        "timestamp": 1623565155
    },
    {
        "content": "<p>Noice.</p>",
        "id": 242540259,
        "sender_full_name": "Miguel Raz Guzmán Macedo",
        "timestamp": 1623631905
    },
    {
        "content": "<p>Anyways the nuances of the AVX gather/scatter API being more apt to the base + offsets model is why I intend to only yield a scatter/gather implementation that tags a single slice per function. We can't <strong>make</strong> LLVM do the right thing, but we can gently... ah... peer pressure it.</p>",
        "id": 242548832,
        "sender_full_name": "Jubilee",
        "timestamp": 1623643025
    },
    {
        "content": "<p>Hopefully deriving all the pointers from a base pointer will show it the light.</p>",
        "id": 242548835,
        "sender_full_name": "Jubilee",
        "timestamp": 1623643034
    },
    {
        "content": "<p>I think it would probably be reasonable if that's the only API we exposed, and anything else would need vendor intrinsics</p>",
        "id": 242549119,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1623643379
    },
    {
        "content": "<p>I disagree...I think scatter/gather based on vectors of pointers should be the API that we provide -- it should not be relegated to using arch-specific intrinsics, which would be overoptimizing the API for Intel's ISA imho.</p>",
        "id": 242552664,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1623646904
    },
    {
        "content": "<p>I don't object to having a scatter/gather API based on array indexing, however I think we would be making a serious mistake to say that array-indexing API is sufficient with no need to add pointer-vector APIs.</p>",
        "id": 242552822,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1623647106
    },
    {
        "content": "<p>It's worth noting that SVE also uses a single pointer with type-width offsets</p>",
        "id": 242552948,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1623647237
    },
    {
        "content": "<p>It's definitely not Intel-specific</p>",
        "id": 242552967,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1623647268
    },
    {
        "content": "<p>I think vectors of pointers are likely not going to be portable or efficient</p>",
        "id": 242553022,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1623647323
    },
    {
        "content": "<p>Well, both Intel and Arm SVE support loading from vectors of pointers. One of the SVE gather instructions has 64-bit vector elements for the input vector register, it calculates the addresses by adding a shifted 5-bit immediate to the input 64-bit vector elements, then loads 32-bit words from those addresses and then writes them to the destination vector after zero-extending the loaded words to 64-bits: <a href=\"https://developer.arm.com/documentation/ddi0602/latest/SVE-Instructions/LD1W--vector-plus-immediate---Gather-load-unsigned-words-to-vector--immediate-index--?lang=en#iclass_64_elem\">https://developer.arm.com/documentation/ddi0602/latest/SVE-Instructions/LD1W--vector-plus-immediate---Gather-load-unsigned-words-to-vector--immediate-index--?lang=en#iclass_64_elem</a></p>",
        "id": 242554820,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1623649567
    },
    {
        "content": "<p>that instruction is <em>totally</em> useless except for gathering from a vector of pointers</p>",
        "id": 242554843,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1623649628
    },
    {
        "content": "<p>since SVE's designers went <em>out of their way</em> to add a whole class of load/store instructions just for use with vectors of pointers (the load/store with vector+immediate address), and since many other architectures also support gather/scatter with vectors of pointers (AVX2, AVX512, Libre-SOC's SimpleV extension for OpenPower, RISC-V V, and more), I think that's sufficient motivation to add support for vectors of pointers.</p>",
        "id": 242555238,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1623650086
    },
    {
        "content": "<p>in fact, all gather/scatter ISAs that I'm aware of support vectors of pointers.</p>",
        "id": 242555412,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1623650305
    },
    {
        "content": "<p>As far as I am concerned the real issue is programming ergonomics, and manipulating pointers is tricky. A safe, slice-oriented API satisfies most needs here without tying us too tightly to implementation details, and it will hopefully compile in a reasonably efficient way.</p>\n<p>As we encounter more exotic concerns, we can address those on a case-by-case basis, and eventually we may expose such an API as you propose, Jacob, but really... pointers have a lot of unsettled questions and we're already in Ralf's face every five seconds to ask questions about target feature and const eval related stuff. I want to give the man a chance to catch his breath before I bombard him with 128 bits every nanosecond of questions about SIMD and pointers.</p>",
        "id": 242652542,
        "sender_full_name": "Jubilee",
        "timestamp": 1623701273
    },
    {
        "content": "<p>Okay, rebuilt my scatter/gather branch and somehow the way I redid it this time to \"properly\" add in pointers and scatter/gather and such causes \"unused\" errors to not be emitted in most cases. Go figure.</p>",
        "id": 242798816,
        "sender_full_name": "Jubilee",
        "timestamp": 1623790701
    },
    {
        "content": "<p>I think based on the recent... uh... comments? we might add scatter/gather_unchecked as a <em>minimally unsafe</em> API extension.</p>",
        "id": 254738991,
        "sender_full_name": "Jubilee",
        "timestamp": 1632503525
    },
    {
        "content": "<p>Hmm did we never add any unchecked variant?</p>",
        "id": 254739117,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1632503582
    },
    {
        "content": "<p>nah, I didn't want to bother heh.</p>",
        "id": 254739179,
        "sender_full_name": "Jubilee",
        "timestamp": 1632503615
    },
    {
        "content": "<p>I think we can add an unchecked variant with a matching API, and eventually we can add the one that takes pointers</p>",
        "id": 254739255,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1632503636
    },
    {
        "content": "<p>oh, i definitely think we should have unsafe variations of stuff where the safety has a performance overhead.</p>",
        "id": 254739984,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1632503853
    },
    {
        "content": "<p>yeah, I am thinking adding it on only the <code>_select</code> variant too, so that it has the thinnest API layer to the underlying intrinsic, and also implicitly requires them to assert \"yeah this is fine.\"</p>",
        "id": 254739991,
        "sender_full_name": "Jubilee",
        "timestamp": 1632503854
    },
    {
        "content": "<p>\"yeah I want to read <strong>all of these indices</strong>\".</p>",
        "id": 254740083,
        "sender_full_name": "Jubilee",
        "timestamp": 1632503884
    },
    {
        "content": "<p>Yeah, if you're doing it unchecked I think it should only be on the most explicit one</p>",
        "id": 254740200,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1632503942
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/Scatter.2FGathers/near/254739984\">said</a>:</p>\n<blockquote>\n<p>oh, i definitely think we should have unsafe variations of stuff where the safety has a performance overhead.</p>\n</blockquote>\n<p>yeah the... recent thread on this was deeply confusing.</p>",
        "id": 254740250,
        "sender_full_name": "Jubilee",
        "timestamp": 1632503970
    },
    {
        "content": "<p>I always took your implementation to be the MVP</p>",
        "id": 254740307,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1632504001
    },
    {
        "content": "<p>We always knew there was more to add, particularly vector-of-pointers</p>",
        "id": 254740389,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1632504019
    },
    {
        "content": "<p>because it was making a complaint that... didn't make much sense to me? until at the end we found out it was actually about performance concerns due to the underlying function constructing a mask.</p>",
        "id": 254740403,
        "sender_full_name": "Jubilee",
        "timestamp": 1632504027
    },
    {
        "content": "<p>and then I was like \"oh okay.\"</p>",
        "id": 254740538,
        "sender_full_name": "Jubilee",
        "timestamp": 1632504089
    },
    {
        "content": "<p>Wouldn't worry too much about that</p>",
        "id": 254740629,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1632504121
    },
    {
        "content": "<p>It can be a bit much if you're doing it a lot in a hot loop.</p>",
        "id": 254740704,
        "sender_full_name": "Jubilee",
        "timestamp": 1632504137
    },
    {
        "content": "<p>also why are you using scatter/gather in a hot loop</p>",
        "id": 254740722,
        "sender_full_name": "Jubilee",
        "timestamp": 1632504147
    },
    {
        "content": "<p>but I digress</p>",
        "id": 254740743,
        "sender_full_name": "Jubilee",
        "timestamp": 1632504155
    },
    {
        "content": "<p>The check is actually surprising efficient, but not nothing</p>",
        "id": 254740850,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1632504208
    },
    {
        "content": "<p>imho <code>gather/scatter_unchecked</code> should allow setting a base ptr of null and having the vector of <code>usize</code> offsets be pointers</p>",
        "id": 254742000,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1632504678
    },
    {
        "content": "<p>eek</p>",
        "id": 254742079,
        "sender_full_name": "Jubilee",
        "timestamp": 1632504715
    },
    {
        "content": "<p>it allows making a poor-man's pointer vector scatter/gather</p>",
        "id": 254742201,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1632504752
    },
    {
        "content": "<p>It's invalid actually.</p>",
        "id": 254742265,
        "sender_full_name": "Jubilee",
        "timestamp": 1632504786
    },
    {
        "content": "<p>I think that's technically fine with the pointer manipulations we're doing?</p>",
        "id": 254742284,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1632504792
    },
    {
        "content": "<p>It requires forging the nullptr into a slice.</p>",
        "id": 254742290,
        "sender_full_name": "Jubilee",
        "timestamp": 1632504796
    },
    {
        "content": "<p>Oh, not with our API, agreed wrt that</p>",
        "id": 254742340,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1632504817
    },
    {
        "content": "<p>oh, <code>scatter/gather_unchecked</code> should just take a base ptr, no length imho</p>",
        "id": 254742442,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1632504851
    },
    {
        "content": "<p>so <code>unsafe fn gather&lt;T, const N: usize&gt;(base: *const T, indexes: Simd&lt;isize, N&gt;) -&gt; Simd&lt;T, N&gt;</code></p>",
        "id": 254742633,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1632504945
    },
    {
        "content": "<p><code>isize</code> allows indexing backwards</p>",
        "id": 254742670,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1632504961
    },
    {
        "content": "<p>It depends if we need to enforce anything with provenance or not</p>",
        "id": 254742737,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1632504975
    },
    {
        "content": "<p>I believe we do not in this case</p>",
        "id": 254742768,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1632504990
    },
    {
        "content": "<p>semantically it should be equivalent to <code>for i in 0..N { retval[i] = *((base as usize).wrapping_add(index[i] as usize) as *const T); }</code></p>",
        "id": 254742956,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1632505071
    },
    {
        "content": "<p>terrifying.</p>",
        "id": 254743145,
        "sender_full_name": "Jubilee",
        "timestamp": 1632505136
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/Scatter.2FGathers/near/254742737\">said</a>:</p>\n<blockquote>\n<p>It depends if we need to enforce anything with provenance or not</p>\n</blockquote>\n<p>uhhhhh.</p>",
        "id": 254743189,
        "sender_full_name": "Jubilee",
        "timestamp": 1632505155
    },
    {
        "content": "<p>when I explained what happens in my code for the scatter/gather API, Ralf made a \"that's correct but it should be illegal\" noise.</p>",
        "id": 254743346,
        "sender_full_name": "Jubilee",
        "timestamp": 1632505209
    },
    {
        "content": "<p>oh, oops, did i forget a multiplication by sizeof T?</p>",
        "id": 254743352,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1632505211
    },
    {
        "content": "<p>like</p>",
        "id": 254743467,
        "sender_full_name": "Jubilee",
        "timestamp": 1632505263
    },
    {
        "content": "<p>the impl as written may literally be invalidated in the future</p>",
        "id": 254743498,
        "sender_full_name": "Jubilee",
        "timestamp": 1632505276
    },
    {
        "content": "<p>Hmm. I thought I looked at LLVM docs and it seemed fine</p>",
        "id": 254743653,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1632505333
    },
    {
        "content": "<p>should it be <code>unsafe fn gather_unchecked_byte_addressing&lt;T, const N: usize&gt;(base: *const (), byte_offsets: Simd&lt;isize, N&gt;) -&gt; Simd&lt;T, N&gt;</code></p>",
        "id": 254743736,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1632505375
    },
    {
        "content": "<p>I don't think the type really matters</p>",
        "id": 254743800,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1632505402
    },
    {
        "content": "<p>If you want to do something like that, just use u8 and cast it</p>",
        "id": 254743882,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1632505432
    },
    {
        "content": "<p>Transmute it</p>",
        "id": 254743894,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1632505439
    },
    {
        "content": "<p>Well</p>",
        "id": 254743965,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1632505461
    },
    {
        "content": "<p>well, <code>gather_unchecked_byte_addressing</code> skips the mul by <code>sizeof::&lt;T&gt;()</code>, allowing you to pass pointers</p>",
        "id": 254743988,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1632505475
    },
    {
        "content": "<p>I think the best place to start with an unchecked API is to just use vectors-of-pointers</p>",
        "id": 254744037,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1632505496
    },
    {
        "content": "<p>Deal with any in-between APIs later</p>",
        "id": 254744079,
        "sender_full_name": "Caleb Zulawski",
        "timestamp": 1632505515
    },
    {
        "content": "<p>if there is the mul by <code>sizeof::&lt;T&gt;()</code> then you can only operate on <code>u8</code> vectors unless the pointers are multiples of <code>sizeof::&lt;T&gt;()</code> and you divide ahead of time</p>",
        "id": 254744219,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1632505569
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312331\">Caleb Zulawski</span> <a href=\"#narrow/stream/257879-project-portable-simd/topic/Scatter.2FGathers/near/254743653\">said</a>:</p>\n<blockquote>\n<p>Hmm. I thought I looked at LLVM docs and it seemed fine</p>\n</blockquote>\n<p>It's subtly issue-laden.</p>",
        "id": 254744254,
        "sender_full_name": "Jubilee",
        "timestamp": 1632505586
    },
    {
        "content": "<p>well, the nice part is the llvm intinsics just take a vector of pointers and make you do the address calc yourself, so we could do <code>wrapping_add</code> if we want</p>",
        "id": 254744619,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1632505748
    }
]