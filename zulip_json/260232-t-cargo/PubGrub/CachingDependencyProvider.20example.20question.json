[
    {
        "content": "<p>Hello all! I've been trying to understand the CachingDependencyProvider and was confused by the way that the <code>choose_package_version</code> method always uses the remote rather than the cache.</p>\n<p><a href=\"https://github.com/pubgrub-rs/pubgrub/blob/717289be5722dd5caaa0d1f4ed13047d11a7f7fd/examples/caching_dependency_provider.rs#L34\">https://github.com/pubgrub-rs/pubgrub/blob/717289be5722dd5caaa0d1f4ed13047d11a7f7fd/examples/caching_dependency_provider.rs#L34</a></p>\n<p>Forgive me if I'm misunderstanding, but I was under the assumption that this function would be called multiple times per package, so it would be desirable to have caching there too. Is that not the case?</p>\n<p>Thanks,<br>\nLouis</p>",
        "id": 255900290,
        "sender_full_name": "Louis Pilfold",
        "timestamp": 1633210742
    },
    {
        "content": "<p>If anything it is more important to have cashing on that function. (and there is some work to reduce the number of times it is called in 0.3) The example does not have that part implemented because it is hard to do generically.</p>",
        "id": 255900599,
        "sender_full_name": "Eh2406",
        "timestamp": 1633211043
    },
    {
        "content": "<p>In the general case the output may depend on the set of package names or the order of iteration. So in general you need collect the <code>packages</code> iter into a <code>Vec</code> and use that as the cache key, witch means you will have almost no hits.</p>",
        "id": 255901578,
        "sender_full_name": "Eh2406",
        "timestamp": 1633212095
    },
    {
        "content": "<p>If your impl looks like <code>packages.arg_max(priorty_for_a_package)</code> then it is likely to be efficient to put a cache around the call to <code>priorty_for_a_package</code>.</p>",
        "id": 255901774,
        "sender_full_name": "Eh2406",
        "timestamp": 1633212298
    },
    {
        "content": "<p>Ah fab! That's very helpful, I was worried I was misunderstanding it all. Thank you</p>",
        "id": 255902365,
        "sender_full_name": "Louis Pilfold",
        "timestamp": 1633212950
    },
    {
        "content": "<p>here are some valid (but nonsensical) <code>choose_package_version</code> that will make a caching example hard:</p>\n<p>(I am not going to get all the details correct)</p>\n<div class=\"codehilite\"><pre><span></span><code>let v: Vec&lt;_&gt; = packages.collect();\nlet mut hasher = FxHasher::new();\nv.iter().forEatch(|(p, r)| hasher.hash((p.borrow(), v.borrow()));\nlet hash = hasher.finish();\nlet (p, r) = v[hash % v.len()];\n</code></pre></div>\n<p>or</p>",
        "id": 255903456,
        "sender_full_name": "Eh2406",
        "timestamp": 1633214097
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>let v: Vec&lt;_&gt; = packages.collect();\nlet has_a = v..iter().find(|(p, _)| p == package_named_a));\nlet has_b = v..iter().find(|(p, _)| p == package_named_b));\nlet has_c = v..iter().find(|(p, _)| p == package_named_c));\n\nif has_a.is_sum() &amp;&amp;  has_b.is_sum() {\n   return has_b;\n} else if has_b.is_sum() &amp;&amp;  has_c.is_sum() {\n   return has_c;\n} else if has_a.is_sum() &amp;&amp;  has_c.is_sum() {\n   return has_a;\n} else {\n   return v.last();\n}\n</code></pre></div>",
        "id": 255903744,
        "sender_full_name": "Eh2406",
        "timestamp": 1633214404
    },
    {
        "content": "<p>I don't really understand the implications of your examples there to be honest. I was thinking I would just cache the HTTP requests so that I make only 1 request to the repository API per package, and share the cache between the two methods.</p>",
        "id": 255904214,
        "sender_full_name": "Louis Pilfold",
        "timestamp": 1633214928
    },
    {
        "content": "<p>That you should definitely do!</p>",
        "id": 255904556,
        "sender_full_name": "Eh2406",
        "timestamp": 1633215319
    },
    {
        "content": "<p>The examples were mostly for me, to document why this is hard to do in the general case. In your concrete case, caching a HTTP level definitely makes sense.</p>",
        "id": 255904675,
        "sender_full_name": "Eh2406",
        "timestamp": 1633215478
    },
    {
        "content": "<p>Fab, thanks again!</p>",
        "id": 255905216,
        "sender_full_name": "Louis Pilfold",
        "timestamp": 1633216031
    },
    {
        "content": "<p>Therned the examples into a comment on the PR I linked (<a href=\"https://github.com/pubgrub-rs/pubgrub/pull/104#issuecomment-932833104\">https://github.com/pubgrub-rs/pubgrub/pull/104#issuecomment-932833104</a>). So thank you!</p>",
        "id": 255906232,
        "sender_full_name": "Eh2406",
        "timestamp": 1633217239
    }
]