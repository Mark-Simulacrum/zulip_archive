[
    {
        "content": "<p>By the way, I just had a look at the issue for tracking public/private. What is the core idea/problem with \"scoped goals\" and \"public dependencies\"? (I know nothing about the RFC)</p>",
        "id": 248323433,
        "sender_full_name": "Matthieu Pizenberg",
        "timestamp": 1628066081
    },
    {
        "content": "<p>I just read the public/private RFC. So if I understand well, there are two goals:</p>\n<ol>\n<li>catch shared usage of a type at different versions at dependency resolution instead of at compilation</li>\n<li>possibly enable more situations for private dependencies (they can basically be any version they want)</li>\n</ol>\n<p>(1) would require a constraint preventing from having two different versions of a crate connected via a chain of public edges (dependencies) in the dependency graph. One remark IÂ have about this RFC is that it will also result in false positives. It could prevent a crate from compiling because in theory two versions of a public dependency are available, but in practice they are not used together.</p>\n<p>(2) I suppose this could even enable situations where we have \"a\" at version 1.1 and 1.2 in the solution if they are both private dependencies? or is that stretching the concept of private too far? because how does that play with a public \"p\" within the private \"a\". I'm not sure I've read in the RFC what is the situations for public deps of private deps.</p>",
        "id": 248329948,
        "sender_full_name": "Matthieu Pizenberg",
        "timestamp": 1628070806
    },
    {
        "content": "<p>That all sounds right. Your point about false positives is entirely correct. That is one of the reasons the RFC cannot be implemented as described. It will need some syntax in Cargo.toml for \"I don't care about this conflict\".</p>",
        "id": 248354974,
        "sender_full_name": "Eh2406",
        "timestamp": 1628086313
    },
    {
        "content": "<blockquote>\n<p>have \"a\" at version 1.1 and 1.2 in the solution</p>\n</blockquote>\n<p>That is going further then the RFC does. (Some think it is a better design, but it would be to big a braking change.)<br>\nThe RFC only adds new conflicts/incompatibilities, it does not relax any existing conflicts/incompatibilities.<br>\nIf the pre-RFC resolver thinks there are no solutions, then there are no solutions with the post-RFC resolver.</p>",
        "id": 248355702,
        "sender_full_name": "Eh2406",
        "timestamp": 1628086610
    },
    {
        "content": "<p>hum I thought that private/public would be relatively easy to implement but now that I'm thinking more about it, it does not seem easy at all ^^.</p>",
        "id": 248818981,
        "sender_full_name": "Matthieu Pizenberg",
        "timestamp": 1628498611
    },
    {
        "content": "<p>If public was always public, it would be easy I think, but public is only public within its subgraph of publicly connected nodes.</p>",
        "id": 248819136,
        "sender_full_name": "Matthieu Pizenberg",
        "timestamp": 1628498706
    },
    {
        "content": "<p>hum, but one advantage is that it's a directed graph, which goes in only one direction, and any private link cuts its current publicly connected subgraph. So each public subgraph can be uniquely identified by its private root, which can be identified by its package name and version. So maybe we can have a \"private_root\" field on the package type handled by the dependency provider.</p>",
        "id": 248819817,
        "sender_full_name": "Matthieu Pizenberg",
        "timestamp": 1628499154
    },
    {
        "content": "<p>I'll have a try writing a section in the guide about what I have in mind, see how that goes while I try to explain it clearly</p>",
        "id": 248820658,
        "sender_full_name": "Matthieu Pizenberg",
        "timestamp": 1628499682
    },
    {
        "content": "<p>New guide section started: <a href=\"https://github.com/pubgrub-rs/guide/pull/4\">https://github.com/pubgrub-rs/guide/pull/4</a></p>",
        "id": 248828257,
        "sender_full_name": "Matthieu Pizenberg",
        "timestamp": 1628505308
    },
    {
        "content": "<p>It ends up being horrendously complicated. Remember that V1 of A may export B as public, but the V1.1 may have it private. For my own sanity, I will focus on getting parity with cargo features before doing any kind of unimplemented or future RFC's. But I certainly don't mind you spending time thinking about it. :-)</p>",
        "id": 248850732,
        "sender_full_name": "Eh2406",
        "timestamp": 1628517932
    },
    {
        "content": "<p>Alright, re-reading what I wrote in the guide, I realize I have an \"off-by-one\" error in my chaining of dependencies, but I have a clear path to solving it. I'm pretty confident it's gonna work, and not be more complex than the \"multiple versions\" scheme with buckets.</p>",
        "id": 248859883,
        "sender_full_name": "Matthieu Pizenberg",
        "timestamp": 1628521593
    },
    {
        "content": "<p>Actually, it was not off by one, it was ok, but not sufficient. Then I realized I need more than one marker. I basically need to add a seed marker to the public path everytime there exist another private path.</p>",
        "id": 248925381,
        "sender_full_name": "Matthieu Pizenberg",
        "timestamp": 1628554286
    },
    {
        "content": "<p>Sorry for the confusing note ^^. It's mainly for my future self. With a picture to help me remember correctly</p>",
        "id": 248925468,
        "sender_full_name": "Matthieu Pizenberg",
        "timestamp": 1628554346
    },
    {
        "content": "<p><a href=\"/user_uploads/4715/7aTv6iaO9X_KB2YVpUBT8xFw/IMG_20210810_020722.jpg\">IMG_20210810_020722.jpg</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/4715/7aTv6iaO9X_KB2YVpUBT8xFw/IMG_20210810_020722.jpg\" title=\"IMG_20210810_020722.jpg\"><img src=\"/user_uploads/4715/7aTv6iaO9X_KB2YVpUBT8xFw/IMG_20210810_020722.jpg\"></a></div>",
        "id": 248925476,
        "sender_full_name": "Matthieu Pizenberg",
        "timestamp": 1628554360
    },
    {
        "content": "<p>I have made many such pictures in my day.</p>",
        "id": 248925525,
        "sender_full_name": "Eh2406",
        "timestamp": 1628554406
    },
    {
        "content": "<p>The end-to-end prop tests where written because p/p is stuff is hard.</p>",
        "id": 248925600,
        "sender_full_name": "Eh2406",
        "timestamp": 1628554451
    },
    {
        "content": "<p>Ahah I can believe it ;)</p>",
        "id": 248925674,
        "sender_full_name": "Matthieu Pizenberg",
        "timestamp": 1628554537
    },
    {
        "content": "<p>Alright, I think I've nailed it, at least in theory since I haven't completed the implementation. You can read my thoughts here: <a href=\"https://github.com/pubgrub-rs/guide/blob/b7726517446c39f29d16be3d69ee819925cedc7a/src/limitations/public_private.md\">https://github.com/pubgrub-rs/guide/blob/b7726517446c39f29d16be3d69ee819925cedc7a/src/limitations/public_private.md</a></p>",
        "id": 248987484,
        "sender_full_name": "Matthieu Pizenberg",
        "timestamp": 1628606030
    },
    {
        "content": "<p>The two missing images are the following</p>",
        "id": 248987509,
        "sender_full_name": "Matthieu Pizenberg",
        "timestamp": 1628606042
    },
    {
        "content": "<p><a href=\"/user_uploads/4715/ALC5ZmFhVlLPGcv0OPVmVKJ-/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/4715/ALC5ZmFhVlLPGcv0OPVmVKJ-/image.png\" title=\"image.png\"><img src=\"/user_uploads/4715/ALC5ZmFhVlLPGcv0OPVmVKJ-/image.png\"></a></div>",
        "id": 248987565,
        "sender_full_name": "Matthieu Pizenberg",
        "timestamp": 1628606057
    },
    {
        "content": "<p><a href=\"/user_uploads/4715/9OezLEMZf5pjPeQUi1LV09if/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/4715/9OezLEMZf5pjPeQUi1LV09if/image.png\" title=\"image.png\"><img src=\"/user_uploads/4715/9OezLEMZf5pjPeQUi1LV09if/image.png\"></a></div>",
        "id": 248987610,
        "sender_full_name": "Matthieu Pizenberg",
        "timestamp": 1628606087
    },
    {
        "content": "<p>And I think the code in PR <a href=\"https://github.com/pubgrub-rs/advanced_dependency_providers/pull/9\">https://github.com/pubgrub-rs/advanced_dependency_providers/pull/9</a> is now correct. I'll have to add other edge cases tests to be sure, and to add documentation. And finally to finish the joint explanation in the guide.</p>",
        "id": 249016336,
        "sender_full_name": "Matthieu Pizenberg",
        "timestamp": 1628619661
    },
    {
        "content": "<p>I will read it over! I will not be convinced that we have nailed it, until we have time prop-tests checking it. I thought I had this working several times, but a new attempt is very exciting.</p>",
        "id": 249034941,
        "sender_full_name": "Eh2406",
        "timestamp": 1628628190
    },
    {
        "content": "<p>I have a question regarding the solver/compiler interface. If there are two places with a dependency to \"a\" and the solver's solutions contains two different versions of \"a\", say V1 and V2. How does the compiler knows which one to use where ?</p>",
        "id": 249131024,
        "sender_full_name": "Matthieu Pizenberg",
        "timestamp": 1628698652
    },
    {
        "content": "<p>For the details you will have to ask Alex or Eric. But the general idea is that package versions is a cargo concept. So <code>A v1</code> gets built into a directory (or file) like like <code>A-{a arbitrary hash value}</code> and <code>A v2</code> in <code>A-{a different hash value}</code>. Then Cargo can tell Rustc \"the files related to what you know as <code>A</code> can be found at <code>A-{the correct hash}</code>\". Rust also uses the hash to mangle the the symbols so that the linker also treats them as totally different things.</p>",
        "id": 249133236,
        "sender_full_name": "Eh2406",
        "timestamp": 1628699617
    },
    {
        "content": "<p>Ok, I was thinking of that because I'm realizing that we don't put any traceability in the solution. So if \"a\" depends on \"b\" 1.0..3.0 and \"b\" is in the solution at both versions 1 and 2, how does the compiler would know which version/directory to use?</p>",
        "id": 249136734,
        "sender_full_name": "Matthieu Pizenberg",
        "timestamp": 1628701256
    },
    {
        "content": "<p>Whatever code lowered the problem to PubGrubs input will need to convert the output. So if it uses Proxies&amp;Buckets and there are more then one compatible Buckets that match and are selected then it will need to look at the Proxies that represent that connection. It will need to walk the implied and unambiguous graph from PubGrubs output and shrink <code>package</code>-&gt;<code>Proxies</code>-&gt;<code>Buckets</code>-&gt;<code>version</code> into a <code>package</code> -&gt; <code>version</code> graph. This may be tricky to get right, but it should be <code>O(n)</code>.</p>",
        "id": 249153968,
        "sender_full_name": "Eh2406",
        "timestamp": 1628708557
    },
    {
        "content": "<blockquote>\n<p>Whatever code lowered the problem to PubGrubs input will need to convert the output</p>\n</blockquote>\n<p>Seems reasonable!</p>",
        "id": 249155956,
        "sender_full_name": "Matthieu Pizenberg",
        "timestamp": 1628709476
    },
    {
        "content": "<p>It would probably be good/completionist of us to add the code for that into the examples in advanced_dependency_providers. But that feels like extra credit.</p>",
        "id": 249157106,
        "sender_full_name": "Eh2406",
        "timestamp": 1628710047
    },
    {
        "content": "<p>\"... will be left as an exercise to the reader\" XD</p>",
        "id": 249157276,
        "sender_full_name": "Matthieu Pizenberg",
        "timestamp": 1628710120
    }
]