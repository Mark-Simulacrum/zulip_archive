[
    {
        "content": "<p>I saw <a href=\"https://github.com/rust-lang/rust/issues/86873\">#86873</a> for opaque pointer support -- is there any other work in progress?</p>",
        "id": 247967117,
        "sender_full_name": "cuviper",
        "timestamp": 1627936067
    },
    {
        "content": "<p>I was thinking of tackling <code>call</code>/<code>invoke</code> myself</p>",
        "id": 247967145,
        "sender_full_name": "cuviper",
        "timestamp": 1627936078
    },
    {
        "content": "<p>There's <a href=\"https://github.com/rust-lang/rust/pull/87695\">https://github.com/rust-lang/rust/pull/87695</a> for GEPs.</p>",
        "id": 247971475,
        "sender_full_name": "Nikita Popov",
        "timestamp": 1627938319
    },
    {
        "content": "<p>great! after GEP and calls, is anything left?</p>",
        "id": 247973947,
        "sender_full_name": "cuviper",
        "timestamp": 1627939779
    },
    {
        "content": "<p>There's also a couple of explicit <code>element_type()</code> calls, but basically that should be it.</p>",
        "id": 247975005,
        "sender_full_name": "Nikita Popov",
        "timestamp": 1627940424
    },
    {
        "content": "<p>here's <code>call</code>/<code>invoke</code>: <a href=\"https://github.com/rust-lang/rust/pull/87743\">https://github.com/rust-lang/rust/pull/87743</a></p>",
        "id": 248288484,
        "sender_full_name": "cuviper",
        "timestamp": 1628029422
    },
    {
        "content": "<p>I just added a check to my PR so <code>element_type</code> only allows arrays and vectors</p>",
        "id": 248517200,
        "sender_full_name": "cuviper",
        "timestamp": 1628188417
    },
    {
        "content": "<p>once that lands, we might be ready to try <code>ptr</code> with LLVM 13?</p>",
        "id": 248518435,
        "sender_full_name": "cuviper",
        "timestamp": 1628189023
    },
    {
        "content": "<p>We might be ready, but LLVM isn't :)</p>",
        "id": 248521336,
        "sender_full_name": "Nikita Popov",
        "timestamp": 1628190135
    },
    {
        "content": "<p>heh</p>",
        "id": 248521633,
        "sender_full_name": "cuviper",
        "timestamp": 1628190311
    },
    {
        "content": "<p>well, we can better kick the tires to help get LLVM ready then</p>",
        "id": 248521680,
        "sender_full_name": "cuviper",
        "timestamp": 1628190336
    },
    {
        "content": "<p>I'll need to check what the check does but aren't vectors of pointers a thing?</p>",
        "id": 248522771,
        "sender_full_name": "nagisa",
        "timestamp": 1628190920
    },
    {
        "content": "<p>They are, but shouldn't be relevant here? That would be the element type being a pointer, not getting an element type on a pointer.</p>",
        "id": 248522889,
        "sender_full_name": "Nikita Popov",
        "timestamp": 1628190975
    },
    {
        "content": "<p>I see.</p>",
        "id": 248522936,
        "sender_full_name": "nagisa",
        "timestamp": 1628190996
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"138448\">cuviper</span> <a href=\"#narrow/stream/187780-t-compiler.2Fwg-llvm/topic/opaque.20pointers/near/248521680\">said</a>:</p>\n<blockquote>\n<p>well, we can better kick the tires to help get LLVM ready then</p>\n</blockquote>\n<p>At least we'll have a frontend to test with :)</p>",
        "id": 248524311,
        "sender_full_name": "Nikita Popov",
        "timestamp": 1628191660
    },
    {
        "content": "<p>is there anything yet for the <code>byval</code> attribute? I remember that sticking out like a sore thumb back in 2015 or whenever I last looked at opaque pointers</p>",
        "id": 248992496,
        "sender_full_name": "eddyb",
        "timestamp": 1628608373
    },
    {
        "content": "<p><a href=\"https://llvm.org/docs/LangRef.html#parameter-attributes\">https://llvm.org/docs/LangRef.html#parameter-attributes</a></p>\n<blockquote>\n<p>byval(&lt;ty&gt;)</p>\n</blockquote>\n<p>Seems to be the case.</p>",
        "id": 249017407,
        "sender_full_name": "bjorn3",
        "timestamp": 1628620094
    },
    {
        "content": "<p>That was already the case before LLVM 12 though I think.</p>",
        "id": 249017761,
        "sender_full_name": "bjorn3",
        "timestamp": 1628620274
    },
    {
        "content": "<p>LLVM 9 it seems: <a href=\"https://github.com/rust-lang/rust/issues/62474\">#62474</a></p>",
        "id": 249017898,
        "sender_full_name": "bjorn3",
        "timestamp": 1628620344
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/commit/eb338220911fbcf0661e4f8802b23d0bd4e5d077\">eb338220911fbcf0661e4f8802b23d0bd4e5d077</a></p>",
        "id": 249017951,
        "sender_full_name": "bjorn3",
        "timestamp": 1628620378
    },
    {
        "content": "<p>ah wow nice</p>",
        "id": 249018176,
        "sender_full_name": "eddyb",
        "timestamp": 1628620511
    },
    {
        "content": "<p>disappointing that it's not a size, which means LLVM gets to keep its weird type-dependence for it, but it should be enough for opaque pointers</p>",
        "id": 249018574,
        "sender_full_name": "eddyb",
        "timestamp": 1628620715
    },
    {
        "content": "<p>that's how opaque pointers work in general though â€“ type moved to the instruction that's it.</p>",
        "id": 249037449,
        "sender_full_name": "nagisa",
        "timestamp": 1628629376
    },
    {
        "content": "<p>some of the discussion back then was about the size - after all, size and alignment are all <code>byval</code> should care about. it's not like instructions that need to reason about <em>values</em> of the type, there's no <code>T</code> value <code>byval(T)</code> copies, only <code>sizeof(T)</code> bytes. and I guess <code>alloca</code> should be similar</p>",
        "id": 249078076,
        "sender_full_name": "eddyb",
        "timestamp": 1628668387
    },
    {
        "content": "<p>eventually I hope to use <code>[i8 x N]</code> types in every \"unnecessarily typed\" part of the IR like this</p>",
        "id": 249078107,
        "sender_full_name": "eddyb",
        "timestamp": 1628668423
    },
    {
        "content": "<p>(the way we lower miri constant data has been a great success IMO)</p>",
        "id": 249078180,
        "sender_full_name": "eddyb",
        "timestamp": 1628668451
    },
    {
        "content": "<p>Yeah, there is still a lot of unnecessary type information. It's just very hard to remove any of it while pointer types are still there. For migration purposes it's easiest to keep everything else typed.</p>",
        "id": 249078632,
        "sender_full_name": "Nikita Popov",
        "timestamp": 1628668808
    },
    {
        "content": "<p>I do hope we'll be able to remove GEP types once we have opaque pointers. Most other type usages are fairly harmless.</p>",
        "id": 249078699,
        "sender_full_name": "Nikita Popov",
        "timestamp": 1628668838
    },
    {
        "content": "<p>redesigning GEP to be an \"multi-indexing offset expression\", or splitting it into multiple instructions, is probably the hardest thing one could do</p>",
        "id": 249078786,
        "sender_full_name": "eddyb",
        "timestamp": 1628668911
    },
    {
        "content": "<p>I never figured out how <code>inbounds</code> semantics work with one <code>GEPi</code> with N indices vs N <code>GEPi</code>s</p>",
        "id": 249078875,
        "sender_full_name": "eddyb",
        "timestamp": 1628668961
    },
    {
        "content": "<p>(the \"simplest\" thing would be forcing the backend to emit multiplications but I kinda doubt LLVM passes are going to like working with that)</p>",
        "id": 249078931,
        "sender_full_name": "eddyb",
        "timestamp": 1628669012
    },
    {
        "content": "<p>anyway let's get opaque pointers first, then we can experiment with firewalling LLVM and feeding it <code>[iN x M]</code> (approximating alignment where possible) in as many places as we can</p>",
        "id": 249079061,
        "sender_full_name": "eddyb",
        "timestamp": 1628669084
    },
    {
        "content": "<p><code>rustc_codegen_spirv</code> suffered a bit from \"mapping Rust types to backend ones 1:1 <em>seems</em> plausible\", and ripping up that kind of thing as much as possible should help with improving its design</p>",
        "id": 249079252,
        "sender_full_name": "eddyb",
        "timestamp": 1628669232
    },
    {
        "content": "<p>TIL there's an option to make all pointers opaque</p>",
        "id": 250053888,
        "sender_full_name": "cuviper",
        "timestamp": 1629409840
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>$ RUSTFLAGS_NOT_BOOTSTRAP=-Cllvm-args=-force-opaque-pointers ./x.py build\n</code></pre></div>",
        "id": 250053899,
        "sender_full_name": "cuviper",
        "timestamp": 1629409847
    },
    {
        "content": "<p>it will crash quickly though <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 250053925,
        "sender_full_name": "cuviper",
        "timestamp": 1629409866
    },
    {
        "content": "<p>I added a few easy bypasses, like <code>if (ptr-&gt;isOpaque()) return;</code>, but SROA <code>getAdjustedPtr</code> looks like it will really need a type</p>",
        "id": 250054152,
        "sender_full_name": "cuviper",
        "timestamp": 1629410007
    },
    {
        "content": "<p>(I'm testing on main <code>36d51386195e3d606e0d40495f1135ab180bd6ae^</code>, because that commit changes API that I don't want to deal with right now)</p>",
        "id": 250054350,
        "sender_full_name": "cuviper",
        "timestamp": 1629410142
    },
    {
        "content": "<p>SROA can likely switch to i8 geps. It currently just tries really, really hard to construct geps without having to insert bitcasts.</p>",
        "id": 250087905,
        "sender_full_name": "Nikita Popov",
        "timestamp": 1629445662
    },
    {
        "content": "<p>Great to hear this is coming along well, <span class=\"user-mention silent\" data-user-id=\"133224\">Nikita Popov</span>!  Thanks for all the work on it <span aria-label=\"heart\" class=\"emoji emoji-2764\" role=\"img\" title=\"heart\">:heart:</span> </p>\n<p>For those not reading LLVM weekly: &lt;<a href=\"https://discourse.llvm.org/t/opaque-pointers-status-update/60296\">https://discourse.llvm.org/t/opaque-pointers-status-update/60296</a>&gt;</p>",
        "id": 272723454,
        "sender_full_name": "scottmcm",
        "timestamp": 1645469326
    },
    {
        "content": "<p>There's a first perf run for rust here: <a href=\"https://github.com/rust-lang/rust/pull/94214#issuecomment-1046925689\">https://github.com/rust-lang/rust/pull/94214#issuecomment-1046925689</a></p>",
        "id": 272734720,
        "sender_full_name": "Nikita Popov",
        "timestamp": 1645477308
    },
    {
        "content": "<p>Take it with a big grain of salt, because there are some regressions on check builds, so we probably end up missing some optimizations.</p>",
        "id": 272734805,
        "sender_full_name": "Nikita Popov",
        "timestamp": 1645477353
    }
]