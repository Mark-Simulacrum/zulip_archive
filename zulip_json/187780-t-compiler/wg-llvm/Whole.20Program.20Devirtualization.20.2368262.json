[
    {
        "content": "<p>I'm currently working on <a href=\"https://github.com/rust-lang/rust/issues/68262\">#68262</a> and I'm stuck with an annoying problem:</p>\n<p>So in order for LLVM to find unused \"virtual\" functions, you have to add the <a href=\"https://llvm.org/docs/TypeMetadata.html#vcall-visibility-metadata\"><code>!vcall_visibility</code></a> type metadata to vtables and then use the <a href=\"https://llvm.org/docs/LangRef.html#llvm-type-checked-load-intrinsic\"><code>llvm.type.checked.load</code></a> intrinsic to load the functions from the vtable. This I  <a href=\"https://github.com/rust-lang/rust/compare/master...flip1995:pk-vfe\">managed to do</a>.</p>\n<p>Now the problem is, that the <code>llvm.type.checked.load</code> intrinsic cannot be lowered to machine code by LLVM. So before lowering to MC, LLVM has to run the <a href=\"https://llvm.org/doxygen/structllvm_1_1WholeProgramDevirtPass.html\">WholeProgramDevirtPass</a> to get rid of those intrinsic calls and replace them with normal <code>load</code>s.</p>\n<p>This pass is only enabled during post-link LTO though. So effectively you have to keep LLVM bitcode until linking and then pass that to the linker. I found, that this can be done with the <a href=\"https://doc.rust-lang.org/rustc/linker-plugin-lto.html\"><code>Clinker-plugin-lto</code></a> flag. </p>\n<p>But I found that this only works if I compile a single crate without dependencies. When using <code>cargo</code> with <code>RUSTFLAGS=\"-Clinker-plugin-lto\"</code> it will try to lower the dependencies to MC (to produce the rlib) anyway and will therefore fail, since the intrinsic calls are still there.</p>\n<p>So my question is: Is there a way to keep LLVM bitcode for all deps and the current crate until the final step where everything is linked together?</p>",
        "id": 261625466,
        "sender_full_name": "flip1995",
        "timestamp": 1637060906
    }
]