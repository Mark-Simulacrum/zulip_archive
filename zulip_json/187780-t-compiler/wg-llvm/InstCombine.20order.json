[
    {
        "content": "<p>I was looking at <a href=\"https://github.com/rust-lang/rust/pull/88834\">https://github.com/rust-lang/rust/pull/88834</a> where <code>(X &amp; 0b1100_0000) == 0b1000_0000</code> is manually optimized to <code>X as i8 &lt; 0b1100_0000</code> and I was wondering if this optimization couldn't be done in LLVM. I made a proof-of-concept patch (<a href=\"https://github.com/falk-hueffner/llvm-project/commit/6588246b3fbd5a6bba35bb30b56bf102dc3f0bb7\">https://github.com/falk-hueffner/llvm-project/commit/6588246b3fbd5a6bba35bb30b56bf102dc3f0bb7</a>) but now I get a test failure in <code>merge-icmp.ll/test2</code>. It seems that this new transformation impedes folding <code>(X &amp; C1) == C2 &amp;&amp; (X &amp; C3) == C4</code>. Is there some way to work around this, like enforcing a different order of transformations?</p>",
        "id": 253723617,
        "sender_full_name": "Falk Hüffner",
        "timestamp": 1631875951
    },
    {
        "content": "<p>No, it's not possible to control folding order. The only hard guarantee is that InstSimplify runs before InstCombine for a given instruction, but that doesn't help you here. You'd have to adjust other folds to handle the new canonical pattern.</p>",
        "id": 253726174,
        "sender_full_name": "Nikita Popov",
        "timestamp": 1631877431
    },
    {
        "content": "<p>I see, thanks. Looks like I might be able to do that by adapting <code>decomposeBitTestICmp</code></p>",
        "id": 253728055,
        "sender_full_name": "Falk Hüffner",
        "timestamp": 1631878476
    }
]