[
    {
        "content": "<p>I've talked to Huawei's LLVM team and they are interested in helping out the Rust project. However they don't have a clear idea of what kind of help they could provide. They would like us to identify 5-10 issues as starting points for areas where they can contribute.</p>",
        "id": 255995695,
        "sender_full_name": "Amanieu",
        "timestamp": 1633312207
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span></p>",
        "id": 255998975,
        "sender_full_name": "Amanieu",
        "timestamp": 1633315469
    },
    {
        "content": "<p>From my own backburner, a couple that come to mind and aren't Rust specific: better lowering for signed integer multiplication with overflow; bringing the LKK strength reduction for division/modulo over the finish line; fixing (where its implemented) or implementing inline-asm stack probes; <code>loop { match { ... } }</code> not becoming a straightforward state machine (<a href=\"https://github.com/rust-lang/rust/issues/80630\">https://github.com/rust-lang/rust/issues/80630</a>) etc.</p>\n<p>Lowerings and strength reductions also need to be extended to work within vectors and for non-native integer sizes. e.g. right now dividing <code>x / 10u128</code> will not replace the division with multiplications and shifts, even though LLVM is perfectly capable of this for <code>u32</code> for instance.</p>\n<p><a href=\"https://github.com/rust-lang/rust/issues/72356\">https://github.com/rust-lang/rust/issues/72356</a> sounds fun.</p>",
        "id": 256035753,
        "sender_full_name": "nagisa",
        "timestamp": 1633342940
    },
    {
        "content": "<p>could the various issues with the <code>NonZero</code> types be worthwhile to look at, you think ? there are a bunch of them, <a href=\"https://github.com/rust-lang/rust/issues/49572\">#49572</a> <a href=\"https://github.com/rust-lang/rust/issues/51346\">#51346</a> or <a href=\"https://github.com/rust-lang/rust/issues/49892\">#49892</a>. (they seemed not exactly trivial to solve, but at the same time, maybe the gain wouldn't be worth the work)</p>",
        "id": 256127232,
        "sender_full_name": "lqd",
        "timestamp": 1633379223
    },
    {
        "content": "<p>Maybe some form of <a href=\"https://github.com/rust-lang/rust/issues/85133\">#85133</a>? That affects codegen for the<code>?</code> operator, which is currently subpar. There's some analysis re: LLVM in  <a href=\"https://github.com/rust-lang/rust/issues/85133#issuecomment-904185574\">https://github.com/rust-lang/rust/issues/85133#issuecomment-904185574</a>, though I don't know how accurate it is.</p>",
        "id": 256157990,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1633395028
    },
    {
        "content": "<p>mostly joking: they could bang up GlobalISel on x86_64 so we can use it instead of trying and failing to use FastISel</p>",
        "id": 256173065,
        "sender_full_name": "Jubilee",
        "timestamp": 1633406087
    },
    {
        "content": "<p>I'd love to see support for automatically handling the interaction between reserved registers and inline assembly, so that it's possible to safely use registers that <em>might</em> be reserved in certain configurations but aren't in the current configuration.</p>",
        "id": 256174776,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1633407358
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/issues/85056\">https://github.com/rust-lang/rust/issues/85056</a></p>",
        "id": 256174833,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1633407382
    },
    {
        "content": "<p>cc: <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> , who always seems to have a laundry list of LLVM issues caused by mishandling or incomplete treatment of pointer provenance. I think there are at least 2 or 3 open tracked bugs here, last I checked, although I'm not sure how actionable they all are.</p>",
        "id": 256340520,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1633480429
    },
    {
        "content": "<p>in general, they could join the LLVM notification group:<br>\n<a href=\"https://rustc-dev-guide.rust-lang.org/notification-groups/about.html#join\">https://rustc-dev-guide.rust-lang.org/notification-groups/about.html#join</a></p>",
        "id": 256439105,
        "sender_full_name": "cuviper",
        "timestamp": 1633536974
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/187780-t-compiler.2Fwg-llvm/topic/Huawei's.20LLVM.20team/near/256340520\">said</a>:</p>\n<blockquote>\n<p>cc: <span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> , who always seems to have a laundry list of LLVM issues caused by mishandling or incomplete treatment of pointer provenance. I think there are at least 2 or 3 open tracked bugs here, last I checked, although I'm not sure how actionable they all are.</p>\n</blockquote>\n<p>yeah, that would be for example <a href=\"https://bugs.llvm.org/show_bug.cgi?id=34548\">https://bugs.llvm.org/show_bug.cgi?id=34548</a>, <a href=\"https://bugs.llvm.org/show_bug.cgi?id=35229\">https://bugs.llvm.org/show_bug.cgi?id=35229</a>. However, these are pretty deep conceptual issues; ultimately this is about pinning down the details of the LLVM memory model (not the concurrency parts, but the sequential parts, and provenance specifically).</p>",
        "id": 256674655,
        "sender_full_name": "RalfJ",
        "timestamp": 1633655807
    },
    {
        "content": "<p>also if they have any capacity to help with the long-running slow-moving effort of killing undef and spreading poison, that would help a lot to establish solid foundations for LLVM language semantics</p>",
        "id": 256674692,
        "sender_full_name": "RalfJ",
        "timestamp": 1633655851
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116113\">lqd</span> <a href=\"#narrow/stream/187780-t-compiler.2Fwg-llvm/topic/Huawei's.20LLVM.20team/near/256127232\">said</a>:</p>\n<blockquote>\n<p>could the various issues with the <code>NonZero</code> types be worthwhile to look at, you think ? there are a bunch of them, <a href=\"https://github.com/rust-lang/rust/issues/49572\">#49572</a> <a href=\"https://github.com/rust-lang/rust/issues/51346\">#51346</a> or <a href=\"https://github.com/rust-lang/rust/issues/49892\">#49892</a>. (they seemed not exactly trivial to solve, but at the same time, maybe the gain wouldn't be worth the work)</p>\n</blockquote>\n<p>These being non-trivial seems like it'd make them a good candidate for an experienced team to look at.  My recollection is that the problem was that there isn't a place in the instructions to preserve the information, and that sounds like the kind of bigger change that would be nearly impossible for someone new to LLVM to do holistically.</p>",
        "id": 257420506,
        "sender_full_name": "scottmcm",
        "timestamp": 1634152141
    },
    {
        "content": "<p>(Basically what Dylan mentioned, but phrased more generally)</p>\n<p>It'd be great to get some extra smarts around discriminant preservation paths.  <a href=\"https://github.com/rust-lang/rust/issues/88616#issuecomment-913877197\">https://github.com/rust-lang/rust/issues/88616#issuecomment-913877197</a> has a nice simple example.  Something like this</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">baz</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"kt\">u32</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"kt\">u32</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">y</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Does an unnecessary icmp+xor+zext / test+setne (&lt;<a href=\"https://rust.godbolt.org/z/5EhEEfPxq\">https://rust.godbolt.org/z/5EhEEfPxq</a>&gt;) to copy over the discriminant when it could just be kept directly.</p>\n<p>I think an improvement here could potentially help basically everything that returns Option/Result, so could be a pervasive win (albeit small in each place).</p>",
        "id": 258244899,
        "sender_full_name": "scottmcm",
        "timestamp": 1634666806
    },
    {
        "content": "<p>Another item, which came up regarding the Rust in the Linux kernel effort:<br>\n<a href=\"https://rust.godbolt.org/z/7rqfbj58b\">https://rust.godbolt.org/z/7rqfbj58b</a><br>\nThe compiler should be able to fold that all down to a constant <code>10</code>, but it can't figure out that the unwrap can never panic.</p>",
        "id": 262083541,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1637336760
    },
    {
        "content": "<p><code>unwrap_unchecked</code> makes it efficient, but that shouldn't be necessary.</p>",
        "id": 262084073,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1637336960
    },
    {
        "content": "<p><code>-C panic=abort</code> also makes it efficient.</p>",
        "id": 262084167,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1637336997
    },
    {
        "content": "<p>But it'd be nice if some combination of rustc and LLVM could manage to constant-fold this even when <code>panic=unwind</code>.</p>",
        "id": 262084868,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1637337248
    },
    {
        "content": "<p>random drive-by-comment but this looks like perhaps a codegen issue with rustc:</p>",
        "id": 262086636,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1637337920
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"LLVM\"><pre><span></span><code>  <span class=\"nv\">%_3</span> <span class=\"p\">=</span> <span class=\"k\">alloca</span> <span class=\"kt\">i64</span><span class=\"p\">,</span> <span class=\"k\">align</span> <span class=\"m\">8</span>\n<span class=\"c\">;; ...</span>\n  <span class=\"nv nv-Anonymous\">%1</span> <span class=\"p\">=</span> <span class=\"k\">bitcast</span> <span class=\"kt\">i64</span><span class=\"p\">*</span> <span class=\"nv\">%_3</span> <span class=\"k\">to</span> <span class=\"kt\">i32</span><span class=\"p\">*</span>\n  <span class=\"k\">store</span> <span class=\"kt\">i32</span> <span class=\"m\">1</span><span class=\"p\">,</span> <span class=\"kt\">i32</span><span class=\"p\">*</span> <span class=\"nv nv-Anonymous\">%1</span><span class=\"p\">,</span> <span class=\"k\">align</span> <span class=\"m\">8</span>\n<span class=\"c\">;; ...</span>\n  <span class=\"nv nv-Anonymous\">%3</span> <span class=\"p\">=</span> <span class=\"k\">load</span> <span class=\"kt\">i64</span><span class=\"p\">,</span> <span class=\"kt\">i64</span><span class=\"p\">*</span> <span class=\"nv\">%_3</span><span class=\"p\">,</span> <span class=\"k\">align</span> <span class=\"m\">8</span>\n  <span class=\"nv\">%tmp.sroa.0.0.extract.trunc.i.i.i</span> <span class=\"p\">=</span> <span class=\"k\">trunc</span> <span class=\"kt\">i64</span> <span class=\"nv nv-Anonymous\">%3</span> <span class=\"k\">to</span> <span class=\"kt\">i32</span>\n  <span class=\"nv\">%switch.i</span> <span class=\"p\">=</span> <span class=\"k\">icmp</span> <span class=\"k\">eq</span> <span class=\"kt\">i32</span> <span class=\"nv\">%tmp.sroa.0.0.extract.trunc.i.i.i</span><span class=\"p\">,</span> <span class=\"m\">0</span>\n  <span class=\"k\">br</span> <span class=\"kt\">i1</span> <span class=\"nv\">%switch.i</span><span class=\"p\">,</span> <span class=\"kt\">label</span> <span class=\"nv\">%bb1.i</span><span class=\"p\">,</span> <span class=\"kt\">label</span> <span class=\"nv\">%bb2</span>\n</code></pre></div>\n<p>this is allocating an <code>i64</code> temporary, storing 32-bits to it, loading 64-bits, then truncating back to 32-bits. LLVM is most likely getting confused about the 32-bit store and the 64-bit load and realizing it can't propagate there</p>",
        "id": 262086918,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1637338016
    },
    {
        "content": "<p>Oh, interesting! If I change u32 to u64 everywhere in the above godbolt example, it all constant-folds away.</p>",
        "id": 262088845,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1637338729
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"458794\">@Wedson Almeida Filho</span> <span class=\"user-mention\" data-user-id=\"382653\">@ojeda</span></p>",
        "id": 262088898,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1637338764
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/187780-t-compiler.2Fwg-llvm/topic/Huawei's.20LLVM.20team/near/262083541\">said</a>:</p>\n<blockquote>\n<p>Another item, which came up regarding the Rust in the Linux kernel effort:<br>\n<a href=\"https://rust.godbolt.org/z/7rqfbj58b\">https://rust.godbolt.org/z/7rqfbj58b</a><br>\nThe compiler should be able to fold that all down to a constant <code>10</code>, but it can't figure out that the unwrap can never panic.</p>\n</blockquote>\n<p>That looks like it might be related to what morse also suggested &lt;<a href=\"#narrow/stream/187780-t-compiler.2Fwg-llvm/topic/Huawei's.20LLVM.20team/near/256157990\">https://rust-lang.zulipchat.com/#narrow/stream/187780-t-compiler.2Fwg-llvm/topic/Huawei's.20LLVM.20team/near/256157990</a>&gt; -- just at const-fold time instead of run-time.</p>\n<p>Part of the problem with it is that LLVM (as I understand it) currently insists on that <code>icmp</code> even when we annotate the load as already only ever being <code>0</code> or <code>1</code>.</p>\n<p>Related: I'm surprised that there's no <code>trunc exact</code> the way there's <code>[su]div exact</code> and <code>[lr]shr exact</code>, to help tell the optimizer that the it doesn't need to mask when emitting it.</p>",
        "id": 262102337,
        "sender_full_name": "scottmcm",
        "timestamp": 1637344131
    },
    {
        "content": "<p>I reported <a href=\"https://bugs.llvm.org/show_bug.cgi?id=52568\">https://bugs.llvm.org/show_bug.cgi?id=52568</a> for the store/load forwarding issue. Not sure on the best way to fix that.</p>",
        "id": 262173119,
        "sender_full_name": "Nikita Popov",
        "timestamp": 1637399793
    }
]