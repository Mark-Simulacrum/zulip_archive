[
    {
        "content": "<p>Howdy folks! I've got rustc building on my workstation against LLVM HEAD again, but my CI box is mysteriously failing with the $SUBJECT error. More output at <a href=\"https://buildkite.com/llvm-project/rust-llvm-integrate-prototype/builds/4643#6d90c69f-a642-4b5d-ada8-6438134c16e9\">https://buildkite.com/llvm-project/rust-llvm-integrate-prototype/builds/4643#6d90c69f-a642-4b5d-ada8-6438134c16e9</a>, but it's not really very enlightening. Does anyone here know how I'm failing at computer and triggering this only on the CI machine?</p>",
        "id": 253108521,
        "sender_full_name": "durin42",
        "timestamp": 1631546757
    },
    {
        "content": "<p>Hm, do you have -Ctarget-cpu=native or something similar?</p>",
        "id": 253108997,
        "sender_full_name": "simulacrum",
        "timestamp": 1631546889
    },
    {
        "content": "<p>This can likely be minified to something using the _mm_crc32_u8 intrinsic (in core::arch::x86_64)</p>",
        "id": 253109086,
        "sender_full_name": "simulacrum",
        "timestamp": 1631546920
    },
    {
        "content": "<p>(<a href=\"https://doc.rust-lang.org/nightly/src/core/up/up/stdarch/crates/core_arch/src/x86/sse42.rs.html#602\">https://doc.rust-lang.org/nightly/src/core/up/up/stdarch/crates/core_arch/src/x86/sse42.rs.html#602</a>)</p>",
        "id": 253109125,
        "sender_full_name": "simulacrum",
        "timestamp": 1631546934
    },
    {
        "content": "<p>Would that be in how I'm building LLVM? I don't see anything obviously-like -Ctarget in the cmake invocations...</p>",
        "id": 253109709,
        "sender_full_name": "durin42",
        "timestamp": 1631547129
    },
    {
        "content": "<p>no, rustc invocations</p>",
        "id": 253110168,
        "sender_full_name": "simulacrum",
        "timestamp": 1631547277
    },
    {
        "content": "<p>In particular the target_feature sse4.2 is maybe statically disabled/enabled then that might change whether this intrinsic gets used by the failing crate</p>",
        "id": 253110463,
        "sender_full_name": "simulacrum",
        "timestamp": 1631547368
    },
    {
        "content": "<p>though it looks like it's supposed to be runtime detected, not static, in theory</p>",
        "id": 253110534,
        "sender_full_name": "simulacrum",
        "timestamp": 1631547399
    },
    {
        "content": "<p>Stuff like CRC and rdrand are platform features that can't really be emulated so if you unconditionally call that without a #[target_feature=\"...\"] or the equivalent cli call then it will fail to select.</p>",
        "id": 253112171,
        "sender_full_name": "nagisa",
        "timestamp": 1631547942
    },
    {
        "content": "<p>It might be the case that llvm got more strict about verifying this specific intrinsic or worse at optimizing unused stuff out</p>",
        "id": 253112298,
        "sender_full_name": "nagisa",
        "timestamp": 1631547982
    },
    {
        "content": "<p>(or maybe does invalid inlining decisions or...)</p>",
        "id": 253112377,
        "sender_full_name": "nagisa",
        "timestamp": 1631548014
    },
    {
        "content": "<p>The relevant call is presumably <a href=\"https://github.com/BurntSushi/rust-snappy/blob/44b40d70a330ad0e283b25c934387f96b6d47490/src/crc32.rs#L71\">https://github.com/BurntSushi/rust-snappy/blob/44b40d70a330ad0e283b25c934387f96b6d47490/src/crc32.rs#L71</a></p>",
        "id": 253113129,
        "sender_full_name": "Nikita Popov",
        "timestamp": 1631548304
    },
    {
        "content": "<p>Could this be a failure that would only show up on machines without sse2 enabled?</p>",
        "id": 253117804,
        "sender_full_name": "durin42",
        "timestamp": 1631549906
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>error: could not compile `snap`\n</code></pre></div>\n<p>So I suspect it's from the <code>snap</code> crate?</p>\n<p>I guess at this point what I need is a way to reproduce this not on the CI machine so I can bisect...</p>",
        "id": 253118282,
        "sender_full_name": "durin42",
        "timestamp": 1631550082
    },
    {
        "content": "<p>Yeah, you can at least try to minimize this to a smaller test case (e.g., just building the snap crate -- the code was linked)</p>",
        "id": 253119946,
        "sender_full_name": "simulacrum",
        "timestamp": 1631550749
    },
    {
        "content": "<p>Right, first I have to have a place where I have shell access that I can reproduce this. :/</p>",
        "id": 253122653,
        "sender_full_name": "durin42",
        "timestamp": 1631551828
    },
    {
        "content": "<p>It looks like that call has a <code>#[target_feature(enable=\"sse4.1\")]</code> on top of it, so it really smells like something going awry on the LLVM rather than Rust side of things. (If its really the call that's causing problems)</p>",
        "id": 253148076,
        "sender_full_name": "nagisa",
        "timestamp": 1631562248
    },
    {
        "content": "<p>My LLVM gurus are asking for a list of compilation commands so I can try and reproduce this further, but I'm not finding the button on x.py to do that. Any guidance? (I'm still digging in parallel)</p>",
        "id": 253160418,
        "sender_full_name": "durin42",
        "timestamp": 1631567238
    },
    {
        "content": "<p>Yeah, this is gonna be hard ^^ x.py does a lot of weird stuff. If only we still had <code>--on-fail</code> <span aria-label=\"frown\" class=\"emoji emoji-1f641\" role=\"img\" title=\"frown\">:frown:</span></p>",
        "id": 253161307,
        "sender_full_name": "nagisa",
        "timestamp": 1631567623
    },
    {
        "content": "<p>Wait, I think Felix did add some sort of a command at some point in the past.</p>",
        "id": 253161420,
        "sender_full_name": "nagisa",
        "timestamp": 1631567662
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/pull/82403\">https://github.com/rust-lang/rust/pull/82403</a></p>",
        "id": 253161490,
        "sender_full_name": "nagisa",
        "timestamp": 1631567696
    },
    {
        "content": "<p>this should make <code>x.py</code> give you sufficient information.</p>",
        "id": 253161632,
        "sender_full_name": "nagisa",
        "timestamp": 1631567762
    },
    {
        "content": "<p><code>\"/build/rust/build/x86_64-unknown-linux-gnu/stage1/bin/rustc\" \"--crate-name\" \"snap\" \"--edition=2018\" \"/root/.cargo/registry/src/github.com-1ecc6299db9ec823/snap-1.0.1/src/lib.rs\" \"--error-format=json\" \"--json=diagnostic-rendered-ansi,artifacts\" \"--crate-type\" \"lib\" \"--emit=dep-info,metadata,link\" \"-C\" \"opt-level=3\" \"-C\" \"embed-bitcode=no\" \"-C\" \"debuginfo=0\" \"-C\" \"metadata=b68732a17f006f26\" \"-C\" \"extra-filename=-b68732a17f006f26\" \"--out-dir\" \"/build/rust/build/x86_64-unknown-linux-gnu/stage1-rustc/x86_64-unknown-linux-gnu/release/deps\" \"--target\" \"x86_64-unknown-linux-gnu\" \"-C\" \"linker=/usr/bin/clang-12\" \"-L\" \"dependency=/build/rust/build/x86_64-unknown-linux-gnu/stage1-rustc/x86_64-unknown-linux-gnu/release/deps\" \"-L\" \"dependency=/build/rust/build/x86_64-unknown-linux-gnu/stage1-rustc/release/deps\" \"--cap-lints\" \"allow\" \"-Zmacro-backtrace\" \"-Clink-args=-Wl,-rpath,$ORIGIN/../lib\" \"-Ztls-model=initial-exec\" \"-Zunstable-options\" \"-Wrustc::internal\" \"-Cprefer-dynamic\" \"-Z\" \"binary-dep-depinfo\" \"-Wrust_2018_idioms\" \"-Wunused_lifetimes\" \"-Wsemicolon_in_expressions_from_macros\" \"-Dwarnings\" \"--sysroot\" \"/build/rust/build/x86_64-unknown-linux-gnu/stage1\" \"-Z\" \"force-unstable-if-unmarked\"</code></p>",
        "id": 253162379,
        "sender_full_name": "durin42",
        "timestamp": 1631568023
    },
    {
        "content": "<p>So that's not nothing, I guess? Since it's the stage1 is it plausible I should try and bisect LLVM to have a better sense of what to sniff-test next?</p>",
        "id": 253162436,
        "sender_full_name": "durin42",
        "timestamp": 1631568051
    },
    {
        "content": "<p>If I was investigating this, I would grab the <code>snap</code> crate and try to minimize it to a single self-contained reproducer first (using the stage1 compiler)</p>",
        "id": 253167957,
        "sender_full_name": "nagisa",
        "timestamp": 1631570651
    },
    {
        "content": "<p>though I guess you can work on that in parallel to bisecting LLVM too.</p>",
        "id": 253167988,
        "sender_full_name": "nagisa",
        "timestamp": 1631570676
    },
    {
        "content": "<p>Okay, now I feel like I'm taking crazy pills. <code>python3 x.py build compiler/rustc</code> fails, <code>python3 x.py build</code> succeeds. That doesn't make any kind of sense, does it?</p>",
        "id": 253278550,
        "sender_full_name": "durin42",
        "timestamp": 1631636234
    },
    {
        "content": "<p>x.py build compiler/rustc only compilers for stage1 a subset of all crates.</p>",
        "id": 253298621,
        "sender_full_name": "nagisa",
        "timestamp": 1631643754
    },
    {
        "content": "<p>Seems like we need to patch x.py then?</p>",
        "id": 253316469,
        "sender_full_name": "durin42",
        "timestamp": 1631650424
    },
    {
        "content": "<p>Also, I'm seeing <code>python3 x.py test src/test/run-make src/test/run-make-fulldeps src/test/run-pass-valgrind</code> fail with the same intrinsic selection error. I assume there's some sort of broken dependency or something?</p>",
        "id": 253316598,
        "sender_full_name": "durin42",
        "timestamp": 1631650468
    },
    {
        "content": "<p>Does that fail while building rustc or running tests?</p>",
        "id": 253318331,
        "sender_full_name": "Nikita Popov",
        "timestamp": 1631651143
    },
    {
        "content": "<p><code>Building stage1 compiler artifacts (x86_64-unknown-linux-gnu -&gt; x86_64-unknown-linux-gnu)</code> in that phase</p>",
        "id": 253318413,
        "sender_full_name": "durin42",
        "timestamp": 1631651167
    },
    {
        "content": "<p>Okay, sounds like the same issue then.</p>",
        "id": 253318459,
        "sender_full_name": "Nikita Popov",
        "timestamp": 1631651188
    },
    {
        "content": "<p>Run the build with <code>-vvv</code> to extract the relevant rustc invocation.</p>",
        "id": 253318506,
        "sender_full_name": "Nikita Popov",
        "timestamp": 1631651215
    },
    {
        "content": "<p>Ah, scroling up I see that you already did that</p>",
        "id": 253318600,
        "sender_full_name": "Nikita Popov",
        "timestamp": 1631651251
    },
    {
        "content": "<p>Okay and I can reproduce it outside the docker container now!</p>",
        "id": 253318622,
        "sender_full_name": "durin42",
        "timestamp": 1631651261
    },
    {
        "content": "<p>so I can give you an easy reproduction recipe if you want it</p>",
        "id": 253318690,
        "sender_full_name": "durin42",
        "timestamp": 1631651283
    },
    {
        "content": "<p>oh for crying out loud <a href=\"https://reviews.llvm.org/D105462\">https://reviews.llvm.org/D105462</a></p>",
        "id": 253347244,
        "sender_full_name": "durin42",
        "timestamp": 1631667671
    },
    {
        "content": "<p>I have no idea why people keep trying to disable vector register on x64 /biased</p>",
        "id": 253347814,
        "sender_full_name": "Jubilee",
        "timestamp": 1631668112
    },
    {
        "content": "<p>the committer is from Intel, so I feel like they must know something about CPUs?</p>",
        "id": 253348149,
        "sender_full_name": "durin42",
        "timestamp": 1631668420
    },
    {
        "content": "<p>I guess we need to make sse4.2 imply crc32 somehow?</p>",
        "id": 253348213,
        "sender_full_name": "durin42",
        "timestamp": 1631668454
    },
    {
        "content": "<p>Oh, I assume they are doing it properly, I just scratch my head at it.<br>\nThough, I suppose it makes sense for kernel code.</p>",
        "id": 253348544,
        "sender_full_name": "Jubilee",
        "timestamp": 1631668721
    },
    {
        "content": "<p>Any idea where in rustc I should be looking to fix this?</p>",
        "id": 253348571,
        "sender_full_name": "durin42",
        "timestamp": 1631668751
    },
    {
        "content": "<p>So, on x86, there is now an additional flag to build with? Hmm.</p>",
        "id": 253348687,
        "sender_full_name": "Jubilee",
        "timestamp": 1631668829
    },
    {
        "content": "<p>At least by default, I guess?</p>",
        "id": 253348746,
        "sender_full_name": "durin42",
        "timestamp": 1631668882
    },
    {
        "content": "<p>Much of the code concerning target features is somewhere hereabouts: <a href=\"https://github.com/rust-lang/rust/blob/2b8de6f21286d6dbd7dd692af7da7dc6937861d3/compiler/rustc_codegen_ssa/src/target_features.rs\">https://github.com/rust-lang/rust/blob/2b8de6f21286d6dbd7dd692af7da7dc6937861d3/compiler/rustc_codegen_ssa/src/target_features.rs</a> and <br>\n<a href=\"https://github.com/rust-lang/rust/tree/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/compiler/rustc_target/src\">https://github.com/rust-lang/rust/tree/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/compiler/rustc_target/src</a></p>",
        "id": 253348843,
        "sender_full_name": "Jubilee",
        "timestamp": 1631668949
    },
    {
        "content": "<p>enabling crc32 when sse4.2 is enabled is fairly reasonable.</p>",
        "id": 253348932,
        "sender_full_name": "nagisa",
        "timestamp": 1631669039
    },
    {
        "content": "<p>I assume should I add crc32 to X86_ALLOWED_FEATURES?</p>",
        "id": 253349022,
        "sender_full_name": "durin42",
        "timestamp": 1631669102
    },
    {
        "content": "<p>Not really. I'm not sure we want to allow crc32 as a standalone feature on our end. And it wouldn't help with the backcompat either way.</p>",
        "id": 253349203,
        "sender_full_name": "nagisa",
        "timestamp": 1631669266
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_llvm/src/llvm_util.rs#L159-L189\">https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_llvm/src/llvm_util.rs#L159-L189</a> seems like it would be an okay place to implement the… ahem… hack(?)..</p>",
        "id": 253349286,
        "sender_full_name": "nagisa",
        "timestamp": 1631669319
    },
    {
        "content": "<p>but this is currently 1:1 mapping only.</p>",
        "id": 253349293,
        "sender_full_name": "nagisa",
        "timestamp": 1631669328
    },
    {
        "content": "<p>Ah that's the function I was missing.</p>",
        "id": 253349317,
        "sender_full_name": "Jubilee",
        "timestamp": 1631669344
    },
    {
        "content": "<p>would have to adjust it so that sse4.2 can map to multiple distinct features.</p>",
        "id": 253349320,
        "sender_full_name": "nagisa",
        "timestamp": 1631669345
    },
    {
        "content": "<p>the warning on top of this function and the fallback case <code>(_, s) =&gt; s</code> makes me wonder if that can be exploited to cause a compiler crash <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 253349458,
        "sender_full_name": "nagisa",
        "timestamp": 1631669439
    },
    {
        "content": "<p>I could add some sort of implied_features function too? Though making that existing <code>to_llvm_feature</code> return a set of enabled features I guess makes sense.</p>",
        "id": 253349798,
        "sender_full_name": "durin42",
        "timestamp": 1631669747
    },
    {
        "content": "<p>Also looks like we need to gate reporting the crc32 feature on it being LLVM 14, but I assume that's easy enough.</p>",
        "id": 253349852,
        "sender_full_name": "durin42",
        "timestamp": 1631669767
    },
    {
        "content": "<p>Until recently we have mostly been just deferring to LLVM handling the implications.</p>",
        "id": 253349985,
        "sender_full_name": "Jubilee",
        "timestamp": 1631669886
    },
    {
        "content": "<p>at least, as far as I can tell.</p>",
        "id": 253349999,
        "sender_full_name": "Jubilee",
        "timestamp": 1631669899
    },
    {
        "content": "<p>Also, we don't report all LLVM features and expose our own names for some of them.</p>",
        "id": 253350020,
        "sender_full_name": "Jubilee",
        "timestamp": 1631669917
    },
    {
        "content": "<p>From the commit message upstream it sorta sounds like sse4.2 could still imply crc32?</p>",
        "id": 253350048,
        "sender_full_name": "durin42",
        "timestamp": 1631669945
    },
    {
        "content": "<p>Yeah, it's fine for sse4.2 to imply crc32 when passed to LLVM.</p>",
        "id": 253350094,
        "sender_full_name": "Jubilee",
        "timestamp": 1631669989
    },
    {
        "content": "<p>At least, from my very weak understanding that seems to be the case? They wanted to make it possible to use crc32 without sse4.2, not the other way.</p>",
        "id": 253350101,
        "sender_full_name": "durin42",
        "timestamp": 1631669997
    },
    {
        "content": "<p>Okay, maybe I should be sending LLVM folks a patch then?</p>",
        "id": 253350156,
        "sender_full_name": "durin42",
        "timestamp": 1631670011
    },
    {
        "content": "<p>I don't think I understand the LLVM patch rn, doesn't it do that?</p>",
        "id": 253350323,
        "sender_full_name": "Jubilee",
        "timestamp": 1631670173
    },
    {
        "content": "<p>it must not if we're getting this error, no?</p>",
        "id": 253350544,
        "sender_full_name": "durin42",
        "timestamp": 1631670360
    },
    {
        "content": "<p><a href=\"https://godbolt.org/z/9Y7hv4TKa\">https://godbolt.org/z/9Y7hv4TKa</a> well this compiles?</p>",
        "id": 253350737,
        "sender_full_name": "Jubilee",
        "timestamp": 1631670502
    },
    {
        "content": "<p>The clang parts of the patch explicitly allows using sse4.2 with crc32 disabled however useless that is.</p>",
        "id": 253350778,
        "sender_full_name": "nagisa",
        "timestamp": 1631670543
    },
    {
        "content": "<p>There's a code comment calling that usecase out too.</p>",
        "id": 253350830,
        "sender_full_name": "nagisa",
        "timestamp": 1631670597
    },
    {
        "content": "<p>yeah.</p>",
        "id": 253350910,
        "sender_full_name": "Jubilee",
        "timestamp": 1631670643
    },
    {
        "content": "<p>Ah so that's what I was confused about then:<br>\nclang handles passing in the crc32 feature?<br>\nOkay, yeah, then we have to, too. <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 253351067,
        "sender_full_name": "Jubilee",
        "timestamp": 1631670808
    },
    {
        "content": "<p>Yeah, clang handles it explicitly. I don't see the bit that lets you do sse4.2 without crc32 in clang? So I guess we're back to making that function return a list instead of a single string?</p>",
        "id": 253351169,
        "sender_full_name": "durin42",
        "timestamp": 1631670896
    },
    {
        "content": "<p>yup</p>",
        "id": 253351217,
        "sender_full_name": "Jubilee",
        "timestamp": 1631670936
    },
    {
        "content": "<p>And we have to make sure that it only does so if we know it's LLVM 14 or greater</p>",
        "id": 253351479,
        "sender_full_name": "Jubilee",
        "timestamp": 1631671151
    },
    {
        "content": "<p>I mean I would also probably submit a patch to LLVM if it were me, because it seems like pointless breakage, but I would also expect to lose that debate <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 253351653,
        "sender_full_name": "Jubilee",
        "timestamp": 1631671242
    },
    {
        "content": "<p>Yeah, I'll try and flag down an LLVM expert tomorrow from $WORK and see what their advice is on the LLVM side</p>",
        "id": 253352261,
        "sender_full_name": "durin42",
        "timestamp": 1631671710
    },
    {
        "content": "<p>I was referencing <a href=\"https://reviews.llvm.org/source/llvm-github/browse/main/clang/lib/Basic/Targets/X86.cpp$158\">https://reviews.llvm.org/source/llvm-github/browse/main/clang/lib/Basic/Targets/X86.cpp$158</a></p>",
        "id": 253378344,
        "sender_full_name": "nagisa",
        "timestamp": 1631693962
    },
    {
        "content": "<p>LLVM making some ill considered changes and then backpedaling on them is not all that rare.</p>",
        "id": 253378453,
        "sender_full_name": "nagisa",
        "timestamp": 1631694019
    },
    {
        "content": "<p>But yeah LLVM is not super strict with regards to the backwards compatibility. When you have a couple hundred-or-so users (rather than a millions), its way easier to justify it.</p>",
        "id": 253378509,
        "sender_full_name": "nagisa",
        "timestamp": 1631694061
    },
    {
        "content": "<p>Ah fascinating. Yeah, sse4.2 implies crc32, but you can still force it off. That seems silly to me...</p>",
        "id": 253414558,
        "sender_full_name": "durin42",
        "timestamp": 1631713101
    },
    {
        "content": "<p>So, to make sure I understood (and that it would work) I tried writing <a href=\"https://github.com/durin42/rust/commit/400bf0fd8d94a91a718f90fff91f4185f002bf2c\">https://github.com/durin42/rust/commit/400bf0fd8d94a91a718f90fff91f4185f002bf2c</a>, and it's not actually allowing the <code>snap</code> crate to compile. Is there anything obviously wrong with that patch?</p>",
        "id": 253422231,
        "sender_full_name": "durin42",
        "timestamp": 1631715727
    },
    {
        "content": "<p>That will only apply when a function specifies specific features, but not when these features are specified via a compiler flag.</p>",
        "id": 253423043,
        "sender_full_name": "nagisa",
        "timestamp": 1631716021
    },
    {
        "content": "<p>so it should work for <code>#[target_feature(enable...)]</code> hmmm...</p>",
        "id": 253423075,
        "sender_full_name": "nagisa",
        "timestamp": 1631716033
    },
    {
        "content": "<p>Ah, you're missing the preceding <code>+</code> sign for enable.</p>",
        "id": 253423148,
        "sender_full_name": "nagisa",
        "timestamp": 1631716065
    },
    {
        "content": "<p>llvm just silently ignores features names it knows of but that don't start with a + or - because it has two different places where it validates these things <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 253423271,
        "sender_full_name": "nagisa",
        "timestamp": 1631716100
    },
    {
        "content": "<p>oh for crying out loud</p>",
        "id": 253424424,
        "sender_full_name": "durin42",
        "timestamp": 1631716486
    },
    {
        "content": "<p>So I can be dirty and poke it in there, or I can make to_llvm_feature return a Vec&lt;String&gt;. Any preference?</p>",
        "id": 253424763,
        "sender_full_name": "durin42",
        "timestamp": 1631716610
    },
    {
        "content": "<p>well the dirty hack will solve the immediate issue, but probably not, like I mentioned, the case where <code>-Ctarget-feature=+sse4.2</code> is specified.</p>",
        "id": 253425642,
        "sender_full_name": "nagisa",
        "timestamp": 1631716922
    },
    {
        "content": "<p><code>to_llvm_feature</code> can probably return a <code>&amp;'static [&amp;'static str]</code>, I think.</p>",
        "id": 253425747,
        "sender_full_name": "nagisa",
        "timestamp": 1631716955
    },
    {
        "content": "<p>Do we have any tests around -Ctarget-feature that I could cargo-cult from to add a test for that? Seems like we should probably have a test.</p>",
        "id": 253426868,
        "sender_full_name": "durin42",
        "timestamp": 1631717396
    },
    {
        "content": "<p>looks like <code>src/test/codegen/target-feature-overrides.rs</code> might be the thing to try and copy from</p>",
        "id": 253427634,
        "sender_full_name": "durin42",
        "timestamp": 1631717654
    },
    {
        "content": "<p><a href=\"https://github.com/durin42/rust/commit/28ce260263f95a51909c2589a6dffa445561ff57#diff-3f7853de8eb4803e88e699841c99812f30b75c92fa5b6fd2080141699e5aa6a7\">here's a test I've written</a> for the <code>#[target_feature(enable = \"sse4.2\")]</code> case. Still not quite sure how I should (or if?) I should have a matching test for the <code>-Ctarget-feature</code> compiler flag flavor. Let me know?</p>\n<p>I'm going to rework the change now to make <code>to_llvm_feature</code> return a list and see how that goes.</p>",
        "id": 253431040,
        "sender_full_name": "durin42",
        "timestamp": 1631718834
    },
    {
        "content": "<p>just check that it builds with the flag but without attribute or write an assembly test.</p>",
        "id": 253433176,
        "sender_full_name": "nagisa",
        "timestamp": 1631719617
    },
    {
        "content": "<p>Do you have any examples of how I should do that check? I think other than tests I might be good to go.</p>",
        "id": 253450232,
        "sender_full_name": "durin42",
        "timestamp": 1631725232
    },
    {
        "content": "<p>like idk, an assembly test could look like this:</p>\n<div class=\"codehilite\"><pre><span></span><code>// compile-flags: --emit=asm -Ctarget-feature=+sse4.2\n\nCHECK-LABEL: banana\nCHECK: crc32\nfn banana() {\n    _mm_crc32_thing_or_whatever_its_called()\n}\n</code></pre></div>",
        "id": 253454506,
        "sender_full_name": "nagisa",
        "timestamp": 1631726693
    },
    {
        "content": "<p>slap on some <code>//only-x86</code> on there, perhaps also fix whatever typos I made in there and it should be good? Especially if you're careful about not including <code>crc32</code> in the test name. It'd go into <code>src/test/assembly</code></p>",
        "id": 253454564,
        "sender_full_name": "nagisa",
        "timestamp": 1631726722
    },
    {
        "content": "<p>Alrighty, let me see if I can set that up so it fails without my patch first. :)</p>",
        "id": 253457347,
        "sender_full_name": "durin42",
        "timestamp": 1631727833
    },
    {
        "content": "<p>So I've got</p>\n<div class=\"codehilite\"><pre><span></span><code>// assembly-output: emit-asm\n// compile-flags: --crate-type staticlib -Ctarget-feature=+sse4.2\n// needs-llvm-components: x86\n\n// CHECK-LABEL: banana\n// CHECK: crc32\n#[no_mangle]\npub unsafe fn banana(v: u8) -&gt; u32 {\n    use std::arch::x86_64::*;\n    let mut out = !0u32;\n    _mm_crc32_u8(out, v);\n    out\n}\n</code></pre></div>\n<p>but it fails with no match (this is without my change), and the resulting asm is</p>\n<div class=\"codehilite\"><pre><span></span><code>    .text\n    .file   &quot;x86_64_sse_crc.bced63b9-cgu.0&quot;\n    .section    .text.banana,&quot;ax&quot;,@progbits\n    .globl  banana\n    .p2align    4, 0x90\n    .type   banana,@function\nbanana:\n    .cfi_startproc\n    movl    $-1, %eax\n    retq\n.Lfunc_end0:\n    .size   banana, .Lfunc_end0-banana\n    .cfi_endproc\n\n    .section    &quot;.note.GNU-stack&quot;,&quot;&quot;,@progbits\n</code></pre></div>",
        "id": 253459531,
        "sender_full_name": "durin42",
        "timestamp": 1631728632
    },
    {
        "content": "<p>that's… interesting and weird too.</p>",
        "id": 253477040,
        "sender_full_name": "nagisa",
        "timestamp": 1631735626
    },
    {
        "content": "<p>Ah, I think it might be const-evaluating the CRC perhaps?</p>",
        "id": 253477065,
        "sender_full_name": "nagisa",
        "timestamp": 1631735641
    },
    {
        "content": "<p>No, that can't be it, <code>v</code> is an argument.</p>",
        "id": 253477141,
        "sender_full_name": "nagisa",
        "timestamp": 1631735661
    },
    {
        "content": "<p>i imagine you've already figured it out but<br>\n<code>_mm_crc32_u8</code> returns the crc, so you want something like</p>\n<div class=\"codehilite\"><pre><span></span><code>pub unsafe fn banana(v: u8) -&gt; u32 {\n    use std::arch::x86_64::*;\n    let init = !0u32;\n    _mm_crc32_u8(init, v)\n}\n</code></pre></div>",
        "id": 253524897,
        "sender_full_name": "erikdesjardins",
        "timestamp": 1631764259
    },
    {
        "content": "<p>I had not! That explains a ton. Thanks!</p>",
        "id": 253604603,
        "sender_full_name": "durin42",
        "timestamp": 1631807795
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"123586\">@nagisa</span> should I squash now, or wait for the perf run to finish first?</p>",
        "id": 253616237,
        "sender_full_name": "durin42",
        "timestamp": 1631812302
    },
    {
        "content": "<p>I think the perf run will get cancelled if you squash and force push before its complete.</p>",
        "id": 253619061,
        "sender_full_name": "nagisa",
        "timestamp": 1631813479
    },
    {
        "content": "<p>not entirely sure though.</p>",
        "id": 253619088,
        "sender_full_name": "nagisa",
        "timestamp": 1631813489
    },
    {
        "content": "<p>Okay, I'll hold off, I was afraid that kind of thing might happen</p>",
        "id": 253619286,
        "sender_full_name": "durin42",
        "timestamp": 1631813574
    },
    {
        "content": "<p>I think that is only the case for the bors try run. I think as soon as the try run completes and rust-timer posts a comment about the perf run being queued it is fine to push.</p>",
        "id": 253619384,
        "sender_full_name": "bjorn3",
        "timestamp": 1631813609
    },
    {
        "content": "<p>Not quite sure though.</p>",
        "id": 253619409,
        "sender_full_name": "bjorn3",
        "timestamp": 1631813617
    }
]