[
    {
        "content": "<p>Other than the maximum number of raw string delimiters, are there other limits that should be defined at some point?</p>",
        "id": 276292107,
        "sender_full_name": "isHavvy",
        "timestamp": 1648015508
    },
    {
        "content": "<p>I think it would be nice to have some kind of high-level guiding principles on that.  There are many places where the reference currently defines unbounded limits.  Just in the lexer, any production that has <code>*</code> or <code>+</code> repetition (identifier lengths, literals, etc.).  </p>\n<p>However, I feel like every instance will be a difficult process to make a final decision.  There will be reasons for and against a limit, or what specific limits there should be, or if they should be minimum or maximums, or should it be implementation-defined. I'm honestly not sure if it is worth the effort right now. There are lots of other things to consider and spend energy on.</p>",
        "id": 276345070,
        "sender_full_name": "Eric Huss",
        "timestamp": 1648047256
    },
    {
        "content": "<p>As an example, here are some limits defined in C11:</p>\n<p>5.2.4.1 Translation limits<br>\n1 The implementation shall be able to translate and execute at least one program that<br>\ncontains at least one instance of every one of the following limits:18)<br>\n— 127 nesting levels of blocks<br>\n— 63 nesting levels of conditional inclusion<br>\n— 12 pointer, array, and function declarators (in any combinations) modifying an<br>\narithmetic, structure, union, or void type in a declaration<br>\n— 63 nesting levels of parenthesized declarators within a full declarator<br>\n— 63 nesting levels of parenthesized expressions within a full expression<br>\n— 63 significant initial characters in an internal identifier or a macro name (each<br>\nuniversal character name or extended source character is considered a single<br>\ncharacter)<br>\n— 31 significant initial characters in an external identifier (each universal character name<br>\nspecifying a short identifier of 0000FFFF or less is considered 6 characters, each<br>\n18) Implementations should avoid imposing fixed translation limits whenever possible.<br>\n§5.2.4.1 Environment 25<br>\nISO/IEC 9899:201x Committee Draft — December 2, 2010 N1548<br>\nuniversal character name specifying a short identifier of 00010000 or more is<br>\nconsidered 10 characters, and each extended source character is considered the same<br>\nnumber of characters as the corresponding universal character name, if any) 19)<br>\n— 4095 external identifiers in one translation unit<br>\n— 511 identifiers with block scope declared in one block<br>\n— 4095 macro identifiers simultaneously defined in one preprocessing translation unit<br>\n— 127 parameters in one function definition<br>\n— 127 arguments in one function call<br>\n— 127 parameters in one macro definition<br>\n— 127 arguments in one macro invocation<br>\n— 4095 characters in a logical source line<br>\n— 4095 characters in a string literal (after concatenation)<br>\n— 65535 bytes in an object (in a hosted environment only)<br>\n— 15 nesting levels for #included files<br>\n— 1023 case labels for a switch statement (excluding those for any nested switch<br>\nstatements)<br>\n— 1023 members in a single structure or union<br>\n— 1023 enumeration constants in a single enumeration<br>\n— 63 levels of nested structure or union definitions in a single struct-declaration-lis</p>",
        "id": 276345109,
        "sender_full_name": "Eric Huss",
        "timestamp": 1648047275
    },
    {
        "content": "<p>But other languages like Java are sometimes a little looser. For example, it says identifiers are \"unlimited-length\".  And IIRC, Java has many emergent limits due to the JVM.</p>",
        "id": 276345638,
        "sender_full_name": "Eric Huss",
        "timestamp": 1648047479
    },
    {
        "content": "<p>Oh, I realize maybe you were asking if there are other pre-existing rustc-imposed limits.  None come to mind.</p>",
        "id": 276358571,
        "sender_full_name": "Eric Huss",
        "timestamp": 1648052062
    },
    {
        "content": "<p>I suspect if we went down that list from C11, we'd find a few other cases in the compiler that have limits. I know there are various things with u32 indices (which is a limit, even if it's a massive one that will never arise in practice).</p>",
        "id": 276358897,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648052168
    },
    {
        "content": "<p>And I wouldn't be surprised if there are <em>some</em> things with u16 indices.</p>",
        "id": 276358949,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648052188
    },
    {
        "content": "<p>xlang in lccc uses a u16 for \"indexing\" the operand stack (indexing in quotes because you can't do random access, but 3 instructions, pop, dup, and pivot, take a u16 number of values), and prescribes a minimum limit of 2^16-1 values on the stack (which translates, at least as it applies to rust, to 2^16-2 maximum function parameters, since parameters are removed from the operand stack by the <code>call</code> xir instruction).</p>",
        "id": 276362564,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648053391
    },
    {
        "content": "<p>Of course, if you have 65536 parameters... idk what to tell you, because you're probably not calling that function on any practical system anyways, not unless 90% of those parameters are ZSTs.</p>",
        "id": 276362645,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648053427
    },
    {
        "content": "<p>Yeah, even having more than 256 parameters seems like macro-generated-code territory.</p>",
        "id": 276386651,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648063189
    },
    {
        "content": "<p>While I think it's not going to be possible to spell out every case an implementation may be limited in some capacity, I think some that may be worth explicitly mentioning are:</p>\n<ul>\n<li>Number of bytes (UTF-8 encoded) in a single token</li>\n<li>Number of tokens in a source file</li>\n<li>Number of tokens produced by a single macro expansion</li>\n<li>Number of total characters in a source file</li>\n<li>Number of parameters in a function declaration/function type</li>\n<li>Number of arguments in a function call expression, including reciever.</li>\n<li>Size of an allocation with a given type (static, stack, thread local, dynamic)</li>\n<li>Size of an allocation produced during constant evaluation.</li>\n</ul>",
        "id": 276563878,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648174265
    },
    {
        "content": "<p>It may be a good idea to go the C++ route of \"Here are the suggested minimums\" and it could be expected that users code against the suggested minimums, so those could be placed suitably, but it would allow for limited capability implementations that have to go lower (thus we could set them higher than would be supportable on, say, a 16-bit host cpu).</p>",
        "id": 276563969,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648174374
    },
    {
        "content": "<p>All of those would be worth explicitly mentioning, but I continue to believe we should <em>not</em> allow variation on the level of support required for any of those.</p>",
        "id": 276564883,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648175412
    },
    {
        "content": "<p>If someone is building a stunt implementation for a 16-bit system, nobody's going to consider the accomplishment less impressive just because it says \"not a compliant implementation of Rust, due to insufficient memory\". Either way, it's an impressive stunt.</p>",
        "id": 276564924,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648175491
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/237824-t-lang.2Fdoc/topic/Other.20undecided.20upon.20limits.3F/near/276564883\">said</a>:</p>\n<blockquote>\n<p>All of those would be worth explicitly mentioning, but I continue to believe we should <em>not</em> allow variation on the level of support required for any of those.</p>\n</blockquote>\n<p>Well, it might be hard to enforce in some cases. And a variation in these limits is going to be natural by different designs of implementation.</p>\n<p>For \"Size of an allocation produced during constant evaluation\", consider the value <code>[0u8;1&lt;&lt;48]</code>. IIRC, a MIRI CTFE byte is 24 host bytes, so this is a massive (1&lt;&lt;56)+(1&lt;&lt;64) bytes. clearly outside the range of any practical implementation. In constrast, xlang's constant evaluator would likely use 256 bytes for the entire value, since it would just be stored as something like <code>CXValue::Array([Piece::Repeat(Value::Integer{ty: uint(8), val:0},Value::Integer{ty: uint(64), val: 0x100000000000})])</code>. </p>\n<p>Thus, one couldn't expect such a limit to be enforced naturally (by it simply causing an oom condition), but instead requires calculating the actual runtime size of the allocation, which is, heh, fun (and likely would be a fair bit of the time cost of an evaluation step).</p>",
        "id": 276603284,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648206368
    },
    {
        "content": "<p>we also have a limit for how many steps compile-time evaluation will take before it stops and errors</p>",
        "id": 276622791,
        "sender_full_name": "RalfJ",
        "timestamp": 1648216907
    },
    {
        "content": "<p>and the number of steps a constant needs is dependent on MIR generation, so this is not really comparable across implementations</p>",
        "id": 276622868,
        "sender_full_name": "RalfJ",
        "timestamp": 1648216927
    },
    {
        "content": "<p>Yeah.</p>",
        "id": 276625291,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648217979
    },
    {
        "content": "<p>That would definately be a limit that would be impossible to put an absolute limit on in terms of rust syntax.</p>",
        "id": 276625399,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648218022
    },
    {
        "content": "<p>well, not <em>impossible</em>. we could define it in terms of loop iterations and function calls as seen from the source.</p>",
        "id": 276630675,
        "sender_full_name": "RalfJ",
        "timestamp": 1648220251
    },
    {
        "content": "<p>that would preclude doing heavy transformations on the IR before executing it (unless those transformations can preserve the information of how many calls and loops there were), but for anything 'sufficiently close to the source code' in structure -- including MIR -- that would work</p>",
        "id": 276630863,
        "sender_full_name": "RalfJ",
        "timestamp": 1648220313
    },
    {
        "content": "<p>I doubt it would work with xir, though, which, while still fairly high level, will contain rust constructs desugared in some interesting ways. </p>\n<p>xir doesn't have a concept of a loop, only branches, so it wouldn't be able to track the number of \"loops\" specifically, not without some magic.</p>",
        "id": 276633483,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648221244
    },
    {
        "content": "<p>It can track calls, but only assuming any inlining hasn't already happened, which would be a very annoying thing to be enjoined from.</p>",
        "id": 276633751,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648221344
    },
    {
        "content": "<p>I agree that limits on CTFE would be harder to standardize.</p>",
        "id": 276654961,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648230131
    },
    {
        "content": "<p>Insofar as in the limit that would be equivalent to putting limits on the runtime of compiled code.</p>",
        "id": 276655097,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648230208
    },
    {
        "content": "<p>Lower bounds could probably be easily standardized, but yeah, absolute limits would be impossible to enforce w/o a significant amount of additional state.</p>",
        "id": 276657833,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648231508
    },
    {
        "content": "<p>Even lower bounds would be difficult to establish without standardizing the execution mechanism for CTFE.</p>",
        "id": 276661265,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648233276
    },
    {
        "content": "<p>It may make sense to instead require that execution time of CTFE maps onto some scalar value, and provide a means of turning that scalar value up, so that the user can push it to the limits of available resources.</p>",
        "id": 276661346,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648233321
    },
    {
        "content": "<p>But that would still lead to having to tune that value differently for different implementations. Definitely problematic.</p>",
        "id": 276661388,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648233346
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/237824-t-lang.2Fdoc/topic/Other.20undecided.20upon.20limits.3F/near/276633483\">said</a>:</p>\n<blockquote>\n<p>I doubt it would work with xir, though, which, while still fairly high level, will contain rust constructs desugared in some interesting ways. </p>\n<p>xir doesn't have a concept of a loop, only branches, so it wouldn't be able to track the number of \"loops\" specifically, not without some magic.</p>\n</blockquote>\n<p>MIR doesnt have loops either. they are just cycles in the CFG. but it's not that hard to ensure that on each cycle in the CG, one BB is marked as 'entry' or so and entering that one counts as a 'step'.</p>",
        "id": 276676823,
        "sender_full_name": "RalfJ",
        "timestamp": 1648241167
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/237824-t-lang.2Fdoc/topic/Other.20undecided.20upon.20limits.3F/near/276633751\">said</a>:</p>\n<blockquote>\n<p>It can track calls, but only assuming any inlining hasn't already happened, which would be a very annoying thing to be enjoined from.</p>\n</blockquote>\n<p>or inlining has to preserve markers, yeah. I dont necessarily think inlining should happen on the IR used for CTFE but <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 276676894,
        "sender_full_name": "RalfJ",
        "timestamp": 1648241200
    }
]