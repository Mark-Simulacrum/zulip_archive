[
    {
        "content": "<p>Regarding <a href=\"https://github.com/rust-lang/reference/pull/1180\">https://github.com/rust-lang/reference/pull/1180</a>, do we want to specify a specific limit for the number of <code>#</code> characters in a raw string?  This is implemented <a href=\"https://github.com/rust-lang/rust/blob/31535841701e0bf7ef33998024376f2cedd8b3e3/compiler/rustc_lexer/src/lib.rs#L705-L709\">here</a>.  </p>\n<p>I don't have a particular opinion.  I suppose some limit is reasonable.  I wanted to check with the lang team to see if anyone had an opinion.</p>",
        "id": 275921936,
        "sender_full_name": "Eric Huss",
        "timestamp": 1647713165
    },
    {
        "content": "<p>I think it may be a good idea to specify that it can be limited, and give a minimum limit.</p>",
        "id": 275922109,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647713504
    },
    {
        "content": "<p>Although it may be more work to decide on <em>what</em> that minimum limit should be.</p>",
        "id": 275922190,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647713632
    },
    {
        "content": "<p>I don't think we want a minimum, I think we just want a single number.</p>",
        "id": 275927917,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647721574
    },
    {
        "content": "<p>Min=max</p>",
        "id": 275927919,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647721583
    },
    {
        "content": "<p>The PR is saying 2^16?? What on earth would someone need 65k pairs for?<br>\nBut on the other hand, what are the drawbacks of having a number that large? I doubt anyone uses more than a dozen, if that.</p>",
        "id": 275928248,
        "sender_full_name": "Jacob Pratt ðŸ‡ºðŸ‡¦",
        "timestamp": 1647722114
    },
    {
        "content": "<p>I think there could be considerations if the host of an implementation is considerably less powerful than x86_64. <br>\nRealistically, 128 is probably more than ever needed and a decent minimum upper bound. If that is <em>the</em> upperbound  also, that's fine.  I don't think it needs or is a good idea in general, though, to make either the minimum or absolute limit 64k.</p>",
        "id": 275928609,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647722633
    },
    {
        "content": "<p>I think 65535 was somewhat arbitrary. The limit was lowered from a u32 in <a href=\"https://github.com/rust-lang/rust/issues/49993\">#49993</a> as a space optimization. <a href=\"https://github.com/rust-lang/rust/issues/50111\">#50111</a> discussed improving the error, where 255 was suggested, but it looks like after some back-and-forth, they stuck with 65535 in <a href=\"https://github.com/rust-lang/rust/issues/50296\">#50296</a> (decision at <a href=\"https://github.com/rust-lang/rust/pull/50296#issuecomment-388372459\">https://github.com/rust-lang/rust/pull/50296#issuecomment-388372459</a>).</p>",
        "id": 275928886,
        "sender_full_name": "Eric Huss",
        "timestamp": 1647722915
    },
    {
        "content": "<p>I guess this discussion could be more of \"should there be implementation-defined limits?\"  There are lots of limits all over that have varying behaviors (returns an error, runs out of memory, etc.).  This is just one arbitrary example.</p>\n<p>I'm a bit on the fence, as I can see pros and cons of defining limits.  It seems to be pretty rare for language specs to define them, though.</p>",
        "id": 275929606,
        "sender_full_name": "Eric Huss",
        "timestamp": 1647723902
    },
    {
        "content": "<p>C and C++ both define it.<br>\nC++ makes them soft limits and just recommends minimums.<br>\nC hard-requires certain minimums (such as up to 15 characters in an external identifier).</p>",
        "id": 275930104,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647724585
    },
    {
        "content": "<p>TIL Rust has literally no limit on identifier length. Or at least it didn't mind my 1gb identifier.</p>",
        "id": 275932729,
        "sender_full_name": "Chris Denton",
        "timestamp": 1647728069
    },
    {
        "content": "<p>I don't think we should have implementation defined limits; that would mean different implementations parse different subsets of Rust code, and in practice people should only rely on the minimum anyway.</p>",
        "id": 275933853,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647729478
    },
    {
        "content": "<p>Allowing more seems like a pointless extension that just introduces incompatibility.</p>",
        "id": 275933894,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647729491
    },
    {
        "content": "<p>I think for the purposes of that original pull request, it just so happened that reducing smaller than a u16 didn't actually reduce the size of the structure at all, but that's not an argument on the basis of what code actually needs, that's just an argument towards making a conservative change.</p>",
        "id": 275933901,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647729518
    },
    {
        "content": "<p>I think in practice stating the limit as 255 or even just 32 would not cause issues.</p>",
        "id": 275933918,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647729548
    },
    {
        "content": "<p>And whatever limit we set, I don't think we should make it an optional extension to support more, I think we should just set it as the requirement.</p>",
        "id": 275933931,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647729588
    },
    {
        "content": "<p>I know C has a whole explanation in the standard for \"minimum maximums\", as well as minimums.</p>",
        "id": 275934190,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647730059
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/237824-t-lang.2Fdoc/topic/Max.20raw.20string.20delimiters/near/275933931\">said</a>:</p>\n<blockquote>\n<p>And whatever limit we set, I don't think we should make it an optional extension to support more, I think we should just set it as the requirement.</p>\n</blockquote>\n<p>For this, I will say fair.</p>",
        "id": 275935137,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647731524
    },
    {
        "content": "<p>(I do think there are cases that the general limit would be higher than the minimum because low-capability implementations, such as ones running on DOS, would need to be considered)</p>",
        "id": 275940353,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647739617
    },
    {
        "content": "<p>Sure, the main reason to have varying limits at all would be for implementations on very small systems.</p>\n<p>But I'm not sure running the compiler itself (as opposed to the compiled code) on DOS is a use case we need to worry about.</p>",
        "id": 275945520,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647748321
    },
    {
        "content": "<p>Especially without a DOS extender.</p>",
        "id": 275945560,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647748332
    },
    {
        "content": "<p>... What, I have some <em>creative</em> ideas about what to do with my time.</p>\n<p>In any case, it probably doesn't need to be explored for this specifically, since I think a sufficiently low limit would be reasonable anyways.</p>\n<p>It might be a good idea to consider at some point, though, in general (probably coinciding with relevant policy-level decisions).</p>",
        "id": 275945953,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647748918
    },
    {
        "content": "<p>Yeah, the 64k limit was purely because making it that small was a space win for <code>Token</code>, and going to 256 didn't gain any additional useful wins. A very arbitrary way to choose it. I have a slight preference for 256 for two reasons:</p>",
        "id": 275959138,
        "sender_full_name": "nnethercote",
        "timestamp": 1647770979
    },
    {
        "content": "<ul>\n<li>It's possible in the future that a 1 byte number might result it space wins</li>\n</ul>",
        "id": 275959151,
        "sender_full_name": "nnethercote",
        "timestamp": 1647771000
    },
    {
        "content": "<ul>\n<li>65,536 just seems like a weird choice. Like, way bigger than would be needed in practice, but not unlimited.</li>\n</ul>",
        "id": 275959240,
        "sender_full_name": "nnethercote",
        "timestamp": 1647771086
    },
    {
        "content": "<p>Hiya, I'm the creator of that PR. I do think 2^16 is a strange limit and 256 would work just fine, but I'm probably not really qualified to make that assesment.</p>\n<p>However, this PR was not made with the intention of defining some upper bound, it was made for the sake completeness of the documentation. At the end of the day, 2^16 _is_ the current limit, so I figure that should be documented somewhere.</p>",
        "id": 275984357,
        "sender_full_name": "GV",
        "timestamp": 1647805574
    },
    {
        "content": "<p>I assume y'all mean 255 so it actually fits a u8?</p>",
        "id": 276267096,
        "sender_full_name": "RalfJ",
        "timestamp": 1647990816
    },
    {
        "content": "<p>Yes.</p>",
        "id": 276272523,
        "sender_full_name": "nnethercote",
        "timestamp": 1647994846
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120989\">nnethercote</span> <a href=\"#narrow/stream/237824-t-lang.2Fdoc/topic/Max.20raw.20string.20delimiters/near/275959151\">said</a>:</p>\n<blockquote>\n<ul>\n<li>It's possible in the future that a 1 byte number might result it space wins</li>\n</ul>\n</blockquote>\n<p>I was looking at the size of <code>Token</code> again just yesterday, so I'm going to upgrade my slight preference for 255 here to a strong preference.</p>",
        "id": 276272770,
        "sender_full_name": "nnethercote",
        "timestamp": 1647994952
    },
    {
        "content": "<p>I don't personally care whether it's a lang-defined limit or an implementation-defined limit, so long as 255 is an allowable limit.</p>",
        "id": 276272857,
        "sender_full_name": "nnethercote",
        "timestamp": 1647994998
    },
    {
        "content": "<p>I have no preference in the matter here either.<br>\nOne reason that making it a minimum limit rather than an absolute limit, is that it may be more efficient in some cases for an implementation to use a 16-bit int, rather than an 8-bit int, and the extra comparison might be an extra time cost. I don't think there's a <em>huge</em> advantage to making it a minimum limit, though.</p>",
        "id": 276276764,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647996879
    },
    {
        "content": "<p>I do definately think that 64k is a hugely excessive limit, though.</p>",
        "id": 276276805,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647996933
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/237824-t-lang.2Fdoc/topic/Max.20raw.20string.20delimiters/near/276267096\">said</a>:</p>\n<blockquote>\n<p>I assume y'all mean 255 so it actually fits a u8?</p>\n</blockquote>\n<p>I was assuming 0-255 \"number of additional levels beyond the first\", if the enum variant just doesn't exist for strings without the <code>#</code>.</p>",
        "id": 276290786,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648013789
    },
    {
        "content": "<p>If the field exists even for strings without <code>#</code> then sure, it'd need to be 0-255, or better yet Option&lt;NonZeroU8&gt;.</p>",
        "id": 276290794,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648013814
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/237824-t-lang.2Fdoc/topic/Max.20raw.20string.20delimiters/near/276276764\">said</a>:</p>\n<blockquote>\n<p>I have no preference in the matter here either.<br>\nOne reason that making it a minimum limit rather than an absolute limit, is that it may be more efficient in some cases for an implementation to use a 16-bit int, rather than an 8-bit int, and the extra comparison might be an extra time cost. I don't think there's a <em>huge</em> advantage to making it a minimum limit, though.</p>\n</blockquote>\n<p>The number of things that would have to be true for that to happen seems excessively many. 16-bit compiler, on a system where 16-bit is more efficient than 8-bit (not true of the most obvious 16-bit systems), running a native Rust compiler, and even then this <em>won't</em> be anywhere <em>close</em> to a bottleneck.</p>",
        "id": 276290864,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648013893
    },
    {
        "content": "<p>It's theoretically possible to construct a scenario in which it would matter, but how much it matters in such a scenario has to be discounted by how much that scenario matters.</p>",
        "id": 276290887,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648013949
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/237824-t-lang.2Fdoc/topic/Max.20raw.20string.20delimiters/near/276290864\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/237824-t-lang.2Fdoc/topic/Max.20raw.20string.20delimiters/near/276276764\">said</a>:</p>\n<blockquote>\n<p>I have no preference in the matter here either.<br>\nOne reason that making it a minimum limit rather than an absolute limit, is that it may be more efficient in some cases for an implementation to use a 16-bit int, rather than an 8-bit int, and the extra comparison might be an extra time cost. I don't think there's a <em>huge</em> advantage to making it a minimum limit, though.</p>\n</blockquote>\n<p>The number of things that would have to be true for that to happen seems excessively many. 16-bit compiler, on a system where 16-bit is more efficient than 8-bit (not true of the most obvious 16-bit systems), running a native Rust compiler, and even then this <em>won't</em> be anywhere <em>close</em> to a bottleneck.</p>\n</blockquote>\n<p>Actually the trivial situtation would be if <code>u8</code> in the structure ended up being padded to a u16 anyways, or maybe the whole structure ends up as a multiple of 8 bytes &gt; 16, but not a multiple 16, on x86_64 (in which case, it's more likely for a larger field in that case). This isn't going to be a hill I'd die upon, though. I have better places to argue for the allowance of a greater limit.</p>",
        "id": 276318861,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648034640
    },
    {
        "content": "<p>To the best of my knowledge, a u8 padded to u16 on x86-64 would still be just as efficient to access via a byte access.</p>",
        "id": 276353279,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648050369
    },
    {
        "content": "<p>In that case, though, it's unnecessarily wasting half of the space. Theoretically it could also avoid a check if the limit it supports is high enough it couldn't ever be reached (e.g. wrapping ops on u32, if the padding would make it effectively 4 bytes anyways).</p>",
        "id": 276355949,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648051288
    },
    {
        "content": "<p>The other case would be if the type ends up 12 bytes in size after padding, rather than 16, since the former needs at least two moves, and the latter needs only 1.</p>",
        "id": 276356339,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648051406
    },
    {
        "content": "<p>(That sort of case being more likely on ix86 or x32, I will admit)</p>",
        "id": 276356549,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648051459
    },
    {
        "content": "<p>I'm a bit confused by the padding discussion - if it's agreed that a u8 is enough to handle everything, isn't it going to be better no matter what? Using u8 will either</p>\n<ul>\n<li>Improve the memory usage on some/all systems, or</li>\n<li>Do nothing, but future unrelated changes may improve memory usage without rethinking this again</li>\n</ul>\n<p>I made a PR for the switch (<a href=\"https://github.com/rust-lang/rust/issues/95251\">#95251</a>). I'm a bit new to all this, so I'm not super sure if it needs a more detailed explanation.</p>",
        "id": 276405158,
        "sender_full_name": "GrishaVar",
        "timestamp": 1648072008
    },
    {
        "content": "<p>This is in the realm of \"Different Implementations do different things\".</p>",
        "id": 276409096,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648074152
    },
    {
        "content": "<p>I'm starting to get the impression I shouldn't be the one doing this. I keep building and running tests, but the CI keeps failing! Aaa!</p>",
        "id": 276413506,
        "sender_full_name": "GrishaVar",
        "timestamp": 1648076505
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"487438\">@GrishaVar</span> You're doing fine, you just need a different command to ensure everything (including clippy) is built. Don't feel bad about it, rustc's build system is quite complex <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 276552244,
        "sender_full_name": "nnethercote",
        "timestamp": 1648164165
    }
]