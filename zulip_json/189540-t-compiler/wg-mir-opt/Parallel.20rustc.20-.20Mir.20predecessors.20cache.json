[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> this is related to the <code>mir cache predecessors</code> topic in <a class=\"stream\" data-stream-id=\"187679\" href=\"/#narrow/stream/187679-t-compiler.2Fwg-parallel-rustc\">#t-compiler/wg-parallel-rustc</a>. So I think your idea of the separate query makes a lot of sense. I only didn't understand the part about the passes that need mutable access to the cache will have access anyways. Here are you implying that only the passes that generate the cache will need mutable access?</p>\n<p>While reviewing the code last week, I saw that the only mutable access currently implemented is to simply wipe the cache when the basic blocks are updated, and the next read recomputes the cache.</p>",
        "id": 176004636,
        "sender_full_name": "Paul Faria",
        "timestamp": 1568813285
    },
    {
        "content": "<p>I checked the read sites, and I think all of them are either after after the <code>optimized_mir</code> query is done, or during optimizations</p>",
        "id": 176004831,
        "sender_full_name": "oli",
        "timestamp": 1568813413
    },
    {
        "content": "<p>How would that fit in with separate passes? Would this simply mean that a modification of the cache and a following read would cause the pass to be run again? (Which I thought was not possible since pass results are immutably cached) or does this never actually occur? I'm also not sure if this still holds when the compiler is processing the queries in parallel</p>",
        "id": 176004835,
        "sender_full_name": "Paul Faria",
        "timestamp": 1568813415
    },
    {
        "content": "<p>Separating the queries is thus unnecessary I believe</p>",
        "id": 176004846,
        "sender_full_name": "oli",
        "timestamp": 1568813429
    },
    {
        "content": "<p>Oh you just answered my second question <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 176004857,
        "sender_full_name": "Paul Faria",
        "timestamp": 1568813436
    },
    {
        "content": "<p>we can simply remove all interior mutability and panic if it's still <code>None</code> when needed</p>",
        "id": 176004875,
        "sender_full_name": "oli",
        "timestamp": 1568813460
    },
    {
        "content": "<p>I'm not sure I'm following 100%. You're saying we should disallow invalidation of the cache?</p>",
        "id": 176005090,
        "sender_full_name": "Paul Faria",
        "timestamp": 1568813602
    },
    {
        "content": "<p>Actually, let me follow up when I'm back to my laptop.</p>",
        "id": 176005387,
        "sender_full_name": "Paul Faria",
        "timestamp": 1568813793
    },
    {
        "content": "<p>ah, no, invalidation can only happen while we have mutable access, because invalidation happens when mutating the body</p>",
        "id": 176005567,
        "sender_full_name": "oli",
        "timestamp": 1568813938
    },
    {
        "content": "<p>so we can just set it to <code>None</code>, but that doesn't need interior mutability</p>",
        "id": 176005589,
        "sender_full_name": "oli",
        "timestamp": 1568813951
    },
    {
        "content": "<p>whenever we need it and have mutable access, we can reinitialize it (or just read it if it's Some)</p>",
        "id": 176005644,
        "sender_full_name": "oli",
        "timestamp": 1568813996
    },
    {
        "content": "<p>so nothing changes about the status quo, except that we have two \"read\" accessors</p>",
        "id": 176005716,
        "sender_full_name": "oli",
        "timestamp": 1568814018
    },
    {
        "content": "<p>one with <code>&amp;mut</code> that initializes if necessary</p>",
        "id": 176005724,
        "sender_full_name": "oli",
        "timestamp": 1568814025
    },
    {
        "content": "<p>and one with <code>&amp;</code> that panics if <code>None</code></p>",
        "id": 176005737,
        "sender_full_name": "oli",
        "timestamp": 1568814036
    },
    {
        "content": "<p>we'll also need a dummy pass at the end of the pipeline that does nothing but initialize the cache</p>",
        "id": 176005777,
        "sender_full_name": "oli",
        "timestamp": 1568814061
    },
    {
        "content": "<p>after optimizations it will be needed at least once, so we don't lose anything by computing the cache eagerly</p>",
        "id": 176005808,
        "sender_full_name": "oli",
        "timestamp": 1568814089
    },
    {
        "content": "<p>Sorry for the delay. Traveling to Sunnyvale today and had some surprises pop up in the morning. I might be able to start serious work on this Friday and if not then sometime in the weekend.</p>",
        "id": 176050046,
        "sender_full_name": "Paul Faria",
        "timestamp": 1568843604
    },
    {
        "content": "<p>no pressure! Take all the time you need</p>",
        "id": 176099979,
        "sender_full_name": "oli",
        "timestamp": 1568900400
    },
    {
        "content": "<p>So I implemented your suggestion, but I still feel worried about this approach (still compiling at the moment, but I'm pretty sure this is going to crash). All readers of the predecessors only ever wanted immutable read access. However, the code that invalidates the predecessors happens more frequently. I did a regex search against <code>basic_body_.*?mut</code> and found with 27 instances that would invalidate the predecessors cache. The other issue I ran into is that it seems interior mutability was being used to avoid a clone when requesting the predecessors. It was being called as <code>self.cache.predecessors(self)</code>, where self was of type <code>&amp;Body&lt;...&gt;</code>. When changing this to not use interior mutability, that means I need cache to be <code>&amp;mut self</code> in <code>predecessors_mut</code>, but this requires that <code>self: &amp;mut Body&lt;...&gt;</code>. That won't compile because the passed <code>self</code> is already borrowed. I can get around this by cloning <code>self: &amp;Body&lt;...&gt;</code>, but that doesn't seem ideal for performance.</p>",
        "id": 176326459,
        "sender_full_name": "Paul Faria",
        "timestamp": 1569186857
    },
    {
        "content": "<p>I think what I'll do later tonight (have to step out for a few hours) if not tomorrow evening, is try to manually map out where the cache is being invalidated and where's it's being read (and would possibly require unique access to the cache to recompute).</p>",
        "id": 176326524,
        "sender_full_name": "Paul Faria",
        "timestamp": 1569187013
    },
    {
        "content": "<p>There were also notes left in the comments about maybe implementing a more intelligent cache that only cleared what was needed. Do you think now might be a good opportunity to revisit that idea, or only once the interior mutability is all cleared up?</p>",
        "id": 176326614,
        "sender_full_name": "Paul Faria",
        "timestamp": 1569187198
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/blob/master/src/librustc/mir/cache.rs#L42\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/master/src/librustc/mir/cache.rs#L42\">https://github.com/rust-lang/rust/blob/master/src/librustc/mir/cache.rs#L42</a> is the comment I'm referring to.</p>",
        "id": 176326666,
        "sender_full_name": "Paul Faria",
        "timestamp": 1569187258
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> whenever you're free ^. Side question: what's the etiquette for pinging people in Zulip? I wasn't sure if pinging every time I had a question would be too annoying, or useful as a way to focus someone where they're needed</p>",
        "id": 176366757,
        "sender_full_name": "Paul Faria",
        "timestamp": 1569244425
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> I found one spot where the predecessors are read and then immediately written over (the mut access will invalidate the cache):<br>\n<a href=\"https://github.com/rust-lang/rust/blob/master/src/librustc_mir/transform/add_call_guards.rs#L42-L49\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/master/src/librustc_mir/transform/add_call_guards.rs#L42-L49\">https://github.com/rust-lang/rust/blob/master/src/librustc_mir/transform/add_call_guards.rs#L42-L49</a></p>",
        "id": 176426298,
        "sender_full_name": "Paul Faria",
        "timestamp": 1569290822
    },
    {
        "content": "<p>Is it possible that other optimizations could be running at the same time this is being computed?</p>",
        "id": 176426356,
        "sender_full_name": "Paul Faria",
        "timestamp": 1569290898
    },
    {
        "content": "<p>Or is this an instance where I should be accessing the mutable variant of predecessors?</p>",
        "id": 176426361,
        "sender_full_name": "Paul Faria",
        "timestamp": 1569290922
    },
    {
        "content": "<p>pinging is fine (at least for me :D)</p>",
        "id": 176441579,
        "sender_full_name": "oli",
        "timestamp": 1569312819
    },
    {
        "content": "<p>So... multiple things:</p>\n<ol>\n<li>probably not all <code>basic_block_mut</code> calls actually mutate the terminator's targets or the number of blocks, maybe we should find a scheme for that</li>\n<li>Unfortunately I can't quite follow what you're saying about multiple mutable borrows, can you push some code that I can look at?</li>\n<li>the comment may be referring to 1. because otherwise I have no idea how to approach a partial invalidation</li>\n</ol>",
        "id": 176441964,
        "sender_full_name": "oli",
        "timestamp": 1569313192
    },
    {
        "content": "<p>I opened a draft PR here <a href=\"https://github.com/rust-lang/rust/pull/64736\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/pull/64736\">https://github.com/rust-lang/rust/pull/64736</a></p>",
        "id": 176461662,
        "sender_full_name": "Paul Faria",
        "timestamp": 1569330631
    },
    {
        "content": "<p>This is the line I can't figure out how to avoid a clone on <a href=\"https://github.com/rust-lang/rust/pull/64736/files#diff-f0577ac900ffbd36d3bb3421a928cbbdR234\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/pull/64736/files#diff-f0577ac900ffbd36d3bb3421a928cbbdR234\">https://github.com/rust-lang/rust/pull/64736/files#diff-f0577ac900ffbd36d3bb3421a928cbbdR234</a></p>",
        "id": 176461808,
        "sender_full_name": "Paul Faria",
        "timestamp": 1569330752
    },
    {
        "content": "<p>I'll think about options for 1. I need to run to work for the moment, but I should be back online late tonight to continue working through ideas. I'll follow up with you tomorrow morning</p>",
        "id": 176461880,
        "sender_full_name": "Paul Faria",
        "timestamp": 1569330802
    },
    {
        "content": "<p>I posted some comments on the PR</p>",
        "id": 176462564,
        "sender_full_name": "oli",
        "timestamp": 1569331213
    },
    {
        "content": "<p>I took a look. Moving the cache into <code>Body</code> makes a lot more sense than the idea I was sitting on <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 176475725,
        "sender_full_name": "Paul Faria",
        "timestamp": 1569339278
    },
    {
        "content": "<p>I'll address those tonight</p>",
        "id": 176475735,
        "sender_full_name": "Paul Faria",
        "timestamp": 1569339287
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> the latest changes are up. My only hesitation with the current impl is this: since the predecessors are only calculated on read of a mut <code>Body</code>, what guarantees that they're computed before they're being read, e.g. in nll? The scenario I'm thinking of is this: Most of the optimizations on MIR will invalidate the predecessors cache, since they request mutable access to the basic blocks, but what code has mutable access to a <code>Body</code> that guarantees that this cache is regenerated when needed? Is it possible we need some pass where we can ensure that the cache is complete and immutable for later parts of the compiler?</p>",
        "id": 176526163,
        "sender_full_name": "Paul Faria",
        "timestamp": 1569376081
    },
    {
        "content": "<p>I've also been thinking about a way to more intelligently update the cache. What if rather than doing a full wipe-out, we had a way to track which blocks were changed during a mutation event, and update the predecessors immediately after that block completed? E.g. something like (fair warning, I'm terrible at naming things on a first pass):</p>\n<div class=\"codehilite\"><pre><span></span>body.track_body_changes(|&amp;mut basic_blocks| -&gt; {\n  basic_blocks.add_terminator(...) // gets tracked for cache\n  basic_blocks.move_terminator(...) // gets tracked for cache\n  basic_blocks.simplify_interior_of_block(..) // ignored so it&#39;s not touching terminators\n}) // after the lambda executes, but before the fn returns, the predecessors cache is recomputed\n</pre></div>\n\n\n<p>This would ensure there's always a cache to look at, but would avoid updating it too frequently. It might also save us from the excessive invalidation that currently happens (invalidate is called really frequently). However, I'm not sure how this is any better than just adding a method calls for terminators specifically, that will add to a predecessors lookup. I.e., special methods for modifying terminators since those are the only ones that would affect predecessors.</p>",
        "id": 176526468,
        "sender_full_name": "Paul Faria",
        "timestamp": 1569376465
    },
    {
        "content": "<blockquote>\n<p>Is it possible we need some pass where we can ensure that the cache is complete and immutable for later parts of the compiler?</p>\n</blockquote>\n<p>yes definitely, this must be the final pass</p>",
        "id": 176540520,
        "sender_full_name": "oli",
        "timestamp": 1569396991
    },
    {
        "content": "<p>wrt updating, I think a scheme similar to what you are suggesting is possible, though I worry whether it will get very complex if we want to truly prevent all irrelevant mutations from requiring cache recomputation</p>",
        "id": 176540580,
        "sender_full_name": "oli",
        "timestamp": 1569397070
    },
    {
        "content": "<p>e.g. think about modifying the conditions of a terminator. This does not affect the predecessor cache</p>",
        "id": 176540642,
        "sender_full_name": "oli",
        "timestamp": 1569397089
    },
    {
        "content": "<p>maybe we could start out with a <code>body.block_statements_mut()</code> function that does not invalidate and see how far that gets us?</p>",
        "id": 176540682,
        "sender_full_name": "oli",
        "timestamp": 1569397155
    },
    {
        "content": "<blockquote>\n<p>e.g. think about modifying the conditions of a terminator. This does not affect the predecessor cache</p>\n</blockquote>\n<p>I think if we can figure out a way to only invalidate on terminator changes (and not on any basic block changes), that might still be useful. I agree there's definitely a point of diminishing returns that won't be useful to pursue.</p>",
        "id": 176563510,
        "sender_full_name": "Paul Faria",
        "timestamp": 1569417765
    },
    {
        "content": "<p>I did a quick search, and it seems terminators are only created/modified through <code>BasicBlockData</code>'s <code>terminator_mut</code> (please correct me if I've missed something) and I only found 13 instances of this being used. I'm thinking  maybe we can have those be managed by the Body type in some form so that the cache just for those specific terminators can be invalidated. I'll try playing around with that tonight. I'll also move it to a separate branch so we can do perf comparisons against any other ideas that come up.</p>",
        "id": 176564380,
        "sender_full_name": "Paul Faria",
        "timestamp": 1569418289
    },
    {
        "content": "<p>This fits into the scheme of having a <code>statements_mut</code> function</p>",
        "id": 176564674,
        "sender_full_name": "oli",
        "timestamp": 1569418469
    },
    {
        "content": "<p>(which doesn't invalidate)</p>",
        "id": 176564724,
        "sender_full_name": "oli",
        "timestamp": 1569418519
    },
    {
        "content": "<p>Latest changes are up here: <a href=\"https://github.com/rust-lang/rust/pull/64841\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/pull/64841\">https://github.com/rust-lang/rust/pull/64841</a><br>\nI made a new PR since I wasn't sure if we were committed to this specific change or not. If you think all of this should be in the same PR, I'll close this one and update the original one.</p>",
        "id": 176745499,
        "sender_full_name": "Paul Faria",
        "timestamp": 1569591020
    },
    {
        "content": "<p>I'm also still missing the final pass to ensure the creation of the cache before the read-only phases.</p>",
        "id": 176745521,
        "sender_full_name": "Paul Faria",
        "timestamp": 1569591036
    },
    {
        "content": "<p>Is it correct to assume I should add it to this list: <a href=\"https://github.com/rust-lang/rust/blob/master/src/librustc_mir/transform/mod.rs#L228\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/master/src/librustc_mir/transform/mod.rs#L228\">https://github.com/rust-lang/rust/blob/master/src/librustc_mir/transform/mod.rs#L228</a></p>",
        "id": 176745597,
        "sender_full_name": "Paul Faria",
        "timestamp": 1569591109
    },
    {
        "content": "<p>Also, if this is the correct place to modify, would it go just before the <code>dump</code> pass, or do you think there's a more ideal location to run that kind of pass?</p>",
        "id": 176745681,
        "sender_full_name": "Paul Faria",
        "timestamp": 1569591170
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> , whenever you're free ^</p>",
        "id": 176745690,
        "sender_full_name": "Paul Faria",
        "timestamp": 1569591182
    },
    {
        "content": "<p>yea it could definitely be infront of the <code>dump</code> pass</p>",
        "id": 176746329,
        "sender_full_name": "oli",
        "timestamp": 1569591661
    },
    {
        "content": "<p>I'll look at the PR in detail later</p>",
        "id": 176746350,
        "sender_full_name": "oli",
        "timestamp": 1569591674
    },
    {
        "content": "<p>huh :D why is there a second PR?</p>",
        "id": 176746512,
        "sender_full_name": "oli",
        "timestamp": 1569591752
    },
    {
        "content": "<p>ah you wrote that above</p>",
        "id": 176746528,
        "sender_full_name": "oli",
        "timestamp": 1569591760
    },
    {
        "content": "<p>yea do everything in the one PR</p>",
        "id": 176746534,
        "sender_full_name": "oli",
        "timestamp": 1569591768
    },
    {
        "content": "<p>hmm.. oh that's about the smart invalidation?</p>",
        "id": 176746656,
        "sender_full_name": "oli",
        "timestamp": 1569591853
    },
    {
        "content": "<p>yea that shouldn't be intermingled</p>",
        "id": 176746666,
        "sender_full_name": "oli",
        "timestamp": 1569591862
    },
    {
        "content": "<p>The first PR shouldn't optimize the invalidation</p>",
        "id": 176746678,
        "sender_full_name": "oli",
        "timestamp": 1569591874
    },
    {
        "content": "<p>just keeping the status quo is ok</p>",
        "id": 176746685,
        "sender_full_name": "oli",
        "timestamp": 1569591880
    },
    {
        "content": "<p>Ok, I'll get to that at lunch time. I assume you'll be reviewing that Monday due to time zones?</p>",
        "id": 176747698,
        "sender_full_name": "Paul Faria",
        "timestamp": 1569592580
    },
    {
        "content": "<p>maybe XD sometimes I find time on weekends, too</p>",
        "id": 176747895,
        "sender_full_name": "oli",
        "timestamp": 1569592711
    },
    {
        "content": "<p>did you change anything in the root PR?</p>",
        "id": 176747912,
        "sender_full_name": "oli",
        "timestamp": 1569592726
    },
    {
        "content": "<p>IIRC that just needs the mir pass regenerating the cache and it's done keeping the status quo alive</p>",
        "id": 176747975,
        "sender_full_name": "oli",
        "timestamp": 1569592770
    },
    {
        "content": "<p>In the root PR I haven't updated anything. You're saying just add the pass and then continue on this next PR?</p>",
        "id": 176756521,
        "sender_full_name": "Paul Faria",
        "timestamp": 1569598108
    },
    {
        "content": "<p>yes</p>",
        "id": 176819595,
        "sender_full_name": "oli",
        "timestamp": 1569665128
    },
    {
        "content": "<p>Ok, I think I've addressed everything. I also added comments on the PR about a couple areas I think could be improved as well as one single place I'm not sure how to enforce the use of the terminator lookup since it's inside of a macro that takes in the mutability during the call.</p>",
        "id": 176830286,
        "sender_full_name": "Paul Faria",
        "timestamp": 1569684630
    },
    {
        "content": "<p>So I started looking at why the CI was failing. Some lint checks failed, so I got those through, but now I'm running into one area that looks like it's going to explode in complexity without interior mutability. So currently, there's a <code>predecessors_for</code> fn that called <code>unwrap_predecessors</code> (it's one that I had a TODO on about whether that was the correct <code>*predecessors</code> fn to call). <code>predecessors_for</code> is called by a trait impl <code>impl &lt;Body as graph::WithPredecessors&gt;::predecessors</code>. The first time this is called, the cache hasn't been computed, so the compiler panics. Changing this to use <code>predecessors</code> (which computes the cache) isn't possible because once we get to the <code>graph::WithPredecessors</code> trait, we're bound to use <code>&amp;self</code>. Assuming this even made sense (which I don't think it does), I could fix this instance by changing <code>WithPredecessors::predecessor</code> to take <code>&amp;mut self</code>, but that requires changing all other impls of that trait.</p>",
        "id": 176838668,
        "sender_full_name": "Paul Faria",
        "timestamp": 1569699698
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> whenever you're free, see the thread above</p>",
        "id": 176930693,
        "sender_full_name": "Paul Faria",
        "timestamp": 1569849504
    },
    {
        "content": "<p>yea :D the email notification about your PR is next on my list of things to process</p>",
        "id": 176930737,
        "sender_full_name": "oli",
        "timestamp": 1569849532
    },
    {
        "content": "<p>I'll look at it after work</p>",
        "id": 176930749,
        "sender_full_name": "oli",
        "timestamp": 1569849540
    },
    {
        "content": "<p>No rush, though the comment I have above is not mentioned in the PR. It's an overview of my review of the CI failures</p>",
        "id": 176930849,
        "sender_full_name": "Paul Faria",
        "timestamp": 1569849619
    },
    {
        "content": "<p>There's only a single impl of <code>WithPredecessors</code> (not counting tests), so yea, feel free to change the trait</p>",
        "id": 176954542,
        "sender_full_name": "oli",
        "timestamp": 1569865045
    },
    {
        "content": "<blockquote>\n<p>Assuming this even made sense (which I don't think it does),</p>\n</blockquote>",
        "id": 176954562,
        "sender_full_name": "oli",
        "timestamp": 1569865061
    },
    {
        "content": "<p>what do you mean by this?</p>",
        "id": 176954565,
        "sender_full_name": "oli",
        "timestamp": 1569865064
    },
    {
        "content": "<p>can you elaborate?</p>",
        "id": 176954570,
        "sender_full_name": "oli",
        "timestamp": 1569865067
    },
    {
        "content": "<p>Oh I didn't realize the other implementors were tests. I thought it was other parts of the compiler, and making all of them mut didn't make sense to me</p>",
        "id": 176966502,
        "sender_full_name": "Paul Faria",
        "timestamp": 1569872554
    },
    {
        "content": "<p>Sorry I missed that</p>",
        "id": 176966503,
        "sender_full_name": "Paul Faria",
        "timestamp": 1569872557
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span>  just got a chance to take a look again, and it's not just the tests. <code>librustc_data_structures/graph</code> also implements this trait, and trying to fix this is causing a trickling of errors that I have to keep fixing.</p>",
        "id": 176978783,
        "sender_full_name": "Paul Faria",
        "timestamp": 1569880894
    },
    {
        "content": "<p>hmm my grep foo must have failed me</p>",
        "id": 177027869,
        "sender_full_name": "oli",
        "timestamp": 1569912107
    },
    {
        "content": "<p>I thought the other uses were just generic forwardings</p>",
        "id": 177027871,
        "sender_full_name": "oli",
        "timestamp": 1569912114
    },
    {
        "content": "<p>maybe make the trait work on <code>self</code> instead of <code>&amp;self</code> or <code>&amp;mut self</code> and implement it for <code>&amp;Foo</code> and <code>&amp;mut Bar</code></p>",
        "id": 177027923,
        "sender_full_name": "oli",
        "timestamp": 1569912154
    },
    {
        "content": "<p>All this time and I never even knew you could do that... Ok I'll work on that this morning. Thanks!</p>",
        "id": 177047465,
        "sender_full_name": "Paul Faria",
        "timestamp": 1569930929
    },
    {
        "content": "<p>So I was confused for a bit until I took a step back and reviewed how all of the code is connected. Your suggestion won't work because I hadn't realized that the methods in <code>librustc_data_structures</code> are actually being called against <code>&amp; &amp;mut Body</code> (after my changes, previously, it was <code>&amp;&amp;Body</code> where <code>&amp;Body</code> was abstracted behind some generic type <code>G</code>), but they're being made to work against any type that implements <code>ControlFlowGraph</code>, which all expect some <code>&amp;T</code>. Implementing <code>WithPredecessors::predecessor(self, ...)</code> would require me to convert <code>&amp;&amp;Body</code> to <code>&amp;mut Body</code>.</p>",
        "id": 177054250,
        "sender_full_name": "Paul Faria",
        "timestamp": 1569936137
    },
    {
        "content": "<p><span aria-label=\"frown\" class=\"emoji emoji-1f641\" role=\"img\" title=\"frown\">:frown:</span></p>",
        "id": 177054840,
        "sender_full_name": "oli",
        "timestamp": 1569936578
    },
    {
        "content": "<p>I guess just refreshing the cache before calling the <code>WithPredecessors</code> thing isn't an option?</p>",
        "id": 177054976,
        "sender_full_name": "oli",
        "timestamp": 1569936647
    },
    {
        "content": "<p>e_O I hadn't thought of that... let me see how often that's called</p>",
        "id": 177055343,
        "sender_full_name": "Paul Faria",
        "timestamp": 1569936892
    },
    {
        "content": "<p>Ok, that helped to move past that panic. Running into other ones now. I'll see if I can't try the same approach</p>",
        "id": 177057383,
        "sender_full_name": "Paul Faria",
        "timestamp": 1569938309
    },
    {
        "content": "<p>Actually, what's a little confusing to me is that the next crash is in the codegen passes. Wouldn't the final pass I added inside of optimize passes have fixed that?</p>",
        "id": 177057466,
        "sender_full_name": "Paul Faria",
        "timestamp": 1569938375
    },
    {
        "content": "<p>it should have fixed that indeed, do you have a backtrace?</p>",
        "id": 177058364,
        "sender_full_name": "oli",
        "timestamp": 1569938936
    },
    {
        "content": "<p>Yep, let's see if it's not too long for zulip (one sec while I copy paste from the terminal)</p>",
        "id": 177060916,
        "sender_full_name": "Paul Faria",
        "timestamp": 1569940335
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>thread &#39;rustc&#39; panicked at &#39;assertion failed: self.predecessors_cache.is_some()&#39;, src/librustc/mir/mod.rs:239:9\nstack backtrace:\n   0: backtrace::backtrace::libunwind::trace\n             at /home/pfaria/.cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.37/src/backtrace/libunwind.rs:88\n   1: backtrace::backtrace::trace_unsynchronized\n             at /home/pfaria/.cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.37/src/backtrace/mod.rs:66\n   2: std::sys_common::backtrace::_print_fmt\n             at src/libstd/sys_common/backtrace.rs:76\n   3: &lt;std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display&gt;::fmt\n             at src/libstd/sys_common/backtrace.rs:60\n   4: core::fmt::write\n             at src/libcore/fmt/mod.rs:1030\n   5: std::io::Write::write_fmt\n             at src/libstd/io/mod.rs:1412\n   6: std::sys_common::backtrace::_print\n             at src/libstd/sys_common/backtrace.rs:64\n   7: std::sys_common::backtrace::print\n             at src/libstd/sys_common/backtrace.rs:49\n   8: std::panicking::default_hook::{{closure}}\n             at src/libstd/panicking.rs:196\n   9: std::panicking::default_hook\n             at src/libstd/panicking.rs:210\n  10: &lt;alloc::boxed::Box&lt;F&gt; as core::ops::function::Fn&lt;A&gt;&gt;::call\n             at ./src/liballoc/boxed.rs:936\n  11: rustc_driver::report_ice\n             at src/librustc_driver/lib.rs:1188\n  12: std::panicking::rust_panic_with_hook\n             at src/libstd/panicking.rs:477\n  13: std::panicking::begin_panic\n             at ./src/libstd/panicking.rs:407\n  14: rustc::mir::Body::unwrap_predecessors\n             at ./&lt;::std::macros::panic macros&gt;:3\n  15: rustc::mir::Body::predecessors_for\n             at ./src/librustc/mir/mod.rs:268\n  16: rustc_codegen_ssa::mir::codegen_mir\n             at ./src/librustc_codegen_ssa/mir/mod.rs:210\n  17: rustc_codegen_ssa::base::codegen_instance\n             at ./src/librustc_codegen_ssa/base.rs:386\n  18: &lt;rustc::mir::mono::MonoItem as rustc_codegen_ssa::mono_item::MonoItemExt&gt;::define\n             at ./src/librustc_codegen_ssa/mono_item.rs:40\n  19: rustc_codegen_llvm::base::compile_codegen_unit::module_codegen\n             at src/librustc_codegen_llvm/base.rs:143\n  20: rustc::dep_graph::graph::DepGraph::with_task_impl\n             at ./src/librustc/dep_graph/graph.rs:334\n  21: rustc::dep_graph::graph::DepGraph::with_task\n             at ./src/librustc/dep_graph/graph.rs:202\n  22: rustc_codegen_llvm::base::compile_codegen_unit\n             at src/librustc_codegen_llvm/base.rs:110\n  23: &lt;rustc_codegen_llvm::LlvmCodegenBackend as rustc_codegen_ssa::traits::backend::ExtraBackendMethods&gt;::compile_codegen_unit\n             at src/librustc_codegen_llvm/lib.rs:126\n  24: rustc_codegen_ssa::base::codegen_crate\n             at ./src/librustc_codegen_ssa/base.rs:617\n  25: &lt;rustc_codegen_llvm::LlvmCodegenBackend as rustc_codegen_utils::codegen_backend::CodegenBackend&gt;::codegen_crate\n             at src/librustc_codegen_llvm/lib.rs:289\n  26: rustc_interface::passes::start_codegen::{{closure}}\n             at src/librustc_interface/passes.rs:1092\n  27: rustc::util::common::time_ext\n             at ./src/librustc/util/common.rs:117\n  28: rustc::util::common::time\n             at ./src/librustc/util/common.rs:111\n  29: rustc_interface::passes::start_codegen\n             at src/librustc_interface/passes.rs:1091\n  30: rustc_interface::queries::&lt;impl rustc_interface::interface::Compiler&gt;::ongoing_codegen::{{closure}}::{{closure}}\n             at src/librustc_interface/queries.rs:243\n  31: rustc_interface::passes::BoxedGlobalCtxt::enter::{{closure}}::{{closure}}\n             at src/librustc_interface/passes.rs:813\n  32: rustc::ty::context::tls::enter_global::{{closure}}\n             at ./src/librustc/ty/context.rs:1883\n  33: rustc::ty::context::tls::enter_context::{{closure}}\n             at ./src/librustc/ty/context.rs:1851\n  34: rustc::ty::context::tls::set_tlv\n             at ./src/librustc/ty/context.rs:1784\n  35: rustc::ty::context::tls::enter_context\n             at ./src/librustc/ty/context.rs:1850\n  36: rustc::ty::context::tls::enter_global\n             at ./src/librustc/ty/context.rs:1882\n  37: rustc_interface::passes::BoxedGlobalCtxt::enter::{{closure}}\n             at src/librustc_interface/passes.rs:813\n  38: rustc_interface::passes::BoxedGlobalCtxt::access::{{closure}}\n             at ./&lt;::rustc_data_structures::box_region::declare_box_region_type macros&gt;:22\n  39: rustc_interface::passes::create_global_ctxt::{{closure}}\n             at src/librustc_interface/passes.rs:879\n  40: alloc::boxed::&lt;impl core::ops::generator::Generator for core::pin::Pin&lt;alloc::boxed::Box&lt;G&gt;&gt;&gt;::resume\n             at ./src/liballoc/boxed.rs:1073\n  41: rustc_data_structures::box_region::PinnedGenerator&lt;I,A,R&gt;::access\n             at ./src/librustc_data_structures/box_region.rs:52\n  42: rustc_interface::passes::BoxedGlobalCtxt::access\n             at ./&lt;::rustc_data_structures::box_region::declare_box_region_type macros&gt;:25\n  43: rustc_interface::passes::BoxedGlobalCtxt::enter\n             at src/librustc_interface/passes.rs:813\n  44: rustc_interface::queries::&lt;impl rustc_interface::interface::Compiler&gt;::ongoing_codegen::{{closure}}\n             at src/librustc_interface/queries.rs:237\n  45: rustc_interface::queries::Query&lt;T&gt;::compute\n             at src/librustc_interface/queries.rs:28\n  46: rustc_interface::queries::&lt;impl rustc_interface::interface::Compiler&gt;::ongoing_codegen\n             at src/librustc_interface/queries.rs:234\n  47: rustc_driver::run_compiler::{{closure}}\n             at src/librustc_driver/lib.rs:388\n  48: rustc_interface::interface::run_compiler_in_existing_thread_pool\n             at ./src/librustc_interface/interface.rs:122\n  49: rustc_interface::interface::run_compiler::{{closure}}\n             at ./src/librustc_interface/interface.rs:141\n  50: rustc_interface::util::spawn_thread_pool::{{closure}}::{{closure}}::{{closure}}::{{closure}}\n             at ./src/librustc_interface/util.rs:192\n  51: rustc::ty::context::tls::with_thread_locals::{{closure}}::{{closure}}\n             at ./src/librustc/ty/context.rs:1839\n  52: std::thread::local::LocalKey&lt;T&gt;::try_with\n             at ./src/libstd/thread/local.rs:262\n  53: std::thread::local::LocalKey&lt;T&gt;::with\n             at ./src/libstd/thread/local.rs:239\n  54: rustc::ty::context::tls::with_thread_locals::{{closure}}\n             at ./src/librustc/ty/context.rs:1831\n  55: std::thread::local::LocalKey&lt;T&gt;::try_with\n             at ./src/libstd/thread/local.rs:262\n  56: std::thread::local::LocalKey&lt;T&gt;::with\n             at ./src/libstd/thread/local.rs:239\n  57: rustc::ty::context::tls::with_thread_locals\n             at ./src/librustc/ty/context.rs:1823\n  58: rustc_interface::util::spawn_thread_pool::{{closure}}::{{closure}}::{{closure}}\n             at ./src/librustc_interface/util.rs:192\n  59: scoped_tls::ScopedKey&lt;T&gt;::set\n             at /home/pfaria/.cargo/registry/src/github.com-1ecc6299db9ec823/scoped-tls-1.0.0/src/lib.rs:137\n  60: rustc_interface::util::spawn_thread_pool::{{closure}}::{{closure}}\n             at ./src/librustc_interface/util.rs:188\n  61: scoped_tls::ScopedKey&lt;T&gt;::set\n             at /home/pfaria/.cargo/registry/src/github.com-1ecc6299db9ec823/scoped-tls-1.0.0/src/lib.rs:137\n  62: syntax::with_globals::{{closure}}\n             at ./src/libsyntax/lib.rs:109\n  63: scoped_tls::ScopedKey&lt;T&gt;::set\n             at /home/pfaria/.cargo/registry/src/github.com-1ecc6299db9ec823/scoped-tls-1.0.0/src/lib.rs:137\n  64: syntax::with_globals\n             at ./src/libsyntax/lib.rs:108\n  65: rustc_interface::util::spawn_thread_pool::{{closure}}\n             at ./src/librustc_interface/util.rs:187\n  66: rustc_interface::util::scoped_thread::{{closure}}\n             at ./src/librustc_interface/util.rs:164\nnote: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.\n</pre></div>",
        "id": 177060951,
        "sender_full_name": "Paul Faria",
        "timestamp": 1569940367
    },
    {
        "content": "<p>Oh. I think this is because the value comes from <code>instance_mir</code>, which may be an autogenerated MIR and not one that passed through <code>optimized_mir</code></p>",
        "id": 177062216,
        "sender_full_name": "oli",
        "timestamp": 1569941188
    },
    {
        "content": "<p>Is that one generated with passes in a similar manner? Where I should add the predecessors pass at the end of that one as well?</p>",
        "id": 177062961,
        "sender_full_name": "Paul Faria",
        "timestamp": 1569941648
    },
    {
        "content": "<p>Or is it generated differently?</p>",
        "id": 177062962,
        "sender_full_name": "Paul Faria",
        "timestamp": 1569941651
    },
    {
        "content": "<p>you should be able to add your pass to <a href=\"https://github.com/rust-lang/rust/blob/22bc9e1d9ca49ee4f5cd953088ab09c238a6dd26/src/librustc_mir/shim.rs#L115\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/22bc9e1d9ca49ee4f5cd953088ab09c238a6dd26/src/librustc_mir/shim.rs#L115\">https://github.com/rust-lang/rust/blob/22bc9e1d9ca49ee4f5cd953088ab09c238a6dd26/src/librustc_mir/shim.rs#L115</a></p>",
        "id": 177063404,
        "sender_full_name": "oli",
        "timestamp": 1569941934
    },
    {
        "content": "<p>That didn't seem to work. I tried adding a log to the pass, but I can't seem to get it to emit</p>",
        "id": 177064742,
        "sender_full_name": "Paul Faria",
        "timestamp": 1569942733
    },
    {
        "content": "<p>Is the env variable <code>RUST_LOG=librustc_mir=debug</code>? Or is it different when running in the compiler?</p>",
        "id": 177064772,
        "sender_full_name": "Paul Faria",
        "timestamp": 1569942755
    },
    {
        "content": "<p>I think you need <code>RUSTC_LOG</code></p>",
        "id": 177065320,
        "sender_full_name": "oli",
        "timestamp": 1569943105
    },
    {
        "content": "<p>It also helps if I ask for <code>librustc_mir</code> rather than <code>lubrustc_mir</code> <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 177065735,
        "sender_full_name": "Paul Faria",
        "timestamp": 1569943359
    },
    {
        "content": "<p>ha</p>",
        "id": 177065753,
        "sender_full_name": "oli",
        "timestamp": 1569943370
    },
    {
        "content": "<p><code>lobster_mir</code></p>",
        "id": 177065766,
        "sender_full_name": "oli",
        "timestamp": 1569943381
    },
    {
        "content": "<p>we should name our crates for rustaceans</p>",
        "id": 177065784,
        "sender_full_name": "oli",
        "timestamp": 1569943390
    },
    {
        "content": "<blockquote>\n<p><code>lobster_mir</code></p>\n</blockquote>\n<p>I'm going to register that into <a href=\"http://crates.io\" target=\"_blank\" title=\"http://crates.io\">crates.io</a> right now</p>",
        "id": 177066374,
        "sender_full_name": "Christian Poveda",
        "timestamp": 1569943775
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span>  I just got around to trying the changes out. Adding the pass in the shim didn't seem to make a difference. I added it at the end. Should it be done earlier? Also, here's a snippet of the logs I collected:</p>\n<div class=\"codehilite\"><pre><span></span>thread &#39;rustc&#39; panicked at &#39;Expected predecessors_cache to be `Some(...)` at: /home/pfaria/.cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.37/src/types.rs:19:5: 19:20&#39;, src/librustc/mir/mod.rs:241:9\nstack backtrace:\n   0: backtrace::backtrace::libunwind::trace\n             at ./src/backtrace/libunwind.rs:88\n   1: backtrace::backtrace::trace_unsynchronized\n             at ./src/backtrace/mod.rs:66\n   2: std::sys_common::backtrace::_print_fmt\n             at src/libstd/sys_common/backtrace.rs:76\n   3: &lt;std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display&gt;::fmt\n             at src/libstd/sys_common/backtrace.rs:60\n   4: core::fmt::write\n             at src/libcore/fmt/mod.rs:1030\n   5: std::io::Write::write_fmt\n             at src/libstd/io/mod.rs:1412\n   6: std::sys_common::backtrace::_print\n             at src/libstd/sys_common/backtrace.rs:64\n   7: std::sys_common::backtrace::print\n             at src/libstd/sys_common/backtrace.rs:49\n   8: std::panicking::default_hook::{{closure}}\n             at src/libstd/panicking.rs:196\n   9: std::panicking::default_hook\n             at src/libstd/panicking.rs:210\n  10: &lt;alloc::boxed::Box&lt;F&gt; as core::ops::function::Fn&lt;A&gt;&gt;::call\n             at /home/pfaria/projects/rust/src/liballoc/boxed.rs:936\n  11: rustc_driver::report_ice\n             at src/librustc_driver/lib.rs:1188\n  12: std::panicking::rust_panic_with_hook\n             at src/libstd/panicking.rs:477\n  13: std::panicking::continue_panic_fmt\n             at src/libstd/panicking.rs:380\n  14: std::panicking::begin_panic_fmt\n             at src/libstd/panicking.rs:335\n  15: rustc::mir::Body::unwrap_predecessors\n             at /home/pfaria/projects/rust/&lt;::std::macros::panic macros&gt;:9\n  16: rustc::mir::Body::predecessors_for\n             at /home/pfaria/projects/rust/src/librustc/mir/mod.rs:271\n  17: rustc_codegen_ssa::mir::codegen_mir\n             at /home/pfaria/projects/rust/src/librustc_codegen_ssa/mir/mod.rs:210\n  18: rustc_codegen_ssa::base::codegen_instance\n             at /home/pfaria/projects/rust/src/librustc_codegen_ssa/base.rs:386\n  19: &lt;rustc::mir::mono::MonoItem as rustc_codegen_ssa::mono_item::MonoItemExt&gt;::define\n             at /home/pfaria/projects/rust/src/librustc_codegen_ssa/mono_item.rs:40\n  20: rustc_codegen_llvm::base::compile_codegen_unit::module_codegen\n             at src/librustc_codegen_llvm/base.rs:143\n  21: rustc::dep_graph::graph::DepGraph::with_task_impl\n             at /home/pfaria/projects/rust/src/librustc/dep_graph/graph.rs:334\n  22: rustc::dep_graph::graph::DepGraph::with_task\n             at /home/pfaria/projects/rust/src/librustc/dep_graph/graph.rs:202\n  23: rustc_codegen_llvm::base::compile_codegen_unit\n             at src/librustc_codegen_llvm/base.rs:110\n  24: &lt;rustc_codegen_llvm::LlvmCodegenBackend as rustc_codegen_ssa::traits::backend::ExtraBackendMethods&gt;::compile_codegen_unit\n             at src/librustc_codegen_llvm/lib.rs:126\n  25: rustc_codegen_ssa::base::codegen_crate\n             at /home/pfaria/projects/rust/src/librustc_codegen_ssa/base.rs:617\n  26: &lt;rustc_codegen_llvm::LlvmCodegenBackend as rustc_codegen_utils::codegen_backend::CodegenBackend&gt;::codegen_crate\n             at src/librustc_codegen_llvm/lib.rs:289\n  27: rustc_interface::passes::start_codegen::{{closure}}\n             at src/librustc_interface/passes.rs:1092\n  28: rustc::util::common::time_ext\n             at /home/pfaria/projects/rust/src/librustc/util/common.rs:117\n  29: rustc::util::common::time\n             at /home/pfaria/projects/rust/src/librustc/util/common.rs:111\n  30: rustc_interface::passes::start_codegen\n             at src/librustc_interface/passes.rs:1091\n  31: rustc_interface::queries::&lt;impl rustc_interface::interface::Compiler&gt;::ongoing_codegen::{{closure}}::{{closure}}\n             at src/librustc_interface/queries.rs:243\n  32: rustc_interface::passes::BoxedGlobalCtxt::enter::{{closure}}::{{closure}}\n             at src/librustc_interface/passes.rs:813\n  33: rustc::ty::context::tls::enter_global::{{closure}}\n             at /home/pfaria/projects/rust/src/librustc/ty/context.rs:1883\n  34: rustc::ty::context::tls::enter_context::{{closure}}\n             at /home/pfaria/projects/rust/src/librustc/ty/context.rs:1851\n  35: rustc::ty::context::tls::set_tlv\n             at /home/pfaria/projects/rust/src/librustc/ty/context.rs:1784\n  36: rustc::ty::context::tls::enter_context\n             at /home/pfaria/projects/rust/src/librustc/ty/context.rs:1850\n  37: rustc::ty::context::tls::enter_global\n             at /home/pfaria/projects/rust/src/librustc/ty/context.rs:1882\n  38: rustc_interface::passes::BoxedGlobalCtxt::enter::{{closure}}\n             at src/librustc_interface/passes.rs:813\n  39: rustc_interface::passes::BoxedGlobalCtxt::access::{{closure}}\n             at /home/pfaria/projects/rust/&lt;::rustc_data_structures::box_region::declare_box_region_type macros&gt;:22\n  40: rustc_interface::passes::create_global_ctxt::{{closure}}\n             at src/librustc_interface/passes.rs:879\n  41: alloc::boxed::&lt;impl core::ops::generator::Generator for core::pin::Pin&lt;alloc::boxed::Box&lt;G&gt;&gt;&gt;::resume\n             at /home/pfaria/projects/rust/src/liballoc/boxed.rs:1073\n  42: rustc_data_structures::box_region::PinnedGenerator&lt;I,A,R&gt;::access\n             at /home/pfaria/projects/rust/src/librustc_data_structures/box_region.rs:52\n  43: rustc_interface::passes::BoxedGlobalCtxt::access\n             at /home/pfaria/projects/rust/&lt;::rustc_data_structures::box_region::declare_box_region_type macros&gt;:25\n  44: rustc_interface::passes::BoxedGlobalCtxt::enter\n             at src/librustc_interface/passes.rs:813\n  45: rustc_interface::queries::&lt;impl rustc_interface::interface::Compiler&gt;::ongoing_codegen::{{closure}}\n             at src/librustc_interface/queries.rs:237\n  46: rustc_interface::queries::Query&lt;T&gt;::compute\n             at src/librustc_interface/queries.rs:28\n  47: rustc_interface::queries::&lt;impl rustc_interface::interface::Compiler&gt;::ongoing_codegen\n             at src/librustc_interface/queries.rs:234\n  48: rustc_driver::run_compiler::{{closure}}\n             at src/librustc_driver/lib.rs:388\n  49: rustc_interface::interface::run_compiler_in_existing_thread_pool\n             at /home/pfaria/projects/rust/src/librustc_interface/interface.rs:122\n  50: rustc_interface::interface::run_compiler::{{closure}}\n             at /home/pfaria/projects/rust/src/librustc_interface/interface.rs:141\n  51: rustc_interface::util::spawn_thread_pool::{{closure}}::{{closure}}::{{closure}}::{{closure}}\n             at /home/pfaria/projects/rust/src/librustc_interface/util.rs:192\n  52: rustc::ty::context::tls::with_thread_locals::{{closure}}::{{closure}}\n             at /home/pfaria/projects/rust/src/librustc/ty/context.rs:1839\n  53: std::thread::local::LocalKey&lt;T&gt;::try_with\n             at /home/pfaria/projects/rust/src/libstd/thread/local.rs:262\n  54: std::thread::local::LocalKey&lt;T&gt;::with\n             at /home/pfaria/projects/rust/src/libstd/thread/local.rs:239\n  55: rustc::ty::context::tls::with_thread_locals::{{closure}}\n             at /home/pfaria/projects/rust/src/librustc/ty/context.rs:1831\n  56: std::thread::local::LocalKey&lt;T&gt;::try_with\n             at /home/pfaria/projects/rust/src/libstd/thread/local.rs:262\n  57: std::thread::local::LocalKey&lt;T&gt;::with\n             at /home/pfaria/projects/rust/src/libstd/thread/local.rs:239\n  58: rustc::ty::context::tls::with_thread_locals\n             at /home/pfaria/projects/rust/src/librustc/ty/context.rs:1823\n  59: rustc_interface::util::spawn_thread_pool::{{closure}}::{{closure}}::{{closure}}\n             at /home/pfaria/projects/rust/src/librustc_interface/util.rs:192\n  60: scoped_tls::ScopedKey&lt;T&gt;::set\n             at /home/pfaria/.cargo/registry/src/github.com-1ecc6299db9ec823/scoped-tls-1.0.0/src/lib.rs:137\n  61: rustc_interface::util::spawn_thread_pool::{{closure}}::{{closure}}\n             at /home/pfaria/projects/rust/src/librustc_interface/util.rs:188\n  62: scoped_tls::ScopedKey&lt;T&gt;::set\n             at /home/pfaria/.cargo/registry/src/github.com-1ecc6299db9ec823/scoped-tls-1.0.0/src/lib.rs:137\n  63: syntax::with_globals::{{closure}}\n             at /home/pfaria/projects/rust/src/libsyntax/lib.rs:109\n  64: scoped_tls::ScopedKey&lt;T&gt;::set\n             at /home/pfaria/.cargo/registry/src/github.com-1ecc6299db9ec823/scoped-tls-1.0.0/src/lib.rs:137\n  65: syntax::with_globals\n             at /home/pfaria/projects/rust/src/libsyntax/lib.rs:108\n  66: rustc_interface::util::spawn_thread_pool::{{closure}}\n             at /home/pfaria/projects/rust/src/librustc_interface/util.rs:187\n  67: rustc_interface::util::scoped_thread::{{closure}}\n             at /home/pfaria/projects/rust/src/librustc_interface/util.rs:164\nnote: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.\n</pre></div>",
        "id": 177117341,
        "sender_full_name": "Paul Faria",
        "timestamp": 1569984901
    },
    {
        "content": "<p>And the logs I had from before that:</p>\n<div class=\"codehilite\"><pre><span></span>[DEBUG rustc::mir] PAUL: Recomputing predecessors: /home/pfaria/.cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.37/src/types.rs:16:10: 16:15\n[DEBUG rustc::mir] PAUL: Invalidating through opt terminator: /home/pfaria/.cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.37/src/types.rs:16:10: 16:15\n[DEBUG rustc::mir] PAUL: Invalidating through opt terminator: /home/pfaria/.cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.37/src/types.rs:16:10: 16:15\n[DEBUG rustc::mir] PAUL: Invalidating through opt terminator: /home/pfaria/.cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.37/src/types.rs:16:10: 16:15\n[DEBUG rustc::mir] PAUL: Invalidating through opt terminator: /home/pfaria/.cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.37/src/types.rs:16:10: 16:15\n[DEBUG rustc::mir] PAUL: Invalidating through opt terminator: /home/pfaria/.cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.37/src/types.rs:16:10: 16:15\n[DEBUG rustc::mir] PAUL: Invalidating through opt terminator: /home/pfaria/.cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.37/src/types.rs:16:10: 16:15\n[DEBUG rustc::mir] PAUL: Invalidating through opt terminator: /home/pfaria/.cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.37/src/types.rs:16:10: 16:15\n[DEBUG rustc::mir] PAUL: Invalidating through opt terminator: /home/pfaria/.cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.37/src/types.rs:16:10: 16:15\n[DEBUG rustc::mir] PAUL: Invalidating through opt terminator: /home/pfaria/.cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.37/src/types.rs:16:10: 16:15\n[DEBUG rustc::mir] PAUL: Invalidating through opt terminator: /home/pfaria/.cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.37/src/types.rs:16:10: 16:15\n[DEBUG rustc::mir] PAUL: Invalidating through opt terminator: /home/pfaria/.cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.37/src/types.rs:16:10: 16:15\n[DEBUG rustc_mir::transform::ensure_predecessors_cache] before-opt-dump: Ensure predecessors cache: /home/pfaria/.cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.37/src/types.rs:16:10: 16:15\n[DEBUG rustc::mir] PAUL: Recomputing predecessors: /home/pfaria/.cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.37/src/types.rs:16:10: 16:15\n...\n</pre></div>",
        "id": 177117349,
        "sender_full_name": "Paul Faria",
        "timestamp": 1569984924
    },
    {
        "content": "<p>So it seems to be processing the <code>backtrace</code> crate (I doubt this is important), but the crash occurs when looking at the body for <code>types.rs:19:5: 19:20</code>, which is never logged at any point previously during compilation (so no cache computing, not invalidation attempts)</p>",
        "id": 177117424,
        "sender_full_name": "Paul Faria",
        "timestamp": 1569985013
    },
    {
        "content": "<p>I have the full trace as well, if that would help, but it's ~27,000 lines  long and includes a lot of extra logs. I couldn't figure out how to filter to only log at the <code>rustc::mir</code> level and nothing below that</p>",
        "id": 177118033,
        "sender_full_name": "Paul Faria",
        "timestamp": 1569985924
    },
    {
        "content": "<p>maybe there's another way <code>instance_mir</code> can generate MIR that I haven't seen? Try following all the function calls in <code>instance_mir</code> and below</p>",
        "id": 177124516,
        "sender_full_name": "oli",
        "timestamp": 1569997043
    },
    {
        "content": "<p>Oooh, Looks like there might be a special case for tuple struct constructors. Compiling an attempt now</p>",
        "id": 177146424,
        "sender_full_name": "Paul Faria",
        "timestamp": 1570020886
    },
    {
        "content": "<p>Ok, got past that panic, on to the next few. I'll review the next ones after work. Thanks again!</p>",
        "id": 177148253,
        "sender_full_name": "Paul Faria",
        "timestamp": 1570022182
    },
    {
        "content": "<p>:D whack-a-panic</p>",
        "id": 177148713,
        "sender_full_name": "oli",
        "timestamp": 1570022475
    },
    {
        "content": "<p>@oli: It can finally compile the compiler :). In my analysis I realized the terminator_mut method idea I had gets called a LOT, so I'd like to do a comparison between that and the previous one (I think I might have messed up your earlier instructions about splitting up the PR, this PR include a different cache invalidation strategy). The latest commit is as small as I thought I could make it</p>",
        "id": 177212731,
        "sender_full_name": "Paul Faria",
        "timestamp": 1570074675
    },
    {
        "content": "<p>I addressed a lot of the issues in the draft PR. I'm rolling back the changes that made terminator invalidate, but I'm seeing that the cache is invalidated more frequently now, so there are additional panics I'm working through. Going to follow up tomorrow morning</p>",
        "id": 177310142,
        "sender_full_name": "Paul Faria",
        "timestamp": 1570164032
    },
    {
        "content": "<p>Nice</p>",
        "id": 177333880,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1570192441
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> I addressed the additional comments you had. For some reason I cannot comment on or resolve the comment you left on <code>src/librustc_mir/transform/add_call_guards.rs Outdated</code>.  I think for this first pass the only remaining item to address is how to manage the serialization of that field (it's the comment midway through the PR from last week).</p>",
        "id": 177340095,
        "sender_full_name": "Paul Faria",
        "timestamp": 1570196865
    },
    {
        "content": "<p>Also, would it make sense to move it out of draft at this point?</p>",
        "id": 177340592,
        "sender_full_name": "Paul Faria",
        "timestamp": 1570197156
    },
    {
        "content": "<p>I added the cache class back so we can ensure there's no encoding/decoding of the cache going on. This broke a few more things. However, now that the compiler is passing, a bunch of tests are panicking. I'll try to address those as well. It does feel a bit scary though that I can't easily predict where the next panic will come from.</p>",
        "id": 177563310,
        "sender_full_name": "Paul Faria",
        "timestamp": 1570484185
    },
    {
        "content": "<p>that's super odd. I thought all the uses of the cache were in the same crate and not cross crate</p>",
        "id": 177598307,
        "sender_full_name": "oli",
        "timestamp": 1570528173
    },
    {
        "content": "<p>It was breaking on things like <code>num::wrapping_add</code> and <code>array... Something</code>. They were both generated by macro calls I think. I'll follow up when I get back to my computer</p>",
        "id": 177602337,
        "sender_full_name": "Paul Faria",
        "timestamp": 1570532114
    },
    {
        "content": "<p>Not sure why I put macros there. I shouldn't message immediately after waking up... It was getting the result from <code>instance_mir</code>, and there from <code>optimized_mir</code>. But I wasn't sure which impl it was calling because there are two in the compiler.. The weirdest part was that neither impl would log in the case of the panic, but they would in other instances.</p>",
        "id": 177608684,
        "sender_full_name": "Paul Faria",
        "timestamp": 1570538190
    },
    {
        "content": "<p>I might have also been jumping to conclusions about the encoding/decoding part. That was just the one part that would make sense given the only change at the time was the move back to the cache with the encoding/decoding changes.</p>",
        "id": 177609130,
        "sender_full_name": "Paul Faria",
        "timestamp": 1570538508
    },
    {
        "content": "<p>Also, inside of <code>instance_mir</code>, which <code>optimized_mir</code> is getting called? Is it <a href=\"https://github.com/rust-lang/rust/blob/e3cb9ea15a2082f39d4d4f10a22e779701dd0d64/src/librustc_metadata/cstore_impl.rs#L129\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/e3cb9ea15a2082f39d4d4f10a22e779701dd0d64/src/librustc_metadata/cstore_impl.rs#L129\">https://github.com/rust-lang/rust/blob/e3cb9ea15a2082f39d4d4f10a22e779701dd0d64/src/librustc_metadata/cstore_impl.rs#L129</a> or <a href=\"https://github.com/rust-lang/rust/blob/22bc9e1d9ca49ee4f5cd953088ab09c238a6dd26/src/librustc_mir/transform/mod.rs#L282\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/22bc9e1d9ca49ee4f5cd953088ab09c238a6dd26/src/librustc_mir/transform/mod.rs#L282\">https://github.com/rust-lang/rust/blob/22bc9e1d9ca49ee4f5cd953088ab09c238a6dd26/src/librustc_mir/transform/mod.rs#L282</a> ?</p>",
        "id": 177609579,
        "sender_full_name": "Paul Faria",
        "timestamp": 1570538824
    },
    {
        "content": "<p>the latter, but the latter may call the former</p>",
        "id": 177609681,
        "sender_full_name": "oli",
        "timestamp": 1570538890
    },
    {
        "content": "<p>I had logs at the beginning of both of those calls, as well as surrounding the call in <code>instance_mir</code>. Specifically in the case of the panic, the logs in the <code>optimized_mir</code> fns wouldn't be output, but the surrounding ones in <code>instance_mir</code> would... which I couldn't wrap my head around</p>",
        "id": 177609683,
        "sender_full_name": "Paul Faria",
        "timestamp": 1570538894
    },
    {
        "content": "<p>well</p>",
        "id": 177609695,
        "sender_full_name": "oli",
        "timestamp": 1570538907
    },
    {
        "content": "<p>not quite</p>",
        "id": 177609696,
        "sender_full_name": "oli",
        "timestamp": 1570538909
    },
    {
        "content": "<p>sorry</p>",
        "id": 177609698,
        "sender_full_name": "oli",
        "timestamp": 1570538911
    },
    {
        "content": "<p>I could find instances of the calls throughout the rest of the log, but not in that specific instance</p>",
        "id": 177609701,
        "sender_full_name": "Paul Faria",
        "timestamp": 1570538912
    },
    {
        "content": "<p>so</p>",
        "id": 177609704,
        "sender_full_name": "oli",
        "timestamp": 1570538913
    },
    {
        "content": "<p>this is a query</p>",
        "id": 177609707,
        "sender_full_name": "oli",
        "timestamp": 1570538914
    },
    {
        "content": "<p>Oh, is it memoized?</p>",
        "id": 177609725,
        "sender_full_name": "Paul Faria",
        "timestamp": 1570538928
    },
    {
        "content": "<p>Oh... I just found <a href=\"https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src/librustc/query/mod.rs#L123\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src/librustc/query/mod.rs#L123\">https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src/librustc/query/mod.rs#L123</a></p>",
        "id": 177610053,
        "sender_full_name": "Paul Faria",
        "timestamp": 1570539178
    },
    {
        "content": "<p>That's only part of it</p>",
        "id": 177610093,
        "sender_full_name": "oli",
        "timestamp": 1570539204
    },
    {
        "content": "<p>I can't find the place where the swtich on <code>def_id.is_local()</code> happens and decides on whether a query is run or fetched from the store</p>",
        "id": 177610125,
        "sender_full_name": "oli",
        "timestamp": 1570539234
    },
    {
        "content": "<p>memoization is just a part of it</p>",
        "id": 177610130,
        "sender_full_name": "oli",
        "timestamp": 1570539241
    },
    {
        "content": "<p>if you query something from another crate, its value is loaded from metadata</p>",
        "id": 177610187,
        "sender_full_name": "oli",
        "timestamp": 1570539255
    },
    {
        "content": "<p>Is that not <a href=\"https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src/librustc/query/mod.rs#L124\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src/librustc/query/mod.rs#L124\">https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src/librustc/query/mod.rs#L124</a> ?</p>",
        "id": 177610554,
        "sender_full_name": "Paul Faria",
        "timestamp": 1570539470
    },
    {
        "content": "<p>That decides to cache it, but I'm wondering what code decides where to load it from</p>",
        "id": 177610975,
        "sender_full_name": "oli",
        "timestamp": 1570539714
    },
    {
        "content": "<p>Following the proc macros I came to this: <a href=\"https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src/librustc_macros/src/query.rs#L331-L353\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src/librustc_macros/src/query.rs#L331-L353\">https://github.com/rust-lang/rust/blob/9e35a2811d8c65e9473176b8656a3201b7e152c7/src/librustc_macros/src/query.rs#L331-L353</a></p>",
        "id": 177611107,
        "sender_full_name": "Paul Faria",
        "timestamp": 1570539792
    },
    {
        "content": "<p>But having a hard to trying to map all of that in my head between the various invocations (coffee hasn't kicked in yet)</p>",
        "id": 177611135,
        "sender_full_name": "Paul Faria",
        "timestamp": 1570539814
    },
    {
        "content": "<p>I'm not going to have time this morning either. Need to rush to an appointment.</p>",
        "id": 177611153,
        "sender_full_name": "Paul Faria",
        "timestamp": 1570539828
    },
    {
        "content": "<p>Now that I know there was a third fn to look at though, I know I can follow up on this tonight and it will make my head hurt less :)</p>",
        "id": 177611221,
        "sender_full_name": "Paul Faria",
        "timestamp": 1570539862
    },
    {
        "content": "<p>heh</p>",
        "id": 177611477,
        "sender_full_name": "oli",
        "timestamp": 1570540048
    },
    {
        "content": "<p>I wouldn't worry about it too much, the query system can be used without understanding</p>",
        "id": 177611506,
        "sender_full_name": "oli",
        "timestamp": 1570540074
    },
    {
        "content": "<p>I understood it mostly half a year ago, but it got refactored a lot</p>",
        "id": 177611555,
        "sender_full_name": "oli",
        "timestamp": 1570540088
    },
    {
        "content": "<p>since I'm not doing anything in it I don't expect to get back to understanding any time soon</p>",
        "id": 177611582,
        "sender_full_name": "oli",
        "timestamp": 1570540113
    },
    {
        "content": "<p>Crazy thought on the way to my appointment: what if instead of storing the cache in <code>Body</code>, it was passed with it? Or if there was another struct that contained both <code>Body</code> and <code>Cache</code>?</p>",
        "id": 177617595,
        "sender_full_name": "Paul Faria",
        "timestamp": 1570543444
    },
    {
        "content": "<p>We could keep the cache mut while the body stays sharable, and that means it could recompute just like before</p>",
        "id": 177617830,
        "sender_full_name": "Paul Faria",
        "timestamp": 1570543560
    },
    {
        "content": "<p>well, you can always create an <code>eval_always</code> query that calls <code>optimized_mir</code> and computes the cache</p>",
        "id": 177618861,
        "sender_full_name": "oli",
        "timestamp": 1570544044
    },
    {
        "content": "<p>but that won't work inside the mir pass pipeline</p>",
        "id": 177618871,
        "sender_full_name": "oli",
        "timestamp": 1570544054
    },
    {
        "content": "<p>and it would then be rather hard to enforce clearing of the cache in the pipeline</p>",
        "id": 177618905,
        "sender_full_name": "oli",
        "timestamp": 1570544071
    },
    {
        "content": "<p>maybe it would be ok to just always eagerly compute it in the pipeline?</p>",
        "id": 177618928,
        "sender_full_name": "oli",
        "timestamp": 1570544087
    },
    {
        "content": "<p>is it ever actually used from a cached version?</p>",
        "id": 177618947,
        "sender_full_name": "oli",
        "timestamp": 1570544099
    },
    {
        "content": "<p>It did panic when it wasn't available for <code>num::wrapping_add</code></p>",
        "id": 177623046,
        "sender_full_name": "Paul Faria",
        "timestamp": 1570546077
    },
    {
        "content": "<p>during compilation of libcore?</p>",
        "id": 177624894,
        "sender_full_name": "oli",
        "timestamp": 1570547132
    },
    {
        "content": "<p>I'm actually not sure during which crate. I'll have to recreate the scenario</p>",
        "id": 177671593,
        "sender_full_name": "Paul Faria",
        "timestamp": 1570580264
    },
    {
        "content": "<p>Looks like the panics came from compiling <code>compiler_builtins</code>:</p>\n<div class=\"codehilite\"><pre><span></span>1947420:[INFO  rustc::ty] PAUL: Getting Item(DefId(2:13848 ~ core[9364]::num[0]::{{impl}}[8]::wrapping_add[0])) for &quot;compiler_builtins&quot;\n1947421:thread &#39;rustc&#39; panicked at &#39;Expected cache.predecessors to be `Some(...)` for block at: /home/pfaria/projects/rust/src/libcore/num/mod.rs:1117:13: 1119:14&#39;, src/librustc/mir/mod.rs:230:9\n1947422-stack backtrace:\n1947423-   0: backtrace::backtrace::libunwind::trace\n</pre></div>",
        "id": 177675759,
        "sender_full_name": "Paul Faria",
        "timestamp": 1570586328
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span>  so I've been playing with that idea of inverting the relationship: <code>OwnedCache { cache: Cache, body: Body }</code>, and it seems to work pretty well so far (I haven't gotten it completely compiling yet, I'll see if I can wrap that up tonight at the lower levels to make sure the borrowing is agreeable with the compiler). I moved the predecessor methods there as well as the methods on <code>Body</code> that invalidate the cache.</p>",
        "id": 177710938,
        "sender_full_name": "Paul Faria",
        "timestamp": 1570626108
    },
    {
        "content": "<p>So I actually got a good amount compiling at this point. <code>librustc</code> and <code>librustc_data_structures</code> are both compiling, but right now I'm looking at 75 errors from old fn's I removed plus the new changes that need to be accounted for. Could you review the progress I made so far and let me know if anything stands out as <code>this clearly won't work</code>? I also wasn't sure if those wrapper types helped at all, but it did make writing the visitor macro significantly easier. It also helps ensure that <code>Body</code> can't be mutated when <code>BorrowedCache</code> is being passed around, but that the cache can still be populated if needed (removing the need for us to sprinkle <code>ensure_predecessors</code> everywhere.</p>",
        "id": 177776026,
        "sender_full_name": "Paul Faria",
        "timestamp": 1570678004
    },
    {
        "content": "<p>Also, regarding the <code>WithPredecessors::predecessors(&amp;mut self)</code> trait fn, I couldn't find a way to write it with <code>self</code>. There were lots of issues with it wanting to consume the <code>&amp;mut</code> and only being satisfied if the <code>T</code> of <code>&amp;mut T</code> was also <code>Copy</code>, which isn't possible since <code>&amp;mut</code> types can't be <code>Copy</code>.</p>",
        "id": 177776090,
        "sender_full_name": "Paul Faria",
        "timestamp": 1570678133
    },
    {
        "content": "<p>Cleaned up the passthrough nightmare. I finally figured out the lifetime issues. librustc_codegen_ssa should be good at this point. Going to try tackling librustc_mir during the week. Given that I have 181 errors in that crate, I'm expecting it to take a while to get through all of them.</p>",
        "id": 178075398,
        "sender_full_name": "Paul Faria",
        "timestamp": 1571032216
    },
    {
        "content": "<p>Got really busy with personal stuff this week. Rebased recently and I need to redo codegen_ssa again <span aria-label=\"sob\" class=\"emoji emoji-1f62d\" role=\"img\" title=\"sob\">:sob:</span>. Someone built a helper that checks predecessors and now I need to get <code>&amp;mut BodyCache&lt;...&gt;</code> through all the modules. Might have time to look at that later tonight or tomorrow afternoon for a few hours.</p>",
        "id": 178559166,
        "sender_full_name": "Paul Faria",
        "timestamp": 1571512324
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span>  I've been working through the idea you posted a few days ago on the PR.</p>",
        "id": 178818256,
        "sender_full_name": "Paul Faria",
        "timestamp": 1571798810
    },
    {
        "content": "<p>I had to ensure the <code>BodyCache</code> returned a new type <code>ReadOnlyBodyCache</code> that ensures the cache is computed before it can be created. This is necessary to fulfill the usage within dominators, which requires the <code>Cache</code> and the <code>Body</code> (and it's not possible to implement the traits against tuples). The issue I'm running into is that to create <code>ReadOnlyBodyCache</code>, I need an fn like:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">fn</span> <span class=\"nf\">read_only</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"na\">&#39;b</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">ReadOnlyBodyCache</span><span class=\"o\">&lt;</span><span class=\"na\">&#39;b</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"na\">&#39;tcx</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">ensure_predecessors</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">ReadOnlyBodyCache</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">cache</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">self</span><span class=\"p\">.</span><span class=\"n\">cache</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">body</span>: <span class=\"nc\">self</span><span class=\"p\">.</span><span class=\"n\">body</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>However, this restricts <code>self</code> from being borrowed immutably elsewhere because the mutable borrow is held. How would I work around this? Would it be alright to make <code>ensure_predecessors</code> public, and generating <code>ReadOnlyBodyCache</code> will just panic if the cache isn't computed?</p>",
        "id": 178818402,
        "sender_full_name": "Paul Faria",
        "timestamp": 1571799088
    },
    {
        "content": "<p>Would it make sense to wrap something like that in a macro to make the <code>ensure_predecessors</code> call pseudo-private?</p>",
        "id": 178818479,
        "sender_full_name": "Paul Faria",
        "timestamp": 1571799240
    },
    {
        "content": "<p>you could make it a method that takes <code>self</code> by value. To go back to a mutable version you can create a second method to convert back</p>",
        "id": 178849118,
        "sender_full_name": "oli",
        "timestamp": 1571834439
    },
    {
        "content": "<p>Oh I hadn't thought about converting back. That should work. Thanks!</p>",
        "id": 178856366,
        "sender_full_name": "Paul Faria",
        "timestamp": 1571839347
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span>  when you get a chance, I've fixed all the type errors up to <code>librustc_mir/transform</code>. What's the best place for me to get started on allowing the <code>MirPass</code>es to pass along the caches? I'm also wondering what to do about the fact that some will need to take <code>&amp;mut BodyCache&lt;&amp;'a mut Body&lt;'tcx&gt;&gt;</code>, and some will need <code>ReadOnlyBodyCache&lt;'a, 'tcx&gt;</code>.</p>",
        "id": 179052142,
        "sender_full_name": "Paul Faria",
        "timestamp": 1572012259
    },
    {
        "content": "<p>That last bit is regarding the <code>run_pass</code> fn</p>",
        "id": 179052175,
        "sender_full_name": "Paul Faria",
        "timestamp": 1572012298
    },
    {
        "content": "<p>Hmmm maybe passing around a <code>&amp;mut BodyCache&lt;Body&lt;'tcx&gt;&gt;</code>?</p>",
        "id": 179052201,
        "sender_full_name": "Paul Faria",
        "timestamp": 1572012316
    },
    {
        "content": "<p>And then converting that to the other types as needed?</p>",
        "id": 179052214,
        "sender_full_name": "Paul Faria",
        "timestamp": 1572012331
    },
    {
        "content": "<p>can't all <code>MirPass</code>es take <code>&amp;mut BodyCache</code>?</p>",
        "id": 179053830,
        "sender_full_name": "oli",
        "timestamp": 1572013438
    },
    {
        "content": "<p>They could, but then I'm not sure whether to pass around <code>&amp;mut BodyCache&lt;Body&lt;'tcx&gt;&gt;</code> or <code>&amp;mut BodyCache&lt;&amp;'a mut Body&lt;'tcx&gt;&gt;</code></p>",
        "id": 179054678,
        "sender_full_name": "Paul Faria",
        "timestamp": 1572014043
    },
    {
        "content": "<p>I assume the latter will give me issues with returning <code>&amp;'a Body&lt;'tcx&gt;</code>, right?</p>",
        "id": 179054717,
        "sender_full_name": "Paul Faria",
        "timestamp": 1572014079
    },
    {
        "content": "<p>all <code>MirPass</code>es will require <code>&amp;mut BodyCache&lt;&amp;mut Body&gt;</code>, so you'll always need the latter</p>",
        "id": 179055019,
        "sender_full_name": "oli",
        "timestamp": 1572014274
    },
    {
        "content": "<p>the passes may not use the mutability</p>",
        "id": 179055026,
        "sender_full_name": "oli",
        "timestamp": 1572014282
    },
    {
        "content": "<p>but that's not a problem</p>",
        "id": 179055067,
        "sender_full_name": "oli",
        "timestamp": 1572014286
    },
    {
        "content": "<p>Hm, I may need to fix some things then in the visitors. In order to get the lifetimes in agreement I did what you had recommended re: <code>fn read_only(self) -&gt; ReadOnlyBodyCache&lt;...&gt;</code>, but that's not possible with <code>&amp;mut BodyCache&lt;...&gt;</code> since I can't move out of the reference. The non-mut visitors were updated to only work with <code>ReadOnlyBodyCache</code>.</p>",
        "id": 179056069,
        "sender_full_name": "Paul Faria",
        "timestamp": 1572014918
    },
    {
        "content": "<p>I'll review later tonight after work</p>",
        "id": 179056151,
        "sender_full_name": "Paul Faria",
        "timestamp": 1572014990
    },
    {
        "content": "<p>btw, I'm going on vacation tomorrow, I won't be online again until the 4th of November</p>",
        "id": 179056982,
        "sender_full_name": "oli",
        "timestamp": 1572015550
    },
    {
        "content": "<p>Enjoy! We'll have a small overlap then since I'll be on vacation from the 7-10th of November.</p>",
        "id": 179057174,
        "sender_full_name": "Paul Faria",
        "timestamp": 1572015664
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> Enjoy! I will update you with the latest changes in intrinsic promotion topic when you come back!</p>",
        "id": 179062716,
        "sender_full_name": "vertexclique",
        "timestamp": 1572018738
    },
    {
        "content": "<p>thx!</p>",
        "id": 179062853,
        "sender_full_name": "oli",
        "timestamp": 1572018835
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> welcome back! I hope it was a wonderful vacation. In your absence I got <a href=\"https://github.com/rust-lang/rust/pull/64736\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/pull/64736\">https://github.com/rust-lang/rust/pull/64736</a> fully compiling, passing tests, and reasonably cleaned up. I was wondering if you think the variable renames all over the place were overkill (I can undo them if it makes the code easier to read). I also left a comment on one area I really dislike, but not sure how to clean up. Either way I think this version makes me much more comfortable than the one that relied on unwraps/asserts more often.</p>",
        "id": 179892879,
        "sender_full_name": "Paul Faria",
        "timestamp": 1572915420
    },
    {
        "content": "<p>slowly catching up :D</p>",
        "id": 179912830,
        "sender_full_name": "oli",
        "timestamp": 1572944678
    },
    {
        "content": "<p>I have 400 new messages from github and around 20 pings on zulip</p>",
        "id": 179912844,
        "sender_full_name": "oli",
        "timestamp": 1572944697
    },
    {
        "content": "<p>e_O</p>",
        "id": 179930221,
        "sender_full_name": "Paul Faria",
        "timestamp": 1572959789
    },
    {
        "content": "<p>No rush. I'll help out in the rustc guide for the time being</p>",
        "id": 179930289,
        "sender_full_name": "Paul Faria",
        "timestamp": 1572959841
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> anything else I should look at in my PR? Also, did you ever see my comments in the PR about the <code>mir_built</code> query?</p>",
        "id": 180139093,
        "sender_full_name": "Paul Faria",
        "timestamp": 1573138322
    },
    {
        "content": "<p>Wanted to see if I could take care of anything before I head out before vacation. I still have a few hours today</p>",
        "id": 180139148,
        "sender_full_name": "Paul Faria",
        "timestamp": 1573138340
    },
    {
        "content": "<p>I responded on the PR</p>",
        "id": 180220548,
        "sender_full_name": "oli",
        "timestamp": 1573211730
    },
    {
        "content": "<p>I'm not quite sure why you need the readonly thing. Couldn't <code>&amp;CachedBody</code> work similarly?</p>",
        "id": 180220610,
        "sender_full_name": "oli",
        "timestamp": 1573211767
    },
    {
        "content": "<p>The difference is that <code>ReadOnlyBodyCache</code> is guaranteed to have a computed cache, while <code>&amp;BodyCache</code> is not</p>",
        "id": 180424355,
        "sender_full_name": "Paul Faria",
        "timestamp": 1573479957
    },
    {
        "content": "<p>Back from vacation. I'll try reviewing this morning, but might not get back to it until late tonight/early tomorrow</p>",
        "id": 180424436,
        "sender_full_name": "Paul Faria",
        "timestamp": 1573479998
    },
    {
        "content": "<p>hmm... right, so this is helping in not forgetting to pre-generate the cache?</p>",
        "id": 180429896,
        "sender_full_name": "oli",
        "timestamp": 1573484289
    },
    {
        "content": "<p>Yes, exactly. I initially thought it was overkill, but it made the cleanup work much easier once I got into it.</p>",
        "id": 180446167,
        "sender_full_name": "Paul Faria",
        "timestamp": 1573496035
    },
    {
        "content": "<p>ok seems fine then. I still think we can do without cloning though <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 180446539,
        "sender_full_name": "oli",
        "timestamp": 1573496274
    },
    {
        "content": "<p>You're referring to the clone in <code>unsafety_check_result</code>? So I can fix that by ensuring the cache is computed at the end of <code>mir_built</code>, but this will mean that cache is invalidated once it's stolen in <code>mir_const</code> ( <a href=\"https://github.com/rust-lang/rust/blob/master/src/librustc_mir/transform/mod.rs#L188\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/master/src/librustc_mir/transform/mod.rs#L188\">https://github.com/rust-lang/rust/blob/master/src/librustc_mir/transform/mod.rs#L188</a> )</p>",
        "id": 180520324,
        "sender_full_name": "Paul Faria",
        "timestamp": 1573568346
    },
    {
        "content": "<p>why does stealing invalidate the cache?</p>",
        "id": 180522312,
        "sender_full_name": "oli",
        "timestamp": 1573569515
    },
    {
        "content": "<p>Stealing doesn't, but the passes running on it can modify the body, which would invalidate the cache, right?</p>",
        "id": 180534429,
        "sender_full_name": "Paul Faria",
        "timestamp": 1573576274
    },
    {
        "content": "<p>Sorry, I was referring to what was happening inside of <code>mir_const</code> and not that stealing itself would invalidate the cache</p>",
        "id": 180534511,
        "sender_full_name": "Paul Faria",
        "timestamp": 1573576320
    },
    {
        "content": "<p>Particularly the run_passes portion of that fn</p>",
        "id": 180534605,
        "sender_full_name": "Paul Faria",
        "timestamp": 1573576350
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span>  I went ahead and implemented your suggestions yesterday. Is there anything other major item? Anything I could improve as well, e.g. comments anywhere within the code, or something else along those lines?</p>",
        "id": 180696036,
        "sender_full_name": "Paul Faria",
        "timestamp": 1573700699
    },
    {
        "content": "<p>I'll do a round of reviews. I think some documentation explaining things that aren't immediately obvious from readign the code would be good indeed. I'll leave comments wherever I see such situations</p>",
        "id": 180725754,
        "sender_full_name": "oli",
        "timestamp": 1573734708
    },
    {
        "content": "<p>Hey <span class=\"user-mention\" data-user-id=\"124288\">@oli</span> , I forgot to follow up last week to ask about inlining. Should I make any attempts at marking the functions inline? Initially I just copied over what was in <code>Body</code>, but not sure if there's a particular approach I should take to figure out the best candidates for marking inline. I.e. if there's any simple benchmarks I can run (outside of triggering a run in through github).</p>",
        "id": 181111199,
        "sender_full_name": "Paul Faria",
        "timestamp": 1574170665
    },
    {
        "content": "<p>Nah, don't mark things as <code>inline</code> unless there's a good motivation to do so. Don't go chasing for it without a concrete reason. We'll run perf tests and see how it goes</p>",
        "id": 181111317,
        "sender_full_name": "oli",
        "timestamp": 1574170759
    },
    {
        "content": "<p>Should I remove the ones that I had added in?</p>",
        "id": 181114279,
        "sender_full_name": "Paul Faria",
        "timestamp": 1574173006
    },
    {
        "content": "<p>without measurements that would be better, yes</p>",
        "id": 181116321,
        "sender_full_name": "oli",
        "timestamp": 1574174192
    },
    {
        "content": "<p>Just got a chance to push up that fix</p>",
        "id": 181214397,
        "sender_full_name": "Paul Faria",
        "timestamp": 1574261928
    },
    {
        "content": "<p>Going to rebase as well (hopefully not too many conflicts this time)</p>",
        "id": 181214420,
        "sender_full_name": "Paul Faria",
        "timestamp": 1574261939
    },
    {
        "content": "<p>I did another review. lgtm now. After you rebase I'll trigger the perf run</p>",
        "id": 181282476,
        "sender_full_name": "oli",
        "timestamp": 1574322030
    },
    {
        "content": "<p>Hey <span class=\"user-mention\" data-user-id=\"124288\">@oli</span> , so I took a look at the last run, and I'm not sure why it's failing to compile. Is there a specific way to run the build in that instance that's different from <code>./x.py build</code>?</p>",
        "id": 182027376,
        "sender_full_name": "Paul Faria",
        "timestamp": 1574867276
    },
    {
        "content": "<p>Re <a href=\"https://dev.azure.com/rust-lang/rust/_build/results?buildId=14488\" target=\"_blank\" title=\"https://dev.azure.com/rust-lang/rust/_build/results?buildId=14488\">https://dev.azure.com/rust-lang/rust/_build/results?buildId=14488</a></p>",
        "id": 182027428,
        "sender_full_name": "Paul Faria",
        "timestamp": 1574867288
    },
    {
        "content": "<p>It looks like it's running <code>x.py dist</code>. I'll try that locally</p>",
        "id": 182027497,
        "sender_full_name": "Paul Faria",
        "timestamp": 1574867365
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/pull/66279\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/pull/66279\">https://github.com/rust-lang/rust/pull/66279</a> merged two days ago and removed the <code>impl_stable_hash_for</code> macro which your PR uses. So when CI merges your PR into <code>master</code>, that macro is no longer defined. I think you just need to rebase on top of the latest <code>master</code> and fix the build issues .</p>",
        "id": 182028105,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1574867780
    },
    {
        "content": "<p>Oh that makes a lot more sense <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> . I incorrectly assumed the lack of merge conflicts in github meant it was something else. Thanks!</p>",
        "id": 182028727,
        "sender_full_name": "Paul Faria",
        "timestamp": 1574868216
    },
    {
        "content": "<p>Yeah, git's merge conflict detection algorithm is purely text based and only cares if you changes lines near other lines that were changed when merging. It's pretty easy to fool it.</p>",
        "id": 182028894,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1574868319
    }
]