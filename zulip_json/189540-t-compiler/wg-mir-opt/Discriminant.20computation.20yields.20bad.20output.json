[
    {
        "content": "<p>Maybe this has been discussed somewhere before (also I'm definitely underqualified to for this conversation), but: I've been working on improving the output of code <a href=\"https://godbolt.org/z/qdPe99WqG\">like this</a> over the last few days (see <a href=\"https://github.com/rust-lang/rust/issues/91840\">#91840</a> and I have a follow up PR that helps in some other cases) but no changes that I've been able to make have been able to get either of these to optimize into the single comparison that we'd want them to be.</p>\n<p>Fundamentally, I think the underlying issue here is that optimizers (both MIR passes and LLVM) have a hard time reasoning about what's going on because the control flow is divided up into two steps: First the discriminant of the enum is computed, and then the value of the discriminant is branched on. In order for the optimizer to get this right, it has to propagate the constraints that the discriminant taking a certain value implies.</p>\n<p>I'm also working on improved layout optimizations right now, and so am especially concerned about this because these kinds of things getting mis-optimized is obviously liable to turn into a major problem the more aggressively we put things in niches.</p>\n<p>Has some more fundamental change here been considered? I'm (again, besides extremely underqualified) imagining something like a <code>switchVariant</code> terminator where what this compiles to is decided at monomorphization time (or whenever the full layout of the enum is known). This would make it possible for the <code>Option&lt;NonZeroU32&gt;</code> equality comparison to look something more like this to LLVM:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"kc\">false</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">     </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"kc\">false</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"kc\">true</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>That's something I at least have some hope of getting compiled into the right thing.</p>",
        "id": 264944294,
        "sender_full_name": "Jake",
        "timestamp": 1639524596
    },
    {
        "content": "<p>(Not that this does get compiled right, <a href=\"https://godbolt.org/z/E3h9rjfPs\">but then what does</a>)</p>",
        "id": 264944436,
        "sender_full_name": "Jake",
        "timestamp": 1639524671
    },
    {
        "content": "<p>It probably doesn't need a new terminator, but having codegen_ssa special-case the <code>_N = discriminant(_M); switchInt (_N)</code> pattern might be profitable.</p>\n<p>It seems like <code>discriminant</code> directly always returns <code>isize</code>, and I recall from looking at suboptimal <code>?</code> codegen that maybe part of what confused it was that it was always switching on an extended-then-truncated value.  (And there's no <code>trunc exact</code> in LLVM to make that more obvious.)  It might be that switching directly could make it easier.</p>\n<p>Alternatively, maybe the <code>discriminant</code> MIR rvalue could be typed differently?  <code>Result</code> would be much happier if it could just <code>br</code> on the <code>i1</code> it read rather than needing it <code>switch</code> it.  That wouldn't work for a fully-generic <code>T</code>, but do we need it to work for that case?  Certainly <code>match</code> isn't ever switchInt'ing over a discriminant for a fully-generic type...</p>",
        "id": 264949038,
        "sender_full_name": "scottmcm",
        "timestamp": 1639527955
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/189540-t-compiler.2Fwg-mir-opt/topic/Discriminant.20computation.20yields.20bad.20output/near/264949038\">said</a>:</p>\n<blockquote>\n<p>It probably doesn't need a new terminator, but having codegen_ssa special-case the <code>_N = discriminant(_M); switchInt (_N)</code> pattern might be profitable.</p>\n</blockquote>\n<p>That might be enough. The thing I am slightly worried about is this encouraging other optimizations to make use of the discriminant being an integer and then eg doing arithmetic or something with it, probably this is a non-issue though.</p>\n<blockquote>\n<p>It seems like <code>discriminant</code> directly always returns <code>isize</code></p>\n</blockquote>\n<p>(and sometimes <code>usize</code>, as I recently learned via an ICE)</p>\n<blockquote>\n<p>Alternatively, maybe the <code>discriminant</code> MIR rvalue could be typed differently?  <code>Result</code> would be much happier if it could just <code>br</code> on the <code>i1</code> it read rather than needing it <code>switch</code> it.</p>\n</blockquote>\n<p>So I suppose its possible to special-case two variant enums (might be possible to just write an optimization pass for this though). But if we do not want to special case, then I think this is actually equivalent to my suggestion. What the <code>switchVariant</code> is effectively doing is <code>_N = discriminant(_M);</code> but now <code>_N</code> has some opaque non-integer type, and then \"switching\" on <code>_N</code> is a type specific operation.</p>",
        "id": 264950250,
        "sender_full_name": "Jake",
        "timestamp": 1639528858
    },
    {
        "content": "<p>Doing this thing pre-monomorphization is difficult when faced with layout optimizations though, because the correct way to codegen switching on the variant of a type like this is very dependent on the generic parameters:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">enum</span> <span class=\"nc\">E</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">T</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">U</span><span class=\"p\">(</span><span class=\"n\">U</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">V</span><span class=\"p\">(</span><span class=\"n\">V</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>ie if all three parameters are <code>u8</code> then this should be an LLVM <code>switchInt</code>, but on <code>E&lt;(NonZeroU8, u8), NonZeroU8, ()&gt;</code> this should be two <code>icmp + br</code>s (asuming that type gets the 2 byte layout)</p>",
        "id": 264950796,
        "sender_full_name": "Jake",
        "timestamp": 1639529287
    },
    {
        "content": "<p>In other words, forcing the non-monomorphized layout for <code>E</code> to pick some small set of values for its discriminants and then come monomorphization time generate whatever code is necessary for <code>discriminant</code> to meet that contract seems less than optimal</p>",
        "id": 264951534,
        "sender_full_name": "Jake",
        "timestamp": 1639529767
    },
    {
        "content": "<p>The huge advantage of just matching \"last statement was assign-from-discriminant\" is that you don't have to implement the new thing in all the backends.  The MIR could just try to move it as late as possible, if it's not already at the end of the block in practice.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jake</span> <a href=\"#narrow/stream/189540-t-compiler.2Fwg-mir-opt/topic/Discriminant.20computation.20yields.20bad.20output/near/264950250\">said</a>:</p>\n<blockquote>\n<p>The thing I am slightly worried about is this encouraging other optimizations to make use of the discriminant being an integer and then eg doing arithmetic or something with it, probably this is a non-issue though.</p>\n</blockquote>\n<p>That's an interesting canonicalization question.  For something like this &lt;<a href=\"https://rust.godbolt.org/z/Wc8qjcqMf\">https://rust.godbolt.org/z/Wc8qjcqMf</a>&gt; I could see an argument that it'd be <em>good</em> for the MIR to have <code>_2 = discriminant(_1); discriminant(_0) = !_2;</code> -- certainly LLVM can't do that today, generating <code>icmp</code>+<code>zext</code> instead of just <code>xor 1</code>.</p>",
        "id": 264952594,
        "sender_full_name": "scottmcm",
        "timestamp": 1639530634
    },
    {
        "content": "<p>Why can't LLVM do this today? In both the MIR and the pre-opt LLVM IR the fallthrough branch on the <code>switchInt</code> is correctly marked as unreachable, so the optimization should be allowed no?</p>",
        "id": 264953346,
        "sender_full_name": "Jake",
        "timestamp": 1639531274
    },
    {
        "content": "<p>See <a href=\"https://github.com/rust-lang/rust/issues/85133#issuecomment-904185574\">https://github.com/rust-lang/rust/issues/85133#issuecomment-904185574</a> for some previous investigation</p>\n<p>(I think it <em>ought</em> to be able to do it -- there's no fundamental semantic problem -- it just doesn't right now.)</p>",
        "id": 264953807,
        "sender_full_name": "scottmcm",
        "timestamp": 1639531697
    },
    {
        "content": "<p>Oh that is... extremely unforunate. It also might explain why one change I had made locally does not cause any perf changes</p>",
        "id": 264953965,
        "sender_full_name": "Jake",
        "timestamp": 1639531853
    },
    {
        "content": "<p>That's also why I wish there was a <code>trunc exact</code> (like there's a <code>udiv exact</code>).  If we could emit <code>load i8; trunc exact i8 to i1; br</code> then it'd know it doesn't need the extra <code>cmp</code>, but since it's just <code>trunc i8 to i1</code> it loses track of the fact that that's a noop.</p>",
        "id": 264954526,
        "sender_full_name": "scottmcm",
        "timestamp": 1639532390
    },
    {
        "content": "<p>I've got a POC for switching on tags directly but I need to clean it up first</p>",
        "id": 264995785,
        "sender_full_name": "nox",
        "timestamp": 1639567586
    },
    {
        "content": "<p>My POC just does the switching on tags at monomorphization time after finding a <code>…; _1 = discriminant(x); switchInt _1 { … }</code> block</p>",
        "id": 264996641,
        "sender_full_name": "nox",
        "timestamp": 1639568096
    },
    {
        "content": "<p>I'm super-excited for this!</p>\n<p>If you want another test, in <a href=\"https://github.com/rust-lang/rust/issues/91998\">#91998</a> I noticed that the length of an option iterator is suboptimal: &lt;<a href=\"https://rust.godbolt.org/z/q3rYjahPb\">https://rust.godbolt.org/z/q3rYjahPb</a>&gt;.  Would be great to be able to leave the obvious code and have it just work thanks to your PR.</p>",
        "id": 265224923,
        "sender_full_name": "scottmcm",
        "timestamp": 1639691624
    },
    {
        "content": "<p>Regarding the code from the Iterator PR: I think that should be merged, and that it is obvious code on its own. I dislike a lot that adapters don't redefine those methods</p>",
        "id": 265277373,
        "sender_full_name": "nox",
        "timestamp": 1639736386
    },
    {
        "content": "<p>And I checked and AFAICT my patch doesn't help :(</p>",
        "id": 265277623,
        "sender_full_name": "nox",
        "timestamp": 1639736538
    },
    {
        "content": "<p>I think what could help is noticing that the switch is exhaustive, and making it have a single arm</p>",
        "id": 265281460,
        "sender_full_name": "nox",
        "timestamp": 1639738784
    },
    {
        "content": "<p>Nope, still <code>icmp</code> in there</p>",
        "id": 265281642,
        "sender_full_name": "nox",
        "timestamp": 1639738846
    },
    {
        "content": "<p>Oh, yeah, I think it makes sense to override all those as in that PR.</p>\n<p>The thing that's less obvious to me is whether using <code>discriminant_value</code> for <code>Option::len</code> is a good change.</p>",
        "id": 265284408,
        "sender_full_name": "scottmcm",
        "timestamp": 1639740589
    },
    {
        "content": "<p>That seems like a bit of a hack. I'm curious why LLVM cannot remove the <code>icmp</code></p>",
        "id": 265303814,
        "sender_full_name": "nox",
        "timestamp": 1639752096
    },
    {
        "content": "<p>I feel like when LLVM optimises <code>%6 = load i32, i32* %5, align 4, !range !1</code>, it drops the range info, and then it cannot remember that the damn arg is always 0 or 1</p>",
        "id": 265304044,
        "sender_full_name": "nox",
        "timestamp": 1639752218
    },
    {
        "content": "<p>That already came up elsewhere: <a href=\"https://github.com/rust-lang/rust/issues/49572\">https://github.com/rust-lang/rust/issues/49572</a></p>",
        "id": 265304591,
        "sender_full_name": "nox",
        "timestamp": 1639752454
    },
    {
        "content": "<p>Yeah, it's also come up in <a href=\"https://github.com/rust-lang/rust/issues/85133#issuecomment-904185574\">https://github.com/rust-lang/rust/issues/85133#issuecomment-904185574</a></p>",
        "id": 265371483,
        "sender_full_name": "scottmcm",
        "timestamp": 1639780760
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/189540-t-compiler.2Fwg-mir-opt/topic/Discriminant.20computation.20yields.20bad.20output/near/264952594\">said</a>:</p>\n<blockquote>\n<p>The huge advantage of just matching \"last statement was assign-from-discriminant\" is that you don't have to implement the new thing in all the backends.  The MIR could just try to move it as late as possible, if it's not already at the end of the block in practice.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jake</span> <a href=\"#narrow/stream/189540-t-compiler.2Fwg-mir-opt/topic/Discriminant.20computation.20yields.20bad.20output/near/264950250\">said</a>:</p>\n<blockquote>\n<p>The thing I am slightly worried about is this encouraging other optimizations to make use of the discriminant being an integer and then eg doing arithmetic or something with it, probably this is a non-issue though.</p>\n</blockquote>\n<p>That's an interesting canonicalization question.  For something like this &lt;<a href=\"https://rust.godbolt.org/z/Wc8qjcqMf\">https://rust.godbolt.org/z/Wc8qjcqMf</a>&gt; I could see an argument that it'd be <em>good</em> for the MIR to have <code>_2 = discriminant(_1); discriminant(_0) = !_2;</code> -- certainly LLVM can't do that today, generating <code>icmp</code>+<code>zext</code> instead of just <code>xor 1</code>.</p>\n</blockquote>\n<p>Value numbering could help here because it has to compute alias info, which gives the optimizer more flexibility when moving statements around.</p>",
        "id": 265375112,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1639783115
    },
    {
        "content": "<p>It could even get a special case for \"discriminant-of\" Operands and rewrite them directly into get-discriminant + switch</p>",
        "id": 265375178,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1639783170
    },
    {
        "content": "<p>Also, this is probably obvious, but with MIR inlining + value numbering + enhanced inst combine we could probably just do this optimization ourselves and save ourselves all this trouble.</p>",
        "id": 265382630,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1639789839
    },
    {
        "content": "<p>I don't see how a MIR pass can improve discriminant switches when you need layout info to do the improvement</p>",
        "id": 265422951,
        "sender_full_name": "nox",
        "timestamp": 1639839674
    },
    {
        "content": "<p>Ah, I guess you meant for that case specifically</p>",
        "id": 265422960,
        "sender_full_name": "nox",
        "timestamp": 1639839691
    }
]