[
    {
        "content": "<p>I'd like to improve the robustness of MIR opt tests, since - in my experience - they have a tendency to break due to unrelated changes. In pursuit of this, I'd like to create a <code>-Zenable-mir-passes=+DestProp,-InstCombine</code> like flag. This would override the behavior of <code>MirPass::is_enabled</code>. Then, with that in place, I'd like to add a \"unit test\" mode for MIR opt tests. Not sure about the syntax yet, but the idea is that it would set <code>-Zmir-opt-level=0</code> and then enable the pass being tested and any other passes the test requests (possibly in addition to a standard set of passes?). This could not be used for all MIR opt tests, but it can be used for those that are just intended to ensure that a pass behaves a particular way on particular input.</p>\n<p>Is there prior art on this kind of idea? Would anyone be willing to review? I don't expect this to require a huge amount of code changes</p>",
        "id": 276758403,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648347565
    },
    {
        "content": "<p>LLVM passes may be prior art. <span class=\"user-mention\" data-user-id=\"118594\">@Dylan MacKenzie (ecstatic-morse)</span> wanted to write such a mir pass system afaicr</p>",
        "id": 276774734,
        "sender_full_name": "oli",
        "timestamp": 1648368934
    },
    {
        "content": "<p>The current mir pass manager is a first step towards it</p>",
        "id": 276774743,
        "sender_full_name": "oli",
        "timestamp": 1648368951
    },
    {
        "content": "<p>The current MIR pass manager is a very, <em>very</em>, simplified form of the LLVM old pass manager. I basically went to look at what LLVM did at the time and took parts of it that I felt was strictly necessary for then-minimal set of MIR passes.</p>",
        "id": 276790871,
        "sender_full_name": "nagisa",
        "timestamp": 1648391032
    },
    {
        "content": "<p>I no longer believe its a right model though, given our need for a concept of phases.</p>",
        "id": 276790910,
        "sender_full_name": "nagisa",
        "timestamp": 1648391053
    },
    {
        "content": "<p>Do you have concrete things that you think we should do differently? I'm happy to work on this</p>",
        "id": 276791199,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648391451
    },
    {
        "content": "<p>I don't know what a good design for us looks like, but I would like to see us share information about the function/program shared between passes somehow and I would love if we didn't need to specify the ordering manually the way we do today.</p>",
        "id": 276791286,
        "sender_full_name": "nagisa",
        "timestamp": 1648391561
    },
    {
        "content": "<p>Neither of these are a huge deal today though, and I'm not sure if it'll become a huge deal ever.</p>",
        "id": 276791301,
        "sender_full_name": "nagisa",
        "timestamp": 1648391593
    },
    {
        "content": "<p>And implementing something like this would also effectively require redesigning a lot about passes.</p>",
        "id": 276791315,
        "sender_full_name": "nagisa",
        "timestamp": 1648391615
    },
    {
        "content": "<blockquote>\n<p>but I would like to see us share information about the function/program shared between passes somehow</p>\n</blockquote>\n<p>Is there a typo in here?</p>\n<p>Also, do you think this should block what I suggested at the beginning of the thread?</p>",
        "id": 276791954,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648392409
    },
    {
        "content": "<p>There are also other things I'd like to do better (for example I have a feeling we do a lot of unnecessary work on recomputing the predecessor cache) but those seem like things we can work on independently</p>",
        "id": 276792033,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648392496
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jak{e,ob} Degen</span> <a href=\"#narrow/stream/189540-t-compiler.2Fwg-mir-opt/topic/MCP.20for.20improvements.20to.20mir.20opt.20tests/near/276791954\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>but I would like to see us share information about the function/program shared between passes somehow</p>\n</blockquote>\n<p>Is there a typo in here?</p>\n<p>Also, do you think this should block what I suggested at the beginning of the thread?</p>\n</blockquote>\n<p>Fixed, and not necessarily, no.</p>",
        "id": 276792285,
        "sender_full_name": "nagisa",
        "timestamp": 1648392827
    },
    {
        "content": "<p>Exposing more control of the how passes work to the tests will make it more difficult to make breaking changes to the system in the future. But given how implausible it is that we'll undertake significant rework in that area, I don't see why we would want to block any work there.</p>",
        "id": 276792408,
        "sender_full_name": "nagisa",
        "timestamp": 1648393005
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123586\">nagisa</span> <a href=\"#narrow/stream/189540-t-compiler.2Fwg-mir-opt/topic/MCP.20for.20improvements.20to.20mir.20opt.20tests/near/276792408\">said</a>:</p>\n<blockquote>\n<p>Exposing more control of the how passes work to the tests will make it more difficult to make breaking changes to the system in the future. But given how implausible it is that we'll undertake significant rework in that area, I don't see why we would want to block any work there.</p>\n</blockquote>\n<p>Indeed, and it definitely might be the case that at that time we have to drop support for a header directive or something like that. However, I also think that the gist of what I'm proposing is going to become <em>more</em> necessary in that world, not less. As passes gradually have less and less control over the conditions under which they are executed, being able to test them \"in isolation\" seems like it will become more important</p>",
        "id": 276793984,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648395510
    },
    {
        "content": "<p>Would you have time to review PRs for the original proposal?</p>",
        "id": 276794239,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648395922
    },
    {
        "content": "<p>I generally review things on weekends only, but if you're fine with the roundtrip time being ~week, I'm happy to review, sure.</p>",
        "id": 276794886,
        "sender_full_name": "nagisa",
        "timestamp": 1648396840
    },
    {
        "content": "<p>I would like to see a write-up of what the design is, and what it is looking to achieve before or along with the implementation, so that at least some semblance of an agreement over the vision can be established.</p>",
        "id": 276794911,
        "sender_full_name": "nagisa",
        "timestamp": 1648396889
    },
    {
        "content": "<p>Yeah, this requires an MCP anyway as far as I can tell (passes both the \"new <code>-Z</code> flag\" and \"needs to go in rustc dev guide\" conditions) so I figure that will be the chance to talk about design</p>",
        "id": 276795472,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648397740
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/189540-t-compiler.2Fwg-mir-opt/topic/MCP.20for.20improvements.20to.20mir.20opt.20tests/near/276774734\">said</a>:</p>\n<blockquote>\n<p>LLVM passes may be prior art. <span class=\"user-mention silent\" data-user-id=\"118594\">Dylan MacKenzie (ecstatic-morse)</span> wanted to write such a mir pass system afaicr</p>\n</blockquote>\n<p>So I did a bunch of reading about the new LLVM pass manager today, and it does sound like an appealing direction to go in. I think it's probably not necessary for the goals that I have in the near future, so I don't see myself driving work in this direction now, but if other people are working on it I would be happy to contribute (or pick it up myself whenever it does begin to block the things I want to do)</p>",
        "id": 276802712,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648408006
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310518\">@Jak{e,ob} Degen</span> I think the <code>-Z</code> flag you proposed would be a useful addition. Here all of the things that I've wanted while working on MIR transforms.</p>\n<ul>\n<li>Turn on/off individual passes at the command line (your idea)</li>\n<li>Change MIR ordering constraints from a total ordering (<code>MirPhase</code>) to a partial one.<ul>\n<li>Each pass can set one or more flags indicating some kind of substantive change has taken place and/or new invariant must be upheld. These can be big (generator transform) or small (multiple return terminators). </li>\n<li>Passes can declare dependencies on sets of flags instead of specifying what phase they run in, since that makes it hard to tell exactly what they depend on.</li>\n</ul>\n</li>\n<li>Have passes schedule <code>SimplifyCfg</code> (and other cleanup passes) themselves:<ul>\n<li>Current transforms either call <code>SimplifyCfg::run_pass</code> directly, which bypasses the \"pass manager\", or manually insert <code>SimplifyCfg</code> in the list of passes themselves, which sometimes gets messed up when new passes are added. The first is usually preferable, but sometimes when debugging MIR passes it's helpful to look at the pre-cleanup MIR dump to see what's going on.</li>\n<li>Also would be cool to allow subsequent passes to \"defer\" cleanup until after they run. For example,  it's not useful to remove unreachable basic blocks if the next pass is doing a DFS on the CFG anyways and is going to create even more unreachable blocks. This probably isn't important, but is easy to implement.</li>\n</ul>\n</li>\n</ul>\n<p>While these would all be nice to have, they don't have affect end-users at all, so I haven't been motivated enough to write an actual proposal and push them through MCP.</p>",
        "id": 276919468,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1648495308
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@Dylan MacKenzie (ecstatic-morse)</span>  Yeah, so it's very nice to see that this roughly lines up with my model of what we might want. The one thing I'd definitely like to add is that I think that the most important thing is to reduce and clarify the MIR dialects. Right now, MIR seems to be three programming languages wrapped into one, and as our passes get more precise and aggressive, I don't expect it to be a long term option for passes to be designed to be compatible with more than one of them. In an ideal world, I think it would work something like this:</p>\n<p>We divide MIR up into two \"dialects:\" Analysis, and optimization. These have different operational semantics, somewhat different structure, and both are documented clearly (and separately, where applicable). Essentially, we should look at these as two different IRs that happen to share a data structure. The transition from one to the other happens in an isolated, controlled, and well-defined region of code. This \"lowering\" step would probably need to happen over more than one <code>MirPass</code>, but there should be as few as possible and they should not be \"flexible,\" ie we can't go re-ordering them, turning some of them off, etc. All of these passes run on MIR that is in some kind of inevitably under-specified, halfway state and that is fundamentally dangerous.</p>\n<p>With two dialects of MIR, we can then define more phases for either of them (if necessary) - the phases might represent different static requirements in MIR (\"after this phase <code>Aggregate</code> statements are no longer allowed\") or indicate other stuff (\"now is a good time to do loop optimizations\"), but they no longer change operational semantics. Each pass is carefully justified against the operational semantics of the dialect it belongs to. For example, I could imagine that optimization MIR has a \"pre-optimization\" phase in which we do stuff like emitting retags, const prop lints, deaggregation, and intrinsic lowering - all of these steps are important and relied upon by subsequent passes, but they do not have to be a part of the dangerous code that runs against a version of MIR without clear semantics.</p>\n<p>Re-reading this now, this almost feels a little bit overly defensive - at the same time though, I'm reminded of how fundamentally difficult the problem of ensuring optimizations are correct seems to be (and not even for MIR specifically, but just in general). So probably being overly strict about not compromising on the existence of clearly defined semantics wherever possible is a good direction to go in</p>",
        "id": 276938708,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648506555
    },
    {
        "content": "<p>I have a question. Given that we do not yet have an option to only turn on certain MIR optimization passes through a CLI flag, the only way to do that currently  is to manually change the <code>run_optimization_passes</code> <a href=\"https://doc.rust-lang.org/nightly/nightly-rustc/src/rustc_mir_transform/lib.rs.html#440-505\">function</a> and recompile the compiler?</p>",
        "id": 276954264,
        "sender_full_name": "Emanuel Lima",
        "timestamp": 1648524567
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"262681\">Emanuel Lima</span> <a href=\"#narrow/stream/189540-t-compiler.2Fwg-mir-opt/topic/MCP.20for.20improvements.20to.20mir.20opt.20tests/near/276954264\">said</a>:</p>\n<blockquote>\n<p>I have a question. Given that we do not yet have an option to only turn on certain MIR optimization passes through a CLI flag, the only way to do that currently  is to manually change the <code>run_optimization_passes</code> <a href=\"https://doc.rust-lang.org/nightly/nightly-rustc/src/rustc_mir_transform/lib.rs.html#440-505\">function</a> and recompile the compiler?</p>\n</blockquote>\n<p>Yes. Of course, we do have <code>-Zmir-opt-level</code> and <code>-Zunsound-mir-opts</code>, but they don't enable individual passes</p>",
        "id": 276955294,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648526043
    },
    {
        "content": "<p>Would you say (guess, actually) that selecting a subset of MIR passes would change execution time of the resulting binary noticeably?</p>",
        "id": 276955641,
        "sender_full_name": "Emanuel Lima",
        "timestamp": 1648526452
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"262681\">Emanuel Lima</span> <a href=\"#narrow/stream/189540-t-compiler.2Fwg-mir-opt/topic/MCP.20for.20improvements.20to.20mir.20opt.20tests/near/276955641\">said</a>:</p>\n<blockquote>\n<p>Would you say (guess, actually) that selecting a subset of MIR passes would change execution time of the resulting binary noticeably?</p>\n</blockquote>\n<p>So, just having run <code>rg \"mir_opt_level\" compiler/rustc_mir_transform</code>, the only passes that are enabled at an opt level available on stable, are optimization passes, and I don't expect LLVM to be able to super easily do itself are uninhabited enum branching and nrvo. I don't expect those to have a huge perf impact, but probably some</p>",
        "id": 276956564,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648527642
    },
    {
        "content": "<p>That being said, if we were to fix all the passes that are off/broken, that might be a very different story</p>",
        "id": 276956575,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648527665
    },
    {
        "content": "<p>I'm slowly working towards that goal</p>",
        "id": 276956588,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648527683
    },
    {
        "content": "<p>If you could guide/mentor me, I could help on that effort <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 277013347,
        "sender_full_name": "Emanuel Lima",
        "timestamp": 1648564320
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"262681\">Emanuel Lima</span> <a href=\"#narrow/stream/189540-t-compiler.2Fwg-mir-opt/topic/MCP.20for.20improvements.20to.20mir.20opt.20tests/near/277013347\">said</a>:</p>\n<blockquote>\n<p>If you could guide/mentor me, I could help on that effort :)</p>\n</blockquote>\n<p>I don't think I really have the background to mentor here, I am mostly just learning myself. That being said, I'm happy to help in whatever way I can</p>",
        "id": 277062527,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648586732
    },
    {
        "content": "<p>My approach here has essentially been pretty simple: pick an opt and fix it. Unfortunately, sometimes this is a bigger task than it seems. For example, <code>EarlyOtherwiseBranch</code> needs either changes to MIR building or value tracking + alias analysis to be sound. <code>SimplifyArmIdentity</code> needs value tracking as well in order to be possible. I'm currently working on <code>DestProp</code> and I don't <em>think</em> that needs any new analysis in order to be sound - but I'll have to see</p>",
        "id": 277063286,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648587190
    }
]