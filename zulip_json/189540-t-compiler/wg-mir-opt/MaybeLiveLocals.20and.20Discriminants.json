[
    {
        "content": "<p>While trying to write a mir dead assignment elimination based on live variable analysis I noticed that <code>MaybeLiveLocals</code> kills a local when it's discriminant is set. This surprised me somewhat (it made me delete \"dead\" assignments to fields of locals with discriminants, which weren't dead). Is this expected behaviour? And when the discriminant of a local is modified, need all fields of the local be set (immidiately) before the discriminant modification? (More generally is there documentation on requirements on mir to be valid?) And is there a fast way to check whether a local has a discriminant (e.g. without looking up the type)?</p>",
        "id": 249276975,
        "sender_full_name": "niluxv",
        "timestamp": 1628794458
    },
    {
        "content": "<p>Do you have example MIR?</p>",
        "id": 250790025,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1629991453
    },
    {
        "content": "<p>no for the last question, whether disciminant is present is a property of the type.</p>",
        "id": 250982538,
        "sender_full_name": "nagisa",
        "timestamp": 1630092298
    },
    {
        "content": "<p>MIR has no documented validity properties AFAIK. There are obviously correct constructions, obviously incorrect ones and those in between. We try to stay within the first category.</p>",
        "id": 250982837,
        "sender_full_name": "nagisa",
        "timestamp": 1630092434
    },
    {
        "content": "<p>It is complicated by the fact that what's considered obviously valid mir depends on its position in the pipeline.</p>",
        "id": 250983297,
        "sender_full_name": "nagisa",
        "timestamp": 1630092629
    },
    {
        "content": "<p>borrowck has certain needs that e.g. cg_llvm doesn't.</p>",
        "id": 250983358,
        "sender_full_name": "nagisa",
        "timestamp": 1630092662
    },
    {
        "content": "<p>Within block liveness results will be incorrect so that doesn't seem right. The only real user of MaybeLiveLocals is state transform, which is concerned with liveness at basic block boundaries, so is probably unaffected (in fact it might improve the precision of the analysis?). Still, seems very subtle if this behavior was intentional. Maybe <span class=\"user-mention\" data-user-id=\"118594\">@Dylan MacKenzie (ecstatic-morse)</span>  will know, if it was?</p>",
        "id": 255941936,
        "sender_full_name": "tm",
        "timestamp": 1633257247
    },
    {
        "content": "<p>I can't speak to intent, since I (hopefully) just translated the existing liveness pass to fit within the framework, but the underlying problem is that <code>MaybeLiveLocals</code> is field-insensitive, so it doesn't differentiate between total writes and partial ones. Presumably this was all that the generator state transform needed (although I don't know for sure). This isn't called out explicitly in the <code>MaybeLiveLocals</code> docs, and it's a pretty big footgun. I suspect this is part of why <code>dest_prop</code>is currently unsound?</p>\n<p>To do the kind of optimization the OP desires, you would need a field-sensitive version of variable liveness. Maybe that should just replace the field-insensitive one since the latter is prone to misuse?</p>",
        "id": 255968488,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1633284382
    },
    {
        "content": "<p>I don't think the generator state transform is hot, and it might benefit from a more careful treatment of live variables.</p>",
        "id": 255968657,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1633284590
    },
    {
        "content": "<p>As I understand, the question is essentially about this change <a href=\"https://github.com/rust-lang/rust/pull/73774/commits/558c8a8c3c7e7cdf83703a044f085e89d71680e8\">https://github.com/rust-lang/rust/pull/73774/commits/558c8a8c3c7e7cdf83703a044f085e89d71680e8</a>. While analysis remains field-insensitive, it does make a distinction between partial and complete writes. In particular, SetDiscriminant has a Store context, which will translate into Def, and if there are no projections the SetDiscriminant statement will kill the whole local.</p>",
        "id": 255971350,
        "sender_full_name": "tm",
        "timestamp": 1633287204
    },
    {
        "content": "<p>Ah, okay. It's starting to come back to me now. Yes I think it's wrong to treat <code>SetDiscriminant</code> as a definition of a variable. I should have handled that in the PR you linked.</p>",
        "id": 255973703,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1633289330
    },
    {
        "content": "<p>Out of curiousity, what does the MIR look like when we assign to an <code>enum</code> typed local? Is it </p>\n<div class=\"codehilite\"><pre><span></span><code>SetDiscriminant(p, MyVariant);\n(p as variant#MyVariant) = data;\n</code></pre></div>\n<p>or vice versa? Something else?</p>",
        "id": 255973748,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1633289387
    },
    {
        "content": "<p>If so, we won't give reasonable liveness info for enums without something more advanced, right?</p>",
        "id": 255973864,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1633289503
    },
    {
        "content": "<p>(It's been a while since I've had to think about MIR semantics)</p>",
        "id": 255973913,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1633289525
    },
    {
        "content": "<p>From the playground, it looks like:</p>\n<div class=\"codehilite\"><pre><span></span><code>        ((_3 as Some).0: i32) = const 4_i32;\n        discriminant(_3) = 1;\n</code></pre></div>",
        "id": 255974873,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1633290443
    },
    {
        "content": "<p>That means that the generator transform depends on <code>discriminant(_3) = 1</code> killing <code>_3</code> to handle enum-typed locals, right?</p>",
        "id": 255975244,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1633290764
    },
    {
        "content": "<p>So we'd need to provide some alternative. We can't just make the obviously correct change.</p>",
        "id": 255975294,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1633290820
    },
    {
        "content": "<p>Well, we could, but probably shouldn't, since generators would get bigger.</p>",
        "id": 255975351,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1633290851
    },
    {
        "content": "<p>Does all of this sound correct <span class=\"user-mention\" data-user-id=\"352985\">@tm</span>? Or did I mess something up?</p>",
        "id": 255975381,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1633290900
    },
    {
        "content": "<p>That sounds right. I would be quite curious to learn about practical significance of this, I don't really have an intuition how important providing an alternative would be.</p>",
        "id": 255977872,
        "sender_full_name": "tm",
        "timestamp": 1633293314
    },
    {
        "content": "<p>Yeah, it's clear to me that the current implementation of <code>MaybeLiveLocals</code> isn't suitable for doing the kind of dead store removal that the OP wanted. I don't even know that a field-sensitive live variables is tractable. Should  we just document the current behavior around <code>SetDiscriminant</code> and preserve the status quo?</p>",
        "id": 255978214,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1633293643
    },
    {
        "content": "<p>Sorry for the long silence. Thanks everyone for the answers. <span class=\"user-mention\" data-user-id=\"118594\">@Dylan MacKenzie (ecstatic-morse)</span> Yes, it would be great if the documentation reflected this somewhat non-obvious behaviour.<br>\n<span class=\"user-mention\" data-user-id=\"352985\">@tm</span> I don't think it is very important. How to do these kinds of optimisations for enum types is very non-obvious anyway, it is just important to know that when using the <code>MaybeLiveLocals</code> analysis, types with discriminants must be ignored for optimisations.</p>",
        "id": 262708145,
        "sender_full_name": "niluxv",
        "timestamp": 1637848564
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"312719\">@Xavier Denis</span> </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">borrowed_enum</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"kt\">u32</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"kt\">u32</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">yref</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">y</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">*</span><span class=\"n\">yref</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>gives the mir given in the attached .dot file, which also shows the live variable analysis results. <a href=\"/user_uploads/4715/pYD7iZKyxibMo47LTs4tQh9q/mir_dataflow_lva_testing.borrowed_enum.-.liveness.-..dot\">mir_dataflow_lva_testing.borrowed_enum.-.liveness.-..dot</a> <br>\nOn line 4 the discriminant of local <code>_2</code> is modified, which kills <code>_2</code> in the live variable analysis (therefore the assignment on line 3 becomes dead, but it is not actually dead).</p>",
        "id": 262709393,
        "sender_full_name": "niluxv",
        "timestamp": 1637849163
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"401145\">@niluxv</span>: <span class=\"user-mention silent\" data-user-id=\"118594\">Dylan MacKenzie (ecstatic-morse)</span> documented the current behaviour of  MaybeLiveLocals in <a href=\"https://github.com/rust-lang/rust/issues/89532\">#89532</a>. Sorry about lack of followup on Zulip.</p>",
        "id": 262863612,
        "sender_full_name": "tm",
        "timestamp": 1638004742
    }
]