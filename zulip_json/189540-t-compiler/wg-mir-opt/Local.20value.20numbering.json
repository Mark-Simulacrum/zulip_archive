[
    {
        "content": "<p>I realized that we could implement local value numbering today and filed an issue: <a href=\"https://github.com/rust-lang/rust/issues/91688\">https://github.com/rust-lang/rust/issues/91688</a></p>",
        "id": 264248964,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1639016783
    },
    {
        "content": "<p>It doesn't need SSA unlike GVN</p>",
        "id": 264248972,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1639016793
    },
    {
        "content": "<p>So I've taken a stab at this and I'm quickly running into questions about what <code>&amp;</code> and <code>&amp;mut</code> are allowed to alias. Since the unsafe code guidelines aren't ready yet, I wonder what basic uncontroversial things I can do.</p>",
        "id": 264388828,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1639097090
    },
    {
        "content": "<p>Right now I'm just assuming that <code>&amp;</code> and <code>&amp;mut</code> are allowed to alias everything, even locals. Obviously this needs to be expanded in the future.</p>",
        "id": 264389062,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1639097278
    },
    {
        "content": "<p><code>&amp;mut</code> can only alias when stacked/reborrowed, no?</p>",
        "id": 264389136,
        "sender_full_name": "cuviper",
        "timestamp": 1639097318
    },
    {
        "content": "<p>hmm, well I guess NLL end can happen within a BB too</p>",
        "id": 264389936,
        "sender_full_name": "cuviper",
        "timestamp": 1639097947
    },
    {
        "content": "<p>Can we assume immutability behind <code>&amp;</code> modulo UnsafeCell? Combined with pointer provenance that could let us use LVN to eliminate redundant loads like a[i] where <code>a</code> is <code>&amp;[int]</code>, which is something LLVM cannot do as easily.</p>",
        "id": 264393551,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1639100789
    },
    {
        "content": "<p>BTW it's looking like LVN isn't that hard to implement. GVN is harder of course because we would need SSA.</p>",
        "id": 264393571,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1639100819
    },
    {
        "content": "<p>I think that's also a borrowck kind of question. If that's a continuous <code>a</code>, then yes it's immutable for <code>T: Freeze</code>.</p>",
        "id": 264398470,
        "sender_full_name": "cuviper",
        "timestamp": 1639106358
    },
    {
        "content": "<p>If LVN normalized two expressions to the same <code>a</code>, then you'd need to make sure there were no writes between.</p>",
        "id": 264398555,
        "sender_full_name": "cuviper",
        "timestamp": 1639106447
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/189540-t-compiler.2Fwg-mir-opt/topic/Local.20value.20numbering/near/264393551\">said</a>:</p>\n<blockquote>\n<p>Can we assume immutability behind <code>&amp;</code> modulo UnsafeCell?</p>\n</blockquote>\n<p>Only one level deep without further analysis (see <code>&amp;&amp;AtomicU8</code>, for example), but yes.  You can probably re-use the same checking that <code>static</code>s use to know they can go in read-only memory.</p>",
        "id": 264421688,
        "sender_full_name": "scottmcm",
        "timestamp": 1639128753
    },
    {
        "content": "<blockquote>\n<p>You can probably re-use the same checking that statics use to know they can go in read-only memory.</p>\n</blockquote>\n<p>That is <code>ty.is_freeze(tcx.at(DUMMY_SP), ParamEnv::reveal_all())</code>: <a href=\"https://github.com/rust-lang/rust/blob/574d37568029f5c637557a87426ade54770d9a14/compiler/rustc_codegen_ssa/src/traits/type_.rs#L82\">https://github.com/rust-lang/rust/blob/574d37568029f5c637557a87426ade54770d9a14/compiler/rustc_codegen_ssa/src/traits/type_.rs#L82</a></p>",
        "id": 264435803,
        "sender_full_name": "bjorn3",
        "timestamp": 1639137056
    },
    {
        "content": "<p>I have a WIP at <a href=\"https://github.com/pcwalton/rust/tree/value-numbering\">https://github.com/pcwalton/rust/tree/value-numbering</a></p>",
        "id": 264506520,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1639169634
    },
    {
        "content": "<p>It can do simple copy propagation, but causes ICEs sometimes right now because it doesn't rewrite StorageLive/StorageDead yet.</p>",
        "id": 264506625,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1639169673
    },
    {
        "content": "<p>Also it can do basic common subexpression elimination.</p>",
        "id": 264506662,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1639169699
    },
    {
        "content": "<p>I wish pointer provenance info were more accessible to <code>rustc_mir_transform</code> instead of being local to borrowck</p>",
        "id": 264585457,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1639257696
    },
    {
        "content": "<p>So it should be able to properly optimize <a href=\"https://rust.godbolt.org/z/7f6Gff7Ms\">https://rust.godbolt.org/z/7f6Gff7Ms</a> once I implement a pass to promote needlessly-mutable locals to immutable.</p>",
        "id": 264917004,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1639512094
    },
    {
        "content": "<p>This is an optimization that LLVM cannot do.</p>",
        "id": 264917124,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1639512134
    },
    {
        "content": "<p>And it's working now, in a simple test :)</p>",
        "id": 264923073,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1639514942
    }
]