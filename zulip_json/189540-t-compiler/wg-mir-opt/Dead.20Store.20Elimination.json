[
    {
        "content": "<p>Do we have a pass that can eliminate stores that are never read? Const prop can leave a lot of those behind when it runs.</p>",
        "id": 198596821,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1590349330
    },
    {
        "content": "<p><code>SimplifyLocals</code> does a rather naive form of DSE</p>",
        "id": 198596901,
        "sender_full_name": "Matthew Jasper",
        "timestamp": 1590349506
    },
    {
        "content": "<p>Specifically it removes stores to locals where the local is never read, rather than where the stored value is never read.</p>",
        "id": 198596971,
        "sender_full_name": "Matthew Jasper",
        "timestamp": 1590349634
    },
    {
        "content": "<p>Ah I see, that should already help</p>",
        "id": 198597081,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1590349693
    },
    {
        "content": "<p>More robust DSE is one of the things I wanted to implement now that intrablock liveness is easy to compute.</p>",
        "id": 198601990,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1590357141
    },
    {
        "content": "<p>I think I'll work on that next week.</p>",
        "id": 198602950,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1590358831
    },
    {
        "content": "<p>Somewhat related, I'm working on being able to remove locals that are only used for debug info while still preserving the debug info data.</p>",
        "id": 198608305,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1590369288
    },
    {
        "content": "<p>Hi! I played around with the playground, looking for simple MIR optimizations. In this code <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=release&amp;edition=2018&amp;gist=5e51319bc039ba93e4006ce775988439\">https://play.rust-lang.org/?version=nightly&amp;mode=release&amp;edition=2018&amp;gist=5e51319bc039ba93e4006ce775988439</a> \"x\" is const so no side effects and completely dead. It is however not removed. </p>\n<p>I'm reviving this topic as that seems to be the \"more robust DSE\" being talked about. Any progress on that <span class=\"user-mention\" data-user-id=\"118594\">@ecstatic-morse</span> , <span class=\"user-mention\" data-user-id=\"125250\">@Wesley Wiser</span> ? If not, I could be interested in giving a (simple) pass a shot. Would this fit inside SimplifyLocals, or should it be pulled out into a separate dead-code-elimination pass?</p>",
        "id": 204696357,
        "sender_full_name": "Simon Vandel Sillesen",
        "timestamp": 1595438688
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"139182\">@Simon Vandel Sillesen</span>! I've actually got a PR up that's waiting to merge that resolves that <a href=\"https://github.com/rust-lang/rust/pull/73210\">https://github.com/rust-lang/rust/pull/73210</a></p>",
        "id": 204696784,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1595438862
    },
    {
        "content": "<p>(The thing that's causing <code>x</code> to hang around is because it's being used by debuginfo)</p>",
        "id": 204696869,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1595438887
    },
    {
        "content": "<p>Alright, that sounds good!</p>",
        "id": 204714755,
        "sender_full_name": "Simon Vandel Sillesen",
        "timestamp": 1595447866
    },
    {
        "content": "<p>If you're looking for an optimization to work on, I think <span class=\"user-mention\" data-user-id=\"124288\">@oli</span>  has some \"beginner\" ones in mind <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 204714945,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1595447955
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@Dylan MacKenzie (ecstatic-morse)</span> and I were discussing Dead Store Elimination w.r.t. drop flags today, here:<br>\n<a href=\"#narrow/stream/131828-t-compiler/topic/MIR.20and.20LLVM.20IR.20observations/near/261882149\">https://rust-lang.zulipchat.com/#narrow/stream/131828-t-compiler/topic/MIR.20and.20LLVM.20IR.20observations/near/261882149</a><br>\nand here: <a href=\"#narrow/stream/131828-t-compiler/topic/Drop.20flags.20and.20dead.20store.20elimination\">https://rust-lang.zulipchat.com/#narrow/stream/131828-t-compiler/topic/Drop.20flags.20and.20dead.20store.20elimination</a></p>\n<p>I might try to implement this tomorrow. I'm happy to hear any advice, pitfalls, pointers to prior work, reasons why I shouldn't do it, etc. <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 261892568,
        "sender_full_name": "nnethercote",
        "timestamp": 1637218857
    },
    {
        "content": "<p>I'm puzzled by step 2 in <a href=\"https://rustc-dev-guide.rust-lang.org/mir/optimizations.html\">https://rustc-dev-guide.rust-lang.org/mir/optimizations.html</a>. How can I generate the MIR dump for a new optimization before I've implemented the optimization?</p>",
        "id": 262028093,
        "sender_full_name": "nnethercote",
        "timestamp": 1637298770
    },
    {
        "content": "<p>I'm also not sure if I want a .diff or a .after.mir or a .before.mir</p>",
        "id": 262028484,
        "sender_full_name": "nnethercote",
        "timestamp": 1637299244
    },
    {
        "content": "<p>I've used <code>// EMIT_MIR dse.main.DeduplicateBlocks.after.mir</code> just to get something going. But the output I get in <code>dse.main.DeduplicateBlocks.after.mir</code> after running <code>./x.py test --bless src/test/mir-opt/dse.rs</code> isn't the same as the output in <code>mir_dump/dse.main.005-022.DeduplicateBlocks.after.mir</code> after running <code>rustc dse.rs -Zdump-mir=all</code>.</p>",
        "id": 262028703,
        "sender_full_name": "nnethercote",
        "timestamp": 1637299529
    },
    {
        "content": "<p>Oh, if I use `rustc -O <a href=\"http://dse.rs\">dse.rs</a> -Zdump-mir=all\" I get output that matches</p>",
        "id": 262028789,
        "sender_full_name": "nnethercote",
        "timestamp": 1637299636
    },
    {
        "content": "<p>Huh, weird, with <code>-O</code> I get MIR that looks less optimized</p>",
        "id": 262028847,
        "sender_full_name": "nnethercote",
        "timestamp": 1637299687
    },
    {
        "content": "<p>Oh, the difference is the presence/absence of <code>StorageLive</code> in my basic block of interest. Looks like <code>emit_lifetime_markers</code> says they should remain in optimized builds</p>",
        "id": 262029103,
        "sender_full_name": "nnethercote",
        "timestamp": 1637299998
    },
    {
        "content": "<p>So now I'm puzzled by the mir testing: if optimized builds and debug builds produce different MIR, how do the tests work with both kinds of builds?</p>",
        "id": 262029172,
        "sender_full_name": "nnethercote",
        "timestamp": 1637300077
    },
    {
        "content": "<p>Back to my first question: if I implement the new optimization as a no-op to start with, then it makes more sense to generate an initial .diff (or .after.mir) file.</p>",
        "id": 262029851,
        "sender_full_name": "nnethercote",
        "timestamp": 1637300845
    },
    {
        "content": "<p>I've not followed those instructions. I just implement the transform (based on what I see in dump-mir) and then emit a diff.</p>",
        "id": 262030152,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1637301211
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> did you write <a href=\"https://rustc-dev-guide.rust-lang.org/mir/optimizations.html\">https://rustc-dev-guide.rust-lang.org/mir/optimizations.html</a>?</p>",
        "id": 262030164,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1637301242
    },
    {
        "content": "<p>Does that predate first class diffs in Mir opt Tests or something?</p>",
        "id": 262030242,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1637301333
    },
    {
        "content": "<p>yea, diffs came a bit later</p>",
        "id": 262058469,
        "sender_full_name": "oli",
        "timestamp": 1637323867
    },
    {
        "content": "<p>I'm still wondering about this:</p>\n<blockquote>\n<p>if optimized builds and debug builds produce different MIR, how do the tests work with both kinds of builds?</p>\n</blockquote>",
        "id": 262261599,
        "sender_full_name": "nnethercote",
        "timestamp": 1637530064
    },
    {
        "content": "<p>compiletest typically passes -Copt-level=3, IIRC</p>",
        "id": 262261993,
        "sender_full_name": "simulacrum",
        "timestamp": 1637530635
    },
    {
        "content": "<p>er, looks like =1 actually</p>",
        "id": 262262005,
        "sender_full_name": "simulacrum",
        "timestamp": 1637530669
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/blob/65f3f8b220f020e562c5dd848ff7319257a7ba45/src/tools/compiletest/src/runtest.rs#L1820\">https://github.com/rust-lang/rust/blob/65f3f8b220f020e562c5dd848ff7319257a7ba45/src/tools/compiletest/src/runtest.rs#L1820</a></p>",
        "id": 262262052,
        "sender_full_name": "simulacrum",
        "timestamp": 1637530691
    },
    {
        "content": "<p>But also <code>Zmir-opt-level=4</code>, <span aria-label=\"thumbs up\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"thumbs up\">:thumbs_up:</span> , thanks</p>",
        "id": 262262739,
        "sender_full_name": "nnethercote",
        "timestamp": 1637531755
    },
    {
        "content": "<p>I have finished a draft of the Dead Store Elimination pass.</p>\n<p>The good news is that it works! It eliminates the unnecessary drop flags, and passes tests.</p>\n<p>The bad news is that it has very little effect on compilation speed. On a couple of big example I looked at (e.g. webrender) <code>cargo llvm-lines</code> says the number of lines dropped by 0.1-0.3%, and a local benchmarking run of opt builds showed negligible changes.</p>",
        "id": 262283805,
        "sender_full_name": "nnethercote",
        "timestamp": 1637563045
    },
    {
        "content": "<p>Did</p>",
        "id": 262286479,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1637566175
    },
    {
        "content": "<p>(I didn't notice I had sent an unfinished message earlier)</p>",
        "id": 262297142,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1637574098
    },
    {
        "content": "<blockquote>\n<p>The bad news is that it has very little effect on compilation speed</p>\n</blockquote>\n<p>I'm guessing it's because these are cleaned up extremely early in LLVM, like in first SROA?</p>",
        "id": 262317149,
        "sender_full_name": "Adrian Wielgosik",
        "timestamp": 1637587198
    },
    {
        "content": "<blockquote>\n<p>Did you implement the simplified boolean only intra-block version you mentioned in another thread?</p>\n</blockquote>\n<p>It is intra-block and constants of all types, though in practice I've only seen it have an effect on booleans.</p>",
        "id": 262381064,
        "sender_full_name": "nnethercote",
        "timestamp": 1637617092
    },
    {
        "content": "<blockquote>\n<p>I'm guessing it's because these are cleaned up extremely early in LLVM, like in first SROA?</p>\n</blockquote>\n<p>I think it's more just that there aren't that many of these dead stores. Eliminating them only reduced the amount of LLVM IR by 0.1-0.3% in the programs I looked at. So if LLVM compile time is proportional to code size (probably a reasonable assumption for rough calculations?) the potential for improvement is just very small.</p>",
        "id": 262381196,
        "sender_full_name": "nnethercote",
        "timestamp": 1637617189
    },
    {
        "content": "<p>On the intra-BB vs inter-BB front: I was just looking at the MIR some more, and it looks like some inter-BB analysis could do better.</p>",
        "id": 262384402,
        "sender_full_name": "nnethercote",
        "timestamp": 1637618924
    },
    {
        "content": "<p>E.g. I see <code>_202 = const false;</code> in five different BBs, and then this:</p>\n<div class=\"codehilite\"><pre><span></span><code>    bb127 (cleanup): {\n        switchInt(_202) -&gt; [false: bb109, otherwise: bb126]; // scope 3 at counts.rs:22:5: 22:6\n    }\n</code></pre></div>",
        "id": 262384483,
        "sender_full_name": "nnethercote",
        "timestamp": 1637618978
    },
    {
        "content": "<p>I see that same pattern with quite a few drop flags</p>",
        "id": 262384610,
        "sender_full_name": "nnethercote",
        "timestamp": 1637619024
    },
    {
        "content": "<p>So <code>bb126</code> is dead in this case</p>",
        "id": 262384716,
        "sender_full_name": "nnethercote",
        "timestamp": 1637619108
    },
    {
        "content": "<p>Which means that <code>bb127</code> is useless</p>",
        "id": 262384787,
        "sender_full_name": "nnethercote",
        "timestamp": 1637619136
    },
    {
        "content": "<p>Oh, interesting; my intra-bb DSE is making it more obvious that some of these drop flags are useless. E.g. there was a <code>_202 = const true</code> in the code that my DSE removed. After that, all the assignments are <code>_202 = const false</code>.</p>",
        "id": 262385684,
        "sender_full_name": "nnethercote",
        "timestamp": 1637619544
    },
    {
        "content": "<p>So I think I can now do a very simple pass looking for <code>bool</code>s that are only ever assigned as false, to identify useless drop flags.</p>",
        "id": 262385731,
        "sender_full_name": "nnethercote",
        "timestamp": 1637619584
    },
    {
        "content": "<p>And then I can get rid of some <code>switchInt</code>s and some BBs, perhaps</p>",
        "id": 262385750,
        "sender_full_name": "nnethercote",
        "timestamp": 1637619602
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120989\">@nnethercote</span> could you post the example where the drop flags were useless? I'm surprised that drop elaboration would emit them in the first place.</p>",
        "id": 262386216,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1637619876
    },
    {
        "content": "<p><code>_199</code>, <code>_200</code>, <code>_201</code>, and <code>_202</code> are all useless:</p>\n<p><a href=\"/user_uploads/4715/7yiVg-T1iOAXwaa3uVKyEs8U/counts.mir\">counts.mir</a></p>",
        "id": 262386520,
        "sender_full_name": "nnethercote",
        "timestamp": 1637620063
    },
    {
        "content": "<p>In each case, there is one BB where the drop flag is assigned true and then shortly after assigned false. All other assignments are false.</p>",
        "id": 262386601,
        "sender_full_name": "nnethercote",
        "timestamp": 1637620089
    },
    {
        "content": "<p>Here's the Rust code:</p>\n<p><a href=\"/user_uploads/4715/F6hAmdNA_rwtuf7_VcPDqRnq/counts.rs\">counts.rs</a></p>",
        "id": 262386744,
        "sender_full_name": "nnethercote",
        "timestamp": 1637620192
    },
    {
        "content": "<p>I'm compiling with <code>rustc counts.rs --emit=mir</code></p>",
        "id": 262386763,
        "sender_full_name": "nnethercote",
        "timestamp": 1637620202
    },
    {
        "content": "<p>It may well be that \"make drop flag insertion smarter\" is the right path forward here, rather than cleaning up the mess afterwards</p>",
        "id": 262386864,
        "sender_full_name": "nnethercote",
        "timestamp": 1637620246
    },
    {
        "content": "<p>Thanks! I'm on my phone now but I'll investigate it later. Part of the core function of drop elaboration is to eliminate useless drops, so it shouldn't be doing that. I expected to be outputting some useless stores to drop flags (since tracking that while doing everything else is hard, but cleaning up later is easy)</p>",
        "id": 262387227,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1637620440
    },
    {
        "content": "<p>Ok, thanks. It wasn't quite as obvious that these drops were useless before I did my DSE pass, which eliminated the <code>true</code> assignments.</p>",
        "id": 262387400,
        "sender_full_name": "nnethercote",
        "timestamp": 1637620512
    },
    {
        "content": "<p>Well the theory behind drop elaboration is that if a variable is known to be moved from (or known not to be moved from) along all possible code paths, we won't emit any drop flags at all. It could be that there's some optimization in between drop elaboration and your DSE pass that makes this true, or there might be some imprecision in drop elaboration.</p>",
        "id": 262388124,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1637620991
    },
    {
        "content": "<p>Looks like the former. I just looked at <code>mir_dump/counts.do_main.003-005.ElaborateDrops.after.mir</code> (where the drop flags are named <code>_255</code>..<code>_260</code>) and things look very different there. All the drop flags are set to <code>true</code> in some BBs and <code>false</code> in others and there are no BBs where a single drop flag is set twice.</p>",
        "id": 262393440,
        "sender_full_name": "nnethercote",
        "timestamp": 1637624591
    },
    {
        "content": "<p>Where is your DSE pass in the optimization pipeline currently?</p>",
        "id": 262394705,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1637625429
    },
    {
        "content": "<p>Right at the end, after DeduplicateBlocks</p>",
        "id": 262397752,
        "sender_full_name": "nnethercote",
        "timestamp": 1637627617
    },
    {
        "content": "<blockquote>\n<p>All the drop flags are set to true in some BBs and false in others and there are no BBs where a single drop flag is set twice</p>\n</blockquote>\n<p>Looking again, I was wrong about that. Still, things do look quite different immediately after <code>ElaborateDrops</code>.</p>",
        "id": 262502791,
        "sender_full_name": "nnethercote",
        "timestamp": 1637696126
    },
    {
        "content": "<p>Ah, I see <code>SimplifyCfg</code> runs multiple times. The <code>003-010.SimplifyCfg-elaborate-drops</code> run is important for my test code. After that runs is when we see some BBs that assign multiple times to the same drop flag. So I think I could run the DSE any time after that. Doing it before the final <code>SimplifyCfg</code> pass might work well.</p>",
        "id": 262506856,
        "sender_full_name": "nnethercote",
        "timestamp": 1637698126
    },
    {
        "content": "<p>Is there an easy way to ask \"is this MIR operation a <code>_var = const true</code> or <code>_var = const false</code>? I'm finding the MIR types surprisingly deeply nested and hard to navigate</p>",
        "id": 262528654,
        "sender_full_name": "nnethercote",
        "timestamp": 1637709915
    },
    {
        "content": "<p>ATM I have this and it's still not specific enough</p>\n<div class=\"codehilite\"><pre><span></span><code>if let Rvalue::Use(Operand::Constant(box Constant { literal: ConstantKind::Ty(..), .. })) = rval\n</code></pre></div>",
        "id": 262528759,
        "sender_full_name": "nnethercote",
        "timestamp": 1637709984
    },
    {
        "content": "<p>Here's what I ended up with:</p>\n<div class=\"codehilite\"><pre><span></span><code>    fn visit_assign(&amp;mut self, place: &amp;Place&lt;&#39;tcx&gt;, rval: &amp;Rvalue&lt;&#39;tcx&gt;, _loc: Location) {\n        // njn: currently restricting to constants, could be more expansive\n        if place.projection.is_empty() {\n            if let Rvalue::Use(Operand::Constant(box Constant { literal: ConstantKind::Ty(ty::Const { val: ty::ConstKind::Value(ConstValue::Scalar(Scalar::Int\n(scalar_int))), .. }), .. })) = rval {\n                match scalar_int {\n                    &amp;ScalarInt::FALSE =&gt; eprintln!(&quot;FALSE&quot;),\n                    &amp;ScalarInt::TRUE =&gt; eprintln!(&quot;TRUE&quot;),\n                    _ =&gt; eprintln!(&quot;OTHER&quot;),\n                }\n            }\n        }\n        eprintln!(&quot;  {:?} = {:?}&quot;, place.local, rval);\n    }\n</code></pre></div>",
        "id": 262529752,
        "sender_full_name": "nnethercote",
        "timestamp": 1637710813
    },
    {
        "content": "<p>It works, but seems very clunky.</p>",
        "id": 262529768,
        "sender_full_name": "nnethercote",
        "timestamp": 1637710827
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 262529774,
        "sender_full_name": "nnethercote",
        "timestamp": 1637710838
    },
    {
        "content": "<p>Ok, I have a draft of this pass working. It successfully removes the drop flags that are always <code>false</code> and changes the <code>switchInt</code>s on these flags to <code>goto</code> statements. I also moved it just after <code>RemoveNoopLandingPads</code>, which means that <code>SimplifyCfg</code> runs after it and removes the basic blocks that end up containing just a single <code>goto</code>, and <code>SimplifyLocals</code> also runs after it and removes the dead locals. It passes tests.</p>",
        "id": 262547556,
        "sender_full_name": "nnethercote",
        "timestamp": 1637730966
    },
    {
        "content": "<p>Although it does more than before, the bad news is that the MIR reduction is still small enough (less than 1%) that it doesn't have a meaningful effect on performance <span aria-label=\"frown\" class=\"emoji emoji-1f641\" role=\"img\" title=\"frown\">:frown:</span></p>",
        "id": 262547577,
        "sender_full_name": "nnethercote",
        "timestamp": 1637731021
    },
    {
        "content": "<p>Is that true in both debug and release?</p>",
        "id": 262623299,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1637777478
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120989\">nnethercote</span> <a href=\"#narrow/stream/189540-t-compiler.2Fwg-mir-opt/topic/Dead.20Store.20Elimination/near/262547556\">said</a>:</p>\n<blockquote>\n<p>Ok, I have a draft of this pass working. It successfully removes the drop flags that are always <code>false</code> and changes the <code>switchInt</code>s on these flags to <code>goto</code> statements. I also moved it just after <code>RemoveNoopLandingPads</code>, which means that <code>SimplifyCfg</code> runs after it and removes the basic blocks that end up containing just a single <code>goto</code>, and <code>SimplifyLocals</code> also runs after it and removes the dead locals. It passes tests.</p>\n</blockquote>\n<p>Const propagation should do some of this already, although it's intra-block only IIRC. That might be part of why you're not seeing the changes you hoped for.</p>",
        "id": 262625046,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1637778482
    },
    {
        "content": "<blockquote>\n<p>Is that true in both debug and release?</p>\n</blockquote>\n<p>Yes. MIR reduction seems slightly higher in debug.</p>",
        "id": 262641237,
        "sender_full_name": "nnethercote",
        "timestamp": 1637788529
    },
    {
        "content": "<blockquote>\n<p>Const propagation should do some of this already, although it's intra-block only IIRC. That might be part of why you're not seeing the changes you hoped for.</p>\n</blockquote>\n<p>It runs before my new pass. My new pass does exactly what I expected it to, it's just the effect is smaller overall than I'd hoped.</p>",
        "id": 262641351,
        "sender_full_name": "nnethercote",
        "timestamp": 1637788624
    }
]