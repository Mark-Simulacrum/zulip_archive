[
    {
        "content": "<p>Hello everyone,</p>\n<p>I hope somebody can help me with this :) I'm a master's student and I'm quite new to Rust, especially as far as the compiler itself is concerned. Currently, I'm writing my thesis on testing with Rust and I'd like to instrument Rust programs and insert additional function calls in certain branches (e.g., after if's) that trace the execution of a branch along with additional information. For this, I need the condition expressions to be atomic, which is why MIR seems to me to be most suitable.</p>\n<p>From this <a href=\"https://zulip-archive.rust-lang.org/stream/182449-t-compiler/help/topic/Modifying.20the.20MIR.20of.20a.20function.20from.20rustc_driver.html\">archive post</a>, I learned that I can modify  MIR and pass the modified version back to the compiler. So what I do is run the compiler and register my own function where I modify the MIR of a function body:</p>\n<div class=\"codehilite\"><pre><span></span><code>const CUSTOM_OPT_MIR: for&lt;&#39;tcx&gt; fn(_: TyCtxt&lt;&#39;tcx&gt;, _: DefId) -&gt; &amp;&#39;tcx Body&lt;&#39;tcx&gt; = |tcx, def| {\n    let opt_mir = rustc_interface::DEFAULT_QUERY_PROVIDERS\n        .borrow()\n        .optimized_mir;\n    let mut body = opt_mir(tcx, def).clone();\n\n    let mut mir_visitor = MirVisitor { tcx };\n\n    mir_visitor.visit_body(&amp;mut body);\n    tcx.arena.alloc(body)\n};\n\nstruct CompilerCallbacks;\n\nimpl rustc_driver::Callbacks for CompilerCallbacks {\n    fn config(&amp;mut self, _config: &amp;mut Config) {\n        _config.override_queries = Some(|session, local, external| {\n            local.optimized_mir = CUSTOM_OPT_MIR;\n        });\n    }\n}\n\nfn main() {\n    // define args and stuff\n\n    let mut callbacks = CompilerCallbacks {};\n    rustc_driver::RunCompiler::new(&amp;args, &amp;mut callbacks)\n        .run()\n        .unwrap();\n}\n</code></pre></div>\n<p>Now, this seems to work. In my MirVisitor, I want to insert a function call at some point. Let's assume I have the following program I try to instrument and a dummy tracing function:</p>\n<div class=\"codehilite\"><pre><span></span><code>use\nmod monitor {\n    pub fn trace() {\n        // do something\n    }\n}\n\nfn main() {\n    let inputs: Vec&lt;u64&gt; = std::env::args()\n        .map(|a| a.parse::&lt;u64&gt;().unwrap())\n        .take(2)\n        .collect();\n    let x = *inputs.get(0).unwrap();\n    let y = *inputs.get(1).unwrap();\n\n    if x &lt; y {\n        println!(&quot;x &lt; y&quot;);\n    } else {\n        println!(&quot;x &gt;= y&quot;);\n    }\n}\n</code></pre></div>\n<p>The relevant basic block in the MIR of the main function looks like this: </p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>bb10: {\n        _12 = (*_13);\n        _19 = _6;\n        _20 = _12;\n        _18 = Lt(move _19, move _20);\n        switchInt(move _18) -&gt; [false: bb13, otherwise: bb11];\n    }\n</code></pre></div>\n<p>Now I want to call the monitor::trace function directly after that, on both control paths. A function call is a terminator, so I could insert a whole new basic block for each branch and let it point to the original descendent blocks, i.e.,</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>bb10: {\n        _12 = (*_13);\n        _19 = _6;\n        _20 = _12;\n        _18 = Lt(move _19, move _20);\n        switchInt(move _18) -&gt; [false: bb14, otherwise: bb15];\n    }\n\n\nbb14: {\n        _22 = monitor::trace() -&gt; [return: bb13, unwind: ...];\n    }\n\n\nbb15: {\n        _23 = monitor::trace() -&gt; [return: bb11, unwind: ...];\n    }\n</code></pre></div>\n<p>I understand that I will also need to add the locals, however, I don't even know how to create such an artificial function call programmatically in the first place. A part of the <a href=\"https://doc.rust-lang.org/stable/nightly-rustc/rustc_middle/mir/terminator/struct.Terminator.html\">Terminator</a> struct is a reference (ConstantKind::Ty). Hence, the basic block I initialize does not live long enough to be passed back to the compiler :( </p>\n<p>Is there a way to implement this idea anyway? Maybe in a different way? Note that I don't just want to trace coverage, but also make computations based on the runtime values used in condition expressions and so on. It seems like a MirPass could achieve something like this. However, as far as I understand, to apply my own MirPass logic, I'd have to build a custom version of the compiler, which I'd like to avoid.</p>",
        "id": 259434717,
        "sender_full_name": "Vsevolod Tymofyeyev",
        "timestamp": 1635446886
    },
    {
        "content": "<blockquote>\n<p>However, as far as I understand, to apply my own MirPass logic, I'd have to build a custom version of the compiler, which I'd like to avoid.</p>\n</blockquote>\n<p>there is no difference between a MirPass and \"modify MIR and pass the modified version back to the compiler.\", so you don't gain anything by using a MirPass.</p>",
        "id": 259444810,
        "sender_full_name": "oli",
        "timestamp": 1635451613
    },
    {
        "content": "<blockquote>\n<p>Is there a way to implement this idea anyway? Maybe in a different way?</p>\n</blockquote>\n<p>you got the right idea. just some details missing <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 259444895,
        "sender_full_name": "oli",
        "timestamp": 1635451663
    },
    {
        "content": "<blockquote>\n<p>Hence, the basic block I initialize does not live long enough to be passed back to the compiler <span aria-label=\"frown\" class=\"emoji emoji-1f641\" role=\"img\" title=\"frown\">:frown:</span> </p>\n</blockquote>\n<p>that is because you need 'tcx lifetimes, and you get those by using methods like <a href=\"https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/context/struct.TyCtxt.html#method.mk_unit\">https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/context/struct.TyCtxt.html#method.mk_unit</a> for the () type (and other mk_* functions for other types)</p>",
        "id": 259445022,
        "sender_full_name": "oli",
        "timestamp": 1635451712
    },
    {
        "content": "<blockquote>\n<p>Note that I don't just want to trace coverage, but also make computations based on the runtime values used in condition expressions and so on</p>\n</blockquote>\n<p>you can pass arguments to your trace functions, which I guess would be the main way to get that information. Injecting more MIR to do computations is going to be rather annoying I would guess. Instead you can write the logic in Rust and call those functions</p>",
        "id": 259445144,
        "sender_full_name": "oli",
        "timestamp": 1635451799
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> that's amazing! Indeed, I just had to use <code>mk_const</code>. Now it works seamlessly <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span> Thanks a lot!</p>",
        "id": 259457333,
        "sender_full_name": "Vsevolod Tymofyeyev",
        "timestamp": 1635458146
    }
]