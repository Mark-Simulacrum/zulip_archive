[
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/blob/6d246f0c8d3063fea86abbb65a824362709541ba/compiler/rustc_mir_transform/src/simplify_comparison_integral.rs#L162-L192\">https://github.com/rust-lang/rust/blob/6d246f0c8d3063fea86abbb65a824362709541ba/compiler/rustc_mir_transform/src/simplify_comparison_integral.rs#L162-L192</a></p>\n<p>This code iterates on the basic block's statements in reverse order to find <code>_3 = Eq(_4, const 1)</code>, but it doesn't stop at the first occurrence of <code>_3 = …</code> and instead continues the lookup until it finds <code>_3 = Eq(…, const …)</code>.</p>\n<p>Doesn't that mean that if <code>_3</code> is shadowed, then the pass will miscompile?</p>",
        "id": 262840499,
        "sender_full_name": "nox",
        "timestamp": 1637967331
    },
    {
        "content": "<p>It's trivial to fix, just want to doublecheck that my reading of the code was correct first, and to know if there is a way to write a test for that. My understanding is that the compiler won't produce such MIR anyway when compiling Rust code.</p>",
        "id": 262840577,
        "sender_full_name": "nox",
        "timestamp": 1637967423
    },
    {
        "content": "<p>Also, if <code>_4</code> is modified between the <code>Eq</code> and the <code>SwitchInt</code> terminator, that pass will misbehave again, right?</p>",
        "id": 262873266,
        "sender_full_name": "nox",
        "timestamp": 1638019706
    },
    {
        "content": "<p>Using <code>if</code> results in MIR always copying the source place, whereas <code>match</code> can be used to achieve miscompilation.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">i</span>: <span class=\"kt\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">i32</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">no</span>: <span class=\"kt\">bool</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">transmute</span><span class=\"p\">(</span><span class=\"kc\">false</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">is_the_answer</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"mi\">42</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"n\">is_the_answer</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">no</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">is_the_answer</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kc\">true</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">42</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kc\">false</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p><code>-O -Z mir-opt-level=0</code> gives:</p>\n<div class=\"codehilite\" data-code-language=\"GAS\"><pre><span></span><code>        <span class=\"nf\">xor</span>     <span class=\"no\">eax</span><span class=\"p\">,</span> <span class=\"no\">eax</span>\n        <span class=\"nf\">ret</span>\n</code></pre></div>\n<p>whereas <code>-O -Z mir-opt-level=1</code> gives:</p>\n<div class=\"codehilite\" data-code-language=\"GAS\"><pre><span></span><code>        <span class=\"nf\">xor</span>     <span class=\"no\">eax</span><span class=\"p\">,</span> <span class=\"no\">eax</span>\n        <span class=\"nf\">cmp</span>     <span class=\"no\">edi</span><span class=\"p\">,</span> <span class=\"mi\">42</span>\n        <span class=\"nf\">cmove</span>   <span class=\"no\">eax</span><span class=\"p\">,</span> <span class=\"no\">edi</span>\n        <span class=\"nf\">ret</span>\n</code></pre></div>",
        "id": 263111094,
        "sender_full_name": "fee1-dead",
        "timestamp": 1638259417
    },
    {
        "content": "<p>Thanks for the help <span class=\"user-mention\" data-user-id=\"361356\">@fee1-dead</span>! Will make a PR today.</p>",
        "id": 263114092,
        "sender_full_name": "nox",
        "timestamp": 1638261852
    },
    {
        "content": "<p>This showcases the \"looking for <code>_3 = Eq(…)</code> too far\" part, but what about my second question, about <code>_4</code> being modified between the <code>Eq</code> and the <code>SwitchInt</code>?</p>",
        "id": 263150332,
        "sender_full_name": "nox",
        "timestamp": 1638281737
    },
    {
        "content": "<p>Also, even if <code>_4</code> isn't modified, what happens if <code>_3</code> is actually used in a different block?</p>",
        "id": 263151019,
        "sender_full_name": "nox",
        "timestamp": 1638282004
    },
    {
        "content": "<p>the problem with _4 is that it is always copying, which I cannot seem to eliminate in the source code.</p>",
        "id": 263264809,
        "sender_full_name": "fee1-dead",
        "timestamp": 1638351825
    },
    {
        "content": "<p>So I'm probably right but there is no known way to trigger that misbehaviour from Rust code input, is that it?</p>",
        "id": 263269175,
        "sender_full_name": "nox",
        "timestamp": 1638354278
    },
    {
        "content": "<p>I don't think that's a sufficient condition for optimization soundness</p>",
        "id": 263275369,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1638357631
    },
    {
        "content": "<p>it should not cause miscompilation for <em>any</em> valid MIR, not just the ones that happened to get generated by the current frontend. A future optimization could change the input to this one and cause a miscompilation</p>",
        "id": 263275443,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1638357700
    },
    {
        "content": "<p>I 100% agree with that sentiment, but I don't know if there is infra to test that a MIR pass compiles stuff correctly with handcrafted MIR input</p>",
        "id": 263279949,
        "sender_full_name": "nox",
        "timestamp": 1638360597
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"312719\">@Xavier Denis</span> the reality is that today any valid MIR is a set exactly matching MIR generated by rustc for any valid Rust code.</p>",
        "id": 263280220,
        "sender_full_name": "nagisa",
        "timestamp": 1638360748
    },
    {
        "content": "<p>MIR does not have its own specification and I'm not seeing one such materializing anytime soon.</p>",
        "id": 263280258,
        "sender_full_name": "nagisa",
        "timestamp": 1638360783
    },
    {
        "content": "<p>well that's not exactly true though, various MIR optimizations transform the code in a significant manner</p>",
        "id": 263280279,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1638360804
    },
    {
        "content": "<p>(which in some ways is a good indication that MIR optimizations aren't really operating in a well defined space)</p>",
        "id": 263280292,
        "sender_full_name": "nagisa",
        "timestamp": 1638360819
    },
    {
        "content": "<p>and while there isn't a specification yet (though that's what Ferrocene is meant to be i believe)</p>",
        "id": 263280363,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1638360850
    },
    {
        "content": "<p>Yeah, SimplifyComparisonIntegral doesn't describe how it expects the code to look like, so anyone can change another pass and produce code that breaks that pass' invariants and cause a miscompile, right?</p>",
        "id": 263280366,
        "sender_full_name": "nox",
        "timestamp": 1638360850
    },
    {
        "content": "<p>I think we should make a best effort attempt at preserving 'semantics' of mir</p>",
        "id": 263280414,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1638360879
    },
    {
        "content": "<p>and there are some various simple properties we should guarantee of MIR, even today like: MIR should be well-typed and should borrow check</p>",
        "id": 263280575,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1638360980
    },
    {
        "content": "<p>Well, here's another thing, MIR doesn't always mean the same thing across the compilation pipeline ^^</p>",
        "id": 263280830,
        "sender_full_name": "nagisa",
        "timestamp": 1638361168
    },
    {
        "content": "<p>by “borrow check” I assume you mean the non-lexical borrow check analysis that we run on early MIR.</p>",
        "id": 263280856,
        "sender_full_name": "nagisa",
        "timestamp": 1638361195
    },
    {
        "content": "<p>MIR is not suitable for that analysis after drop elaboration/borrowck runs to the best of my knowledge.</p>",
        "id": 263280945,
        "sender_full_name": "nagisa",
        "timestamp": 1638361231
    },
    {
        "content": "<p>Which in some ways might warrant giving it a different name. There were some suggestions for introducing a LIR in the past.</p>",
        "id": 263281251,
        "sender_full_name": "nagisa",
        "timestamp": 1638361431
    },
    {
        "content": "<p>whether the analysis as implemented breaks for technical reasons is one thing</p>",
        "id": 263281568,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1638361584
    },
    {
        "content": "<p>but I would find it quite worrying if it broke on a <em>semantic</em> level</p>",
        "id": 263281588,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1638361596
    },
    {
        "content": "<p>I feel like the rules should still apply 'on paper', no?</p>",
        "id": 263281651,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1638361628
    },
    {
        "content": "<p>if they don't then that would mean that post-opt mir could include aliased <code>&amp;mut</code> or invalid pointers which would mean that rust's memory safety flies out the window</p>",
        "id": 263281757,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1638361686
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123586\">nagisa</span> <a href=\"#narrow/stream/189540-t-compiler.2Fwg-mir-opt/topic/SimplifyComparisonIntegral.20Assign.20lookup.20is.20overzealous/near/263280830\">said</a>:</p>\n<blockquote>\n<p>Well, here's another thing, MIR doesn't always mean the same thing across the compilation pipeline ^^</p>\n</blockquote>\n<p>also what do you mean by this?</p>",
        "id": 263281863,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1638361777
    },
    {
        "content": "<p>MIR should have consistent semantics, we just use a few different dialects</p>",
        "id": 263281945,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1638361807
    },
    {
        "content": "<p>(ie poly/mono morphized mir, (de) aggregated mir, etc...)</p>",
        "id": 263282010,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1638361840
    },
    {
        "content": "<p>Only one of those dialects is suitable for borrowck. borrowck requires MIR to be in a certain shape and this shape is not preserved past a certain point in the pipeline.</p>",
        "id": 263282114,
        "sender_full_name": "nagisa",
        "timestamp": 1638361919
    },
    {
        "content": "<p>In other words borrow-checkable is not a property of MIR proper.</p>",
        "id": 263282214,
        "sender_full_name": "nagisa",
        "timestamp": 1638361971
    },
    {
        "content": "<p>Once lifetime erasure occurs we certainly can't do borrowck, right? IIRC that happens while it is still \"MIR\"</p>",
        "id": 263282963,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638362387
    },
    {
        "content": "<p>At which point is MIR monomorphized btw?</p>",
        "id": 263283214,
        "sender_full_name": "nox",
        "timestamp": 1638362524
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312719\">Xavier Denis</span> <a href=\"#narrow/stream/189540-t-compiler.2Fwg-mir-opt/topic/SimplifyComparisonIntegral.20Assign.20lookup.20is.20overzealous/near/263281757\">said</a>:</p>\n<blockquote>\n<p>if they don't then that would mean that post-opt mir could include aliased <code>&amp;mut</code> or invalid pointers which would mean that rust's memory safety flies out the window</p>\n</blockquote>\n<p>I think the way this works is that once you pass the point where borrow checking is possible, you are limited to optimizations that don't introduce reads to pointers or other things that aren't validated by the input MIR</p>",
        "id": 263283276,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638362549
    },
    {
        "content": "<blockquote>\n<p>At which point is MIR monomorphized btw?</p>\n</blockquote>\n<p>Never. Codegen does this on the fly</p>",
        "id": 263283355,
        "sender_full_name": "oli",
        "timestamp": 1638362594
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"124288\">@oli</span>, for a second I thought my understanding was completely wrong <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 263283416,
        "sender_full_name": "nox",
        "timestamp": 1638362630
    },
    {
        "content": "<blockquote>\n<p>Once lifetime erasure occurs we certainly can't do borrowck, right? IIRC that happens while it is still \"MIR\"</p>\n</blockquote>\n<p>Lifetimes are erased before MIR is built. Mir borrowck figures them out all anew</p>",
        "id": 263284313,
        "sender_full_name": "oli",
        "timestamp": 1638363059
    },
    {
        "content": "<p>After mir borrowck MIR only needs to satisfy Rust's borrowing rules dynamically. Basically miri is the current \"spec\"</p>",
        "id": 263284437,
        "sender_full_name": "oli",
        "timestamp": 1638363124
    },
    {
        "content": "<p>I think you can replace all references by pointers in mir and nothing changes</p>",
        "id": 263284490,
        "sender_full_name": "oli",
        "timestamp": 1638363151
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> MIR spec discussions xD</p>",
        "id": 263284520,
        "sender_full_name": "oli",
        "timestamp": 1638363174
    },
    {
        "content": "<p>So anyway, are there MIR-only tests, where the input itself is MIR code?</p>",
        "id": 263284763,
        "sender_full_name": "nox",
        "timestamp": 1638363306
    },
    {
        "content": "<p>Nope</p>",
        "id": 263290586,
        "sender_full_name": "oli",
        "timestamp": 1638365854
    },
    {
        "content": "<p>But we want that.</p>",
        "id": 263290611,
        "sender_full_name": "oli",
        "timestamp": 1638365866
    },
    {
        "content": "<p>Just that no one got around to writing a parser</p>",
        "id": 263290727,
        "sender_full_name": "oli",
        "timestamp": 1638365907
    },
    {
        "content": "<p>There are other issues as well afaik such as resolution / interning etc...</p>",
        "id": 263305652,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1638371849
    },
    {
        "content": "<p>well... we could avoid that if we made a parser that allows parsing regular Rust code but \"simply\" switches to a different parser in certain functions. Basically extend the Rust language to support a much simpler system that parses directly to MIR</p>",
        "id": 263306412,
        "sender_full_name": "oli",
        "timestamp": 1638372090
    },
    {
        "content": "<p>Should the test for that bug be a normal unit test that checks that the return value of <code>foo(42)</code> is 0?</p>",
        "id": 263319013,
        "sender_full_name": "nox",
        "timestamp": 1638376895
    },
    {
        "content": "<p>MIR definitely has a semantics, but it is indeed not very clearly specified currently -- 'whatever Miri does' is a reasonable approximation in many cases</p>",
        "id": 264168826,
        "sender_full_name": "RalfJ",
        "timestamp": 1638976454
    },
    {
        "content": "<p>regarding the MIR semantic rules changing, that is what I am tracking at <a href=\"https://github.com/rust-lang/rust/issues/86299\">https://github.com/rust-lang/rust/issues/86299</a>. I think we should make this explicit with some <code>enum</code> in the MIR body and each pass ensuring it runs on MIR of the right kind. but right now we don't have very fundamental changes in what the same MIR means, I think.</p>",
        "id": 264168959,
        "sender_full_name": "RalfJ",
        "timestamp": 1638976502
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123586\">nagisa</span> <a href=\"#narrow/stream/189540-t-compiler.2Fwg-mir-opt/topic/SimplifyComparisonIntegral.20Assign.20lookup.20is.20overzealous/near/263282214\">said</a>:</p>\n<blockquote>\n<p>In other words borrow-checkable is not a property of MIR proper.</p>\n</blockquote>\n<p>borrow-checkable is not a property of MIR semantics though. basically there is a certain kind of 'normal form' that MIR must be in for the borrowck analysis to be maximally effective, but MIR outside that normal form still follows the exact same rules -- the analysis is just not smart enough to do a good job on such MIR. (ideally the analysis would still be <em>correct</em>, and just reject too many things. I am not sure if that is the case.)</p>",
        "id": 264169212,
        "sender_full_name": "RalfJ",
        "timestamp": 1638976599
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/189540-t-compiler.2Fwg-mir-opt/topic/SimplifyComparisonIntegral.20Assign.20lookup.20is.20overzealous/near/263290727\">said</a>:</p>\n<blockquote>\n<p>Just that no one got around to writing a parser</p>\n</blockquote>\n<p>that would be a large amount of work. Does this need a MCP? Opening an issue to rust-lang/rust would be a good idea, I will do that...</p>",
        "id": 264188912,
        "sender_full_name": "fee1-dead",
        "timestamp": 1638984193
    },
    {
        "content": "<p>We have <a href=\"https://github.com/rust-lang/miri/issues/196\">https://github.com/rust-lang/miri/issues/196</a> where <span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> suggests that we basically write MIR with fake Rust code that won't pass regular compilation, but that can be trivially converted to MIR</p>",
        "id": 264189532,
        "sender_full_name": "oli",
        "timestamp": 1638984435
    },
    {
        "content": "<p>heh yeah</p>",
        "id": 264189602,
        "sender_full_name": "eddyb",
        "timestamp": 1638984470
    },
    {
        "content": "<p>basically a straightforward AST/HIR -&gt; MIR lowering that still relies on name resolution and whatnot (I guess we don't need typeck since all the types would be explicit but we do need some amount of name resolution)</p>",
        "id": 264189744,
        "sender_full_name": "eddyb",
        "timestamp": 1638984534
    },
    {
        "content": "<p>(or we could generate inference variables where necessary and run the MIR typeck used by borrowck :P)</p>",
        "id": 264189814,
        "sender_full_name": "eddyb",
        "timestamp": 1638984562
    },
    {
        "content": "<p>How would it be possible to generate arbitrary control flow including irreducible control flow?</p>",
        "id": 264189887,
        "sender_full_name": "bjorn3",
        "timestamp": 1638984591
    },
    {
        "content": "<p>I think the idea is to not allow arbitrary <code>if</code> block contents, but just work with something like goto and labels</p>",
        "id": 264190105,
        "sender_full_name": "oli",
        "timestamp": 1638984647
    },
    {
        "content": "<p>definitely would have to be a complete CFG</p>",
        "id": 264190174,
        "sender_full_name": "eddyb",
        "timestamp": 1638984676
    },
    {
        "content": "<p>Rust doesn't have a goto statement. Maybe it could be done like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"o\">'</span><span class=\"na\">a</span>: <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">break</span><span class=\"w\"> </span><span class=\"nl\">'b</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">break</span><span class=\"w\"> </span><span class=\"nl\">'c</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"o\">'</span><span class=\"na\">b</span>: <span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"o\">'</span><span class=\"na\">c</span>: <span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 264190269,
        "sender_full_name": "bjorn3",
        "timestamp": 1638984710
    },
    {
        "content": "<p>like what I imagine is taking the current MIR output and making <em>minimal</em> changes to get it to be valid Rust <em>syntax</em></p>",
        "id": 264190270,
        "sender_full_name": "eddyb",
        "timestamp": 1638984711
    },
    {
        "content": "<p>We could also <em>just</em> add <code>Goto</code> to the AST and reject it later ;)</p>",
        "id": 264190400,
        "sender_full_name": "fee1-dead",
        "timestamp": 1638984759
    },
    {
        "content": "<p>I would not write <code>if</code>, I would write <code>SwitchInt</code></p>",
        "id": 264190412,
        "sender_full_name": "eddyb",
        "timestamp": 1638984763
    },
    {
        "content": "<p><code>match foo { true =&gt; break 'b, false =&gt; break 'c }</code>? The current <code>SwitchInt</code> syntax doesn't parse as rust.</p>",
        "id": 264190502,
        "sender_full_name": "bjorn3",
        "timestamp": 1638984813
    },
    {
        "content": "<p>Or even <code>Goto(\"'a\")</code>? AST would interpret it as a struct ctor</p>",
        "id": 264190570,
        "sender_full_name": "fee1-dead",
        "timestamp": 1638984837
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"361356\">fee1-dead</span> <a href=\"#narrow/stream/189540-t-compiler.2Fwg-mir-opt/topic/SimplifyComparisonIntegral.20Assign.20lookup.20is.20overzealous/near/264190570\">said</a>:</p>\n<blockquote>\n<p>Or even <code>Goto(\"'a\")</code>? AST would interpret it as a struct ctor</p>\n</blockquote>\n<p><code>Goto(block2)</code> is what I was imagining</p>",
        "id": 264190631,
        "sender_full_name": "eddyb",
        "timestamp": 1638984853
    },
    {
        "content": "<p>name resolution would have to not emit errors and just silently record a resolution if one exists, IMO</p>",
        "id": 264190705,
        "sender_full_name": "eddyb",
        "timestamp": 1638984883
    },
    {
        "content": "<p><code>Goto::&lt;'a&gt;</code></p>",
        "id": 264190725,
        "sender_full_name": "fee1-dead",
        "timestamp": 1638984890
    },
    {
        "content": "<p>tho you can do something even funnier and import a fake library</p>",
        "id": 264190731,
        "sender_full_name": "eddyb",
        "timestamp": 1638984894
    },
    {
        "content": "<p><code>break 'a</code> is the closest to a goto we have. It just requires jumping out of a block instead of into an arbitrary block.</p>",
        "id": 264190734,
        "sender_full_name": "bjorn3",
        "timestamp": 1638984894
    },
    {
        "content": "<p>existing labels won't work because of their name resolution semantics</p>",
        "id": 264190769,
        "sender_full_name": "eddyb",
        "timestamp": 1638984909
    },
    {
        "content": "<p>you need something like <code>block1 = {...}; block2 = {...}; ...</code></p>",
        "id": 264190804,
        "sender_full_name": "eddyb",
        "timestamp": 1638984922
    },
    {
        "content": "<p>Existing labels are already required to be unique within a function.</p>",
        "id": 264190842,
        "sender_full_name": "bjorn3",
        "timestamp": 1638984939
    },
    {
        "content": "<p>Looks like it is just a warning.</p>",
        "id": 264191094,
        "sender_full_name": "bjorn3",
        "timestamp": 1638985014
    },
    {
        "content": "<p>what I mean is that they resolve lexically so you can't know what... well I guess you can do your own resolution nvm</p>",
        "id": 264191384,
        "sender_full_name": "eddyb",
        "timestamp": 1638985116
    },
    {
        "content": "<p>Just opened <a href=\"https://github.com/rust-lang/rust/issues/91669\">#91669</a>, since mir-opt tests will also benefit from this.</p>",
        "id": 264191436,
        "sender_full_name": "fee1-dead",
        "timestamp": 1638985138
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119009\">eddyb</span> <a href=\"#narrow/stream/189540-t-compiler.2Fwg-mir-opt/topic/SimplifyComparisonIntegral.20Assign.20lookup.20is.20overzealous/near/264190731\">said</a>:</p>\n<blockquote>\n<p>tho you can do something even funnier and import a fake library</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> imagine building MIR up as a CTFE combinator library lol</p>",
        "id": 264191451,
        "sender_full_name": "eddyb",
        "timestamp": 1638985144
    },
    {
        "content": "<p>oh no XD</p>",
        "id": 264191517,
        "sender_full_name": "oli",
        "timestamp": 1638985172
    },
    {
        "content": "<p>Even better allow programs running in miri to use the compiler interfaces used to build MIR!</p>",
        "id": 264191631,
        "sender_full_name": "bjorn3",
        "timestamp": 1638985208
    },
    {
        "content": "<p>How would we separate <code>move _place</code>s from copies?</p>",
        "id": 264191678,
        "sender_full_name": "fee1-dead",
        "timestamp": 1638985229
    },
    {
        "content": "<p><code>move!()</code> or <code>copy!()</code>?</p>",
        "id": 264191713,
        "sender_full_name": "bjorn3",
        "timestamp": 1638985250
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/189540-t-compiler.2Fwg-mir-opt/topic/SimplifyComparisonIntegral.20Assign.20lookup.20is.20overzealous/near/264191631\">said</a>:</p>\n<blockquote>\n<p>Even better allow programs running in miri to use the compiler interfaces used to build MIR!</p>\n</blockquote>\n<p><span aria-label=\"head bandage\" class=\"emoji emoji-1f915\" role=\"img\" title=\"head bandage\">:head_bandage:</span>  <span aria-label=\"explosion\" class=\"emoji emoji-1f4a5\" role=\"img\" title=\"explosion\">:explosion:</span></p>",
        "id": 264191714,
        "sender_full_name": "oli",
        "timestamp": 1638985251
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"361356\">fee1-dead</span> <a href=\"#narrow/stream/189540-t-compiler.2Fwg-mir-opt/topic/SimplifyComparisonIntegral.20Assign.20lookup.20is.20overzealous/near/264191678\">said</a>:</p>\n<blockquote>\n<p>How would we separate <code>move _place</code>s from copies?</p>\n</blockquote>\n<p>I mean those are <code>Move(place)</code> and <code>Copy(place)</code></p>",
        "id": 264191801,
        "sender_full_name": "eddyb",
        "timestamp": 1638985298
    },
    {
        "content": "<p>the <code>move</code> keyword is just cutesy</p>",
        "id": 264191817,
        "sender_full_name": "eddyb",
        "timestamp": 1638985310
    },
    {
        "content": "<p>That would be ambiguous with <code>Rvalue::Aggregate</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code>$ <span class=\"nb\">echo</span> <span class=\"s1\">'pub struct Foo(u8); pub fn bar(arg: u8) -&gt; Foo { Foo(arg) }'</span> <span class=\"p\">|</span> rustc +nightly - -Zdump-mir<span class=\"o\">=</span>bar --crate-type lib\n$ cat mir_dump/rust_out.bar.001-000.CheckPackedRef.before.mir\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// MIR for `bar` before CheckPackedRef</span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">bar</span><span class=\"p\">(</span><span class=\"n\">_1</span>: <span class=\"kt\">u8</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">debug</span><span class=\"w\"> </span><span class=\"n\">arg</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">_1</span><span class=\"p\">;</span><span class=\"w\">                     </span><span class=\"c1\">// in scope 0 at &lt;anon&gt;:1:32: 1:35</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">_0</span>: <span class=\"nc\">Foo</span><span class=\"p\">;</span><span class=\"w\">                     </span><span class=\"c1\">// return place in scope 0 at &lt;anon&gt;:1:44: 1:47</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">_2</span>: <span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\">                      </span><span class=\"c1\">// in scope 0 at &lt;anon&gt;:1:54: 1:57</span>\n\n<span class=\"w\">    </span><span class=\"n\">bb0</span>: <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">StorageLive</span><span class=\"p\">(</span><span class=\"n\">_2</span><span class=\"p\">);</span><span class=\"w\">                 </span><span class=\"c1\">// scope 0 at &lt;anon&gt;:1:54: 1:57</span>\n<span class=\"w\">        </span><span class=\"n\">_2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">_1</span><span class=\"p\">;</span><span class=\"w\">                         </span><span class=\"c1\">// scope 0 at &lt;anon&gt;:1:54: 1:57</span>\n<span class=\"w\">        </span><span class=\"n\">_0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"p\">(</span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"n\">_2</span><span class=\"p\">);</span><span class=\"w\">               </span><span class=\"c1\">// scope 0 at &lt;anon&gt;:1:50: 1:58</span>\n<span class=\"w\">        </span><span class=\"n\">StorageDead</span><span class=\"p\">(</span><span class=\"n\">_2</span><span class=\"p\">);</span><span class=\"w\">                 </span><span class=\"c1\">// scope 0 at &lt;anon&gt;:1:57: 1:58</span>\n<span class=\"w\">        </span><span class=\"k\">return</span><span class=\"p\">;</span><span class=\"w\">                          </span><span class=\"c1\">// scope 0 at &lt;anon&gt;:1:60: 1:60</span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 264192812,
        "sender_full_name": "bjorn3",
        "timestamp": 1638985707
    },
    {
        "content": "<p>Say there is a struct called <code>Move</code>. Does <code>_0 = Move(_2)</code> mean a move of <code>_2</code> or a copy of <code>_2</code> wrapped in the <code>Move</code> struct?</p>",
        "id": 264192903,
        "sender_full_name": "bjorn3",
        "timestamp": 1638985758
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/189540-t-compiler.2Fwg-mir-opt/topic/SimplifyComparisonIntegral.20Assign.20lookup.20is.20overzealous/near/264192903\">said</a>:</p>\n<blockquote>\n<p>Say there is a struct called <code>Move</code>.</p>\n</blockquote>\n<p>never say that! <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span> But yeah, all of this would be perma-unstable as we would only use this for testing.</p>",
        "id": 264194013,
        "sender_full_name": "fee1-dead",
        "timestamp": 1638986254
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/189540-t-compiler.2Fwg-mir-opt/topic/SimplifyComparisonIntegral.20Assign.20lookup.20is.20overzealous/near/264191713\">said</a>:</p>\n<blockquote>\n<p><code>move!()</code> or <code>copy!()</code>?</p>\n</blockquote>\n<p>How about just add a <code>mir!</code> builtin macro and do all the parsing there</p>",
        "id": 264385178,
        "sender_full_name": "Gary Guo",
        "timestamp": 1639094405
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/189540-t-compiler.2Fwg-mir-opt/topic/SimplifyComparisonIntegral.20Assign.20lookup.20is.20overzealous/near/264191631\">said</a>:</p>\n<blockquote>\n<p>Even better allow programs running in miri to use the compiler interfaces used to build MIR!</p>\n</blockquote>\n<p>finally, <code>eval</code> in Rust :D</p>",
        "id": 264394043,
        "sender_full_name": "RalfJ",
        "timestamp": 1639101216
    }
]