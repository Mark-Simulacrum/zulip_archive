[
    {
        "content": "<p>I actually talked to Erick Tryzelaar about this. I definitely want to see it ported to Fuchsia.</p>",
        "id": 135936646,
        "sender_full_name": "Joshua Liebow-Feeser",
        "timestamp": 1539731603
    },
    {
        "content": "<p>awesome, thanks</p>",
        "id": 135972793,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1539783091
    },
    {
        "content": "<p>the API is potentially RFC-able. just a trait I've implemented for some of the core types: <a href=\"https://docs.rs/zeroize/latest/zeroize/trait.Zeroize.html\" target=\"_blank\" title=\"https://docs.rs/zeroize/latest/zeroize/trait.Zeroize.html\">https://docs.rs/zeroize/latest/zeroize/trait.Zeroize.html</a></p>",
        "id": 135972901,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1539783180
    },
    {
        "content": "<p>if it got into <code>std</code>, there wouldn't be any need for OS-by-OS support, since it could provide a stable API for an underlying LLVM intrinsic (<code>volatile_set_memory</code> in this case)</p>",
        "id": 135972944,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1539783224
    },
    {
        "content": "<p>Yeah, that sounds like the way to go.</p>",
        "id": 135986713,
        "sender_full_name": "Joshua Liebow-Feeser",
        "timestamp": 1539796603
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> do you have any thoughts regarding stabilizing <code>volatile_set_memory</code> with an API like <a href=\"https://docs.rs/zeroize/latest/zeroize/trait.Zeroize.html\" target=\"_blank\" title=\"https://docs.rs/zeroize/latest/zeroize/trait.Zeroize.html\">https://docs.rs/zeroize/latest/zeroize/trait.Zeroize.html</a></p>",
        "id": 135992162,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1539801459
    },
    {
        "content": "<p>well, <code>volatile_set_memory</code> that always sets things to 0</p>",
        "id": 135992174,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1539801474
    },
    {
        "content": "<p>even just a stable wrapper that does a volatile zero on a &amp;mut [u8] would be sufficient</p>",
        "id": 135992502,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1539801770
    },
    {
        "content": "<p>I don't have deep thoughts :)</p>",
        "id": 135996444,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539805882
    },
    {
        "content": "<p>it seems like a .. probably fine thing; I imagine there will be some objections that the API on <code>[u8]</code> is too specific, but I'm not sure what the more general API should look like</p>",
        "id": 135996457,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539805907
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> the <code>Zeroize</code> trait I linked above is an idea of what a more general API could look like. I guess the neat part is that much can be built out as a crate so long as there's some access to the intrinsic via core</p>",
        "id": 136000612,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1539810124
    },
    {
        "content": "<p>I think that the idea of adding a stable \"intrinsic primitive\" is pretty appealing, yes</p>",
        "id": 136001102,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539810627
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> so <code>std::ptr::write_volatile</code> has the volatile write semantics a \"zeroizer\" needs, but appears to require alignment. <code>std::ptr::write_unaligned</code> can perform unaligned writes, but they aren't volatile</p>",
        "id": 152120630,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545151286
    },
    {
        "content": "<p>I think the minimum viable primitive which could be used for a crate like <code>zeroize</code> but is also generally useful would be something like <code>std::ptr::write_unaligned_volatile</code> or <code>write_volatile_unaligned</code></p>",
        "id": 152120718,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545151334
    },
    {
        "content": "<p>interesting</p>",
        "id": 152134506,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1545163927
    },
    {
        "content": "<p>it seems like there is no clear reason to couple those two things</p>",
        "id": 152134516,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1545163938
    },
    {
        "content": "<p>this would be as a stable wrapper for <code>core::intrinsics::volatile_set_memory</code></p>",
        "id": 152136832,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545165875
    },
    {
        "content": "<p>which AFAIK has <code>write_unaligned_volatile</code> behavior</p>",
        "id": 152136881,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545165904
    },
    {
        "content": "<p>but perhaps I'm misunderstanding how one or more of these handle alignment</p>",
        "id": 152136910,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545165920
    },
    {
        "content": "<p>perhaps I can dig up some past discussion of this sort of thing</p>",
        "id": 152136932,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545165952
    },
    {
        "content": "<p>the use case is zeroing out arbitrary byte slices which are not necessarily aligned</p>",
        "id": 152136998,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545165983
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"132721\">@Tony Arcieri</span> a byte slice is always aligned since bytes have alignment 1.</p>",
        "id": 152137365,
        "sender_full_name": "briansmith",
        "timestamp": 1545166288
    },
    {
        "content": "<p>Other libraries may be different, but in <em>ring</em> if we wanted to zeroize things, we'd never need to do so in an unaligned way. It seems weird that that would be a requirement.</p>",
        "id": 152137494,
        "sender_full_name": "briansmith",
        "timestamp": 1545166374
    },
    {
        "content": "<p>Also, <code>write_volatile</code> is already <code>unsafe</code> so you could just cast the pointer to a <code>*mut u8</code> and it would work fine without any more <code>unsafe</code>.</p>",
        "id": 152137534,
        "sender_full_name": "briansmith",
        "timestamp": 1545166441
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133214\">@briansmith</span> so I was a bit confused by <code>write_volatile</code>'s documentation</p>",
        "id": 152137597,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545166477
    },
    {
        "content": "<p>namely the Safety section: <a href=\"https://doc.rust-lang.org/std/ptr/fn.write_volatile.html#safety\" target=\"_blank\" title=\"https://doc.rust-lang.org/std/ptr/fn.write_volatile.html#safety\">https://doc.rust-lang.org/std/ptr/fn.write_volatile.html#safety</a></p>",
        "id": 152137611,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545166502
    },
    {
        "content": "<p>and comments like this:</p>",
        "id": 152137626,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545166515
    },
    {
        "content": "<blockquote>\n<p>Note that even if T has size 0, the pointer must be non-NULL and properly aligned.</p>\n</blockquote>",
        "id": 152137628,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545166516
    },
    {
        "content": "<p>what does \"aligned\" mean in the context of a zero-sized type?</p>",
        "id": 152137667,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545166545
    },
    {
        "content": "<p>I assumed that meant \"word aligned\"</p>",
        "id": 152137673,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545166550
    },
    {
        "content": "<p>Maybe it it referring to things like <code>[u64; 0]</code>?</p>",
        "id": 152137734,
        "sender_full_name": "briansmith",
        "timestamp": 1545166570
    },
    {
        "content": "<p>which presumably has alignment 4 or 8 but size 0</p>",
        "id": 152137748,
        "sender_full_name": "briansmith",
        "timestamp": 1545166579
    },
    {
        "content": "<p>if <code>write_volatile</code> already does what I want, hallelujah</p>",
        "id": 152137758,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545166592
    },
    {
        "content": "<p>so if I have a variable-width byte slice, I could just iterate over it clearing it a byte-at-a-time?</p>",
        "id": 152137794,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545166636
    },
    {
        "content": "<p>If you have an arbitrary byte slice, you can't really do it any other way since it might not be properly aligned to be accessed any other way.</p>",
        "id": 152137897,
        "sender_full_name": "briansmith",
        "timestamp": 1545166739
    },
    {
        "content": "<p>yeah not looking for a different way, just wanting to confirm that has the intended semantics</p>",
        "id": 152137923,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545166764
    },
    {
        "content": "<p>Presumably you are getting the pointer that you pass to <code>write_volatile</code> from a reference.</p>",
        "id": 152137946,
        "sender_full_name": "briansmith",
        "timestamp": 1545166788
    },
    {
        "content": "<p>probably a reference to a slice.</p>",
        "id": 152137952,
        "sender_full_name": "briansmith",
        "timestamp": 1545166794
    },
    {
        "content": "<p>References are (assumed to be) always properly aligned so your pointer will always be properly aligned.</p>",
        "id": 152138009,
        "sender_full_name": "briansmith",
        "timestamp": 1545166808
    },
    {
        "content": "<p>FWIW, I still prefer the ISO C semantics for <code>volatile</code> where it is used to describe objects, not accesses to objects.</p>",
        "id": 152138197,
        "sender_full_name": "briansmith",
        "timestamp": 1545166984
    },
    {
        "content": "<p>well, if this is semantically correct... <a href=\"https://github.com/iqlusioninc/crates/pull/142/files\" target=\"_blank\" title=\"https://github.com/iqlusioninc/crates/pull/142/files\">https://github.com/iqlusioninc/crates/pull/142/files</a></p>",
        "id": 152159969,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545196398
    },
    {
        "content": "<p>not sure what else to say but \"wow\"</p>",
        "id": 152159988,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545196417
    },
    {
        "content": "<p><a href=\"/user_uploads/4715/g3yUTu18hxTFMO8s84KcVhn-/Screen-Shot-2018-12-18-at-9.12.47-PM.png\" target=\"_blank\" title=\"Screen-Shot-2018-12-18-at-9.12.47-PM.png\">Screen-Shot-2018-12-18-at-9.12.47-PM.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/4715/g3yUTu18hxTFMO8s84KcVhn-/Screen-Shot-2018-12-18-at-9.12.47-PM.png\" target=\"_blank\" title=\"Screen-Shot-2018-12-18-at-9.12.47-PM.png\"><img src=\"/user_uploads/4715/g3yUTu18hxTFMO8s84KcVhn-/Screen-Shot-2018-12-18-at-9.12.47-PM.png\"></a></div>",
        "id": 152159994,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545196425
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> so I was looking at the generated assembly from ^^^ PR... it does more or less what you'd expect on a byte slice: loops over it doing <code>mov</code> and setting each byte to 0</p>",
        "id": 152214312,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545254733
    },
    {
        "content": "<p>I totally plan on landing that PR, but I was looking at <code>volatile_set_memory</code> and it just calls <code>memset</code>, so I'm still wondering \"what would a stable API for (volatile) memset look like\"?</p>",
        "id": 152214394,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545254789
    },
    {
        "content": "<p>I could imagine in a future with specialization and a stable wrapper for that I could specialize handling of <code>&amp;[u8]</code> which so happens to be the main case I care about</p>",
        "id": 152214433,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545254837
    },
    {
        "content": "<p>the only difference really being that the stable API (<code>write_volatile</code>) writes \"one <code>T</code> worth\" of memory, and you'd prefer to have an <code>n</code> value, basically?</p>",
        "id": 152214910,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1545255315
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"132721\">@Tony Arcieri</span> I think it is OK for <code>volatile_set_memory</code> to just call memset as long as the IR indicates that the call cannot be removed. In general, what's really relevant is the IR, not the generated assembly.</p>",
        "id": 152215001,
        "sender_full_name": "briansmith",
        "timestamp": 1545255423
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> yep!</p>",
        "id": 152215014,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545255443
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133214\">@briansmith</span> I want memset!</p>",
        "id": 152215021,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545255451
    },
    {
        "content": "<p>the problem is <code>volatile_set_memory</code> isn't stable</p>",
        "id": 152215022,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545255458
    },
    {
        "content": "<p>the C equivalent of what I'd actually want is:</p>\n<div class=\"codehilite\"><pre><span></span>memset(dest, &#39;\\0&#39;, n);\nasm volatile (&quot;&quot; ::: &quot;memory&quot;);\n</pre></div>",
        "id": 152215164,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545255566
    },
    {
        "content": "<p>Ideally you'd want semantics that are like \"treat this as a volatile write unless something else would overwrite what it would write\"</p>",
        "id": 152215633,
        "sender_full_name": "briansmith",
        "timestamp": 1545255976
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> crazy idea: <code>set_volatile()</code> or <code>fill_volatile()</code> on the <code>slice</code> primitive</p>",
        "id": 152215647,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545256005
    },
    {
        "content": "<p>or <code>[u8]</code> specifically would be fine</p>",
        "id": 152215750,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545256112
    },
    {
        "content": "<p>It wouldn't be good to limit it only to <code>u8</code>. In fact most secret data probably shouldn't be in <code>u8</code> arrays.</p>",
        "id": 152215787,
        "sender_full_name": "briansmith",
        "timestamp": 1545256177
    },
    {
        "content": "<p><code>memset_s</code> I assume?</p>",
        "id": 152216254,
        "sender_full_name": "Alex Gaynor",
        "timestamp": 1545256649
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130046\">@Alex Gaynor</span> volatile memset, yeah</p>",
        "id": 152216534,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545256914
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133214\">@briansmith</span> yeah, <code>[u8]</code> was in the context of \"in a future Rust with specialization, I could specialize the implementation of <code>Zeroize</code> for <code>[u8]</code>\". good enough for my purposes but I'd agree a more general primitive would be better. instead of specializing a faster implementation just for <code>[u8]</code>, I could have something that's fast for all supported types</p>",
        "id": 152216667,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545257034
    },
    {
        "content": "<p>but yeah anyway, this is all a microoptimization. in the meantime I'll be moving forward with what I've got even if it's slower</p>",
        "id": 152217929,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545258315
    },
    {
        "content": "<p>getting rid of the yucky OS-specific API bindings would be worth it alone, but it's nice how easily this generalizes to all of the primitive number types</p>",
        "id": 152218041,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545258428
    },
    {
        "content": "<p>this was a bit surprising: <a href=\"https://github.com/iqlusioninc/crates/blob/d9ec89ada4e89b6c9a9333ff9c67c650a35455af/zeroize/src/lib.rs#L100\" target=\"_blank\" title=\"https://github.com/iqlusioninc/crates/blob/d9ec89ada4e89b6c9a9333ff9c67c650a35455af/zeroize/src/lib.rs#L100\">https://github.com/iqlusioninc/crates/blob/d9ec89ada4e89b6c9a9333ff9c67c650a35455af/zeroize/src/lib.rs#L100</a></p>",
        "id": 152218119,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545258495
    },
    {
        "content": "<p>the same macro works on <code>char</code> <span class=\"emoji emoji-1f62e\" title=\"open mouth\">:open_mouth:</span></p>",
        "id": 152218127,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545258510
    },
    {
        "content": "<p>not sure that's actually doing what I want</p>",
        "id": 152218129,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545258519
    },
    {
        "content": "<p>possibly doing something unsafe <span class=\"emoji emoji-1f605\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 152218143,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545258538
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"132721\">@Tony Arcieri</span> Couldn't you <code>impl Zeroize for T where T: Default</code>without any macro?</p>",
        "id": 152218507,
        "sender_full_name": "briansmith",
        "timestamp": 1545258920
    },
    {
        "content": "<p><code>Default</code> is implemented on things like <code>Vec&lt;T&gt;</code>, where this wouldn't work, would it?</p>",
        "id": 152218597,
        "sender_full_name": "Alex Gaynor",
        "timestamp": 1545258996
    },
    {
        "content": "<p>Good point.</p>",
        "id": 152218684,
        "sender_full_name": "briansmith",
        "timestamp": 1545259084
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133214\">@briansmith</span> haha, came across this thread where you seem to be asking the questions I'm curious about now <a href=\"https://internals.rust-lang.org/t/volatile-and-sensitive-memory/3188/24\" target=\"_blank\" title=\"https://internals.rust-lang.org/t/volatile-and-sensitive-memory/3188/24\">https://internals.rust-lang.org/t/volatile-and-sensitive-memory/3188/24</a></p>",
        "id": 152258116,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545314670
    },
    {
        "content": "<p>was looking specifically at this in the <code>write_volatile</code> docs</p>",
        "id": 152258151,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545314705
    },
    {
        "content": "<blockquote>\n<p>Memory accessed with read_volatile or write_volatile should not be accessed with non-volatile operations.</p>\n</blockquote>",
        "id": 152258157,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545314707
    },
    {
        "content": "<p>Now I better understand what you're getting at here:</p>\n<blockquote>\n<p>FWIW, I still prefer the ISO C semantics for <code>volatile</code> where it is used to describe objects, not accesses to objects.</p>\n</blockquote>",
        "id": 152258443,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545314921
    },
    {
        "content": "<p>Yes, I spent a significant amount of time trying this idea before. Note in particular that any movable type (i.e. basically all types) do have non-volatile accesses when they are moved.</p>",
        "id": 152274896,
        "sender_full_name": "briansmith",
        "timestamp": 1545329128
    },
    {
        "content": "<p>And, obviously, the same for <code>Copy</code></p>",
        "id": 152274906,
        "sender_full_name": "briansmith",
        "timestamp": 1545329143
    },
    {
        "content": "<p>yep, I already have a whole disclaimer in my README about that sort of thing</p>",
        "id": 152275986,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545330145
    },
    {
        "content": "<p>noting the <code>Pin</code> RFC</p>",
        "id": 152276034,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545330198
    },
    {
        "content": "<p>here's my WIP text... I'm about to mention ^^^ internals.rust-lang thread and <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span>'s response at the very end:</p>\n<div class=\"codehilite\"><pre><span></span>## What guarantees does this crate provide?\n\nIdeally a memory-zeroing function would do two things:\n\n1. Ensure the zeroing operation can&#39;t be &quot;optimized away&quot; by the compiler.\n2. Ensure all subsequent reads to the memory following the zeroing operation\n   will always see zeroes.\n\nThis crate guarantees #1 is true: LLVM&#39;s volatile semantics ensure it.\n\nThe story around #2 is much more complicated. In brief, it should be true that\nLLVM&#39;s current implementation does not attempt to perform optimizations which\nwould allow a subsequent (non-volatile) read to see the original value prior\nto zeroization. However, this is not a guarantee, but rather an LLVM\nimplementation detail.\n\nFor more background, we can look to the [std::ptr::write_volatile()]\ndocumentation:\n\n&gt; Volatile operations are intended to act on I/O memory, and are guaranteed\n&gt; to not be elided or reordered by the compiler across other volatile\n&gt; operations.\n&gt;\n&gt; Memory accessed with read_volatile or write_volatile should not be accessed\n&gt; with non-volatile operations.\n\nUhoh! This crate does not guarantee all reads to the memory it operates on are\nvolatile, and explicitly warns against mixing volatile and non-volatile\noperations. Perhaps we&#39;d be better off with something like a `VolatileCell`\ntype which owns the associated data and ensures all reads and writes are\nvolatile so we don&#39;t have to worry about the semantics of mixing volatile and\nnon-volatile accesses.\n\nWhile that&#39;s a strategy worth pursuing (and something we may investigate\nseparately from this crate), it comes with some onerous API requirements:\nit means any data that we might ever desire to zero is owned by a\n`VolatileCell`. However, this does not make it possible for this crate\nto act on references, which severely limits its applicability.\n\nIt&#39;s worth asking what the semantics of mixing volatile and non-volatile reads\nactually are, and whether a less obtrusive API which can act entirely on\nmutable references is possible, safe, and provides the desired behavior.\nUnfortunately, that&#39;s a tricky question, because Rust does not have a formally\ndefined memory model, and the behavior of mixing volatile and non-volatile\nmemory accesses winds up largely being an LLVM implementation detail.\n\n[To Be Continued]\n</pre></div>",
        "id": 152276150,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545330301
    },
    {
        "content": "<p>err reading over my own text I'm seeing a few things I need to rewrite <span class=\"emoji emoji-1f609\" title=\"wink\">:wink:</span></p>",
        "id": 152276337,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545330474
    },
    {
        "content": "<blockquote>\n<p>This crate does not guarantee all reads to the memory it operates on are volatile, and explicitly warns against mixing volatile and non-volatile<br>\noperations</p>\n</blockquote>",
        "id": 152276393,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545330500
    },
    {
        "content": "<p>need to reword that in particular</p>",
        "id": 152276402,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545330511
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> so based on your response here: <a href=\"https://internals.rust-lang.org/t/volatile-and-sensitive-memory/3188/46\" target=\"_blank\" title=\"https://internals.rust-lang.org/t/volatile-and-sensitive-memory/3188/46\">https://internals.rust-lang.org/t/volatile-and-sensitive-memory/3188/46</a></p>",
        "id": 152298996,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545353034
    },
    {
        "content": "<p>it seems like the best path forward is something that has <code>VolatileCell</code>-like semantics</p>",
        "id": 152299038,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545353048
    },
    {
        "content": "<p>i.e. it owns the data, and ensures <em>all</em> accesses are volatile</p>",
        "id": 152299042,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545353063
    },
    {
        "content": "<p>something like that, plus <code>Pin</code></p>",
        "id": 152299047,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545353083
    },
    {
        "content": "<p>and I think you can enforce fairly reasonable zeroization semantics, which are:</p>",
        "id": 152299069,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545353116
    },
    {
        "content": "<p>1) don't make (non-explicit) copies</p>",
        "id": 152299071,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545353122
    },
    {
        "content": "<p>2) don't allow non-volatile accesses</p>",
        "id": 152299078,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545353144
    },
    {
        "content": "<p>3) the \"zeroization\" operation (which can now be performed on <code>Drop</code>) is guaranteed not to be \"optimized away\" or otherwise elided by the compiler</p>",
        "id": 152299135,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545353175
    },
    {
        "content": "<p>would you agree?</p>",
        "id": 152299137,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545353178
    },
    {
        "content": "<p>just wondering if I'm missing something here</p>",
        "id": 152299172,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545353236
    },
    {
        "content": "<p>re: what I have in ^^^ PR to <code>zeroize</code> it is... \"Not Optimal\" because it mixes volatile and non-volatile accesses</p>",
        "id": 152299204,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545353279
    },
    {
        "content": "<p>also I was wondering if <code>core::sync::atomic::compiler_fence</code> and/or <code>core::sync::atomic::fence</code> can provide reliable, portable semantics for mixing volatile and non-volatile accesses</p>",
        "id": 152299296,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545353368
    },
    {
        "content": "<p>I have never used either and do not have a good sense of what either do</p>",
        "id": 152299303,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545353380
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> also any thoughts on something like <code>VolatileCell</code> in <code>core</code>/<code>std</code>?</p>",
        "id": 152301233,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545355897
    },
    {
        "content": "<p>so <code>VolatileCell</code> for this purpose has a big drawback: it reads an owned value. if the goal is to erase a secret, making copies of it to read it seems... suboptimal</p>",
        "id": 152364729,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545433750
    },
    {
        "content": "<p>added memory fences... and also a marker trait for zeroizing using the <code>Default</code> value which when used as the trait bound for things like collections allows them to only be used once at the end of the collection <a href=\"https://github.com/iqlusioninc/crates/pull/146/files\" target=\"_blank\" title=\"https://github.com/iqlusioninc/crates/pull/146/files\">https://github.com/iqlusioninc/crates/pull/146/files</a></p>",
        "id": 152392044,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545490779
    },
    {
        "content": "<p>was also able to add special-case optimizations on <code>nightly</code> for <code>[u8]</code> and <code>[u8; N]</code> which are the main cases I care about</p>",
        "id": 152392180,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545490964
    },
    {
        "content": "<p>using <code>volatile_set_memory</code></p>",
        "id": 152392188,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1545490986
    },
    {
        "content": "<blockquote>\n<p>it seems like the best path forward is something that has <code>VolatileCell</code>-like semantics</p>\n</blockquote>\n<p>I'm trying to bring this back in cache -- I know that <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> and I were talking about this sort of thing from time to time in conjunction with the work on stacked borrows and other parts of the unsafe-code-guidelines. To some extent, a <code>union</code> may already fit the bill here as well, since the compiler is not generally permitted to assume that the contents are valid</p>",
        "id": 154205183,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1546467159
    },
    {
        "content": "<p>I feel like the upcoming topic for the unsafe-code-guidelines discussion -- which will be a focus on the invariants that have to hold for various types -- is going to be very apropos</p>",
        "id": 154205199,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1546467191
    },
    {
        "content": "<p>(that said, the LLVM treatment of unions may not be sufficiently conservative I suppose, so maybe there is still a need for a volatile cell sort of thing)</p>",
        "id": 154205211,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1546467224
    },
    {
        "content": "<p>I guess the question is whether there are optimizations we could do on unions that would be ruled out by volatile cell</p>",
        "id": 154205253,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1546467245
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> upon further reflection <code>VolatileCell</code> is the opposite of what I want... it makes a copy each time data is read, and I'm trying to reduce the number of copies to 0 <span class=\"emoji emoji-1f609\" title=\"wink\">:wink:</span></p>",
        "id": 154208543,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1546471583
    },
    {
        "content": "<blockquote>\n<p>FWIW, I still prefer the ISO C semantics for volatile where it is used to describe objects, not accesses to objects.</p>\n</blockquote>\n<p>That's not correct: ISO C also allows volatile <em>accesses</em>, you can cast a pointer to a volatile pointer and use that. adding volatile objects adds lots of complexity for no gain at all. In the best case, a definition in terms of objects can coincide with the access-based definition for the case where there is no object with mixed accesses.</p>\n<p>Personally, I never understood volatile objects, for many years. then somewhere I found an explanation in terms of accesses and suddenly everything made sense. Also note that the concurrency memory model is entirely defined in terms of accesses, not objects.<br>\nI am still curious why you think this makes more sense for objects -- but we've had this discussion before and did not get very far.</p>",
        "id": 154232573,
        "sender_full_name": "RalfJ",
        "timestamp": 1546512750
    },
    {
        "content": "<p>Volatile objects make sense as a high-level API, just like we have \"atomic objects\" like <code>AtomicUsize</code>. But they are the wrong level of abstraction for defining the semantics.</p>",
        "id": 154232647,
        "sender_full_name": "RalfJ",
        "timestamp": 1546512853
    },
    {
        "content": "<blockquote>\n<p>it seems like the best path forward is something that has VolatileCell-like semantics<br>\ni.e. it owns the data, and ensures all accesses are volatile</p>\n</blockquote>\n<p>agreed. and you can define this entirely as a library, just like <code>AtomicUsize</code>.</p>\n<blockquote>\n<p>so VolatileCell for this purpose has a big drawback: it reads an owned value. if the goal is to erase a secret, making copies of it to read it seems... suboptimal</p>\n</blockquote>\n<p>what do you mean by this?</p>",
        "id": 154232728,
        "sender_full_name": "RalfJ",
        "timestamp": 1546512979
    },
    {
        "content": "<p>one potential issue here is the <code>dereferencable</code> attribute; for that, also see  <a href=\"https://github.com/rust-lang/rust/issues/55005\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/55005\">https://github.com/rust-lang/rust/issues/55005</a></p>",
        "id": 154236389,
        "sender_full_name": "RalfJ",
        "timestamp": 1546518079
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> naively it looks like <code>VolatileCell</code> performs a volatile read but leaves a copy of the data on the stack</p>",
        "id": 154241640,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1546524965
    },
    {
        "content": "<p>which is literally the opposite of what I want</p>",
        "id": 154241644,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1546524976
    },
    {
        "content": "<p><code>VolatileCell</code> is a type, not an operation, it doesn't do anything.^^ which method are you referring to?</p>",
        "id": 154242330,
        "sender_full_name": "RalfJ",
        "timestamp": 1546525721
    },
    {
        "content": "<p>but also, all of rustc, LLVM (and also GCC, ...) dont have a notion of data being secret, so you'll always be fighting their optimizers etc because you are making a difference between behaviors that they deem equivalent</p>",
        "id": 154242441,
        "sender_full_name": "RalfJ",
        "timestamp": 1546525834
    },
    {
        "content": "<p>I'm specifically referring to the accessors, which work on values, not references, e.g. <a href=\"https://github.com/japaric/vcell/blob/master/src/lib.rs#L43\" target=\"_blank\" title=\"https://github.com/japaric/vcell/blob/master/src/lib.rs#L43\">https://github.com/japaric/vcell/blob/master/src/lib.rs#L43</a></p>",
        "id": 154242851,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1546526268
    },
    {
        "content": "<p>unless I'm mistaken, that's making a copy of a value onto the stack</p>",
        "id": 154242901,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1546526295
    },
    {
        "content": "<p>what else would <code>get</code> do? you asked to get access to the value directly, of course that puts it outside the cell</p>",
        "id": 154246617,
        "sender_full_name": "RalfJ",
        "timestamp": 1546529973
    },
    {
        "content": "<p>well going back to my original comment you were asking about...</p>",
        "id": 154247102,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1546530434
    },
    {
        "content": "<blockquote>\n<p>so VolatileCell for this purpose has a big drawback: it reads an owned value. if the goal is to erase a secret, making copies of it to read it seems... suboptimal</p>\n</blockquote>",
        "id": 154247105,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1546530435
    },
    {
        "content": "<p>I don't want to make copies</p>",
        "id": 154247111,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1546530439
    },
    {
        "content": "<p>I am trying to delete existing copies</p>",
        "id": 154247124,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1546530449
    },
    {
        "content": "<p>why do you call <code>get</code> if you want to erase a secret...?</p>",
        "id": 154248256,
        "sender_full_name": "RalfJ",
        "timestamp": 1546531464
    },
    {
        "content": "<p>I think you're misunderstanding what I'm saying</p>",
        "id": 154248263,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1546531477
    },
    {
        "content": "<p><code>VolatileCell</code> doesn't solve my problem so I'm not using it</p>",
        "id": 154248272,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1546531486
    },
    {
        "content": "<p>I think so too :)</p>",
        "id": 154248274,
        "sender_full_name": "RalfJ",
        "timestamp": 1546531488
    },
    {
        "content": "<blockquote>\n<blockquote>\n<p>FWIW, I still prefer the ISO C semantics for volatile where it is used to describe objects, not accesses to objects.</p>\n</blockquote>\n<p>That's not correct: ISO C also allows volatile <em>accesses</em>, you can cast a pointer to a volatile pointer and use that.</p>\n</blockquote>\n<p>I don't think that is right. The C standard consistently uses the phrase \"object defined with a volatile-qualified type\", says accessing these kinds of objects through volatile-qualified types is implementation defined, and says using them as non-volatile-qualified lvaules is undefined behavior. It doesn't require an implementation to give volatile semantics to objects it knows are not volatile even if they are exclusively accessed through volatile pointers. However, there is a recent proposal by a Googler to change this to the LLVM semantics.</p>",
        "id": 154261126,
        "sender_full_name": "briansmith",
        "timestamp": 1546544040
    },
    {
        "content": "<p>Regardless of that, I understand that at this point it isn't useful to debate what Rust will do w.r.t. volatile. I prefer the C way, except without the ridiculous ease of (accidentally) wrongly casting from volatile &lt;-&gt; non-volatile in ways that don't work, but I understand that it is unlikely that Rust would change to that any time soon, especially because rustc will be using LLVM; it seems easier to change the C standard than to change LLVM, as evidenced by Google's proposal.</p>",
        "id": 154261448,
        "sender_full_name": "briansmith",
        "timestamp": 1546544386
    },
    {
        "content": "<p>another reason we should prefer volatile accesses IMO is that there's a trivial translation from a \"volatile-object\" based world to a \"volatile-access\" based world -- every access to a volatile object is a volatile access, done. there is no translation possible in general the other way. so, volatile accesses are strictly more general.</p>",
        "id": 154402199,
        "sender_full_name": "RalfJ",
        "timestamp": 1546599607
    },
    {
        "content": "<blockquote>\n<p>The C standard consistently uses the phrase \"object defined with a volatile-qualified type\", says accessing these kinds of objects through volatile-qualified types is implementation defined, and says using them as non-volatile-qualified lvaules is undefined behavior.</p>\n</blockquote>\n<p>Indeed, I misremembered.</p>\n<blockquote>\n<p>It doesn't require an implementation to give volatile semantics to objects it knows are not volatile even if they are exclusively accessed through volatile pointers.</p>\n</blockquote>\n<p>A possible reading of the standard is that having a volatile-qualified lvalue makes the object in that lvalue a volatile object.</p>\n<p>Notice that it's not just LLVM that thinks of volatile as being an access-qualifier; the Linux kernel does that a lot so this is for sure also the way GCC handles volatile.</p>",
        "id": 154402419,
        "sender_full_name": "RalfJ",
        "timestamp": 1546599986
    },
    {
        "content": "<p>nice, thanks <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> <a href=\"https://github.com/rust-lang/rust/pull/60972\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/pull/60972\">https://github.com/rust-lang/rust/pull/60972</a></p>",
        "id": 166194127,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1558460189
    },
    {
        "content": "<p>I feel guilty because I was involved in adding this text (and didn't foresee the confusion it would cause), so this is only fair ;)</p>",
        "id": 166194225,
        "sender_full_name": "RalfJ",
        "timestamp": 1558460260
    },
    {
        "content": "<p>Nice work indeed! (Y)</p>",
        "id": 166252548,
        "sender_full_name": "DevQps",
        "timestamp": 1558518612
    }
]