[
    {
        "content": "<p>any thoughts on a README badge like this?</p>",
        "id": 136116112,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1539960582
    },
    {
        "content": "<p><a href=\"/user_uploads/4715/jU0yQMzoXpRUdQcv0kY73mpE/Screen-Shot-2018-10-19-at-7.49.16-AM.png\" target=\"_blank\" title=\"Screen-Shot-2018-10-19-at-7.49.16-AM.png\">Screen-Shot-2018-10-19-at-7.49.16-AM.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/4715/jU0yQMzoXpRUdQcv0kY73mpE/Screen-Shot-2018-10-19-at-7.49.16-AM.png\" target=\"_blank\" title=\"Screen-Shot-2018-10-19-at-7.49.16-AM.png\"><img src=\"/user_uploads/4715/jU0yQMzoXpRUdQcv0kY73mpE/Screen-Shot-2018-10-19-at-7.49.16-AM.png\"></a></div>",
        "id": 136116129,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1539960602
    },
    {
        "content": "<p>I started using them on a few of my projects</p>",
        "id": 136116187,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1539960623
    },
    {
        "content": "<p>Here's a copy-paste of the notes on this topic from the first meeting:</p>\n<p>ET: Do we also want to name and shame projects that are using unsafe in a bad way? Or assuming that they need the performance, do it w/o unsafe.<br>\nBS: Instead of naming and shaming, show how things can be done better. Always propose an alternative, maybe even submit a patch.<br>\nSS: Could generate badges showing percent of unsafe code in a project in order to incentivize less unsafe.<br>\nTA: forbid(unsafe) could be an interesting metric. So the badge could be that you have no uses of unsafe at all.<br>\nBS: We should decide what the goals are. Be careful not to make core crates which enable safe functionality look bad.<br>\nGK: Make sure not to make it sound like “unsafe is only for experts.”<br>\nSS: I think the point of unsafe is to be a higher bar and to raise suspicion.<br>\nGK: I don’t want to make it seem like the next important unsafe-using crate should only be written by experts.<br>\nBS: There are other security considerations beyond unsafe (e.g., for crypto). Also not convinced that the crate is the right granularity for this. E.g.: What about unsafe hidden behind a safe API?<br>\nET: An old idea was to add an audit annotation to unsafe code to declare that it’d been reviewed/checked. Might even go as far as a digital signature. Could add an audit flag/attribute, and have a badge for that.<br>\nBS: Use of dangerous constructs can be a metric of this group’s success.</p>",
        "id": 136116298,
        "sender_full_name": "Joshua Liebow-Feeser",
        "timestamp": 1539960732
    },
    {
        "content": "<p>I like the idea of having a badge for \"all my <code>unsafe</code>s are audited\", which would be a superset of \"I don't use <code>unsafe</code>\".</p>",
        "id": 136116353,
        "sender_full_name": "Joshua Liebow-Feeser",
        "timestamp": 1539960811
    },
    {
        "content": "<p>So all crates w/o <code>unsafe</code> would get that badge automatically.</p>",
        "id": 136116360,
        "sender_full_name": "Joshua Liebow-Feeser",
        "timestamp": 1539960824
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119194\">@Erick Tryzelaar</span> might have thoughts on how to do the review annotations.</p>",
        "id": 136116422,
        "sender_full_name": "Joshua Liebow-Feeser",
        "timestamp": 1539960858
    },
    {
        "content": "<p>Isn't this an example of \"Goodhart's law\"?</p>",
        "id": 136121940,
        "sender_full_name": "Zach Reizner",
        "timestamp": 1539966003
    },
    {
        "content": "<p>If we measure how much unsafe is in a project, the unsafe will get moved to a place less visible.</p>",
        "id": 136121974,
        "sender_full_name": "Zach Reizner",
        "timestamp": 1539966031
    },
    {
        "content": "<p>that's why I'm a fan of <code>forbid</code> <span class=\"emoji emoji-1f609\" title=\"wink\">:wink:</span></p>",
        "id": 136121991,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1539966052
    },
    {
        "content": "<p>Does forbid mean that there is no unsafe code in any module in the dependency chain?</p>",
        "id": 136122295,
        "sender_full_name": "Zach Reizner",
        "timestamp": 1539966347
    },
    {
        "content": "<p>unfortunately not <span class=\"emoji emoji-1f622\" title=\"cry\">:cry:</span></p>",
        "id": 136122956,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1539966975
    },
    {
        "content": "<p>a transitive forbid would be fantastic</p>",
        "id": 136122960,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1539966992
    },
    {
        "content": "<p>I fear some crates will split into cool-crate-totally-safe which will depend on cool-crate-but-with-the-unsafe-parts.</p>",
        "id": 136123860,
        "sender_full_name": "Zach Reizner",
        "timestamp": 1539967771
    },
    {
        "content": "<p>Additionally, some crates will unwittingly depend on potentially exploitable unsafe code, but still proudly put on the \"unsafe forbidden\" badge, which I feel is sending the wrong message to clients of that crate.</p>",
        "id": 136123956,
        "sender_full_name": "Zach Reizner",
        "timestamp": 1539967851
    },
    {
        "content": "<p>yeah, a README badge can always be a bit deceiving</p>",
        "id": 136124726,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1539968522
    },
    {
        "content": "<p>Good point.</p>",
        "id": 136124780,
        "sender_full_name": "Zach Reizner",
        "timestamp": 1539968584
    },
    {
        "content": "<p>Maybe if a client clicks the badge, it links to a full audit chain of that package that will show the unsafe dependencies.</p>",
        "id": 136124792,
        "sender_full_name": "Zach Reizner",
        "timestamp": 1539968606
    },
    {
        "content": "<p>I appreciate that the goal is to nudge devs away from using unsafe where possible, and the badge would be a net good in that effort even if it can be abused sometimes.</p>",
        "id": 136124867,
        "sender_full_name": "Zach Reizner",
        "timestamp": 1539968659
    },
    {
        "content": "<p>I just don't feel \"some humans I've never heard of looked at it and said it's okay\" is a security gurarantee worth pursuing. If anything, I'd rather have correctness proofs with tools such as SMACK, which are an actual assurance (under certain assumptions)</p>",
        "id": 136124946,
        "sender_full_name": "Shnatsel",
        "timestamp": 1539968734
    },
    {
        "content": "<p>Shnatsel, is that with respect to the badging or to adding audit annotations?</p>",
        "id": 136125043,
        "sender_full_name": "Zach Reizner",
        "timestamp": 1539968794
    },
    {
        "content": "<p>Am I correct in assuming those are orthogonal efforts?</p>",
        "id": 136125051,
        "sender_full_name": "Zach Reizner",
        "timestamp": 1539968804
    },
    {
        "content": "<p>Adding audit annotations</p>",
        "id": 136125054,
        "sender_full_name": "Shnatsel",
        "timestamp": 1539968806
    },
    {
        "content": "<p>While the tooling for automated verification has just been ported and so has some rough edges, it doesn't seem to be terribly hard to use. See <a href=\"http://soarlab.org/publications/atva2018-bhr.pdf\" target=\"_blank\" title=\"http://soarlab.org/publications/atva2018-bhr.pdf\">http://soarlab.org/publications/atva2018-bhr.pdf</a> for the porting story and some examples.</p>",
        "id": 136125099,
        "sender_full_name": "Shnatsel",
        "timestamp": 1539968878
    },
    {
        "content": "<p>(Moved to correctness proofs stream)</p>",
        "id": 136125171,
        "sender_full_name": "Zach Reizner",
        "timestamp": 1539968927
    },
    {
        "content": "<p>I disagree that an annotation about human checking isn't good enough. I agree that proofs are cool and desirable, but the reality is that most people aren't going to write proofs, and if my only options are to choose between un-annotated <code>unsafe</code> and <code>unsafe</code> which a human has at least thought about pretty hard and written down their thoughts, I prefer the latter. I also think that we'll get a lot more milage out of encouraging that approach than encouraging verified proofs.</p>",
        "id": 136129095,
        "sender_full_name": "Joshua Liebow-Feeser",
        "timestamp": 1539972612
    },
    {
        "content": "<p>I was under the impression that tools such as SMACK provide not quite as in-depth assurances as manual proofs with interactive proof assistants do, but are in the same ballpark in terms of usage difficulty as fuzzers, and provide greater assurance. If that is not the case I'd tend to agree, but I'm not yet convinced that is not the case <span class=\"emoji emoji-1f61c\" title=\"stuck out tongue wink\">:stuck_out_tongue_wink:</span></p>",
        "id": 136130064,
        "sender_full_name": "Shnatsel",
        "timestamp": 1539973569
    },
    {
        "content": "<p>haha, <code>lazy_static</code> breaks <code>#[forbid(unsafe_code)]</code></p>",
        "id": 136191921,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1540083761
    },
    {
        "content": "<p>That's unfortunate. I have no proposal for how you could fix that, but this feels like it ought to be a bug somewhere.</p>",
        "id": 136191932,
        "sender_full_name": "Alex Gaynor",
        "timestamp": 1540083800
    },
    {
        "content": "<p>That should have been covered by <a href=\"https://github.com/rust-lang/rust/issues/48855\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/48855\">https://github.com/rust-lang/rust/issues/48855</a></p>",
        "id": 136192400,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1540084810
    },
    {
        "content": "<p>well, it was for <code>deny</code> — <a href=\"https://github.com/rust-lang/rust/issues/48385#issuecomment-367142273\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/48385#issuecomment-367142273\">https://github.com/rust-lang/rust/issues/48385#issuecomment-367142273</a></p>",
        "id": 136192408,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1540084859
    },
    {
        "content": "<p>I personally think we should drop the security badge idea, deeming it out of scope. In particular, I think the design of <code>unsafe</code> as it exists now in Rust is highly questionable and I don't think I'm the only one. If the design of <code>unsafe</code> itself is unquestionable then IMO it's premature to gamify its use/non-use even if such gamification were otherwise a good idea. See <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=f2e8f93ce0ae2823b6de0e3f29b01b21\" target=\"_blank\" title=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=f2e8f93ce0ae2823b6de0e3f29b01b21\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=f2e8f93ce0ae2823b6de0e3f29b01b21</a> and <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=8ecb524f00ba696379853be7f0d2e479\" target=\"_blank\" title=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=8ecb524f00ba696379853be7f0d2e479\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=8ecb524f00ba696379853be7f0d2e479</a> for some examples of why I'm skeptical of the current design of <code>unsafe</code> as it stands today.</p>",
        "id": 136200452,
        "sender_full_name": "briansmith",
        "timestamp": 1540100628
    },
    {
        "content": "<p>haha, some stronger reactions than I was expecting. what I was getting at with these sorts of badges was all other things being equal, given a choice between a crate which uses unsafe and one that does not, I would prefer people pick the safe crate. the <code>base64</code> crate is a relevant example</p>",
        "id": 136270708,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1540218244
    },
    {
        "content": "<p>and more generally, discourage the use of <code>unsafe</code> when it isn't necessary</p>",
        "id": 136270724,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1540218261
    },
    {
        "content": "<p>on a separate but somewhat related note, I have ideas for unsafe improvements, but that could probably use its own topic</p>",
        "id": 136277900,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1540225387
    },
    {
        "content": "<p>regarding this topic, any ideas for security-related badges other than unsafe?</p>",
        "id": 136277913,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1540225411
    },
    {
        "content": "<p>I could potentially do some sort of RustSec badge</p>",
        "id": 136277985,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1540225454
    },
    {
        "content": "<p>Like a badge that says none of your deps have a known advisory?</p>",
        "id": 136278013,
        "sender_full_name": "Zach Reizner",
        "timestamp": 1540225483
    },
    {
        "content": "<p>yep, ala many similar systems that do the same thing for other language-specific vuln databases</p>",
        "id": 136278415,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1540225832
    },
    {
        "content": "<p>Sounds good to me.</p>",
        "id": 136278904,
        "sender_full_name": "Zach Reizner",
        "timestamp": 1540226343
    },
    {
        "content": "<p>it would require RustSec-as-a-service which might be a bit tricky, heh</p>",
        "id": 136278988,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1540226404
    },
    {
        "content": "<p>Shouldn't be too hard. We just have to find someone willing to donate us some infrastucture</p>",
        "id": 136279051,
        "sender_full_name": "Zach Reizner",
        "timestamp": 1540226489
    },
    {
        "content": "<p>I could donate the infrastructure for something like that</p>",
        "id": 136281200,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1540228545
    },
    {
        "content": "<p>That may not be necessary. I wonder if Mozilla would be willing to host something like that.</p>",
        "id": 136281284,
        "sender_full_name": "Zach Reizner",
        "timestamp": 1540228631
    },
    {
        "content": "<p>I have no idea how official this working group is though.</p>",
        "id": 136281294,
        "sender_full_name": "Zach Reizner",
        "timestamp": 1540228648
    },
    {
        "content": "<p>It's not official in the sense of not being able to speak on behalf of the Rust project. It's official in the sense of being sanctioned by the Rust project.</p>",
        "id": 136284537,
        "sender_full_name": "Joshua Liebow-Feeser",
        "timestamp": 1540232178
    },
    {
        "content": "<p>Also, wrt a RustSec badge, I'd be worried that it would just mean that crates that nobody looks at get the badge. If we had a high volume of vuln reports, it might give us meaningful data, but I think we get too few vuln reports to extract any meaningful signal from the noise.</p>",
        "id": 136284579,
        "sender_full_name": "Joshua Liebow-Feeser",
        "timestamp": 1540232234
    },
    {
        "content": "<p>I don't think a badge is a good place for the \"no dependencies have a known advisory\" info. I'd expect <code>cargo build</code> to complain loudly if they do; perhaps <a href=\"http://crates.io\" target=\"_blank\" title=\"http://crates.io\">crates.io</a> notifying maintainers that their dependencies have known advisories; but a readme badge sounds a lot less useful and would require a great deal more infrastructure.</p>",
        "id": 136325268,
        "sender_full_name": "Shnatsel",
        "timestamp": 1540285751
    },
    {
        "content": "<p><code>cargo build</code> can only tell you about your security advisories if you regularly build your crate.</p>",
        "id": 136350192,
        "sender_full_name": "Zach Reizner",
        "timestamp": 1540314008
    },
    {
        "content": "<p>A notification seems like the key piece of the puzzle. The badge is nice because it's an external signal to clients of a crate that the maintainers care about security.</p>",
        "id": 136350243,
        "sender_full_name": "Zach Reizner",
        "timestamp": 1540314080
    },
    {
        "content": "<p>I still am concerned that badges are only helpful if a negative signal is helpful. Right now, we don't get enough vuln reports for \"this crate doesn't have a vuln report\" to mean anything.</p>",
        "id": 136352591,
        "sender_full_name": "Joshua Liebow-Feeser",
        "timestamp": 1540316042
    },
    {
        "content": "<p>At this point, \"this crate has had vuln reports\" basically just means \"this crate is used enough that people bothered looking.\"</p>",
        "id": 136352651,
        "sender_full_name": "Joshua Liebow-Feeser",
        "timestamp": 1540316059
    },
    {
        "content": "<blockquote>\n<p>I could donate the infrastructure for something like that</p>\n</blockquote>\n<p>I can check with my employer (DigitalOcean), I think we could get machines/credit donated for this effort.</p>",
        "id": 136546283,
        "sender_full_name": "qmx",
        "timestamp": 1540560011
    },
    {
        "content": "<p>I've been doing some brainstorming and I have a version of this working that generates the audits as part of a gitlab ci run.</p>",
        "id": 136563748,
        "sender_full_name": "Zach Reizner",
        "timestamp": 1540577019
    },
    {
        "content": "<p>It seems to be working pretty well. It can build and audit in about 5 minutes and I can schedule CI jobs using cron syntax, currently set for hourly.</p>",
        "id": 136563771,
        "sender_full_name": "Zach Reizner",
        "timestamp": 1540577040
    },
    {
        "content": "<p>Could we add <code>cargo audit</code> (or whatever tool you're working on) as a CI pass? So, e.g., in your <code>.travis.yml</code>, run a tool which fails the CI test if your dependency graph has any known vulns?</p>",
        "id": 136564076,
        "sender_full_name": "Joshua Liebow-Feeser",
        "timestamp": 1540577322
    },
    {
        "content": "<p>I'll defer to the <span class=\"user-mention\" data-user-id=\"132721\">@Tony Arcieri</span> who made the cargo audit.</p>",
        "id": 136564116,
        "sender_full_name": "Zach Reizner",
        "timestamp": 1540577383
    },
    {
        "content": "<p>I'm making more of a <code>crates-audit</code>.</p>",
        "id": 136564124,
        "sender_full_name": "Zach Reizner",
        "timestamp": 1540577397
    },
    {
        "content": "<p>The thing I'm making generates a data structure like this:</p>\n<div class=\"codehilite\"><pre><span></span>#[derive(Serialize, Deserialize, PartialEq)]\nstruct CratesAudit {\n    crates_index_commit: String,\n    advisory_db_commit: String,\n    // Map of crate name to list of RustSec advisory IDs.\n    advisories: BTreeMap&lt;String, Vec&lt;String&gt;&gt;,\n}\n</pre></div>",
        "id": 136564203,
        "sender_full_name": "Zach Reizner",
        "timestamp": 1540577435
    },
    {
        "content": "<p>Gotcha</p>",
        "id": 136564335,
        "sender_full_name": "Joshua Liebow-Feeser",
        "timestamp": 1540577612
    },
    {
        "content": "<p>Another slight difference is that <code>cargo audit</code> uses a Cargo.lock file as opposed to <code>crates-audit</code> which does its own dependency resolution.</p>",
        "id": 136564531,
        "sender_full_name": "Zach Reizner",
        "timestamp": 1540577816
    },
    {
        "content": "<p>Neat! Let me know when you publish the code, it would be very interesting to poke at it. Also, this has been on my \"cool project I can't get around to\" list for a long time, so thanks for actually stepping up and doing it!</p>",
        "id": 136573683,
        "sender_full_name": "Shnatsel",
        "timestamp": 1540587826
    },
    {
        "content": "<p>Thanks. It was a right place right time kind of situation because I already had the crates indexing and dependency resolution code written but I no longer needed it for its original purpose.</p>",
        "id": 136573791,
        "sender_full_name": "Zach Reizner",
        "timestamp": 1540587937
    },
    {
        "content": "<p>Yeah likewise, this has been suggested several times but I've never had time to work on it.</p>",
        "id": 136657038,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1540740967
    },
    {
        "content": "<p>and yeah, <code>cargo audit</code> is good to go for CI. Per <span class=\"user-mention\" data-user-id=\"130046\">@Alex Gaynor</span>'s issue I should document Travis at least</p>",
        "id": 136657050,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1540740992
    },
    {
        "content": "<p>I use it on Travis</p>",
        "id": 136657053,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1540740998
    },
    {
        "content": "<p>(and CircleCI, and Cloud Build, but that's a different story)</p>",
        "id": 136657059,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1540741008
    },
    {
        "content": "<p>Yeah, I don't think it's rocket science to set up, just want to drag that barrier down.</p>",
        "id": 136658995,
        "sender_full_name": "Alex Gaynor",
        "timestamp": 1540743377
    },
    {
        "content": "<p>Sorry I'd dropped off the radar for a bit.  I actually just recently starting on a crate to measure unsafe coverage inside a crate.  Before I dove too deep on it I wanted to check with the group to make sure one doesn't already exist.</p>",
        "id": 137114870,
        "sender_full_name": "Stuart Small",
        "timestamp": 1541254574
    },
    {
        "content": "<p>Plan is walking the crate with syn, measure unsafe usage and get a percentage than can be shown off in a badge.  So far it looks fairly straight forward.</p>",
        "id": 137114880,
        "sender_full_name": "Stuart Small",
        "timestamp": 1541254669
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"132722\">@Stuart Small</span> I'm curious how the uses of unsafe will be counted. Consider <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=61340cde2f564c4f9dbc9af0bf99e87c\" target=\"_blank\" title=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=61340cde2f564c4f9dbc9af0bf99e87c\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=61340cde2f564c4f9dbc9af0bf99e87c</a> vs <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=ff104f86e8a21c7be6e2a0c5c097e6b5\" target=\"_blank\" title=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=ff104f86e8a21c7be6e2a0c5c097e6b5\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=ff104f86e8a21c7be6e2a0c5c097e6b5</a> vs <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=1235743a7a0bac91990f0eb252a77571\" target=\"_blank\" title=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=1235743a7a0bac91990f0eb252a77571\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=1235743a7a0bac91990f0eb252a77571</a>. Would they have the same score or different scores?</p>",
        "id": 137129543,
        "sender_full_name": "briansmith",
        "timestamp": 1541280821
    },
    {
        "content": "<p>I'm still playing around with it.  I'm new to syn.  From what I've read so far it will be on the expression level, so the first two will be equal but the 3rd one will show a lower percentage of unsafe.  I believe it's correct to have the 3rd example to have a better score because while the usage of unsafe is the same, the surface area to audit is smaller.</p>",
        "id": 137133880,
        "sender_full_name": "Stuart Small",
        "timestamp": 1541289670
    },
    {
        "content": "<p>A did a quick POC of my approach on this and included a couple of the case you mentioned <span class=\"user-mention\" data-user-id=\"133214\">@Brian Smith</span> .  It can be found here:  <a href=\"https://github.com/stusmall/cargo-unsafe-coverage\" target=\"_blank\" title=\"https://github.com/stusmall/cargo-unsafe-coverage\">https://github.com/stusmall/cargo-unsafe-coverage</a></p>\n<p>I added a couple of the examples you'd mentioned in there are unit tests.  To get this far it was pretty smooth sailing, itll just be the work of filling out implementation for different AST states and handling them.  Something like this can encourage people to either advertise their lack of unsafe code or help encourage concentrating it in smaller, more central, audit-able locations.  Like any metric, like code coverage, it isn't perfect but can help encourage good practices.</p>",
        "id": 137144113,
        "sender_full_name": "Stuart Small",
        "timestamp": 1541311551
    },
    {
        "content": "<blockquote>\n<p>I believe it's correct to have the 3rd example to have a better score because while the usage of unsafe is the same, the surface area to audit is smaller.</p>\n</blockquote>\n<p>Any approach that takes into account how often the <code>unsafe</code> keyword appears in the rating beyond \"it never appears\" and \"it appears at least once\" is probably incorrect. </p>\n<p>So I'm interested too into how this unsafe rating would work. Is there a document explaining it anywhere?</p>",
        "id": 137150943,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541326822
    },
    {
        "content": "<p>I've toyed with the idea of measuring coverage of unsafe code already, discussed it with some folks, and arrived to the conclusion that it's simply impossible to produce a meaningful result. Here's an extreme example: <a href=\"https://github.com/WanzenBug/rust-fixed-capacity-vec\" target=\"_blank\" title=\"https://github.com/WanzenBug/rust-fixed-capacity-vec\">https://github.com/WanzenBug/rust-fixed-capacity-vec</a> at one point in its history had exactly one <code>unsafe</code> block with just one line it in. It was in creation of fixed-capacity vector view, so any conceivable test would enter that line; it would have 100% unsafe coverage by any conceivable metric. However, the safety of that line depended on <em>the entire rest of the code in the module,</em> all of which is safe, upholding a certain non-trivial invariant.<br>\nSo such metrics would be often useless at best and wildly misleading at worst.</p>",
        "id": 137151711,
        "sender_full_name": "Shnatsel",
        "timestamp": 1541328444
    },
    {
        "content": "<p>Those are pretty much my thoughts too <span class=\"user-mention\" data-user-id=\"127617\">@Shnatsel</span> . I think the only useful metric is whether the crate uses unsafe at all or not, and if you want something more fine grained, how many % of the modules in a crate use unsafe at all or not (where if a module uses unsafe, you have to count all its child modules as using unsafe as well).</p>",
        "id": 137152019,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541329157
    },
    {
        "content": "<p><a href=\"https://github.com/anderejd/cargo-geiger\" target=\"_blank\" title=\"https://github.com/anderejd/cargo-geiger\">https://github.com/anderejd/cargo-geiger</a> does that, also with dependencies and transitive dependencies</p>",
        "id": 137152089,
        "sender_full_name": "Shnatsel",
        "timestamp": 1541329306
    },
    {
        "content": "<p>No documentation yet.   Last night was my first pass at setting it up.  It looks for the amount of code covered by unsafe blocks.  It isn't a count of unsafe blocks or the number of lines inside them,  but the count of statements inside that block or method.</p>\n<p>As for the any unsafe is enough, I'm trying to keep the actix case in mind.  In the early days of the project it had a lot of unsafe usage in the crate.  The community found it and help reduce it down to a few small places where it was needed for performance.  Something like this could be a quick smoke test for heavy unsafe usage in where it doesn't make sense, but a little unsafe does.</p>",
        "id": 137159080,
        "sender_full_name": "Stuart Small",
        "timestamp": 1541344201
    },
    {
        "content": "<p><a href=\"https://github.com/anderejd/cargo-geiger\" target=\"_blank\" title=\"https://github.com/anderejd/cargo-geiger\">https://github.com/anderejd/cargo-geiger</a> already counts the total amount of expressions under unsafe per crate, as well as number of unsafe impls, traits and methods. I.e. it seems to be already doing what you're trying to achieve.</p>",
        "id": 137159461,
        "sender_full_name": "Shnatsel",
        "timestamp": 1541344913
    },
    {
        "content": "<blockquote>\n<p>It isn't a count of unsafe blocks or the number of lines inside them, but the count of statements inside that block or method.</p>\n</blockquote>\n<p>Yeah so this approach is incorrect, the count of statements inside an unsafe block isn't a measure for the amount of unsafe code.</p>",
        "id": 137159523,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541344999
    },
    {
        "content": "<p>It would catch the Actix case though, which seems to be the design goal.</p>",
        "id": 137159583,
        "sender_full_name": "Shnatsel",
        "timestamp": 1541345126
    },
    {
        "content": "<p>For that goal, <code>grep</code> would arguably be enough?</p>",
        "id": 137159631,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541345173
    },
    {
        "content": "<p>True. That's what I tend to use.</p>",
        "id": 137159646,
        "sender_full_name": "Shnatsel",
        "timestamp": 1541345240
    },
    {
        "content": "<p>I think if one is going to give crates a score based on <code>unsafe</code>, one should really think through what would happen if people would optimize for that goal. AFAICT given what <span class=\"user-mention\" data-user-id=\"132722\">@Stuart Small</span> proposed, such a tool would encourage using minimally scoped <code>unsafe</code> blocks to minimize the number of \"unsafe statements\", but that's something that the std library explicitly avoids because it gives the impression that the unsafety is only present in those parts of the code, while in reality, one needs to inspect the whole function, module, child modules, etc. So under this model, optimizing to reduce such a score would actually be introducing anti-patterns that make the code more \"unsafe\".</p>\n<p>For example, if you have a struct with a <code>Vec</code>, and a single <code>unsafe</code> block in the module doing a <code>unsafe { self.vec.set_len(self.vec.len() + 1) }</code>, that might have a tiny statement count, but in reality, everything that can directly or indirectly access <code>self.vec</code> becomes unsafe due to this, even though one doesn't need to add more unsafe blocks. So that ought to have a larger \"danger\" associated with it than maybe doing a raw pointer dereference, where either doing it succeeds or not, but is something that can be prevented fairly locally with an <code>assert!</code> without tainting the whole module.</p>",
        "id": 137159802,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541345473
    },
    {
        "content": "<p>Oh wow.  I hadn't caught that they had added that since the last time I looked at that crate.  Nevermind</p>",
        "id": 137162402,
        "sender_full_name": "Stuart Small",
        "timestamp": 1541349485
    },
    {
        "content": "<p>Last time I had looked a geiger just gave a thumbs up/thumbs down on if it had unsafe.</p>",
        "id": 137162425,
        "sender_full_name": "Stuart Small",
        "timestamp": 1541349543
    },
    {
        "content": "<p>Hmmm.  Now that at it I think I imagined it was only a yes or no.  Looks like it's always gathered stats on the usage.  Glad I brought this up with the group before I went to far on it.</p>",
        "id": 137162848,
        "sender_full_name": "Stuart Small",
        "timestamp": 1541350199
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"132920\">@gnzlbg</span> If it is true that the stdlib intentionally avoids minimizing the scope of <code>unsafe</code> blocks \"because it gives the impression that the unsafety is only present in those parts\" then we should change that. I think minimizing the amount of code that is within <code>unsafe</code> makes the use of <code>unsafe</code> much clearer and also avoids unnecessary and accidental unsafe code.</p>",
        "id": 137165907,
        "sender_full_name": "briansmith",
        "timestamp": 1541355411
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133214\">@Brian Smith</span>  Most functions in the std library using <code>unsafe</code> just wrap the whole function content in a big <code>unsafe { ... }</code> block. I personally disagree that minimally scoped unsafe blocks make anything clearer. When one uses minimally scoped unsafe blocks most undefined behavior related bugs start happening out of any unsafe block. Also people modifying code outside unsafe blocks pay less attention than those modifying unsafe blocks. Larger than minimal unsafe blocks are an indication that modifying anything inside the block has to be done with extra care.</p>\n<p>And that's the root of the problem: once your crate/module has a single use of <code>unsafe {}</code>, no matter how minimally scoped, an error in \"safe\" Rust code can introduce undefined behavior. Its not \"is this unsafe code correct\", but \"is all of this code correct given that unsafe is used somewhere\".</p>",
        "id": 137166047,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541355698
    },
    {
        "content": "<p>Well... on one hand, seeing which of the calls are to <code>unsafe fn</code> and which aren't at a glance would be helpful so I could look them all up, make a list of invariants that they require to be upheld, and then check that they're actually upheld. On the other hand, it could create a lot of noise. So sounds like highlighting calls to unsafe fn would be better solved with an IDE plugin.</p>",
        "id": 137166147,
        "sender_full_name": "Shnatsel",
        "timestamp": 1541355880
    },
    {
        "content": "<p>Highlighting calls to <code>unsafe fn</code> is a great idea, but there are things that require unsafe that are not <code>unsafe fn</code> (e.g. dereferencing raw pointers, creating a reference to a packed struct field, reading from an union, etc.) and all of these could be happening inside the same <code>unsafe</code> block, so ideally all of these would be \"highlighted\", underlined, or something.</p>",
        "id": 137166222,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541356027
    },
    {
        "content": "<p>Wanna open a feature request against RLS or whatever should be handling this?</p>",
        "id": 137166273,
        "sender_full_name": "Shnatsel",
        "timestamp": 1541356098
    },
    {
        "content": "<p>RLS or the rust-analyzer should be the tools that expose this information</p>",
        "id": 137166274,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541356122
    },
    {
        "content": "<p>Huh, I did not know about rust-analyzer. Thanks for pointing it out.</p>",
        "id": 137166401,
        "sender_full_name": "Shnatsel",
        "timestamp": 1541356362
    },
    {
        "content": "<p>Care to open feature requests against them?</p>",
        "id": 137166402,
        "sender_full_name": "Shnatsel",
        "timestamp": 1541356374
    },
    {
        "content": "<p><a href=\"https://github.com/rust-analyzer/rust-analyzer/issues/190\" target=\"_blank\" title=\"https://github.com/rust-analyzer/rust-analyzer/issues/190\">https://github.com/rust-analyzer/rust-analyzer/issues/190</a></p>",
        "id": 137166462,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541356501
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"132920\">@gnzlbg</span> Sure, but in that case every Rust program is \"unsafe\" because they all depend on libstd/libcore which use <code>unsafe</code>. <code>unsafe</code> isn't meant to delimit the scope of what's affected by unsafe constructs; it delimits the direct use of unsafe constructs only. The argument that minimizing the scope of <code>unsafe</code> because it is confusing as to what the ultimate unsafe effect can be is targeting a mental model of <code>unsafe</code> that's just incorrect.</p>",
        "id": 137169164,
        "sender_full_name": "briansmith",
        "timestamp": 1541361909
    },
    {
        "content": "<blockquote>\n<p>Sure, but in that case every Rust program is \"unsafe\" because they all depend on libstd/libcore which use unsafe</p>\n</blockquote>\n<p>Iff the public API of libstd/libcore is sound, then every Rust programs that only interacts with these via safe public APIs is sound too (not unsafe).</p>",
        "id": 137169264,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541362130
    },
    {
        "content": "<p>The key difference is that code inside a module (and child modules) does not need to interact with the module its defined in through its public API. This code can, for example, use <code>safe Rust</code> code to modify private struct fields, potentially introducing undefined behavior because of interaction with some <code>unsafe</code> code somewhere else in the module that did not expect those modifications.</p>",
        "id": 137169275,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541362186
    },
    {
        "content": "<p>Once <code>unsafe</code> appears once inside a module, modifying code anywhere in the module or child modules can introduce undefined behavior independently of whether the code being modified is inside an <code>unsafe</code> block or not. Minimizing the scope of <code>unsafe</code> blocks does not make anything safer per se, it just changes the region that whoever write the code wants to highlight to the reader as being \"unsafe\".</p>",
        "id": 137169447,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541362450
    },
    {
        "content": "<p>Some people like to highlight the bare minimum, the std library likes to highlight whole functions, or largerish parts of functions.</p>",
        "id": 137169586,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541362763
    },
    {
        "content": "<p>This all might be too abstract, but one example of this practice is the <code>RawVec</code> module in case someone is wondering how this all looks in the standard library: <a href=\"https://github.com/rust-lang/rust/blob/master/src/liballoc/raw_vec.rs#L90\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/master/src/liballoc/raw_vec.rs#L90\">https://github.com/rust-lang/rust/blob/master/src/liballoc/raw_vec.rs#L90</a></p>",
        "id": 137169645,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541362847
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/blob/master/src/liballoc/raw_vec.rs#L239\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/master/src/liballoc/raw_vec.rs#L239\">https://github.com/rust-lang/rust/blob/master/src/liballoc/raw_vec.rs#L239</a></p>",
        "id": 137169653,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541362907
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/blob/master/src/liballoc/raw_vec.rs#L359\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/master/src/liballoc/raw_vec.rs#L359\">https://github.com/rust-lang/rust/blob/master/src/liballoc/raw_vec.rs#L359</a></p>",
        "id": 137169696,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541362937
    },
    {
        "content": "<p>This RawVec is the code where <a href=\"https://github.com/rust-lang/rust/issues/44800\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/44800\">CVE-2018-1000657</a> happened</p>",
        "id": 137169704,
        "sender_full_name": "Shnatsel",
        "timestamp": 1541362981
    },
    {
        "content": "<p>No, that CVE happened in <code>VecDeque</code>: <a href=\"https://github.com/rust-lang/rust/pull/44802/files\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/pull/44802/files\">https://github.com/rust-lang/rust/pull/44802/files</a></p>",
        "id": 137169772,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541363084
    },
    {
        "content": "<p>Good catch, I stand corrected. Apparently I forgot the details since I applied for CVE</p>",
        "id": 137169791,
        "sender_full_name": "Shnatsel",
        "timestamp": 1541363160
    },
    {
        "content": "<p><code>VecDeque</code> uses <code>RawVec</code>, and relies a lot in the exact behavior of some of <code>RawVec</code>'s internals for correctness (exact allocation doubling behavior, etc.), but that's another story..</p>",
        "id": 137169834,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541363179
    },
    {
        "content": "<p>I believe there was a safety regression this cycle in either VecDeque or RawVec, which was caught in beta or some such. I could look up the details if anyone's interested.</p>",
        "id": 137169838,
        "sender_full_name": "Shnatsel",
        "timestamp": 1541363205
    },
    {
        "content": "<p>haven't heard of that one, but having re-implemented most of <code>VecDeque</code> API in <code>SliceDeque</code>, it isn't hard to break safety with tiny mistakes while writing these types of data-structures</p>",
        "id": 137169897,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541363283
    },
    {
        "content": "<p>huh, is that some kind of fixed-capacity double-ended queue?</p>",
        "id": 137169922,
        "sender_full_name": "Shnatsel",
        "timestamp": 1541363399
    },
    {
        "content": "<p>it is dynamically-resizable, but the elements always form a contiguous slice</p>",
        "id": 137170011,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541363495
    },
    {
        "content": "<p>Ah, okay. I was hoping it could be a shortcut implementing <a href=\"https://internals.rust-lang.org/t/pre-rfc-fixed-capacity-view-of-vec/8413\" target=\"_blank\" title=\"https://internals.rust-lang.org/t/pre-rfc-fixed-capacity-view-of-vec/8413\">a fixed-capacity view of Vec</a>, because manually enforcing lack of reallocation in the undelying Vec is not fun, especially since Vec reallocation behavior is very loosely specified for methods that insert multiple elements.</p>",
        "id": 137170088,
        "sender_full_name": "Shnatsel",
        "timestamp": 1541363621
    },
    {
        "content": "<p>There is a prototype implementation that's even reasonably fast, but I'm pretty sure it still has some issues e.g. with panic safety for types implementing Drop</p>",
        "id": 137170136,
        "sender_full_name": "Shnatsel",
        "timestamp": 1541363670
    },
    {
        "content": "<p>I've seen that RFC but I had mixed feelings about it. I kind of wish that instead it would propose a <code>&amp;mut VecView</code> that would also work with <code>ArrayVec</code>, <code>SmallVec</code>, <code>Vec</code>, etc. Having such a type only for <code>Vec</code> feels a bit \"not widely-useful enough\".</p>",
        "id": 137170226,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541363872
    },
    {
        "content": "<p>That doesn't sound terribly hard to implement, actually. Currently we only have a constructor from Vec but there is no reason it wouldn't work with other types that have a properly aligned backing buffer with a known capacity and length.</p>",
        "id": 137170502,
        "sender_full_name": "Shnatsel",
        "timestamp": 1541364324
    },
    {
        "content": "<p>This <code>View</code> type only needs a <code>(*mut T,usize,usize)</code>, and it cannot grow the underlying vector anyways because <code>ArrayVec</code> cannot grow beyond its capacity, and growing a <code>SmallVec</code> is non-trivial either, so it kind of is what you are looking for, but works for more cases.</p>",
        "id": 137170563,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541364386
    },
    {
        "content": "<p>Post that to the thread. Sounds like a pretty good idea that's fairly easy to implement</p>",
        "id": 137170577,
        "sender_full_name": "Shnatsel",
        "timestamp": 1541364426
    },
    {
        "content": "<p>Here's a different take on the issue: What we're really trying to do is figure out which code is in the TCB (i.e., the set of code which, if buggy, could cause unsoundness), and which code isn't. Can we think of a way to automatically figure out (or at least estimate the size of) that TCB? I suspect the answer is \"no,\" but maybe we could get close with some code conventions?</p>",
        "id": 146818356,
        "sender_full_name": "Joshua Liebow-Feeser",
        "timestamp": 1541446732
    },
    {
        "content": "<p>So I'm late to this thread and just noted the \"Most functions in the std library using unsafe just wrap the whole function content in a big unsafe { ... } block\". I agree that that makes sense, given that unsafety 'leaks' to the wider scope, but should there then be a way of tagging the bits that need to be unsafe in order to compile? Maybe nested unsafe blocks could do that (if unused_unsafe warnings were off by defaut).</p>",
        "id": 158383989,
        "sender_full_name": "Grant Husbands",
        "timestamp": 1550002600
    },
    {
        "content": "<p>sounds like what I proposed here <a href=\"https://internals.rust-lang.org/t/crate-capability-lists/8933/2\" target=\"_blank\" title=\"https://internals.rust-lang.org/t/crate-capability-lists/8933/2\">https://internals.rust-lang.org/t/crate-capability-lists/8933/2</a></p>",
        "id": 158557954,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1550173250
    }
]