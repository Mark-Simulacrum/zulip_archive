[
    {
        "content": "<p>I understand that the <code>secrecy</code> crate does not prevent e.g. accidental stack moves: <a href=\"https://github.com/iqlusioninc/crates/issues/534\">https://github.com/iqlusioninc/crates/issues/534</a><br>\n<code>Pin</code> currently doesn't solve that either, because <code>Secret&lt;T&gt;</code> implements <code>Unpin</code>. So:</p>\n<ol>\n<li>Is there anything that we need to do other than adding <code>PhantomPinned</code> to <code>Secret</code> in order to support explicit pinning? Is there any reason why that's not actually done? Would recruiting community contributors to work on that help?</li>\n<li>Is there an easy way to incorporate pinning into <code>Secret</code> itself so that the users would not have to pin the value explicitly? Also, ditto for contributors.</li>\n</ol>",
        "id": 260583411,
        "sender_full_name": "Shnatsel",
        "timestamp": 1636303062
    },
    {
        "content": "<p>For 2. That would require heap allocating.</p>",
        "id": 260601558,
        "sender_full_name": "bjorn3",
        "timestamp": 1636327129
    },
    {
        "content": "<p>I should probably rephrase the question: is there a way to incorporate <code>Pin</code> into <code>Secret</code> in such a way that would make it difficult or impossible to forget to pin the stack value when creating the <code>Secret</code>? So that I could write <code>Secret&lt;T&gt;</code> instead of <code>Secret&lt;Pin&lt;T&gt;&gt;</code></p>",
        "id": 260602136,
        "sender_full_name": "Shnatsel",
        "timestamp": 1636327865
    },
    {
        "content": "<p>yes, it's something I've wanted to do for years and never had the time to work on</p>",
        "id": 260663331,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1636381644
    },
    {
        "content": "<p>I think its not possible for secrecy, unless you force secrets to live on the heap (and obviously secrets on the heap aren't a concern as much, since they don't have sensitive data copied on every move). Even future doesn't enforce this at construction time, only after you poll. Future polling is pretty close to when you create the future usually, since they represent computation you want to start on right away, but secrets are data. After construction, you might have to do stuff.</p>\n<p>There's stuff like <code>moveit</code>, which does a trick to store the constructor function and parameters in an object, but this means you'll end up copying stuff around still as part of the closure environment. And that stuff won't be zeroed on drop, since the secret isn't created yet.</p>",
        "id": 260672733,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1636385537
    },
    {
        "content": "<p>It's unfortunate. Maybe you could help encourage the right thing get by requiring Pin&lt;&amp;Self&gt; to access the value inside the secret, but it would be quite painful and it's not clear it would work that well either.</p>",
        "id": 260672863,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1636385603
    },
    {
        "content": "<p>forcing secrets to live on the heap is fine</p>",
        "id": 260673464,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1636385858
    },
    {
        "content": "<p>it has heapless support now but obviously keeping secrets on the heap solves a lot of problems</p>",
        "id": 260673519,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1636385881
    },
    {
        "content": "<p>I basically wanted to rewrite it with a <code>Box</code>-like primitive as the core primitive</p>",
        "id": 260673593,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1636385898
    },
    {
        "content": "<p>The following API would support both heap and stack pinning:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">use</span><span class=\"w\"> </span>::<span class=\"n\">core</span>::<span class=\"n\">marker</span>::<span class=\"n\">PhantomPinned</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">PhantomPinSensitive</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">struct</span> <span class=\"nc\">Secret</span><span class=\"o\">&lt;</span><span class=\"n\">S</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">S</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">PhantomPinSensitive</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">S</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Secret</span><span class=\"o\">&lt;</span><span class=\"n\">S</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// Note that `forget(Secret::new(…))`</span>\n<span class=\"w\">    </span><span class=\"cp\">#[cfg(feature = </span><span class=\"s\">\"alloc\"</span><span class=\"cp\">)]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"cp\">#[inline(always)]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"n\">secret</span>: <span class=\"nc\">S</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Pin</span><span class=\"o\">&lt;</span><span class=\"nb\">Box</span><span class=\"o\">&lt;</span><span class=\"bp\">Self</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"nb\">Box</span>::<span class=\"n\">pin</span><span class=\"p\">(</span><span class=\"n\">Secret</span><span class=\"p\">(</span><span class=\"n\">secret</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"err\">…</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"c1\">// Allocation-less API. Bonus: value cannot be leaked.</span>\n<span class=\"w\">    </span><span class=\"cp\">#[inline(always)]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">with_new</span><span class=\"o\">&lt;</span><span class=\"n\">R</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">secret</span>: <span class=\"nc\">S</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">scope</span>: <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"nb\">FnOnce</span><span class=\"p\">(</span><span class=\"n\">Pin</span><span class=\"o\">&lt;&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">Self</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">R</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">R</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">secret</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Secret</span><span class=\"p\">(</span><span class=\"n\">secret</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"err\">…</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">pin_mut</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">secret</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">scope</span><span class=\"p\">(</span><span class=\"n\">secret</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<ul>\n<li>(That being said, I'm not 100% convinced that a pure library abstraction can really defend against accidental copies of the secret in the stack or the heap; for instance, the constructor(s) take(s) an unwrapped secret (let's hope the <code>inline(always)</code> helps a bit with that). Moreover, any user-ergonomic API (<em>e.g.</em>, <code>new()</code>) will have the issue of not guaranteeing that the secret is eventually zeroed (imagine it being caught in a ref-count cycle). I thus personally find that, rather than the whole ordeal about zeroing on drop and so on, that the main use of <code>Secret</code> is its restricted API against accidental reads (<code>[Redacted …]</code> <code>Debug</code> impls are just <span aria-label=\"ok\" class=\"emoji emoji-1f44c\" role=\"img\" title=\"ok\">:ok:</span>); so I'd just not bother that much with <code>Pin</code>)</li>\n</ul>",
        "id": 260710064,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1636401471
    },
    {
        "content": "<blockquote>\n<p>The following API would support both heap and stack pinning</p>\n</blockquote>\n<p>Huh? It's using <code>Box</code>?</p>",
        "id": 260727714,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1636410211
    },
    {
        "content": "<p>that doesn't look bad per se but when I said \"heapless\" I meant no-alloc</p>",
        "id": 260727740,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1636410226
    },
    {
        "content": "<p>oh wait sorry</p>",
        "id": 260727797,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1636410247
    },
    {
        "content": "<p>it scrolled down after responding</p>",
        "id": 260727811,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1636410255
    },
    {
        "content": "<p>bad Zulip UX</p>",
        "id": 260727823,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1636410270
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232018\">@Daniel Henry-Mantilla</span> The lack of zeroing on an Rc cycle can be mitigated by an explicit zeroing call... but if you've put the data in RC you don't know when to zero it, I suppose.<br>\nBut what makes you think accidental copying cannot be prevented?</p>",
        "id": 261521931,
        "sender_full_name": "Shnatsel",
        "timestamp": 1636993736
    },
    {
        "content": "<p>Ah, the constructor accepts the secret as an argument... so without placement-new or some such there will be a copy of it on the stack regardless. Argh.</p>",
        "id": 261522075,
        "sender_full_name": "Shnatsel",
        "timestamp": 1636993798
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"127617\">Shnatsel</span> <a href=\"#narrow/stream/146229-wg-secure-code/topic/.60secrecy.60.20crate.20and.20.60Pin.60/near/261522075\">said</a>:</p>\n<blockquote>\n<p>Ah, the constructor accepts the secret as an argument... so without placement-new or some such there will be a copy of it on the stack regardless. Argh.</p>\n</blockquote>\n<p>Yeah, hence the suggestion for an<code>#[inline(always)]</code> and <span aria-label=\"pray\" class=\"emoji emoji-1f64f\" role=\"img\" title=\"pray\">:pray:</span></p>\n<hr>\n<p>It is technically possible to use generative lifetimes to brand an out parameter and prove that it has been initialized. The constructor would then be:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">S</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Secret</span><span class=\"o\">&lt;</span><span class=\"n\">S</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">new_with</span><span class=\"o\">&lt;'</span><span class=\"na\">scope</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">initializer</span>: <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"o\">&lt;'</span><span class=\"na\">id</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"nb\">FnOnce</span><span class=\"p\">(</span><span class=\"n\">Out</span><span class=\"o\">&lt;'</span><span class=\"na\">id</span><span class=\"p\">,</span><span class=\"w\">  </span><span class=\"o\">'</span><span class=\"na\">scope</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">ProofOfInit</span><span class=\"o\">&lt;'</span><span class=\"na\">id</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">      </span>-&gt; <span class=\"nc\">SmthSmthPinned</span><span class=\"o\">&lt;</span><span class=\"n\">S</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n</code></pre></div>\n<ul>\n<li>(The <code>'scope</code> could be removed for the sake of simplicity, but that could lead to a <a href=\"https://users.rust-lang.org/t/argument-requires-that-is-borrowed-for-static/66503/2?u=yandros\">non-upper-bounded hrtb lifetime</a>, which in practice could make the closure have to be <code>'static</code>, which would be inconvenient).</li>\n</ul>\n<p>And, for <code>struct</code>s, have a <code>derive</code> macro allowing for field-by-field init:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">out_point</span><span class=\"p\">.</span><span class=\"n\">init_with</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"p\">(</span><span class=\"n\">out_x</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">out_y</span><span class=\"p\">)</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">out_x</span><span class=\"p\">.</span><span class=\"n\">init</span><span class=\"p\">(</span><span class=\"err\">…</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">out_y</span><span class=\"p\">.</span><span class=\"n\">init</span><span class=\"p\">(</span><span class=\"err\">…</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"p\">))</span><span class=\"w\"></span>\n</code></pre></div>\n<p>But that signature (and the derive!) would just scare the hell out of any reasonable user <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>\n<p>I find it more reasonable to just mention that local copies in only-through-UB reachable data are not guaranteed to be prevented by <code>secrecy</code>, despite a genuine best effort to reduce them nonetheless <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 261540491,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1637001569
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"132721\">Tony Arcieri</span> <a href=\"#narrow/stream/146229-wg-secure-code/topic/.60secrecy.60.20crate.20and.20.60Pin.60/near/260727823\">said</a>:</p>\n<blockquote>\n<p>bad Zulip UX</p>\n</blockquote>\n<p>Bad indeed, I somehow missed the notification for your comments <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 261540612,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1637001627
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"132721\">Tony Arcieri</span> <a href=\"#narrow/stream/146229-wg-secure-code/topic/.60secrecy.60.20crate.20and.20.60Pin.60/near/260727740\">said</a>:</p>\n<blockquote>\n<p>that doesn't look bad per se</p>\n</blockquote>\n<p>Yeah, both are sensible additions, but for the by-value <code>secret</code> argument which is still around and so not fully preventing local <code>memcpy</code>-es</p>",
        "id": 261540820,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1637001743
    }
]