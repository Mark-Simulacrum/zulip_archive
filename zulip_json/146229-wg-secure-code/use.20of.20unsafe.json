[
    {
        "content": "<p>Ropey just got released as 1.0 and I got <a href=\"https://www.reddit.com/r/rust/comments/accvq7/ropey_10_an_editable_text_buffer_for_rust/ed938tv/?context=3\" target=\"_blank\" title=\"https://www.reddit.com/r/rust/comments/accvq7/ropey_10_an_editable_text_buffer_for_rust/ed938tv/?context=3\">an overview</a> of the use of unsafe code in it from the author. Haven't dug into the code yet, but this may be an interesting case for trying to exploit compiler optimizations without resorting to unsafe code.</p>",
        "id": 154438613,
        "sender_full_name": "Shnatsel",
        "timestamp": 1546637371
    },
    {
        "content": "<p>Reviving this thread. Anyone made stats on how unsafe is used? I'm thinking in FFI, Sync/Send (or other traits) or others.</p>",
        "id": 159797091,
        "sender_full_name": "snf",
        "timestamp": 1551533420
    },
    {
        "content": "<p>Afaik, <a href=\"https://github.com/anderejd/cargo-geiger\" target=\"_blank\" title=\"https://github.com/anderejd/cargo-geiger\">https://github.com/anderejd/cargo-geiger</a> is the best tool for analyzing unsafe code but it's missing FFI in its classification. Probably because it doesn't matter as long as it is unsafe code</p>",
        "id": 159797218,
        "sender_full_name": "snf",
        "timestamp": 1551533523
    },
    {
        "content": "<p>I have seen a number of common patterns of unsafe code usage in binary format decoders. We've even got a clippy warning for a (precursor to) one of them. If I don't get around to replying today, poke me tomorrow and I'll elaborate.</p>",
        "id": 159799059,
        "sender_full_name": "Shnatsel",
        "timestamp": 1551536014
    },
    {
        "content": "<p>Today I saw this in the libflate crate</p>\n<div class=\"codehilite\"><pre><span></span>let mut buf = Vec::new();\n    loop {\n        let b = reader.read_u8()?;\n        if b == 0 {\n            return Ok(unsafe { CString::from_vec_unchecked(buf) });\n        }\n        buf.push(b);\n    }\n</pre></div>\n\n\n<p>If you look closely you can see that this is actually safe, since there could be no NULL characters in between. I guess they probably did this for performance reasons, such that they don't have to check the whole Vec for intermediary NULL characters.</p>\n<p>Now I am not a pro, but I think it should not be too hard to create a method for this. I wouldn't be surprised if this occurs more often.<br>\nThe options that pop up in my mind:</p>\n<p>1. Implement Read::read_cstring() -&gt; CString            (this could be implemented by the trait itself, using Read::read() -&gt; u8)<br>\n2. Implement CString::read&lt;T: impl Read&gt;(readable: T) -&gt; CString<br>\n3. Add some utility methods to a crate like byteorder that could read from a Read trait.<br>\nForgive me the names of the functions, though, it's about the general idea :)</p>\n<p>Curious to what you guys think!</p>",
        "id": 160792733,
        "sender_full_name": "DevQps",
        "timestamp": 1552577996
    },
    {
        "content": "<p>sounds good, but note that <code>read_u8</code>doesn't seem to be part of the <code>Read</code> trait either, must be elsewhere in that crate or its deps. If it weren't for that, I think Option 2 seems most appropriate</p>",
        "id": 160808352,
        "sender_full_name": "Daniel Carosone",
        "timestamp": 1552588176
    },
    {
        "content": "<p>I think this can be rewritten using <code>read_until()</code>: <a href=\"https://doc.rust-lang.org/std/io/trait.BufRead.html#method.read_until\" target=\"_blank\" title=\"https://doc.rust-lang.org/std/io/trait.BufRead.html#method.read_until\">https://doc.rust-lang.org/std/io/trait.BufRead.html#method.read_until</a></p>",
        "id": 160819714,
        "sender_full_name": "Shnatsel",
        "timestamp": 1552595683
    },
    {
        "content": "<p>Could you provide some context for that code? It's strange to see a pure-Rust library use a <code>CString</code> at all.</p>",
        "id": 160819841,
        "sender_full_name": "Shnatsel",
        "timestamp": 1552595768
    },
    {
        "content": "<p>Not directly relevant, but I just wanted to jot down some notes while we're discussing libflate: <a href=\"https://github.com/sile/libflate/blob/74c2b8bd5072cd9ca676d5b92ee326e64a01827f/src/lz77/default.rs#L108-L117\" target=\"_blank\" title=\"https://github.com/sile/libflate/blob/74c2b8bd5072cd9ca676d5b92ee326e64a01827f/src/lz77/default.rs#L108-L117\">https://github.com/sile/libflate/blob/74c2b8bd5072cd9ca676d5b92ee326e64a01827f/src/lz77/default.rs#L108-L117</a><br>\nThis function has caused trouble for the second time in a row. The function declaration is definitely wrong, the code as-is should be annotated <code>unsafe fn</code> because it doesn't validate that the length of the input is greater than 3.<br>\nBut we actually want that function to be safe, so we want to validate that. The cheap way to do it is either an assert at the beginning, or subslice it <code>[0..3]</code> and look up values from that. This creates only one bounds check.<br>\nSince the function is marked <code>#[inline(always)]</code> rustc should elide the bounds check entirely where appropriate. The next step is to find if there are any hot loops which are using this function and check bounds for the entire loop just once, if possible. You can do that without explicit <code>unsafe</code> if you do the checks up front and the optimizer figures out that they can be elided in the loop.</p>",
        "id": 160820425,
        "sender_full_name": "Shnatsel",
        "timestamp": 1552596211
    },
    {
        "content": "<blockquote>\n<p>sounds good, but note that <code>read_u8</code>doesn't seem to be part of the <code>Read</code> trait either, must be elsewhere in that crate or its deps. If it weren't for that, I think Option 2 seems most appropriate</p>\n</blockquote>\n<p>Ah my bad... I thought it provided such a method but apparently it does not..</p>",
        "id": 160823099,
        "sender_full_name": "DevQps",
        "timestamp": 1552598059
    },
    {
        "content": "<blockquote>\n<p>I think this can be rewritten using <code>read_until()</code>: <a href=\"https://doc.rust-lang.org/std/io/trait.BufRead.html#method.read_until\" target=\"_blank\" title=\"https://doc.rust-lang.org/std/io/trait.BufRead.html#method.read_until\">https://doc.rust-lang.org/std/io/trait.BufRead.html#method.read_until</a></p>\n</blockquote>\n<p>The code is from here!: <a href=\"https://github.com/sile/libflate/blob/a7cd7995458ace28ed388ba0d1374bfdc4b495e5/src/gzip.rs\" target=\"_blank\" title=\"https://github.com/sile/libflate/blob/a7cd7995458ace28ed388ba0d1374bfdc4b495e5/src/gzip.rs\">https://github.com/sile/libflate/blob/a7cd7995458ace28ed388ba0d1374bfdc4b495e5/src/gzip.rs</a><br>\nI see that they use the byteorder crate (with ReadBytesExt) to do the read_u8() call.</p>\n<p>I must say read_until() looks promising, however when I smell my mustache I feel like something's not quite right. </p>\n<p>Let's take for example libflate. I can image that someone wants their Decoder to be used with anything that implement Read right? Regardless of when it implements BufRead or not. I can imagine someone implementing some kind of  structure that implements Read but not BufRead, without having to perform expensive system calls. Or does this make no sense?  </p>\n<p>I thought repeatedly reading a single byte with Read::read would be really slow, but I see that the byteorder ReadBytesExt::read_u8 does exactly this. Therefore we could technically create a Read::read_until method that uses Read::read without performance overhead (as long as the object implementing Read::read is efficient)</p>",
        "id": 160824124,
        "sender_full_name": "DevQps",
        "timestamp": 1552598824
    },
    {
        "content": "<blockquote>\n<p>Not directly relevant, but I just wanted to jot down some notes while we're discussing libflate: <a href=\"https://github.com/sile/libflate/blob/74c2b8bd5072cd9ca676d5b92ee326e64a01827f/src/lz77/default.rs#L108-L117\" target=\"_blank\" title=\"https://github.com/sile/libflate/blob/74c2b8bd5072cd9ca676d5b92ee326e64a01827f/src/lz77/default.rs#L108-L117\">https://github.com/sile/libflate/blob/74c2b8bd5072cd9ca676d5b92ee326e64a01827f/src/lz77/default.rs#L108-L117</a><br>\nThis function has caused trouble for the second time in a row. The function declaration is definitely wrong, the code as-is should be annotated <code>unsafe fn</code> because it doesn't validate that the length of the input is greater than 3.<br>\nBut we actually want that function to be safe, so we want to validate that. The cheap way to do it is either an assert at the beginning, or subslice it <code>[0..3]</code> and look up values from that. This creates only one bounds check.<br>\nSince the function is marked <code>#[inline(always)]</code> rustc should elide the bounds check entirely where appropriate. The next step is to find if there are any hot loops which are using this function and check bounds for the entire loop just once, if possible. You can do that without explicit <code>unsafe</code> if you do the checks up front and the optimizer figures out that they can be elided in the loop.</p>\n</blockquote>\n<p>As for this!: I saw this as well! It looked like it could easily go wrong if the slice is not exactly 3 bytes. I am not sure however how easy that is to happen. Personally I kind of feel like a single bound check should not degrade performance by that much and I'd rather have safe code then something that squeezes out a few extra micro/milliseconds. I will at least take a look at this! Hopefully I have some time tomorrow!</p>",
        "id": 160824481,
        "sender_full_name": "DevQps",
        "timestamp": 1552599033
    },
    {
        "content": "<p>I think the better question to ask would be why does it use <code>CString</code> at all. It's not the read part that's unsafe, it's the CString part.</p>",
        "id": 160824522,
        "sender_full_name": "Shnatsel",
        "timestamp": 1552599067
    },
    {
        "content": "<p>Build a benchmark with Criterion and you'll know instead of guessing: <a href=\"https://bheisler.github.io/criterion.rs/book/index.html\" target=\"_blank\" title=\"https://bheisler.github.io/criterion.rs/book/index.html\">https://bheisler.github.io/criterion.rs/book/index.html</a><br>\nI'm pretty sure I've already made one for <code>inflate</code> crate, so you can mostly reuse that for <code>libflate</code>: <a href=\"https://github.com/Shnatsel/inflate/tree/benchmarking\" target=\"_blank\" title=\"https://github.com/Shnatsel/inflate/tree/benchmarking\">https://github.com/Shnatsel/inflate/tree/benchmarking</a><br>\nBonus points for contributing it upstream.</p>",
        "id": 160824686,
        "sender_full_name": "Shnatsel",
        "timestamp": 1552599188
    },
    {
        "content": "<blockquote>\n<p>I think the better question to ask would be why does it use <code>CString</code> at all. It's not the read part that's unsafe, it's the CString part.</p>\n</blockquote>\n<p>I figured out that it's used for reading the GZIP header which stores the filename and potential comments as a null-terminated String. It seems like the unsafe function is used for both the filename and the comment field.</p>",
        "id": 160825569,
        "sender_full_name": "DevQps",
        "timestamp": 1552599822
    },
    {
        "content": "<p>Any reason why a plain old Vec doesn't cut it?</p>",
        "id": 160825898,
        "sender_full_name": "Shnatsel",
        "timestamp": 1552600030
    },
    {
        "content": "<blockquote>\n<p>I think the better question to ask would be why does it use <code>CString</code> at all. It's not the read part that's unsafe, it's the CString part.</p>\n</blockquote>\n<p>Mmm I agree that the function call of CString is what makes it unsafe, but wouldn't you say that there should be a safe method for reading a CString without having to do loop over a buffer twice? Like reading and constructing a CString such that one can safely construct a CString while knowing that there are no null characters in between? I wouldn't be surprised if other projects would use the unchecked version as well just for performance reasons, while shouldn't be strictly necessary I think :)</p>",
        "id": 160825907,
        "sender_full_name": "DevQps",
        "timestamp": 1552600041
    },
    {
        "content": "<p>Wait... I suddenly feel like I am beginning to understand things haha :)</p>\n<p>We can probably just replace the loop and fill the buffer without the null character and then convert it to a String or str somehow right?</p>",
        "id": 160826048,
        "sender_full_name": "DevQps",
        "timestamp": 1552600164
    },
    {
        "content": "<p>String or &amp;str must be valid UTF-8, these are just bytes. It should be a vector.</p>",
        "id": 160826131,
        "sender_full_name": "Shnatsel",
        "timestamp": 1552600204
    },
    {
        "content": "<blockquote>\n<p>String or &amp;str must be valid UTF-8, these are just bytes. It should be a vector.</p>\n</blockquote>\n<p>That sounds good. I see that they also have calls like: get_filename and get_comment. Do you think these should return Vectors as well?</p>",
        "id": 160826190,
        "sender_full_name": "DevQps",
        "timestamp": 1552600253
    },
    {
        "content": "<p>Unless the function is passing the CString to some C code, the same guarantee (that the sequence is null-terminated) can be achieved by introducing a NullTerminatedVec newtype, with constructor that accepts a Vec and implements Deref into Vec</p>",
        "id": 160826203,
        "sender_full_name": "Shnatsel",
        "timestamp": 1552600261
    },
    {
        "content": "<p>If they have <code>CString</code> in the public API, you're probably stuck with them though</p>",
        "id": 160826236,
        "sender_full_name": "Alex Gaynor",
        "timestamp": 1552600297
    },
    {
        "content": "<p>Well, you could convert them into slices I guess</p>",
        "id": 160826349,
        "sender_full_name": "Shnatsel",
        "timestamp": 1552600348
    },
    {
        "content": "<p>They do have this kind of code:</p>\n<div class=\"codehilite\"><pre><span></span>/// Returns the file name.\n    pub fn filename(&amp;self) -&gt; Option&lt;&amp;CString&gt; {\n        self.filename.as_ref()\n    }\n\n    /// Returns the comment.\n    pub fn comment(&amp;self) -&gt; Option&lt;&amp;CString&gt; {\n        self.comment.as_ref()\n    }\n</pre></div>\n\n\n<p>but they do not pass it anywhere to C code.</p>",
        "id": 160826375,
        "sender_full_name": "DevQps",
        "timestamp": 1552600373
    },
    {
        "content": "<p>So I guess we're stuck then?</p>",
        "id": 160826400,
        "sender_full_name": "DevQps",
        "timestamp": 1552600388
    },
    {
        "content": "<p>It's probably to return the information as it is in the file</p>",
        "id": 160826425,
        "sender_full_name": "snf",
        "timestamp": 1552600420
    },
    {
        "content": "<p>Actually, could Vector maybe implement <code>.into(CString)</code>?</p>",
        "id": 160826432,
        "sender_full_name": "Shnatsel",
        "timestamp": 1552600425
    },
    {
        "content": "<p>Not slice, but vector</p>",
        "id": 160826453,
        "sender_full_name": "Shnatsel",
        "timestamp": 1552600441
    },
    {
        "content": "<p>That could be implemented safely and efficiently</p>",
        "id": 160826509,
        "sender_full_name": "Shnatsel",
        "timestamp": 1552600460
    },
    {
        "content": "<p>I think there ir CString::from(Vec&lt;u8&gt;), it will probably require iterating it though</p>",
        "id": 160826526,
        "sender_full_name": "snf",
        "timestamp": 1552600480
    },
    {
        "content": "<p>How could it be done efficiently? It'd need a linear scan right?</p>",
        "id": 160826528,
        "sender_full_name": "Alex Gaynor",
        "timestamp": 1552600482
    },
    {
        "content": "<p>That would probably work, however I guess that would require checking if there are any null terminated characters in the content as well.</p>",
        "id": 160826530,
        "sender_full_name": "DevQps",
        "timestamp": 1552600485
    },
    {
        "content": "<p><code>CString::new</code> uses <code>memchr</code>, so it's probably pretty fast, though obviously still O(n)</p>",
        "id": 160826580,
        "sender_full_name": "Alex Gaynor",
        "timestamp": 1552600534
    },
    {
        "content": "<p>The thing is this I guess:</p>\n<p>CString supports a safe way to read the CString namely CString::new. But that method checks the whole buffer again for intermediary null characters. So for performance reasons CString::from_vec_unchecked is used. If we would do a Vec to CString I guess in order to be safe we would also have to perform the check again right? Or am I wrong about this?</p>",
        "id": 160826670,
        "sender_full_name": "DevQps",
        "timestamp": 1552600610
    },
    {
        "content": "<p>I think you're right -- we really need a <code>CString::from_reader</code> or something like that</p>",
        "id": 160826692,
        "sender_full_name": "Alex Gaynor",
        "timestamp": 1552600640
    },
    {
        "content": "<blockquote>\n<p>I think you're right -- we really need a <code>CString::from_reader</code> or something like that</p>\n</blockquote>\n<p>I personally think this would solve many problems as well. You don't have to sacrifice performance and it would still be safe.</p>",
        "id": 160826720,
        "sender_full_name": "DevQps",
        "timestamp": 1552600674
    },
    {
        "content": "<p>Yeah <code>CString::from_reader</code> sounds like a good idea. However, CString in public API still sounds like a really bad idea.</p>",
        "id": 160826837,
        "sender_full_name": "Shnatsel",
        "timestamp": 1552600798
    },
    {
        "content": "<p>Yeah, that also seems like a mistake</p>",
        "id": 160826918,
        "sender_full_name": "Alex Gaynor",
        "timestamp": 1552600841
    },
    {
        "content": "<p>I guess we all agree on that! :) If you guys would like it I can create an issue and submit a pull request?</p>",
        "id": 160826971,
        "sender_full_name": "DevQps",
        "timestamp": 1552600902
    },
    {
        "content": "<p>Adding <code>CString::from_reader</code> or changing libflate API?</p>",
        "id": 160827025,
        "sender_full_name": "Shnatsel",
        "timestamp": 1552600931
    },
    {
        "content": "<p>First adding CString::from_reader and then changing libflate as well! It will probably take a while till the CString PR would get through, so I could look at other problems with libflate as well.</p>",
        "id": 160827074,
        "sender_full_name": "DevQps",
        "timestamp": 1552601000
    },
    {
        "content": "<p>Or do you think I am running too fast with this?</p>",
        "id": 160827235,
        "sender_full_name": "DevQps",
        "timestamp": 1552601158
    },
    {
        "content": "<p>Nah, go right ahead! I think prototyping it locally would be a good start, then you can create an RFC describing the behavior and a PR against standard library.</p>",
        "id": 160827572,
        "sender_full_name": "Shnatsel",
        "timestamp": 1552601416
    },
    {
        "content": "<p>I think just adding a single new method to <code>CString</code> wouldn't require an RFC, but I'm not positive.</p>",
        "id": 160827602,
        "sender_full_name": "Alex Gaynor",
        "timestamp": 1552601445
    },
    {
        "content": "<p>Start with a PR and they'll tell you if an RFC is needed or not :)</p>",
        "id": 160827625,
        "sender_full_name": "Shnatsel",
        "timestamp": 1552601468
    },
    {
        "content": "<p>Also we should start collecting info on the patterns we find that are missing. I have put a lot of work into one back in the day, along with a proposal to fix it, although my implementation turned out to be too fragile for my liking: <a href=\"https://internals.rust-lang.org/t/pre-rfc-fixed-capacity-view-of-vec/8413/1\" target=\"_blank\" title=\"https://internals.rust-lang.org/t/pre-rfc-fixed-capacity-view-of-vec/8413/1\">https://internals.rust-lang.org/t/pre-rfc-fixed-capacity-view-of-vec/8413/1</a></p>",
        "id": 160827661,
        "sender_full_name": "Shnatsel",
        "timestamp": 1552601515
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130046\">@Alex Gaynor</span> Unstable methods, especially on non-traits, definitely don't need RFCs for the most part</p>",
        "id": 160827776,
        "sender_full_name": "simulacrum",
        "timestamp": 1552601618
    },
    {
        "content": "<p>OTOH, stabilizing one might -- depending on the amount of thorny questions around the API. Probably not though.</p>",
        "id": 160827793,
        "sender_full_name": "simulacrum",
        "timestamp": 1552601636
    },
    {
        "content": "<p>I will first make a small draft of the function tomorrow and share it with you guys, so you can review it first. Since I am not a very experienced Rust programmer that might be the best option! I'll go catch some sleep now and I'll tune in tomorrow again! Thanks for the nice discussion (Y)!</p>",
        "id": 160827986,
        "sender_full_name": "DevQps",
        "timestamp": 1552601775
    },
    {
        "content": "<p>Is there anything we want to cover other than <code>BufReader</code> types? That would make implementation trivial, and would cover most use cases since <code>Cursor</code> implements <code>BufReader</code> and if you're doing external I/O you probably want to wrap that in a BufReader as well.</p>",
        "id": 160828047,
        "sender_full_name": "Shnatsel",
        "timestamp": 1552601843
    },
    {
        "content": "<p>OTOH I'm not sure how that meshes with the <code>byteorder</code> use case, which might be a deal-breaker</p>",
        "id": 160828151,
        "sender_full_name": "Shnatsel",
        "timestamp": 1552601913
    },
    {
        "content": "<p>Perhaps Byteorder could expose a <code>u8_reader</code> that implements BufReader if the underlying reader does as well</p>",
        "id": 160828478,
        "sender_full_name": "Shnatsel",
        "timestamp": 1552602272
    },
    {
        "content": "<p>Alright guys! I made my initial version: </p>\n<div class=\"codehilite\"><pre><span></span>pub fn CString::from_reader(mut reader: impl Read) -&gt; Result&lt;CString, std::io::Error&gt;\n{\n    let mut buffer = Vec::new();\n    loop {\n        // Read a single byte, same way as byteorder::read_u8 does it (using std::slice however).\n        // If the specific implementation of Read::read is buffered and inlined\n        // I am quite sure this can be optimized well.\n        let mut character: u8 = 0;\n        let slice = std::slice::from_mut(&amp;mut character);\n        reader.read_exact(slice)?;\n\n        // Push a new character.\n        buffer.push(character);\n\n        // Check if a null character has been found, if so return the Vec as CString.\n        if character == 0 {\n            return Ok(CString { inner: buffer.into_boxed_slice() });\n        }\n    }\n}\n</pre></div>\n\n\n<p>Here is a playground version of it but since I cannot construct CString directly I modified the code slightly for it to work (moving the buffer line and replacing it with from_vec_unchecked). But the general idea is the same.</p>\n<p>Playground version: <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=59f4f97198d6d5a3310064770be2f4e1\" target=\"_blank\" title=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=59f4f97198d6d5a3310064770be2f4e1\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=59f4f97198d6d5a3310064770be2f4e1</a></p>",
        "id": 160871318,
        "sender_full_name": "DevQps",
        "timestamp": 1552654324
    },
    {
        "content": "<p>Let me know what you guys think! </p>\n<p>The only thing that kind of itches me is the initial capacity of a Vec. It feels like it would be a bit of a shame if Vec has to allocate multiple times because the to-be-read string is longer then expected. I am not sure if it would be overkill, but maybe we should create another method that allows a user to specify the default capacity?</p>",
        "id": 160871515,
        "sender_full_name": "DevQps",
        "timestamp": 1552654518
    },
    {
        "content": "<p>So another idea occurred to me; should <code>CString</code> support a safe <code>from</code> method that takes <code>Vec&lt;NonZeroU8&gt;</code>? Because it's <code>repr(transparent)</code> I think you can cheat and convert it into a <code>&amp;[u8]</code> with some magic <code>unsafe</code>.</p>",
        "id": 160903960,
        "sender_full_name": "Alex Gaynor",
        "timestamp": 1552676703
    },
    {
        "content": "<p>Why not <code>unsafe {CString::from_vec_unchecked(buffer)}</code>? That sounds like the obvious thing from performance standpoint. People will just roll their own version of this if the stdlib function doesn't work like that.</p>",
        "id": 160908636,
        "sender_full_name": "Shnatsel",
        "timestamp": 1552680005
    },
    {
        "content": "<p>Why not what? That's what people seem to be doing now, the question was how do we reduce the need to write <code>unsafe</code>?</p>",
        "id": 160908680,
        "sender_full_name": "Alex Gaynor",
        "timestamp": 1552680036
    },
    {
        "content": "<p>Oh, I meant to ask why is that not in the function code posted above. My thinking was that we write the function with that unsafe block once and expose a safe interface, and everybody else can use it to get speed without rolling their own <code>unsafe</code>.</p>",
        "id": 160908826,
        "sender_full_name": "Shnatsel",
        "timestamp": 1552680151
    },
    {
        "content": "<p>Oh, sure, that works. My suggestion about something taking <code>Vec&lt;NonZeroU8&gt;</code> was mostly because that has the interesting property that it can be safe and fast.</p>",
        "id": 160918065,
        "sender_full_name": "Alex Gaynor",
        "timestamp": 1552688262
    },
    {
        "content": "<p>About the unsafe CString::from_vec_unchecked!: I guess it is because it uses reserve_exact right? Otherwise the code is exactly identical. But I agree that might be better! We would introduce calling an unsafe method to the from_reader method, but in terms of behavior it would be just as unsafe as constructing it directly. If the from_vec_unchecked call is inlined we have the same (optimal) performance!</p>\n<p>Are there any other things you'd suggest me to change? Otherwise I can open a PR for this! I wonder however about the procedure. Should I first create an issue on the Rust repo for this? Or can I directly make a pull request?</p>",
        "id": 160921037,
        "sender_full_name": "DevQps",
        "timestamp": 1552691313
    },
    {
        "content": "<p>you can send a PR without an issue</p>",
        "id": 160921144,
        "sender_full_name": "Alex Gaynor",
        "timestamp": 1552691404
    },
    {
        "content": "<p>Okay thanks for that info! It's already 0:12 here, so I will create one and link it back here tomorrow.</p>",
        "id": 160921317,
        "sender_full_name": "DevQps",
        "timestamp": 1552691633
    },
    {
        "content": "<p>Good night guys :)</p>",
        "id": 160921318,
        "sender_full_name": "DevQps",
        "timestamp": 1552691638
    },
    {
        "content": "<p>And btw Alex! I think its a cool idea! However I was wondering: How can one construct a Vec&lt;NonZeroU8&gt; safely without suffering the performance check of having to check if it is non-zero? Or do you think the compiler can optimise this? I could check if it does tomorrow if you're not sure</p>",
        "id": 160921643,
        "sender_full_name": "DevQps",
        "timestamp": 1552691999
    },
    {
        "content": "<p>Check where? In the sample from libflate, you're already checking if each byte is 0, this would simply change that check into constructing a new <code>NonZeroU8</code></p>",
        "id": 160933294,
        "sender_full_name": "Alex Gaynor",
        "timestamp": 1552709189
    },
    {
        "content": "<p>Ahhh in that sense! I think that would be a great approach as well! What about implementing the From&lt;Vec&lt;NonZeroU8&gt;&gt; for CString? That way we can consume the buffer and use it for the CString.</p>",
        "id": 160941752,
        "sender_full_name": "DevQps",
        "timestamp": 1552724507
    },
    {
        "content": "<p>Maybe that is even better actually. I always felt like CString::from_reader is a bit akward... I think using the From trait would introduce less clutter but it would mean that people have to code reading byte by byte just as I did before themselves, but I that doesn't have to be a problem perse.</p>",
        "id": 160941863,
        "sender_full_name": "DevQps",
        "timestamp": 1552724724
    },
    {
        "content": "<p>Alright, I guess we have two methods of doing this right now:</p>\n<p><strong>Method 1: Using CString::from_reader</strong><br>\n<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=49cecd94f4cc0e1c09dc83deca5c91ee\" target=\"_blank\" title=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=49cecd94f4cc0e1c09dc83deca5c91ee\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=49cecd94f4cc0e1c09dc83deca5c91ee</a></p>\n<ul>\n<li>Ease of use: People only require one line of code to get what they want, namely CString::from_reader<br>\n-/+ Flexibility: Can only be used on items that implement Read. On the other hand: &amp;[u8] implements Read so in some sense it is quite flexible I guess?</li>\n</ul>\n<p><strong>Method 2: Using From&lt;Vec&lt;NonZeroU8&gt;&gt;</strong><br>\n<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2018&amp;gist=3a4a90b19e7e7d3fdd80f9f1f48edeb9\" target=\"_blank\" title=\"https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2018&amp;gist=3a4a90b19e7e7d3fdd80f9f1f48edeb9\">https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2018&amp;gist=3a4a90b19e7e7d3fdd80f9f1f48edeb9</a></p>\n<ul>\n<li>Ease of use: People are required to manually read bytes into a Vec&lt;NonZeroU8&gt;</li>\n<li>Flexibility: Everything that can be converted to Vec&lt;NonZeroU8&gt; can be converted to a CString, not only objects that implement Read.</li>\n</ul>\n<p>Additional Question: Maybe we should provide both methods?</p>\n<p>Personally I feel like the second option just feels more right... The only thing I am worried about is that people find it too complex and will use do something unsafe because they have no knowledge on how to do it right.</p>",
        "id": 160945170,
        "sender_full_name": "DevQps",
        "timestamp": 1552730862
    },
    {
        "content": "<p>I decided to create an issue: <a href=\"https://github.com/rust-lang/rust/issues/59229\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/59229\">https://github.com/rust-lang/rust/issues/59229</a> such that we can continue the discussion there. I am also wondering if there are other people of the Rust community that have any solutions on their minds. To be really honest, I think implementing both methods we have come up with so far does not sound so bad.</p>",
        "id": 160946120,
        "sender_full_name": "DevQps",
        "timestamp": 1552732546
    },
    {
        "content": "<p><code>NonZeroU8</code> seems like a great way to arrange for the null check to happen once, and to communicate safely using types that it's already happened</p>",
        "id": 161117195,
        "sender_full_name": "Daniel Carosone",
        "timestamp": 1552965738
    },
    {
        "content": "<p><em>but</em> it won't carry the NULL terminator, so some copying is needed to get a contiguous 0u8 on the end in the CString's storage.</p>",
        "id": 161117274,
        "sender_full_name": "Daniel Carosone",
        "timestamp": 1552965874
    },
    {
        "content": "<p>You don't need to copy, since you're passing ownership of the <code>Vec</code> to <code>CString</code> you can just append to it -- after stealing the storage and converting it to a <code>Vec&lt;u8&gt;</code> of course.</p>",
        "id": 161117318,
        "sender_full_name": "Alex Gaynor",
        "timestamp": 1552965940
    },
    {
        "content": "<p>yeah, so long as the Vec has capacity +1</p>",
        "id": 161117366,
        "sender_full_name": "Daniel Carosone",
        "timestamp": 1552965966
    },
    {
        "content": "<p>I will implement the CString::from_reader function tomorrow hopefully!</p>",
        "id": 161124686,
        "sender_full_name": "DevQps",
        "timestamp": 1552976886
    },
    {
        "content": "<p>We can probably do the From&lt;NonZeroU8&gt; conversion in a separate PR</p>",
        "id": 161124696,
        "sender_full_name": "DevQps",
        "timestamp": 1552976921
    },
    {
        "content": "<p>The pull request for CString::from_reader is here!: <a href=\"https://github.com/rust-lang/rust/pull/59314\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/pull/59314\">https://github.com/rust-lang/rust/pull/59314</a></p>",
        "id": 161253393,
        "sender_full_name": "DevQps",
        "timestamp": 1553092885
    },
    {
        "content": "<p>If you have any comments, please let me know!</p>",
        "id": 161253405,
        "sender_full_name": "DevQps",
        "timestamp": 1553092892
    },
    {
        "content": "<p>I was reading through some old T-Doc issues and I found this one:<br>\n<a href=\"https://github.com/rust-lang/rust/issues/54542\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/54542\">https://github.com/rust-lang/rust/issues/54542</a></p>\n<p>Maybe we can try to create an abstraction for this?</p>",
        "id": 162113561,
        "sender_full_name": "DevQps",
        "timestamp": 1553938411
    },
    {
        "content": "<p>not sure where else to ask this or who might know (perhaps <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> ) but I'm wondering if there's a safe way to do <code>AsRef</code>-style reference conversions for wrapper newtypes for other references now, possibly with something like <code>#[repr(transparent)]</code></p>",
        "id": 171334776,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1563642277
    },
    {
        "content": "<p>the use case is something like <code>std::path::Path</code> (but my own custom path type for different purposes), where I also have an owned <code>PathBuf</code> type, want for it to be able to impl <code>AsRef&lt;Path&gt;</code>, and then use <code>AsRef&lt;Path&gt;</code> as a bound so you can interchangeably pass either a <code>&amp;PathBuf</code> or a <code>&amp;Path</code></p>",
        "id": 171334792,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1563642356
    },
    {
        "content": "<p>and how to <code>impl AsRef&lt;Path&gt; for PathBuf</code> without using <code>unsafe</code></p>",
        "id": 171334838,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1563642391
    },
    {
        "content": "<p>I believe <code>std</code> uses <code>transmute</code> <span aria-label=\"grimacing\" class=\"emoji emoji-1f62c\" role=\"img\" title=\"grimacing\">:grimacing:</span></p>",
        "id": 171334841,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1563642411
    },
    {
        "content": "<p>Related discussion on special (safe) syntax for <code>#[repr(transparent)]</code> reference conversion on internals: <a href=\"https://internals.rust-lang.org/t/pre-rfc-patterns-allowing-transparent-wrapper-types/10229\" target=\"_blank\" title=\"https://internals.rust-lang.org/t/pre-rfc-patterns-allowing-transparent-wrapper-types/10229\">https://internals.rust-lang.org/t/pre-rfc-patterns-allowing-transparent-wrapper-types/10229</a></p>",
        "id": 171334918,
        "sender_full_name": "HeroicKatora",
        "timestamp": 1563642563
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"229913\">@Andreas Molzer</span> exactly what I'm looking for! thank you</p>",
        "id": 171334925,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1563642602
    },
    {
        "content": "<p>HeroicKatora? I know this guy, he took over maintenance of <code>png</code>, <code>inflate</code> and a bunch of other formerly Piston projects, and getting safety fixed merged got way easier since. Always very helpful on PRs. Kudos to that guy.</p>",
        "id": 171335242,
        "sender_full_name": "Shnatsel",
        "timestamp": 1563643168
    },
    {
        "content": "<p>would love to see something like this. in the meantime I'm using <code>Into</code> instead of <code>AsRef</code> as the bound, in order to create an owned wrapper rather than a reference. that mostly works except I'd love to have my <code>PathBuf</code> also impl <code>Deref&lt;Target=Path&gt;</code> but that's not possible without a reference conversion <span aria-label=\"cry\" class=\"emoji emoji-1f622\" role=\"img\" title=\"cry\">:cry:</span></p>",
        "id": 171335702,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1563644030
    },
    {
        "content": "<p>and in absence of being able to impl <code>Deref</code> I'm instead writing wrapper functions on <code>PathBuf</code> that delegate to <code>Path</code></p>",
        "id": 171335745,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1563644078
    },
    {
        "content": "<p>I imagine if this sort of feature lands, there's all sorts of places in <code>std</code> that could use it too...</p>",
        "id": 171335751,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1563644137
    },
    {
        "content": "<p>so the question is how to do this without writing <code>unsafe</code>? Sorry, I don't know. :/</p>",
        "id": 171338733,
        "sender_full_name": "RalfJ",
        "timestamp": 1563649548
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> yes, exactly. the pre-RFC <span class=\"user-mention\" data-user-id=\"229913\">@Andreas Molzer</span> linked has a suggested casting syntax</p>",
        "id": 171338843,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1563649750
    },
    {
        "content": "<p>which would do exactly what I want</p>",
        "id": 171338844,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1563649760
    },
    {
        "content": "<p>I just want to cast the inner <code>&amp;'a T</code> into a <code>&amp;'a MyNewtype</code> which is a <code>#[repr(transparent)]</code> 1-tuple newtype for <code>&amp;'a T</code></p>",
        "id": 171338891,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1563649824
    },
    {
        "content": "<p>Is there a way to assert/static_assert that a type is transparent?<br>\nI feel like if there was, a simple macro could probably do this</p>",
        "id": 173997715,
        "sender_full_name": "Nick12",
        "timestamp": 1566589929
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"219940\">@Nick12</span> try asking in #black_magic in Rust Community Discord</p>",
        "id": 174260234,
        "sender_full_name": "Shnatsel",
        "timestamp": 1566932917
    }
]