[
    {
        "content": "<p>Continuining the conversation from here: <a href=\"#narrow/stream/189812-t-compiler.2Fwg-rfc-2229/topic/refactoring.20.60hir.3A.3APlace.60.20and.20.60hir_id.60/near/200247505\">https://rust-lang.zulipchat.com/#narrow/stream/189812-t-compiler.2Fwg-rfc-2229/topic/refactoring.20.60hir.3A.3APlace.60.20and.20.60hir_id.60/near/200247505</a></p>",
        "id": 201923521,
        "sender_full_name": "Aman Arora",
        "timestamp": 1593048420
    },
    {
        "content": "<p>Can we get some more details on the ProjectionsKinds here: <a href=\"https://github.com/rust-lang/project-rfc-2229/blob/master/hir-place-target.md\">https://github.com/rust-lang/project-rfc-2229/blob/master/hir-place-target.md</a></p>",
        "id": 201923614,
        "sender_full_name": "Aman Arora",
        "timestamp": 1593048519
    },
    {
        "content": "<p>Especially more ideas about what Field and VariantIdx is? <br>\nWe were thinking some around using <a href=\"https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TypeckTables.html#structfield.field_indices\">https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TypeckTables.html#structfield.field_indices</a> , not sure how  to really use it rn.</p>",
        "id": 201923645,
        "sender_full_name": "Aman Arora",
        "timestamp": 1593048589
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281950\">@Aman Arora</span> field and variant index refers to the way the compiler represents structs/enums, which are unified into one concept (a \"ADT\"). You can read about the ADT stuff in <a href=\"https://rustc-dev-guide.rust-lang.org/ty.html?highlight=adt#adts-representation\">this section of the rustc-dev-guide</a></p>",
        "id": 202028934,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1593121350
    },
    {
        "content": "<p>but for an enum the \"variants\" are the, well, variants of the enum: e.g., for option it would be <code>Some</code> and <code>None</code></p>",
        "id": 202028988,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1593121381
    },
    {
        "content": "<p>and the field index is the index within a variant. So if you have <code>Some(v)</code> the <code>v</code> is the field 0</p>",
        "id": 202029000,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1593121393
    },
    {
        "content": "<p>a struct is basically an enum with just one variant</p>",
        "id": 202029009,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1593121400
    },
    {
        "content": "<p>so the idea would be that <code>foo.f</code> is basically going to be the index of <code>f</code> combined with the index 0 for the variant (because <code>foo</code> must be a struct)</p>",
        "id": 202029067,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1593121430
    },
    {
        "content": "<p>but when you get refs to fields through pattern matching, you can get other things</p>",
        "id": 202029118,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1593121443
    },
    {
        "content": "<p>e.g., </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"nb\">String</span>::<span class=\"n\">new</span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"cm\">/* p here is a place that points into `*x` */</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 202029214,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1593121504
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> Still not sure where we would use ProjectionKind::Field wtih a variant other tham 0? </p>\n<p>Will it be something like here: <a href=\"https://gist.github.com/rust-play/aaa6a922cf0a6392b80aeedbba91f587\">https://gist.github.com/rust-play/aaa6a922cf0a6392b80aeedbba91f587</a>?</p>\n<p>And we handle this in TupleStruct? <a href=\"https://github.com/rust-lang/rust/blob/9491f18c5de3ff1c4bf9c3fdacf52d9859e26f7c/src/librustc_typeck/mem_categorization.rs#L657\">https://github.com/rust-lang/rust/blob/9491f18c5de3ff1c4bf9c3fdacf52d9859e26f7c/src/librustc_typeck/mem_categorization.rs#L657</a>? </p>\n<p>If so how do we get the variant index and field index in this case?</p>",
        "id": 202650762,
        "sender_full_name": "Aman Arora",
        "timestamp": 1593666363
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281950\">@Aman Arora</span> non-zero variants arise from pattern matching, yes. To be honest, I'm not sure if this will arise in closures. I think maybe it you use the older <code>ref</code> form of patterns, perhaps with an example like this...</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"nb\">String</span>::<span class=\"n\">new</span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"k\">ref</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n\n\n<p>the borrow that crates <code>q</code> would be from the <code>Same</code> variant. (<span class=\"user-mention\" data-user-id=\"116118\">@Matthew Jasper</span>, thoughts?)</p>\n<p>The newer form of that <code>if let</code> (<code>if let Some(q) = &amp;p</code>) would first borrow <code>p</code> as a whole, I think, and so we wouldn't consider to only borrow \"some part\" of <code>p</code>. That is sort of interesting actually. =)</p>",
        "id": 202674543,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1593688293
    },
    {
        "content": "<p>That sounds right. Closures have to borrow the whole enum either way, because we don't know which variant is active for the enum when we create the closure.<br>\nThere are some ways to borrow from inside an enum without writing <code>ref</code>: <code>if let Some(A { x }) = Some(&amp;A { x: 2 })</code> borrows <code>(*(tmp.(Some.0))).x</code>.</p>",
        "id": 202675296,
        "sender_full_name": "Matthew Jasper",
        "timestamp": 1593688875
    },
    {
        "content": "<p>Although I think when we match on something the expr use visitor currently records a borrow of all of it, because we don't have a way to represent the tag of an enum.</p>",
        "id": 202675400,
        "sender_full_name": "Matthew Jasper",
        "timestamp": 1593688966
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/blob/3659406c513062c265f8d8631fa8dae2702bbe8d/src/librustc_typeck/expr_use_visitor.rs#L203\">https://github.com/rust-lang/rust/blob/3659406c513062c265f8d8631fa8dae2702bbe8d/src/librustc_typeck/expr_use_visitor.rs#L203</a></p>",
        "id": 202675671,
        "sender_full_name": "Matthew Jasper",
        "timestamp": 1593689207
    },
    {
        "content": "<p>Yeah, so, we already can't always borrow the precise path (e.g., slices), and I think that borrowing always the entire enum is fine</p>",
        "id": 202692294,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1593698587
    },
    {
        "content": "<p>but either way we probably want <code>Place</code> to have variant index</p>",
        "id": 202692322,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1593698603
    },
    {
        "content": "<p>kind of separate questions</p>",
        "id": 202692326,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1593698605
    },
    {
        "content": "<p>To generate the place for the enum access- will we be doing that while handling PatKind::TupleStruct? </p>\n<p>And if so how do get the variant indeed and field information? Will it come from subpat_ty?</p>\n<p><a href=\"https://github.com/rust-lang/rust/blob/9491f18c5de3ff1c4bf9c3fdacf52d9859e26f7c/src/librustc_typeck/mem_categorization.rs#L657\">https://github.com/rust-lang/rust/blob/9491f18c5de3ff1c4bf9c3fdacf52d9859e26f7c/src/librustc_typeck/mem_categorization.rs#L657</a></p>",
        "id": 202694453,
        "sender_full_name": "Aman Arora",
        "timestamp": 1593699555
    },
    {
        "content": "<p>both <code>PatKind::TupleStruct</code> and <code>PatKind::Struct</code></p>",
        "id": 202694797,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1593699706
    },
    {
        "content": "<p>let me find the answer the other part of your question...</p>",
        "id": 202694827,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1593699721
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/blob/9491f18c5de3ff1c4bf9c3fdacf52d9859e26f7c/src/librustc_mir_build/hair/pattern/mod.rs#L622-L630\">this is the code that builds the HAIR</a></p>",
        "id": 202695049,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1593699819
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/blob/9491f18c5de3ff1c4bf9c3fdacf52d9859e26f7c/src/librustc_mir_build/hair/pattern/mod.rs#L617\">this code identifies the variant</a></p>",
        "id": 202695204,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1593699876
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/blob/9491f18c5de3ff1c4bf9c3fdacf52d9859e26f7c/src/librustc_mir_build/hair/pattern/mod.rs#L720\">this code computes the variant index</a></p>",
        "id": 202695287,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1593699921
    },
    {
        "content": "<p>so yeah some combination of those calls :)</p>",
        "id": 202695292,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1593699924
    },
    {
        "content": "<p>Thank you</p>",
        "id": 202696570,
        "sender_full_name": "Aman Arora",
        "timestamp": 1593700482
    },
    {
        "content": "<p>When using <code>span_bug!</code> how to we handle error codes? </p>\n<p>We are trying to use it here: <a href=\"https://github.com/sexxi-goose/rust/blob/expand_projection_kinds/src/librustc_typeck/mem_categorization.rs#L653\">https://github.com/sexxi-goose/rust/blob/expand_projection_kinds/src/librustc_typeck/mem_categorization.rs#L653</a></p>\n<p>In case of <br>\n<a href=\"https://github.com/rust-lang/rust/blob/9491f18c5de3ff1c4bf9c3fdacf52d9859e26f7c/src/test/ui/issues/issue-38412.rs\">https://github.com/rust-lang/rust/blob/9491f18c5de3ff1c4bf9c3fdacf52d9859e26f7c/src/test/ui/issues/issue-38412.rs</a><br>\n<a href=\"https://github.com/rust-lang/rust/blob/9491f18c5de3ff1c4bf9c3fdacf52d9859e26f7c/src/test/ui/issues/issue-38412.stderr\">https://github.com/rust-lang/rust/blob/9491f18c5de3ff1c4bf9c3fdacf52d9859e26f7c/src/test/ui/issues/issue-38412.stderr</a></p>\n<p>Our error text looks similar but is formatted weirdly </p>\n<div class=\"codehilite\"><pre><span></span><code>{&quot;message&quot;:&quot;expected tuple struct or tuple variant, found struct `Box`&quot;,&quot;code&quot;:{&quot;code&quot;:&quot;E0532&quot;,&quot;explanation&quot;:&quot;Pattern arm did not match expected kind.\\n\\nErroneous code example:\\n\\n```compile_fail,E0532\\nenum State {\\n    Succeeded,\\n    Failed(String),\\n}\\n\\nfn print_on_failure(state: &amp;State) {\\n    match *state {\\n        // error: expected unit struct, unit variant or constant, found tuple\\n        //        variant `State::Failed`\\n        State::Failed =&gt; println!(\\&quot;Failed\\&quot;),\\n        _ =&gt; ()\\n    }\\n}\\n```\\n\\nTo fix this error, ensure the match arm kind is the same as the expression\\nmatched.\\n\\nFixed example:\\n\\n```\\nenum State {\\n    Succeeded,\\n    Failed(String),\\n}\\n\\nfn print_on_failure(state: &amp;State) {\\n    match *state {\\n        State::Failed(ref msg) =&gt; println!(\\&quot;Failed with {}\\&quot;, msg),\\n        _ =&gt; ()\\n    }\\n}\\n```\\n&quot;},&quot;level&quot;:&quot;error&quot;,&quot;spans&quot;:[{&quot;file_name&quot;:&quot;/users/a52arora/rust/src/test/ui/issues/issue-38412.rs&quot;,&quot;byte_start&quot;:20,&quot;byte_end&quot;:23,&quot;line_start&quot;:2,&quot;line_end&quot;:2,&quot;column_start&quot;:9,&quot;column_end&quot;:12,&quot;is_primary&quot;:true,&quot;text&quot;:[{&quot;text&quot;:&quot;    let Box(a) = loop { };&quot;,&quot;highlight_start&quot;:9,&quot;highlight_end&quot;:12}],&quot;label&quot;:&quot;constructor is not visible here due to private fields&quot;,&quot;suggested_replacement&quot;:null,&quot;suggestion_applicability&quot;:null,&quot;expansion&quot;:null}],&quot;children&quot;:[],&quot;rendered&quot;:&quot;error[E0532]: expected tuple struct or tuple variant, found struct `Box`\\n  --&gt; /users/a52arora/rust/src/test/ui/issues/issue-38412.rs:2:9\\n   |\\nLL |     let Box(a) = loop { };\\n   |         ^^^ constructor is not visible here due to private fields\\n\\n&quot;}\n{&quot;message&quot;:&quot;src/librustc_typeck/mem_categorization.rs:733:26: tuple struct pattern not applied to an ADT [type error]&quot;,&quot;code&quot;:null,&quot;level&quot;:&quot;error: internal compiler error&quot;,&quot;spans&quot;:[{&quot;file_name&quot;:&quot;/users/a52arora/rust/src/test/ui/issues/issue-38412.rs&quot;,&quot;byte_start&quot;:20,&quot;byte_end&quot;:26,&quot;line_start&quot;:2,&quot;line_end&quot;:2,&quot;column_start&quot;:9,&quot;column_end&quot;:15,&quot;is_primary&quot;:true,&quot;text&quot;:[{&quot;text&quot;:&quot;    let Box(a) = loop { };&quot;,&quot;highlight_start&quot;:9,&quot;highlight_end&quot;:15}],&quot;label&quot;:null,&quot;suggested_replacement&quot;:null,&quot;suggestion_applicability&quot;:null,&quot;expansion&quot;:null}],&quot;children&quot;:[],&quot;rendered&quot;:&quot;error: internal compiler error: src/librustc_typeck/mem_categorization.rs:733:26: tuple struct pattern not applied to an ADT [type error]\\n  --&gt; /users/a52arora/rust/src/test/ui/issues/issue-38412.rs:2:9\\n   |\\nLL |     let Box(a) = loop { };\\n   |         ^^^^^^\\n\\n&quot;}\n\n.... More stuff ....\n</code></pre></div>",
        "id": 202860994,
        "sender_full_name": "Aman Arora",
        "timestamp": 1593846689
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281950\">@Aman Arora</span> <code>span_bug</code> is to be used only in the event of an internal compiler bug. It doesn't have any error codes?</p>",
        "id": 203053110,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1594078231
    },
    {
        "content": "<p>in other words, if you're <em>testing</em> the output, it's not really an appropriate use of <code>span_bug</code></p>",
        "id": 203053142,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1594078278
    },
    {
        "content": "<p>(i.e., we expect never to see that output)</p>",
        "id": 203053148,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1594078289
    },
    {
        "content": "<p>this <em>may</em> be an appropriate case for <code>delay_span_bug</code></p>",
        "id": 203053163,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1594078304
    },
    {
        "content": "<p>Give me one min</p>",
        "id": 203053220,
        "sender_full_name": "Aman Arora",
        "timestamp": 1594078331
    },
    {
        "content": "<p>unfortunately I don't see any coverage of this in rustc-dev-guide</p>",
        "id": 203053221,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1594078331
    },
    {
        "content": "<p>Copied this line here: <a href=\"https://github.com/rust-lang/rust/blob/9491f18c5de3ff1c4bf9c3fdacf52d9859e26f7c/src/librustc_mir_build/hair/pattern/mod.rs#L615\">https://github.com/rust-lang/rust/blob/9491f18c5de3ff1c4bf9c3fdacf52d9859e26f7c/src/librustc_mir_build/hair/pattern/mod.rs#L615</a></p>",
        "id": 203053242,
        "sender_full_name": "Aman Arora",
        "timestamp": 1594078351
    },
    {
        "content": "<p>the difference may be that</p>",
        "id": 203053266,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1594078381
    },
    {
        "content": "<p>the HAIR construction code doesn't execute if they are type-checker errors</p>",
        "id": 203053272,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1594078394
    },
    {
        "content": "<p>but the upvar inference <em>does</em></p>",
        "id": 203053274,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1594078398
    },
    {
        "content": "<p>so that means that HAIR can assume that no errors were reported</p>",
        "id": 203053281,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1594078410
    },
    {
        "content": "<p>this is why I mentioned <code>delay_span_bug</code> --</p>",
        "id": 203053286,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1594078416
    },
    {
        "content": "<p>that basically is a method that says \"it's a bug if you get to this code and no error was reported\"</p>",
        "id": 203053290,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1594078426
    },
    {
        "content": "<p>however, in that case, you still have to figure out what to <em>Do</em></p>",
        "id": 203053298,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1594078438
    },
    {
        "content": "<p>i.e., where <code>span_bug</code> panics, <code>delay_span_bug</code> does not</p>",
        "id": 203053340,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1594078451
    },
    {
        "content": "<p>in this case, generating some dummy place (perhaps an \"error\" place) would be appropriate</p>",
        "id": 203053346,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1594078465
    },
    {
        "content": "<p>For the current test, we aren't doing any upvar analysis</p>",
        "id": 203053350,
        "sender_full_name": "Aman Arora",
        "timestamp": 1594078475
    },
    {
        "content": "<p>see also <a href=\"https://rustc-dev-guide.rust-lang.org/ty.html?highlight=delay_span_bug#type-errors\">this section of rustc-dev-guide</a></p>",
        "id": 203053362,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1594078492
    },
    {
        "content": "<p>which does cover this general idea, albeit in a distinct context</p>",
        "id": 203053370,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1594078501
    },
    {
        "content": "<p>well, regardless, the point is that you are reaching this point</p>",
        "id": 203053381,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1594078507
    },
    {
        "content": "<p>Give me a bit to read</p>",
        "id": 203053498,
        "sender_full_name": "Aman Arora",
        "timestamp": 1594078631
    },
    {
        "content": "<p>Okay delay_span_bug makes sense to me</p>",
        "id": 203053532,
        "sender_full_name": "Aman Arora",
        "timestamp": 1594078673
    },
    {
        "content": "<p>If I understand correctly -- it makes sense to do this in our case because this bug to be previously reported and that is since information around it was previously generated in typeck where the error would've been noticed</p>",
        "id": 203053611,
        "sender_full_name": "Aman Arora",
        "timestamp": 1594078730
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> <br>\nDo we need Downcast and const index for our needs? <a href=\"https://github.com/rust-lang/project-rfc-2229/issues/1\">https://github.com/rust-lang/project-rfc-2229/issues/1</a></p>\n<p>or what is described <a href=\"https://github.com/rust-lang/project-rfc-2229/blob/master/hir-place-target.md\">https://github.com/rust-lang/project-rfc-2229/blob/master/hir-place-target.md</a> enough?</p>\n<p>IIRC for arrays  we don't care about which index we mark the whole array as captured, and down casts shoulnd't affect catpures</p>",
        "id": 203082532,
        "sender_full_name": "Aman Arora",
        "timestamp": 1594113928
    },
    {
        "content": "<p>And tuples get handled as fields</p>",
        "id": 203082610,
        "sender_full_name": "Aman Arora",
        "timestamp": 1594113990
    },
    {
        "content": "<p>Where <code>ConstIndex</code> is used in a MIR Place, we can use <code>Index</code>, since we  don't care about the index. <code>Downcast</code> is merged into field in the HIR place described.</p>",
        "id": 203083043,
        "sender_full_name": "Matthew Jasper",
        "timestamp": 1594114365
    },
    {
        "content": "<p>what do you mean by Downcast is merged into field?</p>",
        "id": 203084964,
        "sender_full_name": "Aman Arora",
        "timestamp": 1594115950
    },
    {
        "content": "<p>in MIR, we use \"downcasting\" to select the enum variant. So if you access (e.g.) the 0th field of the <code>Some</code> variant, you get a place like <code>foo.downcast&lt;Some&gt;.0</code> -- obviously this is not valid Rust syntax. </p>\n<p><span class=\"user-mention silent\" data-user-id=\"116118\">Matthew Jasper</span> was proposing for HIR Places that we can just make that <code>foo.(Some:0)</code>, i.e., bake the variant (<code>Some</code>) into the projection itself.</p>\n<p>I think that's fine, though I also think that if we like that more we should consider revising the MIR places to match.</p>",
        "id": 203086712,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1594117600
    },
    {
        "content": "<p>Similarly, <code>ConstIndex</code> is used for some special cases where we know the index is a fixed constant -- mostly pattern matching like <code>let [a, b, _] = some_array</code>.  The compiler is (sometimes) smart enough to see that these moves are distinct from (say) <code>let [_, _, c] = some_array</code>, but to be that smart, it needs to know the indices as constants. We I think are just going to capture the entire array for now, so we don't care for now.</p>",
        "id": 203086802,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1594117715
    },
    {
        "content": "<p><a href=\"https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir/enum.PatKind.html#variant.Tuple\">https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir/enum.PatKind.html#variant.Tuple</a><br>\nWhen it says <code>dots_pos &lt;= subpats.len()</code>,  is it trying to refer to the total number of fields for the Tuple? </p>\n<p>Even in the case where <code>if let (a, b, ..) = (1, 2)</code> , the subpats count = 3. dots_pos = 2</p>",
        "id": 203330110,
        "sender_full_name": "Aman Arora",
        "timestamp": 1594246273
    },
    {
        "content": "<p>Nvm looked up ast_lowering subpats acutally don't contain the dots</p>",
        "id": 203360541,
        "sender_full_name": "Aman Arora",
        "timestamp": 1594282475
    },
    {
        "content": "<p>So the original spec for ProjectionKind::Field expresses the field index as a <code>u32</code> instead of <code>usize</code>. I'm wondering if there is a specific reason behind it? I see that everywhere it's used in code we have to cast around it because fields are expressed using <code>usize</code> everywhere.</p>",
        "id": 221105874,
        "sender_full_name": "Aman Arora",
        "timestamp": 1609207175
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281950\">@Aman Arora</span> no real reason, just to save memory</p>",
        "id": 221224780,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1609345780
    }
]