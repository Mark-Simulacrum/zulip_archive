[
    {
        "content": "<p>So if I enable this feature by default then iterator fails to build. </p>\n<p>Log: <a href=\"http://csclub.uwaterloo.ca/~a52arora/rust-builds/log_773e5336-8959-4d16-816a-038b63a0a88c\">http://csclub.uwaterloo.ca/~a52arora/rust-builds/log_773e5336-8959-4d16-816a-038b63a0a88c</a></p>",
        "id": 218066523,
        "sender_full_name": "Aman Arora",
        "timestamp": 1606465720
    },
    {
        "content": "<p>I'm wondering if there is something that kind of obvious to you that we might have messed up</p>",
        "id": 218066732,
        "sender_full_name": "Aman Arora",
        "timestamp": 1606465917
    },
    {
        "content": "<p>Our code is here: <a href=\"https://github.com/sexxi-goose/rust/pull/33\">https://github.com/sexxi-goose/rust/pull/33</a></p>",
        "id": 218066799,
        "sender_full_name": "Aman Arora",
        "timestamp": 1606465947
    },
    {
        "content": "<p>The theme is fairly common, move closure and captuing a variable of type <code>&amp;mut T</code></p>",
        "id": 218066975,
        "sender_full_name": "Aman Arora",
        "timestamp": 1606466095
    },
    {
        "content": "<p>My attempts to recreate a minimum  source code didn't work</p>",
        "id": 218067002,
        "sender_full_name": "Aman Arora",
        "timestamp": 1606466119
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span></p>",
        "id": 218114849,
        "sender_full_name": "Aman Arora",
        "timestamp": 1606498364
    },
    {
        "content": "<p>So I was being dumb and didn't have the feature gate <span aria-label=\"face palm\" class=\"emoji emoji-1f926\" role=\"img\" title=\"face palm\">:face_palm:</span>‍♂️ <br>\nThis fails:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#![feature(capture_disjoint_fields)]</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">t</span><span class=\"p\">(</span><span class=\"n\">ref_s</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">*</span><span class=\"n\">ref_s</span><span class=\"w\"> </span><span class=\"o\">+=</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">};</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"n\">c</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ref_s</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"n\">t</span><span class=\"p\">(</span><span class=\"n\">ref_s</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 218116425,
        "sender_full_name": "Aman Arora",
        "timestamp": 1606499655
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>error[E0594]: cannot assign to `ref_s`, as it is not declared as mutable\n  --&gt; move_closure.rs:10:9\n   |\n7  | fn t&lt;&#39;a&gt;(ref_s: &amp;&#39;a mut i32) {\n   |          ----- help: consider changing this to be mutable: `mut ref_s`\n...\n10 |         *ref_s += 10; //some_num(ref_s);\n   |         ^^^^^^^^^^^^ cannot assign\n</code></pre></div>",
        "id": 218116438,
        "sender_full_name": "Aman Arora",
        "timestamp": 1606499662
    },
    {
        "content": "<p>So this can be traced when we log here: <a href=\"https://github.com/sexxi-goose/rust/blob/mir_min_cap_writeback/compiler/rustc_typeck/src/check/upvar.rs#L240-L243\">https://github.com/sexxi-goose/rust/blob/mir_min_cap_writeback/compiler/rustc_typeck/src/check/upvar.rs#L240-L243</a></p>\n<p>Okay so the problem is when the feature is enabled what gets captured is <code>Place(hir_id_ref_s, base_ty: &amp;mut i32, projections: [(Deref, i32)]</code>, i.e. the type of the capture is <code>i32</code>.</p>\n<p>When we don't have the <code>move</code> there then we get a <code>UniqueImmBorrow</code> (instead of a <code>ByValue</code>) which then converts it into <code>mut i32</code> when recording the type. </p>\n<p>When the feature isn't enabled then the root variable is captured we get a <code>&amp;mut i32</code> as it should be</p>",
        "id": 218152696,
        "sender_full_name": "Aman Arora",
        "timestamp": 1606548483
    },
    {
        "content": "<hr>\n<p>Maybe we just drop all Deref that are not followed by any Field Projections. Because we can't really ger more disjoint after that</p>",
        "id": 218155025,
        "sender_full_name": "Aman Arora",
        "timestamp": 1606553233
    },
    {
        "content": "<p>And since we are keeping an ancestor it technically reduces the amt of work we do later to find a matching capture</p>",
        "id": 218155075,
        "sender_full_name": "Aman Arora",
        "timestamp": 1606553306
    },
    {
        "content": "<p>So this doesn't quite solve the problem</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#![feature(capture_disjoint_fields)]</span><span class=\"w\"></span>\n<span class=\"cp\">#![feature(rustc_attrs)]</span><span class=\"w\"></span>\n\n<span class=\"k\">struct</span> <span class=\"nc\">Point</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">x</span>: <span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">y</span>: <span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Point</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"mi\">10</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span>: <span class=\"mi\">10</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"c1\">// #[rustc_capture_analysis]</span>\n<span class=\"w\">    </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">mp</span><span class=\"p\">.</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">};</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"n\">c</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Essentially when <code>mp.x</code> is captured we need it to be marked mutable because <code>mp</code> starts off a mutable reference.</p>",
        "id": 218187044,
        "sender_full_name": "Aman Arora",
        "timestamp": 1606607810
    },
    {
        "content": "<p>I guess this is a more interesting example because the mutability can be introduced  from any part in the path and not just the base</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#![feature(capture_disjoint_fields)]</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">t1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">t1</span><span class=\"p\">.</span><span class=\"mf\">0.0</span><span class=\"w\"> </span><span class=\"o\">+=</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">};</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"n\">c</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 218188362,
        "sender_full_name": "Aman Arora",
        "timestamp": 1606610250
    },
    {
        "content": "<p>I'm a bit confused what the problem is here, <span class=\"user-mention\" data-user-id=\"281950\">@Aman Arora</span></p>",
        "id": 218353052,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606774071
    },
    {
        "content": "<p>oh hmm</p>",
        "id": 218353071,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606774080
    },
    {
        "content": "<p>well no I'm still a bit confused :)</p>",
        "id": 218353120,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606774089
    },
    {
        "content": "<p>we certainly expect that <code>t</code> would be modified in place by the above example, right?</p>",
        "id": 218353141,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606774106
    },
    {
        "content": "<p>yes</p>",
        "id": 218353161,
        "sender_full_name": "Aman Arora",
        "timestamp": 1606774115
    },
    {
        "content": "<p>So the way I had currently (incorrectly) implemented  mutability for precise captures is if the root variable being captured is mutable</p>",
        "id": 218353188,
        "sender_full_name": "Aman Arora",
        "timestamp": 1606774128
    },
    {
        "content": "<p>and the reason it ends up working out today is that, at some point when we look at the path within the closure we see the &amp;mut type.  That is <code>t1</code>  is immut</p>\n<p>However since we capture <code>t1.0.0</code> which has type <code>i32</code> and not <code>mut i32</code>, we loose the information about it being mutable</p>",
        "id": 218353403,
        "sender_full_name": "Aman Arora",
        "timestamp": 1606774218
    },
    {
        "content": "<p>I see</p>",
        "id": 218353441,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606774235
    },
    {
        "content": "<p>well I sort of see</p>",
        "id": 218353481,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606774260
    },
    {
        "content": "<p>is this a bug you fixed already or not yet :)</p>",
        "id": 218353499,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606774269
    },
    {
        "content": "<p>Not yet, still trying to figure it out a bit</p>",
        "id": 218353527,
        "sender_full_name": "Aman Arora",
        "timestamp": 1606774281
    },
    {
        "content": "<p>Might need to store more information in mir::Body or something</p>",
        "id": 218353653,
        "sender_full_name": "Aman Arora",
        "timestamp": 1606774310
    },
    {
        "content": "<p>I'm assuming this bits needs to get more information. <a href=\"https://github.com/rust-lang/rust/blob/master/compiler/rustc_mir/src/borrow_check/mod.rs#L157-L181\">https://github.com/rust-lang/rust/blob/master/compiler/rustc_mir/src/borrow_check/mod.rs#L157-L181</a></p>",
        "id": 218353826,
        "sender_full_name": "Aman Arora",
        "timestamp": 1606774374
    },
    {
        "content": "<p>Because the way we do it for local variables is stored that info in Mir::Body::local_decls and we can see a use of that here: <a href=\"https://github.com/rust-lang/rust/blob/master/compiler/rustc_mir/src/borrow_check/mod.rs#L1211-L1215\">https://github.com/rust-lang/rust/blob/master/compiler/rustc_mir/src/borrow_check/mod.rs#L1211-L1215</a></p>",
        "id": 218353994,
        "sender_full_name": "Aman Arora",
        "timestamp": 1606774457
    },
    {
        "content": "<p>uh</p>",
        "id": 218354467,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606774715
    },
    {
        "content": "<p>I wouldn't <em>expect</em> changes in <em>borrow check</em> really</p>",
        "id": 218354497,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606774731
    },
    {
        "content": "<p>I guess my expectation is that the upvar would ultimately be an <code>&amp;mut</code></p>",
        "id": 218354536,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606774754
    },
    {
        "content": "<p>I asked around on t-compiler/help over the weekend and was pointed to <a href=\"https://github.com/rust-lang/rust/blob/c4fe25d8613a32dcd71e5258c22ff5685f12d4c3/compiler/rustc_mir/src/borrow_check/mod.rs#L2156-L2306\">https://github.com/rust-lang/rust/blob/c4fe25d8613a32dcd71e5258c22ff5685f12d4c3/compiler/rustc_mir/src/borrow_check/mod.rs#L2156-L2306</a></p>\n<p>But I think by the time we get here, we have lost some valuable information</p>",
        "id": 218354550,
        "sender_full_name": "Aman Arora",
        "timestamp": 1606774762
    },
    {
        "content": "<p>so e.g. if you have <code>|| *x += 1</code></p>",
        "id": 218354598,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606774787
    },
    {
        "content": "<p>then I would expect us to capture <code>*x</code> by mutable ref</p>",
        "id": 218354623,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606774796
    },
    {
        "content": "<p>so if e.g. <code>mut x: Box&lt;i32&gt;</code>, then we would have an upvar of type <code>&amp;mut i32</code></p>",
        "id": 218354686,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606774814
    },
    {
        "content": "<p>It does but if we have a move closure then it won't work</p>",
        "id": 218354687,
        "sender_full_name": "Aman Arora",
        "timestamp": 1606774814
    },
    {
        "content": "<p>becuase we capture <code>ByValue, [x, projection: (Deref, i32)]</code></p>",
        "id": 218354720,
        "sender_full_name": "Aman Arora",
        "timestamp": 1606774840
    },
    {
        "content": "<p>is it a <code>FnOnce</code> or <code>FnMut</code> closure...</p>",
        "id": 218354776,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606774871
    },
    {
        "content": "<p>if <code>FnMut</code>, then I expect that we would reach the upvar via <code>(*self).upvar</code></p>",
        "id": 218354826,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606774894
    },
    {
        "content": "<p>where <code>self: &amp;mut ClosureType</code>, so the mutability comes from there</p>",
        "id": 218354843,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606774903
    },
    {
        "content": "<p>Yes</p>",
        "id": 218354857,
        "sender_full_name": "Aman Arora",
        "timestamp": 1606774910
    },
    {
        "content": "<p>if <code>FnOnce</code> then I guess we need a <code>mut self</code>, but I would expect the same problem today</p>",
        "id": 218354869,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606774916
    },
    {
        "content": "<p>so presumably we handle it somehow</p>",
        "id": 218354891,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606774923
    },
    {
        "content": "<p>e.g. by having <code>mut self</code></p>",
        "id": 218354923,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606774928
    },
    {
        "content": "<p>e.g., <code>move || x += 1</code> where <code>x: i32</code></p>",
        "id": 218354937,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606774937
    },
    {
        "content": "<p>I think that will work but I think the problem might be when we deal with references. I don't know when we decide if we need a <code>mut self</code> vs a <code>self</code> for closure, but we start to loose information about mutability in capture analysis. </p>\n<p>So for the example below:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#![feature(capture_disjoint_fields)]</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">t1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">t1</span><span class=\"p\">.</span><span class=\"mf\">0.0</span><span class=\"w\"> </span><span class=\"o\">+=</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">};</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"n\">c</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>The place that is captured for <code>t1.0.0</code> would be <code>base: t1, projections: [{ Field(0), &amp;mut (i32, i32) {Deref, (i32, i32)}, {Field(0), i32}]</code></p>",
        "id": 218355435,
        "sender_full_name": "Aman Arora",
        "timestamp": 1606775194
    },
    {
        "content": "<p>I would expect to just always use <code>mut self</code></p>",
        "id": 218355707,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606775348
    },
    {
        "content": "<p>Also if I look <a href=\"https://github.com/rust-lang/rust/blob/c4fe25d8613a32dcd71e5258c22ff5685f12d4c3/compiler/rustc_mir/src/borrow_check/mod.rs#L157-L178\">here</a> I don't see this looking for &amp;mut when setting mutability here</p>",
        "id": 218355745,
        "sender_full_name": "Aman Arora",
        "timestamp": 1606775373
    },
    {
        "content": "<p>here, are you assuming a <code>move</code> closure or not?</p>",
        "id": 218355754,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606775378
    },
    {
        "content": "<p>that said, in that example above, I still don't <em>quite</em> get the problem, wouldn't we be storing an <code>&amp;mut i32</code>?</p>",
        "id": 218355871,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606775430
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281950\">Aman Arora</span> <a href=\"#narrow/stream/189812-t-compiler.2Fwg-rfc-2229/topic/mutability.20of.20captured.20path/near/218355745\">said</a>:</p>\n<blockquote>\n<p>Also if I look <a href=\"https://github.com/rust-lang/rust/blob/c4fe25d8613a32dcd71e5258c22ff5685f12d4c3/compiler/rustc_mir/src/borrow_check/mod.rs#L157-L178\">here</a> I don't see this looking for &amp;mut when setting mutability here</p>\n</blockquote>\n<p>oh hmm</p>",
        "id": 218355961,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606775492
    },
    {
        "content": "<p>The type is <code>i32</code> as far as I remember, lemme double check</p>",
        "id": 218355962,
        "sender_full_name": "Aman Arora",
        "timestamp": 1606775493
    },
    {
        "content": "<p>I'm remembering something now :)</p>",
        "id": 218355965,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606775496
    },
    {
        "content": "<p>Also, this might be incorrectly done: <a href=\"https://github.com/rust-lang/rust/blob/977aa99592c7f8449f591e05d552c0f93afc1652/compiler/rustc_mir_build/src/build/expr/as_rvalue.rs#L387-L428\">https://github.com/rust-lang/rust/blob/977aa99592c7f8449f591e05d552c0f93afc1652/compiler/rustc_mir_build/src/build/expr/as_rvalue.rs#L387-L428</a></p>",
        "id": 218355988,
        "sender_full_name": "Aman Arora",
        "timestamp": 1606775509
    },
    {
        "content": "<p>I had forgotten that we kind of special-cased closure upvars in the mutability check</p>",
        "id": 218355991,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606775510
    },
    {
        "content": "<p>that's annoying</p>",
        "id": 218356066,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606775534
    },
    {
        "content": "<p>but ok I think I see your point better</p>",
        "id": 218356077,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606775540
    },
    {
        "content": "<p><em>right</em> so today we decide that an upvar is mutable based on whether the variable is mutable</p>",
        "id": 218356117,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606775579
    },
    {
        "content": "<p>sigh.</p>",
        "id": 218356165,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606775603
    },
    {
        "content": "<p>some part of me wonders if that logic belong in borrow check</p>",
        "id": 218356190,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606775618
    },
    {
        "content": "<p>but let's not worry about that for now :P</p>",
        "id": 218356198,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606775623
    },
    {
        "content": "<p>ok, I guess you have to store some extra information indeed</p>",
        "id": 218356215,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606775637
    },
    {
        "content": "<p>or at least...</p>",
        "id": 218356305,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606775676
    },
    {
        "content": "<p>is <code>closure_captures</code> the new or old style table?</p>",
        "id": 218356324,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606775689
    },
    {
        "content": "<p>that is old style</p>",
        "id": 218356335,
        "sender_full_name": "Aman Arora",
        "timestamp": 1606775698
    },
    {
        "content": "<p>Ported code with new info is here: <a href=\"https://github.com/rust-lang/rust/pull/79553/commits/08fb1ec5c248abc77e733387b1181a5bfb1a2acf\">https://github.com/rust-lang/rust/pull/79553/commits/08fb1ec5c248abc77e733387b1181a5bfb1a2acf</a></p>",
        "id": 218356377,
        "sender_full_name": "Aman Arora",
        "timestamp": 1606775727
    },
    {
        "content": "<p>OK</p>",
        "id": 218356400,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606775743
    },
    {
        "content": "<p>that's what I figured</p>",
        "id": 218356408,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606775748
    },
    {
        "content": "<p>so I guess the logic might be something like: if it is captured by mut ref, it needs to be mut; if it is captured by <em>value</em>, then maybe we want to track \"mutable value\"</p>",
        "id": 218356576,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606775819
    },
    {
        "content": "<p>That could work</p>",
        "id": 218356695,
        "sender_full_name": "Aman Arora",
        "timestamp": 1606775893
    },
    {
        "content": "<p>How do we assure that what we are assuming is correct, i,e, if we are borrowing with mut borrow it is mutable. I'm assuming that's just typeck</p>",
        "id": 218356805,
        "sender_full_name": "Aman Arora",
        "timestamp": 1606775986
    },
    {
        "content": "<p>The reason I ask is because, borrow check also has the mutability errors.</p>",
        "id": 218356910,
        "sender_full_name": "Aman Arora",
        "timestamp": 1606776048
    },
    {
        "content": "<p>well</p>",
        "id": 218356918,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606776053
    },
    {
        "content": "<p>if we do a mut borrow</p>",
        "id": 218356922,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606776057
    },
    {
        "content": "<p>and the path is not mutable</p>",
        "id": 218356927,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606776061
    },
    {
        "content": "<p>then the closure creator will get an error</p>",
        "id": 218356936,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606776065
    },
    {
        "content": "<p>but it may be a bad user experience, it's true</p>",
        "id": 218356949,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606776075
    },
    {
        "content": "<p>we could also have typeck compute whether upvar path is mutable</p>",
        "id": 218356967,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606776091
    },
    {
        "content": "<p>and store that separately</p>",
        "id": 218356974,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606776096
    },
    {
        "content": "<p>it's not super complicated</p>",
        "id": 218356979,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606776102
    },
    {
        "content": "<p>that could work</p>",
        "id": 218356987,
        "sender_full_name": "Aman Arora",
        "timestamp": 1606776109
    },
    {
        "content": "<p>I'm assuming check if the place_base or any of the projections has a TypeMut or something along those lines?</p>",
        "id": 218357057,
        "sender_full_name": "Aman Arora",
        "timestamp": 1606776134
    },
    {
        "content": "<p>yeah you'd have walk down the projections</p>",
        "id": 218357076,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606776150
    },
    {
        "content": "<p>if the base is mutable, it starts as mutable</p>",
        "id": 218357084,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606776156
    },
    {
        "content": "<p>if you deref an <code>&amp;mut</code>, it becomes mutable</p>",
        "id": 218357089,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606776159
    },
    {
        "content": "<p>if you deref an <code>&amp;</code>, it is not</p>",
        "id": 218357094,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606776163
    },
    {
        "content": "<p>something like that</p>",
        "id": 218357100,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606776164
    },
    {
        "content": "<p>I sort of like the idea of storing it separately</p>",
        "id": 218357120,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606776179
    },
    {
        "content": "<p>then if there's a mismatch I guess it results in a type error</p>",
        "id": 218357138,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606776187
    },
    {
        "content": "<p>feels a bit less \"trusting\"</p>",
        "id": 218357150,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606776193
    },
    {
        "content": "<p>Might have some edge cases</p>\n<div class=\"codehilite\"><pre><span></span><code>let x = 10;\nlet mut refx = &amp;x;\n\nlet || {\n    *refx += 10;\n}\n</code></pre></div>",
        "id": 218357180,
        "sender_full_name": "Aman Arora",
        "timestamp": 1606776219
    },
    {
        "content": "<p><code>refx</code> is mut but the place being captured isn't</p>",
        "id": 218357197,
        "sender_full_name": "Aman Arora",
        "timestamp": 1606776235
    },
    {
        "content": "<p>yeah that would be covered by what I wrote</p>",
        "id": 218357221,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606776244
    },
    {
        "content": "<p>because it's a deref of the <code>&amp;T</code></p>",
        "id": 218357248,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606776254
    },
    {
        "content": "<p>I guess <code>if the base is mutable, it starts as mutable</code> was a bit conflicting</p>",
        "id": 218357271,
        "sender_full_name": "Aman Arora",
        "timestamp": 1606776275
    },
    {
        "content": "<p>but yea</p>",
        "id": 218357280,
        "sender_full_name": "Aman Arora",
        "timestamp": 1606776281
    },
    {
        "content": "<p>Also maybe dropping any trailing derefs is also just a decent thing to do, makes mir build also a little faster because smaller projection list</p>",
        "id": 218357319,
        "sender_full_name": "Aman Arora",
        "timestamp": 1606776313
    },
    {
        "content": "<p>and doesn't affect any precise capture</p>",
        "id": 218357329,
        "sender_full_name": "Aman Arora",
        "timestamp": 1606776324
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281950\">Aman Arora</span> <a href=\"#narrow/stream/189812-t-compiler.2Fwg-rfc-2229/topic/mutability.20of.20captured.20path/near/218357271\">said</a>:</p>\n<blockquote>\n<p>I guess <code>if the base is mutable, it starts as mutable</code> was a bit conflicting</p>\n</blockquote>\n<p>I meant that the mutability changes as you walk down the projections and you get the mutability from the final point</p>",
        "id": 218357411,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606776367
    },
    {
        "content": "<p>Oh I see</p>",
        "id": 218357425,
        "sender_full_name": "Aman Arora",
        "timestamp": 1606776379
    },
    {
        "content": "<p>or you could do it by walking <em>up</em> the projections and stopping when you reach a deref of an <code>&amp;T</code> (or take mutability of base if you never do)</p>",
        "id": 218357430,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606776383
    },
    {
        "content": "<p>something like that</p>",
        "id": 218357433,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606776385
    },
    {
        "content": "<p>anyway it seems like we will need something like this</p>",
        "id": 218357461,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1606776411
    },
    {
        "content": "<p>yeah</p>",
        "id": 218357468,
        "sender_full_name": "Aman Arora",
        "timestamp": 1606776416
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span>  any idea what might be triggerring this?</p>\n<p><a href=\"/user_uploads/4715/8Bsz3WN0vf-Ao1tpDFPlIMUA/image.png\">image.png</a> </p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/4715/8Bsz3WN0vf-Ao1tpDFPlIMUA/image.png\" title=\"image.png\"><img src=\"/user_uploads/4715/8Bsz3WN0vf-Ao1tpDFPlIMUA/image.png\"></a></div><p>Happens when I use the feature by default to compile stdlib</p>",
        "id": 218629037,
        "sender_full_name": "Aman Arora",
        "timestamp": 1606947960
    },
    {
        "content": "<p>more of the code<br>\n<a href=\"/user_uploads/4715/QG44fdYZr5QPNRrYdf-Eqzcl/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/4715/QG44fdYZr5QPNRrYdf-Eqzcl/image.png\" title=\"image.png\"><img src=\"/user_uploads/4715/QG44fdYZr5QPNRrYdf-Eqzcl/image.png\"></a></div>",
        "id": 218642846,
        "sender_full_name": "Aman Arora",
        "timestamp": 1606957998
    },
    {
        "content": "<p>yeah I have some idea :)</p>",
        "id": 218706184,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1607008363
    },
    {
        "content": "<p>heh, this is interesting!</p>",
        "id": 218706192,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1607008367
    },
    {
        "content": "<p>I think we cannot capture through derefs of raw pointers</p>",
        "id": 218706215,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1607008375
    },
    {
        "content": "<p>so we must be capturing <code>*leaf_ptr</code></p>",
        "id": 218706233,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1607008381
    },
    {
        "content": "<p>which is unsafe to capture</p>",
        "id": 218706244,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1607008385
    },
    {
        "content": "<p>i.e., <code>leaf_ptr: *mut T</code> or something</p>",
        "id": 218706261,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1607008390
    },
    {
        "content": "<p>so that requires an unsafe block</p>",
        "id": 218706274,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1607008396
    },
    {
        "content": "<p>it is indeed invalid for us to move when that deref occurs</p>",
        "id": 218706292,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1607008402
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281950\">@Aman Arora</span> <span aria-label=\"point up\" class=\"emoji emoji-1f446\" role=\"img\" title=\"point up\">:point_up:</span></p>",
        "id": 218706302,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1607008406
    },
    {
        "content": "<p>we can only capture a deref place that derefs through an <code>&amp;T</code>, <code>&amp;mut T</code> or <code>Box&lt;T&gt;</code>, I think</p>",
        "id": 218706335,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1607008420
    },
    {
        "content": "<p>not <code>*mut T</code></p>",
        "id": 218706366,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1607008430
    },
    {
        "content": "<p>(I think we already don't capture overloaded derefs, right)</p>",
        "id": 218706391,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1607008441
    },
    {
        "content": "<p>Okay that makes sense based on some of the logic that I have seen around</p>",
        "id": 218706489,
        "sender_full_name": "Aman Arora",
        "timestamp": 1607008465
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span>  is it correct to say that in case of move by value, the captured path is always mutable. </p>\n<p>My reasoning behind this is that move kind of creates sort of a new binding within the closure structure and therefore that binding can now be mutable. If we do end up doing the reborrowing approach it will still work because it just suggests that what we are borrow can change and not the contents of  what is being borrowed</p>",
        "id": 219927663,
        "sender_full_name": "Aman Arora",
        "timestamp": 1607995887
    },
    {
        "content": "<p>The reason I ask this is because, today when you run the following code, it suggests that t must be <code>mut</code> regardless of if our feature is enabled or not.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">no_ref</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">struct</span> <span class=\"nc\">S</span><span class=\"p\">(</span><span class=\"nb\">String</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">struct</span> <span class=\"nc\">T</span><span class=\"p\">(</span><span class=\"n\">S</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\">  </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">(</span><span class=\"n\">S</span><span class=\"p\">(</span><span class=\"s\">\"s\"</span><span class=\"p\">.</span><span class=\"n\">into</span><span class=\"p\">()));</span><span class=\"w\"> </span><span class=\"c1\">//~ ERROR: t must be mut</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">t</span><span class=\"p\">.</span><span class=\"mf\">0.0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">\"new S\"</span><span class=\"p\">.</span><span class=\"n\">into</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">c</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>When the feature is enabled and I run with <code>let mut t</code> I get a warning that t doesn't need to be mut and it makes sense because  the following is valid code</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">S</span><span class=\"p\">(</span><span class=\"nb\">String</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">T</span><span class=\"p\">(</span><span class=\"n\">S</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">no_ref</span><span class=\"p\">(</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">s</span>: <span class=\"nb\">String</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">println</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"s\">\"{}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">format</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"s\">\"s\"</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">println</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"s\">\"{}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">(</span><span class=\"n\">S</span><span class=\"p\">(</span><span class=\"s\">\"old\"</span><span class=\"p\">.</span><span class=\"n\">into</span><span class=\"p\">()));</span><span class=\"w\"> </span><span class=\"c1\">//~ ERROR: t must be mut</span>\n<span class=\"w\">    </span><span class=\"n\">no_ref</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">.</span><span class=\"mf\">0.0</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 219928004,
        "sender_full_name": "Aman Arora",
        "timestamp": 1607996256
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281950\">Aman Arora</span> <a href=\"#narrow/stream/189812-t-compiler.2Fwg-rfc-2229/topic/mutability.20of.20captured.20path/near/219927663\">said</a>:</p>\n<blockquote>\n<p>is it correct to say that in case of move by value, the captured path is always mutable. </p>\n</blockquote>\n<p>No, it's not correct. Based on the <strong>desuaring</strong>, it would stand to reason, but we have rather special treatment for captured variables in closures that attempts to make captured things mutable only if they would have been mutable in the creating function (I was confused about this earlier)</p>",
        "id": 219961252,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608029028
    },
    {
        "content": "<p>We talked about this some and came up with some rules for mutability, <span class=\"user-mention\" data-user-id=\"281950\">@Aman Arora</span>, but I'll have to go back to find the precise comment in the history</p>",
        "id": 219961359,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608029087
    },
    {
        "content": "<p>yeah this wasn't one of what we had discussed, it came up because of this example</p>",
        "id": 219961443,
        "sender_full_name": "Aman Arora",
        "timestamp": 1608029137
    },
    {
        "content": "<p>what we had discussed was if we deref a immut-borrow we will have an immutable place</p>",
        "id": 219961481,
        "sender_full_name": "Aman Arora",
        "timestamp": 1608029162
    },
    {
        "content": "<p>well</p>",
        "id": 219961613,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608029230
    },
    {
        "content": "<p>I think the same rule that I outlined there applies here</p>",
        "id": 219961622,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608029236
    },
    {
        "content": "<p>basically that we want to derive the mutability of a given upvar by looking at the mutability of the place of which it is a capture</p>",
        "id": 219961658,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608029266
    },
    {
        "content": "<p>I guess my first question is, what do we expect here</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">no_ref</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">struct</span> <span class=\"nc\">S</span><span class=\"p\">(</span><span class=\"nb\">String</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">struct</span> <span class=\"nc\">T</span><span class=\"p\">(</span><span class=\"n\">S</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\">  </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">(</span><span class=\"n\">S</span><span class=\"p\">(</span><span class=\"s\">\"s\"</span><span class=\"p\">.</span><span class=\"n\">into</span><span class=\"p\">()));</span><span class=\"w\"> </span><span class=\"c1\">//~ ERROR: t must be mut</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">t</span><span class=\"p\">.</span><span class=\"mf\">0.0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">\"new S\"</span><span class=\"p\">.</span><span class=\"n\">into</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">c</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 219961726,
        "sender_full_name": "Aman Arora",
        "timestamp": 1608029291
    },
    {
        "content": "<p>should t be mutable for this to work with our feature enabled</p>",
        "id": 219961740,
        "sender_full_name": "Aman Arora",
        "timestamp": 1608029305
    },
    {
        "content": "<p>yes</p>",
        "id": 219961833,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608029386
    },
    {
        "content": "<p>I think the error is correct</p>",
        "id": 219961849,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608029398
    },
    {
        "content": "<p>note that you get the same error today</p>",
        "id": 219961925,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608029419
    },
    {
        "content": "<p>yup</p>",
        "id": 219961942,
        "sender_full_name": "Aman Arora",
        "timestamp": 1608029428
    },
    {
        "content": "<p>basically the situation is:</p>",
        "id": 219961953,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608029440
    },
    {
        "content": "<ul>\n<li>you are correct that if you desugar, mut ought not to be required</li>\n</ul>",
        "id": 219961962,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608029448
    },
    {
        "content": "<ul>\n<li>but for end users, they are not thinking of the desugaring</li>\n</ul>",
        "id": 219961975,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608029458
    },
    {
        "content": "<p>Fair point</p>",
        "id": 219961988,
        "sender_full_name": "Aman Arora",
        "timestamp": 1608029466
    },
    {
        "content": "<p>it is a bit weird because it means there isn't really a desugaring you can do</p>",
        "id": 219961995,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608029470
    },
    {
        "content": "<p>because our mutability system isn't sufficiently expressive</p>",
        "id": 219962007,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608029478
    },
    {
        "content": "<p>but...oh well</p>",
        "id": 219962016,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608029486
    },
    {
        "content": "<p>I'd rather fix that by expanding the mutability system some day, if we think it's important</p>",
        "id": 219962027,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608029498
    },
    {
        "content": "<p>I guess I need to work on suppressing the warning</p>",
        "id": 219962030,
        "sender_full_name": "Aman Arora",
        "timestamp": 1608029502
    },
    {
        "content": "<p>Because if I enable capture_disjoint_fields and use <code>mut t</code>, compiler tells me t doesn't need to be mut. Which also makes sense</p>",
        "id": 219962094,
        "sender_full_name": "Aman Arora",
        "timestamp": 1608029528
    },
    {
        "content": "<blockquote>\n<p>it is a bit weird because it means there isn't really a desugaring you can do</p>\n</blockquote>\n<p>right, and it's precisely because of <span aria-label=\"point up\" class=\"emoji emoji-1f446\" role=\"img\" title=\"point up\">:point_up:</span> that the code can't be cleaner :(</p>",
        "id": 219962095,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608029529
    },
    {
        "content": "<p>(I guess arguably we could implement a more expressive mutability system internally to the compiler)</p>",
        "id": 219962116,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608029546
    },
    {
        "content": "<p>what do you mean here</p>",
        "id": 219962138,
        "sender_full_name": "Aman Arora",
        "timestamp": 1608029563
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281950\">Aman Arora</span> <a href=\"#narrow/stream/189812-t-compiler.2Fwg-rfc-2229/topic/mutability.20of.20captured.20path/near/219962030\">said</a>:</p>\n<blockquote>\n<p>I guess I need to work on suppressing the warning</p>\n</blockquote>\n<p>tbh I don't remember the details of how upvar mutability is handled in borrowck</p>",
        "id": 219962158,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608029577
    },
    {
        "content": "<p>this doesn't need to do with upvar mutability</p>",
        "id": 219962180,
        "sender_full_name": "Aman Arora",
        "timestamp": 1608029596
    },
    {
        "content": "<p>so we have a local decl for t</p>",
        "id": 219962187,
        "sender_full_name": "Aman Arora",
        "timestamp": 1608029603
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281950\">Aman Arora</span> <a href=\"#narrow/stream/189812-t-compiler.2Fwg-rfc-2229/topic/mutability.20of.20captured.20path/near/219962138\">said</a>:</p>\n<blockquote>\n<p>what do you mean here</p>\n</blockquote>\n<p>what I mean is that if you have <code>self.foo</code>, in today's Rust, you can either make <code>mut self</code> (and hence <em>all</em> fields are mutable) or <code>self</code> (no fields are mutable)</p>",
        "id": 219962195,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608029610
    },
    {
        "content": "<p>but you could imagine a mutability system where, for example, each field <em>also</em> had to be declared <code>mut</code></p>",
        "id": 219962207,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608029622
    },
    {
        "content": "<p>Oh yes</p>",
        "id": 219962211,
        "sender_full_name": "Aman Arora",
        "timestamp": 1608029625
    },
    {
        "content": "<p>(in fact, I think we should've done this)</p>",
        "id": 219962215,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608029626
    },
    {
        "content": "<p>so e.g. <code>struct Foo { mut bar: u32, baz: u32 }</code></p>",
        "id": 219962226,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608029635
    },
    {
        "content": "<p>in that case, <code>self.bar = 22</code> would work iff <code>mut self</code>, but <code>self.baz = 44</code> would not</p>",
        "id": 219962283,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608029648
    },
    {
        "content": "<p>yea that makes sense</p>",
        "id": 219962303,
        "sender_full_name": "Aman Arora",
        "timestamp": 1608029662
    },
    {
        "content": "<p>in any case I am not (currently) trying to argue for this as a good system for end-user Rust</p>",
        "id": 219962316,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608029672
    },
    {
        "content": "<p>but I am saying that the compiler could <em>internally</em> act \"as if\" this was how Rust worked</p>",
        "id": 219962333,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608029683
    },
    {
        "content": "<p>and then we could desugar closures into that</p>",
        "id": 219962336,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608029687
    },
    {
        "content": "<p>instead of having \"Special case logic\" for upvars</p>",
        "id": 219962354,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608029698
    },
    {
        "content": "<p>I suspect this is not the right thing for you to do right now</p>",
        "id": 219962373,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608029709
    },
    {
        "content": "<p>but it might be the cleaner approach in the end</p>",
        "id": 219962385,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608029718
    },
    {
        "content": "<p>seems more like a \"after this is done\" kind of refactoring to me though</p>",
        "id": 219962394,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608029726
    },
    {
        "content": "<p>Yeah</p>",
        "id": 219962395,
        "sender_full_name": "Aman Arora",
        "timestamp": 1608029726
    },
    {
        "content": "<p>So the problem we have is because we have two local declarations, one is for t and the other is for <code>t.0</code> when the closure is constructed. We see <code>t</code> not being mutated and that's the issue.  I think special casing closures here might add a bit too much</p>",
        "id": 219962441,
        "sender_full_name": "Aman Arora",
        "timestamp": 1608029760
    },
    {
        "content": "<p>oh</p>",
        "id": 219962512,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608029776
    },
    {
        "content": "<p>hmm</p>",
        "id": 219962520,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608029780
    },
    {
        "content": "<p>is this in the <em>liveness</em> code?</p>",
        "id": 219962527,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608029783
    },
    {
        "content": "<p>or the <em>borrow check</em> code?</p>",
        "id": 219962534,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608029787
    },
    {
        "content": "<p>...where does that warning come from...</p>",
        "id": 219962547,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608029798
    },
    {
        "content": "<p>this is in the borrow checker code</p>",
        "id": 219962551,
        "sender_full_name": "Aman Arora",
        "timestamp": 1608029801
    },
    {
        "content": "<p><a href=\"https://github.com/sexxi-goose/rust/blob/master/compiler/rustc_mir/src/borrow_check/mod.rs#L437\">https://github.com/sexxi-goose/rust/blob/master/compiler/rustc_mir/src/borrow_check/mod.rs#L437</a><br>\nhere</p>",
        "id": 219962586,
        "sender_full_name": "Aman Arora",
        "timestamp": 1608029827
    },
    {
        "content": "<p>yeah so we really need a concept of 'mut by value' capture I guess</p>",
        "id": 219962613,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608029857
    },
    {
        "content": "<p>(also, I'll note that my desugaring idea above doesn't capture <em>this</em> aspect of things)</p>",
        "id": 219962637,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608029882
    },
    {
        "content": "<p>Well kind of</p>",
        "id": 219962678,
        "sender_full_name": "Aman Arora",
        "timestamp": 1608029883
    },
    {
        "content": "<p>in particular it could make an error occur if you are missing a <code>mut</code></p>",
        "id": 219962717,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608029911
    },
    {
        "content": "<p>but for the lint, we need info to flow in the opposite direction, <em>from</em> the closure into the creator, indicating that the closure will require <code>mut</code></p>",
        "id": 219962742,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608029932
    },
    {
        "content": "<p>Yes</p>",
        "id": 219962771,
        "sender_full_name": "Aman Arora",
        "timestamp": 1608029956
    },
    {
        "content": "<p>there must already be some special casing of closures happening here</p>",
        "id": 219962873,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608030003
    },
    {
        "content": "<p>presumably related to this <code>used_mut_upvars</code> field</p>",
        "id": 219962894,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608030019
    },
    {
        "content": "<p>yes, so <a href=\"https://github.com/sexxi-goose/rust/blob/master/compiler/rustc_mir/src/borrow_check/mod.rs#L1358\">this function call</a></p>",
        "id": 219962912,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608030039
    },
    {
        "content": "<p><a href=\"https://github.com/sexxi-goose/rust/blob/e261649593cf9c2707f7b30a61c46c4469c67ebb/compiler/rustc_mir/src/borrow_check/mod.rs#L1373\">this function</a></p>",
        "id": 219962923,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608030050
    },
    {
        "content": "<p>reading</p>",
        "id": 219962982,
        "sender_full_name": "Aman Arora",
        "timestamp": 1608030094
    },
    {
        "content": "<p>did you update that function at all?</p>",
        "id": 219962984,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608030097
    },
    {
        "content": "<p>pre-existing:</p>",
        "id": 219963103,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608030154
    },
    {
        "content": "<p><a href=\"https://github.com/sexxi-goose/rust/blob/e261649593cf9c2707f7b30a61c46c4469c67ebb/compiler/rustc_mir/src/borrow_check/mod.rs#L536-L538\">this comment is woefully insufficient</a></p>",
        "id": 219963112,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608030159
    },
    {
        "content": "<p>oh, maybe not</p>",
        "id": 219963148,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608030177
    },
    {
        "content": "<p>I just updated the part where we set if a capture is mutable or not</p>",
        "id": 219963185,
        "sender_full_name": "Aman Arora",
        "timestamp": 1608030197
    },
    {
        "content": "<p>I there a relationship b/w the local_decl entry of <code>t</code> vs <code>t.0</code>?</p>",
        "id": 219963209,
        "sender_full_name": "Aman Arora",
        "timestamp": 1608030215
    },
    {
        "content": "<p>ok so .. <code>used_mut_upvars</code> is a list of field indices</p>",
        "id": 219963213,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608030218
    },
    {
        "content": "<p>I guess that can be used to extract the parent variable</p>",
        "id": 219963332,
        "sender_full_name": "Aman Arora",
        "timestamp": 1608030273
    },
    {
        "content": "<p>I think that <a href=\"https://github.com/sexxi-goose/rust/blob/e261649593cf9c2707f7b30a61c46c4469c67ebb/compiler/rustc_mir/src/borrow_check/mod.rs#L1374\">this logic is wrong</a></p>",
        "id": 219963343,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608030278
    },
    {
        "content": "<p>it probably needs to recurse</p>",
        "id": 219963437,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608030321
    },
    {
        "content": "<p>this might be a nested closure case</p>",
        "id": 219963442,
        "sender_full_name": "Aman Arora",
        "timestamp": 1608030324
    },
    {
        "content": "<p>well so it's a bit tricky</p>",
        "id": 219963453,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608030332
    },
    {
        "content": "<p>right now though it does nothing if you </p>\n<ul>\n<li>have a projection</li>\n<li>are not a upvar field projection</li>\n</ul>",
        "id": 219963498,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608030357
    },
    {
        "content": "<p>I think what you want to do is to \"pop\" off the right-most projection until you either</p>\n<ul>\n<li>are just a local variable (in which case you add it to <code>used_muts</code>)</li>\n<li>are a deref of a (shared or mutable) reference (in which case you do nothing)</li>\n<li>or are an upvar field projection (in which case you record it as a 'used mut upvar')</li>\n</ul>",
        "id": 219963616,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608030428
    },
    {
        "content": "<p>the middle case is kind of interesting, I'm remembering this corner case ... maybe it no longer applies in the MIR borrow check era</p>",
        "id": 219963665,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608030470
    },
    {
        "content": "<p>I think it sort of makes sense</p>",
        "id": 219963771,
        "sender_full_name": "Aman Arora",
        "timestamp": 1608030527
    },
    {
        "content": "<p>would it not be easy to start searching from the start?</p>",
        "id": 219963796,
        "sender_full_name": "Aman Arora",
        "timestamp": 1608030545
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"mi\">22</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">+=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>\n<p>(this requires <code>x</code> be captured by \"unique\" reference, which also isn't a concept that Rust exposes to end users)</p>",
        "id": 219963817,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608030565
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281950\">Aman Arora</span> <a href=\"#narrow/stream/189812-t-compiler.2Fwg-rfc-2229/topic/mutability.20of.20captured.20path/near/219963796\">said</a>:</p>\n<blockquote>\n<p>would it not be easy to start searching from the start?</p>\n</blockquote>\n<p>you could also do that, the reason I expessed it as going from the right-hand side is that you want to take action based on the \"last\" thing you find</p>",
        "id": 219963856,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608030598
    },
    {
        "content": "<p>I would use the <a href=\"https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/struct.Place.html#method.as_ref\"><code>Place::as_ref</code></a> to convert to a slice</p>",
        "id": 219963909,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608030606
    },
    {
        "content": "<p>well, convert to a <a href=\"https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/struct.PlaceRef.html\"><code>PlaceRef</code></a></p>",
        "id": 219964006,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608030670
    },
    {
        "content": "<p>though <code>PlaceRef</code> seems to be missing the method I think would be most useful</p>",
        "id": 219964030,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608030689
    },
    {
        "content": "<p>hmm actually <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> recently added some helper for this in one of their PRs</p>",
        "id": 219964049,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608030701
    },
    {
        "content": "<p>I guess it didn't land yet</p>",
        "id": 219964135,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608030743
    },
    {
        "content": "<p>I don't quite think this solves the problem:</p>\n<ol>\n<li>are just a local variable (in which case you add it to used_muts). This is local variable within the closure, right?</li>\n<li>are a deref of a (shared or mutable) reference (in which case you do nothing).</li>\n<li>or are an upvar field projection (in which case you record it as a 'used mut upvar'). The Field projection we get here, is of the precise place</li>\n</ol>",
        "id": 219964137,
        "sender_full_name": "Aman Arora",
        "timestamp": 1608030744
    },
    {
        "content": "<p>because it's waiting on me to r+..d'oh</p>",
        "id": 219964145,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608030748
    },
    {
        "content": "<p>(PR <a href=\"https://github.com/rust-lang/rust/pull/78068\">https://github.com/rust-lang/rust/pull/78068</a>)</p>",
        "id": 219964191,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608030776
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281950\">Aman Arora</span> <a href=\"#narrow/stream/189812-t-compiler.2Fwg-rfc-2229/topic/mutability.20of.20captured.20path/near/219964137\">said</a>:</p>\n<blockquote>\n<ol>\n<li>are just a local variable (in which case you add it to used_muts). This is local variable within the closure, right?</li>\n</ol>\n</blockquote>\n<p>no, this will be the local variable in the closure creator</p>\n<blockquote>\n<ol start=\"3\">\n<li>or are an upvar field projection (in which case you record it as a 'used mut upvar'). The Field projection we get here, is of the precise place</li>\n</ol>\n</blockquote>\n<p>not sure I follow this</p>",
        "id": 219964240,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608030816
    },
    {
        "content": "<p>in particular, the <code>Place</code> we are iterating here is the <em>place that was captured</em></p>",
        "id": 219964250,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608030827
    },
    {
        "content": "<p>i.e., from the perspective of the closure <em>creator</em></p>",
        "id": 219964260,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608030837
    },
    {
        "content": "<p>Okay, yeah I was confused a bit about that. Okay makes more sense. How do we differentiate a Field from an upvar field projection?</p>",
        "id": 219964376,
        "sender_full_name": "Aman Arora",
        "timestamp": 1608030887
    },
    {
        "content": "<p>also just to confirm that would be a nested closure case?</p>",
        "id": 219964415,
        "sender_full_name": "Aman Arora",
        "timestamp": 1608030913
    },
    {
        "content": "<p>the <a href=\"https://github.com/sexxi-goose/rust/blob/e261649593cf9c2707f7b30a61c46c4469c67ebb/compiler/rustc_mir/src/borrow_check/mod.rs#L1376\"><code>is_upvar_field_projection</code></a> function can do that for you</p>",
        "id": 219964429,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608030923
    },
    {
        "content": "<p>but basically the answer is: if you're in a closure and you have <code>self.foo</code></p>",
        "id": 219964440,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608030931
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281950\">Aman Arora</span> <a href=\"#narrow/stream/189812-t-compiler.2Fwg-rfc-2229/topic/mutability.20of.20captured.20path/near/219964415\">said</a>:</p>\n<blockquote>\n<p>also just to confirm that would be a nested closure case?</p>\n</blockquote>\n<p>yes</p>",
        "id": 219964444,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608030934
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/189812-t-compiler.2Fwg-rfc-2229/topic/mutability.20of.20captured.20path/near/219964429\">said</a>:</p>\n<blockquote>\n<p>the <a href=\"https://github.com/sexxi-goose/rust/blob/e261649593cf9c2707f7b30a61c46c4469c67ebb/compiler/rustc_mir/src/borrow_check/mod.rs#L1376\"><code>is_upvar_field_projection</code></a> function can do that for you</p>\n</blockquote>\n<p>oh right <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 219964456,
        "sender_full_name": "Aman Arora",
        "timestamp": 1608030943
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/189812-t-compiler.2Fwg-rfc-2229/topic/mutability.20of.20captured.20path/near/219964440\">said</a>:</p>\n<blockquote>\n<p>but basically the answer is: if you're in a closure and you have <code>self.foo</code></p>\n</blockquote>\n<p>or <code>*self.foo</code></p>",
        "id": 219964472,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608030955
    },
    {
        "content": "<p>I'll try this out later today, and see how this goes</p>",
        "id": 219964627,
        "sender_full_name": "Aman Arora",
        "timestamp": 1608031049
    },
    {
        "content": "<p>Great!</p>",
        "id": 219964953,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608031240
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span>  I created a PR for this: <a href=\"https://github.com/rust-lang/rust/pull/80092\">https://github.com/rust-lang/rust/pull/80092</a> </p>\n<p>There was another unexpected warning, I was able to hack around it, but I'm wasn't able to find/fix the root cause <span aria-label=\"confused\" class=\"emoji emoji-1f615\" role=\"img\" title=\"confused\">:confused:</span> </p>\n<p>I left the details in the PR.</p>",
        "id": 220170913,
        "sender_full_name": "Aman Arora",
        "timestamp": 1608151738
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281950\">@Aman Arora</span> left some comments -- I want to double check that I am understanding what you are referring to about the unexpected warning. Maybe I missed it.</p>",
        "id": 220228937,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608202389
    },
    {
        "content": "<p>You were right, handling the not deref didn't fix the issue</p>",
        "id": 220334434,
        "sender_full_name": "Aman Arora",
        "timestamp": 1608263478
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281950\">@Aman Arora</span> I can try to dig a bit deeper perhaps, though my coding time is very limited :)</p>",
        "id": 220385713,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608305640
    },
    {
        "content": "<p>Thank you <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 220404792,
        "sender_full_name": "Aman Arora",
        "timestamp": 1608313484
    },
    {
        "content": "<p>I'm going to do a brain dump here, in case something is useful:</p>\n<ul>\n<li>So one thing that I observed was that it is now possible that a path itself is a capture</li>\n<li>This wasn't previously the case , which means (previously) if capture wasn't mutable that was because it wasn't declared mutable</li>\n</ul>",
        "id": 222205317,
        "sender_full_name": "Aman Arora",
        "timestamp": 1610252996
    },
    {
        "content": "<p>Without the feature enabled is_mutable is called twice that stood out to me</p>\n<div class=\"codehilite\"><pre><span></span><code>-&gt; DEBUG rustc_mir::borrow_check is_mutable: place=PlaceRef { local: _1, projection: [Deref, Field(field[0], &amp;mut (&amp;mut (&amp;(std::string::String, std::string::String), &amp;str), &amp;str)), Deref, Field(field[0], &amp;mut (&amp;(std::string::String, std::string::String), &amp;str)), Deref, Field(field[0], &amp;(std::string::String, std::string::String)), Deref, Field(field[0], std::string::String)] }, is_local...=No\n\n-&gt; DEBUG rustc_mir::borrow_check is_mutable: place=PlaceRef { local: _1, projection: [Deref, Field(field[0], &amp;mut (&amp;mut (&amp;(std::string::String, std::string::String), &amp;str), &amp;str)), Deref, Field(field[0], &amp;mut (&amp;(std::string::String, std::string::String), &amp;str)), Deref, Field(field[0], &amp;(std::string::String, std::string::String)), Deref] }, is_local...=No\n</code></pre></div>\n<p>With the feature enabled</p>\n<div class=\"codehilite\"><pre><span></span><code>-&gt;  DEBUG rustc_mir::borrow_check is_mutable: place=PlaceRef { local: _1, projection: [Deref, Field(field[0], &amp;mut std::string::String), Deref] }, is_local...=No\n\n-&gt;  DEBUG rustc_mir::borrow_check is_mutable: place=PlaceRef { local: _1, projection: [Deref, Field(field[0], &amp;mut std::string::String)] }, is_local...=No\n\n-&gt; DEBUG rustc_mir::borrow_check is_mutable: upvar.mutability=Upvar { name: &quot;z&quot;, place: CapturedPlace { place: Place { base_ty: (&amp;mut (&amp;(std::string::String, std::string::String), &amp;str), &amp;str), base: Upvar(UpvarId(HirId { owner: DefId(0:3 ~ cant_mutate_imm_borrow[317d]::main), local_id: 76 };`z`;DefId(0:4 ~ cant_mutate_imm_borrow[317d]::main::{closure#0}))), projections: [Projection { ty: &amp;mut (&amp;(std::string::String, std::string::String), &amp;str), kind: Field(0, 0) }, Projection { ty: (&amp;(std::string::String, std::string::String), &amp;str), kind: Deref }, Projection { ty: &amp;(std::string::String, std::string::String), kind: Field(0, 0) }, Projection { ty: (std::string::String, std::string::String), kind: Deref }, Projection { ty: std::string::String, kind: Field(0, 0) }] }, info: CaptureInfo { expr_id: Some(HirId { owner: DefId(0:3 ~ cant_mutate_imm_borrow[317d]::main), local_id: 82 }), capture_kind: ByRef(UpvarBorrow(UniqueImmBorrow, ReErased)) }, mutability: Not }, by_ref: true } local_mutation_is_allowed=No place=PlaceRef { local: _1, projection: [Deref, Field(field[0], &amp;mut std::string::String)] }, place_base=PlaceRef { local: _1, projection: [Deref] }\n\n..... more is_mutable ....\n\n-&gt; DEBUG rustc_mir::borrow_check is_mutable: place=PlaceRef { local: _28, projection: [Field(field[0], &amp;mut (&amp;(std::string::String, std::string::String), &amp;str)), Deref, Field(field[0], &amp;(std::string::String, std::string::String)), Deref, Field(field[0], std::string::String)] }, is_local...=Yes\n\n-&gt; DEBUG rustc_mir::borrow_check is_mutable: place=PlaceRef { local: _28, projection: [Field(field[0], &amp;mut (&amp;(std::string::String, std::string::String), &amp;str)), Deref, Field(field[0], &amp;(std::string::String, std::string::String)), Deref] }, is_local...=Yes\n</code></pre></div>",
        "id": 222205486,
        "sender_full_name": "Aman Arora",
        "timestamp": 1610253252
    },
    {
        "content": "<p>So I have some speculation for this issue:</p>\n<ul>\n<li>\n<p>If we consider the case without the feature:</p>\n<ul>\n<li>We have a path starting off of a capture being used and not the capture being itself</li>\n<li>This means we store this info in used_muts for some local thing based on this</li>\n<li>this will fail because of &amp; borrow</li>\n</ul>\n</li>\n<li>\n<p>if the feature is enabled</p>\n<ul>\n<li>we see that we are trying to modify a capture, which has Mutability::Not.</li>\n<li>this probably gets added  to used_mut_upvars </li>\n<li>throws an error when we propagate the mut requirements up  and we think that the root variable needs to be mut</li>\n</ul>\n</li>\n</ul>",
        "id": 222323039,
        "sender_full_name": "Aman Arora",
        "timestamp": 1610383499
    },
    {
        "content": "<p>well that was sitting in the draft, woops</p>",
        "id": 222323113,
        "sender_full_name": "Aman Arora",
        "timestamp": 1610383528
    },
    {
        "content": "<p>So I was looking at some more logs around this and this feels like the MIR might be wrong</p>",
        "id": 222323291,
        "sender_full_name": "Aman Arora",
        "timestamp": 1610383604
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>DEBUG rustc_mir::borrow_check check_access_permissions((*((*_1).0: &amp;mut std::string::String)), Write(Mutate), is_local_mutation_allowed: No)\nDEBUG rustc_mir::borrow_check is_mutable: place=PlaceRef { local: _1, projection: [Deref, Field(field[0], &amp;mut std::string::String), Deref] }, is_local...=No\nDEBUG rustc_mir::borrow_check is_mutable: place=PlaceRef { local: _1, projection: [Deref, Field(field[0], &amp;mut std::string::String)] }, is_local...=No\nDEBUG rustc_mir::borrow_check is_mutable: upvar.mutability=Upvar { name: &quot;z&quot;, place: CapturedPlace { place: Place { base_ty: (&amp;mut (&amp;(std::string::String, std::string::String), &amp;str), &amp;str), base: Upvar(UpvarId(HirId { owner: DefId(0:3 ~ cant_mutate_imm_borrow[317d]::main), local_id: 76 };`z`;DefId(0:4 ~ cant_mutate_imm_borrow[317d]::main::{closure#0}))), projections: [Projection { ty: &amp;mut (&amp;(std::string::String, std::string::String), &amp;str), kind: Field(0, 0) }, Projection { ty: (&amp;(std::string::String, std::string::String), &amp;str), kind: Deref }, Projection { ty: &amp;(std::string::String, std::string::String), kind: Field(0, 0) }, Projection { ty: (std::string::String, std::string::String), kind: Deref }, Projection { ty: std::string::String, kind: Field(0, 0) }] }, info: CaptureInfo { expr_id: Some(HirId { owner: DefId(0:3 ~ cant_mutate_imm_borrow[317d]::main), local_id: 82 }), capture_kind: ByRef(UpvarBorrow(UniqueImmBorrow, ReErased)) }, mutability: Not }, by_ref: true } local_mutation_is_allowed=No place=PlaceRef { local: _1, projection: [Deref, Field(field[0], &amp;mut std::string::String)] }, place_base=PlaceRef { local: _1, projection: [Deref] }\nDEBUG rustc_mir::borrow_check::diagnostics::mutability_errors report_mutability_error(access_place=(*((*_1).0: &amp;mut std::string::String)), span=cant-mutate-imm-borrow.rs:16:9: 16:16 (#0), the_place_err=PlaceRef { local: _1, projection: [Deref, Field(field[0], &amp;mut std::string::String)] }, error_access=Mutate, location=bb3[1],)\nDEBUG rustc_mir::borrow_check::diagnostics::mutability_errors report_mutability_error: access_place_desc=Some(&quot;z&quot;)\n</code></pre></div>",
        "id": 222323324,
        "sender_full_name": "Aman Arora",
        "timestamp": 1610383623
    },
    {
        "content": "<p>nvm I'm dumb we expect the capture type to be &amp;mut string, that's the typeck part we were discussing</p>",
        "id": 222324840,
        "sender_full_name": "Aman Arora",
        "timestamp": 1610384258
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281950\">Aman Arora</span> <a href=\"#narrow/stream/189812-t-compiler.2Fwg-rfc-2229/topic/mutability.20of.20captured.20path/near/222323039\">said</a>:</p>\n<blockquote>\n<ul>\n<li>if the feature is enabled<ul>\n<li>we see that we are trying to modify a capture, which has Mutability::Not.</li>\n<li>this probably gets added  to used_mut_upvars </li>\n<li>throws an error when we propagate the mut requirements up  and we think that the root variable needs to be mut</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p>So this is incorrect, we wouldn't add it to the used_upvar_muts because the is_mutable test fails for them</p>",
        "id": 222365456,
        "sender_full_name": "Aman Arora",
        "timestamp": 1610403198
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span>  Okay I think I got this. This isn't quite a bug</p>\n<p>Well there is a logging bug i think, but not quite an actual bug</p>",
        "id": 222460509,
        "sender_full_name": "Aman Arora",
        "timestamp": 1610470445
    },
    {
        "content": "<p>if u look at this: <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=d207754d7a09e7b11ff20d2ac0b746a2\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=d207754d7a09e7b11ff20d2ac0b746a2</a><br>\nwe see two logs being emitted. This example is closer to the test case with the feature enabled because a capture is directly being mutated.</p>\n<p>We can see that we emit two errors here: One is thrown when we are borrow checking the closure because the capture isn't mutable and therefore can't be assigned to. The second is when we process the function, in which case the error is when we try to mut borrow so that we can create the closure</p>",
        "id": 222460971,
        "sender_full_name": "Aman Arora",
        "timestamp": 1610470616
    },
    {
        "content": "<p>Now the problem arises from the notion that if a capture is immutable then that must be because the root variable is immutable</p>",
        "id": 222462895,
        "sender_full_name": "Aman Arora",
        "timestamp": 1610471284
    },
    {
        "content": "<p>we could use this assumption to provide the suggestion to mark that place mut but that might not be a correct suggestion when a precise path is captured.</p>\n<p>So my hack is not quite a hack <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span></p>",
        "id": 222463177,
        "sender_full_name": "Aman Arora",
        "timestamp": 1610471379
    }
]