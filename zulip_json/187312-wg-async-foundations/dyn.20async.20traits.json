[
    {
        "content": "<p>I've been playing with the idea of shadow traits as Niko laid out in the 6th blog post. It all seems to work rather well and I was pleasently surpised that even the coercion from e.g., &amp;SleepyRange to &amp;dyn DynAsyncIter works (surprising to me since there is not an impl of DynAsyncIter for SleepyRange)</p>",
        "id": 260434123,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1636131776
    },
    {
        "content": "<p>Anyway, istm that this is a really nice solution because the compiler/std doesn't need to be involved in derive_dyn (or whatever the macro is) and users could use different macros (or flags to the macro or whatever) to use alternatives to boxing</p>",
        "id": 260434396,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1636131879
    },
    {
        "content": "<p>So, I was a bit surprised by the \"I don’t really see this as a “long term solution”, but I would be interested to play with it.\" line in the blog post - <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> why don't you see it as a long term solution?</p>",
        "id": 260434542,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1636131945
    },
    {
        "content": "<p>(I wonder if an attribute macro is optimal - perhaps the crate which specifies the async trait should not have to concern themselves with this, and a downstream crate should be able to use a macro to create the dynamic version of the trait and generate the impls. That would require a little more boilerplate (having to name the methods and sigs) or being able to pass the trait def to the macro somehow. But it means the user can decide whether they want to use Box or something else, and it seems like the user is likely to be the one more constrained</p>",
        "id": 260435064,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1636132162
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256841\">@Nick Cameron</span> ooh, excited to hear that!</p>",
        "id": 260464785,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1636146367
    },
    {
        "content": "<p>I agree it works well and checks a lot of boxes</p>",
        "id": 260464800,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1636146377
    },
    {
        "content": "<p>I've had on my list to write some follow-up blog posts, and try to lay out an impl plan for a crate called <code>dyner </code> to do the translation for you</p>",
        "id": 260464826,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1636146398
    },
    {
        "content": "<p>but maybe you're ahead of me? That'd be aweseome :)</p>",
        "id": 260464840,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1636146407
    },
    {
        "content": "<p>In any case, why don't I see it as a long-term solution:</p>\n<p>I guess, tbh, I sort of do as well. I think there's going to be a desire to get control and this seems like a plausible way to do that. One thing I also kind of like is that, actually, these \"dyn flavors\" of traits can be done <em>outside</em> the crate where the trait was defined.</p>",
        "id": 260464916,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1636146457
    },
    {
        "content": "<p>my main concern is that I'd like a 'convenient, easy' default</p>",
        "id": 260464944,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1636146472
    },
    {
        "content": "<p>otoh I think that dyn overall in rust is kind of painful</p>",
        "id": 260464960,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1636146481
    },
    {
        "content": "<p>anyway, I'd love to discuss more</p>",
        "id": 260465001,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1636146488
    },
    {
        "content": "<p>I didn't try implementing a macro, only experimenting with what the generated code and user code would look like</p>",
        "id": 260696994,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1636395300
    },
    {
        "content": "<p>I guess it might be nice to have some crazy syntax like Box&lt;dyn async&lt;Box&gt; AsynIterator&gt;</p>",
        "id": 260697329,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1636395432
    },
    {
        "content": "<p>perhaps some kind of parametric build script for crates? I found it a bit hard to imagine how we could do the fully ergonomic thing without some kind of madness...</p>",
        "id": 260697484,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1636395488
    },
    {
        "content": "<p>more to think about...</p>",
        "id": 260697500,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1636395500
    },
    {
        "content": "<p>remote derives :-)</p>",
        "id": 260734927,
        "sender_full_name": "tmandry",
        "timestamp": 1636414690
    },
    {
        "content": "<p>since it doesn't have to be defined in the crate that defines the trait</p>",
        "id": 260735201,
        "sender_full_name": "tmandry",
        "timestamp": 1636414943
    },
    {
        "content": "<p>though you probably want to have a central crate where these are all defined so you can use the new dyn variants across multiple crates</p>",
        "id": 260735565,
        "sender_full_name": "tmandry",
        "timestamp": 1636415253
    },
    {
        "content": "<p>which leads to the next crazy idea, which is defining these dyn variants \"on demand\" and considering them part of the dyn variant crate for coherence purposes</p>",
        "id": 260735700,
        "sender_full_name": "tmandry",
        "timestamp": 1636415335
    },
    {
        "content": "<p>so if I wind up with code naming <code>dyn&lt;UserBox&gt; Future</code>, the derive defining <code>UserBoxDynFuture</code> would happen automatically</p>",
        "id": 260735969,
        "sender_full_name": "tmandry",
        "timestamp": 1636415532
    },
    {
        "content": "<p>To get past custom <code>DynAsyncIter</code>-esque fat pointers, what do y'all think of allowing dyner crates to write their own <code>Unsize</code> impls, so that <code>Bok&lt;impl MyTrait&gt; -&gt; Box&lt;dyn MyTrait&gt;</code> coercion can automatically add custom metadata? Something like:</p>\n<div class=\"codehilite\"><pre><span></span><code>impl&lt;T: AsyncIter&gt; Unsize&lt;dyn AsyncIter&gt; for T {\n    const META: &amp;&#39;static AsyncIterVTable = dyn_async_iter_vtable();\n}\n</code></pre></div>",
        "id": 260742676,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636420671
    },
    {
        "content": "<p>It works pretty well for slices too, although there is no reason users should be implementing those:</p>\n<div class=\"codehilite\"><pre><span></span><code>impl&lt;const N: usize, T&gt; Usize&lt;[T]&gt; for [T; N] {\n    const META: usize = N;\n}\n</code></pre></div>",
        "id": 260742960,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636420913
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116883\">tmandry</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/dyn.20async.20traits/near/260735565\">said</a>:</p>\n<blockquote>\n<p>though you probably want to have a central crate where these are all defined so you can use the new dyn variants across multiple crates</p>\n</blockquote>\n<p>yeah, I've been pondering how important this is. My hypothesis is that for cross-crate compat people are more likely to use generics and trait objects are more likely to be used within a project.  My reasoning is that the reason to use a specific smart pointer is probably due to the specifics of a project's environment, rather than anything about either the trait or its impl</p>",
        "id": 260963166,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1636536013
    },
    {
        "content": "<p>then for compat between crates you'd need HKTs</p>",
        "id": 260963197,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1636536040
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116883\">tmandry</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/dyn.20async.20traits/near/260735700\">said</a>:</p>\n<blockquote>\n<p>which leads to the next crazy idea, which is defining these dyn variants \"on demand\" and considering them part of the dyn variant crate for coherence purposes</p>\n</blockquote>\n<p>I think this is the same idea as my \"crazy syntax like Box&lt;dyn async&lt;Box&gt; AsynIterator&gt;\" suggestion. I don't like it very much :-D</p>",
        "id": 260963288,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1636536106
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"222520\">Sam Sartor</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/dyn.20async.20traits/near/260742676\">said</a>:</p>\n<blockquote>\n<p>To get past custom <code>DynAsyncIter</code>-esque fat pointers, what do y'all think of allowing dyner crates to write their own <code>Unsize</code> impls, so that <code>Bok&lt;impl MyTrait&gt; -&gt; Box&lt;dyn MyTrait&gt;</code> coercion can automatically add custom metadata? Something like:</p>\n<p><div class=\"codehilite\"><pre><span></span><code>impl&lt;T: AsyncIter&gt; Unsize&lt;dyn AsyncIter&gt; for T {\n    const META: &amp;&#39;static AsyncIterVTable = dyn_async_iter_vtable();\n}\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I don't think you need this? With the right impls, unsizing coercions work out of the box for the dynamic traits</p>",
        "id": 260963399,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1636536164
    },
    {
        "content": "<p>I'm not clear what you mean by custom metadata though</p>",
        "id": 260963429,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1636536183
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256841\">@Nick Cameron</span> Assuming a dyn_derive crate wants to define its own vtable struct and fill it with custom wrapper functions, how does the coercion know the vtable instance for a given concrete type?</p>",
        "id": 261036757,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636570282
    },
    {
        "content": "<p>It can be done simply by delegating from one trait impl to another without having to explicitly fiddle with vtables at all. It might be good to have some mechanism to eliminate the indirection by manipulating the vtable, but I can’t imagine an ergonomic solution</p>",
        "id": 261040496,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1636571971
    },
    {
        "content": "<p>Oh yah, because you are relying only on the coercion of the shadow trait. I'm sorta hung up on the fact that given <code>MyStruct&lt;T: AsyncIter&gt;</code>, a <code>MyStruct&lt;impl AsyncIter&gt;</code> can only coerce to <code>MyStruct&lt;dyn ErasedAsyncIter&gt;</code>if <code>ErasedAsyncIter: AsyncIter</code> and <code>dyn ErasedAsyncIter: AsyncIter</code>. But I suppose those problems shouldn't be too hard to solve vs exposing the vtable implementation directly?</p>",
        "id": 261044833,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636573904
    },
    {
        "content": "<p>Actually, I think I am wrong about the <code>ErasedAsyncIter: AsyncIter</code> bound. Because you can cast directly from <code>impl SubTrait</code> to <code>dyn SuperTrait</code>. And think the <code>impl AsyncIter for dyn ErasedAsyncIter</code> does work out of the box, right?</p>",
        "id": 261045726,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636574271
    },
    {
        "content": "<p>I think I was just overthinking stuff. As long as you <code>impl AsyncIter for dyn ErasedAsyncIter</code> directly, it all does work well.</p>",
        "id": 261047796,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636575100
    },
    {
        "content": "<p>Indeed, it’s kind of amazing that everything just works</p>",
        "id": 261049767,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1636575940
    }
]