[
    {
        "content": "<p>Should this snippet be allowed (taken from <code>not-send-sync.rs</code>)?</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"n\">assert_sync</span><span class=\"p\">(</span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">//~^ ERROR: generator cannot be shared between threads safely</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Cell</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kr\">yield</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">});</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Currently it is not, I'm assuming because <code>a</code> is in scope across the <code>yield</code>. But, when basing captures off liveness instead, <code>a</code> doesn't get captured because <code>a</code> is not used after the yield.</p>",
        "id": 250420679,
        "sender_full_name": "eholk",
        "timestamp": 1629757902
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"421986\">@eholk</span> and because it doesn't have a destructor? We do currently take that into account from borrow check (sheesh, I should take my own advice and try to document those rules).</p>",
        "id": 250534155,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629832542
    },
    {
        "content": "<p>I am in favor of using consistent rules</p>",
        "id": 250534182,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629832554
    },
    {
        "content": "<p>Correct, in this case it doesn't have a destructor.</p>",
        "id": 250544549,
        "sender_full_name": "eholk",
        "timestamp": 1629837207
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> I wonder if we could actually unify all these rules. We might need different implementations of them, due to pass phasing issues, which would be sad, but at least we could just say \"We use the standard liveness/borrow/capture rules.\"</p>",
        "id": 250544707,
        "sender_full_name": "eholk",
        "timestamp": 1629837274
    },
    {
        "content": "<p>Do we have another set of rules for closures too? It seems like they should be a subset of the generator rules, since it seems like closures should just be generators that don't yield.</p>",
        "id": 250544906,
        "sender_full_name": "eholk",
        "timestamp": 1629837369
    },
    {
        "content": "<p>Generators are indeed a generalization of closures and they have the same capture semantics, but liveness wouldn't come into the picture with regular closures</p>",
        "id": 250579901,
        "sender_full_name": "tmandry",
        "timestamp": 1629867053
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"421986\">@eholk</span> yes, I think we should strive to have unified rules</p>",
        "id": 250698692,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629935031
    },
    {
        "content": "<p>I'm not sure how much we can do that by having one bit of code, but we should try to write out the rules</p>",
        "id": 250698705,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629935041
    },
    {
        "content": "<p>and then we can at least test for consistency</p>",
        "id": 250698747,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629935047
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> - I was just looking at how <code>ExprUseVisitor</code> is used in <code>closure_analyze</code>. I wonder if we could do the live-across-yield analysis as part of closure analysis too, since closures basically generators that don't yield.</p>",
        "id": 250832029,
        "sender_full_name": "eholk",
        "timestamp": 1630008438
    },
    {
        "content": "<p><code>resolve_generator_interiors</code> runs right after <code>closure_analyze</code>, so it seems like unifying the two may sorta kinda work.</p>",
        "id": 250832184,
        "sender_full_name": "eholk",
        "timestamp": 1630008500
    },
    {
        "content": "<p>seems reasonable..</p>",
        "id": 250866878,
        "sender_full_name": "tmandry",
        "timestamp": 1630029315
    },
    {
        "content": "<p>So there's another aspect of this I've been thinking about. Consider this case:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">client</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Client</span><span class=\"p\">(</span><span class=\"nb\">Box</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"kc\">true</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">client</span><span class=\"p\">.</span><span class=\"n\">status</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"mi\">200</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">get</span><span class=\"p\">().</span><span class=\"k\">await</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">},</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">(),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>This future is not <code>Send</code> because <code>client</code> is not <code>Sync</code>, and therefore the borrow of <code>client</code> is not <code>Send</code>. (Let's assume the current rules, not the new liveness rules I'm working on. We could construct a similar example under the liveness rules though)</p>",
        "id": 251267683,
        "sender_full_name": "eholk",
        "timestamp": 1630346176
    },
    {
        "content": "<p>It seems like this should be okay, since the future owns <code>client</code>. In general it wouldn't be safe to send the <code>&amp;Client</code> to another thread, but if we send the generator we'll send both the <code>Client</code> and the <code>&amp;Client</code>.</p>",
        "id": 251267902,
        "sender_full_name": "eholk",
        "timestamp": 1630346282
    },
    {
        "content": "<p>I wonder if there's a way we account for this in our rules too.</p>",
        "id": 251267982,
        "sender_full_name": "eholk",
        "timestamp": 1630346311
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> or <span class=\"user-mention\" data-user-id=\"116883\">@tmandry</span>, what do you think?</p>",
        "id": 251268197,
        "sender_full_name": "eholk",
        "timestamp": 1630346408
    },
    {
        "content": "<p>Also, I have a patch that describes liveness-based auto traits for generators in the Reference. I'd appreciate some feedback from the async folks, and then I'll look at proposing this to the lang team.<br>\n<a href=\"https://github.com/eholk/reference/commit/3f831eafd7a497ce5c6859dcceb3b58f0ea76917\">https://github.com/eholk/reference/commit/3f831eafd7a497ce5c6859dcceb3b58f0ea76917</a></p>",
        "id": 251294443,
        "sender_full_name": "eholk",
        "timestamp": 1630357293
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"421986\">eholk</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/Generator.20captures/near/251267902\">said</a>:</p>\n<blockquote>\n<p>It seems like this should be okay, since the future owns <code>client</code>. In general it wouldn't be safe to send the <code>&amp;Client</code> to another thread, but if we send the generator we'll send both the <code>Client</code> and the <code>&amp;Client</code>.</p>\n</blockquote>\n<p>yeah, so this came up in <a href=\"#narrow/stream/187312-wg-async-foundations/topic/Example.20of.20odd.20composing.20of.20Send\">this thread</a></p>",
        "id": 251588398,
        "sender_full_name": "tmandry",
        "timestamp": 1630513664
    },
    {
        "content": "<p>I wrote down some ideas about it at some point and haven't revisited</p>",
        "id": 251588429,
        "sender_full_name": "tmandry",
        "timestamp": 1630513678
    }
]