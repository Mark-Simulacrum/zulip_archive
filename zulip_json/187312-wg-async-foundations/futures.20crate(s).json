[
    {
        "content": "<p>Hey <span class=\"user-mention\" data-user-id=\"203289\">@boats</span>, <span class=\"user-mention\" data-user-id=\"127859\">@Taylor Cramer</span>  --</p>\n<p>One of the questions that I don't have a good handle on is the futures crate. Looking at the <a href=\"https://github.com/rust-lang-nursery/futures-rs\" target=\"_blank\" title=\"https://github.com/rust-lang-nursery/futures-rs\">rust-lang-nursery/futures-rs</a> crate, I see a lot of \"subcrates\". Is there some consensus about the relative importance of these various features? Is the plan to move some/all of this into libstd at some point, once it's had more time to bake?</p>",
        "id": 167476484,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1559823921
    },
    {
        "content": "<p>There's not a clear consensus. My understanding of the current plan is that some time between Future being stabilized and async/await being stabilized, we will release an <code>0.3</code> of the crates which will be substantially similar to the current API.</p>",
        "id": 167490425,
        "sender_full_name": "boats",
        "timestamp": 1559833821
    },
    {
        "content": "<p>We've discussed a 1.0 version at the all hands, but there were several outstanding issues that made that seem more difficult to produce</p>",
        "id": 167490453,
        "sender_full_name": "boats",
        "timestamp": 1559833850
    },
    {
        "content": "<p>In the long term, there's a general sense that we'd like core abstractions like stream, asyncread, asyncwrite to be in std, but its still very unclear and up in the air</p>",
        "id": 167490493,
        "sender_full_name": "boats",
        "timestamp": 1559833873
    },
    {
        "content": "<p>Would it be possible to extract an uncontroversial subset and release that as 1.0?</p>",
        "id": 167491567,
        "sender_full_name": "Florian Gilcher",
        "timestamp": 1559834554
    },
    {
        "content": "<p>I wanted to look into doing that but I think it will have to be delayed until after async/await is stable</p>",
        "id": 167492157,
        "sender_full_name": "boats",
        "timestamp": 1559834926
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"215333\">@Florian Gilcher</span> unfortunately the uncontroversial subset does not include Stream</p>",
        "id": 167501643,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1559841596
    },
    {
        "content": "<p><code>AsyncRead</code>/<code>AsyncWrite</code> IMO are the most \"obvious\"ly correct, but even they have points of disagreement that folks have argued over.</p>",
        "id": 167501724,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1559841650
    },
    {
        "content": "<p><code>futures-core</code> and <code>futures-io</code>are meant to represent a subset that is stable enough for folks to rely on in public API boundaries</p>",
        "id": 167501758,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1559841684
    },
    {
        "content": "<p>everything else is intended to be left as utilities/implementation details that can evolve freely over time as they grow to better fit the needs of users.</p>",
        "id": 167501843,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1559841734
    },
    {
        "content": "<p>I would be a concerned with a development of having too many AsyncX traits</p>",
        "id": 167506050,
        "sender_full_name": "centril",
        "timestamp": 1559844332
    },
    {
        "content": "<p>that would presumably cause a lot of code duplication and be unfortunate from an effect system POV</p>",
        "id": 167506075,
        "sender_full_name": "centril",
        "timestamp": 1559844354
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"126931\">@centril</span> I don't think that's avoidable</p>",
        "id": 167508021,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1559845563
    },
    {
        "content": "<p>elaborate?</p>",
        "id": 167508051,
        "sender_full_name": "centril",
        "timestamp": 1559845582
    },
    {
        "content": "<p>Like, this is the \"what color is your function\" problem in its purest form</p>",
        "id": 167508053,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1559845583
    },
    {
        "content": "<p>This problem has a known solution: Monads or effect systems.</p>",
        "id": 167508076,
        "sender_full_name": "centril",
        "timestamp": 1559845606
    },
    {
        "content": "<p>We cannot do the former; we can do the latter.</p>",
        "id": 167508098,
        "sender_full_name": "centril",
        "timestamp": 1559845625
    },
    {
        "content": "<p>Neither of those solve this problem, and there's tons of existing literature into why</p>",
        "id": 167508108,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1559845633
    },
    {
        "content": "<p>but I'd be happy to discuss w/ you why and what an \"async trait\"-like effects system might look like, and why I think it's unlikely to pan out, at least anytime in the near future</p>",
        "id": 167508206,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1559845700
    },
    {
        "content": "<p>Not the literature I've read (e.g. Frank, Idris's algebraic effects, etc.) but I'm happy to discuss it</p>",
        "id": 167508222,
        "sender_full_name": "centril",
        "timestamp": 1559845720
    },
    {
        "content": "<p>I'm not completely defeatist on the idea, but I think it's very far from where we are today</p>",
        "id": 167508225,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1559845723
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"127859\">@Taylor Cramer</span> aside: up for pre-triage mtg?</p>",
        "id": 167508271,
        "sender_full_name": "centril",
        "timestamp": 1559845757
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"126931\">@centril</span> yeah, it doesn't look like I'm getting kicked out of my room yet</p>",
        "id": 167508705,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1559846004
    },
    {
        "content": "<p>often I can't get a room :(</p>",
        "id": 167508716,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1559846012
    },
    {
        "content": "<p>neat</p>",
        "id": 167508720,
        "sender_full_name": "centril",
        "timestamp": 1559846015
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"127859\">@Taylor Cramer</span> I don't see why we absolutely need <code>Stream</code>, TBH</p>",
        "id": 167509919,
        "sender_full_name": "Florian Gilcher",
        "timestamp": 1559846717
    },
    {
        "content": "<p>From my point of view, Stream as a stable and all-encompassing abstraction takes time, but for any subset of users needs, either using a concrete channel implementation or an ad-hoc library trait will do.</p>",
        "id": 167509990,
        "sender_full_name": "Florian Gilcher",
        "timestamp": 1559846756
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"215333\">@Florian Gilcher</span> interesting. I think it's necessary for the same reasons that <code>Iterator</code> is necessary, but maybe you're considering a more specific use-case than the ones I have in mind</p>",
        "id": 167511950,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1559847792
    },
    {
        "content": "<p>I think I already tried to start a few discussions around this which never got traction. But here’s my opinion again: </p>\n<p>I think neither Streams nor the AsyncXyz things should be stabilized right now, and until someone can paint a clear path forward for a reasonable integration with futures. Up to now only Nemo157 could do that partially, and even they weren’t sure if it would really work out.  Up to that point even the current prominence of those types in crates like Runtime feels unfortunate. I wouldn’t want to see a 3 color function world in Rust. And neither people building on top of abstractions which get canned later on.</p>",
        "id": 167544269,
        "sender_full_name": "Matthias247",
        "timestamp": 1559879581
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"204219\">@Matthias247</span> how do you want to stop people from building on top?</p>",
        "id": 167558922,
        "sender_full_name": "Florian Gilcher",
        "timestamp": 1559897155
    },
    {
        "content": "<p>Like, honestly, people are waiting for this for years now, they will either take what we give or build their own.</p>",
        "id": 167558978,
        "sender_full_name": "Florian Gilcher",
        "timestamp": 1559897179
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"127859\">@Taylor Cramer</span> you mean as adapters? I don't think they fill the same niche as Iterator, especially not in a sense that they need to be available as a finished interface from the get-go</p>",
        "id": 167559046,
        "sender_full_name": "Florian Gilcher",
        "timestamp": 1559897241
    },
    {
        "content": "<p>Like, I appreciate that they should be present, but useful applications of considerable size can be written without, which gives a bit of leeway to not stabilising them.</p>",
        "id": 167560245,
        "sender_full_name": "Florian Gilcher",
        "timestamp": 1559898348
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"215333\">@Florian Gilcher</span> no one wants to include these things in the MVP</p>",
        "id": 167566553,
        "sender_full_name": "boats",
        "timestamp": 1559904950
    },
    {
        "content": "<p>I mean I guess youre talking about leaving stream out of a 1.0 version of the futures crate</p>",
        "id": 167566727,
        "sender_full_name": "boats",
        "timestamp": 1559905100
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"215333\">@Florian Gilcher</span> You can’t stop but you can discourage. E.g. by leavings things out of stabilization as proposed. And by at least communicating that this is an open area, and investing some work in it (experimenting and then proposing a path forward). Right now the official communication sounds like: Stream is the way to go, and we might make it somehow work with Generators. Due to that projects like runtime and go are picking things up as their core abstraction.</p>",
        "id": 167590290,
        "sender_full_name": "Matthias247",
        "timestamp": 1559923935
    },
    {
        "content": "<p>I don't know what a 1.0 version of the futures crate would include if not <code>Stream</code>. It seems like it'd just be what's in std, which is the only \"true\" 1.0 in my mind</p>",
        "id": 167600601,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1559931801
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"203289\">@boats</span> my initial question was if there's a subset of the futures crate that _is_ ready for 1.0 and it has slowly drifted that people seem to feel like such a subset is not useful.</p>",
        "id": 167706765,
        "sender_full_name": "Florian Gilcher",
        "timestamp": 1560097840
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"127859\">@Taylor Cramer</span> futures combinators for example, potentially asyncread/write to build protocols on a more abstract fashion then reading sockets directly.</p>",
        "id": 167706792,
        "sender_full_name": "Florian Gilcher",
        "timestamp": 1560097900
    },
    {
        "content": "<p>I wonder if <code>AsyncRead</code>/<code>AsyncWrite</code>/<code>Stream</code> should use proper <code>async fn foo</code> instead of <code>fn poll_foo</code> (once async trait methods become possible). What do you think about renaming current <code>AsyncRead</code>/<code>AsyncWrite</code> to <code>PollRead</code>/<code>PollWrite</code> instead?</p>",
        "id": 167761727,
        "sender_full_name": "stjepang",
        "timestamp": 1560175502
    },
    {
        "content": "<p>So we'd have something like:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">PollRead</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">poll_read</span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"bp\">self</span>: <span class=\"nc\">Pin</span><span class=\"o\">&lt;&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">Self</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">cx</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">Context</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">buf</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Poll</span><span class=\"o\">&lt;</span><span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Error</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 167761745,
        "sender_full_name": "stjepang",
        "timestamp": 1560175509
    },
    {
        "content": "<p>Then, once async trait methods become possible, we can add:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">AsyncRead</span>: <span class=\"nc\">PollRead</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">async</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">read</span><span class=\"p\">(</span><span class=\"n\">buf</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">])</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Poll</span><span class=\"o\">&lt;</span><span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Error</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 167761769,
        "sender_full_name": "stjepang",
        "timestamp": 1560175540
    },
    {
        "content": "<p>Finally, we deprecate polling traits in favor of the new traits using <code>async fn</code> and add the following blanket impl.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span>: <span class=\"nc\">PollRead</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">AsyncRead</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">async</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">read</span><span class=\"p\">(</span><span class=\"n\">buf</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">])</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Error</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">future</span>::<span class=\"n\">poll_fn</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">cx</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">poll_read</span><span class=\"p\">(</span><span class=\"n\">cx</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">buf</span><span class=\"p\">)).</span><span class=\"n\">await</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>This way, libraries using <code>PollRead</code> can switch to <code>AsyncRead</code> without breaking backwards compatibility.</p>",
        "id": 167761889,
        "sender_full_name": "stjepang",
        "timestamp": 1560175618
    },
    {
        "content": "<p>The problem with <code>poll_foo</code> methods is that they don't return futures. It is (in a philosophical sense) <em>wrong</em> for <code>File</code> to have <code>poll_read()</code> method because, well, files are not futures. However, operations on files (like read or write) are futures.</p>",
        "id": 167762041,
        "sender_full_name": "stjepang",
        "timestamp": 1560175738
    },
    {
        "content": "<p>This especially becomes a problem when asynchronous operations need to keep some state. For example, with <code>poll_read</code>, async read operations cannot keep their own state. And if there is any state inside an async read operation, then it has to be embedded into the <code>File</code> struct.</p>",
        "id": 167762200,
        "sender_full_name": "stjepang",
        "timestamp": 1560175826
    },
    {
        "content": "<p>But even that's fraught with problems because then there is no way to \"cancel\" async operations with <code>poll_read()</code>. If you begin a read operation by calling <code>poll_read()</code> and then timeout on it, you can't drop the future to cancel it because there isn't one! That means the next read operation will try to pick up the state of the previous <code>poll_read()</code> invocation, which isn't right.</p>",
        "id": 167762407,
        "sender_full_name": "stjepang",
        "timestamp": 1560175974
    },
    {
        "content": "<p>All those problems make me believe <code>poll_foo</code> methods should only belong to real futures (i.e. async operations), and <em>not</em> to objects that can be operated on asynchronously (i.e. start async operations).</p>",
        "id": 167762533,
        "sender_full_name": "stjepang",
        "timestamp": 1560176062
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"128448\">@stjepang</span> main discussion of that idea is at <a href=\"https://github.com/rust-lang-nursery/futures-rs/issues/1365\" target=\"_blank\" title=\"https://github.com/rust-lang-nursery/futures-rs/issues/1365\">https://github.com/rust-lang-nursery/futures-rs/issues/1365</a></p>",
        "id": 167780518,
        "sender_full_name": "Nemo157",
        "timestamp": 1560189401
    },
    {
        "content": "<p>the major issue that cramertj mentions is that <code>async fn read</code> in a trait is actually sugar for an associated type + function (well, almost certainly going to be, once it's defined), once you have that associated type on the trait how do you deal with <code>dyn AsyncRead</code>?</p>",
        "id": 167780770,
        "sender_full_name": "Nemo157",
        "timestamp": 1560189594
    },
    {
        "content": "<p>the alternative solution is to have it be a dynamically-dispatched future of some kind, but it's unclear exactly how that would work</p>",
        "id": 167784206,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1560191767
    },
    {
        "content": "<p>one proposal that i'd been playing around with was a kind of automatic version of what we did for <code>Waker</code>, which is to offer by-value DSTs with a fixed \"max size\" (in the case of waker, the size is \"one pointer width\")</p>",
        "id": 167784292,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1560191825
    },
    {
        "content": "<p>we could do something sorta clever like making the object returned the size of all the arguments to the function + alignment so that you could store them all in a struct and return that type to prevent having to heap-allocate for all the existing impls while retaining object safety</p>",
        "id": 167784449,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1560191910
    },
    {
        "content": "<p>it's <em>really</em> complicated though and requires a whole field of language functionality we don't have today</p>",
        "id": 167784465,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1560191926
    },
    {
        "content": "<p>e.g.:</p>\n<div class=\"codehilite\"><pre><span></span>trait AsyncRead {\n    async fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;usize, io::Error&gt;;\n}\n</pre></div>\n\n\n<p>would desugar into something like this:</p>\n<div class=\"codehilite\"><pre><span></span>trait AsyncRead {\n    fn read&lt;&#39;a&gt;(&amp;&#39;a mut self, buf: &amp;&#39;a mut [u8]) -&gt; dyn&lt;sizeof(usize) * 2&gt; Future&lt;Output = Result&lt;...&gt;&gt; + &#39;a;\n}\n</pre></div>",
        "id": 167784700,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1560192086
    },
    {
        "content": "<p>where <code>dyn&lt;NUM&gt; Trait</code> is some by-value dyn trait with an upper size bound of <code>NUM</code></p>",
        "id": 167784803,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1560192152
    },
    {
        "content": "<p>and implementing it with an <code>async fn</code> whose body was too big would require writing <code>async(Box:new)</code> or something</p>",
        "id": 167784836,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1560192173
    },
    {
        "content": "<blockquote>\n<p>the major issue that cramertj mentions is that <code>async fn read</code> in a trait is actually sugar for an associated type + function (well, almost certainly going to be, once it's defined), once you have that associated type on the trait how do you deal with <code>dyn AsyncRead</code>?</p>\n</blockquote>\n<p>Do we need <code>dyn AsyncRead</code>? Can we just make traits with <code>async fn</code>s not object-safe?</p>",
        "id": 167785516,
        "sender_full_name": "stjepang",
        "timestamp": 1560192627
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"128448\">@stjepang</span> yes, <code>dyn AsyncRead</code> is critically important</p>",
        "id": 167785788,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1560192837
    },
    {
        "content": "<blockquote>\n<p>can we make traits with <code>async fn</code>s not object-safe?</p>\n</blockquote>\n<p>Yes, but people will continue to hack around them and not use them if that's the case. I'm not opposed to starting here necessarily, but it's not a generally applicable solution.</p>",
        "id": 167785935,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1560192921
    },
    {
        "content": "<blockquote>\n<p><code>dyn AsyncRead</code> is critically important</p>\n</blockquote>\n<p>As a curious bystander, why is that?</p>",
        "id": 167786558,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1560193331
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116155\">@Jake Goulding</span> it's a core point over which libraries and other tools allow abstraction of underlying interfaces (notably TCP), and making all of the relevant functions generic over those parameters is either not an option in some places due to heterogeneous collections, or it would cause an incredibly large amount of code bloat</p>",
        "id": 167786931,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1560193635
    },
    {
        "content": "<p>(note that all the same comments apply to <code>Stream</code>, if you viewed it as <code>async fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;</code>)</p>",
        "id": 167787022,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1560193686
    },
    {
        "content": "<p>Why is this code bloat more of a problem compared to plain-old <code>Read</code> or <code>Iterator</code> (which I use as my sync version of <code>Stream</code>)?</p>",
        "id": 167787143,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1560193798
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"127859\">@Taylor Cramer</span> I'm curious too - I've never seen <code>dyn Iterator</code>, <code>dyn Read</code>, or <code>dyn Write</code> before. Are async versions really used with dynamic dispatch?</p>",
        "id": 167787636,
        "sender_full_name": "stjepang",
        "timestamp": 1560194173
    },
    {
        "content": "<p>I've used all of those a bunch</p>",
        "id": 167787710,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1560194258
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116155\">@Jake Goulding</span> it isn't, but the same comments apply to <code>Read</code> and <code>Iterator</code></p>",
        "id": 167787726,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1560194279
    },
    {
        "content": "<p>those are used w/ dynamic dispatch very often</p>",
        "id": 167787781,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1560194301
    },
    {
        "content": "<p>Hmm. We must experience drastically different types of code, I suppose; I find dynamic dispatch relatively uncommon.</p>",
        "id": 167789428,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1560195537
    },
    {
        "content": "<p>However, it wouldn't surprise me if most functions took the generic and then certain classes of callers used the trait object</p>",
        "id": 167789470,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1560195558
    },
    {
        "content": "<p>a search for <code>&amp;mut Read</code> on github turns up a few thousand results, but I don't know how large that is by percentage</p>",
        "id": 167789777,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1560195759
    },
    {
        "content": "<p><a href=\"https://github.com/search?q=%22%26mut+Read%22+language%3ARust&amp;type=Code\" target=\"_blank\" title=\"https://github.com/search?q=%22%26mut+Read%22+language%3ARust&amp;type=Code\">https://github.com/search?q=%22%26mut+Read%22+language%3ARust&amp;type=Code</a></p>",
        "id": 167789778,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1560195759
    },
    {
        "content": "<p><code>Box&lt;Read&gt;</code> + <code>Box&lt;dyn Read&gt;</code> is only about 200</p>",
        "id": 167789841,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1560195811
    },
    {
        "content": "<p><code>Box&lt;Iterator</code> also gives a few thousand</p>",
        "id": 167789867,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1560195835
    },
    {
        "content": "<p><code>&amp;mut Iterator</code> is ~2k</p>",
        "id": 167789920,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1560195853
    },
    {
        "content": "<p>We encourage people to take the generics (e.g. <a href=\"https://rust-lang-nursery.github.io/api-guidelines/interoperability.html#generic-readerwriter-functions-take-r-read-and-w-write-by-value-c-rw-value\" target=\"_blank\" title=\"https://rust-lang-nursery.github.io/api-guidelines/interoperability.html#generic-readerwriter-functions-take-r-read-and-w-write-by-value-c-rw-value\">https://rust-lang-nursery.github.io/api-guidelines/interoperability.html#generic-readerwriter-functions-take-r-read-and-w-write-by-value-c-rw-value</a>) because it works for both cases.</p>",
        "id": 167795136,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1560199727
    },
    {
        "content": "<p>it also generates a heck of a lot more code ;)</p>",
        "id": 167795174,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1560199753
    },
    {
        "content": "<p>and doesn't work for heterogeneous collections</p>",
        "id": 167795195,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1560199771
    },
    {
        "content": "<p>hm, it should work with heterogeneous collections?</p>",
        "id": 167795288,
        "sender_full_name": "simulacrum",
        "timestamp": 1560199821
    },
    {
        "content": "<p>I've personally found trait objects to be extremely useful and would be concerned if we didn't have a story for them</p>",
        "id": 167795299,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1560199829
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> perhaps what I said was unclear: e.g. <code>HashMap&lt;u32, Box&lt;dyn Read&gt;&gt;</code> won't work with generics</p>",
        "id": 167795333,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1560199859
    },
    {
        "content": "<p>I dunno about \"a heck of a lot\" because I simply haven't done that investigation; can you point to any info I can read to have a sense of the magnitude?</p>",
        "id": 167795347,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1560199866
    },
    {
        "content": "<p>it only works due to trait objects</p>",
        "id": 167795348,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1560199869
    },
    {
        "content": "<p>Mostly I know about the format machinery, where the codegen was indeed too much</p>",
        "id": 167795363,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1560199892
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116155\">@Jake Goulding</span> I've personally changed a few functions in fuchsia to use trait objects rather than generics and dropped compilation times and binary size by more than 30%</p>",
        "id": 167795382,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1560199916
    },
    {
        "content": "<p><code>Box&lt;dyn Read&gt;</code> implements Read though so I'd sort of expect it to work...?</p>",
        "id": 167795432,
        "sender_full_name": "simulacrum",
        "timestamp": 1560199931
    },
    {
        "content": "<p>as far as more holistic samples, I know <span class=\"user-mention\" data-user-id=\"116015\">@Alex Crichton</span> has done some in the past</p>",
        "id": 167795436,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1560199935
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> to be clear, the <code>Box&lt;dyn Read&gt;</code> is exactly the piece I'm talking about</p>",
        "id": 167795446,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1560199947
    },
    {
        "content": "<p>you can't write <code>HashMap&lt;u32, Box&lt;impl Read&gt;&gt;</code></p>",
        "id": 167795452,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1560199959
    },
    {
        "content": "<p>and store multiple different <code>Read</code> types</p>",
        "id": 167795462,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1560199972
    },
    {
        "content": "<p>oh, yes, that's true -- but if you have R: Read you can always Box it (though you might end up with multiple levels of boxes, which is unfortunate)</p>",
        "id": 167795477,
        "sender_full_name": "simulacrum",
        "timestamp": 1560199984
    },
    {
        "content": "<p>Sure-- the point is that if <code>AsyncRead</code> wasn't object safe, then things like that wouldn't be possible</p>",
        "id": 167795496,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1560200011
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"127859\">@Taylor Cramer</span> How did that affect runtime performance? I don't know much about Fuchsia's target machines, are they binary-size limited?</p>",
        "id": 167795498,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1560200018
    },
    {
        "content": "<p>Ah, yes, that's true</p>",
        "id": 167795499,
        "sender_full_name": "simulacrum",
        "timestamp": 1560200019
    },
    {
        "content": "<p>Though you can sometimes work around it (e.g., create a \"fake\" object like we do with RawWaker IIRC)</p>",
        "id": 167795566,
        "sender_full_name": "simulacrum",
        "timestamp": 1560200047
    },
    {
        "content": "<p>And to be clear, I agree that <code>AsyncRead</code> will ideally be object-safe</p>",
        "id": 167795567,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1560200047
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116155\">@Jake Goulding</span> </p>\n<blockquote>\n<p>I don't know much about Fuchsia's target machines, are they binary-size limited?</p>\n</blockquote>\n<p>That's not something I can address publicly</p>",
        "id": 167795582,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1560200071
    },
    {
        "content": "<p>I was mostly investigating the \"critically important\" modifier</p>",
        "id": 167795597,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1560200084
    },
    {
        "content": "<p>Binary size is important</p>",
        "id": 167795611,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1560200097
    },
    {
        "content": "<p>In general sure, cause of cache sizes and all that.</p>",
        "id": 167795637,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1560200113
    },
    {
        "content": "<p>I'd expect that for most things were AsyncRead is worthwhile the async-ness is slow enough that the speed gained by generics would probably not be worth it? i.e., network is too slow</p>",
        "id": 167795644,
        "sender_full_name": "simulacrum",
        "timestamp": 1560200122
    },
    {
        "content": "<p>Like I said, I can't speak more specifically</p>",
        "id": 167795645,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1560200125
    },
    {
        "content": "<p>I didn't realize that part wasn't public, I apologize for asking.</p>",
        "id": 167795648,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1560200131
    },
    {
        "content": "<p>no worries! it's an annoying limitation of the world at present :)</p>",
        "id": 167795665,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1560200145
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> an interesting point about the expected usecases of the two traits.</p>",
        "id": 167795735,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1560200169
    },
    {
        "content": "<blockquote>\n<p>I'd expect that for most things were AsyncRead is worthwhile the async-ness is slow enough that the speed gained by generics would probably not be worth it? i.e., network is too slow</p>\n</blockquote>\n<p>somewhat, yes, although note that some of these usecases are things like \"pipe the data coming from a local socket to stdout\"</p>",
        "id": 167795761,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1560200202
    },
    {
        "content": "<p>stdout and such are likely either file i/o or terminal i/o or something like that I suspect so that seems like it'd just support the \"don't use generics\" argument</p>",
        "id": 167795803,
        "sender_full_name": "simulacrum",
        "timestamp": 1560200242
    },
    {
        "content": "<p>at the end of the day I haven't seen very many if any <code>AsyncRead</code> impls that would benefit greatly from being written with <code>async</code>/<code>await</code> such that they would outweigh the rest of these tradeoffs</p>",
        "id": 167795897,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1560200285
    },
    {
        "content": "<p>not including the limitations around what we can actually do with such a type in terms of storing the output future (which is not only nameless, but contains a lifetime parameter that can't be abstracted over due to current limitations of HRTB / GATs)</p>",
        "id": 167795933,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1560200327
    },
    {
        "content": "<p>and I doubt that many people would implement <code>AsyncRead</code> for their own custom types without the help of combinators</p>",
        "id": 167795968,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1560200358
    },
    {
        "content": "<p>(it's easy to allow <code>async { ... }</code> implementations of <code>AsyncRead</code> today with an intermediate combinator type)</p>",
        "id": 167795987,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1560200378
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> yup, they don't need to be crazy fast, but \"fast enough\" to be useful for things like file transfers</p>",
        "id": 167796112,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1560200441
    },
    {
        "content": "<p>sure, where the box probably won't matter I'd guess? i.e., LLVM still sees and optimizes both sides</p>",
        "id": 167796158,
        "sender_full_name": "simulacrum",
        "timestamp": 1560200485
    },
    {
        "content": "<p>mhm</p>",
        "id": 167796168,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1560200495
    },
    {
        "content": "<p>the only problem would be non-buffered file io, but that's slow regardless</p>",
        "id": 167796174,
        "sender_full_name": "simulacrum",
        "timestamp": 1560200505
    },
    {
        "content": "<p>yeah, we have AsyncBufReader and AsyncBufWriter for that</p>",
        "id": 167796239,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1560200531
    },
    {
        "content": "<p>My one gripe/concern with <code>Box&lt;dyn Trait&gt;</code> is that you want to be sure to use it everywhere</p>",
        "id": 167796262,
        "sender_full_name": "simulacrum",
        "timestamp": 1560200558
    },
    {
        "content": "<p>e.g. you don't want to have crate A which uses it, B which has T: Trait and C which has <code>Box&lt;dyn Trait&gt;</code> in a callchain since you'll end up with <code>Box&lt;Box&lt;dyn Trait&gt;&gt;</code> at the end</p>",
        "id": 167796306,
        "sender_full_name": "simulacrum",
        "timestamp": 1560200604
    },
    {
        "content": "<p>which is... two levels of pointer chasing?</p>",
        "id": 167796327,
        "sender_full_name": "simulacrum",
        "timestamp": 1560200622
    },
    {
        "content": "<p>yeah, it'd be great to have specialization around to help solve that one</p>",
        "id": 167797471,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1560201510
    },
    {
        "content": "<p>(you sort of want HKT here I think since ideally you'd also not constrain to Box and accept anything \"small\" but not have to double box and such)</p>",
        "id": 167797602,
        "sender_full_name": "simulacrum",
        "timestamp": 1560201624
    },
    {
        "content": "<p>though I'm not sure if HKT is the right thing, I'd need to do some more research to be sure.</p>",
        "id": 167797617,
        "sender_full_name": "simulacrum",
        "timestamp": 1560201654
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116155\">@Jake Goulding</span> </p>\n<blockquote>\n<p>How did that affect runtime performance? </p>\n</blockquote>\n<p>I realized I didn't address this part of your question-- it didn't at all, but that was particular to the specific place in which the change was made.</p>",
        "id": 167799414,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1560203119
    },
    {
        "content": "<p>Other parts of the codebase certainly rely on generics to avoid multiple levels of <code>Box</code>ing</p>",
        "id": 167799425,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1560203135
    },
    {
        "content": "<p>which would be performance-critical</p>",
        "id": 167799429,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1560203142
    },
    {
        "content": "<p>fwiw you can actually get around the double boxing bit on stable today if your type is 'static via Any</p>",
        "id": 167799483,
        "sender_full_name": "simulacrum",
        "timestamp": 1560203164
    },
    {
        "content": "<p>Good discussion! I think I might give a +1 to the idea of <span class=\"user-mention\" data-user-id=\"128448\">@stjepang</span> . The naming at least indicates that those are not \"real\" async types, but all handwritten ones.</p>\n<p>I agree that dynamic dispatch would be great to have! I don't have any performance concerns, since I've never experienced any important impact in the past (e.g. comparing boost asio with boxed types vs. templatized ones). The main concern I have is overhead due to dynamic allocations, but trait objects don't necessarily require dynamic allocations.</p>\n<p>However if I have to decide between the \"being able use trait objects\" and \"being able to implement types via async functions\" I think I would lean towards the latter.</p>",
        "id": 167816172,
        "sender_full_name": "Matthias247",
        "timestamp": 1560224152
    },
    {
        "content": "<p>I don't agree that one ever wants to implement <code>AsyncRead</code> (or: async byte streams in general) only manually and never through composition.<br>\nE.g. in my HTTP/2 library for .NET the Stream implementation (HTTP stream) conforms to a byte stream interface which is basically the equivalent of <code>AsyncRead + AsyncWrite</code>. Reading and writing data is purely implemented in terms of async functions that use async primitives (mutexes, semaphores, internal streams): <a href=\"https://github.com/Matthias247/http2dotnet/blob/master/Http2/StreamImpl.cs#L371-L480\" target=\"_blank\" title=\"https://github.com/Matthias247/http2dotnet/blob/master/Http2/StreamImpl.cs#L371-L480\">https://github.com/Matthias247/http2dotnet/blob/master/Http2/StreamImpl.cs#L371-L480</a></p>\n<p>That worked out pretty great, and I wouldn't want to write those things all in a manual fashion.</p>",
        "id": 167816352,
        "sender_full_name": "Matthias247",
        "timestamp": 1560224457
    },
    {
        "content": "<p>Or as an easier example: The Implementation of an async data pipe, which implements <code>AsyncRead</code> on one end and <code>AsyncWrite</code> on the other. This can be composed on top of a ringbuffer, a synchronous mutex and two async <code>ManualResetEvent</code>s and a two <code>async fns</code>. There is no need to manually touch or store a <code>Waker</code> and to manually implement <code>poll()</code>s</p>",
        "id": 167816514,
        "sender_full_name": "Matthias247",
        "timestamp": 1560224697
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"127859\">@Taylor Cramer</span> </p>\n<blockquote>\n<p>we could do something sorta clever like making the object returned the size of all the arguments to the function + alignment so that you could store them all in a struct and return that type to prevent having to heap-allocate for all the existing impls while retaining object safety</p>\n</blockquote>\n<p>I like the idea, but I think it can't be done based on the argument alone. The size of the returned <code>Future</code> is determined also be how much state will be on the \"stack\" of the <code>async fn</code>. And therefore an implementation which uses more \"stack\" won't fit in the preallocated space for a smaller object. we can probably determine some upper bounds through educated guesses and uses those. Then the functions might return something along <code>FixedBox&lt;Size=256&gt;(dyn Future)</code>. The downside is obviously that large futures won't fit, and for small ones we are wasting space.</p>\n<p>Maybe the compiler feature that would help on this is some kind of whole program analysis that inserts at compile-time the actually used number of bytes based on the biggest implementation of the trait that it encountered?</p>\n<p>We could also use a box which only allocates dynamically when a given size treshold was exceeded (like <a href=\"https://docs.rs/smallbox/0.7.3/smallbox/index.html\" target=\"_blank\" title=\"https://docs.rs/smallbox/0.7.3/smallbox/index.html\">https://docs.rs/smallbox/0.7.3/smallbox/index.html</a>), but that only seems to make the interface even more restricted and obscure while not solving the general case.</p>",
        "id": 167816978,
        "sender_full_name": "Matthias247",
        "timestamp": 1560225427
    },
    {
        "content": "<blockquote>\n<p>the major issue that cramertj mentions is that <code>async fn read</code> in a trait is actually sugar for an associated type + function (well, almost certainly going to be, once it's defined), once you have that associated type on the trait how do you deal with <code>dyn AsyncRead</code>?</p>\n</blockquote>\n<p>it feels like we need to solve this regardless</p>",
        "id": 167868999,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1560272389
    },
    {
        "content": "<p>In general, I agree with <span class=\"user-mention\" data-user-id=\"127859\">@Taylor Cramer</span> that trait objects are often underused, especially at system boundaries.</p>",
        "id": 168041774,
        "sender_full_name": "Florian Gilcher",
        "timestamp": 1560430633
    },
    {
        "content": "<p>There's another interesting issue that came up yesterday: There's a pretty trivial implementation of <code>Read/Write</code> for <code>AsyncRead/AsyncWrite</code> in futures compat, but it relies on the context being task local and retrievable via <code>Current</code>: <a href=\"https://rust-lang-nursery.github.io/futures-api-docs/0.3.0-alpha.9/futures/compat/struct.Compat.html#impl-Read\" target=\"_blank\" title=\"https://rust-lang-nursery.github.io/futures-api-docs/0.3.0-alpha.9/futures/compat/struct.Compat.html#impl-Read\">https://rust-lang-nursery.github.io/futures-api-docs/0.3.0-alpha.9/futures/compat/struct.Compat.html#impl-Read</a></p>",
        "id": 168053617,
        "sender_full_name": "Florian Gilcher",
        "timestamp": 1560438300
    },
    {
        "content": "<p>Now, that implementation is quite useful, e.g. to bridge the gap to native-tls and such. Is there a good way to implement this using the new futures?</p>",
        "id": 168053618,
        "sender_full_name": "Florian Gilcher",
        "timestamp": 1560438300
    },
    {
        "content": "<p>Personally I think we need to think about the implicit contexts via compiler/language mechanism, not TLS, that <span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> and a few others have talked about -- it'd be useful for this sort of \"I need global-ish state in a bunch of functions\" type thing, such as TyCtxt and Session in the compiler formatting infrastructure etc</p>",
        "id": 168054090,
        "sender_full_name": "simulacrum",
        "timestamp": 1560438614
    },
    {
        "content": "<p>I think I've heard that some language has this? Maybe .. Racket, but not sure</p>",
        "id": 168054105,
        "sender_full_name": "simulacrum",
        "timestamp": 1560438628
    },
    {
        "content": "<p>Not sure, but I'd actually be interested, as someone who works in fields where \"per request\" context is a big thing.</p>",
        "id": 168058277,
        "sender_full_name": "Florian Gilcher",
        "timestamp": 1560441355
    },
    {
        "content": "<p>That's long-term, though, but the question was more if there's a halfway elegant solution with what we have.</p>",
        "id": 168058354,
        "sender_full_name": "Florian Gilcher",
        "timestamp": 1560441403
    },
    {
        "content": "<p><a href=\"https://github.com/PistonDevelopers/dyon/issues/224\" target=\"_blank\" title=\"https://github.com/PistonDevelopers/dyon/issues/224\">https://github.com/PistonDevelopers/dyon/issues/224</a> is basically what I was talking about but I think that's inspired by some other language</p>",
        "id": 168058914,
        "sender_full_name": "simulacrum",
        "timestamp": 1560441794
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> my ideas are mostly that of eternaleye, FWIW, so you might want to get a hold of him (are you on IRC? Freenode, specifically)</p>",
        "id": 168080327,
        "sender_full_name": "eddyb",
        "timestamp": 1560456363
    },
    {
        "content": "<p>I could try to get him in here, hmpf</p>",
        "id": 168080379,
        "sender_full_name": "eddyb",
        "timestamp": 1560456383
    },
    {
        "content": "<p>Not currently but can be in a week or so (currently in the process of moving, so servers/internet are a bit up in the air)</p>",
        "id": 168080397,
        "sender_full_name": "simulacrum",
        "timestamp": 1560456404
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> I think you might be referring to something like implicits in Scala or a language-assisted dependency-injection mechanism in general. For Kotlin this one was recently proposed: <a href=\"https://github.com/Kotlin/KEEP/blob/46e6a347432d868635e9c6161ca332581315b185/proposals/compile-time-dependency-resolution.md\" target=\"_blank\" title=\"https://github.com/Kotlin/KEEP/blob/46e6a347432d868635e9c6161ca332581315b185/proposals/compile-time-dependency-resolution.md\">https://github.com/Kotlin/KEEP/blob/46e6a347432d868635e9c6161ca332581315b185/proposals/compile-time-dependency-resolution.md</a></p>\n<p>Dependency injection mechanisms are definitely helpful to cleanup the amount of require boilerplate. However I think of those as mostly a helpful thing and not a must-have. People should be able to write the same code by manually threading through all required arguments too, which involves less magic and has less compatibility issues.</p>",
        "id": 168104015,
        "sender_full_name": "Matthias247",
        "timestamp": 1560483277
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"204219\">@Matthias247</span> I don't think that's quite the right feature -- and sometimes you can't ergonomically thread the argument through into e.g. a fmt::Display/fmt::Debug impl</p>",
        "id": 168136930,
        "sender_full_name": "simulacrum",
        "timestamp": 1560520619
    },
    {
        "content": "<p>and AIUI this feature would have less overhead than e.g. storing the value in structs since we'd not be using stack space for it -- the compiler would point at some top-level stack frame with the value where it knows a pointer to it or the value itself is</p>",
        "id": 168137028,
        "sender_full_name": "simulacrum",
        "timestamp": 1560520702
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"215333\">@Florian Gilcher</span> that actually sounds similar to what <a href=\"https://www.reddit.com/r/rust/comments/c08178/openssl_async_adapter/\" target=\"_blank\" title=\"https://www.reddit.com/r/rust/comments/c08178/openssl_async_adapter/\">https://www.reddit.com/r/rust/comments/c08178/openssl_async_adapter/</a> is using</p>",
        "id": 168148614,
        "sender_full_name": "Nemo157",
        "timestamp": 1560528567
    },
    {
        "content": "<p>But via explicit adaptor fields rather than implicit context</p>",
        "id": 168148651,
        "sender_full_name": "Nemo157",
        "timestamp": 1560528600
    }
]