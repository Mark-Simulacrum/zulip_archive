[
    {
        "content": "<p>Who remembers the rationale for the current approach of putting async APIs behind top-level modules like <code>std::future</code> and <code>std::task</code>?</p>\n<p>As we're talking about <a href=\"https://github.com/rust-lang/rfcs/pull/3208\">renaming <code>std::stream::Stream</code> to <code>std::async_iter::AsyncIterator</code></a> I'm thinking about how many other modules like this will be introduced (I/O traits, executor traits, and so on) and wondering if we shouldn't have a central \"entry point\" for finding all of them in the module hierarchy itself.</p>",
        "id": 264964236,
        "sender_full_name": "tmandry",
        "timestamp": 1639542557
    },
    {
        "content": "<p>Personally I would love it if we could do this:</p>\n<ul>\n<li><code>std::async::iter::AsyncIterator</code> - predictable naming for async things that have analogues in the sync world</li>\n<li><code>std::async::task::Task</code> - discoverability for things that <em>don't</em> have direct analogues, using the path to make it more obvious what they're <em>for</em></li>\n</ul>\n<p>But of course we can't now due to async being a keyword (and it might not even be possible to allow, though I don't actually see why not).</p>",
        "id": 264964671,
        "sender_full_name": "tmandry",
        "timestamp": 1639542974
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116883\">@tmandry</span> General <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span> for putting most things into a common module hierarchy, but I do think there's value in not having a single module for things that on the sync side would be in multiple places.</p>",
        "id": 264965744,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639544119
    },
    {
        "content": "<p>For instance, I/O is in <code>std::io</code>, and filesystem stuff is in <code>std::fs</code>, and process stuff is in <code>std::process</code>, and I don't think the async equivalents should all be in the same module.</p>",
        "id": 264965802,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639544166
    },
    {
        "content": "<p>So what I'm wondering is if we should have <code>std::async::io</code> and <code>std::async::fs</code> and so on</p>",
        "id": 264965830,
        "sender_full_name": "tmandry",
        "timestamp": 1639544225
    },
    {
        "content": "<p>(You could even imagine inverting the order.. <code>std::io::async</code>.. but that advantages discovering \"there is an async version of this thing\" over discovering \"here are all the things you can do with async\")</p>",
        "id": 264965917,
        "sender_full_name": "tmandry",
        "timestamp": 1639544321
    },
    {
        "content": "<p>+1 for std::async::io etc, however, we have already stabilised at least std::future, so not everything async will be in std::async</p>",
        "id": 264989794,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1639564502
    },
    {
        "content": "<p>not sure how/if that affects the consistency argument</p>",
        "id": 264989823,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1639564513
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256841\">@Nick Cameron</span> we could have a re-export to fix that consistency issue</p>",
        "id": 264994994,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1639567193
    },
    {
        "content": "<p>FWIW, I'd love to have an (opt-in) <code>async</code> prelude. <em>e.g.</em>, having to refer to three distinct modules in:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code>::<span class=\"n\">core</span>::<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">future</span>::<span class=\"n\">Future</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">marker</span>::<span class=\"n\">PhantomPinned</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">pin</span>::<span class=\"n\">Pin</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>\n<p>seems quite silly every time I write it <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 264995443,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1639567414
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232018\">Daniel Henry-Mantilla</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/Paths.20of.20async.20APIs.20in.20std/near/264994994\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> we could have a re-export to fix that consistency issue</p>\n</blockquote>\n<p>True! It would still be a bit messy, but perhaps worth it for a long-term better scenario</p>",
        "id": 264996130,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1639567790
    },
    {
        "content": "<p>There's also the question of async overloading, which would let everything stay where it is now.</p>",
        "id": 265003783,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1639572238
    },
    {
        "content": "<p>Yeah, ideally we could follow Swift's example and expose the same APIs for both async and non-async Rust from their existing locations. <span class=\"user-mention\" data-user-id=\"256841\">@Nick Cameron</span> and I talked about taking a closer look at the feasibility of <a href=\"https://blog.yoshuawuyts.com/async-overloading/\">async overloading</a> to hopefully provide some more clarity on this.</p>",
        "id": 265587250,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1640018637
    },
    {
        "content": "<p>+1 to consolidating the hierarchy; I'm not sure about having the overloaded API or not, though it is definitely appealing</p>",
        "id": 265587601,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1640018787
    },
    {
        "content": "<p>Coming from Node.js which has both <a href=\"https://nodejs.org/docs/latest-v15.x/api/fs.html\"><code>fs.readdir</code> and <code>fs.readdirSync</code></a>-style  duplicates <em>everywhere</em>, if we could avoid that type of split in the stdlib it would be incredible.</p>",
        "id": 265587627,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1640018798
    },
    {
        "content": "<p>On the one hand, the idea of being able to just use <code>std::fs::FIle</code> sounds interesting and handy. On the other hand, I'm having a hard time imagining how we could reasonably do that without introducing issues. Sometimes you want to reference a sync API from an async function or vice versa. And conversely, how would we catch errors? If you forget the <code>.await</code>, does that mean you want the sync API or that you want the async API but forgot the <code>.await</code>?</p>",
        "id": 265599067,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640024275
    },
    {
        "content": "<p>I'm rather tempted to have a parallel hierarchy, like <code>async::fs::File</code> (modulo keywordiness).</p>",
        "id": 265599196,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640024328
    },
    {
        "content": "<p>I suppose it's possible to have both <code>sync</code> and <code>async</code> parallel hierarchies, and to have the default ones resolve based on where they're used.</p>",
        "id": 265599839,
        "sender_full_name": "tmandry",
        "timestamp": 1640024689
    },
    {
        "content": "<p>though we may want a more general convenient way to force sync/async resolution than with module hierarchies</p>",
        "id": 265600156,
        "sender_full_name": "tmandry",
        "timestamp": 1640024867
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/Paths.20of.20async.20APIs.20in.20std/near/265599067\">said</a>:</p>\n<blockquote>\n<p>Sometimes you want to reference a sync API from an async function or vice versa.</p>\n</blockquote>\n<p>Maybe if we support async overloading we also need to include something like a <code>sync { ... }</code> block that explicitly marks a section of code as sync.</p>",
        "id": 265609836,
        "sender_full_name": "eholk",
        "timestamp": 1640030671
    },
    {
        "content": "<p>Or closures?</p>",
        "id": 265610690,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640031231
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">bar</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">spawn_blocking</span><span class=\"p\">(</span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">())</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 265610756,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640031258
    },
    {
        "content": "<p>I would expect this to resolve to the sync version of <code>foo</code>.</p>",
        "id": 265610780,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640031270
    },
    {
        "content": "<p>Not that I know why you would ever want to use the sync version over the async version.</p>",
        "id": 265610873,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640031351
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">bar</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 265610943,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640031389
    },
    {
        "content": "<p>Would both use the async version then.</p>",
        "id": 265610950,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640031396
    },
    {
        "content": "<p>So then the rules would be:</p>\n<ul>\n<li>In a sync fn/closure: sync version</li>\n<li>In a async fn/closure/block: async version</li>\n</ul>",
        "id": 265611515,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640031779
    },
    {
        "content": "<p>I think that would work.</p>",
        "id": 265611563,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640031809
    },
    {
        "content": "<p>That would effectively be adopting the \"implicit await\" proposal from a while back.</p>",
        "id": 265623401,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640039314
    },
    {
        "content": "<p>I think all the discussion points raised during that proposal would apply.</p>",
        "id": 265623421,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640039340
    },
    {
        "content": "<blockquote>\n<p>That would effectively be adopting the \"implicit await\" proposal from a while back.</p>\n</blockquote>\n<p>How so?</p>",
        "id": 265624128,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640039853
    },
    {
        "content": "<p>There's no implicit await here</p>",
        "id": 265624135,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640039861
    },
    {
        "content": "<p>You just have to enter an async context to call the async version of the function.</p>",
        "id": 265624221,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640039929
    },
    {
        "content": "<p>Which, in a sync function, means wrapping the call in an async block/closure</p>",
        "id": 265624243,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640039950
    },
    {
        "content": "<p>You still have to await the async block to run the future</p>",
        "id": 265624258,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640039963
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"363998\">@Ibraheem Ahmed</span> OK, then just part of that proposal. But still: that means you can't call <code>async_func()</code> to get a future, in a sync function, then <em>pass</em> that future to an async context.</p>",
        "id": 265624389,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640040047
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// sync context</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">fut</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">async_func</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"n\">work_with_future</span><span class=\"p\">(</span><span class=\"n\">fut</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 265624550,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640040163
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// sync context</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">fut</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">func</span><span class=\"p\">().</span><span class=\"k\">await</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"n\">work_with_future</span><span class=\"p\">(</span><span class=\"n\">fut</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 265624575,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640040192
    },
    {
        "content": "<p>Oh, sorry, maybe the confusion is from my example.</p>",
        "id": 265624592,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640040212
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"363998\">@Ibraheem Ahmed</span> I realize that's <em>possible</em>, but that's the same kind of problem that existed in the implicit-await proposal.</p>",
        "id": 265624593,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640040218
    },
    {
        "content": "<p>It should be <code>async || foo().await</code>, not <code>async || foo()</code></p>",
        "id": 265624601,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640040226
    },
    {
        "content": "<p>The failure mode here goes from \"you called an async function in a sync context and that doesn't work\" to \"you called an async function in a sync context so it did an unexpected sync thing instead\".</p>",
        "id": 265624679,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640040254
    },
    {
        "content": "<p>Well in a sync context, the default is calling the sync thing. If you expected to call the async thing and get a future, then somewhere down the line you will get a type error <code>Expected impl Future&lt;Output = T&gt;, found T</code></p>",
        "id": 265624763,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640040336
    },
    {
        "content": "<p>And I think that's fine.</p>",
        "id": 265624768,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640040348
    },
    {
        "content": "<p>Interesting point.</p>",
        "id": 265624776,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640040354
    },
    {
        "content": "<p>In the interests of fairness, I should also note that a <em>similar</em> failure mode applies to accidentally calling the sync version of an async function, even if it has a different path; after all, you could accidentally call <code>std::fs::File</code> instead of <code>std::async::fs::File</code> or equivalent, especially if you have imports such that that's just <code>fs::File</code> or <code>File</code> and you don't realize it's the wrong one.</p>",
        "id": 265624828,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640040377
    },
    {
        "content": "<p>I would also note that <code>async { async_func().await }</code> seems excessively verbose compared to <code>async_func()</code>, especially if you need to do it more than once for different futures, such as if you're calling <code>or</code> or similar.</p>",
        "id": 265624904,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640040435
    },
    {
        "content": "<p>Comparison:</p>",
        "id": 265624917,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640040447
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">fut</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">or</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">async_func1</span><span class=\"p\">().</span><span class=\"k\">await</span><span class=\"w\"> </span><span class=\"p\">},</span><span class=\"w\"> </span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">async_func2</span><span class=\"p\">().</span><span class=\"k\">await</span><span class=\"w\"> </span><span class=\"p\">});</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 265624943,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640040473
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">fut</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">or</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">async_func1</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">async_func2</span><span class=\"p\">());</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 265625002,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640040495
    },
    {
        "content": "<p>Well, you just have to enter an async context.</p>",
        "id": 265625016,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640040513
    },
    {
        "content": "<p>Every future doesn't have to be wrapped in an individual async block.</p>",
        "id": 265625039,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640040526
    },
    {
        "content": "<p>I suppose you could <em>also</em> spell that as:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">fut</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">or</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">async_func1</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">async_func2</span><span class=\"p\">()).</span><span class=\"k\">await</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 265625046,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640040537
    },
    {
        "content": "<p>Yeah</p>",
        "id": 265625048,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640040540
    },
    {
        "content": "<p>I don't think that's too bad.</p>",
        "id": 265625065,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640040554
    },
    {
        "content": "<p>That still feels like a verbose cost to impose, just so that we can do async overloading.</p>",
        "id": 265625081,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640040564
    },
    {
        "content": "<p>Plus, it adds to the context-sensitivity of the language, versus having a given path just be a given function.</p>",
        "id": 265625108,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640040597
    },
    {
        "content": "<p><code>async</code> as a call-site modifier is also an option.</p>",
        "id": 265625403,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640040729
    },
    {
        "content": "<p>I know that was discussed a lot during the async/await bikeshed.</p>",
        "id": 265625415,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640040739
    },
    {
        "content": "<p>Along the lines of <code>async f()</code> rather than <code>async { f().await }</code>?</p>",
        "id": 265625431,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640040752
    },
    {
        "content": "<p>It's also what Zig does for their \"colourless async\"</p>",
        "id": 265625438,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640040759
    },
    {
        "content": "<p>Yeah</p>",
        "id": 265625441,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640040762
    },
    {
        "content": "<p>Do you mean <em>everywhere</em>, or everywhere that's not in an async context already?</p>",
        "id": 265625472,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640040785
    },
    {
        "content": "<p>(and in the latter case, wouldn't we also need a sync modifier?)</p>",
        "id": 265625483,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640040793
    },
    {
        "content": "<p>Well, I think it is probably too late for <em>everywhere</em> :)</p>",
        "id": 265625525,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640040832
    },
    {
        "content": "<p>I think <em>everywhere</em> would also be an even more verbose cost.</p>",
        "id": 265625599,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640040876
    },
    {
        "content": "<p>True</p>",
        "id": 265625607,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640040882
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">fut</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"n\">or</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">async_func1</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">async_func2</span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"c1\">// =&gt; let fut = async { or!(async_func1(), async_func2()).await };</span>\n</code></pre></div>",
        "id": 265625641,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640040908
    },
    {
        "content": "<p>To be fair the cost of the async wrapping is only imposed on the odd case.</p>",
        "id": 265625678,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640040939
    },
    {
        "content": "<p>For <em>most</em> users, it would ideally \"just work\"</p>",
        "id": 265625779,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640041007
    },
    {
        "content": "<p>There's already an extra cost to do things like setup work before returning a future.</p>",
        "id": 265625827,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640041051
    },
    {
        "content": "<p>Where the default async/await semantics don't quite work.</p>",
        "id": 265625939,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640041107
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">b</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">a</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span> <span class=\"kt\">str</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">b</span> <span class=\"kt\">str</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"n\">Future</span><span class=\"o\">&lt;</span><span class=\"n\">Output</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">()</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">b</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 265626030,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640041175
    },
    {
        "content": "<p>On that tangent: <a href=\"https://docs.rs/async_fn/0.0.2/async_fn/macro.before_async.html#eager-vs-lazy--suspended-code\">https://docs.rs/async_fn/0.0.2/async_fn/macro.before_async.html#eager-vs-lazy--suspended-code</a></p>",
        "id": 265635357,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1640048412
    }
]