[
    {
        "content": "<p>Do you think <code>std::future::join!</code> requires an RFC or could I just PR it?</p>",
        "id": 264059800,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1638905938
    },
    {
        "content": "<p>The variadic version</p>",
        "id": 264059876,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1638905973
    },
    {
        "content": "<p>I think an unstable version could just be a PR with an r+ or <em>at most</em> an FCP.</p>",
        "id": 264060331,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638906144
    },
    {
        "content": "<p>Aren't macros insta-stable?</p>",
        "id": 264060839,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1638906358
    },
    {
        "content": "<p>Oh, hmmm. For some reason I thought it was possible to have an unstable macro. If it's not then yeah, it'd need <em>at least</em> an FCP if not an RFC.</p>",
        "id": 264061101,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638906458
    },
    {
        "content": "<p>It looks like <code>#[unstable</code> can be applied to <code>macro_rules!</code>.</p>",
        "id": 264061286,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638906525
    },
    {
        "content": "<p>Oh I was under the impression that it couldn't</p>",
        "id": 264061345,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1638906548
    },
    {
        "content": "<p><code>library/stdarch/crates/std_detect/src/detect/error_macros.rs</code></p>",
        "id": 264061427,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638906580
    },
    {
        "content": "<p>I think it would be a proc-macro though</p>",
        "id": 264061437,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1638906586
    },
    {
        "content": "<p>It's possible to write as a macro_rules! macro, though it might not be the most efficient implementation.</p>",
        "id": 264061542,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638906624
    },
    {
        "content": "<p>I don't think it affects efficiency</p>",
        "id": 264061595,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1638906659
    },
    {
        "content": "<p><a href=\"https://docs.rs/tokio/latest/src/tokio/macros/join.rs.html#57-119\">https://docs.rs/tokio/latest/src/tokio/macros/join.rs.html#57-119</a></p>",
        "id": 264061761,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1638906729
    },
    {
        "content": "<p>Ah so it looks like decl macros 1.0 were insta-stable, but 2.0s aren't</p>",
        "id": 264061905,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1638906795
    },
    {
        "content": "<p>A decl macro implementation would have to be recursive</p>",
        "id": 264062004,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1638906833
    },
    {
        "content": "<p>That doesn't seem like a critical issue; it seems unlikely to call <code>join!(...)</code> on thousands of arguments.</p>",
        "id": 264062141,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638906880
    },
    {
        "content": "<p>Can macros 2.0 currently use private items in the expansion?</p>",
        "id": 264063808,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1638907538
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#![feature(decl_macro)]</span><span class=\"w\"></span>\n\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">mod</span> <span class=\"nn\">foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"kr\">macro</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">Foo</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">mod</span> <span class=\"nn\">bar</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">bar</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">crate</span>::<span class=\"n\">foo</span>::<span class=\"n\">foo</span><span class=\"o\">!</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 264086466,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1638918145
    },
    {
        "content": "<p>Is this supposed to work?</p>",
        "id": 264086479,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1638918150
    },
    {
        "content": "<p>It's not right now</p>",
        "id": 264086545,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1638918185
    },
    {
        "content": "<p>The macro needs access to a <code>MaybeDone</code> type that stores the output of the future until all of them are done</p>",
        "id": 264086587,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1638918209
    },
    {
        "content": "<p>I guess it could generate the code for that with an extra tuple of options...</p>",
        "id": 264086928,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1638918407
    },
    {
        "content": "<p>Doing that way</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">join</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Becomes</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">outputs</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nb\">None</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"w\">        </span><span class=\"c1\">// === EXTRA BECAUSE NO `MaybeDone` ===</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">futures</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">fut</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">done</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kc\">false</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"n\">poll_fn</span><span class=\"p\">(</span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">cx</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">done</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                        </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">Poll</span>::<span class=\"n\">Ready</span><span class=\"p\">(());</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">Pin</span>::<span class=\"n\">new_unchecked</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">fut</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}.</span><span class=\"n\">poll</span><span class=\"p\">(</span><span class=\"n\">cx</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                        </span><span class=\"n\">Poll</span>::<span class=\"n\">Ready</span><span class=\"p\">(</span><span class=\"n\">val</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">out</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">outputs</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">                            </span><span class=\"o\">*</span><span class=\"n\">out</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">val</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">                            </span><span class=\"n\">done</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kc\">true</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">                            </span><span class=\"n\">Poll</span>::<span class=\"n\">Ready</span><span class=\"p\">(())</span><span class=\"w\"></span>\n<span class=\"w\">                        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">                        </span><span class=\"n\">Poll</span>::<span class=\"n\">Pending</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Poll</span>::<span class=\"n\">Pending</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"p\">})</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">},</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">fut</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">done</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kc\">false</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"n\">poll_fn</span><span class=\"p\">(</span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">cx</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">done</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                        </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">Poll</span>::<span class=\"n\">Ready</span><span class=\"p\">(());</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">Pin</span>::<span class=\"n\">new_unchecked</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">fut</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}.</span><span class=\"n\">poll</span><span class=\"p\">(</span><span class=\"n\">cx</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                        </span><span class=\"n\">Poll</span>::<span class=\"n\">Ready</span><span class=\"p\">(</span><span class=\"n\">val</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">out</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">outputs</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">                            </span><span class=\"o\">*</span><span class=\"n\">out</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">val</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">                            </span><span class=\"n\">done</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kc\">true</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">                            </span><span class=\"n\">Poll</span>::<span class=\"n\">Ready</span><span class=\"p\">(())</span><span class=\"w\"></span>\n<span class=\"w\">                        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">                        </span><span class=\"n\">Poll</span>::<span class=\"n\">Pending</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Poll</span>::<span class=\"n\">Pending</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"p\">})</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">},</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// == END EXTRA ==</span>\n\n<span class=\"w\">        </span><span class=\"n\">poll_fn</span><span class=\"p\">(</span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">cx</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">done</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kc\">true</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">fut</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">futures</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">done</span><span class=\"w\"> </span><span class=\"o\">&amp;=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">Pin</span>::<span class=\"n\">new_unchecked</span><span class=\"p\">(</span><span class=\"n\">fut</span><span class=\"p\">).</span><span class=\"n\">poll</span><span class=\"p\">(</span><span class=\"n\">cx</span><span class=\"p\">).</span><span class=\"n\">is_ready</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">fut</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">futures</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">done</span><span class=\"w\"> </span><span class=\"o\">&amp;=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">Pin</span>::<span class=\"n\">new_unchecked</span><span class=\"p\">(</span><span class=\"n\">fut</span><span class=\"p\">).</span><span class=\"n\">poll</span><span class=\"p\">(</span><span class=\"n\">cx</span><span class=\"p\">).</span><span class=\"n\">is_ready</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">done</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"n\">Poll</span>::<span class=\"n\">Ready</span><span class=\"p\">((</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">val</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">outputs</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">                        </span><span class=\"n\">val</span><span class=\"p\">.</span><span class=\"n\">unwrap</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"p\">},</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">outputs</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">                        </span><span class=\"n\">val</span><span class=\"p\">.</span><span class=\"n\">unwrap</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"p\">))</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"n\">Poll</span>::<span class=\"n\">Pending</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">})</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">.</span><span class=\"k\">await</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 264088646,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1638919408
    },
    {
        "content": "<p>Is that unreasonable?</p>",
        "id": 264088777,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1638919470
    },
    {
        "content": "<p>That actually wouldn't work either, both the inner futures and the outer future need mutable access the the outputs</p>",
        "id": 264094428,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1638922537
    },
    {
        "content": "<p>I can't think of a good way to do this without adding a <code>MaybeDone</code> type to std.</p>",
        "id": 264095205,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1638923075
    },
    {
        "content": "<p>Scratch that, I got it working</p>",
        "id": 264101133,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1638928290
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/pull/91645\">https://github.com/rust-lang/rust/pull/91645</a></p>",
        "id": 264101946,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1638929060
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"363998\">Ibraheem Ahmed</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/join!/near/264086479\">said</a>:</p>\n<blockquote>\n<p>Is this supposed to work?</p>\n</blockquote>\n<p>There is a difference between <em>path</em> privacy and inherent <em>type</em> privacy. Your <code>Foo</code> there is type-private, but a <code>mod private { pub struct Foo; }</code> wouldn't. With the latter your <code>macro</code> approach would work, since proper hygiene is able to use the <em>path</em> privacy of the macro definition site, which in this instance would be able to access <code>private::Foo</code>.</p>",
        "id": 264149149,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1638967479
    },
    {
        "content": "<p>(This should sound very similar to trait-sealing requiring a <code>mod private { pub trait … }</code> rather than a non-<code>pub</code> <code>trait …</code>)</p>",
        "id": 264149253,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1638967532
    },
    {
        "content": "<p>Ah okay, that makes sense</p>",
        "id": 264151130,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1638968552
    },
    {
        "content": "<p>Thanks</p>",
        "id": 264151135,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1638968555
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> Do you think the return type of <code>join!</code> should be exposed publicly?</p>",
        "id": 264224127,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1638999360
    },
    {
        "content": "<p>I think it'd be fine for the <em>logical</em> return type of <code>join!</code> to be <code>impl Future</code>, personally.</p>",
        "id": 264224251,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638999404
    },
    {
        "content": "<p>So in short, no.</p>",
        "id": 264224277,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638999410
    },
    {
        "content": "<p>Ready for review :)</p>",
        "id": 264229409,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1639001978
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"363998\">@Ibraheem Ahmed</span> Looks good to me. I'm going to go ahead and approve.</p>",
        "id": 264253158,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639021461
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"363998\">@Ibraheem Ahmed</span> One thought that crosses my mind: since it's a macro, and it does <code>async move</code> in the expansion, is there any possibility that it could unintentionally move something the caller owned and expected to be borrowed?</p>",
        "id": 264253183,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639021501
    },
    {
        "content": "<p>I <em>think</em> it can't, but I don't fully know if <code>async move</code> has the right semantics for any possible macro argument.</p>",
        "id": 264253208,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639021532
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/join!/near/264253183\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"363998\">Ibraheem Ahmed</span> One thought that crosses my mind: since it's a macro, and it does <code>async move</code> in the expansion, is there any possibility that it could unintentionally move something the caller owned and expected to be borrowed?</p>\n</blockquote>\n<p>Yeah I thought of that too, I added a basic test for an explicit borrow <a href=\"https://github.com/rust-lang/rust/blob/5478f439e13b55c7b9b858f76986786371b97c8f/library/core/tests/future.rs#L57\">https://github.com/rust-lang/rust/blob/5478f439e13b55c7b9b858f76986786371b97c8f/library/core/tests/future.rs#L57</a>.</p>",
        "id": 264254077,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1639022443
    },
    {
        "content": "<p>To remove any uncertainty  it could return something like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">JoinFut</span><span class=\"o\">&lt;</span><span class=\"n\">FutTuple</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">PollFn</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">FutTuple</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">PollFn</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 264254231,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1639022597
    },
    {
        "content": "<p>That's actually why I was asking about publicly exposing the return type</p>",
        "id": 264254345,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1639022698
    },
    {
        "content": "<p>Although I guess leaving <code>JoinFut</code> public but unexported would work with macro hygiene right?</p>",
        "id": 264254403,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1639022757
    },
    {
        "content": "<p>I'm not actually sure what macros can get away with.</p>",
        "id": 264261603,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639030828
    },
    {
        "content": "<p>I <em>think</em> if a macro constructs it, it might actually have to be a public type.</p>",
        "id": 264261608,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639030839
    },
    {
        "content": "<p>Can we send PRs to futures-rs and other runtimes to re-export the std version rather than using their own?</p>",
        "id": 264283626,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1639047103
    },
    {
        "content": "<p>Wow, that was merged so fast! Faster than I could review <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span> </p>\n<ul>\n<li>I'd have expected the creator of <code>.ready()?</code> to use that in their own PR <span aria-label=\"stuck out tongue\" class=\"emoji emoji-1f61b\" role=\"img\" title=\"stuck out tongue\">:stuck_out_tongue:</span> </li>\n<li>\n<p>More seriously, there is an important (classic) issue with macros, that the arguments are not pre-evaluated. This will indeed cause trouble with the <code>async move</code> (<em>e.g.</em>, <code>join!(static_future(&amp;thing), …)</code> will consume ownership of <code>thing</code>) as well as when doing, say, <code>join!(maybe_fut?, …)</code>.</p>\n</li>\n<li>\n<p>Unit tests for those cases ought to be added as well</p>\n</li>\n</ul>\n<p>So it should be doing:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"w\"> </span><span class=\"cp\">$(</span><span class=\"w\"> </span><span class=\"n\">MaybeDone</span>::<span class=\"n\">Future</span><span class=\"p\">(</span><span class=\"cp\">$fut</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">futures</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// …</span>\n<span class=\"p\">}}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>(<em>c.f.</em> the <code>$_:value</code> matcher pre-RFC to avoid this kind of pitfalls)</p>",
        "id": 264293660,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1639053224
    },
    {
        "content": "<p>(neat <code>(_, _, … _, var, ..)</code> trick, though <span aria-label=\"ok\" class=\"emoji emoji-1f44c\" role=\"img\" title=\"ok\">:ok:</span>)</p>",
        "id": 264293774,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1639053270
    },
    {
        "content": "<p>We can and should iterate before stabilising, so please file issues or send PRs <span aria-label=\"heart\" class=\"emoji emoji-2764\" role=\"img\" title=\"heart\">:heart:</span>️</p>",
        "id": 264294261,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1639053532
    },
    {
        "content": "<blockquote>\n<p>I'd have expected the creator of .ready()? to use that in their own PR</p>\n</blockquote>\n<p>Oh right I could have enabled the feature in core <span aria-label=\"smiley\" class=\"emoji emoji-1f603\" role=\"img\" title=\"smiley\">:smiley:</span></p>",
        "id": 264297186,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1639055015
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/join!/near/264283626\">said</a>:</p>\n<blockquote>\n<p>Can we send PRs to futures-rs and other runtimes to re-export the std version rather than using their own?</p>\n</blockquote>\n<p>Once it's stable in their MSRV....</p>",
        "id": 264297332,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1639055093
    },
    {
        "content": "<p>Urgh, I hate MSRV :-(</p>",
        "id": 264297550,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1639055206
    },
    {
        "content": "<p>Can we cfg on version or channel? I fear that we won't get momentum for people to change to use the std version without the runtimes changing, and without that we won't get the experience we need to stabilise</p>",
        "id": 264297808,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1639055368
    },
    {
        "content": "<p>Maybe in <code>futures</code> and <code>async-std</code>, but tokio has strict stability guarantees</p>",
        "id": 264298340,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1639055601
    },
    {
        "content": "<p>The std version doesn't implicitly .await, so it would be a breaking change</p>",
        "id": 264298355,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1639055617
    },
    {
        "content": "<blockquote>\n<p>The Tokio 1.0 release ends this churn. As part of the release, we are committing to providing a stable foundation for the ecosystem. We have no current plans for Tokio 2.0 and we commit to holding back on a Tokio 2.0 release for at least 3 years. We plan to maintain the Tokio 1.0 branch for a minimum of 5 years. Tokio will keep a rolling MSRV (minimum supported rust version) policy of 6 months. When increasing the MSRV, the new Rust version must have been released at least six months ago.</p>\n</blockquote>",
        "id": 264298521,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1639055671
    },
    {
        "content": "<p>:(</p>",
        "id": 264298537,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1639055684
    },
    {
        "content": "<p>Yeah, I think the best we can hope for Tokio is to have lots of things ready (and Tokio folk eager to have those changes) so when they start working on the 2.0 release, we get as much in as possible (I assume they will want to have a 2.0 preview available some time before the actual release for the sake of testing, etc.)</p>",
        "id": 264299072,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1639055943
    },
    {
        "content": "<p>Changing futures-rs seems the most possible and perhaps most useful</p>",
        "id": 264299172,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1639056003
    },
    {
        "content": "<p>If one were to change from futures::join to std::join, they would presumably then get a lint warning about the missing .await?</p>",
        "id": 264299257,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1639056036
    },
    {
        "content": "<p>Yes they would</p>",
        "id": 264299284,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1639056053
    },
    {
        "content": "<p>If not, we probably need to just remove join from futures rather than re-export the std version or there would be nasty silent breakage</p>",
        "id": 264299319,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1639056069
    },
    {
        "content": "<p>Would it make sense to remove the implicit .await from futures <em>now</em> to make the migration easier?</p>",
        "id": 264299342,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1639056084
    },
    {
        "content": "<p>I don't think so, if we re-export then the change should be transparent, otherwise, right?</p>",
        "id": 264299452,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1639056125
    },
    {
        "content": "<p>Hmm, actually does futures-rs support stable Rust?</p>",
        "id": 264299526,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1639056154
    },
    {
        "content": "<p>futures-util's MSRV is 1.45</p>",
        "id": 264299595,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1639056190
    },
    {
        "content": "<p>Presumably re-exporting an unstable item doesn't work on stable rust channel?</p>",
        "id": 264299598,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1639056191
    },
    {
        "content": "<p><a href=\"/user_uploads/4715/e6QeP98_3cMhCO8Ds8PfT9nw/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/4715/e6QeP98_3cMhCO8Ds8PfT9nw/image.png\" title=\"image.png\"><img src=\"/user_uploads/4715/e6QeP98_3cMhCO8Ds8PfT9nw/image.png\"></a></div>",
        "id": 264299889,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1639056298
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/futures-rs/issues/2207\">https://github.com/rust-lang/futures-rs/issues/2207</a></p>",
        "id": 264299951,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1639056314
    },
    {
        "content": "<p>So, I guess for futures-rs we should keep that impl in sync with the libcore one and add a line to the docs saying it is available in core?</p>",
        "id": 264301562,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1639057016
    },
    {
        "content": "<p>I guess it would be good to open a PR for that so we can discuss at least (not sure how futures-rs feel about breaking changes like that)</p>",
        "id": 264301642,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1639057062
    },
    {
        "content": "<p>(Seems like cfg on version is still unstable and cfg(accessible) is not properly implemented yet, although it is possible to 'cfg' on version using a build script)</p>",
        "id": 264301789,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1639057135
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"213313\">@Taiki Endo</span></p>",
        "id": 264303288,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1639057808
    },
    {
        "content": "<p>Now for <code>try_join!</code> which is arguably even more useful than <code>join!</code></p>",
        "id": 264343187,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1639073710
    },
    {
        "content": "<p>If <code>join!</code> returns a concrete future, we could have <code>join!(a, b).try().await</code> instead of <code>try_join!(a, b).await</code></p>",
        "id": 264343302,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1639073757
    },
    {
        "content": "<p>Contemplating whether it's nicer that way</p>",
        "id": 264343371,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1639073776
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/join!/near/264294261\">said</a>:</p>\n<blockquote>\n<p>We can and should iterate before stabilising, so please file issues or send PRs <span aria-label=\"heart\" class=\"emoji emoji-2764\" role=\"img\" title=\"heart\">:heart:</span>️</p>\n</blockquote>\n<p>Done: <a href=\"https://github.com/rust-lang/rust/pull/91721\">https://github.com/rust-lang/rust/pull/91721</a>. I've tagged you as a reviewer, but if <span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> (or <span class=\"user-mention\" data-user-id=\"363998\">@Ibraheem Ahmed</span>   if they have the rights) prefers to take over, they should feel free to do so <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 264350117,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1639076461
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232018\">@Daniel Henry-Mantilla</span> Looks good to me. Can you take a look at the structured suggestion and disposition it, and then I'll merge?</p>",
        "id": 264360510,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639081128
    },
    {
        "content": "<p>I'll try to first add a unit test for the two issues I mentioned above (<code>join!(async_fun(&amp;borrowed), opt_fut?)</code> should neither consume <code>borrowed</code>, nor complain about / misuse the <code>?</code>), and then I'll <code>r?</code> you</p>",
        "id": 264362071,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1639082008
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232018\">@Daniel Henry-Mantilla</span> Sounds good.</p>",
        "id": 264370196,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639085875
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"363998\">Ibraheem Ahmed</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/join!/near/264343302\">said</a>:</p>\n<blockquote>\n<p>If <code>join!</code> returns a concrete future, we could have <code>join!(a, b).try().await</code> instead of <code>try_join!(a, b).await</code></p>\n</blockquote>\n<p>I personally think <code>try_join!</code> seems clearer.</p>",
        "id": 264370304,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639085912
    },
    {
        "content": "<p>It makes the type of the future (\"something that might fail\") clear up front.</p>",
        "id": 264370353,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639085934
    },
    {
        "content": "<p>Kinda like a type signature.</p>",
        "id": 264370362,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639085939
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232018\">@Daniel Henry-Mantilla</span> pointed out that <code>try</code> is a keyword</p>",
        "id": 264370393,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1639085953
    },
    {
        "content": "<p>Also, <code>.try()</code> isn't an option anyway, since try is a keyword. ;)</p>",
        "id": 264370396,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639085954
    },
    {
        "content": "<p>(jinx)</p>",
        "id": 264370411,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639085962
    },
    {
        "content": "<p>Yeah :)</p>",
        "id": 264370415,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1639085964
    },
    {
        "content": "<p>Thank you both so much for working on this! It's exciting to see bits of the async ecosystem starting to filter into the standard library.</p>",
        "id": 264370517,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639086009
    },
    {
        "content": "<p>I added a couple alternative syntaxes for join! on the tracking issue</p>",
        "id": 264370540,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1639086026
    },
    {
        "content": "<p>I've started to quite like <code>await_all!</code></p>",
        "id": 264370585,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1639086054
    },
    {
        "content": "<p>But also <code>impl&lt;A...N&gt; Future for (A...N)</code>, which would allow <code>(a, b, c).await</code></p>",
        "id": 264370829,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1639086165
    },
    {
        "content": "<p>...huh.</p>",
        "id": 264370852,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639086176
    },
    {
        "content": "<p>That's a <em>fascinating</em> idea...</p>",
        "id": 264370860,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639086181
    },
    {
        "content": "<p>That's starting to almost feel like <code>collect</code>.</p>",
        "id": 264370898,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639086202
    },
    {
        "content": "<p>Huh.</p>",
        "id": 264370916,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639086211
    },
    {
        "content": "<p>How <em>ridiculous</em> would it be to make <code>.collect().await</code> work to collect a collection of futures into a collection of results?</p>",
        "id": 264370984,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639086243
    },
    {
        "content": "<p>That might not be possible, not sure.</p>",
        "id": 264371024,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639086253
    },
    {
        "content": "<p>Hm you mean like adding a <code>AsyncCollect</code> trait implemented for tuples?</p>",
        "id": 264371076,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1639086276
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/join!/near/264370984\">said</a>:</p>\n<blockquote>\n<p>How <em>ridiculous</em> would it be to make <code>.collect().await</code> work to collect a collection of futures into a collection of results?</p>\n</blockquote>\n<p>I want this so bad, for tuples and <code>Vec&lt;impl Future&gt;</code></p>",
        "id": 264371153,
        "sender_full_name": "Khionu Sybiern",
        "timestamp": 1639086316
    },
    {
        "content": "<p>For <code>Vec&lt;impl Future&gt;</code> there's <code>FuturesUnordered</code></p>",
        "id": 264371190,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1639086335
    },
    {
        "content": "<p>Forgot about that, but I think it might also be a good addition to std as well. Another RFC, though, I think?</p>",
        "id": 264371585,
        "sender_full_name": "Khionu Sybiern",
        "timestamp": 1639086504
    },
    {
        "content": "<p>Yeah probably</p>",
        "id": 264371609,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1639086513
    },
    {
        "content": "<p>A tuple of futures is a much more general use case</p>",
        "id": 264371628,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1639086525
    },
    {
        "content": "<p><code>FuturesUnordered</code> is <em>significantly</em> more complicated as well</p>",
        "id": 264371901,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1639086659
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"363998\">Ibraheem Ahmed</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/join!/near/264371076\">said</a>:</p>\n<blockquote>\n<p>Hm you mean like adding a <code>AsyncCollect</code> trait implemented for tuples?</p>\n</blockquote>\n<p>I don't mean tuples, those would have to be separate. I mean making <code>collect</code> itself work for an iterator of futures, returning a future of a collection.</p>",
        "id": 264372218,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639086797
    },
    {
        "content": "<p>It would leave the question open whether <code>collect().await</code> would be ordered or unordered. There might be a <em>good</em> assumption there, but I'm not sure an <em>obvious</em> one.</p>",
        "id": 264372414,
        "sender_full_name": "Khionu Sybiern",
        "timestamp": 1639086897
    },
    {
        "content": "<p>Imagine if this could work:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">v</span>: <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">fallible_fut</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">fallible_fut2</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">fallible_fut3</span><span class=\"p\">()].</span><span class=\"n\">collect</span>::<span class=\"o\">&lt;</span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Future</span><span class=\"o\">&lt;</span><span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">().</span><span class=\"k\">await</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 264372467,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639086930
    },
    {
        "content": "<p>I'm don't think that can work, but <code>.collect::&lt;future::Collect&lt;Result&lt;Vec&lt;T&gt;, E&gt;&gt;&gt;</code> might</p>",
        "id": 264373662,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1639087418
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">v</span>: <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">fallible_fut</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">fallible_fut2</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">fallible_fut3</span><span class=\"p\">()].</span><span class=\"n\">into_iter</span><span class=\"p\">().</span><span class=\"n\">collect</span>::<span class=\"o\">&lt;</span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Future</span><span class=\"o\">&lt;</span><span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">().</span><span class=\"k\">await</span><span class=\"o\">?</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">v</span>: <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">fallible_fut</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">fallible_fut2</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">fallible_fut3</span><span class=\"p\">()].</span><span class=\"n\">into_stream</span><span class=\"p\">().</span><span class=\"n\">collect</span>::<span class=\"o\">&lt;</span><span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">().</span><span class=\"k\">await</span><span class=\"o\">?</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 264373985,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1639087547
    },
    {
        "content": "<p><code>IntoStream</code> and <code>FromStream</code> are probably coming eventually, so...</p>",
        "id": 264374075,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1639087575
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"360486\">@Kestrer</span> pointed out that it would have to be <code>impl&lt;A...N&gt; IntoFuture for (A...N)</code>, and I actually think that's a much more logical impl to have</p>",
        "id": 264374839,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1639088011
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232018\">@Daniel Henry-Mantilla</span> <span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> thanks for the PR and review, respectively :-)</p>",
        "id": 264422478,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1639129205
    },
    {
        "content": "<p>I like the collect idea, but it feels like its solving a different problem to join! or await on a tuple. If you have an iterator of futures already, then I'd want to use collect, but if you have a bunch of individual futures, then putting them into a collection, iterating it, then collecting it is a lot of boilerplate (and probably inefficient).</p>",
        "id": 264422667,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1639129302
    },
    {
        "content": "<p>I guess that it is kind of subtle that await on a tuple awaits in parallel rather than sequentially (this is hard enough to explain already, so I wonder if slightly magical syntax is the best idea here)</p>",
        "id": 264422844,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1639129403
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"363998\">@Ibraheem Ahmed</span> could you explain your into_iter/into_stream example please? I am interested in how collect would work with iterators of futures vs streams, but I'm not sure what you are trying to demonstrate with the example</p>",
        "id": 264423085,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1639129542
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/join!/near/264422667\">said</a>:</p>\n<blockquote>\n<p>I like the collect idea, but it feels like its solving a different problem to join! or await on a tuple. If you have an iterator of futures already, then I'd want to use collect, but if you have a bunch of individual futures, then putting them into a collection, iterating it, then collecting it is a lot of boilerplate (and probably inefficient).</p>\n</blockquote>\n<p>In case it wasn't clear, I completely agree, and I wasn't suggesting <code>collect</code> as a <em>replacement</em> for join or similar.</p>",
        "id": 264433806,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639135876
    },
    {
        "content": "<p>Am I correct in the assumption that we would only stabilize the behavior of <code>join!</code> (as opposed to the code the macro expands to)? I'm asking because there might multiple basically equivalent ways to implement this -- but some of them would make it very hard for a debugger to reconstruct things from debuginfo while other implementation strategies might make it trivial.</p>",
        "id": 264450529,
        "sender_full_name": "mw",
        "timestamp": 1639144777
    },
    {
        "content": "<p>Yeah, we never stabilise implementations, so as long as the behaviour is unchanged, the implementation can change as much as we like</p>",
        "id": 264450845,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1639144879
    },
    {
        "content": "<p>I have yet to collect more experience on what exactly makes it easy for a debugger to detect a join (either on the call stack or in a suspended generator frame) and thus can't give feedback on any specific implementation now. So it would be great if retained some flexibility in what's implemented.</p>",
        "id": 264450887,
        "sender_full_name": "mw",
        "timestamp": 1639144898
    },
    {
        "content": "<p>Having said that, if you have concerns, it might be better to make a change sooner rather than later just in case it is a behaviour-changing change</p>",
        "id": 264450928,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1639144919
    },
    {
        "content": "<p>OK, that sounds good</p>",
        "id": 264450929,
        "sender_full_name": "mw",
        "timestamp": 1639144919
    },
    {
        "content": "<p>I suspect that behavior would not have to be changed. It would more be something like \"wrap things in a helper struct with a well-known name instead of generating a bunch of unrecognizable variables on the stack\"</p>",
        "id": 264451281,
        "sender_full_name": "mw",
        "timestamp": 1639145050
    },
    {
        "content": "<p>Is this expected to be stabilized soon?</p>",
        "id": 264451753,
        "sender_full_name": "mw",
        "timestamp": 1639145281
    },
    {
        "content": "<p>Given that we've changed the interface slightly from what is in futures-rs and Tokio, I'd think we'd want to get a decent amount of experience before stabilising it</p>",
        "id": 264452328,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1639145544
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/join!/near/264423085\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"363998\">Ibraheem Ahmed</span> could you explain your into_iter/into_stream example please? I am interested in how collect would work with iterators of futures vs streams, but I'm not sure what you are trying to demonstrate with the example</p>\n</blockquote>\n<p>The <code>into_iter</code> version is what <span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> was thinking about, but if there was an <code>impl IntoStream for I: IntoIterator&lt;Item: Future&gt;</code>, that could be nicer.</p>",
        "id": 264463695,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1639150498
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/join!/near/264422844\">said</a>:</p>\n<blockquote>\n<p>I guess that it is kind of subtle that await on a tuple awaits in parallel rather than sequentially (this is hard enough to explain already, so I wonder if slightly magical syntax is the best idea here)</p>\n</blockquote>\n<p>Concurrently not in parallel, but yes I agree. A macro is easier to document and teach.</p>",
        "id": 264463746,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1639150529
    },
    {
        "content": "<p>I think <code>await_all!</code> is the clearest (<code>Task.WhenAll</code>, <code>Promise.All</code> from other languages)</p>",
        "id": 264463810,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1639150560
    },
    {
        "content": "<blockquote>\n<p>FuturesUnordered is significantly more complicated as well</p>\n</blockquote>\n<p>It's also significantly less expensive, and the exponential complexity of the plain <code>join!</code> might surprise some people. That's one reason against including it in <code>std</code></p>",
        "id": 264535715,
        "sender_full_name": "Matthias247",
        "timestamp": 1639189853
    },
    {
        "content": "<p>Because it takes tuples I don't think that's a big problem</p>",
        "id": 264539858,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1639195793
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"363998\">Ibraheem Ahmed</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/join!/near/264059800\">said</a>:</p>\n<blockquote>\n<p>Do you think <code>std::future::join!</code> requires an RFC or could I just PR it?</p>\n</blockquote>\n<p>I don't think adding <code>std::future::join!</code> in the current macro form would be the right direction for the stdlib. I wrote a post earlier this year on the design of <code>join!</code>, <code>join_all!</code>, <code>try_join!</code>, <code>race!</code> and <code>try_race!</code> here: <a href=\"https://blog.yoshuawuyts.com/futures-concurrency-2/\">FUTURES CONCURRENCY II</a>.</p>\n<p>The prototype library described in the post can be found here: <a href=\"https://docs.rs/futures-concurrency/1.1.0/futures_concurrency/index.html\">yoshuawuyts/futures-concurrency</a>. Here's an example of what using that library looks like today:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// Await multiple similarly-typed futures.</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">future</span>::<span class=\"n\">ready</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"k\">u8</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">future</span>::<span class=\"n\">ready</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"k\">u8</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">future</span>::<span class=\"n\">ready</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"k\">u8</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"fm\">assert_eq!</span><span class=\"p\">([</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"p\">].</span><span class=\"n\">join</span><span class=\"p\">().</span><span class=\"k\">await</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">]);</span><span class=\"w\"></span>\n\n<span class=\"c1\">// Await multiple differently-typed futures.</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">future</span>::<span class=\"n\">ready</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"k\">u8</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">future</span>::<span class=\"n\">ready</span><span class=\"p\">(</span><span class=\"s\">\"hello\"</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">future</span>::<span class=\"n\">ready</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"k\">u16</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"fm\">assert_eq!</span><span class=\"p\">((</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"p\">).</span><span class=\"n\">join</span><span class=\"p\">().</span><span class=\"k\">await</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"hello\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">));</span><span class=\"w\"></span>\n\n<span class=\"c1\">// It even works with vectors of futures, providing an alternative</span>\n<span class=\"c1\">// to futures-rs' `join_all`.</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">future</span>::<span class=\"n\">ready</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"k\">u8</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">future</span>::<span class=\"n\">ready</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"k\">u8</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">future</span>::<span class=\"n\">ready</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"k\">u8</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"fm\">vec!</span><span class=\"p\">[</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"p\">].</span><span class=\"n\">join</span><span class=\"p\">().</span><span class=\"k\">await</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"fm\">vec!</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">]);</span><span class=\"w\"></span>\n</code></pre></div>\n<hr>\n<p>The whole post might be worth a read. It covers some issues that I haven't seen brought up yet in this thread. For example: the return types of the various macros tend to be incompatible. And having two separate interfaces to perform <code>join!</code> vs <code>join_all</code> is not particularly ergonomic.</p>\n<p>I feel like I've gone fairly deep on the topic of async concurrency API design, but haven't ironed out all the kinks yet.  I feel strongly that futures concurrency should be treated as a single topic that requires a cohesive design, and should go through the RFC process.  But before that: I think we should experiment outside of the stdlib more before we propose to merge anything,  as the space seems somewhat under-explored. And perhaps a group under the async-foundations WG might be the right venue to do that?</p>",
        "id": 264737045,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1639415061
    },
    {
        "content": "<blockquote>\n<p>I'm of the opinion we should aim to return convenient named futures</p>\n</blockquote>\n<p>Why? If in the rare case someone needs a named future they can just use TAIT themselves.</p>",
        "id": 264739511,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1639416035
    },
    {
        "content": "<p>So far all futures in the stdlib have intentionally been named, and I don't think we should break from that.</p>",
        "id": 264740258,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1639416331
    },
    {
        "content": "<p>We made the mistake of not doing that in <code>async-std</code>, and in hindsight that's been one of our major flaws. What we gained in implementation speed, we lost in usability.</p>",
        "id": 264740401,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1639416373
    },
    {
        "content": "<p>There are reasons why we <em>temporarily</em> might want to expose an anonymous future (see also: \"road to std\" in my post). But it should not be the final state a design finds itself in.</p>",
        "id": 264740496,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1639416407
    },
    {
        "content": "<p>I don't think there's really any basis for judging how rare a case might be. But even assuming the case is rare, if it's included in the stdlib by virtue of scale the rare case will still happen all the time.</p>",
        "id": 264740800,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1639416539
    },
    {
        "content": "<p>From your post:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">type</span> <span class=\"nc\">JoinFuture</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Future</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"c1\">// Implement `Join` for tuple `(A, B)`.</span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Join</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">A</span>: <span class=\"nc\">Future</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">B</span>: <span class=\"nc\">Future</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Output</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">A</span>::<span class=\"n\">Output</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">B</span>::<span class=\"n\">Output</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">join</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">JoinFuture</span><span class=\"o\">&lt;</span><span class=\"bp\">Self</span>::<span class=\"n\">Output</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"c1\">// ...and repeat for all other tuples (likely using a macro).</span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">JoinTrait</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">JoinTrait</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">JoinTrait</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>I don't believe this will work with TAIT.</p>",
        "id": 264741074,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1639416652
    },
    {
        "content": "<p>Each async block will generate a new opaque type.</p>",
        "id": 264741089,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1639416662
    },
    {
        "content": "<p>Oh I see, yeah I think you might be right</p>",
        "id": 264742059,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1639417093
    },
    {
        "content": "<p>You could have <code>impl&lt;T..N&gt; Future for JoinFuture&lt;(T..N)&gt;</code> with a macro or eventually variadics.</p>",
        "id": 264742754,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1639417306
    },
    {
        "content": "<p>Yeah, that's what I was hoping for. TAITs were only meant to act as an intermediate state; working from the assumption that we'd have access to TAITs before we have access to variadics / variadic tuples.</p>",
        "id": 264743278,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1639417423
    },
    {
        "content": "<p>That is also possible with the <code>join!</code> macro though.</p>",
        "id": 264743481,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1639417491
    },
    {
        "content": "<p><a href=\"#narrow/stream/187312-wg-async-foundations/topic/join!/near/264224251\">https://rust-lang.zulipchat.com/#narrow/stream/187312-wg-async-foundations/topic/join!/near/264224251</a></p>",
        "id": 264743541,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1639417518
    },
    {
        "content": "<p>Oh I missed that <a href=\"https://github.com/rust-lang/rust/pull/91645\">https://github.com/rust-lang/rust/pull/91645</a> had been merged</p>",
        "id": 264743619,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1639417554
    },
    {
        "content": "<p>The wg-async-foundations team was never tagged :/</p>",
        "id": 264743680,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1639417574
    },
    {
        "content": "<p>Oh yes, it's unstable though of course.</p>",
        "id": 264743715,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1639417586
    },
    {
        "content": "<p>I think I did tag wg-async-foundations?</p>",
        "id": 264743732,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1639417595
    },
    {
        "content": "<p>the tag doesn't resolve, meaning the WG never got the notification</p>",
        "id": 264743767,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1639417615
    },
    {
        "content": "<p>I would've written what I just wrote ^ in the issue</p>",
        "id": 264743780,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1639417622
    },
    {
        "content": "<p>async concurrency is a big enough topic that I don't think we should be merging it piece-meal</p>",
        "id": 264743838,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1639417647
    },
    {
        "content": "<p>I agree that we should come up with a coherent interface for join, try_join, and join_all before merging.</p>",
        "id": 264743914,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1639417674
    },
    {
        "content": "<p>I don't agree that <code>await_all!(a, b, c)</code> is \"awkward\" compared to <code>(a, b, c).join().await</code>, and I also think that the API for ordered/unordered stream collection is a more powerful and just as usable of an interface compared to <code>.join()</code>, but given the many design possiblities, I do think an RFC is the best path forward.</p>",
        "id": 264746972,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1639418860
    },
    {
        "content": "<p>Filed a comment on the tracking issue: <a href=\"https://github.com/rust-lang/rust/issues/91642#issuecomment-992773288\">https://github.com/rust-lang/rust/issues/91642#issuecomment-992773288</a> -- this roughly maps to what I would've said on the PR if the notification would've gone out.</p>",
        "id": 264753532,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1639421894
    },
    {
        "content": "<p>FWIW, in general we do tend to merge unstable PRs on the basis of \"looks reasonable\", and then take <em>much</em> more care when stabilizing them.</p>",
        "id": 264781448,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639435300
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"211722\">@Yoshua Wuyts [he/they]</span> So please don't take the straightforward merger of this PR as an indication that we won't take substantial care before stabilizing; in particular, we'll pay attention to the note you sent.</p>",
        "id": 264781528,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639435336
    },
    {
        "content": "<p>I do personally think that <code>.join()</code> on a tuple might make sense (and I like that better than just <code>.await</code> on a tuple).</p>",
        "id": 264781574,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639435371
    },
    {
        "content": "<p>And I like that that would be postfix here.</p>",
        "id": 264781642,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639435438
    },
    {
        "content": "<p>Is the primary reason for <code>join</code> being a macro is that it's variadic?</p>",
        "id": 264813568,
        "sender_full_name": "Andrew Chin (eminence)",
        "timestamp": 1639459066
    },
    {
        "content": "<p>(maybe someone's done this already, but it'd probably be good to document the ergonomic benefits of variadic macros and weight them against the ergonomic costs of macros)</p>",
        "id": 264813790,
        "sender_full_name": "Andrew Chin (eminence)",
        "timestamp": 1639459190
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"222286\">Andrew Chin (eminence)</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/join!/near/264813568\">said</a>:</p>\n<blockquote>\n<p>Is the primary reason for <code>join</code> being a macro is that it's variadic?</p>\n</blockquote>\n<p>that's right</p>",
        "id": 264848361,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1639484388
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"211722\">@Yoshua Wuyts [he/they]</span> while I think that <code>.join().await</code> makes sense, even despite the variadics / maximum arity concerns for differently-typed futures, that doesn't solve the other necessary <code>.race()</code>ing APIs. It has been discussed here about a <code>(…).join().try().await</code> API design (don't mind the keyword issue, that's just bikeshedding), whereby <code>.try()</code> would have been an adaptor to change the semantics of the previous <code>.join()</code> (conceptually) by changing the semantics of the following <code>.await</code> (implementation-wise). The initial reaction from some people (among the few people \"polled\" (heh)) was that that was maybe too subtle/terse: <code>join()</code> is written, but then <code>race</code>-ing behavior is showcased for <code>Err</code>s. That's why then having extra names makes sense: <code>.try_join().await</code> / <code>.race().await</code> / <code>.try_race().await</code>: these four concurrency primitives you talk about are each unique and important enough on its own to be written as standalone constructions, I'd say.</p>\n<p>Finally, there was a double question:</p>\n<ul>\n<li>other languages feature a \"<code>all()</code>-based naming\" (<em>e.g.</em>, <code>Promise::all()</code>): that <em>all</em> element in the name seems interesting / relevant.</li>\n<li><em>with the macro syntax</em>, should the <code>.await</code> be explicit or implicit. </li>\n</ul>\n<p>Hence the idea of an <code>await_all!(…)</code> macro: there is both <code>await</code> and <code>all</code> in the name, with the <em>await</em> part playing a double role: it disambiguates / brings <code>async</code> context to the <code>all</code> part, so that we understand what is going on; by virtue of being called, <em>verbatim</em>, <em>await</em>, we can afford to offer an \"implicitly\" <code>.await</code>-ed API, without falling into \"too terse\" territory.</p>\n<p>So, my personal takeaway would be that the two best candidate APIs would be <code>await_all!(…)</code> and <code>(…).join().await</code>. Given the variadic limitations at the moment, the macro API has the advantage of being more flexible. But since <code>[…].join().await</code>, on the other hand, seems like an interesting <em>complementary</em> addition, for those dealing with a <code>const</code>-generic len, or a runtime-variable length (<code>vec![…].join()</code>) —I don't know how often that occurs in practice—, then I can see the point for a <code>(…).join().await</code> API, much alike <code>task::ready!(…)</code> having already become a <code>.ready()?</code> method for <code>Poll</code>. Making such a switch in the future wouldn't be hard.</p>",
        "id": 264890413,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1639501674
    },
    {
        "content": "<p>Regarding the nameability of the returned futures, I think that they should only be nameable through <code>impl Future</code> aliases, or using <code>&lt;(…) as Join&gt;::Output</code>, at least for the heterogenous futures situation: there should be no concrete type, or if there is one, it should be perma-<code>unstable</code>. This is indeed different from, say, <code>&lt;Vec&lt;T&gt; as IntoIterator&gt;::IntoIter</code> being nameable (as <code>::std::vec::IntoIter&lt;T&gt;</code>). The reason for that being that, especially with the whole variadic situation being unclear, the actual implementation details are susceptible to evolve.<br>\nThis is not such a big deal for libraries, since there is always the possibility to perform a new major release.<br>\nBut if we take the current implementation of <code>join!</code>, for instance, the currently yielded future, should there not be an <code>async  { … .await }</code> layer, would have been an <code>PollFn&lt;…&gt;</code>. This means that people would then have been able to write <code>let PollFn { .. } = join!(…);</code> and, from there, the stdlib would have been doomed to always yield a <code>PollFn</code> with the exact same type arity (modulo defaulted type params) just for back-compat.</p>\n<p>Moreover, by the time this whole std effort lands on stable, it's very likely that we'll already have TAITs, or a subset of them (<code>min_…</code>), precisely to reduce the current sore points with Voldemort futures.</p>",
        "id": 264892704,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1639502426
    },
    {
        "content": "<blockquote>\n<p>Voldemort futures</p>\n</blockquote>\n<p>Not really relevant, but this is an amazing term!</p>",
        "id": 264942672,
        "sender_full_name": "eholk",
        "timestamp": 1639523856
    },
    {
        "content": "<p>I don't think <code>(...).join().await</code> is the best solution, because it adds a function <code>&lt;(T...)&gt;::join</code> that doesn't immediately carry the message of being async. In the mindset of writing async code it makes sense, but <code>join</code> is quite a generic word and outside <code>async</code> a method named <code>join</code> on tuples could potentially do things completely unrelated to joining futures - concatenate two tuples, for example. It would be quite easy for a beginner to stumble into that method, assume it's some generic operation and be confused because they don't know what a \"future\" is - in contrast, if <code>join</code> were to be located in a <code>future</code> module it would be clear that it's only used for async code and if you don't need futures you don't need it. Of course it could be implemented with an extension trait, but that would be a weird API design when we _are_ the standard library, and it would effectively create two \"modes\" of Rust, each one where <code>(...).join()</code> means a different thing - like it's some feature flag.</p>\n<p>Additionally, tuples don't play well with rustfmt. Often it ends up being formatted like this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">b</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">c</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">.</span><span class=\"n\">join</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"p\">.</span><span class=\"k\">await</span><span class=\"w\"></span>\n</code></pre></div>\n<p>which is a one extra line and a weird-looking lone opening bracket. In comparison:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">future</span>::<span class=\"n\">join</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">b</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">c</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">.</span><span class=\"k\">await</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 264970516,
        "sender_full_name": "Kestrer",
        "timestamp": 1639549851
    }
]