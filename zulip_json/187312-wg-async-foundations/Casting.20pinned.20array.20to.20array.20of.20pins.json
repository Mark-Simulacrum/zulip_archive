[
    {
        "content": "<p>Hey all, I was wondering if there's a canonical way to do the following conversion:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">convert</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">input</span>: <span class=\"nc\">Pin</span><span class=\"o\">&lt;&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">T</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"p\">]</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"p\">[</span><span class=\"n\">Pin</span><span class=\"o\">&lt;&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"p\">];</span><span class=\"w\"></span>\n</code></pre></div>\n<p>I'm noticing this is a pattern which comes up when manually writing future adapters which use const generics, and having a sound conversion between the two (if possible) would be helpful.</p>",
        "id": 265686562,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1640094522
    },
    {
        "content": "<p>The underlying reason of why I want this is because <code>pin-project</code> can only guarantee the array is pinned; I'm having trouble expressing that I want each value _within_ the array to be pinned too.</p>",
        "id": 265686747,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1640094615
    },
    {
        "content": "<p>Probably cc <span class=\"user-mention\" data-user-id=\"213313\">@Taiki Endo</span> ?</p>",
        "id": 265686784,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1640094636
    },
    {
        "content": "<p>The closest I've gotten is <a href=\"https://github.com/rust-lang/futures-rs/blob/b48eb2e9a9485ef7388edc2f177094a27e08e28b/futures-util/src/future/join_all.rs#L18-L23\">https://github.com/rust-lang/futures-rs/blob/b48eb2e9a9485ef7388edc2f177094a27e08e28b/futures-util/src/future/join_all.rs#L18-L23</a>, which suggests that this general transform should be sound.</p>",
        "id": 265686901,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1640094707
    },
    {
        "content": "<p>Oh, hah. Answered my own question. Using <code>array::each_mut</code> we can convert <code>[T; N]</code> to <code>[&amp;mut T; N]</code>, which we can then <code>array::map</code> to <code>[Pin&lt;&amp;mut T&gt;; N]</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"p\">(</span><span class=\"k\">crate</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">pin_project_array</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">slice</span>: <span class=\"nc\">Pin</span><span class=\"o\">&lt;&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">T</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"p\">]</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"p\">[</span><span class=\"n\">Pin</span><span class=\"o\">&lt;&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">slice</span><span class=\"p\">.</span><span class=\"n\">get_unchecked_mut</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">.</span><span class=\"n\">each_mut</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">.</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">t</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">Pin</span>::<span class=\"n\">new_unchecked</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">})</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 265687485,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1640095036
    },
    {
        "content": "<p>I think you can reopen <a href=\"https://github.com/rust-lang/rust/pull/78370\">https://github.com/rust-lang/rust/pull/78370</a>.</p>",
        "id": 265688000,
        "sender_full_name": "Taiki Endo",
        "timestamp": 1640095283
    },
    {
        "content": "<p>I almost feel like it'd be useful to have both</p>",
        "id": 265694334,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1640099026
    },
    {
        "content": "<p>Okay, got it all working. It seems while both can be useful, but <code>get_pin_ref</code> and <code>get_pin_mut</code> seem fundamental. We really do need some form of that PR to land.</p>",
        "id": 265697432,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1640100401
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"213313\">@Taiki Endo</span>!</p>",
        "id": 265697443,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1640100407
    },
    {
        "content": "<p>For the record, I'm implementing a <code>Stream</code> in the following way:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">S</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Stream</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Merge</span><span class=\"o\">&lt;</span><span class=\"n\">S</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">S</span>: <span class=\"nc\">Stream</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Item</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">S</span>::<span class=\"n\">Item</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">poll_next</span><span class=\"p\">(</span><span class=\"bp\">self</span>: <span class=\"nc\">Pin</span><span class=\"o\">&lt;&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">Self</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">cx</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">Context</span><span class=\"o\">&lt;'</span><span class=\"nb\">_</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Poll</span><span class=\"o\">&lt;</span><span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"bp\">Self</span>::<span class=\"n\">Item</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">project</span><span class=\"p\">();</span><span class=\"w\"></span>\n\n<span class=\"w\">        </span><span class=\"c1\">// Randomize the indexes into our streams array. This ensures that when</span>\n<span class=\"w\">        </span><span class=\"c1\">// multiple streams are ready at the same time, we don't accidentally</span>\n<span class=\"w\">        </span><span class=\"c1\">// exhaust one stream before another.</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">arr</span>: <span class=\"p\">[</span><span class=\"kt\">usize</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">core</span>::<span class=\"n\">array</span>::<span class=\"n\">from_fn</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">n</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">arr</span><span class=\"p\">.</span><span class=\"n\">sort_by_cached_key</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">_</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">utils</span>::<span class=\"n\">random</span><span class=\"p\">(</span><span class=\"mi\">1000</span><span class=\"p\">));</span><span class=\"w\"></span>\n\n<span class=\"w\">        </span><span class=\"c1\">// Iterate over our streams one-by-one. If a stream yields a value,</span>\n<span class=\"w\">        </span><span class=\"c1\">// we exit early. By default we'll return `Poll::Ready(None)`, but</span>\n<span class=\"w\">        </span><span class=\"c1\">// this changes if we encounter a `Poll::Pending`.</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Poll</span>::<span class=\"n\">Ready</span><span class=\"p\">(</span><span class=\"nb\">None</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">index</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">arr</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">stream</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">utils</span>::<span class=\"n\">get_pin_mut</span><span class=\"p\">(</span><span class=\"n\">this</span><span class=\"p\">.</span><span class=\"n\">streams</span><span class=\"p\">.</span><span class=\"n\">as_mut</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">index</span><span class=\"p\">).</span><span class=\"n\">unwrap</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">stream</span><span class=\"p\">.</span><span class=\"n\">poll_next</span><span class=\"p\">(</span><span class=\"n\">cx</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"n\">Poll</span>::<span class=\"n\">Ready</span><span class=\"p\">(</span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">item</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">Poll</span>::<span class=\"n\">Ready</span><span class=\"p\">(</span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">item</span><span class=\"p\">)),</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"n\">Poll</span>::<span class=\"n\">Ready</span><span class=\"p\">(</span><span class=\"nb\">None</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">continue</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"n\">Poll</span>::<span class=\"n\">Pending</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Poll</span>::<span class=\"n\">Pending</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">res</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 265697535,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1640100448
    },
    {
        "content": "<p>In order to index into a pinned array of items in arbitrary order, we need <code>get_pin_mut</code>.</p>",
        "id": 265697661,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1640100512
    },
    {
        "content": "<p>(planning to publish this code soon; I'll share a permalink to it so we can reference it for any PR to the stdlib)</p>",
        "id": 265697743,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1640100556
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"211722\">Yoshua Wuyts [he/they]</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/Casting.20pinned.20array.20to.20array.20of.20pins/near/265687485\">said</a>:</p>\n<blockquote>\n<p>Oh, hah. Answered my own question. Using <code>array::each_mut</code> we can convert <code>[T; N]</code> to <code>[&amp;mut T; N]</code>, which we can then <code>array::map</code> to <code>[Pin&lt;&amp;mut T&gt;; N]</code>:</p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"p\">(</span><span class=\"k\">crate</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">pin_project_array</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">slice</span>: <span class=\"nc\">Pin</span><span class=\"o\">&lt;&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">T</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"p\">]</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"p\">[</span><span class=\"n\">Pin</span><span class=\"o\">&lt;&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">slice</span><span class=\"p\">.</span><span class=\"n\">get_unchecked_mut</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">.</span><span class=\"n\">each_mut</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">.</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">t</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">Pin</span>::<span class=\"n\">new_unchecked</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">})</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Actually, not even sure this is sound. After doing this, the array can be re-ordered in-place, which I believe violates <code>Pin</code> guarantees.</p>",
        "id": 265701564,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1640102419
    }
]