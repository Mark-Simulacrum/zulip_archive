[
    {
        "content": "<p>Functions like <code>join!</code> come with the drawback that it is suboptimal to attempt to call it on futures like <code>JoinHandle</code>, because it causes more wakeups than necessary. To alleviate this problem a new method could be added to Future:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">needs_poll</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">bool</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kc\">false</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Only futures like <code>JoinHandle</code> would return <code>true</code> for this. The implementation of <code>join!</code> would first check whether its futures return <code>true</code>, and if so delay polling them until the very end, when it polls them efficiently in sequence.</p>\n<p>Unfortunately, I don't think this would allow for any optimization in other utilities like <code>try_join!</code>. Unless I'm not thinking of something we're stuck with the quadratic complexity there unless we introduce a FuturesUnordered-like subscheduler.</p>",
        "id": 264975338,
        "sender_full_name": "Kestrer",
        "timestamp": 1639555120
    }
]