[
    {
        "content": "<p>There seems to be some ambiguity about these terms. Sometimes they are used interchangeably, or even explicitly conflated as in the Tokio tutorial glossary, but sometimes they are used to mean subtly different things.</p>",
        "id": 261158896,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1636650037
    },
    {
        "content": "<p>Does anyone have a precise definition of the two concepts and/or an opinion that they mean the same things or different things?</p>",
        "id": 261159003,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1636650083
    },
    {
        "content": "<p>And in the specific case of the futures crate, it has been described as having an executor but not a scheduler (I can't find the quote now though, I hope I didn't imagine it). Is that correct? What does it mean exactly?</p>",
        "id": 261159166,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1636650151
    },
    {
        "content": "<p>Would folk consider the futures crate as a runtime in the same way as Tokio, or is it missing something?</p>",
        "id": 261159224,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1636650189
    },
    {
        "content": "<p>I generally consider these to be the same thing, and draw a distinction between the reactor (OS integration, leaf futures) and the executor (polls futures)</p>",
        "id": 261172204,
        "sender_full_name": "tmandry",
        "timestamp": 1636657155
    },
    {
        "content": "<p>if there were enough logic to call something a scheduler, I would consider it a component of the executor</p>",
        "id": 261172262,
        "sender_full_name": "tmandry",
        "timestamp": 1636657194
    },
    {
        "content": "<p>Can an generalized abstraction layer exist between the reactor and the executor? That's an <code>alloc</code>-style config knob that I hadn't thought of.</p>",
        "id": 261173293,
        "sender_full_name": "Esteban Küber",
        "timestamp": 1636657747
    },
    {
        "content": "<p>Huh, I have always assumed reactor and executor were synonymous</p>",
        "id": 261176107,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1636659335
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116883\">@tmandry</span> so, how would you describe the futures crate’s executor and would you distinguish that from Tokio or async std in a categorical way?</p>",
        "id": 261176228,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1636659423
    },
    {
        "content": "<p>I generally use them interchangeably</p>",
        "id": 261181914,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1636662999
    },
    {
        "content": "<p>I would consider the executor and scheduler to be the same, but reactor to be different.<br>\nExecutor: Runs futures in the background<br>\nReactor: Dispatches events from one source (e.g. epoll) to many leaf futures<br>\nA nice conceptual model is that the reactor exists as just another future running on the executor. When epoll wakes, that future will be scheduled to run and once it does it will wake up any other futures that need to be woken. Additionally, the executor itself can just be another future running atop <code>block_on</code>, <code>async-executor</code>-style. By this definition, <code>hyper::client::conn::Connection</code> (<a href=\"https://docs.rs/hyper/0.14/hyper/client/conn/struct.Connection.html\">https://docs.rs/hyper/0.14/hyper/client/conn/struct.Connection.html</a>) is also a reactor and I think that's a good thing.</p>",
        "id": 261185737,
        "sender_full_name": "Kestrer",
        "timestamp": 1636665611
    },
    {
        "content": "<p>Components in the <code>smol-rs</code> ecosystem highlight this distinction:</p>\n<ul>\n<li><a href=\"https://docs.rs/async-io/1.6.0/async_io/\"><code>async-io</code></a> is an example of a reactor</li>\n<li><a href=\"https://docs.rs/async-task/4.0.3/async_task/\"><code>async-task</code></a> is an example of an executor</li>\n</ul>\n<p>Runtimes aimed at end-users can re-package these components to create something more usable off the shelf. But at the component level distinguishing between reactor and executor is useful, in particular as it allows for experimenting with one part of the runtime, while not touching the other. For example <a href=\"https://docs.rs/ringbahn/0.0.0-experimental.3/ringbahn/\"><code>ringbahn</code></a> exposes an API similar to <code>async-io</code>, but was designed exclusively for  Linux' <code>io_uring</code>.</p>",
        "id": 262454168,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1637673763
    },
    {
        "content": "<p>That said though, in my experience most users of async Rust do not care / will not want to have to care about the distinction between reactor and executor. A runtime is often just a mandatory step to make HTTP and pals work, with questions like: \"What components does the runtime consist of\" usually being too granular.</p>\n<p>But if we're coming at this from a perspective of: \"What interfaces should Rust expose to support first-class async abstractions\", then I think we will likely want to be cognisant of this distinction.</p>",
        "id": 262456999,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1637675096
    },
    {
        "content": "<p>FWIW I also use \"executor\" to mean \"the thing that polls futures\", while \"reactor\" is \"the thing that drives futures / wakes them up in response to OS events.\" In some systems it's advantageous for performance reasons to have these be the same thing.</p>",
        "id": 262492099,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1637690600
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/executor.20vs.20scheduler/near/261159166\">said</a>:</p>\n<blockquote>\n<p>And in the specific case of the futures crate, it has been described as having an executor but not a scheduler (I can't find the quote now though, I hope I didn't imagine it). Is that correct? What does it mean exactly?</p>\n</blockquote>\n<p>I think this is true for <code>futures::executor::block_on</code> (that is, it's an executor but not a scheduler), because it only executes one task, so it doesn't have to do any \"scheduling\" (picking which task to poll next). However, <code>futures::executor::LocalPool</code> and <code>futures::executor::ThreadPool</code>are executors which do have to schedule multiple tasks and therefore are also schedulers. So I think it's not correct to say \"the futures crate has an executor but not a scheduler\".</p>\n<p>At least, if you subscribe my definitions of executor and scheduler.</p>",
        "id": 263787340,
        "sender_full_name": "Dan Johnson",
        "timestamp": 1638736142
    },
    {
        "content": "<p>I want to share a reddit comment that lead me here; <a href=\"https://www.reddit.com/r/rust/comments/rb8fgt/portable_and_interoperable_async_rust/hnvb7sp/?context=1\">https://www.reddit.com/r/rust/comments/rb8fgt/portable_and_interoperable_async_rust/hnvb7sp/?context=1</a></p>\n<p>To me, the \"executor\" is more like a scheduler of tasks, while a \"reactor\" is a resource that registers and watches IO events, these two can work in tandem, but i think it'd help if they were seperated</p>\n<p>like i said on twitter: i think it would be interesting if libraries can \"choose their own reactor\", at which the executor would then have to manage tasks and reactors together. if this can be done transiently, you start to have the real \"mix and match\" feel that y'all are trying to achieve here</p>",
        "id": 264686458,
        "sender_full_name": "Jonathan de Jong",
        "timestamp": 1639391268
    },
    {
        "content": "<p>Furthermore, it would be interesting to explore if there can be a \"std reactor\" that libraries can default to then, so that executors arent handling 10-odd exotic reactors at a same time, but that 99% of the libraries (could) use std for all of their purposes, but one uses that one io_uring-based reactor library to achieve extra speed</p>",
        "id": 264686842,
        "sender_full_name": "Jonathan de Jong",
        "timestamp": 1639391468
    },
    {
        "content": "<p>Possibly, reactors could themselves depend on timer-based reactors, to continually check a resource and then \"poke\" the executor, so then reactors could be async-task based.</p>\n<p>Or, reactors would need a full thread to themselves to do their work, and then the executor would allocate them that thread.</p>\n<p>There could also be opportunities for \"enhanced integrations\", i.e. if tokio would like to capture all the IO the std_reactor would do, and instead re-route it to its <code>mio</code>-based own reactor.</p>\n<p>There's a lot of food for thought here, but i personally think this could be a healthy separation, and it would allow reactor-based (io_uring, etc.) development and executor (low-overhead, industry, resillient, generic, etc.) development to happen concurrently without getting in eachother's way</p>",
        "id": 264688098,
        "sender_full_name": "Jonathan de Jong",
        "timestamp": 1639392197
    },
    {
        "content": "<p>I don't know what exactly is discussed here, but the thread name suggests these two papers from C++ standardization may be relevant:</p>\n<ul>\n<li>\"Disentangling schedulers and executors\" - <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2235r0.html\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2235r0.html</a></li>\n<li>\"Scheduler vs Executor\" - <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2250r0.pdf\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2250r0.pdf</a></li>\n</ul>\n<p>Context: development of concepts (traits) for the C++ executor library.<br>\nNot sure how that story ended, I didn't have time to read the C++ committee mailings from 2021.</p>",
        "id": 264722741,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1639409437
    }
]