[
    {
        "content": "<p>On <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/3014-must-not-suspend-lint.md\">https://github.com/rust-lang/rfcs/blob/master/text/3014-must-not-suspend-lint.md</a>, I am finding that it is significantly more difficult to correctly lint if we allow <code>#[must_not_suspend]</code> on fn/method items (which works for <code>#[must_use]</code>. Can someone confirm that I am reading that RFC right, and we want <code>#must_not_suspend]</code> to work on ADTs, fns (including trait method definitions and methods), and traits (I think this just affects <code>impl Trait</code> and <code>impl Trait</code> and MAYBE <code>dyn Trait</code>?)</p>\n<p>Also, as it will probably require more complex changes to <a href=\"http://generator_interior.rs\">generator_interior.rs</a>, and this lint is gated on a nightly feature, is it reasonable to split up making it work on ADT's and work on fn calls as separate PRs? cc <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> I believe was mentoring for this (its labor day so feel free to ignore my ping till another day)</p>",
        "id": 252224562,
        "sender_full_name": "Gus Wynn",
        "timestamp": 1630963363
    },
    {
        "content": "<p>I think it's fine to do this incrementally and split making with work on ADTs and fn calls as separate PRs.</p>",
        "id": 252340984,
        "sender_full_name": "eholk",
        "timestamp": 1631035637
    },
    {
        "content": "<p>While<code>#[must_use]</code> on an fn item makes sense (\"you must use the result of this specific call\"), I don't know that it makes as much sense for <code>#[must_not_suspend]</code> to apply to the results of specific functions. Tying it to types only seems pretty reasonable to me.</p>",
        "id": 252341323,
        "sender_full_name": "eholk",
        "timestamp": 1631035765
    },
    {
        "content": "<p>How to make it work with traits is kind of interesting though.</p>",
        "id": 252341369,
        "sender_full_name": "eholk",
        "timestamp": 1631035783
    },
    {
        "content": "<p>Like, does it apply if a type impls <em>any</em> trait marked with <code>#[must_not_suspend]</code>? Or does it only matter if the type is used as that trait?</p>",
        "id": 252341532,
        "sender_full_name": "eholk",
        "timestamp": 1631035840
    },
    {
        "content": "<p>It's definitely possible to do it fns/methods/etc, and the rfc does say this in the reference explanation: \"The must_not_suspend attribute is used to issue a diagnostic warning when a value is not \"used\". It can be applied to user-defined composite types (structs, enums and unions), traits.\"</p>\n<p>but like I said, it would require more complex changes to the generator yield analysis, which I would need help on. I think my plan is, this week sometime ill 1. figure out how to scope the attribute to just ADTs for now and 2. fix up the language and nice-looking-ness of the diagnostic that I have working</p>",
        "id": 252358462,
        "sender_full_name": "Gus Wynn",
        "timestamp": 1631042547
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"421986\">eholk</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/must_not_suspend.20annotations.20on.20fn's/near/252341532\">said</a>:</p>\n<blockquote>\n<p>Like, does it apply if a type impls <em>any</em> trait marked with <code>#[must_not_suspend]</code>? Or does it only matter if the type is used as that trait?</p>\n</blockquote>\n<p>no, I think for traits its JUST <code>impl Trait</code> (and maybe <code>dyn Trait</code>, i havent checked); or at least, thats how must_use works</p>",
        "id": 252358542,
        "sender_full_name": "Gus Wynn",
        "timestamp": 1631042584
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"421986\">eholk</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/must_not_suspend.20annotations.20on.20fn's/near/252341323\">said</a>:</p>\n<blockquote>\n<p>While<code>#[must_use]</code> on an fn item makes sense (\"you must use the result of this specific call\"), I don't know that it makes as much sense for <code>#[must_not_suspend]</code> to apply to the results of specific functions. Tying it to types only seems pretty reasonable to me.</p>\n</blockquote>\n<p>I agree with this</p>",
        "id": 252359308,
        "sender_full_name": "tmandry",
        "timestamp": 1631042946
    },
    {
        "content": "<p>okay nice, <code>check_attr.rs</code> here I come!</p>",
        "id": 252361249,
        "sender_full_name": "Gus Wynn",
        "timestamp": 1631043859
    },
    {
        "content": "<p>Oh yeah, <code>impl Trait</code> makes sense, and if that's the behavior of <code>must_use</code> anyway, then following that seems pretty reasonable.</p>",
        "id": 252371167,
        "sender_full_name": "eholk",
        "timestamp": 1631048389
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257428\">@Gus Wynn</span> - I've been spending a lot of time staring at <code>generator_interior.rs</code> lately, so feel free to reach out if you want help getting started if and when you come to that part.</p>",
        "id": 252371302,
        "sender_full_name": "eholk",
        "timestamp": 1631048423
    },
    {
        "content": "<p>impl trait is likely not too bad, in fact it may already work with the code I wrote (copied from the <code>must_use</code> code, copied cause its sufficiently different now)</p>\n<p>the difficulty with fn/method annotations is that the Visitor in generator_interior <code>visit_expr</code>'s and <code>visit_pat's</code>....so for things like<br>\n<code>let guard = thing()</code>, btw the time you are visiting the <code>guard</code> pat, you have lost the context of the <code>thing()</code> expr that you need to check for the <code>must_not_suspend</code> annotation. </p>\n<p>I could \"lift\" this up and instead override <code>visit_stmt</code> and then delegate to a function that checks the expr's, but i would have to be careful to not break the existing code, and also make sure I correctly pass context for ALL exprs that are callsites that produce values (i guess, non-temporary values?). <code>must_use</code> only cares about <code>StmtKind::Semi</code>, but its more complex for <code>must_not_suspend</code></p>\n<p>also for things like:</p>\n<div class=\"codehilite\"><pre><span></span><code>let thing = {\n    let inner = fn_that_has_the_attribute();\n    // do some other stuff\n   inner\n};\n</code></pre></div>\n<p>I have NO idea how to pass that context along. The generator visitor will visit the <code>thing</code> pattern and if the type ITSELF (be that impl trait or an ADT) has the annotation, then its ez to discover that here, but it seems in general impossible to know if a value came from a function call that has a certain attribute?</p>\n<p>Like, with <code>must_use</code>, its the callsite alone that you have to check, but with <code>must_not_suspend</code> it seems really difficult?</p>",
        "id": 252375091,
        "sender_full_name": "Gus Wynn",
        "timestamp": 1631050438
    },
    {
        "content": "<p>Yeah, that makes sense. I think the way I'd approach it (not saying it's the right idea, or even that it will work), is to try to mark the type of the return from <code>fn_that_has_the_attribute()</code> as <code>must_not_suspend</code>.</p>",
        "id": 252383728,
        "sender_full_name": "eholk",
        "timestamp": 1631055966
    },
    {
        "content": "<p>Basically, generator interior only gathers up types that are live across a yield, so what I'd try to do is make a \"virtual singleton type\" that represents the return value of a <code>must_not_suspend</code> function.</p>",
        "id": 252383854,
        "sender_full_name": "eholk",
        "timestamp": 1631056036
    },
    {
        "content": "<p>I <em>think</em> the right way to do this is to make <code>InteriorVisitor::yield</code> take another flag that says whether the thing we're yielding has the <code>must_not_suspend</code> attribute.</p>",
        "id": 252384193,
        "sender_full_name": "eholk",
        "timestamp": 1631056238
    },
    {
        "content": "<p>and then do the appropriate plumbing from there...</p>",
        "id": 252384220,
        "sender_full_name": "eholk",
        "timestamp": 1631056256
    },
    {
        "content": "<p>oh yeah, then <code>GeneratorInteriorTypeCause</code> would get an extra field that says whether the <code>must_not_suspend</code> attribute was given.</p>",
        "id": 252384336,
        "sender_full_name": "eholk",
        "timestamp": 1631056328
    },
    {
        "content": "<p>Actually, you might even be able to recover the attribute from the <code>expr</code> field in <code>GeneratorInteriorTypeCause</code>.</p>",
        "id": 252384426,
        "sender_full_name": "eholk",
        "timestamp": 1631056407
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"421986\">eholk</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/must_not_suspend.20annotations.20on.20fn's/near/252383728\">said</a>:</p>\n<blockquote>\n<p>Yeah, that makes sense. I think the way I'd approach it (not saying it's the right idea, or even that it will work), is to try to mark the type of the return from <code>fn_that_has_the_attribute()</code> as <code>must_not_suspend</code>.</p>\n</blockquote>\n<p>hmm, that would infect other instances of that type tho?</p>",
        "id": 252386745,
        "sender_full_name": "Gus Wynn",
        "timestamp": 1631058196
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"421986\">eholk</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/must_not_suspend.20annotations.20on.20fn's/near/252384336\">said</a>:</p>\n<blockquote>\n<p>oh yeah, then <code>GeneratorInteriorTypeCause</code> would get an extra field that says whether the <code>must_not_suspend</code> attribute was given.</p>\n</blockquote>\n<p>currently I lint right before I add the TypeCause, but I like this idea</p>",
        "id": 252386769,
        "sender_full_name": "Gus Wynn",
        "timestamp": 1631058225
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257428\">Gus Wynn</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/must_not_suspend.20annotations.20on.20fn's/near/252386745\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"421986\">eholk</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/must_not_suspend.20annotations.20on.20fn's/near/252383728\">said</a>:</p>\n<blockquote>\n<p>Yeah, that makes sense. I think the way I'd approach it (not saying it's the right idea, or even that it will work), is to try to mark the type of the return from <code>fn_that_has_the_attribute()</code> as <code>must_not_suspend</code>.</p>\n</blockquote>\n<p>hmm, that would infect other instances of that type tho?</p>\n</blockquote>\n<p>Yeah, you don't want to mark the type itself. I was thinking more like making an implicit newtype for each return value from when the function is called.</p>",
        "id": 252485742,
        "sender_full_name": "eholk",
        "timestamp": 1631116609
    },
    {
        "content": "<p>oh i meant to send this last night: \"I still think it may be worth it to do the ADT part separately, first\" <br>\nas a good chunk of the code will be shared</p>",
        "id": 252492770,
        "sender_full_name": "Gus Wynn",
        "timestamp": 1631119191
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"421986\">eholk</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/must_not_suspend.20annotations.20on.20fn's/near/252485742\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257428\">Gus Wynn</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/must_not_suspend.20annotations.20on.20fn's/near/252386745\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"421986\">eholk</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/must_not_suspend.20annotations.20on.20fn's/near/252383728\">said</a>:</p>\n<blockquote>\n<p>Yeah, that makes sense. I think the way I'd approach it (not saying it's the right idea, or even that it will work), is to try to mark the type of the return from <code>fn_that_has_the_attribute()</code> as <code>must_not_suspend</code>.</p>\n</blockquote>\n<p>hmm, that would infect other instances of that type tho?</p>\n</blockquote>\n<p>Yeah, you don't want to mark the type itself. I was thinking more like making an implicit newtype for each return value from when the function is called.</p>\n</blockquote>\n<p>thats something to look into!</p>",
        "id": 252492796,
        "sender_full_name": "Gus Wynn",
        "timestamp": 1631119199
    },
    {
        "content": "<p>I think the <code>GeneratorTypeInteriorCause</code> change will have kind of the same effect as making an implicit newtype, at least as far as <code>generator_interior.rs</code> is concerned</p>",
        "id": 252498595,
        "sender_full_name": "eholk",
        "timestamp": 1631121375
    },
    {
        "content": "<p>Ah I see</p>",
        "id": 252499339,
        "sender_full_name": "Gus Wynn",
        "timestamp": 1631121672
    },
    {
        "content": "<p>its mostly working: <a href=\"https://github.com/rust-lang/rust/pull/88865\">https://github.com/rust-lang/rust/pull/88865</a></p>",
        "id": 252926038,
        "sender_full_name": "Gus Wynn",
        "timestamp": 1631383957
    },
    {
        "content": "<p>why would hashing a TyKind cause a hash of RegionKind?</p>",
        "id": 252927040,
        "sender_full_name": "Gus Wynn",
        "timestamp": 1631385120
    },
    {
        "content": "<p>I did come up with one place that having <code>must_not_suspend</code> on a fn/method might be nice: we can put it on the <code>lock</code> method of mutex, so even if someone forgets to unwrap/handle the poison error, they get the lint (ie, if the <code>Result&lt;MutexGuard, PoisonError&gt;</code> is held across the await point. This may also work if we went with <span class=\"user-mention\" data-user-id=\"124288\">@oli</span> 's suggestion to use an auto-trait like <code>?Suspend</code> to mark safety</p>\n<p>but I am not sure if its worth it</p>\n<p>in any case: <a href=\"https://github.com/rust-lang/rust/pull/89303\">https://github.com/rust-lang/rust/pull/89303</a></p>",
        "id": 255070954,
        "sender_full_name": "Gus Wynn",
        "timestamp": 1632757613
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257428\">@Gus Wynn</span> I'm confused about this example</p>",
        "id": 256078247,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1633361492
    },
    {
        "content": "<p>doesn't <code>MutexGuard</code> have a \"must not suspend\" annotation?</p>",
        "id": 256078272,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1633361504
    },
    {
        "content": "<p>is the problem that it doesn't \"bubble up\" through <code>Result</code>?</p>",
        "id": 256078292,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1633361511
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/must_not_suspend.20annotations.20on.20fn's/near/256078292\">said</a>:</p>\n<blockquote>\n<p>is the problem that it doesn't \"bubble up\" through <code>Result</code>?</p>\n</blockquote>\n<p>yeah this is the problem</p>\n<p>We could special case result, but that seems problematic.</p>",
        "id": 256079625,
        "sender_full_name": "Gus Wynn",
        "timestamp": 1633361988
    },
    {
        "content": "<p>(we do bubble up for things like <code>Box</code>)</p>",
        "id": 256079718,
        "sender_full_name": "Gus Wynn",
        "timestamp": 1633362012
    },
    {
        "content": "<p>I think we should probably bubble</p>",
        "id": 256080827,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1633362440
    },
    {
        "content": "<p>Though I've kind of been altering my opinion on this</p>",
        "id": 256080851,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1633362450
    },
    {
        "content": "<p>I also think that <code>#[must_use]</code> should behave analogously</p>",
        "id": 256080867,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1633362459
    },
    {
        "content": "<p>I think my opinion before was that we should fix this in a comparable way for the two</p>",
        "id": 256080907,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1633362479
    },
    {
        "content": "<p>What would be the logic? arbitrary deep nesting within an ADT? If we have that, we would need a way to turn it off, as someone could be making a wrapper that IS suspendable</p>",
        "id": 256080991,
        "sender_full_name": "Gus Wynn",
        "timestamp": 1633362500
    },
    {
        "content": "<p>There were a few proposals</p>",
        "id": 256081531,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1633362705
    },
    {
        "content": "<p>One was arbitrary deep nesting, another was using a trait</p>",
        "id": 256081549,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1633362711
    },
    {
        "content": "<p>Yeah, I think Oli may have mentioned that in review. an auto-trait like Unpin, <code>`#[must_not_suspend]</code> is like <code>PhantomUnSuspend</code>, and people can override with <code>impl Suspend for Thing</code>, similar concept for <code>must_use</code></p>",
        "id": 256082000,
        "sender_full_name": "Gus Wynn",
        "timestamp": 1633362876
    },
    {
        "content": "<p>Would adding bubbling like this be a breaking change? it may increase the number of warnings people get by a lot</p>",
        "id": 256082076,
        "sender_full_name": "Gus Wynn",
        "timestamp": 1633362901
    },
    {
        "content": "<p>it's not considered a breaking change, because the cap-lint mechanism ensures that your dependencies don't break, but it would certainly take some preparation and consideration</p>",
        "id": 256082678,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1633363141
    },
    {
        "content": "<p>what is \"cap-lint\"? Does rustc ignore <code>deny</code> directives on deps?</p>",
        "id": 256082819,
        "sender_full_name": "Gus Wynn",
        "timestamp": 1633363193
    },
    {
        "content": "<p><a href=\"https://rust-lang.github.io/rfcs/1193-cap-lints.html\">https://rust-lang.github.io/rfcs/1193-cap-lints.html</a> oh nice, how did I not know about this?</p>",
        "id": 256084189,
        "sender_full_name": "Gus Wynn",
        "timestamp": 1633363651
    },
    {
        "content": "<p>(another interesting quirk is that <code>impl Future</code> and async fn's trigger the <code>must_use</code> lint on Future, but concrete implementors dont. <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=807add1ad9d9fd8f7481173d5f83ce22\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=807add1ad9d9fd8f7481173d5f83ce22</a><br>\nis that something we want to reconcile as well?)</p>",
        "id": 256264272,
        "sender_full_name": "Gus Wynn",
        "timestamp": 1633446983
    },
    {
        "content": "<p>We put a manual <code>#[must_use]</code> on most of the manual future impls in Tokio, but I guess not that one</p>",
        "id": 256387240,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1633515228
    },
    {
        "content": "<p>Interesting, it would be nice to have that automatically, but that seems like it would have to be solved orthogonally to the nesting <code>must_use</code>, <code>must_not_suspend</code> ask</p>",
        "id": 256459374,
        "sender_full_name": "Gus Wynn",
        "timestamp": 1633544537
    }
]