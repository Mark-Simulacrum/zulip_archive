[
    {
        "content": "<p><a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=d68f48effd9419241e5323bb3cf86148\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=d68f48effd9419241e5323bb3cf86148</a></p>",
        "id": 249676640,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1629173063
    },
    {
        "content": "<p>This example doesn't type check because the two async blocks are !Send, therefore foo is not !Send, which is required by spawn</p>",
        "id": 249676661,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1629173111
    },
    {
        "content": "<p>One could fix this by using a Mutex or something, but it seems vaguely reasonable to fix this without needing more atomics, etc, by some kind of scoping composability of futures</p>",
        "id": 249676716,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1629173184
    },
    {
        "content": "<p>I.e., one could imagine that a future which owns the Cell and evaluates to join, should be Send, even though the join future is not Send because internal to that future, the sub-futures will be evaluated on the same thread and the reference to the Cell does not exist outside the future</p>",
        "id": 249676791,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1629173322
    },
    {
        "content": "<p>Is it possible to write something like that today (using async, rather than writing the futures manually)? Or is this on the radar for async work? (It feels a bit similar to the scopes deliverable, but I don't think it quite addresses it)</p>",
        "id": 249676857,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1629173420
    },
    {
        "content": "<p>Niko and I were actually talking about this a bit yesterday.. ideally we can separate the original call from the \"polling state\" somehow</p>",
        "id": 249788825,
        "sender_full_name": "tmandry",
        "timestamp": 1629240515
    },
    {
        "content": "<blockquote>\n<p>I.e., one could imagine that a future which owns the Cell and evaluates to join, should be Send, even though the join future is not Send because internal to that future, the sub-futures will be evaluated on the same thread and the reference to the Cell does not exist outside the future</p>\n</blockquote>\n<p>That would need to be a guarantee that is given by the executor. And executors which are multi-threaded don't provide it. They might move the task between each <code>.poll()</code> operation.</p>",
        "id": 249888026,
        "sender_full_name": "Matthias247",
        "timestamp": 1629309587
    },
    {
        "content": "<p>If you have an executor which provides guarantees of not moving tasks between threads (like a single-threaded one), it can take <code>!Send</code> <code>Future</code>s  and everything is fine. tokio <code>LocalSet</code> also does something like this.</p>",
        "id": 249888304,
        "sender_full_name": "Matthias247",
        "timestamp": 1629309668
    },
    {
        "content": "<p>What I like to see for a while is that once we have structured concurrency you can create a sub-scope which has stronger executor guarantees, like tying everything onto a single thread. And from there on you can do <code>.spawn_local(task)</code> to start non-synchronized tasks</p>",
        "id": 249888536,
        "sender_full_name": "Matthias247",
        "timestamp": 1629309745
    },
    {
        "content": "<p>Although it seems like I might just have gotten half of the question, and the other half is why it requires <code>Sync</code> here and not just <code>Send</code>. I'm not sure on this.</p>",
        "id": 249889605,
        "sender_full_name": "Matthias247",
        "timestamp": 1629310163
    },
    {
        "content": "<p>Right, this has to do with Rust not having a concept of \"not <code>Send</code> unless you move every instance simultaneously\", which applies to both <code>Rc</code> and <code>&amp;T</code> for non-Sync <code>T</code>.</p>",
        "id": 249902481,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1629316053
    },
    {
        "content": "<p>^ that's interesting. to me it feels conceptually similar to self-borrows</p>",
        "id": 249914769,
        "sender_full_name": "tmandry",
        "timestamp": 1629322416
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"204219\">Matthias247</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/Example.20of.20odd.20composing.20of.20Send/near/249888026\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>I.e., one could imagine that a future which owns the Cell and evaluates to join, should be Send, even though the join future is not Send because internal to that future, the sub-futures will be evaluated on the same thread and the reference to the Cell does not exist outside the future</p>\n</blockquote>\n<p>That would need to be a guarantee that is given by the executor. And executors which are multi-threaded don't provide it. They might move the task between each <code>.poll()</code> operation.</p>\n</blockquote>\n<p>You could have an executor which assigns futures to a potentially different thread on spawn, but does not move them between polls. That seems like a common enough use case that's worth considering</p>",
        "id": 249914937,
        "sender_full_name": "tmandry",
        "timestamp": 1629322515
    },
    {
        "content": "<p>You could. But to make use of that you would have to change the spawn signature, since the <code>Future</code> type is the same between having been polled or not being polled yet. Something along: <code>spawn&lt;Func: Send + FnOnce() -&gt; Fut, Fut: Future&gt;(f:  Func)</code>. </p>\n<p>Not sure if you would want that, or just start/enter a sub-scope first which is ok with <code>!Send</code> and from there on spawn the tasks.</p>",
        "id": 249946376,
        "sender_full_name": "Matthias247",
        "timestamp": 1629354367
    },
    {
        "content": "<p>I get that the executor can move the future between threads between polls and that's why the futures need to be Send, I'm wondering if its possible to deduce somehow that the Join future should be Send even though the 'child' futures are !Send, essentially because its OK to move the 'whole thing' but not 'components of the thing'</p>",
        "id": 250241417,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1629586362
    },
    {
        "content": "<p>Theoretically we could have an API like this</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">with_unsync_ref</span><span class=\"o\">&lt;</span><span class=\"n\">T</span>: <span class=\"nb\">Send</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">O</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">value</span>: <span class=\"nc\">T</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">f</span>: <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">S</span>: <span class=\"o\">?</span><span class=\"nb\">Send</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">AsyncFnOnce</span><span class=\"o\">&lt;</span><span class=\"p\">(</span><span class=\"n\">Ref</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">,),</span><span class=\"w\"> </span><span class=\"n\">Output</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">O</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Future</span>: <span class=\"nc\">S</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">O</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>The HRTB would require that the <code>AsyncFnOnce</code> doesn't use any <code>!Send</code> types inside it other than the <code>Ref</code>, so the future returned by <code>with_unsync_ref</code> would always be <code>Send</code>.</p>",
        "id": 250256755,
        "sender_full_name": "Kestrer",
        "timestamp": 1629610983
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/Example.20of.20odd.20composing.20of.20Send/near/250241417\">said</a>:</p>\n<blockquote>\n<p>I get that the executor can move the future between threads between polls and that's why the futures need to be Send, I'm wondering if its possible to deduce somehow that the Join future should be Send even though the 'child' futures are !Send, essentially because its OK to move the 'whole thing' but not 'components of the thing'</p>\n</blockquote>\n<p>In what scenario would that be ok?</p>",
        "id": 250534082,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629832506
    },
    {
        "content": "<p>When you have a future containing a Cell and a reference to the Cell. You can move the whole thing, but can't separate the owned value &amp; reference because that could cause data races.</p>",
        "id": 250545073,
        "sender_full_name": "Kestrer",
        "timestamp": 1629837458
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> see the playground at the start of the thread. I haven't thought about generalisations</p>",
        "id": 250553801,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1629841623
    },
    {
        "content": "<p>Here's a strawman called <a href=\"https://hackmd.io/m5ooA3drSJWjHQYJlJ5KxQ?view\">Shards</a> that I think could work for expressing this in the language. I'm not proposing actually adding this, so do with it what you will (:</p>",
        "id": 251772474,
        "sender_full_name": "tmandry",
        "timestamp": 1630610897
    },
    {
        "content": "<blockquote>\n<ul>\n<li>This is ugly and not worth complicating the language!<ul>\n<li>I tend to agree. It could serve as a starting point for a better idea or a more general “capabilities” mechanism, however.</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p>I also tend to agree, but I'm intrigued by the idea of a more general capabilities system. Have you thought any about what that would look like, <span class=\"user-mention\" data-user-id=\"116883\">@tmandry</span>?</p>",
        "id": 251780048,
        "sender_full_name": "eholk",
        "timestamp": 1630613954
    },
    {
        "content": "<p>I actually kind of like the idea, I just think it's weird to have something so similar to lifetimes alongside the lifetimes system</p>",
        "id": 251780232,
        "sender_full_name": "eholk",
        "timestamp": 1630614032
    },
    {
        "content": "<p>not really. <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> mentioned it to me in passing</p>",
        "id": 251780389,
        "sender_full_name": "tmandry",
        "timestamp": 1630614109
    },
    {
        "content": "<p>I assume there is prior art in type systems research, I’m just not familiar with it</p>",
        "id": 251780602,
        "sender_full_name": "tmandry",
        "timestamp": 1630614211
    }
]