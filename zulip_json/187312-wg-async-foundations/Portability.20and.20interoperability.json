[
    {
        "content": "<p>I am looking to 'officially' get started on the portability and interoperability initiative. This is a thread for anyone who wants to be involved to say 'hi', or for anyone with concerns/ideas/thoughts (especially around planning) to share them.</p>",
        "id": 264001282,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1638884106
    },
    {
        "content": "<p>I've just published a blog post with things I think are important and some vague semblance of a plan for tackling the topic: <a href=\"https://www.ncameron.org/blog/portable-and-interoperable-async-rust/\">https://www.ncameron.org/blog/portable-and-interoperable-async-rust/</a></p>",
        "id": 264001384,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1638884158
    },
    {
        "content": "<p>I think the next step for me will be clarifying the problems around AsyncRead and AsyncWrite, and generally starting a discussion there.</p>",
        "id": 264001521,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1638884204
    },
    {
        "content": "<p>Hi <span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span></p>",
        "id": 264002874,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1638884792
    },
    {
        "content": "<p>I think you forgot to edit this TODO out :)</p>\n<blockquote>\n<p>(e.g., Tokio's requirement that all async code (TODO clarify) is within the context of an executor)</p>\n</blockquote>",
        "id": 264002920,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1638884822
    },
    {
        "content": "<p>Heh, thanks, I did</p>",
        "id": 264004549,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1638885541
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"363998\">@Ibraheem Ahmed</span> anything in particular you're interested in? Thoughts on priorities etc.?</p>",
        "id": 264005720,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1638885980
    },
    {
        "content": "<p>Also \"hi\" I guess</p>",
        "id": 264006517,
        "sender_full_name": "Dirkjan Ochtman",
        "timestamp": 1638886332
    },
    {
        "content": "<p>I'm very interested in having a solution for <code>AsyncRead</code>/<code>AsyncWrite</code> that is shared across tokio and other runtimes</p>",
        "id": 264006585,
        "sender_full_name": "Dirkjan Ochtman",
        "timestamp": 1638886370
    },
    {
        "content": "<p>it's too bad that the <code>ReadBuf</code> PR seems to be stalled :(</p>",
        "id": 264006620,
        "sender_full_name": "Dirkjan Ochtman",
        "timestamp": 1638886388
    },
    {
        "content": "<p>Which ReadBuf PR?</p>",
        "id": 264006936,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1638886516
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/pull/81156\">https://github.com/rust-lang/rust/pull/81156</a></p>",
        "id": 264007860,
        "sender_full_name": "Dirkjan Ochtman",
        "timestamp": 1638886924
    },
    {
        "content": "<p>FWIW my interest is mainly as a maintainer of quinn and trust-dns, for both of which I/O abstraction is of course very important</p>",
        "id": 264009075,
        "sender_full_name": "Dirkjan Ochtman",
        "timestamp": 1638887447
    },
    {
        "content": "<p>Quinn currently only supports Tokio, Trust-DNS has a custom trait to abstract over runtimes (one important user is Fuchsia)</p>",
        "id": 264009189,
        "sender_full_name": "Dirkjan Ochtman",
        "timestamp": 1638887508
    },
    {
        "content": "<p>I agree that AsyncRead/Write are the highest priority items right now</p>",
        "id": 264014257,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1638889865
    },
    {
        "content": "<p>Hi, I have read a Twitter about this issue, is there anything I can help or contribute?</p>",
        "id": 264016311,
        "sender_full_name": "Xuanwo",
        "timestamp": 1638890831
    },
    {
        "content": "<p>Hi! Yes there is lots to do! At the moment we’re at the planning and requirements gathering stage, so the most useful thing to do is share experiences, constraints, or wishes. I’ll have some links soon for places to follow for more concrete ways to contribute</p>",
        "id": 264018764,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1638891804
    },
    {
        "content": "<p>For wish: as a lib developer, I don't want to make decisions of async runtime for my end users. As described in the blog post, <code>AsyncRead</code> / <code>AsyncWrite</code> in std makes it possible to develop libs that no depends on async runtime.</p>",
        "id": 264019295,
        "sender_full_name": "Xuanwo",
        "timestamp": 1638892003
    },
    {
        "content": "<p>There's also the question of when we're ready to start adding async primitives to std, that are already runtime agnostic</p>",
        "id": 264020068,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1638892299
    },
    {
        "content": "<p>e.g future combinators, locks, channels</p>",
        "id": 264020119,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1638892323
    },
    {
        "content": "<p>I suppose that mostly just needs an RFC</p>",
        "id": 264020166,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1638892331
    },
    {
        "content": "<p>We should talk with the libs team about the specifics. My impression is that currently a lot of the  things like locks and channels are tied to the runtime and we will need to do some work to separate them out. The futures combinators could be added to std, but I'm not sure how much motivation there is to do so - using async/await is the preferred way to use futures and then the combinators aren't needed. If the combinators are only used by a relatively small number of users, then leaving them in the futures crate seems fine</p>",
        "id": 264024663,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1638893951
    },
    {
        "content": "<p>Locks and channels aren't tied to the runtime</p>",
        "id": 264025352,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1638894195
    },
    {
        "content": "<p>All of tokio::sync is runtime agnostic</p>",
        "id": 264025382,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1638894208
    },
    {
        "content": "<p>The stuff in <code>tokio::sync</code> does have some runtime specific stuff, e.g. support for Tokio's coop system and there are PRs for (unstable) tracing integration, though these features will just disable themselves when used outside of a Tokio runtime, so they don't really tie them to the runtime.</p>",
        "id": 264030511,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1638895905
    },
    {
        "content": "<p>Is it? That would make things much easier if true. I thought that the Tokio libraries allow for pre-emption of Tokio tasks in various places? My understanding is also that even if they are runtime agnostic, they are different from the equivalents in the futures crate (and async std/smol)</p>",
        "id": 264030523,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1638895908
    },
    {
        "content": "<p>There is a repo for discussing this work: <a href=\"https://github.com/nrc/portable-interoperable\">https://github.com/nrc/portable-interoperable</a> I created some issues today to discuss high level goals and principles. I also created an issue specifically for AsyncRead/AsyncWrite. Following that repo (or a specific issue/label) will probably be the best way to keep up to date with this work.</p>",
        "id": 264036494,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1638897843
    },
    {
        "content": "<blockquote>\n<p>using async/await is the preferred way to use futures and then the combinators aren't needed.</p>\n</blockquote>\n<p>That doesn’t appear to account for things like join/select/buffer_unordered/etc.  — any of the combinators that do interesting async-smart operations.</p>",
        "id": 264040244,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1638899176
    },
    {
        "content": "<p>Yeah, join and select are definitely still relevant. I don't know buffer_unordered so well. I'd hope to move join/select macros into std, though again there are runtime-specific complications</p>",
        "id": 264043892,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1638899943
    },
    {
        "content": "<p>What runtime specific complications are there for join or select?</p>",
        "id": 264044459,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1638900094
    },
    {
        "content": "<p>I don't believe there are any</p>",
        "id": 264044642,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1638900154
    },
    {
        "content": "<p>Also, buffer_unordered is a stream combinator, there are a ton of those that would be useful</p>",
        "id": 264044718,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1638900193
    },
    {
        "content": "<p>Many of those are blocked/waiting for on async closures, and the stream rfc chose to leave them out for now</p>",
        "id": 264045117,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1638900327
    },
    {
        "content": "<p>I’m not totally up to speed on the macros, iirc they are not integrated with the runtimes or anything, but the different runtimes do have different implementations</p>",
        "id": 264049995,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1638902028
    },
    {
        "content": "<p>Async iteration/streams are a topic all of their own, so are out of scope for the interoperability initiative</p>",
        "id": 264050193,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1638902093
    },
    {
        "content": "<p>For select, yeah there is a difference between the futures and tokio version</p>",
        "id": 264050235,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1638902108
    },
    {
        "content": "<p>Futures should move to the tokio method though</p>",
        "id": 264050282,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1638902127
    },
    {
        "content": "<p>There's an open issue about it, it's just that no one's done it yet :)</p>",
        "id": 264050422,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1638902170
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/futures-rs/issues/1989\">https://github.com/rust-lang/futures-rs/issues/1989</a></p>",
        "id": 264050887,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1638902303
    },
    {
        "content": "<p>Tokio based their version on ^</p>",
        "id": 264051063,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1638902366
    },
    {
        "content": "<p>I'm not sure whether this fits into the interoperability initiative though</p>",
        "id": 264051331,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1638902464
    },
    {
        "content": "<p>Good to know, thanks!</p>",
        "id": 264051808,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1638902628
    },
    {
        "content": "<p>I think it does, I want things like select to be in std, not each runtime having their own version</p>",
        "id": 264051933,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1638902655
    },
    {
        "content": "<p>I agree on wanting them in std (eventually), but the current ones in the crates <em>are</em> interoperable, AFAICT. That's why it seems out of scope for the <strong>interoperability</strong> initiative. Maybe the name is artificially limiting?</p>",
        "id": 264055285,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1638903926
    },
    {
        "content": "<p>About \"eventually\" — it'd be nice if a \"good amount\" of the stdlib combinators stabilized when <code>std::Stream</code> does, to minimize the amount of churn as people could switch once.</p>",
        "id": 264055585,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1638904061
    },
    {
        "content": "<p>There shouldn't be much churn, futures::Stream will just become <code>pub use std::stream::Stream</code></p>",
        "id": 264056209,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1638904324
    },
    {
        "content": "<p>assuming that it's unchanged, sure.</p>",
        "id": 264056474,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1638904448
    },
    {
        "content": "<p>re the <code>select</code> macros, this had recent activity: <a href=\"https://stackoverflow.com/q/60811657/155423\">What is the difference between futures::select! and tokio::select?</a></p>",
        "id": 264056938,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1638904675
    },
    {
        "content": "<p>I think select! will need an RFC as there's quite a bit of design work there, but join! is more straightforward</p>",
        "id": 264059013,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1638905575
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/Portability.20and.20interoperability/near/264001282\">said</a>:</p>\n<blockquote>\n<p>I am looking to 'officially' get started on the portability and interoperability initiative. This is a thread for anyone who wants to be involved to say 'hi', or for anyone with concerns/ideas/thoughts (especially around planning) to share them.</p>\n</blockquote>\n<p>\"hi\". :)</p>",
        "id": 264060094,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638906054
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/Portability.20and.20interoperability/near/264030523\">said</a>:</p>\n<blockquote>\n<p>Is it? That would make things much easier if true. I thought that the Tokio libraries allow for pre-emption of Tokio tasks in various places? My understanding is also that even if they are runtime agnostic, they are different from the equivalents in the futures crate (and async std/smol)</p>\n</blockquote>\n<p>That's a key issue, yeah. People don't like ending up with 400 dependencies because they end up pulling in <em>three different</em> implementations of channels, locks, primitives, futures, etc.</p>",
        "id": 264060446,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638906194
    },
    {
        "content": "<p>Having <em>one</em> is fine, but then that means all your dependencies have to be prepared to work with that <em>one</em>, which means being more ecosystem-agnostic and having lots of feature flags, which is painful.</p>",
        "id": 264060541,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638906240
    },
    {
        "content": "<p>Also, in addition to portability, I'm personally very interested in the proposals that have been discussed to use <code>impl Future</code> to support implementing traits without using <code>Poll</code>.</p>",
        "id": 264061001,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638906417
    },
    {
        "content": "<p><code>select!</code> is more complex, but <code>race!</code> is simpler and could be implemented</p>",
        "id": 264071738,
        "sender_full_name": "Kestrer",
        "timestamp": 1638911199
    },
    {
        "content": "<p><code>race!</code> being the macro that takes a list of futures that all resolve to the same type and gives the output of the first one</p>",
        "id": 264071784,
        "sender_full_name": "Kestrer",
        "timestamp": 1638911231
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"226095\">@Dirkjan Ochtman</span> I took some time and read through the 1000+ line patch today. <a href=\"https://github.com/rust-lang/rust/pull/81156#issuecomment-988298256\">https://github.com/rust-lang/rust/pull/81156#issuecomment-988298256</a></p>",
        "id": 264084082,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638916745
    },
    {
        "content": "<p>Hi folks, I've written my own async runtime, and would love to see better interop. I agree with what others have said, that the IO traits are probably the most important thing. it would also be nice to see an agreed upon approach for select (right now my pref would be tokio-style that works on bare futures, unlike futures-rs, unless I misunderstand something; also ideally the impl wouldn't need to alloc or else people may still drag around their own select like me)</p>",
        "id": 264115314,
        "sender_full_name": "Justin Karneges",
        "timestamp": 1638943196
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> awesome, thanks!</p>",
        "id": 264119085,
        "sender_full_name": "Dirkjan Ochtman",
        "timestamp": 1638947310
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/Portability.20and.20interoperability/near/264061001\">said</a>:</p>\n<blockquote>\n<p>Also, in addition to portability, I'm personally very interested in the proposals that have been discussed to use <code>impl Future</code> to support implementing traits without using <code>Poll</code>.</p>\n</blockquote>\n<p>is that specific to join/select macros or is this a more general proposal?</p>",
        "id": 264136890,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1638959632
    },
    {
        "content": "<p>I filed an issue about select: <a href=\"https://github.com/nrc/portable-interoperable/issues/6\">https://github.com/nrc/portable-interoperable/issues/6</a></p>",
        "id": 264138768,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1638960767
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"218683\">@Alice Ryhl</span> Do you know how Tokio folk feel about the RFC 2930 approach to reading into an uninit buffer? Does it cover all the motivations for a similar setup in Tokio's AsyncRead trait?</p>",
        "id": 264161041,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1638973121
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256841\">@Nick Cameron</span> what's the solution to dyn-safe async traits that doesn't require inline async?</p>",
        "id": 264166208,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1638975454
    },
    {
        "content": "<p>A proc macro currently named dyner, basically it creates a proxy trait with the argument boxed when using trait objects</p>",
        "id": 264166492,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1638975574
    },
    {
        "content": "<p>I'm not sure that approach is a good idea for AsyncRead/Write</p>",
        "id": 264167211,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1638975822
    },
    {
        "content": "<p>why not?</p>",
        "id": 264167759,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1638976019
    },
    {
        "content": "<p>It adds an allocation to a common hot path</p>",
        "id": 264168085,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1638976167
    },
    {
        "content": "<p>The boxing only happens once when the future is created (not while it is being polled), so it seems to me like a pretty minimal allocation. Given that the context is that IO is happening, it seems like a single allocation shouldn't make a difference relative to the time the IO takes</p>",
        "id": 264168746,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1638976441
    },
    {
        "content": "<p>It adds an allocation every time you read or write from/to the stream</p>",
        "id": 264173793,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1638978181
    },
    {
        "content": "<p>Why?</p>",
        "id": 264174263,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1638978365
    },
    {
        "content": "<p>Because it would be:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">read</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">buf</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">])</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">BoxFuture</span><span class=\"o\">&lt;'</span><span class=\"nb\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">io</span>::<span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"kt\">usize</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">write</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">buf</span>: <span class=\"kp\">&amp;</span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">])</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">BoxFuture</span><span class=\"o\">&lt;'</span><span class=\"nb\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">io</span>::<span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"kt\">usize</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>In a dyn context.</p>",
        "id": 264177575,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1638979600
    },
    {
        "content": "<p>So something like <code>read_to_end</code> on a <code>Box&lt;dyn AsyncRead&gt;</code> could potentially need a bunch more allocations.</p>",
        "id": 264178719,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1638980058
    },
    {
        "content": "<p>Ah I see, you’re thinking of functions which call read or write multiple times, that makes sense, thanks!</p>",
        "id": 264180162,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1638980706
    },
    {
        "content": "<p>Is the plan at this point for AsyncRead/Write to define async functions or poll functions?</p>",
        "id": 264181083,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1638981086
    },
    {
        "content": "<p>There is no plan at present. Existing versions use poll functions, many people assume we should use async functions (and that is mentioned in the vision doc) but I don’t think it has been discussed in depth</p>",
        "id": 264181286,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1638981172
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"363998\">@Ibraheem Ahmed</span> thinking about this a bit more, something like read_to_end should be implemented outside the dynamic context, so will call read directly (ie there is no allocation), the allocation happens in the stub for read_to_end</p>",
        "id": 264181552,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1638981291
    },
    {
        "content": "<p>This would still be a problem for external functions calling read repeatedly though</p>",
        "id": 264181625,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1638981323
    },
    {
        "content": "<p>Ah yeah, you're right</p>",
        "id": 264186682,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1638983229
    },
    {
        "content": "<blockquote>\n<p>This would still be a problem for external functions calling read repeatedly though</p>\n</blockquote>\n<p>Yes, something like streaming a <a href=\"https://docs.rs/http-types/latest/src/http_types/body.rs.html#56\"><code>tide::Body</code></a>.</p>",
        "id": 264187495,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1638983588
    }
]