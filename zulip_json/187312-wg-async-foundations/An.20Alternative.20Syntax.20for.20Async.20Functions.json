[
    {
        "content": "<p>I've been thinking about the async fn in traits problem for a while, and I decided to flesh out by thoughts in writing. The basic idea is that <code>async fn foo() -&gt; usize;</code> would become <code>async fn foo() -&gt; impl Future&lt;Output = usize&gt;;</code>, which has numerous benefits: <a href=\"https://ibraheem.ca/writings/an-alternative-async-fn-syntax/\">https://ibraheem.ca/writings/an-alternative-async-fn-syntax/</a></p>",
        "id": 251601535,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1630518857
    },
    {
        "content": "<p>All that being said, I doubt this change will happen, but after <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> said that implicit await was doable across an edition, I thought I'd put it out there :)</p>",
        "id": 251606291,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1630520710
    },
    {
        "content": "<p>One thing that convinced me against this is that <code>impl Trait</code> does not capture lifetimes by default, so it becomes actually reasonably awkward to write most functions.</p>",
        "id": 251606599,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1630520831
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/An.20Alternative.20Syntax.20for.20Async.20Functions/near/251606599\">said</a>:</p>\n<blockquote>\n<p>One thing that convinced me against this is that <code>impl Trait</code> does not capture lifetimes by default, so it becomes actually reasonably awkward to write most functions.</p>\n</blockquote>\n<p><code>+ 'in</code> solves that</p>",
        "id": 251608411,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1630521582
    },
    {
        "content": "<p>I just realized how weird it is that <code>impl Trait</code> does not capture input lifetimes by default, given that <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=fb4aef6a488936fb5d141583a3f1747b\">it does capture input types</a>. I wonder how breaking it would be to change that. It would certainly benefit this proposal.</p>",
        "id": 251626656,
        "sender_full_name": "Kestrer",
        "timestamp": 1630529258
    },
    {
        "content": "<p>I agree that this is odd</p>",
        "id": 251634536,
        "sender_full_name": "tmandry",
        "timestamp": 1630532861
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"363998\">Ibraheem Ahmed</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/An.20Alternative.20Syntax.20for.20Async.20Functions/near/251601535\">said</a>:</p>\n<blockquote>\n<p>I've been thinking about the async fn in traits problem for a while, and I decided to flesh out by thoughts in writing. The basic idea is that <code>async fn foo() -&gt; usize;</code> would become <code>async fn foo() -&gt; impl Future&lt;Output = usize&gt;;</code>, which has numerous benefits: <a href=\"https://ibraheem.ca/writings/an-alternative-async-fn-syntax/\">https://ibraheem.ca/writings/an-alternative-async-fn-syntax/</a></p>\n</blockquote>\n<p>I'd like to experiment with something like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">stuff</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"n\">Future</span><span class=\"o\">&lt;</span><span class=\"n\">Output</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">()</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"n\">foo</span><span class=\"p\">().</span><span class=\"k\">await</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>where <code>async</code> can be combined with other effecting keywords like <code>box</code> and <code>try</code>. We're like one step removed from this, it's not a breaking change, and it benefits areas other than async.</p>",
        "id": 251634718,
        "sender_full_name": "tmandry",
        "timestamp": 1630532935
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116883\">@tmandry</span> - is the syntax of that basically <code>fn $ident($param*) -&gt; $type = $block</code>?</p>",
        "id": 251634916,
        "sender_full_name": "eholk",
        "timestamp": 1630533026
    },
    {
        "content": "<p>Could I also do this?</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">bar</span>: <span class=\"nc\">Bar</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 251634981,
        "sender_full_name": "eholk",
        "timestamp": 1630533064
    },
    {
        "content": "<p>Or even?</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">one</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">i32</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 251635231,
        "sender_full_name": "eholk",
        "timestamp": 1630533187
    },
    {
        "content": "<p>no :)</p>",
        "id": 251635242,
        "sender_full_name": "tmandry",
        "timestamp": 1630533194
    },
    {
        "content": "<p>I mean, in theory we could allow that, I just don't want to ;)</p>",
        "id": 251635271,
        "sender_full_name": "tmandry",
        "timestamp": 1630533211
    },
    {
        "content": "<p>okay :)</p>",
        "id": 251635283,
        "sender_full_name": "eholk",
        "timestamp": 1630533218
    },
    {
        "content": "<p>or at least not to start</p>",
        "id": 251635310,
        "sender_full_name": "tmandry",
        "timestamp": 1630533234
    },
    {
        "content": "<p>I actually kinda like the more general version (having thought about it for all of 30 seconds)</p>",
        "id": 251635317,
        "sender_full_name": "eholk",
        "timestamp": 1630533238
    },
    {
        "content": "<p>But you're right, it's easy to generalize in the future.</p>",
        "id": 251635374,
        "sender_full_name": "eholk",
        "timestamp": 1630533249
    },
    {
        "content": "<p>scala has this, I always found it hard to skim if the entire function + body was all on one line</p>",
        "id": 251635409,
        "sender_full_name": "tmandry",
        "timestamp": 1630533276
    },
    {
        "content": "<p>which is why I'd prefer to only have blocks</p>",
        "id": 251635453,
        "sender_full_name": "tmandry",
        "timestamp": 1630533295
    },
    {
        "content": "<p>but this is all my personal opinion of course</p>",
        "id": 251635484,
        "sender_full_name": "tmandry",
        "timestamp": 1630533310
    },
    {
        "content": "<p>oh yeah, I guess <code>match</code> is an expression, not a block</p>",
        "id": 251635498,
        "sender_full_name": "eholk",
        "timestamp": 1630533319
    },
    {
        "content": "<p>I'm not as opposed to the <code>match</code> idea actually</p>",
        "id": 251635547,
        "sender_full_name": "tmandry",
        "timestamp": 1630533348
    },
    {
        "content": "<p>I think that could be nice</p>",
        "id": 251635561,
        "sender_full_name": "tmandry",
        "timestamp": 1630533360
    },
    {
        "content": "<p>What about?</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 251635585,
        "sender_full_name": "eholk",
        "timestamp": 1630533363
    },
    {
        "content": "<p>well, that does fit the pattern of \"effect-y block syntax\"</p>",
        "id": 251635646,
        "sender_full_name": "tmandry",
        "timestamp": 1630533387
    },
    {
        "content": "<p>Where that would be equivalent to </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 251635658,
        "sender_full_name": "eholk",
        "timestamp": 1630533398
    },
    {
        "content": "<p>the only drawback is that it could be easy for reviewers to miss</p>",
        "id": 251635663,
        "sender_full_name": "tmandry",
        "timestamp": 1630533399
    },
    {
        "content": "<p>true</p>",
        "id": 251635810,
        "sender_full_name": "eholk",
        "timestamp": 1630533482
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116883\">tmandry</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/An.20Alternative.20Syntax.20for.20Async.20Functions/near/251634718\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"363998\">Ibraheem Ahmed</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/An.20Alternative.20Syntax.20for.20Async.20Functions/near/251601535\">said</a>:</p>\n<blockquote>\n<p>I've been thinking about the async fn in traits problem for a while, and I decided to flesh out by thoughts in writing. The basic idea is that <code>async fn foo() -&gt; usize;</code> would become <code>async fn foo() -&gt; impl Future&lt;Output = usize&gt;;</code>, which has numerous benefits: <a href=\"https://ibraheem.ca/writings/an-alternative-async-fn-syntax/\">https://ibraheem.ca/writings/an-alternative-async-fn-syntax/</a></p>\n</blockquote>\n<p>I'd like to experiment with something like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">stuff</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"n\">Future</span><span class=\"o\">&lt;</span><span class=\"n\">Output</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">()</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"n\">foo</span><span class=\"p\">().</span><span class=\"k\">await</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>where <code>async</code> can be combined with other effecting keywords like <code>box</code> and <code>try</code>. We're like one step removed from this, it's not a breaking change, and it benefits areas other than async.</p>\n</blockquote>\n<p>Yeah, that was brought up on internals as well.</p>",
        "id": 251639149,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1630535311
    },
    {
        "content": "<p><a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/expression-bodied-members\">C# has a very general version of this too</a></p>",
        "id": 251639239,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1630535394
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"C#\"><pre><span></span><code><span class=\"k\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">Foo</span><span class=\"p\">()</span> <span class=\"p\">=&gt;</span> <span class=\"m\">1</span><span class=\"p\">;</span>\n</code></pre></div>",
        "id": 251639307,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1630535414
    },
    {
        "content": "<p>I think it works a bit better for languages that have the return type before the function name.</p>",
        "id": 251639330,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1630535443
    },
    {
        "content": "<p><code>int foo() = 1;</code> vs <code>fn foo() -&gt; int = 1;</code></p>",
        "id": 251639357,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1630535465
    },
    {
        "content": "<p>Fun thing is that the <code>-&gt; Future</code> syntax is basically what C# and some other languages do, where the return type of the async function is the future or task state. </p>\n<p>The downside is that it adds noise to function signatures. But then it allowed them to e.g. make async functions cheaper by allowing to return different \"future-like\" types (<code>Task</code> requiring a heap allocation vs <code>ValueTask</code> which doesn't if the value is already ready).</p>",
        "id": 251648495,
        "sender_full_name": "Matthias247",
        "timestamp": 1630541903
    },
    {
        "content": "<p>If we do this, we can also add the new <code>Async/CompletionFuture</code> type by making people write explicitly returning it. That requires  no additional modifier or attribute, which seems like a plus</p>",
        "id": 251648750,
        "sender_full_name": "Matthias247",
        "timestamp": 1630542130
    },
    {
        "content": "<p>Yes, I mentioned C# in the post, returning the future type explicitly opens up possibilities of all sorts of future extensions with clean integration.</p>",
        "id": 251657901,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1630550358
    },
    {
        "content": "<p>In general I think the current syntax is quite limiting.</p>",
        "id": 251657912,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1630550376
    },
    {
        "content": "<p>C# lets you return async iterators too.</p>",
        "id": 251658139,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1630550588
    },
    {
        "content": "<p>Its less noisy for them, <code>Task&lt;T&gt;</code> vs. <code> impl Future&lt;Output = T&gt; + '_</code>, which is probably why it was the clear choice.</p>",
        "id": 251658408,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1630550825
    },
    {
        "content": "<p>Its less noisy for them, <code>Task&lt;T&gt;</code> vs. <code> impl Future&lt;Output = T&gt; + '_</code>, which is probably why it was the clear choice.</p>",
        "id": 251658742,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1630551136
    },
    {
        "content": "<p>My guess is C# went for it, because their implementation of async/await requires functions to return objects to which the surrounding state-machine can attach continuations. If there would be an implicit conversion from <code>T</code> to <code>Task&lt;T&gt;</code>, the conversion would also always have involved a heap allocation. But with giving users the ability to explicitly return those <code>Task</code> objects, users can cache them. e.g.</p>\n<div class=\"codehilite\"><pre><span></span><code>static Task&lt;Foo&gt; alwaysFailing = Task.FromException(&quot;this task object can be returned on all error path and only has to be allocated once\n\nasync Task&lt;Foo&gt; doSomething(int a) {\n    if (a != 777) {\n       return alwaysFailing;\n    }\n}\n</code></pre></div>\n<p>The idea that async functions can return other objects which are awaitable (like <code>ValueTask</code>) came up only 5+ years later.</p>",
        "id": 251666283,
        "sender_full_name": "Matthias247",
        "timestamp": 1630558811
    },
    {
        "content": "<p>The flexibility is definitely nice, and the fact that it keeps things consistent too.<br>\nHowever both the current notation and <code>Task&lt;T&gt;</code> are a lot more pleasant to write than <code>impl Future&lt;Output = T&gt; + '_</code>. I fear there might not be a lot of love for requiring this as default.</p>",
        "id": 251666467,
        "sender_full_name": "Matthias247",
        "timestamp": 1630558984
    },
    {
        "content": "<p>What about using a simple macro like <code>future!(T) =&gt; impl Future&lt;Output = T&gt; + '_</code>? It would solve the character count problem for the most part, although I have no idea what a good name would be, and using macros makes things more mysterious unless everyone learns it and knows that it is a simple macro</p>",
        "id": 251677441,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630568506
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span>: <span class=\"nc\">Sealed</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">poll</span><span class=\"p\">(</span><span class=\"bp\">self</span>: <span class=\"nc\">Pin</span><span class=\"o\">&lt;&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">Self</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">cx</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">Context</span><span class=\"o\">&lt;'</span><span class=\"nb\">_</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Poll</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Fut</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Fut</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"n\">Fut</span>: <span class=\"nc\">Future</span><span class=\"o\">&lt;</span><span class=\"n\">Output</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">poll</span><span class=\"p\">(</span><span class=\"bp\">self</span>: <span class=\"nc\">Pin</span><span class=\"o\">&lt;&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">Self</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">cx</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">Context</span><span class=\"o\">&lt;'</span><span class=\"nb\">_</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Poll</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">poll</span><span class=\"p\">(</span><span class=\"n\">cx</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">F</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Sealed</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"n\">F</span>: <span class=\"nc\">Future</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"p\">(</span><span class=\"k\">crate</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Sealed</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 251729056,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1630594689
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">bar</span>: <span class=\"kp\">&amp;</span><span class=\"kt\">str</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">&lt;</span><span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">in</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"mi\">1</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 251729088,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1630594703
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">bar</span>: <span class=\"kp\">&amp;</span><span class=\"kt\">str</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">usize</span>  <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"mi\">1</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 251729354,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1630594803
    },
    {
        "content": "<p>That's pretty close <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 251729448,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1630594825
    },
    {
        "content": "<p>what about using the async keyword for this?</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">async</span><span class=\"o\">&lt;</span><span class=\"kt\">i32</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"nb\">Send</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"mi\">5</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 251825800,
        "sender_full_name": "Kestrer",
        "timestamp": 1630647861
    },
    {
        "content": "<p>What about the other use cases mentioned in Ibraheem's post, like <code>impl Stream</code>? Or are you saying that this is just acting like a macro and you can also choose not to use it</p>",
        "id": 251826266,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630648323
    },
    {
        "content": "<p>yeah, it would be like a macro</p>",
        "id": 251826322,
        "sender_full_name": "Kestrer",
        "timestamp": 1630648381
    },
    {
        "content": "<p>kind of like how <code>async</code> in expression position is sugar for a future value, <code>async</code> in type position is sugar for a future type</p>",
        "id": 251826350,
        "sender_full_name": "Kestrer",
        "timestamp": 1630648416
    },
    {
        "content": "<p>Repeating <code>async</code> twice is kind of weird.</p>",
        "id": 251897736,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1630682810
    },
    {
        "content": "<p>See <code>requires requires</code> in C++ <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span></p>",
        "id": 252109282,
        "sender_full_name": "Matthias247",
        "timestamp": 1630884591
    },
    {
        "content": "<p>Now that bare trait objects are a hard error in rust 2021, would it be plausible for <code>fn foo() -&gt; Trait</code> to mean <code>fn foo() -&gt; impl Trait</code>?</p>",
        "id": 252205888,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1630950613
    },
    {
        "content": "<p>I don't think we would want to change that; we now have an explicit indication of whether a trait is <code>impl</code> or <code>dyn</code>.</p>",
        "id": 252207189,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1630951436
    },
    {
        "content": "<p>(FWIW, though, I like the proposed async syntax with an explicit trait. If we're exploring a variant anyway because of potential trait changes, I think it's worth considering. I would personally prefer it.)</p>",
        "id": 252207286,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1630951498
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/An.20Alternative.20Syntax.20for.20Async.20Functions/near/252207189\">said</a>:</p>\n<blockquote>\n<p>I don't think we would want to change that; we now have an explicit indication of whether a trait is <code>impl</code> or <code>dyn</code>.</p>\n</blockquote>\n<p>I agree, but I was just curious if that could be done without it being breaking change.</p>",
        "id": 252207631,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1630951734
    },
    {
        "content": "<p>I think it could be, I just don't think it should be.</p>",
        "id": 252207814,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1630951873
    },
    {
        "content": "<p>Another argument in favor of the async syntax with an explicit return type: it would be consistent with having an explicit return type on try functions as well. I would be fine with having <code>try fn</code>, as long as the <code>Result</code> type is still present.</p>",
        "id": 252207961,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1630951970
    },
    {
        "content": "<p>I wouldn't want to hide the <code>Result</code> there, and I think not hiding futures (whatever we end up representing them as) is similarly the right answer.</p>",
        "id": 252208010,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1630952015
    },
    {
        "content": "<p>(Someone understands, yes! <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span> )</p>",
        "id": 252208145,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1630952102
    },
    {
        "content": "<p>It also means that the problems with complex bounds and such should be addressed at an impl Trait level, not just for async functions.</p>",
        "id": 252208276,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1630952167
    },
    {
        "content": "<p>Like the <a href=\"https://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-hard/\">suggested</a> <code>where DB: Database + async Send</code>, <code>Send</code> bounds don't only apply to futures, although that is probably the most common.</p>",
        "id": 252208383,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1630952252
    },
    {
        "content": "<p>You more likely want to say that all return types of this trait are <code>Send</code>, or <code>Sync</code>.</p>",
        "id": 252208403,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1630952269
    },
    {
        "content": "<p>Hmmm.. It might actually make sense for the <code>Send</code> bound in <code>F: Foo + Send</code> to be recursive, applying to all associated types.</p>",
        "id": 252208497,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1630952322
    },
    {
        "content": "<p>That would be breaking though.</p>",
        "id": 252208508,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1630952333
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Output</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span>::<span class=\"n\">Output</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"c1\">// implies F::Output: Send</span>\n<span class=\"k\">fn</span> <span class=\"nf\">foo_send</span><span class=\"o\">&lt;</span><span class=\"n\">F</span>: <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"nb\">Send</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">f</span>: <span class=\"nc\">F</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// ...</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 252218927,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1630959044
    },
    {
        "content": "<p>And you could use <code>?Send</code> to opt-out.</p>",
        "id": 252218938,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1630959053
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">foo_send_output_not_send</span><span class=\"o\">&lt;</span><span class=\"n\">F</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">f</span>: <span class=\"nc\">F</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">F</span>: <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"nb\">Send</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">F</span>::<span class=\"n\">Output</span>: <span class=\"o\">?</span><span class=\"nb\">Send</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// ...</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 252218943,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1630959058
    },
    {
        "content": "<p>I wonder how breaking this would be.</p>",
        "id": 252218976,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1630959078
    },
    {
        "content": "<p>I don't think I've ever run into a case where I wanted the type to be send, but the output not to be, for futures at least.</p>",
        "id": 252219019,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1630959113
    },
    {
        "content": "<p>There should be some way to express this.</p>",
        "id": 252219094,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1630959156
    },
    {
        "content": "<p><code>F: Foo + recursive Send</code>?</p>",
        "id": 252219143,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1630959199
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"363998\">@Ibraheem Ahmed</span> At least the explicit <code>impl Trait</code> syntax makes this an orthogonal concern, since as you noted there are other places where people want bounds to propagate.</p>",
        "id": 252220058,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1630959910
    },
    {
        "content": "<p>We may need a general mechanism for <code>X has SomeTrait if Y has SomeTrait</code> (where <code>SomeTrait</code> may be something like <code>Send</code>).</p>",
        "id": 252220065,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1630959922
    },
    {
        "content": "<p>For the \"type and all associated types must be Send\", <code>T: Trait&lt;_: Send&gt; + Send</code> might work.</p>",
        "id": 252220638,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1630960317
    },
    {
        "content": "<p>Maybe sugar for <code>T: Trait + Send, T::_: Send</code> with <code>feature(associated_type_bounds)</code></p>",
        "id": 252220821,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1630960392
    },
    {
        "content": "<blockquote>\n<p>We may need a general mechanism for X has SomeTrait if Y has SomeTrait (where SomeTrait may be something like Send).</p>\n</blockquote>\n<p>HRTBs extended to type parameters would provide that: <code>for&lt;X: SomeTrait&gt; Y&lt;X&gt;: SomeTrait</code></p>",
        "id": 252220945,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1630960492
    },
    {
        "content": "<p>That and <code>T: Trait&lt;_: SomeTrait&gt;</code> might be enough.</p>",
        "id": 252220998,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1630960539
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"363998\">Ibraheem Ahmed</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/An.20Alternative.20Syntax.20for.20Async.20Functions/near/252220945\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>We may need a general mechanism for X has SomeTrait if Y has SomeTrait (where SomeTrait may be something like Send).</p>\n</blockquote>\n<p>HRTBs extended to type parameters would provide that: <code>for&lt;X: SomeTrait&gt; Y&lt;X&gt;: SomeTrait</code></p>\n</blockquote>\n<p>That looks promising to me.</p>",
        "id": 252224599,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1630963406
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span>  mentioned that Chalk supports those types of bounds</p>",
        "id": 252231024,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1630969520
    },
    {
        "content": "<p>I was also thinking, now that HRTBs are going to be used much more with GATs, the elided lifetime could be used as sugar.</p>",
        "id": 252238953,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1630977811
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">type</span> <span class=\"nc\">Output</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span>::<span class=\"n\">Output</span><span class=\"o\">&lt;'</span><span class=\"nb\">_</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"o\">&lt;</span><span class=\"n\">F</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">foo</span>: <span class=\"nc\">F</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">F</span>: <span class=\"nc\">Foo</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">F</span>::<span class=\"n\">Output</span><span class=\"o\">&lt;'</span><span class=\"nb\">_</span><span class=\"o\">&gt;</span>: <span class=\"nb\">Send</span>\n    <span class=\"c1\">// =&gt; for&lt;'a&gt; F::Output&lt;'a&gt;: Send</span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// ...</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 252239038,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1630977897
    },
    {
        "content": "<p><code>'_</code> isn't allowed there, so wouldn't be a breaking change.</p>",
        "id": 252239066,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1630977944
    },
    {
        "content": "<p>and maybe <code>_</code> could be used similarlly for a HRTB with type parameters.</p>",
        "id": 252239124,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1630977996
    },
    {
        "content": "<p><a href=\"https://internals.rust-lang.org/t/hrtb-sugar/15293\">Opened an internals thread for anyone interested.</a></p>",
        "id": 252239673,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1630978635
    }
]