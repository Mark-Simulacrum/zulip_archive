[
    {
        "content": "<p>Hey <span class=\"user-mention\" data-user-id=\"125294\">@Aaron Hill</span>  -- I've been looking over PR <a href=\"https://github.com/rust-lang/rust/issues/65782\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/65782\">#65782</a>, do you want to chat about it soon-ish as we discussed?</p>",
        "id": 183192274,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576092610
    },
    {
        "content": "<p>Sure!</p>",
        "id": 183192291,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576092619
    },
    {
        "content": "<p>Actually I've mostly been pondering the main comment, I've not really looked at the code yet =)</p>",
        "id": 183192305,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576092628
    },
    {
        "content": "<p>There are essentially two parts:<br>\n1) Delaying the processing of generator-related obligations until mir typeck/borrowck<br>\n2) Changing how 'constituent tyoes' are defined for GeneratorWitness</p>",
        "id": 183192395,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576092686
    },
    {
        "content": "<p>Can you say a bit more about 2?</p>",
        "id": 183192424,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576092709
    },
    {
        "content": "<p>I'm mostly thinking about 1</p>",
        "id": 183192430,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576092713
    },
    {
        "content": "<p>I think the first part might actually be the more complicated part, since it involves changes to both typeck, TraitEngine/SelectionContext, and mir typeck/borrowck</p>",
        "id": 183192433,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576092715
    },
    {
        "content": "<p>sure</p>",
        "id": 183192442,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576092718
    },
    {
        "content": "<p>How I understood from the PR <em>description</em> is something like</p>",
        "id": 183192488,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576092723
    },
    {
        "content": "<ul>\n<li>when we have to prove <code>G: Send</code> for some generator interior <code>G</code></li>\n</ul>",
        "id": 183192504,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576092734
    },
    {
        "content": "<p>we record that for posterity and just assume it's true</p>",
        "id": 183192516,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576092742
    },
    {
        "content": "<p>(perhaps in some \"special mode\")</p>",
        "id": 183192529,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576092750
    },
    {
        "content": "<p>then later in MIR code, we go and prove for real</p>",
        "id": 183192547,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576092760
    },
    {
        "content": "<p>That's correct</p>",
        "id": 183192558,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576092771
    },
    {
        "content": "<p>this is effectively <em>similar</em> to the idea of \"reveal\"</p>",
        "id": 183192559,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576092771
    },
    {
        "content": "<p>it interacts I think with specialization</p>",
        "id": 183192573,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576092779
    },
    {
        "content": "<p>How so? I would have assumed that specialization doesn't directly interact with generators</p>",
        "id": 183192620,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576092808
    },
    {
        "content": "<p>like, if you have a specialization that is true iff something is Send</p>",
        "id": 183192622,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576092810
    },
    {
        "content": "<p>Since you can't write impls for them</p>",
        "id": 183192627,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576092813
    },
    {
        "content": "<p>ah</p>",
        "id": 183192724,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576092855
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">MyTrait</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Bar</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">MyTrait</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">default</span> <span class=\"k\">type</span><span class=\"w\"> </span><span class=\"n\">Bar</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">();</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span>: <span class=\"nb\">Send</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">MyTrait</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">type</span> <span class=\"nc\">Bar</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 183192733,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576092862
    },
    {
        "content": "<p>I implemeneted the 'delayed generator witnesses' as a 'special mode' of TraitEngine</p>",
        "id": 183192745,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576092870
    },
    {
        "content": "<p>we only use this mode during type inference</p>",
        "id": 183192753,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576092876
    },
    {
        "content": "<p>I believe that, as presently defined, you <em>can</em> observe that <code>&lt;T as MyTrait&gt;::Bar</code> is <code>u32</code></p>",
        "id": 183192755,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576092877
    },
    {
        "content": "<p>every other existing usage of TraitEngine/SelectionnContext gets the current behavior</p>",
        "id": 183192768,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576092893
    },
    {
        "content": "<p>(I'm thinking also about what this would mean for chalk)</p>",
        "id": 183192771,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576092895
    },
    {
        "content": "<p>oh, you're talking about specialization of assocaited types</p>",
        "id": 183192805,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576092918
    },
    {
        "content": "<p>I thought you were referring to the impl itself</p>",
        "id": 183192815,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576092926
    },
    {
        "content": "<p>hmm</p>",
        "id": 183192816,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576092927
    },
    {
        "content": "<p>I guess if I had concerns they would be:</p>\n<ul>\n<li>adding modes to trait resolution might have unexpected interactions</li>\n<li>determining the \"live types\" from MIR is probably right but it may also be more precise than we wanted it to be? we could reveal impl details we don't intend to. I'm however not as nervous about this if we tie it to the MIR that feeds into borrowck, since the same is already true there.</li>\n</ul>",
        "id": 183192914,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576092968
    },
    {
        "content": "<p>yes, typeck can observe specializations, <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=3e2cd720425a19c59f1b7eb25a548ba0\" target=\"_blank\" title=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=3e2cd720425a19c59f1b7eb25a548ba0\">as you can see here</a></p>",
        "id": 183192998,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576093030
    },
    {
        "content": "<p>I'm not very familiar with specialization of associated types - where do we end up 'checking' (but not requiring) if a bound holds, so that we can see if the specialized impl should be used?</p>",
        "id": 183193011,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576093042
    },
    {
        "content": "<p>(interestingly, the current code <em>cannot</em> rely on the projection being <code>()</code> -- that is, we always assume new specializations could be added during typeck)</p>",
        "id": 183193024,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576093051
    },
    {
        "content": "<blockquote>\n<p>I'm not very familiar with specialization of associated types - where do we end up 'checking' (but not requiring) if a bound holds, so that we can see if the specialized impl should be used?</p>\n</blockquote>\n<p>it happens in the <a href=\"http://select.rs\" target=\"_blank\" title=\"http://select.rs\">select.rs</a> code right now</p>",
        "id": 183193058,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576093073
    },
    {
        "content": "<p>there is some logic that says \"if you have two competing impls A and B, and A specializes B, and you know that A applies, then discard B\"</p>",
        "id": 183193126,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576093097
    },
    {
        "content": "<p>we could certainly make it so that \"generator impls Send\" is more of a \"maybe true\" bit of info</p>",
        "id": 183193166,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576093133
    },
    {
        "content": "<p>that's a new concept we'd have to add though</p>",
        "id": 183193194,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576093155
    },
    {
        "content": "<p>I hadn't considered that interaction at all</p>",
        "id": 183193197,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576093160
    },
    {
        "content": "<p>that really complicates things</p>",
        "id": 183193202,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576093163
    },
    {
        "content": "<p>Yes.</p>",
        "id": 183193216,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576093185
    },
    {
        "content": "<p>I had previously assumed that it didn't really matter 'when' we determined if 'G: AutoTrait' holds or not. However, that seems to be wrong</p>",
        "id": 183193235,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576093198
    },
    {
        "content": "<p>The same thing is something of a problem for <code>-&gt; impl Trait</code> and send</p>",
        "id": 183193236,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576093198
    },
    {
        "content": "<p>Right now we impose a DAG relationship for that reason</p>",
        "id": 183193297,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576093211
    },
    {
        "content": "<p>It's of course possible to imagine that we should alter specialization to avoid this interaction, though it'd be a significant limitation</p>",
        "id": 183193337,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576093242
    },
    {
        "content": "<p>/me thinks</p>",
        "id": 183193477,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576093335
    },
    {
        "content": "<p>So, if we <em>didn't</em> take this approach</p>",
        "id": 183193512,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576093352
    },
    {
        "content": "<p>Well, put another way, the conflict I am identifying is basically unavoidable</p>",
        "id": 183193549,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576093378
    },
    {
        "content": "<p>yeah, it seems so - we need to do type-checking to generate the MIR, but the MIR can directly influence type-checking via specialization</p>",
        "id": 183193720,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576093478
    },
    {
        "content": "<p>I think this would apply to any approach that tries to use the MIR (in any way) to determine generator auto trait impls</p>",
        "id": 183193782,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576093523
    },
    {
        "content": "<p>Agreed</p>",
        "id": 183193795,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576093530
    },
    {
        "content": "<p>This is kind of where I got stuck when thinking about it before</p>",
        "id": 183193803,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576093536
    },
    {
        "content": "<p>It seems like there are two options</p>",
        "id": 183193808,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576093540
    },
    {
        "content": "<p>Or maybe three :)</p>",
        "id": 183193834,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576093552
    },
    {
        "content": "<p>I mean (1) is that we take this basic approach, but we work out the interactions w/ specialization etc <em>somehow</em></p>",
        "id": 183193930,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576093589
    },
    {
        "content": "<p>This might be by assuming Send is true (and checking later), which I'm not wild about, or by regarding it as \"unknown\" (and hence refusing to decide whether the specialization applies)</p>",
        "id": 183193968,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576093612
    },
    {
        "content": "<p>with perhaps some kind of \"opt-in\" to make it required to be true</p>",
        "id": 183193976,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576093620
    },
    {
        "content": "<p>well, hmm, so even looking past MIR, there really is a \"core cycle\" which is:</p>",
        "id": 183194119,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576093700
    },
    {
        "content": "<p>we can't figure out all the types</p>",
        "id": 183194134,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576093709
    },
    {
        "content": "<p>(at least in some cases)</p>",
        "id": 183194144,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576093716
    },
    {
        "content": "<p>i.e., the type of something might depend on specialization</p>",
        "id": 183194148,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576093722
    },
    {
        "content": "<p>so I think there are really just two choices</p>",
        "id": 183194157,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576093730
    },
    {
        "content": "<p>we can resolve that, as I just described, or we can use an approximation (as we do today) -- but even the one we use today seems to require knowing the types..?</p>",
        "id": 183194241,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576093789
    },
    {
        "content": "<p>To make matters worse, the generator can be hidden behind several other types, via type-alias-impl-trait</p>",
        "id": 183194469,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576093891
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"cp\">#![feature(specialization)]</span><span class=\"w\"></span>\n\n<span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">MyTrait</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Bar</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">MyTrait</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">default</span> <span class=\"k\">type</span><span class=\"w\"> </span><span class=\"n\">Bar</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">();</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span>: <span class=\"nb\">Send</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">MyTrait</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">type</span> <span class=\"nc\">Bar</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">gimme</span><span class=\"o\">&lt;</span><span class=\"n\">T</span>: <span class=\"nc\">MyTrait</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"nc\">T</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">MyTrait</span><span class=\"o\">&gt;</span>::<span class=\"n\">Bar</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">panic</span><span class=\"o\">!</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">async</span><span class=\"w\"> </span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">gimme</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 183194493,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576093909
    },
    {
        "content": "<p>So, trying to specialize based on <code>InnocousStruct: Send</code> might actually involve determining whether some generator is Send</p>",
        "id": 183194496,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576093911
    },
    {
        "content": "<p>that's an example where the type of <code>y</code> is determined from <code>gimme(x)</code></p>",
        "id": 183194549,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576093924
    },
    {
        "content": "<p>I think you can use some deferred type variables to get that as part of <code>x</code></p>",
        "id": 183194568,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576093938
    },
    {
        "content": "<p>e.g., <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=2da9e6f5b6c50c5e7154ea537a1e66fe\" target=\"_blank\" title=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=2da9e6f5b6c50c5e7154ea537a1e66fe\">this one</a>, but it won't compile today (which seems good)</p>",
        "id": 183194641,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576093988
    },
    {
        "content": "<p>(and as I expected)</p>",
        "id": 183194650,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576093997
    },
    {
        "content": "<p>I think what is happening there is that we don't yet know the interior types of the generator, so that the <code>T: MyTrait&lt;Bar = ?U&gt;</code> obligation remains effectively unsatisfied, and hence the type of <code>z: Option&lt;?U&gt;</code> is never fully known</p>",
        "id": 183194793,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576094078
    },
    {
        "content": "<p>\"more or less\"</p>",
        "id": 183194837,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576094104
    },
    {
        "content": "<p>hmm</p>",
        "id": 183194894,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576094153
    },
    {
        "content": "<p>thinking about this from the MIR side - we really do need to know the actual types when deciding which types are live across yield points. - the analysis takes <code>Drop</code> into account</p>",
        "id": 183194992,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576094207
    },
    {
        "content": "<p>this cycle seems really fundamental, unfortunately</p>",
        "id": 183195019,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576094230
    },
    {
        "content": "<p>Yeah. So there is the option of just refusing to make decisions.</p>",
        "id": 183195145,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576094286
    },
    {
        "content": "<p>After all, this is something of an edge case that is unlikely to truly arise.</p>",
        "id": 183195152,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576094294
    },
    {
        "content": "<p>I'm thinking a bit about it from the chalk angle</p>",
        "id": 183195188,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576094323
    },
    {
        "content": "<p>Right now chalk has a notion of \"cannot prove\" --</p>",
        "id": 183195204,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576094335
    },
    {
        "content": "<p>so e.g. trying to prove <code>T: Send</code> could yield that, and it would prevent specializations from being used</p>",
        "id": 183195231,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576094349
    },
    {
        "content": "<p>however, that's likely not quite what we want here, in that</p>",
        "id": 183195248,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576094362
    },
    {
        "content": "<p>if you had some code that relied on it being send</p>",
        "id": 183195289,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576094387
    },
    {
        "content": "<p>it would get an error</p>",
        "id": 183195297,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576094389
    },
    {
        "content": "<p>(well, maybe that <em>is</em> what we want..?)</p>",
        "id": 183195316,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576094400
    },
    {
        "content": "<p>put another way, leaving chalk aside, if you imagine that the result of saying \"can I prove this?\" is either yes/no/maybe</p>",
        "id": 183195433,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576094420
    },
    {
        "content": "<p>/me stops to think :)</p>",
        "id": 183195513,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576094471
    },
    {
        "content": "<p>So, we would error whenever we attempted to check a specialization that would require evaluating <code>G: AutoTrait</code>?</p>",
        "id": 183195515,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576094473
    },
    {
        "content": "<p>well, it wouldn't be an <em>error</em></p>",
        "id": 183195538,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576094489
    },
    {
        "content": "<p>it wouldn't be able to decide if the spec applies or not</p>",
        "id": 183195575,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576094501
    },
    {
        "content": "<p>but that might not lead to an error</p>",
        "id": 183195580,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576094504
    },
    {
        "content": "<p>as it might not matter</p>",
        "id": 183195585,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576094506
    },
    {
        "content": "<p>e.g., if you were trying to prove something like <code>&lt;T as MyTrait&gt;::Bar: Sized</code>, you don't actually care if <code>T: Send</code>--i.e., you don't care if you took the specialization or not</p>",
        "id": 183195653,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576094527
    },
    {
        "content": "<p>there is a small 'fly in the ointment' though</p>",
        "id": 183195668,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576094535
    },
    {
        "content": "<p>In your <code>&lt;u32 as MyTrait&gt;::Bar</code> example, would we then use the unspecialised impl for <code>G</code>?</p>",
        "id": 183195731,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576094567
    },
    {
        "content": "<p>if the example were changed to involve generators, that is</p>",
        "id": 183195747,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576094578
    },
    {
        "content": "<p>ah, maybe since specialization is unstable, it's largely ok, but it's true that <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=ed3e8a7eb0e944581062f758c89126c6\" target=\"_blank\" title=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=ed3e8a7eb0e944581062f758c89126c6\">this compiles today</a></p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">async</span><span class=\"w\"> </span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">gimme</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>and it is only able to do so because we are able to first figure out that the generator type is <code>Send</code> so that  we can resolve the type of <code>y</code></p>",
        "id": 183195825,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576094621
    },
    {
        "content": "<blockquote>\n<p>In your <code>&lt;u32 as MyTrait&gt;::Bar</code> example, would we then use the unspecialised impl for <code>G</code>?</p>\n</blockquote>\n<p>we would not use either impl</p>",
        "id": 183195834,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576094628
    },
    {
        "content": "<p>that is, in type-checking</p>",
        "id": 183195892,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576094645
    },
    {
        "content": "<p>er, I'm guessing you meant <code>&lt;G as MyTrait&gt;::Bar</code>, where <code>G</code> is a generator type</p>",
        "id": 183195920,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576094670
    },
    {
        "content": "<p>(or something that depends on a generator)</p>",
        "id": 183195941,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576094682
    },
    {
        "content": "<p>yeah, sorry for being unclear there</p>",
        "id": 183195944,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576094683
    },
    {
        "content": "<p>the idea would be that we just can't normalize that</p>",
        "id": 183195983,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576094709
    },
    {
        "content": "<p>we can't convert it to <code>()</code> or <code>u32</code></p>",
        "id": 183195990,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576094718
    },
    {
        "content": "<p>What would happen for uses of the impl that don't involve associated types - e.g. calling a potentially specialised method?</p>",
        "id": 183196109,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576094774
    },
    {
        "content": "<p>I guess we don't actually need to know that during typeck, right?</p>",
        "id": 183196148,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576094809
    },
    {
        "content": "<p>nothing; we know that there exists some method, you could still call it, it's not until codgen time that we'd have to figure out exactly which one gets invoked</p>",
        "id": 183196163,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576094819
    },
    {
        "content": "<p>in the associated type example, would we just give up and error when a generator was involved in the normalization?</p>",
        "id": 183196332,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576094919
    },
    {
        "content": "<p>it depends I guess, I'm not sure exactly which example you mean</p>",
        "id": 183196426,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576094978
    },
    {
        "content": "<p><code>&lt;G as MyTrait&gt;::Bar</code></p>",
        "id": 183196457,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576094998
    },
    {
        "content": "<p>a lazy normalization strategy kind of affects this too</p>",
        "id": 183196459,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576095000
    },
    {
        "content": "<p>or some type involving a generator instead of <code>G</code></p>",
        "id": 183196515,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576095010
    },
    {
        "content": "<p>i.e., the type of <code>y</code> right now is considered \"unresolved\" but conceivably it could just be assigned to <code>&lt;G as MyTrait&gt;::Bar</code> in a lazy norm strategy, and that's a perfectly valid type (that will be normalized if it must be, i.e., if some bit of code requires that to be <code>u32</code>)</p>",
        "id": 183196562,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576095042
    },
    {
        "content": "<p>right, but that's not a complete example</p>",
        "id": 183196572,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576095050
    },
    {
        "content": "<p>the <code>gimme(x)</code> example with <code>let x = async move</code></p>",
        "id": 183196620,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576095080
    },
    {
        "content": "<p>so e.g. if you had</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">async</span><span class=\"w\"> </span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">gimme</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"n\">drop</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">);</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>we don't really have to know the type of <code>y</code>, it's enough to know that it has <em>some</em> <code>Sized</code> type</p>",
        "id": 183196624,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576095081
    },
    {
        "content": "<p>but if you have</p>",
        "id": 183196629,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576095084
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">async</span><span class=\"w\"> </span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y</span>: <span class=\"kt\">u32</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">gimme</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>that's different</p>",
        "id": 183196645,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576095097
    },
    {
        "content": "<p>so depending on how we set things up, it could be that the first one builds, but the second one doesn't</p>",
        "id": 183196754,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576095146
    },
    {
        "content": "<p>e.g., because the type of <code>y</code> effectively gets inferred to the placeholder <code>G::Bar</code>, since we can't decide which specialization to use</p>",
        "id": 183196762,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576095154
    },
    {
        "content": "<p>I see. When this error occurred, would the user have any way to fix it (other than not using the trait in question)?</p>",
        "id": 183196840,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576095223
    },
    {
        "content": "<p>Things could be very deeply nested, so I'm not sure what kind of information the user could specify to resolve it</p>",
        "id": 183196924,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576095258
    },
    {
        "content": "<p>the bigger problem I think is code like this, which builds today:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">fn</span> <span class=\"nf\">gimme_send</span><span class=\"o\">&lt;</span><span class=\"n\">T</span>: <span class=\"nb\">Send</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"nc\">T</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">panic</span><span class=\"o\">!</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">async</span><span class=\"w\"> </span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">gimme_send</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>because this code only type-checks if the generator is <code>Send</code></p>",
        "id": 183196989,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576095301
    },
    {
        "content": "<p>(sorry, it's not a <em>problem</em>, it's just a thing to remember)</p>",
        "id": 183197003,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576095312
    },
    {
        "content": "<blockquote>\n<p>I see. When this error occurred, would the user have any way to fix it (other than not using the trait in question)?</p>\n</blockquote>\n<p>I think we'd have to add a mechanism</p>",
        "id": 183197021,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576095330
    },
    {
        "content": "<p>I'm not sure what that means, I guess it would be a declaration that the <code>async move</code> is <code>Send</code></p>",
        "id": 183197105,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576095364
    },
    {
        "content": "<p>and maybe we can use some kind of \"approx analysis\" to avoid the need for that sometimes, too -- i.e., if we have an over-approx, we could (maybe?)check if that suffices</p>",
        "id": 183197123,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576095389
    },
    {
        "content": "<p>( in any case, I was just pondering how specialization should be modeled in chalk, I'm trying to map this to the chalk solver, and wondering if I had overlooked something there )</p>",
        "id": 183197234,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576095446
    },
    {
        "content": "<p>(ah, no, I guess it's ok)</p>",
        "id": 183197323,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576095490
    },
    {
        "content": "<p>sorry to keep mapping back to chalk, I can try to elaborate, I just find that a useful framework for thinking about this stuff</p>",
        "id": 183197341,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576095502
    },
    {
        "content": "<p>I think the way I'm thining about it right now is like this</p>",
        "id": 183197570,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576095655
    },
    {
        "content": "<p>Here's a different approach I'm thinking of (not sure if it will work):</p>",
        "id": 183197612,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576095691
    },
    {
        "content": "<p>we augment the system so that when you try to prove something (e.g., <code>T: Foo</code>), you can get back an answer like \"yes if G\" where <code>G</code> are some things that must be proven later. We already do something like this for region constraints and we are trying to build up some similar logic for coinduction anyway.</p>",
        "id": 183197629,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576095711
    },
    {
        "content": "<p>Such an answer is considered \"ambiguous\" in some sense, you can't know if it's true or false yet</p>",
        "id": 183197646,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576095722
    },
    {
        "content": "<p>This is basically the \"mode\" you added</p>",
        "id": 183197690,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576095745
    },
    {
        "content": "<p>i.e., the mode is \"defer\" <code>G: Send</code> goals</p>",
        "id": 183197717,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576095764
    },
    {
        "content": "<blockquote>\n<p>Here's a different approach I'm thinking of (not sure if it will work):</p>\n</blockquote>\n<p>anyway, go for it :)</p>",
        "id": 183197788,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576095803
    },
    {
        "content": "<p>hmm, what I was thinking of might actually not work out</p>",
        "id": 183198090,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576095975
    },
    {
        "content": "<p>I was thinking that we didn't actually need to know the types of upvars when type-checking the parent - only the types of things local to the generator.</p>",
        "id": 183198121,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576096002
    },
    {
        "content": "<p>However, you can have something like:</p>",
        "id": 183198131,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576096008
    },
    {
        "content": "<p><code>async move { let myvar = some_fn(local_var, upvar) }</code></p>",
        "id": 183198153,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576096022
    },
    {
        "content": "<p>And the type of <code>myvar</code> might depend on <code>upvar</code> if <code>some_fn</code> is generic</p>",
        "id": 183198184,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576096041
    },
    {
        "content": "<p>So the typeck results from the parent can actually be relevant when determining which types live across suspend points</p>",
        "id": 183198240,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576096077
    },
    {
        "content": "<p>yeah it's all tangled up :)</p>",
        "id": 183198451,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576096198
    },
    {
        "content": "<p>though, on second thought - is it possible to combine that case with specialization of an associated type?</p>",
        "id": 183198612,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576096284
    },
    {
        "content": "<p>That would mean that 1) the parent is trying to compute a type (e.g. <code>let a: u32 = &lt;G as MyTrait&gt;::MyType</code>) while specializing on the generator, and 2) the generator is trying to use that type from the parent</p>",
        "id": 183198711,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576096326
    },
    {
        "content": "<p>I think that should cause a cycle error even if we kept the current generator auto-trait behavior (i.e using the GeneratorWitness types from HIR)</p>",
        "id": 183198738,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576096352
    },
    {
        "content": "<p>The parent needs to evaluate <code>G:  AutoTrait</code>, but the constituent types (under any scheme) depend on an upvar that relies on the specialization of <code>G: AutoTrait</code></p>",
        "id": 183198818,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576096401
    },
    {
        "content": "<p>So, I think there are two cases:<br>\n1) We have the kind of weird cycle that I just described. We have to emit a cycle error regardless of how we determine the consitutent types of <code>G</code><br>\n2) We don't have this kind of cycle. This means that one of these cases is true:<br>\n2.1) We are specializing on the generator type, but the generator doesn't rely on the result of that specializtion (via an upvar)<br>\n2.2) We are not specializing on the generator type, and the generator uses an upvar<br>\n2.3) We are not specializing, and the generator does not use an upvar</p>",
        "id": 183199033,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576096545
    },
    {
        "content": "<p>If we're not specializing, then the existing 'delayed generator predicate' scheme works</p>",
        "id": 183199120,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576096588
    },
    {
        "content": "<p>If we <em>are</em> specializing, then I think we can go with something like this:</p>\n<p>We comute some kind of 'incomplete mir' for the generator - it has the generator interior types filled in, but not upvars</p>",
        "id": 183199201,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576096642
    },
    {
        "content": "<p>err, rather</p>",
        "id": 183199234,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576096670
    },
    {
        "content": "<p>It does have upvars, which we can determine the types of because we're not specializing</p>",
        "id": 183199288,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576096688
    },
    {
        "content": "<p>We then run the analysis on that MIR, and use the results for the witness types</p>",
        "id": 183199302,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576096702
    },
    {
        "content": "<p>This is pretty complicated, but I think it should be completely transparent to users</p>",
        "id": 183199314,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576096713
    },
    {
        "content": "<p>and will not introduce errors in any casses where they did not already exist (e.g. the weird specialization + upvar cycle)</p>",
        "id": 183199329,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576096733
    },
    {
        "content": "<p>sorry, that ended up being way longer than I thought it would <span aria-label=\"smiley\" class=\"emoji emoji-1f603\" role=\"img\" title=\"smiley\">:smiley:</span></p>",
        "id": 183199349,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576096747
    },
    {
        "content": "<p>I admit i don't <em>quite</em> follow all that logic. I'll have to re-read it carefully. =)</p>",
        "id": 183199395,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576096793
    },
    {
        "content": "<p>I've probably got to run to do a few other things, but I think the idea of able to have \"deferred\" trait proving goals might be quite useful (as I noted, also for <code>impl Trait</code>). I feel like I can sort of understand how to model it in chalk, and then the question is mostly how we can ensure that those things eventually get proven.</p>",
        "id": 183199450,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576096805
    },
    {
        "content": "<p>The main idea is that if we're doing any kind of associated type specialization based on the generator, the generator itself cannot rely on that associated type specialization (via an upvar)</p>",
        "id": 183199484,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576096830
    },
    {
        "content": "<p>Yeah. I'm kind of taking that as a given in some sense.</p>",
        "id": 183199510,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576096850
    },
    {
        "content": "<p>I think it would effectively manifest as a kind of error -- i.e., we wouldn't be able to prove that the specialized impl applies</p>",
        "id": 183199535,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576096869
    },
    {
        "content": "<p>I think that fact lets us perform the needed analysis without hitting cycles</p>",
        "id": 183199544,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576096873
    },
    {
        "content": "<p>I guess I don't really like the idea of (e.g.) \"incomplete MIR\", it's sounding very complex</p>",
        "id": 183199576,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576096901
    },
    {
        "content": "<p>Yeah, I agree that it's not very great</p>",
        "id": 183199605,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576096918
    },
    {
        "content": "<p>That said, maybe there is some \"reframing\"</p>",
        "id": 183199658,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576096934
    },
    {
        "content": "<p>That is, the current setup where we do type-check to compute all the types etc, then build the MIR, doesn't quite seem fine-grained enough necessarily, maybe there is another way to draw the line .. e.g. I don't know producing some other kind of intermediate structure (more like HAIR, maybe) that we can use .. still sounds complex :)</p>",
        "id": 183199728,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576097001
    },
    {
        "content": "<p>Thinking about this more, I think we don't actually need the notion of 'incomplete MIR':</p>",
        "id": 183199746,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576097027
    },
    {
        "content": "<p>or perhaps not - this approach really is quite complicated</p>",
        "id": 183200140,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576097277
    },
    {
        "content": "<p>Oh, wait - I think I may have misunderstood how closrue type-checking works</p>",
        "id": 183200356,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576097393
    },
    {
        "content": "<p>I was thinking that the parent had a separate TypeckTables, which the child depended on</p>",
        "id": 183200424,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576097413
    },
    {
        "content": "<p>but actually, they use the same TypeckTables</p>",
        "id": 183200441,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576097423
    },
    {
        "content": "<p>I don't think that helps to simplify the complexity of the 'incomplete mir' approach, though</p>",
        "id": 183200595,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576097561
    },
    {
        "content": "<p>yeah, that's how it works, but in a way it's part of the problem</p>",
        "id": 183201518,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576098269
    },
    {
        "content": "<p>I wonder if we could just ban associated type specializations on generator types, when the specialization occurs in the same function as the generator</p>",
        "id": 183201704,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576098391
    },
    {
        "content": "<p>for the time being, that is</p>",
        "id": 183201717,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576098403
    },
    {
        "content": "<p>I think the error would almost never come up (you need to be using an unstable feature, and be specializing on associated types, and have generators/async fns involved)</p>",
        "id": 183201800,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576098469
    },
    {
        "content": "<p>it would leave room to decide what the actual behavior should be (a more complicated analysis, a more targeted error, something else)</p>",
        "id": 183201945,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576098495
    },
    {
        "content": "<p>I think all other cases are fine (if the specialization is in a different function, then we can certainly compute <code>G: AutoTrait</code> without hitting a cycle)</p>",
        "id": 183202003,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1576098531
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125294\">@Aaron Hill</span> <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span>  is there any progress on this PR? Thanks</p>",
        "id": 188048815,
        "sender_full_name": "DPC",
        "timestamp": 1581538124
    }
]