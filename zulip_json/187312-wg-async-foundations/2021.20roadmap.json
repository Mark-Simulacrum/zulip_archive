[
    {
        "content": "<p>It's time to start building our 2021 roadmap</p>",
        "id": 222487199,
        "sender_full_name": "tmandry",
        "timestamp": 1610482045
    },
    {
        "content": "<p>I created <a href=\"https://github.com/rust-lang/wg-async-foundations/issues/22\">rust-lang/wg-async-foundations#22</a> to track this, but would like to keep most discussion here</p>",
        "id": 222487453,
        "sender_full_name": "tmandry",
        "timestamp": 1610482152
    },
    {
        "content": "<p>(I do think it would be useful, however, to include a pointer to each item we consider on the issue)</p>",
        "id": 222487579,
        "sender_full_name": "tmandry",
        "timestamp": 1610482205
    },
    {
        "content": "<p>The first thing I'd like to put up for discussion is <a href=\"https://github.com/rust-lang/wg-async-foundations/issues/23\">rust-lang/wg-async-foundations#23</a>: AsyncRead, AsyncWrite traits</p>",
        "id": 222488989,
        "sender_full_name": "tmandry",
        "timestamp": 1610482962
    },
    {
        "content": "<p>I think there's a pretty clear path we can take to adding these to std this year</p>",
        "id": 222489023,
        "sender_full_name": "tmandry",
        "timestamp": 1610482981
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116883\">@tmandry</span> (Cheering you on. I look forward to having those traits standardized.)</p>",
        "id": 222516030,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1610497967
    },
    {
        "content": "<p>Would std versions of <code>sleep()</code>/<code>sleep_for()</code>/<code>interval()</code> be feasible?</p>",
        "id": 222573064,
        "sender_full_name": "Dirkjan Ochtman",
        "timestamp": 1610541523
    },
    {
        "content": "<p>How would they be implemented?</p>",
        "id": 222588583,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1610548747
    },
    {
        "content": "<p>I'm a big fan of AsyncRead / AsyncWrite getting standardized :)</p>",
        "id": 222599495,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1610552501
    },
    {
        "content": "<p>and excited to see this discussion start</p>",
        "id": 222599504,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1610552505
    },
    {
        "content": "<p>My personal take is that a combination of: standardize stream, async-read, async-write, and work on polish might be a decent start</p>",
        "id": 222599648,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1610552540
    },
    {
        "content": "<p>that's a lot of progress</p>",
        "id": 222599664,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1610552547
    },
    {
        "content": "<p>(along with I imagine other smaller things)</p>",
        "id": 222599697,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1610552558
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243558\">Steven Fackler</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/2021.20roadmap/near/222588583\">said</a>:</p>\n<blockquote>\n<p>How would they be implemented?</p>\n</blockquote>\n<p>Maybe it doesn't make sense and would require some kind of <code>Runtime</code> trait</p>",
        "id": 222701438,
        "sender_full_name": "Dirkjan Ochtman",
        "timestamp": 1610620873
    },
    {
        "content": "<blockquote>\n<p>Would std versions of sleep()/sleep_for()/interval() be feasible?</p>\n</blockquote>\n<p>You can do it, but that requires the std to spin up a timer thread and run that in the background. That would never be as efficient as a timer which is integrated into [local thread] runtime.</p>\n<p>We could standardize trait versions of those, but i'm not sure how helpful they are.</p>",
        "id": 222952795,
        "sender_full_name": "Matthias247",
        "timestamp": 1610764131
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"211722\">@Yoshua Wuyts</span> said on the issue:</p>\n<blockquote>\n<p>I'd like us to consider <a href=\"https://github.com/rust-lang/wg-async-foundations/issues/11\">#11</a>: thread::block_on. And see <a href=\"https://github.com/rust-lang/wg-async-foundations/issues/12\">#12</a> Stream, and <a href=\"https://github.com/rust-lang/wg-async-foundations/issues/14\">#14</a> yield_safe through to stabilization.</p>\n<p>edit: also if @betamos has the bandwidth, I'd love to see his original proposal in <a href=\"https://github.com/rust-lang/wg-async-foundations/issues/19\">#19</a> converted into an RFC.</p>\n</blockquote>",
        "id": 223560732,
        "sender_full_name": "tmandry",
        "timestamp": 1611258239
    },
    {
        "content": "<p>(cc <span class=\"user-mention\" data-user-id=\"137147\">@Didrik Nordstrom</span>)</p>",
        "id": 223560784,
        "sender_full_name": "tmandry",
        "timestamp": 1611258247
    },
    {
        "content": "<p>Thanks for bringing these up, I think they're all reasonable to put on the roadmap</p>",
        "id": 223560816,
        "sender_full_name": "tmandry",
        "timestamp": 1611258262
    },
    {
        "content": "<p>also cc <span class=\"user-mention\" data-user-id=\"204219\">@Matthias247</span> who wrote the original <a href=\"https://github.com/rust-lang/rust/pull/65875\"><code>block_on</code> PR</a></p>",
        "id": 223561003,
        "sender_full_name": "tmandry",
        "timestamp": 1611258347
    },
    {
        "content": "<p>The main thing I am concerned about wrt to that is potentially confusing users that they can use that instead of their executor's version for futures which block on some kind of I/O</p>",
        "id": 223561298,
        "sender_full_name": "tmandry",
        "timestamp": 1611258486
    },
    {
        "content": "<p>That's a fair concern; perhaps we could address by adding some guidance to the RFC for runtimes which we think may be affected by this</p>",
        "id": 223563219,
        "sender_full_name": "Yoshua Wuyts",
        "timestamp": 1611259420
    },
    {
        "content": "<p>(I have the beginnings of an RFC for this;  will make sure to incorporate this point -- I'm holding off on sharing this publicly until we've landed <code>Stream</code> to limit the amount of things we have in flight at any given time)</p>",
        "id": 223563668,
        "sender_full_name": "Yoshua Wuyts",
        "timestamp": 1611259671
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116883\">@tmandry</span> <span class=\"user-mention\" data-user-id=\"211722\">@Yoshua Wuyts</span> Yes, I can convert the \"blocking\" lint to an RFC at this point.</p>",
        "id": 223573630,
        "sender_full_name": "Didrik Nordstrom",
        "timestamp": 1611264860
    },
    {
        "content": "<p>(cc <span class=\"user-mention\" data-user-id=\"119031\">@Esteban KÃ¼ber</span> to this topic too)</p>",
        "id": 224107116,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1611696947
    },
    {
        "content": "<p>Along these lines, I've been starting to think about how we define Rust's \"vision for async I/O\", going beyond a single year.</p>",
        "id": 224241416,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1611778705
    },
    {
        "content": "<p>I've been working on an <a href=\"https://hackmd.io/p6cmRZ9ZRQ-F1tlhGaN9rg\">Async Vision Document</a> -- this is very much an experiment, I'd love to get feedback on the contents and/or structure.</p>",
        "id": 224242371,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1611779206
    },
    {
        "content": "<p>Refreshing to see a materialized vision. Agree with these sentiments.</p>",
        "id": 224255720,
        "sender_full_name": "Didrik Nordstrom",
        "timestamp": 1611785474
    },
    {
        "content": "<blockquote>\n<p>Async is like sync, but with blocking points clearly identified. At the highest level, writing a simple program using asynchronous I/O in Rust should be analogous to writing one that uses synchronous I/O, except that one adds async in front of function declarations and adds .await after each call.</p>\n</blockquote>\n<p>Totally agree. To me, one of the bigger violations of this principle is the inability to reason about and rely on completion of async functions - there are a few proposals for this.</p>\n<blockquote>\n<p>Library ecosystem is key. We want to have a strong ecosystem of async crates, utilities, and frameworks. This will require mechanisms to write libraries/utilities/frameworks that are generic and interoperable across runtimes.</p>\n</blockquote>\n<p>+1, again. We are currently witnessing ecosystem divergence and siloing, affecting not only runtimes but downstream crates and so on. If we look at what we <em>have</em> stabilized so far, (through future and context), it's been an amazing success. Now, synchronization and combinators can be used in any async context - independent of runtime. Making progress in this direction for (in ascending difficulty) spawning tasks, timers,  and I/O is truly important to get closer to this goal.</p>",
        "id": 224256920,
        "sender_full_name": "Didrik Nordstrom",
        "timestamp": 1611786005
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"137147\">@Didrik Nordstrom</span> say more about \"completion\" -- can you please send me examples of the proposals?</p>",
        "id": 224311356,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1611831964
    },
    {
        "content": "<p>Are you think about things like this <a class=\"stream-topic\" data-stream-id=\"249502\" href=\"/#narrow/stream/249502-wg-async-foundations.2Fstream-trait-rfc/topic/start.2Fend.20polling\">#wg-async-foundations/stream-trait-rfc &gt; start/end polling</a>?</p>",
        "id": 224311605,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1611832123
    },
    {
        "content": "<p>I think he's referring to this: <a href=\"#narrow/stream/187312-wg-async-foundations/topic/run.20to.20completion.20async.20fn\">https://rust-lang.zulipchat.com/#narrow/stream/187312-wg-async-foundations/topic/run.20to.20completion.20async.20fn</a></p>",
        "id": 224379755,
        "sender_full_name": "tmandry",
        "timestamp": 1611862060
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> Yes that thread has more context. Conretely: (1) <a href=\"https://github.com/Matthias247/rfcs/pull/1\">https://github.com/Matthias247/rfcs/pull/1</a> and (2) <a href=\"https://internals.rust-lang.org/t/pre-rfc-leave-auto-trait-for-reliable-destruction/13825\">https://internals.rust-lang.org/t/pre-rfc-leave-auto-trait-for-reliable-destruction/13825</a> (async agnostic approach - WIP)</p>",
        "id": 224392857,
        "sender_full_name": "Didrik Nordstrom",
        "timestamp": 1611868083
    },
    {
        "content": "<p>There's overlap between \"async drop\", \"scoped tasks\" and \"completion futures\" (even cancellation propagation is related) in both problem and solution space. It's a little messy. I had plans to start a collaborative summary doc once the proposals have been thoroughly discussed, and ideally prototyped.</p>",
        "id": 224393142,
        "sender_full_name": "Didrik Nordstrom",
        "timestamp": 1611868233
    },
    {
        "content": "<p>I have my neutral hat available for any questions about the current state of things. <span class=\"user-mention\" data-user-id=\"204219\">@Matthias247</span> too I'm sure..</p>",
        "id": 224393389,
        "sender_full_name": "Didrik Nordstrom",
        "timestamp": 1611868364
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"137147\">@Didrik Nordstrom</span> btw, since you revised the proposal significantly you might consider starting a new thread incorporating everything you learned; long threads tend to be pretty intimidating</p>",
        "id": 224417695,
        "sender_full_name": "tmandry",
        "timestamp": 1611881474
    },
    {
        "content": "<p>Totally. I have some homework to do first.</p>",
        "id": 224419861,
        "sender_full_name": "Didrik Nordstrom",
        "timestamp": 1611883156
    },
    {
        "content": "<p>OK, I've caught up a bit. I have to say that I am pretty skeptical of introducing a new type of asynchronous functions.</p>",
        "id": 225185752,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1612456615
    },
    {
        "content": "<p>Introducing async functions at all is a pretty huge cost, in terms of the whole \"what color is your function\" question, but one that we think/claim is worth its cost, because reasoning about async I/O is worth it etc etc</p>",
        "id": 225185859,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1612456657
    },
    {
        "content": "<p>But having <em>two</em> types of such functions? I'd want to be <em>very</em> convinced that we can't address these problems in other ways</p>",
        "id": 225185883,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1612456669
    },
    {
        "content": "<p>I do understand that the existing model makes some tradeoffs, embraces one style over another, and that it is not optimal for all things, but I'm not convinced that this is worth the price of trying to introduce a new form of async fn</p>",
        "id": 225186026,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1612456722
    },
    {
        "content": "<p>That said, I'm going to print out this RFC and read it in detail :)</p>",
        "id": 225186094,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1612456752
    },
    {
        "content": "<p>This is kind of my \"off the cuff\" reaction</p>",
        "id": 225186106,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1612456757
    },
    {
        "content": "<p>I'm on that side too, but I don't want to reject before I've fully understood the proposal and seen the prototype.</p>",
        "id": 225206117,
        "sender_full_name": "Didrik Nordstrom",
        "timestamp": 1612465342
    },
    {
        "content": "<p>If/when you read the RFC make sure to check the updated version, it's mentioned at the top. That'll save you time.</p>",
        "id": 225206178,
        "sender_full_name": "Didrik Nordstrom",
        "timestamp": 1612465368
    },
    {
        "content": "<p>TL;DR it got broken up into two independent features. <code>Leak</code> enables scoped threads and tasks (static borrowing across tasks/threads which is virtually identical to the proposal from 2015 around the \"scoped thread soundness crisis\"). <code>ImplicitDrop</code> enables the compiler to enforce that state machines (such as futures) aren't dropped prematurely by accident. They don't depend on each other.</p>",
        "id": 225206911,
        "sender_full_name": "Didrik Nordstrom",
        "timestamp": 1612465668
    },
    {
        "content": "<p>It sounds more like Niko is talking about Matthias's RFC</p>",
        "id": 225215602,
        "sender_full_name": "tmandry",
        "timestamp": 1612469467
    },
    {
        "content": "<p>I had the same reaction. But I think the design space is worth exploring some until we have an async drop proposal we feel really good about.</p>",
        "id": 225215981,
        "sender_full_name": "tmandry",
        "timestamp": 1612469629
    },
    {
        "content": "<p>After hitting the problem this is trying to solve in <em>very large</em> software ( notably SQLx ), I've thought on this for a long time.</p>\n<p>I very much agree that we need a third color of functions. However, its not as bad as it sounds I don't think. </p>\n<p>For <code>#[completion] async fn</code> I think it would help to frame this as \"suspending\" functions instead of \"asynchronous\" functions. We support an asynchronous computation model fairly well but there is a massive amount of library code that is fairly broken (in the face of cancellation, timeouts, web frameworks cancelling requests, etc.) as its built on the preconception that Rust's model is suspension instead of \"cooperative asynchronous\".</p>\n<p>I would even go as far as saying that async functions as they are now should be linted against for having any <code>&amp;mut</code> parameters. The pitfall is way too easy to fall into.</p>\n<p>Doing so you start to recommend a world of _pure_ asynchronous computation vs. potentially _impure_ suspending execution.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// building block</span>\n<span class=\"k\">async</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">delay</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"cm\">/* ... */</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"c1\">// outer layer</span>\n<span class=\"n\">suspend</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"cm\">/* ... */</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>I would also recommend to avoid the <code>Future</code> suffix here and call it something like <code>std::task::Deferred&lt;Output&gt;</code>. This helps by framing this as a feature instead of a bolt-on to async.  </p>\n<p>If this isn't the right place for this kind of musing, my apologies. New to Zulip here.</p>",
        "id": 225220451,
        "sender_full_name": "Ryan Leckey",
        "timestamp": 1612471811
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116883\">@tmandry</span> Heh, I think you're right. To be clear I was referring to the Pre-RFC posted earlier.</p>",
        "id": 225221551,
        "sender_full_name": "Didrik Nordstrom",
        "timestamp": 1612472368
    },
    {
        "content": "<blockquote>\n<p>I would even go as far as saying that async functions as they are now should be linted against for having any &amp;mut parameters. The pitfall is way too easy to fall into.</p>\n</blockquote>\n<p>In the current state, this would make sense. The vision of \"async should be analogous to sync\" needs some mechanism of preventing against arbitrary interruption..</p>",
        "id": 225222249,
        "sender_full_name": "Didrik Nordstrom",
        "timestamp": 1612472692
    },
    {
        "content": "<p>I think linting any <code>&amp;mut</code> parameters would make <code>async fn</code>s pretty much unusable. There's always a socket, timer, etc in it, and interacting with them mutates some state.</p>",
        "id": 225365289,
        "sender_full_name": "Matthias247",
        "timestamp": 1612563275
    },
    {
        "content": "<p>For the third version of async function: I definitely share the concern of too much functionality and options. However even after multiple years of thinking about it, I can't find another sensible way to cover the scenarios that are supported in other async/await environments.</p>\n<p>Rust would be generally safer than e.g. Swift or C++ or Kotlin regarding threading mistakes, but can't support structured concurrency in the same fashion they do. That's not ideal. And not being able to have a true zero-cost abstraction over completion-based IO (which is common in async systems) is also not perfect. </p>\n<p>In terms of usage I see things pretty much the same as <span class=\"user-mention\" data-user-id=\"238574\">@Ryan Leckey</span> : Application developers in the future would mostly interact with completion based functions. The regular <code>async fn</code> provides some smaller building blocks - like interacting with channels, timers, synchronization primitives.<br>\nI think this is teachable with guidance like \"Use the completion based function, unless you wan't your function to be interruptible at any point and are sure it has no negative side effects\".</p>\n<p>But the \"teachable\" part is the one where I have the strong preference about a completable function keyword/attribute, instead of a more general <code>Leak</code> one. The first one explains people it's use case, whereas the second one informs them how the desired functionality is achieved. But in order to understand the \"how\", one needs to have bigger background knowledge,</p>",
        "id": 225367413,
        "sender_full_name": "Matthias247",
        "timestamp": 1612564594
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"204219\">Matthias247</span> I think linting any &amp;mut parameters would make async fns pretty much unusable. There's always a socket, timer, etc in it, and interacting with them mutates some state.</p>\n</blockquote>\n<p>My point with that lint would be to push people to the new completion-based async paradigm. </p>\n<p>A timer has mutable state, yes, but not _externally-observable_ mutable state. It's <code>delay(duration).await</code>. </p>\n<p>Interacting with a socket/stream within <code>async fn</code> such as <code>async fn foo(stream: &amp;mut TcpStream)</code> is extremely prone to bugs. As an example, in <code>futures-rs</code> the <code>write_all</code> method is very dangerous as you can drop the future for it and you will have no idea how much of the buffer was written to the stream. </p>\n<p>There are lots of what I would call async _primitives_ that can be done with a restricted <code>async fn</code> and be consistent.</p>",
        "id": 225370841,
        "sender_full_name": "Ryan Leckey",
        "timestamp": 1612567065
    },
    {
        "content": "<blockquote>\n<p>But the \"teachable\" part is the one where I have the strong preference about a completable function keyword/attribute,</p>\n</blockquote>\n<p>Yeah, this is where I'm coming from when I want to call these suspending functions to mirror Kotlin. We want people to type them easily and not be a second choice. </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">suspend</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">process</span><span class=\"p\">(</span><span class=\"n\">stream</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">TcpStream</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">i32</span> <span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>With the return type of <code>impl std::task::Deferred&lt;i32&gt;</code>, this now feels like a separate (but complementary) feature from futures and not something tacked on to fix a problem. Especially so with the lint, Rust devs will have guidelines on when to use what kind of method.</p>",
        "id": 225371195,
        "sender_full_name": "Ryan Leckey",
        "timestamp": 1612567356
    },
    {
        "content": "<p>Some IO primitives are definitely broken when cancelled currently. E.g. everything which buffers internally, or employs some flow control hacks (like all TLS libraries do) is endangered. See e.g. <a href=\"https://github.com/tokio-rs/tls/issues/41\">https://github.com/tokio-rs/tls/issues/41</a></p>\n<p>I think most of those should realisitically just close the underyling handle whenever the first operation is aborted - which works with <code>Future</code>s, but not with <code>AsyncRead/Write</code></p>",
        "id": 225376248,
        "sender_full_name": "Matthias247",
        "timestamp": 1612571560
    },
    {
        "content": "<blockquote>\n<p>With the return type of impl std::task::Deferred&lt;i32&gt;, this now feels like a separate (but complementary) feature from futures and not something tacked on to fix a problem.</p>\n</blockquote>\n<p>Interesting thought. I think we can see it both ways: A different name feels less tackled on. But a similar than indicates that it is not really that much different, and also not fully incompatible. <br>\nI'm personally fine with both approaches</p>",
        "id": 225376340,
        "sender_full_name": "Matthias247",
        "timestamp": 1612571658
    },
    {
        "content": "<blockquote>\n<p>I think most of those should realisitically just close the underyling handle whenever the first operation is aborted</p>\n</blockquote>\n<p>Some of the underlying handles are relatively <strong>expensive</strong> to open. Specifically I'm referring to SQLx. I'm currently rewriting its core to handle the implicit cancellation problem. It's not impossible to do correctly, just requires being _very_ careful. If an operation is dropped (e.g., a query command), what happens now is in the next command, any partially written data finishes being written and packets emitted from that are popped off the stream before we consider any output as relevant. </p>\n<hr>\n<p>In the RFC you've mentioned that \"completion\" async functions could not be called from regular async. Technically I don't see that being impossible as long as we have a way to \"spawn\" in std. It's less efficient for sure, but it could be a nice thing to specify so the function types _can_ be mixed (and mixing like that can always be linted against).</p>",
        "id": 225377358,
        "sender_full_name": "Ryan Leckey",
        "timestamp": 1612572888
    },
    {
        "content": "<p>Sure, spawning on a long-running runtime and waiting on a handle work. But I don't call this \"directly called\". It's not efficient, and hasn't the same semantics (the background task can outlive the calling task).</p>",
        "id": 225384395,
        "sender_full_name": "Matthias247",
        "timestamp": 1612583053
    }
]