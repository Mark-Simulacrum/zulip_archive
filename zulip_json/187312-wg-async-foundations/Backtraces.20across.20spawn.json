[
    {
        "content": "<p>I posted this in <a href=\"https://twitter.com/theinedibleholk/status/1470914103786938372?s=20\">tweet form</a>, but it's worth mentioning here for a more in-depth discussion. For async stack traces, would folks expect the trace to traverse across spawns?</p>\n<div class=\"inline-preview-twitter\"><div class=\"twitter-tweet\"><a href=\"https://twitter.com/theinedibleholk/status/1470914103786938372?s=20\"><img class=\"twitter-avatar\" src=\"https://uploads.zulipusercontent.net/8c1d7ec4279540b57e7631183ef1bb97a8ce6340/68747470733a2f2f7062732e7477696d672e636f6d2f70726f66696c655f696d616765732f313533373930303636392f3330393235375f3533393633303032353233335f32393230303631335f33303932323033305f3238353532353137335f6e5f6e6f726d616c2e6a7067\"></a><p>I'm curious what people would like to see in the backtrace from this program: <a href=\"https://t.co/MnrhSZ4YuH\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=45c5290aed389dae2fda5ca325986349</a>\n\nI'll post a couple rough ideas as replies to this tweet, but let me know what you like best.</p><span>- Eric Holk (@theinedibleholk)</span></div></div><p>I have an example on the <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=0f3eb177fd94b289c70704aa3e520192\">playground</a>, but here's the code:</p>\n<div class=\"codehilite\"><pre><span></span><code>fn main() {\n    let runtime = tokio::runtime::Builder::new_multi_thread()\n        .worker_threads(2)\n        .enable_all()\n        .build()\n        .unwrap();\n\n    runtime.block_on(foo());\n}\n\nasync fn foo() {\n    tokio::spawn(bar()).await.expect(&quot;task failed&quot;);\n}\n\nasync fn bar() {\n    panic!();\n}\n</code></pre></div>\n<p>It looks like right now with <code>RUST_BACKTRACE=1</code> we basically get a trace of all threads, so one shows <code>main</code>, then all the runtime setup/spawn code, and then <code>foo()</code>, and the other thread basically shows <code>bar()</code> with all the panicking and panic handler gunk. Is this structure ideal (obviously we'd like to clean up a lot of the extraneous frames)?</p>\n<p>Or, would it make sense to see a unified stack trace that looks something like this?</p>\n<div class=\"codehilite\"><pre><span></span><code>1. bar()\n2. foo()\n3. main()\n</code></pre></div>\n<p>I suppose the unified stack trace could have some more details, like we could annotate each frame with the actual thread it is running on.</p>",
        "id": 264950503,
        "sender_full_name": "eholk",
        "timestamp": 1639529050
    },
    {
        "content": "<p>I think <span class=\"user-mention\" data-user-id=\"124287\">@mw</span> and I had talked about this some. I'd like to eventually see information about where a task was spawned in logical async stack traces. It might be confusing to include it as \"just another frame\" in the normal future-based stack, but it might not be. Either way I think it'd be good to capture that information at spawn time (with a config knob to enable/disable, since this can affect performance)</p>",
        "id": 264962767,
        "sender_full_name": "tmandry",
        "timestamp": 1639541017
    },
    {
        "content": "<p>Yeah, I agree that the backtrace should not cross spawn, but it is information that would be good to have available (and similar things like what's happening at the other end of a channel, or who is holding a lock that a task is blocked on).</p>",
        "id": 264991437,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1639565350
    },
    {
        "content": "<p>This all has obvious parallels with non-async things. I'm pretty sure nobody has looked into Rust-specific stuff here, but there might be prior art in other languages which are worth looking into</p>",
        "id": 264991567,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1639565405
    },
    {
        "content": "<p>That's a good idea to look at prior art in other languages. I started thinking about this particular case after reading this series of blog posts: <a href=\"https://developers.facebook.com/blog/post/2021/09/16/async-stack-traces-folly-Introduction/\">https://developers.facebook.com/blog/post/2021/09/16/async-stack-traces-folly-Introduction/</a> (there are five posts, that's just the first one but it has links to the others).</p>\n<p>It looks like they choose to have stack traces cross tasks, but the backtrace goes through the await points and not the spawn points.</p>",
        "id": 265024843,
        "sender_full_name": "eholk",
        "timestamp": 1639581772
    },
    {
        "content": "<p>V8 (Node.js / Google Chrome) added support for async backtraces in JavaScript a good while ago: <a href=\"https://docs.google.com/document/d/13Sy_kBIJGP0XT34V1CV3nkWya4TwYx9L3Yv45LdGB6Q/edit\">https://docs.google.com/document/d/13Sy_kBIJGP0XT34V1CV3nkWya4TwYx9L3Yv45LdGB6Q/edit#</a>!</p>",
        "id": 265585912,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1640017948
    },
    {
        "content": "<p>I actually started using async backtraces in JS before I moved to Rust full-time, and being able to debug async code using logical backtraces made a _huge_ difference for debugging errors.</p>",
        "id": 265586124,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1640018052
    },
    {
        "content": "<p>The V8 post is interesting. One thing that stood out to me is how the JS spec describes both the language and runtime, and since V8 implements both they can assume a lot more about the internals of promise chains.</p>",
        "id": 265609478,
        "sender_full_name": "eholk",
        "timestamp": 1640030454
    },
    {
        "content": "<p>For Rust, I think there's a question of how much of the responsibility for stack traces falls on the language and how much falls on the runtime.</p>",
        "id": 265609530,
        "sender_full_name": "eholk",
        "timestamp": 1640030484
    }
]