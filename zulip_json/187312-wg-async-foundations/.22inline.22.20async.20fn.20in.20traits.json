[
    {
        "content": "<p>So I have this idea that I think could be a nice optimization and also a game changer that basically makes custom poll functions (like those found in <code>AsyncRead</code>, <code>AsyncWrite</code>, and the <code>AsyncDrop</code> that <span class=\"user-mention\" data-user-id=\"256759\">@boats</span> proposed) obsolete. I wrote it up here:</p>\n<p><a href=\"https://hackmd.io/bKfiVPRpTvyX8JK_Ng2EWA?view\">https://hackmd.io/bKfiVPRpTvyX8JK_Ng2EWA?view</a></p>\n<p>I'd be curious to know what people think.</p>",
        "id": 239721278,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621589075
    },
    {
        "content": "<p>Hm, I'm a bit unhappy with the action at a distance, particularly if you implement a bunch of different traits for the same type you get a long invisible suffix. (at the very least, requiring the type to be repr(Rust) seems good, or perhaps even repr(async_trait_container)). Figuring out how to expose the relevant lifetimes from the added state and any potential relationships also seems annoying.</p>\n<p>It seems a bit unfortunate that we have to resort to such things, too, but at some level I do like the idea. I think it doesn't really feel like it should be constrained to async fn, vs just \"one way\" to represent impl trait return types in traits, or even <em>the</em> way with a repr(dyn)...? It seems unfortunate that the struct would likely end up pretty huge if it implemented multiple such traits, as e.g. a File would...</p>",
        "id": 239733901,
        "sender_full_name": "simulacrum",
        "timestamp": 1621596107
    },
    {
        "content": "<p>How does this idea relate to GATs (at minimum, TAIT) for async trait methods?</p>",
        "id": 239735891,
        "sender_full_name": "Dirkjan Ochtman",
        "timestamp": 1621597184
    },
    {
        "content": "<p>It's true that if you implement a bunch of such traits for one type it could grow precipitously in size. Of course, I'm not sure that's a very likely scenario.</p>",
        "id": 239765135,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621609427
    },
    {
        "content": "<p>I plan to write up a kind of survey of the \"dyn safe\" space in a bit</p>",
        "id": 239765210,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621609446
    },
    {
        "content": "<p>I think there are a few options</p>",
        "id": 239765221,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621609450
    },
    {
        "content": "<p>It seems to me that there isn't a single \"best option\" that fits everything</p>",
        "id": 239765252,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621609464
    },
    {
        "content": "<p>Ah, there is one other interesting thing about this proposal:</p>",
        "id": 239765275,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621609474
    },
    {
        "content": "<p>I just remembered</p>",
        "id": 239765280,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621609476
    },
    {
        "content": "<p>It's actually <em>very important</em> for <code>Drop</code> that <em>all the storage it needs is in the self type</em></p>",
        "id": 239765305,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621609489
    },
    {
        "content": "<p>this is because:</p>",
        "id": 239765327,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621609496
    },
    {
        "content": "<p>if you have </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"o\">&lt;</span><span class=\"n\">T</span>: <span class=\"nb\">Default</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 239765401,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621609523
    },
    {
        "content": "<p>the resulting Future is send if <code>T: Send</code></p>",
        "id": 239765453,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621609542
    },
    {
        "content": "<p>but if that may instantiat a drop future</p>",
        "id": 239765551,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621609565
    },
    {
        "content": "<p>we would need to account for that</p>",
        "id": 239765565,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621609573
    },
    {
        "content": "<p>we could plausibly do that with a <code>T</code> that we know</p>",
        "id": 239765579,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621609577
    },
    {
        "content": "<p>e.g., it'd be like a where clause <code>&lt;T as AsyncDrop&gt;::DropFuture: Send</code></p>",
        "id": 239765612,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621609592
    },
    {
        "content": "<p>but for a <code>Box&lt;dyn Future&gt;</code> sort of thing</p>",
        "id": 239765639,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621609600
    },
    {
        "content": "<p>it's going to be much trickier and weirder</p>",
        "id": 239765655,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621609607
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/.22inline.22.20async.20fn.20in.20traits/near/239765135\">said</a>:</p>\n<blockquote>\n<p>It's true that if you implement a bunch of such traits for one type it could grow precipitously in size. Of course, I'm not sure that's a very likely scenario.</p>\n</blockquote>\n<p>one other point: I made the repr \"invisible\" at the impl site, but there is no real reason to do that</p>",
        "id": 239765712,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621609636
    },
    {
        "content": "<p>that might help with the action at a distance, <span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> -- you could have to \"opt in\" in some way on the struct itself</p>",
        "id": 239765738,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621609650
    },
    {
        "content": "<p>Another option would be to forbid the use of local variables live across awaits, and force people to put that state directly into their struct</p>",
        "id": 239765997,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621609755
    },
    {
        "content": "<p>but to me, that seems strictly less nice</p>",
        "id": 239766009,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621609761
    },
    {
        "content": "<p>still, it might be adequare for most everything</p>",
        "id": 239766030,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621609771
    },
    {
        "content": "<p>I'd prefer that the solution is general enough that it works for not just async fn regardless, personally, at least as an easy-ish future extension</p>",
        "id": 239766135,
        "sender_full_name": "simulacrum",
        "timestamp": 1621609809
    },
    {
        "content": "<p>e.g., <code>trait Foo { fn bar(&amp;mut self) -&gt; impl Iterator; }</code></p>",
        "id": 239766183,
        "sender_full_name": "simulacrum",
        "timestamp": 1621609829
    },
    {
        "content": "<p>it could be extended to other traits, yes</p>",
        "id": 239766247,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621609857
    },
    {
        "content": "<p>I think though that would work best</p>",
        "id": 239766326,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621609890
    },
    {
        "content": "<p>if we had generators</p>",
        "id": 239766329,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621609892
    },
    {
        "content": "<p>I added some notes about these things to the doc for now</p>",
        "id": 239766502,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621609951
    },
    {
        "content": "<p>hm I don't see how generators play into it - I mean that <em>in general</em> you're basically solving the problem of \"function returns a thing that implements Foo and has an unknown to the caller size\"</p>",
        "id": 239766757,
        "sender_full_name": "simulacrum",
        "timestamp": 1621610056
    },
    {
        "content": "<p>and you likely want it to be true that if you call it in a generic/known-type context, i.e., not through dyn trait, the compiler still sees through any hiding and doesn't need all this embedding magic</p>",
        "id": 239766816,
        "sender_full_name": "simulacrum",
        "timestamp": 1621610091
    },
    {
        "content": "<p>that might not be possible, though, not sure.</p>",
        "id": 239766840,
        "sender_full_name": "simulacrum",
        "timestamp": 1621610103
    },
    {
        "content": "<p>I agree it's not limited to generators</p>",
        "id": 239767172,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621610206
    },
    {
        "content": "<p>well</p>",
        "id": 239767189,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621610219
    },
    {
        "content": "<p>it has to \"lock\" the self, to start, and it requires that the trait is something with a \"from-fn\" method</p>",
        "id": 239767219,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621610234
    },
    {
        "content": "<p>async fn gaurantees those properties</p>",
        "id": 239767239,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621610242
    },
    {
        "content": "<p>your signature for example does not</p>",
        "id": 239767248,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621610246
    },
    {
        "content": "<p>it would have to be <code>fn bar(&amp;mut self) -&gt; impl Iterator + '_</code></p>",
        "id": 239767291,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621610266
    },
    {
        "content": "<p>but if it were that, it should work</p>",
        "id": 239767312,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621610274
    },
    {
        "content": "<p>sure, that's true</p>",
        "id": 239767770,
        "sender_full_name": "simulacrum",
        "timestamp": 1621610467
    },
    {
        "content": "<p>In theory you could imagine that the dyn trait has a Layout stored, and the caller needs to pass a *mut to memory for that layout</p>",
        "id": 239767855,
        "sender_full_name": "simulacrum",
        "timestamp": 1621610501
    },
    {
        "content": "<p>(not literally, but in the ABI)</p>",
        "id": 239767869,
        "sender_full_name": "simulacrum",
        "timestamp": 1621610508
    },
    {
        "content": "<p>yes, in theory</p>",
        "id": 239767960,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621610534
    },
    {
        "content": "<p>and they can do that by allocating -- Box -- by knowing the size since they know the type, so being able to put it on the stack directly before calling</p>",
        "id": 239767969,
        "sender_full_name": "simulacrum",
        "timestamp": 1621610536
    },
    {
        "content": "<p>one thing worth pointing out is that async fn cannot use alloca</p>",
        "id": 239767981,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621610541
    },
    {
        "content": "<p>hm, why not?</p>",
        "id": 239768160,
        "sender_full_name": "simulacrum",
        "timestamp": 1621610626
    },
    {
        "content": "<p>because their \"stack frame' is actually a struct</p>",
        "id": 239768170,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621610635
    },
    {
        "content": "<p>I think this also implies that the \"unsized rvalues\" RFC needs to be scaled back to more the original, alloca-less variant</p>",
        "id": 239768295,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621610671
    },
    {
        "content": "<p>I guess, I'm not sure why that matters -- you just need a place to put that stack frame on the stack, right? And then pin it?</p>",
        "id": 239768360,
        "sender_full_name": "simulacrum",
        "timestamp": 1621610700
    },
    {
        "content": "<p>when you run an async fn, all of its storage that might live across an await has to be placed into a struct</p>",
        "id": 239768441,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621610732
    },
    {
        "content": "<p>me and <span class=\"user-mention\" data-user-id=\"116883\">@tmandry</span> were considering a case where you used alloca to allocate enough space for the future</p>",
        "id": 239768470,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621610747
    },
    {
        "content": "<p>but in that case, you'd have to have a variable-sized field in the struct</p>",
        "id": 239768482,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621610755
    },
    {
        "content": "<p>which of course you cannot do</p>",
        "id": 239768495,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621610761
    },
    {
        "content": "<p>so you'd need to have some \"max size\" and use an allocator over that</p>",
        "id": 239768555,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621610770
    },
    {
        "content": "<p>at which point you've got a rather different feature, which is one of the ones I'd like to enumerate as a possibility, but which I also do not like as much in some other respects</p>",
        "id": 239768618,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621610793
    },
    {
        "content": "<p>I thought a future's size is statically known -- this seems true, otherwise Box wouldn't work either</p>",
        "id": 239768658,
        "sender_full_name": "simulacrum",
        "timestamp": 1621610810
    },
    {
        "content": "<p>that's exactly the point</p>",
        "id": 239768679,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621610818
    },
    {
        "content": "<p>you're invoking an unknown future</p>",
        "id": 239768702,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621610827
    },
    {
        "content": "<p>oh, you mean that you can't recursively do this</p>",
        "id": 239768713,
        "sender_full_name": "simulacrum",
        "timestamp": 1621610832
    },
    {
        "content": "<p>but your size must be statically known</p>",
        "id": 239768720,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621610834
    },
    {
        "content": "<p>yeah that's true</p>",
        "id": 239768734,
        "sender_full_name": "simulacrum",
        "timestamp": 1621610838
    },
    {
        "content": "<p>well, arguably, that's no different to a recursive call today -- which must also be boxed for a similar reason</p>",
        "id": 239769044,
        "sender_full_name": "simulacrum",
        "timestamp": 1621610972
    },
    {
        "content": "<p>(we don't know how deep the recursion will go so can't statically allocate you)</p>",
        "id": 239769064,
        "sender_full_name": "simulacrum",
        "timestamp": 1621610982
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/.22inline.22.20async.20fn.20in.20traits/near/239769044\">said</a>:</p>\n<blockquote>\n<p>well, arguably, that's no different to a recursive call today -- which must also be boxed for a similar reason</p>\n</blockquote>\n<p>I don't know what this means :)</p>",
        "id": 239772920,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621612460
    },
    {
        "content": "<p>t's true that a recursive call must be boxed</p>",
        "id": 239772933,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621612466
    },
    {
        "content": "<p>I'm just not sure what that has to do with these sorts of calls, which are not recursive</p>",
        "id": 239772960,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621612477
    },
    {
        "content": "<p>(or at least, not necessarily recursive)</p>",
        "id": 239773020,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621612497
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116883\">@tmandry</span> this topic exists</p>",
        "id": 239788639,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621619407
    },
    {
        "content": "<blockquote>\n<p>tmandry: I mean I think having it inside makes sense for today's async fn futures</p>\n</blockquote>",
        "id": 239788646,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621619413
    },
    {
        "content": "<p>it is what the current traits would have you do, if that's what you mean</p>",
        "id": 239788692,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621619433
    },
    {
        "content": "<p>Iâ€™d love to see some examples of things that implement both AsyncRead and AsyncWrite where the two are used simultaneously (cc <span class=\"user-mention\" data-user-id=\"211731\">@Sean McArthur</span>)</p>",
        "id": 239788862,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621619523
    },
    {
        "content": "<p>First example that comes to mind is HTTP/2 over a TcpStream</p>",
        "id": 239788939,
        "sender_full_name": "Sean McArthur",
        "timestamp": 1621619555
    },
    {
        "content": "<p>links! links!</p>",
        "id": 239788948,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621619563
    },
    {
        "content": "<p>its not easy to point at</p>",
        "id": 239788974,
        "sender_full_name": "Sean McArthur",
        "timestamp": 1621619575
    },
    {
        "content": "<p>I have faith in you</p>",
        "id": 239788999,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621619592
    },
    {
        "content": "<p>:P</p>",
        "id": 239789052,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621619630
    },
    {
        "content": "<p>what I'm trying to figure out is</p>",
        "id": 239789057,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621619634
    },
    {
        "content": "<p>I want to know how much the impls make use of the <code>&amp;mut self</code></p>",
        "id": 239789121,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621619651
    },
    {
        "content": "<p>to what extent are they mutating data</p>",
        "id": 239789142,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621619658
    },
    {
        "content": "<p>you could imagine having an <code>AsyncReadWrite</code> that supports both simultaneously, but with an <code>&amp;self</code></p>",
        "id": 239789169,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621619672
    },
    {
        "content": "<p>(based on an idea I just had...)</p>",
        "id": 239789181,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621619676
    },
    {
        "content": "<p>but it would require <code>Cell</code> and <code>RefCell</code> etc to mutate fields</p>",
        "id": 239789206,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621619691
    },
    {
        "content": "<p>ignoring <code>Send</code> for a second, how terrible would that be?</p>",
        "id": 239789225,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621619699
    },
    {
        "content": "<p>for something like a file descriptor, not bad at all</p>",
        "id": 239789235,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621619704
    },
    {
        "content": "<p>Yea, so at the core you'd be waiting on readiness for both read and write on the socket itself</p>",
        "id": 239789272,
        "sender_full_name": "Sean McArthur",
        "timestamp": 1621619719
    },
    {
        "content": "<p>since multiplexing many streams over a single socket means you _can't_  block writing a frame for one stream on reading the next frame for whichever stream it happens to be</p>",
        "id": 239789365,
        "sender_full_name": "Sean McArthur",
        "timestamp": 1621619763
    },
    {
        "content": "<p>So it seems like we could wave some hands and say \"ya ya, concurrently doing that on a socket is actually safe because the OS makes it so\"</p>",
        "id": 239789487,
        "sender_full_name": "Sean McArthur",
        "timestamp": 1621619818
    },
    {
        "content": "<p>but inevitably, you get wrapping types that build in buffering (both directions), or some sort of decode state, etc, and _then_ it's not actually safe to have 2 mut refs</p>",
        "id": 239789578,
        "sender_full_name": "Sean McArthur",
        "timestamp": 1621619872
    },
    {
        "content": "<p>could you \"decompose\" the socket into two objects, one for reading and one for writing?</p>",
        "id": 239789752,
        "sender_full_name": "tmandry",
        "timestamp": 1621619955
    },
    {
        "content": "<p>you could, but then you need something like an <code>Arc</code></p>",
        "id": 239789840,
        "sender_full_name": "Sean McArthur",
        "timestamp": 1621619997
    },
    {
        "content": "<p>I didn't mean to say the idea is impossible, just that it might not be free (or maybe there's some crazy magic to uncover).</p>",
        "id": 239790001,
        "sender_full_name": "Sean McArthur",
        "timestamp": 1621620042
    },
    {
        "content": "<p>I'm imagining something where original object could stick around and these both hold a reference. could ensure there aren't duplicates by making them come from <code>&amp;mut self</code> or something</p>",
        "id": 239790260,
        "sender_full_name": "tmandry",
        "timestamp": 1621620143
    },
    {
        "content": "<p>Another example is a duplex tcp proxy, where you want to forward in both directions as the data becomes available. linkerd2 has one, I think tokio got also has a <code>copy_bidirectional</code> helper?</p>",
        "id": 239790937,
        "sender_full_name": "Sean McArthur",
        "timestamp": 1621620449
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/.22inline.22.20async.20fn.20in.20traits/near/239772960\">said</a>:</p>\n<blockquote>\n<p>I'm just not sure what that has to do with these sorts of calls, which are not recursive</p>\n</blockquote>\n<p>I'm saying one could argue that the caller for these sorts of calls needs to provide somewhere to put it: whether that's a Box, or some arena, or inside their type. The last of those is not ergonomic today, but we could help with it in a variety of ways (e.g., such as you've suggested, by some repr attributes).</p>",
        "id": 239793132,
        "sender_full_name": "simulacrum",
        "timestamp": 1621621507
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243965\">Sean McArthur</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/.22inline.22.20async.20fn.20in.20traits/near/239790001\">said</a>:</p>\n<blockquote>\n<p>I didn't mean to say the idea is impossible, just that it might not be free (or maybe there's some crazy magic to uncover).</p>\n</blockquote>\n<p>it's not super crazy to imagine a <code>&amp;mut self</code> that can't hold references across awaits and where the compiler treats it as \"releasing\" the <code>&amp;mut</code>, but I don't know that I love the idea from a user's perspective</p>",
        "id": 239859417,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621675259
    },
    {
        "content": "<p>that said, another option -- which is interesting -- is something like</p>",
        "id": 239859430,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621675268
    },
    {
        "content": "<p>well, hmm. I was going to say that there's a lower-level trait that you can manually implement if you choose</p>",
        "id": 239859506,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621675338
    },
    {
        "content": "<p>which is certainly possible</p>",
        "id": 239859508,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621675343
    },
    {
        "content": "<p>but I'm not sure it's going to work out well</p>",
        "id": 239859514,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621675349
    },
    {
        "content": "<p>of course the cell-ref-cell idea is plausible too, but that is a kind of overhead (in the multithreaded case in particular, where that translates to actual mutexes, even if they'll never really be needed)</p>",
        "id": 239859522,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621675377
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243965\">@Sean McArthur</span> I'd still like links into the source so I can read up on those types more directly</p>",
        "id": 239941192,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621765983
    },
    {
        "content": "<p>The bidirectional copy is much simpler to link to: <a href=\"https://github.com/tokio-rs/tokio/blob/master/tokio/src/io/util/copy_bidirectional.rs\">https://github.com/tokio-rs/tokio/blob/master/tokio/src/io/util/copy_bidirectional.rs</a></p>",
        "id": 239960895,
        "sender_full_name": "Sean McArthur",
        "timestamp": 1621786068
    },
    {
        "content": "<p>One strategy for supporting concurrent read / writes would be to have an IoReady trait that lets the caller specify which direction they want to listen for: <code>my_io.ready(Ready::Readable | Ready::Writable).awiat</code> then have <code>TryRead</code> and <code>TryWrite</code> traits instead (<code>fn try_read(&amp;mut self, ...) -&gt; io::Result&lt;()&gt;). These would be non-blocking calls and could return </code>io::Result`. This would make implementing read / write trickier and also not be super io-uring friendly.</p>",
        "id": 240077809,
        "sender_full_name": "Carl Lerche",
        "timestamp": 1621874843
    },
    {
        "content": "<p>Alternatively, maybe there is an option where implementations like Tokio TcpStream can implement the de-sugarded versions by hand, then maybe we can make <code>impl AsyncRead for &amp;TcpStream</code> work</p>",
        "id": 240077919,
        "sender_full_name": "Carl Lerche",
        "timestamp": 1621874894
    },
    {
        "content": "<p>THe main missing piece for ^^ to work afaik is some hook indicating the async fn is cancelled so we can cleanup internal state</p>",
        "id": 240077970,
        "sender_full_name": "Carl Lerche",
        "timestamp": 1621874918
    },
    {
        "content": "<p>Besides that, <a href=\"https://github.com/hyperium/h2/tree/master/src/codec\">h2's codec</a> has some encoding and decoding state on top of the <code>AsyncRead + AsyncWrite</code> (which itself builds on top of <code>tokio_util::codec</code>), but then all the stream state happens, and all that is managed inside a single <code>Connection::poll</code>.</p>",
        "id": 240078026,
        "sender_full_name": "Sean McArthur",
        "timestamp": 1621874949
    },
    {
        "content": "<p>Well, implementing AsyncRead for &amp;TcpStream would be a bit more complicated... but there probably is a way to make it work</p>",
        "id": 240078275,
        "sender_full_name": "Carl Lerche",
        "timestamp": 1621875054
    },
    {
        "content": "<p>I already commented on amazon slack regarding this, but I somehow mistook the origin of the doc and also not everyone has access to it. So here again:</p>\n<p>This seems pretty similar to what I described at <a href=\"https://internals.rust-lang.org/t/async-traits-the-less-dynamic-allocations-edition/13048/10\">https://internals.rust-lang.org/t/async-traits-the-less-dynamic-allocations-edition/13048/10</a> .</p>\n<p>However it has some pros:</p>\n<ul>\n<li>Static dispatch and allowing better inling</li>\n<li>Even the first dynamic allocation is saved, which makes it more interesting for interfaces which are only called once</li>\n<li>Compiler is doing the job, and no proc macro dependency</li>\n</ul>\n<p>And some cons:</p>\n<ul>\n<li>You don't get a nicely type-erased future back anymore (e.g. when you want to put them into a FuturesUnordered or so</li>\n<li>Works only for <code>&amp;mut self</code> calls.</li>\n</ul>\n<p>I think the latter kind of adds more confusion to the topic than that it helps. People will ask \"why does this limitation exist\", and one has to go down into all the nittgy gritty details of how this desugars to explain. So I'm rather not inlined of directly having this.</p>",
        "id": 240097314,
        "sender_full_name": "Matthias247",
        "timestamp": 1621883395
    },
    {
        "content": "<p>One thing which is more about the article style which confused me is that it in the beginning talks about <code>AsyncDrop</code> and sounds like it would solve the async drop problem - but it really doesn't. The same challenges of the drop method having no guarantee to be called continues to exist. I therefore think it's fine to leave it out for this proposal, and talk about this separately.</p>",
        "id": 240097582,
        "sender_full_name": "Matthias247",
        "timestamp": 1621883520
    },
    {
        "content": "<p>One example where <code>&amp;self</code> can be useful:</p>\n<p><a href=\"https://github.com/rust-lang/futures-rs/issues/1365\">https://github.com/rust-lang/futures-rs/issues/1365</a> was probably the very first issue where discussion about better async IO traits was brought up.</p>\n<p>In the first post there is an example of an in-memory channel which and async send/receive interface where each side could adhere to a trait. The implementation in there could easily be switched to take <code>&amp;self</code> instead of <code>&amp;mut self</code> and thereby to represent a MPMC channel. While this is implementable using purely async/await as the example shows, the proposed async trait version couldn't model that.</p>\n<p>Something similar can be said about OS file IO, since sockets can really be read/written from concurrently.</p>",
        "id": 240099755,
        "sender_full_name": "Matthias247",
        "timestamp": 1621884526
    },
    {
        "content": "<p><strong>However something interesting occured to me: One can combine this proposal for async traits and combine it with <a href=\"#narrow/stream/187312-wg-async-foundations/topic/run.20to.20completion.20async.20fn\">https://rust-lang.zulipchat.com/#narrow/stream/187312-wg-async-foundations/topic/run.20to.20completion.20async.20fn</a> </strong></p>\n<p>If functions run to completion (are just intended to be directly <code>.await</code>ed, there shouldn't be any place anymore where multiple states for <code>&amp;self</code> futures are required for the <code>!Sync</code> case, and those states could also be stored inline. Still doesn't solve the <code>Sync</code> case yet, but one step closer.</p>",
        "id": 240100388,
        "sender_full_name": "Matthias247",
        "timestamp": 1621884767
    },
    {
        "content": "<p>It actually works for <code>&amp;self</code> too, but you can't add add'l fields</p>",
        "id": 240377265,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1622056974
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224941\">Carl Lerche</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/.22inline.22.20async.20fn.20in.20traits/near/240077919\">said</a>:</p>\n<blockquote>\n<p>Alternatively, maybe there is an option where implementations like Tokio TcpStream can implement the de-sugarded versions by hand, then maybe we can make <code>impl AsyncRead for &amp;TcpStream</code> work</p>\n</blockquote>\n<p>I'm more and into the idea of supporting <code>&amp;self</code> and having an <code>AsyncReadWrite</code> interface</p>",
        "id": 240377340,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1622057016
    },
    {
        "content": "<p>but I thnk I'm going to want to rework the doc into multiple versions, there's a lot of moving parts and I'm not sure which one is best altogether</p>",
        "id": 240377399,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1622057041
    },
    {
        "content": "<p>let me take a look at the internals thread that <span class=\"user-mention\" data-user-id=\"204219\">@Matthias247</span> cited though</p>",
        "id": 240377456,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1622057053
    },
    {
        "content": "<p>I see. Interesting.</p>",
        "id": 240377731,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1622057174
    },
    {
        "content": "<p>seems like it can be implemented atop this verson</p>",
        "id": 240377750,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1622057188
    },
    {
        "content": "<p>I'm not sure if there's going to be a \"one size fits all\" version here, in the end</p>",
        "id": 240377786,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1622057205
    },
    {
        "content": "<p>afaik this \"inline\" repr is the only representation that can accommodate async-drop</p>",
        "id": 240377801,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1622057215
    },
    {
        "content": "<p>What would <code>AsyncReadWrite</code> look like?</p>",
        "id": 240485056,
        "sender_full_name": "Carl Lerche",
        "timestamp": 1622129155
    },
    {
        "content": "<p>I'm been thinking more about this and I think my idea ddn't quite work as is</p>",
        "id": 240626329,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1622218242
    },
    {
        "content": "<p>In particular, if you have an <code>&amp;self</code> method, I don't really think it's feasible to work with <code>RefCell</code>, and I don't know how you could delegate to another future</p>",
        "id": 240626392,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1622218275
    },
    {
        "content": "<p>you'd have to do a refcell borrow, and that would create a temporary, and that temporary would have to be preserved across the await, so it really doesn't work.</p>",
        "id": 240626426,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1622218297
    },
    {
        "content": "<p>that said, I'm now starting to think about other thoughts :) what if we had the ability to declare that two <code>&amp;mut self</code> methods must be able to execute simultaneously? it'd be useful in other contexts</p>",
        "id": 240626524,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1622218334
    },
    {
        "content": "<p>that said, you could also have a trait that makes \"split\" into more of a first-class operation, but I don't know how you do that without requiring some extensions to rust's borrowing system; have to think abou that</p>",
        "id": 240626594,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1622218375
    },
    {
        "content": "<p>basically the equivalent of something like <code>fn split() -&gt; (impl AsyncRead, impl AsyncWrite)</code>, though this has its own dyn trait issues :)</p>",
        "id": 240626643,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1622218401
    },
    {
        "content": "<p>I am pretty centered on this goal of \"users should just write async fn\"</p>",
        "id": 240626658,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1622218415
    },
    {
        "content": "<blockquote>\n<p>I am pretty centered on this goal of \"users should just write async fn\"</p>\n</blockquote>\n<p>+100 on this. Also the reason why I currently just recommend people to use <code>async_trait</code>. It significantly reduces the amount of concepts to learn, and just works.</p>\n<p>I definitely like this proposal, and I think even the limitations of <code>&amp;mut</code> are acceptable for most places where I've seen async traits being used. Not being able to model e.g. a <code>Receiver&lt;T&gt;</code> trait for a non-cloneable MPMC (like <a href=\"https://docs.rs/futures-intrusive/0.4.0/futures_intrusive/channel/struct.GenericChannel.html#method.receive\">the futures-intrusive one</a>) is a drawback, but it's probably minor since it can be fixed with wrapping in an <code>Arc</code> and cloning. At least for all the non <code>no-std</code> usecases.</p>\n<p>The main downside I can still see is that it can't cover all the use-cases and we will still have <code>async_trait</code> around - so the question on where to use what version will come up <strong>very often</strong>.</p>\n<blockquote>\n<p>what if we had the ability to declare that two &amp;mut self methods must be able to execute simultaneously? </p>\n</blockquote>\n<p>What does \"simulateneously\" mean? Concurrently? From multiple threads? Seems like rather contradictionary to what <code>&amp;mut</code> means so far. And how would it look like?</p>",
        "id": 240636289,
        "sender_full_name": "Matthias247",
        "timestamp": 1622223066
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/.22inline.22.20async.20fn.20in.20traits/near/240626524\">said</a>:</p>\n<blockquote>\n<p>that said, I'm now starting to think about other thoughts :) what if we had the ability to declare that two <code>&amp;mut self</code> methods must be able to execute simultaneously? it'd be useful in other contexts</p>\n</blockquote>\n<p>Would be really nice. I would have to think about tit some, but perhaps being able to say two traits need to be able to be split could work</p>",
        "id": 240636474,
        "sender_full_name": "Carl Lerche",
        "timestamp": 1622223139
    },
    {
        "content": "<p>Regarding <code>split</code>: I think having it only on concrete types is totally fine. If someone needs the capability, split immediately and just pass the individual reader and writer. If you don't, then pass around a <code>T: AsyncRead + AsyncWrite</code>. I've now built a couple of libraries around this, and see no issues on that.</p>",
        "id": 240636562,
        "sender_full_name": "Matthias247",
        "timestamp": 1622223196
    },
    {
        "content": "<p>That said, I don't <em>think</em> it would be possible to make it work for TlsStream as, TlsStream may read from the inner stream on write and vice versa</p>",
        "id": 240636608,
        "sender_full_name": "Carl Lerche",
        "timestamp": 1622223223
    },
    {
        "content": "<p>The automatic splitting has its issues anyway. E.g. its still broken on tokio-tls for certain conditions (see <a href=\"https://github.com/tokio-rs/tls/issues/40\">https://github.com/tokio-rs/tls/issues/40</a>)</p>",
        "id": 240636692,
        "sender_full_name": "Matthias247",
        "timestamp": 1622223256
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> maybe there is a way to say \"you must not hold any references across await points\"?</p>",
        "id": 240636693,
        "sender_full_name": "Carl Lerche",
        "timestamp": 1622223257
    },
    {
        "content": "<p>In theory, if no references are held to self across await points, it should be possible to split safely?</p>",
        "id": 240636822,
        "sender_full_name": "Carl Lerche",
        "timestamp": 1622223334
    },
    {
        "content": "<p>the split handles would have to be !Send, which could cause other problems...</p>",
        "id": 240637011,
        "sender_full_name": "Carl Lerche",
        "timestamp": 1622223433
    },
    {
        "content": "<p>A generic split has a other issues that are not talked about in here. The one in tokio works because it assumes that an underlying io impl can store a different <code>Waker</code> for read and write. If it wouldn't be able to do that, it wouldn't work<br>\n So to make this work for other functions, you would also need to teach the trait about \"this is having multiple <code>&amp;mut self</code> methods, but they store individual wakers\". Sounds tricky.</p>",
        "id": 240638703,
        "sender_full_name": "Matthias247",
        "timestamp": 1622224228
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/.22inline.22.20async.20fn.20in.20traits/near/239721278\">said</a>:</p>\n<blockquote>\n<p>So I have this idea that I think could be a nice optimization and also a game changer that basically makes custom poll functions (like those found in <code>AsyncRead</code>, <code>AsyncWrite</code>, and the <code>AsyncDrop</code> that <span class=\"user-mention silent\" data-user-id=\"256759\">boats</span> proposed) obsolete. I wrote it up here:</p>\n<p><a href=\"https://hackmd.io/bKfiVPRpTvyX8JK_Ng2EWA?view\">https://hackmd.io/bKfiVPRpTvyX8JK_Ng2EWA?view</a></p>\n<p>I'd be curious to know what people think.</p>\n</blockquote>\n<p>I know I'm coming in a bit late here, but I wanted to share some recent experiences that this proposal seems to want to solve but as far as I can see, doesn't quite get there.</p>\n<p>I've been writing a lot of <code>AsyncRead</code> implementations that needs to mix the output of futures/streams in the struct with immediately available data. As a concrete example, consider, WLOG, a reader that internally holds another reader:</p>\n<p><code>struct MyReader { embedded: AsyncReadType }</code></p>\n<p>We want to write an <code>AsyncRead</code> <code>impl</code> for this type that prefixes every 5 bytes emitted by <code>AsyncReadType</code> with <code>foo:</code>. What I'd <em>like</em> to write is something like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">data</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"k\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"k\">loop</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">loop</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">start</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">+=</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">embedded</span><span class=\"p\">.</span><span class=\"n\">read</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">data</span><span class=\"p\">[</span><span class=\"n\">n</span><span class=\"o\">..</span><span class=\"p\">]).</span><span class=\"k\">await</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">start</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">break</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">break</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">buf</span><span class=\"p\">.</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"s\">b\"foo:\"</span><span class=\"p\">).</span><span class=\"k\">await</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">buf</span><span class=\"p\">.</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">data</span><span class=\"p\">[</span><span class=\"o\">..</span><span class=\"n\">n</span><span class=\"p\">]).</span><span class=\"k\">await</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Besides being able to use <code>async/await</code> in the trait, this also requires some kind <code>.write()</code> on the <code>buf</code> that yields when there isn't enough capacity in <code>buf</code>. You can imagine how tedious this book-keeping is without async/await. Of course, my real-world examples are much more complicated than this, generally needing to insert more than just one value as well as parse values from the reader and insert those parsed values into the stream.</p>\n<p>I haven't seen a proposal of this sort yet, but the inability to write code like this has likely been my top time sink when writing async I/O trait impls.</p>",
        "id": 240904130,
        "sender_full_name": "Sergio",
        "timestamp": 1622532628
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224941\">Carl Lerche</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/.22inline.22.20async.20fn.20in.20traits/near/240636693\">said</a>:</p>\n<blockquote>\n<p>maybe there is a way to say \"you must not hold any references across await points\"?</p>\n</blockquote>\n<p>yes, this is certainly possible, I guess the thing to do is to have some canonical examples of the kinds of code we want to write</p>",
        "id": 241155068,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1622643470
    },
    {
        "content": "<p>What I meant by \"permit two &amp;mut concurrently\" is roughly: it's plausible to imagine having <code>&amp;mut</code> references that don't give access to all the fields of the struct, or which shared access to some. This is a language feature that's been kicking around for a while as a \"nice to have\". It'd be nice to be able to implement a trait and declare that two methods are \"disjoint\" (i.e., they either access disjoint memoy, or for shared memory access it in an <code>&amp;self</code>-compatible way)</p>",
        "id": 241155234,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1622643541
    },
    {
        "content": "<p>You can model this by hand like so:</p>",
        "id": 241155240,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1622643545
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">Merged</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">a</span>: <span class=\"nc\">A</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span>: <span class=\"nc\">B</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">c</span>: <span class=\"nc\">C</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">Left</span><span class=\"o\">&lt;'</span><span class=\"na\">me</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">a</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">me</span> <span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">c</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">me</span> <span class=\"nc\">C</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">Right</span><span class=\"o\">&lt;'</span><span class=\"na\">me</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">b</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">me</span> <span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">c</span>: <span class=\"o\">'</span><span class=\"na\">me</span> <span class=\"nc\">C</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Merged</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">split</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"p\">(</span><span class=\"n\">Left</span><span class=\"o\">&lt;'</span><span class=\"nb\">_</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Right</span><span class=\"o\">&lt;'</span><span class=\"nb\">_</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">Left</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">a</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">c</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">self</span><span class=\"p\">.</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"p\">},</span><span class=\"w\"> </span><span class=\"n\">Right</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">b</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">b</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">c</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">self</span><span class=\"p\">.</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"p\">})</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 241155453,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1622643628
    },
    {
        "content": "<p>now I can put methods on <code>Left</code> and <code>Right</code></p>",
        "id": 241155476,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1622643638
    },
    {
        "content": "<p>it is <em>plausible</em> to imagine a language feature that makes this easier</p>",
        "id": 241155511,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1622643660
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"326186\">@Sergio</span> I thnk that my proposal would definitel enable this sort of thing</p>",
        "id": 241155630,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1622643721
    },
    {
        "content": "<p>you would want to (presumably) layer some kind of \"write-and-retry\" loop on top</p>",
        "id": 241155724,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1622643741
    },
    {
        "content": "<p>that is, you would want a method like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">write</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">bytes</span>: <span class=\"kp\">&amp;</span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">])</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">io</span>::<span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"p\">()</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 241155760,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1622643767
    },
    {
        "content": "<p>that either writes <em>all</em> of bytes or fails</p>",
        "id": 241155772,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1622643775
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> Ah, sure, I don't think I was clear in my example, but the idea would be to write data as soon as output buffer capacity becomes available, not only when you have enough space for an entire chunk in the output buffer. For instance, if <code>buf</code> has a capacity of <code>1</code>, <code>buf.write(b\"foo:\")</code> should write <code>f</code>. When the reader is next polled, it should continue to fill <code>buf</code> as capacity becomes available.</p>",
        "id": 241171527,
        "sender_full_name": "Sergio",
        "timestamp": 1622650159
    },
    {
        "content": "<p>So if the next time around <code>buf</code> has a capacity of 2, it should write <code>oo</code>, and so on.</p>",
        "id": 241171798,
        "sender_full_name": "Sergio",
        "timestamp": 1622650311
    },
    {
        "content": "<p>I don't see a way to accomplish this in a composable manner without <code>buf</code> being smarter. I think, you could, for instance, have a <code>write!</code> macro called in the async read impl that would make this work, but that wouldn't compose.</p>",
        "id": 241172728,
        "sender_full_name": "Sergio",
        "timestamp": 1622650732
    },
    {
        "content": "<p>Maybe that's good enough though. I'll think about it/prototype it.</p>",
        "id": 241174309,
        "sender_full_name": "Sergio",
        "timestamp": 1622651434
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"326186\">@Sergio</span> I don't quite see the problem :/</p>",
        "id": 241300162,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1622658616
    },
    {
        "content": "<p>well, maybe I do</p>",
        "id": 241300191,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1622658633
    },
    {
        "content": "<p>if you built <code>write</code> atop the abstractions that <span class=\"user-mention\" data-user-id=\"224941\">@Carl Lerche</span> proposed, though, it seems like it would work quite well</p>",
        "id": 241300226,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1622658650
    },
    {
        "content": "<p>it'd be something like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">AsyncIo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">write</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">buf</span>: <span class=\"kp\">&amp;</span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">])</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">io</span>::<span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"p\">()</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">position</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">while</span><span class=\"w\"> </span><span class=\"n\">position</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"w\"> </span><span class=\"n\">buf</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">ready</span><span class=\"p\">(</span><span class=\"n\">Interest</span>::<span class=\"n\">WRITABLE</span><span class=\"p\">).</span><span class=\"k\">await</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">position</span><span class=\"w\"> </span><span class=\"o\">+=</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">try_write</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">buf</span><span class=\"p\">[</span><span class=\"n\">position</span><span class=\"o\">..</span><span class=\"p\">])</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 241300550,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1622658769
    },
    {
        "content": "<p>Yeah! If I'm understanding that correctly, something like that would indeed work. The issue is exactly that <code>buf</code>, or the thing you're writing to, needs to be able to suspend the computation itself if there isn't enough capacity.</p>",
        "id": 241310811,
        "sender_full_name": "Sergio",
        "timestamp": 1622663624
    },
    {
        "content": "<p>But I don't see how <code>&amp;mut [u8]</code> could ever implement such a trait in a manner you'd like. That is, the <code>AsyncRead</code> trait would need to change.</p>",
        "id": 241311790,
        "sender_full_name": "Sergio",
        "timestamp": 1622664053
    },
    {
        "content": "<p>This is where the \"smarter <code>buf</code>\" part comes in. Somehow you want to suspend the computation when you're out of capacity, swap the underlying buffer, and then resume the computation.</p>",
        "id": 241311995,
        "sender_full_name": "Sergio",
        "timestamp": 1622664134
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"326186\">@Sergio</span> I think it's fine to change the <code>AsyncRead</code> trait, and indeed I'm assuming some changes, but I don't quite understand what you are saying about the role of a \"smarter buf\"</p>",
        "id": 241326252,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1622671711
    },
    {
        "content": "<p>can you maybe sketch out the pseudo-code of what you <em>wish</em> you could do?</p>",
        "id": 241326287,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1622671731
    },
    {
        "content": "<p>and/or show me how it might work in C# :)</p>",
        "id": 241326295,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1622671736
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> The small snippet I pasted before is an example, but here's an even smaller one:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">Event</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">name</span>: <span class=\"nc\">Cursor</span><span class=\"o\">&lt;</span><span class=\"n\">Cow</span><span class=\"o\">&lt;'</span><span class=\"nb\">static</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">]</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">value</span>: <span class=\"nc\">Cursor</span><span class=\"o\">&lt;</span><span class=\"n\">Cow</span><span class=\"o\">&lt;'</span><span class=\"nb\">static</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">]</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">AsyncRead</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Event</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">poll_read</span><span class=\"p\">(</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span>: <span class=\"nc\">Pin</span><span class=\"o\">&lt;&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">Self</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">buf</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">ReadBuf</span><span class=\"o\">&lt;'</span><span class=\"nb\">_</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">io</span>::<span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"p\">()</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">buf</span><span class=\"p\">.</span><span class=\"n\">write_all</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">name</span><span class=\"p\">).</span><span class=\"k\">await</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">buf</span><span class=\"p\">.</span><span class=\"n\">write_all</span><span class=\"p\">(</span><span class=\"s\">b\":\"</span><span class=\"p\">).</span><span class=\"k\">await</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">buf</span><span class=\"p\">.</span><span class=\"n\">write_all</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">value</span><span class=\"p\">).</span><span class=\"k\">await</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nb\">Ok</span><span class=\"p\">(())</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 241329985,
        "sender_full_name": "Sergio",
        "timestamp": 1622674592
    },
    {
        "content": "<p>The ideal semantics would be:</p>\n<ul>\n<li>A <code>read_to_end</code> of <code>Event</code> would read the equivalent of the contents of <code>buf</code> after <code>write!(buf, \"{}:{}\", self.name, b\":\", self.value);</code>. In fact, this is what I would <em>really</em> love to be able to write. Such an implementation is within grasp if the above can be written, of course.</li>\n<li><code>write_all</code> writes into <code>buf</code> incrementally. If there is one byte of capacity available in <code>buf</code>, 1 byte is written, if two, two, and so on.</li>\n</ul>",
        "id": 241330165,
        "sender_full_name": "Sergio",
        "timestamp": 1622674781
    },
    {
        "content": "<p>Any future that's returned by <code>write_all</code> is going to store <code>buf</code>, necessarily, so it can write to it. As it is today, in <code>tokio</code> <em>and</em> <code>futures</code>, that <code>buf</code> points to a concrete backing slice. As soon as that slice is filled, there's no way for the future to say: \"hey, go get me another backing slice, I'm done with this one, and then continue right at this point.\"</p>",
        "id": 241330413,
        "sender_full_name": "Sergio",
        "timestamp": 1622674951
    },
    {
        "content": "<p>I'm not sure you can do this in C#. Maybe full call/cc semantics <em>would</em> allow you to implement this, however.</p>",
        "id": 241330521,
        "sender_full_name": "Sergio",
        "timestamp": 1622675007
    },
    {
        "content": "<p>But my thinking was more along the lines of a <code>ReadBuf</code> that is able to return a special future that can swap out it's backing buffer when the current one fills up, waiting for said buffer to become available.</p>",
        "id": 241330916,
        "sender_full_name": "Sergio",
        "timestamp": 1622675306
    },
    {
        "content": "<p>Here's a real-world implementation of a slightly fancier <code>Event</code> today: <a href=\"https://github.com/SergioBenitez/Rocket/blob/f1ecb79a7ea536bacc7b7e92d33bf5406c0c635f/core/lib/src/response/stream/raw_sse.rs#L184-L231\">https://github.com/SergioBenitez/Rocket/blob/f1ecb79a7ea536bacc7b7e92d33bf5406c0c635f/core/lib/src/response/stream/raw_sse.rs#L184-L231</a></p>",
        "id": 241331302,
        "sender_full_name": "Sergio",
        "timestamp": 1622675630
    },
    {
        "content": "<p>Is that meant to be awaiting writing into the <code>ReadBuf</code>? It's usually going to have a fixed sized, and so if there isn't room, those <code>write_all().await</code> would never work (or would error on a short-write)</p>",
        "id": 241337146,
        "sender_full_name": "Sean McArthur",
        "timestamp": 1622680894
    },
    {
        "content": "<p>Yeah, that's exactly my point! :)</p>",
        "id": 241337347,
        "sender_full_name": "Sergio",
        "timestamp": 1622681124
    },
    {
        "content": "<p>Well then, I did the silly thing and just read the code and went <em>woah is someone wrong on the internet?!</em></p>",
        "id": 241337673,
        "sender_full_name": "Sean McArthur",
        "timestamp": 1622681502
    }
]