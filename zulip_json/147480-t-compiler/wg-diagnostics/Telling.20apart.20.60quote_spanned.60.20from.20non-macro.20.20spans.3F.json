[
    {
        "content": "<p>Hi <span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span> <br>\nIn Clippy, we're running into cases where code generated by <code>quote_spanned</code> triggers various lints and it's not clear whether there's a way to avoid this at all.<br>\nHere's an example <code>proc_macro_attribute</code> where code in <code>quote_spanned</code> triggers a Clippy lint:<br>\n<a href=\"https://github.com/rust-lang/rust-clippy/issues/6514#issuecomment-758279802\">https://github.com/rust-lang/rust-clippy/issues/6514#issuecomment-758279802</a><br>\nIt seems that this is potentially also an issue with rustc lints: <a href=\"https://github.com/rust-lang/rust/issues/78862\">https://github.com/rust-lang/rust/issues/78862</a></p>\n<p>I guess I'm asking, if there is any way to tell apart <code>quote_spanned</code> spans from non-macro spans?</p>",
        "id": 222400188,
        "sender_full_name": "Phil H",
        "timestamp": 1610437806
    },
    {
        "content": "<p>IIRC you are expected to add an attribute on macro generated code so that it doesn't lint. I don't remember what it was off hand tho</p>",
        "id": 222415249,
        "sender_full_name": "nagisa",
        "timestamp": 1610448650
    },
    {
        "content": "<p>Hm, I thought we had machinery to detect if a span was a result of macro expansion - regardless of usage of quote_spanned</p>",
        "id": 222426511,
        "sender_full_name": "simulacrum",
        "timestamp": 1610456528
    },
    {
        "content": "<p>We do, but that relies on the span being produced by macro rules expansion to begin with</p>",
        "id": 222427425,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1610457006
    },
    {
        "content": "<p>a proc macro can use <code>quote_spanned</code> (or <code>set_span</code>) to associate arbitrary spans with arbitrary tokens</p>",
        "id": 222427450,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1610457027
    },
    {
        "content": "<p>if a proc-macro associated a normal user-provided span with tokens that it generates, we can't detect it as macro generated</p>",
        "id": 222427501,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1610457070
    },
    {
        "content": "<p>hm, interesting - I would expect for that to set the location but still associate the span with the macro's expansion id (if I'm remembering name right)</p>",
        "id": 222427678,
        "sender_full_name": "simulacrum",
        "timestamp": 1610457169
    },
    {
        "content": "<p>there are stablizied apis to do any combination of those things</p>",
        "id": 222429156,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1610457708
    },
    {
        "content": "<p>Using <code>set_span</code> overwrites the entire <code>Span</code></p>",
        "id": 222429272,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1610457734
    },
    {
        "content": "<p>you can use <code>Span::located_at</code> and <code>Span::resolved_at</code> to set the location and hygiene (<code>SyntaxContext</code>) individually from other spans</p>",
        "id": 222429360,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1610457766
    },
    {
        "content": "<p>Hm ok</p>",
        "id": 222430558,
        "sender_full_name": "simulacrum",
        "timestamp": 1610458428
    },
    {
        "content": "<p>In order for us to be able to reliably detect spans produced by macro expansion, we would need to store some extra state which is unaffected by the <code>proc_macro::Span</code> apis</p>",
        "id": 222430728,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1610458512
    },
    {
        "content": "<p>That makes sense, I guess I had assumed we had that already.</p>",
        "id": 222431194,
        "sender_full_name": "simulacrum",
        "timestamp": 1610458741
    }
]