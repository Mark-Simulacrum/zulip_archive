[
    {
        "content": "<p>Follow up from <a href=\"#narrow/stream/122652-new-members/topic/First.20non-trivial.20contribution\">https://rust-lang.zulipchat.com/#narrow/stream/122652-new-members/topic/First.20non-trivial.20contribution</a></p>\n<p><span class=\"user-mention\" data-user-id=\"388880\">@Sasha Pourcelot (she/her)</span>  You're looking at the right method in <code>Parser::parse_closure_expr</code>. If you look at that, you can also see that we call <code>parse_expr_res</code> or <code>parse_block_expr</code>. The later only when an explicit type has been given, which means that the likelihood of braces being missing are low, so we can focus on the first one.</p>",
        "id": 249574676,
        "sender_full_name": "Esteban Küber",
        "timestamp": 1629112083
    },
    {
        "content": "<p>We can ignore the ruby syntax case for now</p>",
        "id": 249574718,
        "sender_full_name": "Esteban Küber",
        "timestamp": 1629112103
    },
    {
        "content": "<p>So given that, following the method call chain we end up in <code>parse_assoc_expr_with</code></p>",
        "id": 249574757,
        "sender_full_name": "Esteban Küber",
        "timestamp": 1629112147
    },
    {
        "content": "<p>an option might be to create a new <code>Restrictions</code> signal, but would like to avoid that</p>",
        "id": 249574777,
        "sender_full_name": "Esteban Küber",
        "timestamp": 1629112169
    },
    {
        "content": "<p>it's likely we'll have to add a new field to the parser to hold info on the inner most closure being parsed right now, something similar to what we do with <code>last_type_ascription</code></p>",
        "id": 249574840,
        "sender_full_name": "Esteban Küber",
        "timestamp": 1629112204
    },
    {
        "content": "<p>So that before emitting any error we look to see if it could be this case.</p>",
        "id": 249574864,
        "sender_full_name": "Esteban Küber",
        "timestamp": 1629112229
    },
    {
        "content": "<p>Another alternative would be to keep a <code>self.clone()</code> snapshot and try both parses...</p>",
        "id": 249574878,
        "sender_full_name": "Esteban Küber",
        "timestamp": 1629112246
    },
    {
        "content": "<p>But it'd be ideal if we can avoid that to not have to pay the memory cost of that.</p>",
        "id": 249574918,
        "sender_full_name": "Esteban Küber",
        "timestamp": 1629112282
    },
    {
        "content": "<p>The first thing we can do is keep a signal that we're parsing a closure body to avoid the comma recovery</p>",
        "id": 249575040,
        "sender_full_name": "Esteban Küber",
        "timestamp": 1629112377
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119031\">Esteban Küber</span> <a href=\"#narrow/stream/147480-t-compiler.2Fwg-diagnostics/topic/Parse.20closure.20missing.20braces.20around.20body.20.2388065/near/249574777\">said</a>:</p>\n<blockquote>\n<p>an option might be to create a new <code>Restrictions</code> signal, but would like to avoid that</p>\n</blockquote>\n<p>That was my initial idea, but as you pointed out it is not ideal.</p>",
        "id": 249575497,
        "sender_full_name": "Sasha Pourcelot (she/her)",
        "timestamp": 1629112741
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119031\">Esteban Küber</span> <a href=\"#narrow/stream/147480-t-compiler.2Fwg-diagnostics/topic/Parse.20closure.20missing.20braces.20around.20body.20.2388065/near/249575040\">said</a>:</p>\n<blockquote>\n<p>The first thing we can do is keep a signal that we're parsing a closure body to avoid the comma recovery</p>\n</blockquote>\n<p>Alright, i'll start with that. I'll need some time as I lack experience with this part of the codebase. I'll ping you once I get there :)</p>",
        "id": 249575791,
        "sender_full_name": "Sasha Pourcelot (she/her)",
        "timestamp": 1629113036
    },
    {
        "content": "<p>Remember you can use <code>-Ztreat-err-as-bug</code> and <code>RUST_BACKTRACE=1</code> to cause <code>rustc</code> to emit a stacktrace where the error is <code>emit</code>ted</p>",
        "id": 249577507,
        "sender_full_name": "Esteban Küber",
        "timestamp": 1629114147
    },
    {
        "content": "<p>Nice! Thanks for the tip</p>",
        "id": 249577776,
        "sender_full_name": "Sasha Pourcelot (she/her)",
        "timestamp": 1629114347
    },
    {
        "content": "<p>The rustc dev guide also has lots of info that comes in handy<br>\n<a href=\"https://rustc-dev-guide.rust-lang.org/\">https://rustc-dev-guide.rust-lang.org/</a></p>",
        "id": 249580598,
        "sender_full_name": "Esteban Küber",
        "timestamp": 1629116202
    },
    {
        "content": "<p>I made little progress (see <a href=\"https://github.com/scrabsha/rust/compare/master...scrabsha:scrabsha/closure-missing-braces\">my local branch</a>). So far I update the state of the parser to mark it as \"currently parsing a closure body\".</p>",
        "id": 249595822,
        "sender_full_name": "Sasha Pourcelot (she/her)",
        "timestamp": 1629124156
    },
    {
        "content": "<p>I may be wrong, but this approach disables the recovery for the whole closure body, even for what's inside (where it may be legitimate), while we want to disable it only for the end of the closure body</p>",
        "id": 249595856,
        "sender_full_name": "Sasha Pourcelot (she/her)",
        "timestamp": 1629124175
    },
    {
        "content": "<p>It would. Right now you have the signal in place only, you'd be missing the disabling of the comma recovery</p>",
        "id": 249610599,
        "sender_full_name": "Esteban Küber",
        "timestamp": 1629130827
    },
    {
        "content": "<p>I think i'm getting somewhere. I have successfully disabled the errors that are caused by the incorrect recovery and added a test for it (see <a href=\"https://github.com/scrabsha/rust/compare/master...scrabsha:scrabsha/closure-missing-braces#diff-105ab5a49804d3ccd4ddbee76f499a760f5a86c24fae7ba2e3fdb21b0f93b8ef\">the test</a> and <a href=\"https://github.com/scrabsha/rust/compare/master...scrabsha:scrabsha/closure-missing-braces#diff-105ab5a49804d3ccd4ddbee76f499a760f5a86c24fae7ba2e3fdb21b0f93b8ef\">its stderr</a>).</p>",
        "id": 249691599,
        "sender_full_name": "Sasha Pourcelot (she/her)",
        "timestamp": 1629189485
    },
    {
        "content": "<p>I have found an approach that may be a bit cleaner.<br>\nTLDR: we can analyze the state of the Parser after extracting the closure body. If the innermost delimiter is a parenthesis and the next token is a colon, then we can trigger the \"you may be missing a pair of braces\" error.<br>\nIMO it is cleaner and easier to implement since it does not add any internal state to the parser. I have pushed my idea <a href=\"https://github.com/scrabsha/rust/compare/master...scrabsha/closure-missing-braces-2\">here</a>. Do you think that would work <span class=\"user-mention\" data-user-id=\"119031\">@Esteban Küber</span> ?</p>",
        "id": 249700995,
        "sender_full_name": "Sasha Pourcelot (she/her)",
        "timestamp": 1629196681
    },
    {
        "content": "<p>The thing with that approach is that it would be <em>too</em> targeted for the repro case we have. We also need to account for other potential misparses. Just removing the suggestion altogether wouldn't have much fallout, just make the compiler less helpful. We can do that always only when parsing a closure without braces and the loss would be small</p>",
        "id": 249701373,
        "sender_full_name": "Esteban Küber",
        "timestamp": 1629197042
    },
    {
        "content": "<p>There are cases where a comma would be needed after a closure when passed as a function argument to separate the next one, but the generic error in that case should already have enough context.</p>",
        "id": 249701449,
        "sender_full_name": "Esteban Küber",
        "timestamp": 1629197099
    },
    {
        "content": "<p>Adding state to the parser is not ideal, though.</p>",
        "id": 249701467,
        "sender_full_name": "Esteban Küber",
        "timestamp": 1629197122
    },
    {
        "content": "<p>Yeah, I'm not sure this code you posted will trigger with the repro case.</p>",
        "id": 249701554,
        "sender_full_name": "Esteban Küber",
        "timestamp": 1629197183
    },
    {
        "content": "<p>give me a minute, i'll create a test with the exact code posted in the issue</p>",
        "id": 249701609,
        "sender_full_name": "Sasha Pourcelot (she/her)",
        "timestamp": 1629197235
    },
    {
        "content": "<p>I inserted an explicit panic in the condition and copy/pasted the code from the issue and it panics<br>\nThe thing is that this method will not work in for the other-Ruby syntax<br>\n(the code has been pushed to <code>scrabsha/closure-missing-braces-2</code>)</p>",
        "id": 249701957,
        "sender_full_name": "Sasha Pourcelot (she/her)",
        "timestamp": 1629197523
    },
    {
        "content": "<p>The \"signal\" approach scares me a bit, as i have to find the places where i have to switch the signal on and off, and any mistake can dramatically degrade the diagnostics for other errors.</p>",
        "id": 249702216,
        "sender_full_name": "Sasha Pourcelot (she/her)",
        "timestamp": 1629197741
    },
    {
        "content": "<p>Your point about this fix being way too specific is entirely valid though.</p>",
        "id": 249702895,
        "sender_full_name": "Sasha Pourcelot (she/her)",
        "timestamp": 1629198213
    },
    {
        "content": "<p>I implemented the signal the way you described it. It removes all the errors caused by the recovery, keeping only the \"unexpected <code>;</code>\" error. I think this is what you described.<br>\nThe code is available <a href=\"https://github.com/scrabsha/rust/compare/master...scrabsha:scrabsha/closure-missing-braces\">here</a></p>",
        "id": 249719503,
        "sender_full_name": "Sasha Pourcelot (she/her)",
        "timestamp": 1629207475
    },
    {
        "content": "<p>So, I like the straighforward nature of the proactive approach (looking if surrounded by parens and we've encountered a semi, and try to parse a body). The second (or first, based on branch names) is closer to what I envisioned and seems quite complete. The only issue I see with this last one is that the AST ends up with a closure with a single statement, which causes the typeck error you see there</p>",
        "id": 249872211,
        "sender_full_name": "Esteban Küber",
        "timestamp": 1629302665
    },
    {
        "content": "<p>So what I would do in either strategy is to use (IIRC) <code>self.mk_err(span)</code> instead so that we swallow the closure's body whole and avoid <em>any</em> error coming from it.</p>",
        "id": 249872753,
        "sender_full_name": "Esteban Küber",
        "timestamp": 1629302892
    },
    {
        "content": "<p>I think that the approach in <code>closure-missing-braces</code> will properly handle the <code>{ |coming| from; ruby }</code> case</p>",
        "id": 249872887,
        "sender_full_name": "Esteban Küber",
        "timestamp": 1629302956
    },
    {
        "content": "<p>Could you try that out, to see what output we get with it?</p>",
        "id": 249872924,
        "sender_full_name": "Esteban Küber",
        "timestamp": 1629302976
    },
    {
        "content": "<p>Thanks for your feedback! I think I will drop the strategy I developped in <code>closure-missing-braces-2</code> and focus exclusively on the approach you suggested.<br>\nThere are also a couple of less-technical things I need to figure out, such as the wording of the error messages, but that can be discussed later.<br>\nI was wondering how to remove the typeck error. I'll apply your suggestions tomorrow and will keep you updated for what happens with the ruby syntax :)<br>\nThank you again for taking time to review my code</p>",
        "id": 249889267,
        "sender_full_name": "Sasha Pourcelot (she/her)",
        "timestamp": 1629310013
    },
    {
        "content": "<p>As you suggested, <code>self.mk_expr_err(span)</code> removed the typeck error. The resulting diagnostic looks is good imho. The recently added colored suggestions make the suggestion super-friendly too</p>",
        "id": 249977566,
        "sender_full_name": "Sasha Pourcelot (she/her)",
        "timestamp": 1629375532
    },
    {
        "content": "<p>I added the a test for the <code>{ |coming| from; ruby }</code> syntax too (by the way, i love that name!). The results are the same as what was emitted before. I need to investigate a bit how the typecheck algorithm operate before working on it.</p>",
        "id": 249977815,
        "sender_full_name": "Sasha Pourcelot (she/her)",
        "timestamp": 1629375690
    },
    {
        "content": "<p>Side question: should I open a PR now, which fixes only <a href=\"https://github.com/rust-lang/rust/issues/88065\">#88065</a> or should I open a bigger PR where <code>{ |coming| from; ruby }</code> is fixed too?</p>",
        "id": 249980702,
        "sender_full_name": "Sasha Pourcelot (she/her)",
        "timestamp": 1629377267
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"119031\">@Esteban Küber</span>! I'm making good progress on the initial <a href=\"https://github.com/rust-lang/rust/issues/88065\">#88065</a> but i have no clue on how to fix <code>{ |coming| from; ruby }</code> syntax error. Can i get some pointers of where to make changes?</p>",
        "id": 251414552,
        "sender_full_name": "Sasha Pourcelot (she/her)",
        "timestamp": 1630427351
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"388880\">@Sasha Pourcelot (she/her)</span>!<br>\nThat's great to hear! Do you have a PR open now or a branch I can look at? I would open a PR with what you already have, and then we can talk about addressing the \"ruby closure\" case on its own, likely building on top of what you've already have.</p>",
        "id": 251422188,
        "sender_full_name": "Esteban Küber",
        "timestamp": 1630430466
    },
    {
        "content": "<p>I feel like the \"forgot braces\" case is going to be more prevalent than the \"transposed where the braces go\" case, so it makes sense to land it as soon as it is ready.</p>",
        "id": 251422267,
        "sender_full_name": "Esteban Küber",
        "timestamp": 1630430500
    },
    {
        "content": "<p>Given that you'll be able to detect closures without braces, we can also detect single closures marked as recovered due to lack of braces inside of a block with no statements and a tail expression (the closure)</p>",
        "id": 251422449,
        "sender_full_name": "Esteban Küber",
        "timestamp": 1630430560
    },
    {
        "content": "<p>Thank you for guidance :)<br>\nI opened the PR <a href=\"https://github.com/rust-lang/rust/pull/88546\">#88546</a> and took the liberty to r? you. Feel free to un-assign yourself if you feel this is inappropriate.<br>\nI can't wait to start working on the ruby closure case</p>",
        "id": 251463973,
        "sender_full_name": "Sasha Pourcelot (she/her)",
        "timestamp": 1630445589
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119031\">@Esteban Küber</span> i'm trying to work on the ruby-syntax handling. I have an idea of fix but I'd like to get some feedback before actually writing it:</p>\n<p>- when checking a block expression (in <a href=\"https://github.dev/rust-lang/rust/blob/e71925aab9e28ce35363e3fdef27ca011ac6a1dc/compiler/rustc_typeck/src/check/fn_ctxt/checks.rs#L667-L667\"><code>FnCtxt::check_block_with_expected</code></a>), see if the first statement of the block is a closure,<br>\n  - if it is, then modify the state of the <code>FnCtxt</code>, perhaps by setting a <code>possible_ruby_style_closure</code> to true just before checking the tail expression,<br>\n  - on type error, check for the value of <code>self.possible_ruby_style_closure</code>, and suggest the Rust syntax instead.</p>\n<p>This could allow us to handle simple cases  where the closure variable is not used in the closure body, such as <code>{ |_x| dbg!(); 42 }</code>.</p>\n<p>If it works well, we can change the type of <code>possible_ruby_style_closure</code> so that it stores the name of the variables introduced by the closure, which we can look at when we find a variable which is not in scope, such as <code>{ |x| dbg!(x); x * 2 }</code>.</p>\n<p>It makes sense in my head but I don't know if it will work correctly. Do you think that makes sense? Alternatively, do you have a better idea?</p>",
        "id": 254020404,
        "sender_full_name": "Sasha Pourcelot (she/her)",
        "timestamp": 1632129967
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"388880\">@Sasha Pourcelot (she/her)</span> that approach sounds reasonable for this specific problem, but I'm wondering if there isn't an alternative approach where we eagerly complain about closures being created and dropped immediately. That should already be taken care by <code>#[must_use]</code>, but lints don't emit if there are other errors being emitted <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 254060729,
        "sender_full_name": "Esteban Küber",
        "timestamp": 1632148852
    },
    {
        "content": "<p>This is the warning I'm talking about: <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=d7d7fc41cc7ab3cdb9b20ecadcfedc03\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=d7d7fc41cc7ab3cdb9b20ecadcfedc03</a></p>",
        "id": 254062895,
        "sender_full_name": "Esteban Küber",
        "timestamp": 1632149669
    },
    {
        "content": "<blockquote>\n<p>lints don't emit if there are other errors being emitted</p>\n</blockquote>\n<p>You mean parse errors, right? In general I don't think errors are fatal unless someone specifically uses <code>sess.fatal</code></p>",
        "id": 254154375,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1632198907
    },
    {
        "content": "<p>(I don't have any idea how hard it would be to make parse errors non-fatal, but it doesn't seem impossible in theory)</p>",
        "id": 254154395,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1632198936
    },
    {
        "content": "<blockquote>\n<p>You mean parse errors, right?</p>\n</blockquote>\n<p>I don't think the fix will be in the parsing step, as the ruby-style closure syntax is syntactically valid in Rust.</p>",
        "id": 254160907,
        "sender_full_name": "Sasha Pourcelot (she/her)",
        "timestamp": 1632205506
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232545\">Joshua Nelson</span> <a href=\"#narrow/stream/147480-t-compiler.2Fwg-diagnostics/topic/Parse.20closure.20missing.20braces.20around.20body.20.2388065/near/254154375\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>lints don't emit if there are other errors being emitted</p>\n</blockquote>\n<p>You mean parse errors, right? In general I don't think errors are fatal unless someone specifically uses <code>sess.fatal</code></p>\n</blockquote>\n<p>Fatal errors stop the compiler and no other errors are emitted, but lints don't get emitted if other errors were. Think the <code>unused_binding</code> lint, you don't see them if there was a type error anywhere in your crate. The same happens for these: the <code>unused_must_use</code> lint doesn't get emitted if there are any other errors in the file (because we don't want to inundate users with warnings that might go away when the error itself is fixed).</p>",
        "id": 254329753,
        "sender_full_name": "Esteban Küber",
        "timestamp": 1632297733
    },
    {
        "content": "<p>Can we create an additional pass of lints that are always emitted, regardless of the errors emitted later?</p>\n<p>As pointed out, this could be useful to <code>unused_binding</code> and <code>unused_must_use</code> and can also be used for unused parentheses around if condition as well as a warning against potential ruby-style closure.</p>\n<p>Edit: i misread your message, your point about keeping the compiler output clear and concise is valid and more important IMO.</p>",
        "id": 256198799,
        "sender_full_name": "Sasha Pourcelot (she/her)",
        "timestamp": 1633423787
    },
    {
        "content": "<p>I think it might be worth it to have a way of forcing the run of some lints, but they should be few and far between</p>",
        "id": 256275190,
        "sender_full_name": "Esteban Küber",
        "timestamp": 1633450784
    }
]