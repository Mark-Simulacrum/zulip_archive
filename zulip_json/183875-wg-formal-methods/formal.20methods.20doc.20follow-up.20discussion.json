[
    {
        "content": "<p>this is to continue discussion of <a href=\"https://hackmd.io/qLk-wnwtStOhCOBeF5YuOw?view\">https://hackmd.io/qLk-wnwtStOhCOBeF5YuOw?view</a></p>",
        "id": 276628196,
        "sender_full_name": "pnkfelix",
        "timestamp": 1648219241
    },
    {
        "content": "<p><span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span></p>",
        "id": 276628207,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648219249
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312719\">Xavier Denis</span> <a href=\"#narrow/stream/238009-t-compiler.2Fmeetings/topic/.5Bsteering.20meeting.5D.202022-03-25.20compiler-team.23488.2C.20.23498/near/276627982\">said</a>:</p>\n<blockquote>\n<p>this also plays into the cargo issues since cargo doesn't clean / invalidate it</p>\n</blockquote>\n<p>Could a <code>cmeta</code> file (or equivalent) be put in the <code>rlib</code> archive and then you wouldn’t need to worry about cleaning it up separately? I think there’s some logic somewhere in the compiler for reading the metadata out of the <code>rlib</code> files by looking up a known filename in the archive.</p>",
        "id": 276628445,
        "sender_full_name": "davidtwco",
        "timestamp": 1648219349
    },
    {
        "content": "<p>that owuld definitely work</p>",
        "id": 276628693,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648219461
    },
    {
        "content": "<p>either that or cargo would need a mechanism to be taught about additional metadata files</p>",
        "id": 276628744,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648219491
    },
    {
        "content": "<p>For the <a class=\"stream\" data-stream-id=\"131828\" href=\"/#narrow/stream/131828-t-compiler\">#t-compiler</a> folks that are interested in these concerns, there's plenty more detail that we can go into</p>",
        "id": 276628841,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648219539
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"312719\">@Xavier Denis</span> okay, so, maybe here we can dig into my questions about why its hard to add more info in a post-hoc manner to traits/methods</p>",
        "id": 276634512,
        "sender_full_name": "pnkfelix",
        "timestamp": 1648221681
    },
    {
        "content": "<p>Yea!</p>",
        "id": 276635111,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648221902
    },
    {
        "content": "<p>So, let's consider a simple example: a simplified <code>Eq</code> trait</p>",
        "id": 276635241,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648221962
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"nb\">Eq</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">fn</span> <span class=\"nf\">eq</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">o</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">Self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">bool</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 276635313,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648221979
    },
    {
        "content": "<p>In how far are the pre- and postconditions and invariants similar between tools? Can we add basic support to rustc, just without actually interpreting them? (Or maybe treating them as debug assertions?)</p>",
        "id": 276635452,
        "sender_full_name": "bjorn3",
        "timestamp": 1648222045
    },
    {
        "content": "<p>the question of the specification language used by tools is a seperate issue imo</p>",
        "id": 276635503,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648222071
    },
    {
        "content": "<p>I am trying to work with different tool teams to bring people behind a single language, but its still very early</p>",
        "id": 276635625,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648222101
    },
    {
        "content": "<p>Suppose that we which to say that every impl of <code>Eq</code> defines an <em>equivalence relation</em> for the type being implemented</p>",
        "id": 276635652,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648222116
    },
    {
        "content": "<p>This means, that we need implementors to also provide a definition of <code>equiv</code> which is <em>logical</em> predicate characterizing what it means for two values of this type to be equivalent</p>",
        "id": 276635816,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648222175
    },
    {
        "content": "<p>I'm not saying they have to be exactly equal, but if you could have special functions defined and interpreted by the tool, would it be possible to lower the pre- and postconditions to MIR and include it in the crate metadata without handling it in any other way?</p>",
        "id": 276635953,
        "sender_full_name": "bjorn3",
        "timestamp": 1648222211
    },
    {
        "content": "<p>oh yea, i actually had a bullet point about that in my document</p>",
        "id": 276635993,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648222229
    },
    {
        "content": "<p>if MIR had opaque support for contract / contract expressions</p>",
        "id": 276636020,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648222238
    },
    {
        "content": "<p>that would be major</p>",
        "id": 276636034,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648222241
    },
    {
        "content": "<p>but it wouldn't solve the issue of 'extenral specifications' unless we can assign contracts to definitions</p>",
        "id": 276636127,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648222280
    },
    {
        "content": "<p>They can be represented as empty functions defined in a library part of the tool, right? Say <code>fn equiv&lt;T&gt;(a: T, b: T) {}</code>.</p>",
        "id": 276636137,
        "sender_full_name": "bjorn3",
        "timestamp": 1648222284
    },
    {
        "content": "<p>yea, that's not far from what i do, except its not an empty function</p>",
        "id": 276636197,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648222320
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312719\">Xavier Denis</span> <a href=\"#narrow/stream/183875-wg-formal-methods/topic/formal.20methods.20doc.20follow-up.20discussion/near/276636127\">said</a>:</p>\n<blockquote>\n<p>but it wouldn't solve the issue of 'extenral specifications' unless we can assign contracts to definitions</p>\n</blockquote>\n<p>True.</p>",
        "id": 276636243,
        "sender_full_name": "bjorn3",
        "timestamp": 1648222324
    },
    {
        "content": "<p>but the real issue is that when user code uses <code>==</code> that translates to a call on <code>Eq::eq</code></p>",
        "id": 276636277,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648222339
    },
    {
        "content": "<p>and we need someway to define the contract that <code>eq</code> should have (which here would be <code>ensures(self.equiv(other))</code></p>",
        "id": 276636302,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648222354
    },
    {
        "content": "<p>but the issue is that contract is only valid for types which are also <code>Equiv</code></p>",
        "id": 276636364,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648222382
    },
    {
        "content": "<p>for <em>normal</em> functions is is not an issue since we can provide wrappers in a library which have stricter bounds on types</p>",
        "id": 276636444,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648222414
    },
    {
        "content": "<p>like i could make a <code>veri-std</code> crate which re-exports <code>std</code> methods and types but with <code>Equiv</code> instead of <code>Eq</code> or whatever</p>",
        "id": 276636485,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648222438
    },
    {
        "content": "<p>but i can't do that for things like <code>eq</code>, <code>index</code>, <code>add</code> which are <em>hardcoded</em> to be the <code>core</code> traits</p>",
        "id": 276636561,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648222463
    },
    {
        "content": "<p>The other alternative is to package a custom <code>std</code> but then this imposes a huge maintenance burden. Perhaps in the long term when verification tools unite around a common specification language it will be possible</p>",
        "id": 276636692,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648222529
    },
    {
        "content": "<p>I think those are orthogonal problems. On one hand you have lowering and storing the contracts themself. This would be solved by my proposal of adding rustc support I think. On the other hand you have adding contracts to external types, for which I don't have a solution.</p>",
        "id": 276636795,
        "sender_full_name": "bjorn3",
        "timestamp": 1648222568
    },
    {
        "content": "<p>agreed. lowering and storing contracts is a seperate problem</p>",
        "id": 276636831,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648222588
    },
    {
        "content": "<p>but I thought that <span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> was asking about the second issue</p>",
        "id": 276636889,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648222620
    },
    {
        "content": "<p>but there are some relatively minor things i think that could be added to store and lower contracts which would make things sooo much less hacky</p>",
        "id": 276636973,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648222660
    },
    {
        "content": "<p>as it stands my lowering is <em>hacky</em> and involves patching <code>mir_built</code></p>",
        "id": 276637076,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648222698
    },
    {
        "content": "<p>in part because contracts need to have access to either the function parameters and types (pre/post) or be evaluated in whatever lexical scope they are found (assertions)</p>",
        "id": 276637135,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648222736
    },
    {
        "content": "<p>as I said in the document I (and prusti afaik) do this by using closures but this is hacky as it pollutes the MIR of the annotated function and we must be careful not to trigger mir lowering on those closures</p>",
        "id": 276637330,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648222816
    },
    {
        "content": "<p>I think the proper way to do it with rustc changes would be to do something like promoted mir for storing the mir bodies of the contracts and then have preconditions be functions which copies the argument list from the function it is a contract on. Have postconditions do the same, but also add outputs as arguments. Assertions should get their own terminator kind which is like a function call, except calling a contract function.</p>",
        "id": 276637751,
        "sender_full_name": "bjorn3",
        "timestamp": 1648223023
    },
    {
        "content": "<p>I don't think that can be done without rustc changes though.</p>",
        "id": 276637870,
        "sender_full_name": "bjorn3",
        "timestamp": 1648223064
    },
    {
        "content": "<p>yea, I would argue that contracts shouldn't be represented as MIR but otherwise agreed</p>",
        "id": 276638475,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648223328
    },
    {
        "content": "<p>(THIR is a better IR for contracts imo)</p>",
        "id": 276638512,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648223346
    },
    {
        "content": "<p>it makes handling structures like <code>forall</code> much simpler</p>",
        "id": 276638794,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648223450
    },
    {
        "content": "<p>so, just to make sure I understand the problem here...</p>",
        "id": 276642821,
        "sender_full_name": "pnkfelix",
        "timestamp": 1648224932
    },
    {
        "content": "<p>the \"obvious\" way I would attach contracts would be to assume that the crate-name+module-path-to-item (+ method name, when refering to a method attached to an item like a trait or the inherent impl for a struct/enum/union) can serve as a unique identifier</p>",
        "id": 276643032,
        "sender_full_name": "pnkfelix",
        "timestamp": 1648225009
    },
    {
        "content": "<p>but <span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> pointed out in the mtg earlier that you cannot assume those paths remain stable</p>",
        "id": 276643065,
        "sender_full_name": "pnkfelix",
        "timestamp": 1648225026
    },
    {
        "content": "<p>Is that <em>the</em> reason you cannot take that strategy? or am I missing something even more disastrous with that idea?</p>",
        "id": 276643130,
        "sender_full_name": "pnkfelix",
        "timestamp": 1648225056
    },
    {
        "content": "<p>(I am also assuming globally unique crate names, which is similarly problematic since crates can be given local names that the compiler is responsible for mapping to the associated object code. Its arguably just another instance of the instability problem that <span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> pointed out.)</p>",
        "id": 276643336,
        "sender_full_name": "pnkfelix",
        "timestamp": 1648225134
    },
    {
        "content": "<p>the problem isn't so much figuring out how to address the definitions, as you said, the fully qualified / disambiguated name suffices</p>",
        "id": 276643436,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648225175
    },
    {
        "content": "<p>the real issue is that in general adding specifications requires you to tighten trait bounds on a function</p>",
        "id": 276643551,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648225205
    },
    {
        "content": "<p>mmm. so there's potentially a viral propagation when you do that?</p>",
        "id": 276643641,
        "sender_full_name": "pnkfelix",
        "timestamp": 1648225240
    },
    {
        "content": "<p>yea</p>",
        "id": 276643649,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648225245
    },
    {
        "content": "<p>because if you give a spec to <code>Eq</code>, that spec should force you to show (via the trait system) that you have a well-behaved instance of <code>Eq</code></p>",
        "id": 276643748,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648225282
    },
    {
        "content": "<p>for normal methods its not an issue as we can just provide wrappers around types / functions with the appropriate bounds</p>",
        "id": 276643908,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648225331
    },
    {
        "content": "<p>but for anything tied to operators or core traits like <code>Copy</code>, that's nto a choice</p>",
        "id": 276643967,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648225352
    },
    {
        "content": "<p>I think the statement that \"wrappers can solve this\" doesn't help me understand, because I would assume that the virality issues arise then too</p>",
        "id": 276644108,
        "sender_full_name": "pnkfelix",
        "timestamp": 1648225407
    },
    {
        "content": "<p>hmm sorry. let me try to rephrase</p>",
        "id": 276644126,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648225415
    },
    {
        "content": "<p>i.e. I can totally understand that adding a spec ends up generating proof obligations for all the things that call into that spec</p>",
        "id": 276644266,
        "sender_full_name": "pnkfelix",
        "timestamp": 1648225469
    },
    {
        "content": "<p>So the issue is that when you're verifying code, you inevitably end up interacting with things that come from outside (whether that's <code>std</code> or another crate)</p>",
        "id": 276644280,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648225477
    },
    {
        "content": "<p>you end up needing some mechanism to say 'ok, assume that <code>Vec::foo</code> has the spec <code>S</code></p>",
        "id": 276644327,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648225501
    },
    {
        "content": "<p>which is what we can call an 'external specification declaration'</p>",
        "id": 276644366,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648225518
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/183875-wg-formal-methods/topic/formal.20methods.20doc.20follow-up.20discussion/near/276644266\">said</a>:</p>\n<blockquote>\n<p>i.e. I can totally understand that adding a spec ends up generating proof obligations for all the things that call into that spec</p>\n</blockquote>\n<p>but what I don't understand is if the common solution is to go through and figure out the corresponding specs that need to be added to all callers, and recurse as needed. Or if the common solution solution is some sort of tool to automatically attach specs (i.e. \"any instance of T: Eq implies this corresponding proof obligation.\")</p>",
        "id": 276644386,
        "sender_full_name": "pnkfelix",
        "timestamp": 1648225535
    },
    {
        "content": "<p>if i understand what you're saying, I'm going with the second option</p>",
        "id": 276644478,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648225565
    },
    {
        "content": "<p><a href=\"https://github.com/xldenis/creusot/blob/febd73b261b36210a4afdbc4f1ac83cdd32bdc2f/creusot-contracts/src/std/fun.rs#L79-L83\">https://github.com/xldenis/creusot/blob/febd73b261b36210a4afdbc4f1ac83cdd32bdc2f/creusot-contracts/src/std/fun.rs#L79-L83</a></p>",
        "id": 276644578,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648225610
    },
    {
        "content": "<p>this shows how i use an <code>extern_spec</code> macro to give a spec to  <code>call_once</code></p>",
        "id": 276644606,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648225626
    },
    {
        "content": "<p>hmm. okay.</p>",
        "id": 276644618,
        "sender_full_name": "pnkfelix",
        "timestamp": 1648225632
    },
    {
        "content": "<p>the idea being that now every time <code>call_once</code> appears in the code, we force you to prove that you have <code>F: FnOnceSpec</code> also be true</p>",
        "id": 276644661,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648225656
    },
    {
        "content": "<p>(beyond just <code>F: FnOnce</code></p>",
        "id": 276644669,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648225662
    },
    {
        "content": "<p>is <code>F: FnOnceSpec</code> there itself an instance of a type: trait bound, that is interpreted by the Rust trait system?</p>",
        "id": 276644767,
        "sender_full_name": "pnkfelix",
        "timestamp": 1648225698
    },
    {
        "content": "<p>or is it something specific to Creusot that <code>rustc</code> has no knowledge of?</p>",
        "id": 276644786,
        "sender_full_name": "pnkfelix",
        "timestamp": 1648225709
    },
    {
        "content": "<p>its fully integrated into rust</p>",
        "id": 276644802,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648225718
    },
    {
        "content": "<p>(creusot leverages the rust trait / type system for specs)</p>",
        "id": 276644823,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648225727
    },
    {
        "content": "<p>Okay. okay. I think that helps me understand better the limitations you're hitting.</p>",
        "id": 276644843,
        "sender_full_name": "pnkfelix",
        "timestamp": 1648225739
    },
    {
        "content": "<p>it comes from above in the file: <a href=\"https://github.com/xldenis/creusot/blob/febd73b261b36210a4afdbc4f1ac83cdd32bdc2f/creusot-contracts/src/std/fun.rs#L5-L11\">https://github.com/xldenis/creusot/blob/febd73b261b36210a4afdbc4f1ac83cdd32bdc2f/creusot-contracts/src/std/fun.rs#L5-L11</a></p>",
        "id": 276644849,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648225741
    },
    {
        "content": "<p>I fully acknowledge that 'extern specs' are truly twisting rustc's arm,</p>",
        "id": 276645139,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648225864
    },
    {
        "content": "<p>no, this helps.</p>",
        "id": 276645215,
        "sender_full_name": "pnkfelix",
        "timestamp": 1648225905
    },
    {
        "content": "<p>I'm still wrapping my head around whether its the architecture that <em>I</em> would try to adopt if I were making a FM tool</p>",
        "id": 276645249,
        "sender_full_name": "pnkfelix",
        "timestamp": 1648225922
    },
    {
        "content": "<p>but I think I at least understand where you are coming from.</p>",
        "id": 276645297,
        "sender_full_name": "pnkfelix",
        "timestamp": 1648225931
    },
    {
        "content": "<p>I think if i were building the 'official rust FM tool' i wouldn't necessarily do this, though it would probably still be very useful in practice</p>",
        "id": 276645446,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648226011
    },
    {
        "content": "<p>(to avoid needing to fork all your deps)</p>",
        "id": 276645460,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648226017
    },
    {
        "content": "<p>I think my gut reaction is more based on \"wait, this cannot possibly work.\" and yet you're showing that it does. <span aria-label=\"lol\" class=\"emoji emoji-1f606\" role=\"img\" title=\"lol\">:lol:</span></p>",
        "id": 276645556,
        "sender_full_name": "pnkfelix",
        "timestamp": 1648226051
    },
    {
        "content": "<p>oh but it is <em>haacky</em> :)</p>",
        "id": 276645590,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648226065
    },
    {
        "content": "<p>Could we have some way to specify \"semantic\" source patches and then recompile the sysroot while applying a patch to add the contracts? Such patches could be of the form \"add this attribute to an item available at this path\".</p>",
        "id": 276645735,
        "sender_full_name": "bjorn3",
        "timestamp": 1648226147
    },
    {
        "content": "<p>but for example in the case of <code>eq</code> we also would need to add a super trait</p>",
        "id": 276645808,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648226174
    },
    {
        "content": "<p>I wonder if the language would benefit just supporting that as a first class feature.</p>",
        "id": 276645884,
        "sender_full_name": "pnkfelix",
        "timestamp": 1648226214
    },
    {
        "content": "<p>because if we want to say that </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[ensures(self.equiv(rhs))]</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">eq</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">rhs</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">Self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">bool</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 276645887,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648226217
    },
    {
        "content": "<p>The patches should resolve re-exports to prevent breaking when a definition moves.</p>",
        "id": 276645891,
        "sender_full_name": "bjorn3",
        "timestamp": 1648226219
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/183875-wg-formal-methods/topic/formal.20methods.20doc.20follow-up.20discussion/near/276645884\">said</a>:</p>\n<blockquote>\n<p>I wonder if the language would benefit just supporting that as a first class feature.</p>\n</blockquote>\n<p>what, semantic patches?</p>",
        "id": 276645916,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648226238
    },
    {
        "content": "<p>no, introducing new traits that are automatically super traits of one or more other traits</p>",
        "id": 276645954,
        "sender_full_name": "pnkfelix",
        "timestamp": 1648226258
    },
    {
        "content": "<p>(you'd need to specify <em>how</em> they get automatically supported; e.g. provide implementations of all non-default methods for each of the relevant subtraits)</p>",
        "id": 276646101,
        "sender_full_name": "pnkfelix",
        "timestamp": 1648226313
    },
    {
        "content": "<p>the coherence and resolution implications seem sketch</p>",
        "id": 276646103,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648226315
    },
    {
        "content": "<p>I suppose the potential for diamond implementation hierarchies could be a problem.</p>",
        "id": 276646201,
        "sender_full_name": "pnkfelix",
        "timestamp": 1648226365
    },
    {
        "content": "<p>I'm not sure if that's the same as <span class=\"user-mention\" data-user-id=\"312719\">@Xavier Denis</span> 's concerns re coherence+resolution</p>",
        "id": 276646251,
        "sender_full_name": "pnkfelix",
        "timestamp": 1648226390
    },
    {
        "content": "<p>anyway I'm majorly diverting the discussion. ignore that train of thought.</p>",
        "id": 276646339,
        "sender_full_name": "pnkfelix",
        "timestamp": 1648226417
    },
    {
        "content": "<p>Yea that and the need for default impls</p>",
        "id": 276646497,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648226496
    },
    {
        "content": "<p>I think that an <code>extern_spec!</code> system is important in practice for a verification tool / platform but I also think that its very nature means it will be hacky to some degree</p>",
        "id": 276646707,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648226573
    },
    {
        "content": "<p>It certainly seems to have much in common with a proper contract system</p>",
        "id": 276646749,
        "sender_full_name": "pnkfelix",
        "timestamp": 1648226601
    },
    {
        "content": "<p>which Rust doesn't have a standard story for today</p>",
        "id": 276646765,
        "sender_full_name": "pnkfelix",
        "timestamp": 1648226609
    },
    {
        "content": "<p>but <em>should</em>, IMO</p>",
        "id": 276646774,
        "sender_full_name": "pnkfelix",
        "timestamp": 1648226615
    },
    {
        "content": "<p>(I guess it, like <code>#[bench]</code>, was something we figured we'd let the community figure out rather than screw it up ourselves...)</p>",
        "id": 276646895,
        "sender_full_name": "pnkfelix",
        "timestamp": 1648226661
    },
    {
        "content": "<p>yea, as bjorn3 was saying:  some sort of opaque support for contracts and lowering them could be added to rustc</p>",
        "id": 276647052,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648226744
    },
    {
        "content": "<p>without having to go into the questions of the semantics of the actual contract language, a mechanism to attach some expressions representing a contract and have them lowered with minimal pollution of MIR</p>",
        "id": 276647176,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648226793
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312719\">Xavier Denis</span> <a href=\"#narrow/stream/183875-wg-formal-methods/topic/formal.20methods.20doc.20follow-up.20discussion/near/276647176\">said</a>:</p>\n<blockquote>\n<p>without having to go into the questions of the semantics of the actual contract language, a mechanism to attach some expressions representing a contract and have them lowered with minimal pollution of MIR</p>\n</blockquote>\n<p>I think that for tools that aim to verify that unsafe code does not cause UB, it is essential that the verified MIR matches the one that is compiled because (as was mentioned in the stable MIR document) UB may potentially be removed when lowering from source Rust to MIR. This, unfortunately, is very hard to achieve with specifications based on procedural macros.</p>",
        "id": 276730404,
        "sender_full_name": "Vytautas Astrauskas [he/him]",
        "timestamp": 1648307371
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/183875-wg-formal-methods/topic/formal.20methods.20doc.20follow-up.20discussion/near/276635953\">said</a>:</p>\n<blockquote>\n<p>I'm not saying they have to be exactly equal, but if you could have special functions defined and interpreted by the tool, would it be possible to lower the pre- and postconditions to MIR and include it in the crate metadata without handling it in any other way?</p>\n</blockquote>\n<p>That would be great! I'm not sure how Creusot does it, but in Prusti contracts are already procedural macros that desugar to the \"special functions\" that you mentioned (and more stuff). We link the pre/postcondition-function to the function to be verified by using attributes and UUIDs. For example, <a href=\"https://github.com/viperproject/prusti-dev/blob/620565ca946b01fb105a4559eec07ec57bc308e0/prusti-tests/tests/parse/ui/true.rs#L8-L9\">this</a> becomes <a href=\"https://github.com/viperproject/prusti-dev/blob/620565ca946b01fb105a4559eec07ec57bc308e0/prusti-tests/tests/parse/ui/true.stdout#L20-L27\">this</a>.</p>\n<p>Our current challenge is that to retrieve the contract from an external crate we need to obtain the <em>borrow-checked MIR</em> of external functions. Not the <em>optimized</em> one. One option that should already be possible is to serialize/deserialize the borrow-checked MIR to disk on our own, but storing it in the crate's metadata seems much more maintainable, less error prone etc.</p>\n<p>Are there known limitations on the size of the metadata of a crate? The borrow-checked MIR that we might have to serialize is <code>BodyWithBorrowckFacts</code>, which includes the Polonius facts.</p>",
        "id": 277130978,
        "sender_full_name": "Federico Poli",
        "timestamp": 1648640979
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312719\">Xavier Denis</span> <a href=\"#narrow/stream/183875-wg-formal-methods/topic/formal.20methods.20doc.20follow-up.20discussion/near/276644661\">said</a>:</p>\n<blockquote>\n<p>the idea being that now every time <code>call_once</code> appears in the code, we force you to prove that you have <code>F: FnOnceSpec</code> also be true beyond just <code>F: FnOnce</code></p>\n</blockquote>\n<p>I'm trying to understand your idea. If every <code>FnOnce</code> is forced to also be <code>FnOnceSpec</code>, is adding the <code>FnOnceSpec</code>'s methods directly to <code>FnOnce</code> instead of creating the new trait a more or less equivalent alternative? The additional methods could be marked in a special way to be sure that rustc ignores them when lowering MIR to LLVM IR and so on.</p>",
        "id": 277134315,
        "sender_full_name": "Federico Poli",
        "timestamp": 1648642533
    },
    {
        "content": "<blockquote>\n<p>That would be great! I'm not sure how Creusot does it, but in Prusti contracts are already procedural macros that desugar to the \"special functions\" that you mentioned (and more stuff). We link the pre/postcondition-function to the function to be verified by using attributes and UUIDs. For example, this becomes this.</p>\n</blockquote>\n<p>In MIR I do something similar, a proc macro parses the contracts and produces a function with a 'HOAS' version of the contract, that is: the expression <code>requires(a ==&gt; b)</code> becomes something like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">requires_uuuuuuuid</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"w\"> </span>: <span class=\"nc\">T1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span>: <span class=\"nc\">T2</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">bool</span> <span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">creusot_contracts</span>::<span class=\"n\">stubs</span>::<span class=\"n\">implies</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>similar to prusti i then link these contract functions to their original program function using attributes. <br>\nWhen dealing with invariants I do the same trick but use a <em>closure</em> instead. </p>\n<blockquote>\n<p>Our current challenge is that to retrieve the contract from an external crate we need to obtain the borrow-checked MIR of external functions. Not the optimized one. One option that should already be possible is to serialize/deserialize the borrow-checked MIR to disk on our own, but storing it in the crate's metadata seems much more maintainable, less error prone etc.</p>\n</blockquote>\n<p>My solution to this is twofold: 1. I translate contracts from THIR, 2. I produce an IR which i then serialize into a custom metadata file (<code>.cmeta</code>) using existing serialization infrastructure. I posted about this in <a class=\"stream-topic\" data-stream-id=\"183875\" href=\"/#narrow/stream/183875-wg-formal-methods/topic/Encoding.20custom.20metadata\">#wg-formal-methods &gt; Encoding custom metadata</a> .  This has given me a pretty complete solution, though it can interact poorly with cargo's caching system</p>",
        "id": 277137936,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648644257
    },
    {
        "content": "<blockquote>\n<p>I'm trying to understand your idea. If every FnOnce is forced to also be FnOnceSpec, is adding the FnOnceSpec's methods directly to FnOnce instead of creating the new trait a more or less equivalent alternative? The additional methods could be marked in a special way to be sure that rustc ignores them when lowering MIR to LLVM IR and so on. </p>\n</blockquote>\n<p>The case of <code>FnOnceSpec</code> is special because <code>FnOnce</code> is special and hardcoded into the compiler. But more broadly, sure all of these could be done easily if we could extend standard library traits. But that would require forking / patching the standard library (lots of maintenance work to follow) and also causes an issue where you need to specify and prove every instace of those traits</p>",
        "id": 277138051,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648644338
    },
    {
        "content": "<p>What I'm attempting to do is find a way to bring specifications to std in a 'open world' or incremental manner, so that it doesn't imply \"maintain a whole fork of std alone\"</p>",
        "id": 277138147,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648644375
    },
    {
        "content": "<p>For example, if we use a <code>EqSpec</code> trait to specify <code>eq</code>, this doesn't break every existing instance of <code>Eq</code> out there by adding new, undefined predicates. Instead, if we want to use <code>eq</code> in our <em>verified</em> program we must show that we also have <code>EqSpec</code> for that type</p>",
        "id": 277138491,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648644555
    },
    {
        "content": "<p>so we just have to provide instances for the types we actually use</p>",
        "id": 277138522,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648644570
    },
    {
        "content": "<blockquote>\n<p>similar to prusti i then link these contract functions to their original program function using attributes.<br>\nWhen dealing with invariants I do the same trick but use a closure instead.</p>\n</blockquote>\n<p>Same in Prusti <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>\n<blockquote>\n<p>My solution to this is twofold: 1. I translate contracts from THIR, 2. I produce an IR which i then serialize into a custom metadata file (.cmeta) using existing serialization infrastructure. I posted about this in #wg-formal-methods &gt; Encoding custom metadata . This has given me a pretty complete solution, though it can interact poorly with cargo's caching system</p>\n</blockquote>\n<p>Is that the THIR generated by the proc macros? If so, how do you lower those to MIR in the end? Do you take all contracts from the external crates and generate local functions? (I guess not)</p>\n<blockquote>\n<p>But that would require forking / patching the standard library (lots of maintenance work to follow)</p>\n</blockquote>\n<p>Not necessarily, if the compiler gives support to inject via the API \"ghost\" methods into existing traits. (With \"ghost\" I mean code that is guaranteed by the compiler to be removed before lowering to LLVM IR. Something like a <code>#[ghost]</code> attribute, which would be useful for verification tools anyway.) That said, I don't have a full solution in mind. I was just trying to understand if the additional supertraits that you described are in the end equivalent to adding methods to the trait definitions.</p>\n<blockquote>\n<p>What I'm attempting to do is find a way to bring specifications to std in a 'open world' or incremental manner, so that it doesn't imply \"maintain a whole fork of std alone\"</p>\n</blockquote>\n<p>I completely agree  <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>\n<p>What do you mean with undefined predicates?</p>",
        "id": 277143008,
        "sender_full_name": "Federico Poli",
        "timestamp": 1648646395
    },
    {
        "content": "<blockquote>\n<p>Not necessarily, if the compiler gives support to inject via the API \"ghost\" methods into existing traits. (With \"ghost\" I mean code that is guaranteed by the compiler to be removed before lowering to LLVM IR. Something like a #[ghost] attribute, which would be useful for verification tools anyway.) That said, I don't have a full solution in mind. I was just trying to understand if the additional supertraits that you described are in the end equivalent to adding methods to the trait definitions.</p>\n</blockquote>\n<p>But if you inject methods into <code>Eq</code> how do you give an actual value for say <code>Vec</code> or <code>HashMap</code>, the whole point of injecitng methods into traits is that each impl should define them in a unique manner. So I don't think its possible for rust to add 'ghost methods' for us. </p>\n<blockquote>\n<p>Is that the THIR generated by the proc macros? If so, how do you lower those to MIR in the end? Do you take all contracts from the external crates and generate local functions? (I guess not)</p>\n</blockquote>\n<p>I don't lower logical functions to MIR at all. In fact I erase them so that they have no MIR. I also don't generate local functions for external contracts, I just deserialize their IR much like how you can request <code>optimized_mir</code> for external functions, except that here it's a format appropriate for predicates.</p>",
        "id": 277153955,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648650880
    },
    {
        "content": "<blockquote>\n<p>But if you inject methods into <code>Eq</code> how do you give an actual value for say <code>Vec</code> or <code>HashMap</code>, the whole point of injecitng methods into traits is that each impl should define them in a unique manner. So I don't think its possible for rust to add 'ghost methods' for us. </p>\n</blockquote>\n<p>If a method declaration <code>fn equiv(&amp;self, other: &amp;Self) -&gt; bool</code> can be injected into <code>Eq</code>, then I would also expect to be able to inject different implementations into <code>impl Eq for Vec</code>, <code>HashMap</code> etc. Adding a single supertrait as you suggested looks like a smaller change to the compiler's API.</p>\n<blockquote>\n<p>I don't lower logical functions to MIR at all. In fact I erase them so that they have no MIR. I also don't generate local functions for external contracts, I just deserialize their IR much like how you can request <code>optimized_mir</code> for external functions, except that here it's a format appropriate for predicates.</p>\n</blockquote>\n<p>Ah, I see. Thanks!</p>",
        "id": 277245142,
        "sender_full_name": "Federico Poli",
        "timestamp": 1648713439
    },
    {
        "content": "<blockquote>\n<p>If a method declaration fn equiv(&amp;self, other: &amp;Self) -&gt; bool can be injected into Eq, then I would also expect to be able to inject different implementations into impl Eq for Vec, HashMap etc. Adding a single supertrait as you suggested looks like a smaller change to the compiler's API.</p>\n</blockquote>\n<p>Ah of course, if you can inject into trait declarations you would be able to inject into instances, that makes sense. I still think that it would be more painful to use as i think the upfront cost is much higher than what I suggest.</p>",
        "id": 277270445,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648728595
    }
]