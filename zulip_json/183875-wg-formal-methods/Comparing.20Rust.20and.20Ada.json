[
    {
        "content": "<p>We recently published a CACM article on Rust:<br>\n<a href=\"https://cacm.acm.org/magazines/2021/4/251364-safe-systems-programming-in-rust/fulltext\">https://cacm.acm.org/magazines/2021/4/251364-safe-systems-programming-in-rust/fulltext</a><br>\nNow a question (more of a comment, really) has come up pointing out that \"safe systems programming\" is also very much in the domain of Ada. Does anyone here know a good comparison of Rust and Ada? It is my understanding that Ada itself has no notion of ownership/borrowing, so where Rust shines when verifying memory management, Ada provides little support. Is that correct? (It is then often pointed out that Ada programs often use way fewer pointers than C++ or Rust programs would, but still, in terms of comparing language capabilities that seems like an important point.) What about concurrency; I read that newer versions of Ada have built-in \"parallel blocks\" but what does the type-checker do to avoid data races?<br>\nAnd then there is Ada/SPARK, but that is backed by a theorem prover, so at this point we'd have to compare with Prusti or so, right? (Of course SPARK is much more mature that what Rust has in this space.)<br>\nI've been curious about this myself for quite some time, and sadly never had the chance of having a long conversation with an Ada expert to get to the bottom of this.</p>",
        "id": 231768167,
        "sender_full_name": "RalfJ",
        "timestamp": 1616663891
    },
    {
        "content": "<blockquote>\n<p>It is my understanding that Ada itself has no notion of ownership/borrowing, so where Rust shines when verifying memory management, Ada provides little support. Is that correct?</p>\n</blockquote>\n<p>As far as I know, Ada has raw pointers, but no notion of ownership. However, Ada/SPARK recently got support for Rust like references with (Prusti) pledges.</p>",
        "id": 231768953,
        "sender_full_name": "Vytautas Astrauskas [he/him]",
        "timestamp": 1616664336
    },
    {
        "content": "<p>Maybe, <span class=\"user-mention\" data-user-id=\"312719\">@Xavier Denis</span> knows more since Ada/SPARK is based on Why3?</p>",
        "id": 231769486,
        "sender_full_name": "Vytautas Astrauskas [he/him]",
        "timestamp": 1616664650
    },
    {
        "content": "<p>(We're already chatting with Xavier's advisor, Jacques-Henri, about this -- but I was hoping to get some input from the wider community here.^^)</p>",
        "id": 231769928,
        "sender_full_name": "RalfJ",
        "timestamp": 1616664855
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/183875-wg-formal-methods/topic/Comparing.20Rust.20and.20Ada/near/231769928\">said</a>:</p>\n<blockquote>\n<p>(We're already chatting with Xavier's advisor, Jacques-Henri, about this -- but I was hoping to get some input from the wider community here.^^)</p>\n</blockquote>\n<p>I see. I also would be curious to learn more about Ada and SPARK <span aria-label=\"smiling face\" class=\"emoji emoji-263a\" role=\"img\" title=\"smiling face\">:smiling_face:</span>.</p>",
        "id": 231773360,
        "sender_full_name": "Vytautas Astrauskas [he/him]",
        "timestamp": 1616666532
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> that’s no longer true! SPARK just added mutable borrows</p>",
        "id": 231773673,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1616666665
    },
    {
        "content": "<p>are we comparing Rust with Ada or SPARK now? ;)</p>",
        "id": 231773726,
        "sender_full_name": "RalfJ",
        "timestamp": 1616666699
    },
    {
        "content": "<p>those seem like two different questions, no?</p>",
        "id": 231773765,
        "sender_full_name": "RalfJ",
        "timestamp": 1616666711
    },
    {
        "content": "<p>the comment on the CACM site only talks about Ada</p>",
        "id": 231773789,
        "sender_full_name": "RalfJ",
        "timestamp": 1616666720
    },
    {
        "content": "<p>but \"Ada/SPARK is taking inspiration from Rust features\" is certainly going to be part of our answer :)</p>",
        "id": 231773828,
        "sender_full_name": "RalfJ",
        "timestamp": 1616666742
    },
    {
        "content": "<p>So spark is a subset of Ada</p>",
        "id": 231775210,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1616667394
    },
    {
        "content": "<p>And supports borrows in the rust sense</p>",
        "id": 231775212,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1616667395
    },
    {
        "content": "<p>And can verify programs using those</p>",
        "id": 231775213,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1616667395
    },
    {
        "content": "<p>I actually have one of the spark devs right next to me right now</p>",
        "id": 231775214,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1616667395
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/183875-wg-formal-methods/topic/Comparing.20Rust.20and.20Ada/near/231773765\">said</a>:</p>\n<blockquote>\n<p>those seem like two different questions, no?</p>\n</blockquote>\n<p>I have an impression that SPARK has a strong influence on the development of Ada. For example, Ada 2012 got first-class support for functional specifications. Therefore, I would not be surprised if an upcoming version of Ada would also have support for borrowing. I would say that both projects have a lot to learn from each other.</p>",
        "id": 231775514,
        "sender_full_name": "Vytautas Astrauskas [he/him]",
        "timestamp": 1616667549
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> they actually use a translation quite similar to RustHorn / Creusot and allow “prophetic specifications” like in creusot</p>",
        "id": 231776368,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1616668013
    },
    {
        "content": "<p>The SPARK being a subset of Ada comment is from the mouth of a SPARK dev</p>",
        "id": 231776371,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1616668013
    },
    {
        "content": "<p><a href=\"https://docs.adacore.com/spark2014-docs/html/ug/en/source/access.html#borrowing\">https://docs.adacore.com/spark2014-docs/html/ug/en/source/access.html#borrowing</a></p>",
        "id": 231776869,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1616668291
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312719\">Xavier Denis</span> <a href=\"#narrow/stream/183875-wg-formal-methods/topic/Comparing.20Rust.20and.20Ada/near/231776371\">said</a>:</p>\n<blockquote>\n<p>The SPARK being a subset of Ada comment is from the mouth of a SPARK dev</p>\n</blockquote>\n<p>so it's a bit like misra-C vs C?</p>",
        "id": 231781136,
        "sender_full_name": "RalfJ",
        "timestamp": 1616670299
    },
    {
        "content": "<p>OTOH it some regards it seems to be \"more\" than Ada, namely by adding some fancy type system features (including, recently, some inspired by Rust)</p>",
        "id": 231781341,
        "sender_full_name": "RalfJ",
        "timestamp": 1616670396
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312719\">Xavier Denis</span> <a href=\"#narrow/stream/183875-wg-formal-methods/topic/Comparing.20Rust.20and.20Ada/near/231776869\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://docs.adacore.com/spark2014-docs/html/ug/en/source/access.html#borrowing\">https://docs.adacore.com/spark2014-docs/html/ug/en/source/access.html#borrowing</a></p>\n</blockquote>\n<p>I see no lifetimes there, so can I assume this is still much less flexible than what the borrow checker can do? for example, could you write the typed safe-to-use API of Rust's <code>Vec</code>?</p>",
        "id": 231781392,
        "sender_full_name": "RalfJ",
        "timestamp": 1616670434
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312719\">Xavier Denis</span> <a href=\"#narrow/stream/183875-wg-formal-methods/topic/Comparing.20Rust.20and.20Ada/near/231775214\">said</a>:</p>\n<blockquote>\n<p>I actually have one of the spark devs right next to me right now</p>\n</blockquote>\n<p>ah that'd be great if they could comment on this. :D<br>\nI am particularly wondering about concurrency -- do Ada or Ada+SPARK have mechanisms in place to ensure data-race freedom? Is there something equivalent to Rust's <code>Mutex</code>/<code>RwLock</code> that enables safe shared mutable state?</p>",
        "id": 231781567,
        "sender_full_name": "RalfJ",
        "timestamp": 1616670519
    },
    {
        "content": "<p>Another aspect we're interested is formal proofs -- is there a formal model of Ada or SPARK with a proof of type safety, or anything like that?</p>",
        "id": 231782655,
        "sender_full_name": "RalfJ",
        "timestamp": 1616671071
    },
    {
        "content": "<p>I told Yannick to sign up for Zulip so he should log on soon to give proper answers</p>",
        "id": 231785826,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1616672720
    },
    {
        "content": "<p>(Happy to use other communication channels as well, e.g. our MPI Mattermost or email or whatever)</p>",
        "id": 231786003,
        "sender_full_name": "RalfJ",
        "timestamp": 1616672771
    },
    {
        "content": "<p>From my understanding of spark borrows they are much more “local” so they don’t need a complex borrow checker like rust</p>",
        "id": 231786060,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1616672794
    },
    {
        "content": "<p>I’m no Ada expert though</p>",
        "id": 231786078,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1616672804
    },
    {
        "content": "<p>And I believe they mean it’s a subset of Ada in the sense that a subset of Ada programs are valid spark</p>",
        "id": 231786273,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1616672893
    },
    {
        "content": "<p>So imposing additional data flow analyses is no issue for them</p>",
        "id": 231786337,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1616672933
    },
    {
        "content": "<p>right, but that still restricts what you can do in terms of abstraction</p>",
        "id": 231786457,
        "sender_full_name": "RalfJ",
        "timestamp": 1616672989
    },
    {
        "content": "<p>Yes it’s not equivalent to Rust</p>",
        "id": 231786530,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1616673011
    },
    {
        "content": "<p>you could do a borrow-checker-like thing in C and carve out some appropriate \"subset of C\" that way, but where Rust shines is giving types to APIs that have interesting ownership patterns (such as <code>Vec</code>)</p>",
        "id": 231786589,
        "sender_full_name": "RalfJ",
        "timestamp": 1616673044
    },
    {
        "content": "<p>Also afaik they have no formal proof of type system soundness</p>",
        "id": 231786591,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1616673046
    },
    {
        "content": "<p>and to get those types you need to add something (namely a more expressive type system), not just reject more programs</p>",
        "id": 231786618,
        "sender_full_name": "RalfJ",
        "timestamp": 1616673062
    },
    {
        "content": "<p>Agreed, but different use cases I think</p>",
        "id": 231786686,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1616673103
    },
    {
        "content": "<p>I think Yannick will be best places to answer these questions</p>",
        "id": 231786808,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1616673159
    },
    {
        "content": "<p>I really only have a passing knowledge of SPARK, particularly in how they translate and reason on their borrows</p>",
        "id": 231786871,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1616673194
    },
    {
        "content": "<p>Very nice article btw! I was invited by <span class=\"user-mention\" data-user-id=\"312719\">@Xavier Denis</span> to answer questions on Ada and SPARK. SPARK is indeed a subset of Ada, like MISRA C is a subset of C (I even wrote a comparison about that at <a href=\"https://learn.adacore.com/courses/SPARK_for_the_MISRA_C_Developer/\">https://learn.adacore.com/courses/SPARK_for_the_MISRA_C_Developer/</a>), but the goal with SPARK is to provide guarantees statically about the program, by static analysis and proof. Ada does not provide as many guarantees statically as Rust regarding dynamic memory and concurrency. Regarding pointers, its main focus is on pointers to the stack, which by typing can't become dangling pointers: you can declare local pointer types for pointer variables that _can_ point to a stack variable of the same or a less-nested scope, but can't point to a stack variable of a more-nested scope. You can also have a form of local memory reclamation by declaring a local pointer type with its own \"memory pool\" in which all dynamically allocated pointers of that type are allocated, which is freed when the scope is exited. The typing rules ensure that this does not lead again to dangling pointers. But there are no guarantees for more liberal use of dynamic allocation, in particular the \"free\" function is called Unchecked_Deallocation and opens the door to double-free or use-after-free, and you are not protected against memory leaks when not using a local \"memory pool\".  Similarly, Ada does not provide as many guarantees statically as Rust regarding concurrent access to shared data/resources. The safe way to access shared data/resources is to use \"protected objects\" (with their own lock) but nothing forces you to comply with it. The parallel features in the upcoming version of Ada are not implemented in GNAT/SPARK today and may not be for some time. </p>\n<p>SPARK supports both pointers and concurrency safely by restricting what you can do. For concurrency, that means only accessing shared data that is \"synchronized\" (exact definition here: <a href=\"https://docs.adacore.com/live/wave/spark2014/html/spark2014_rm/tasks-and-synchronization.html\">https://docs.adacore.com/live/wave/spark2014/html/spark2014_rm/tasks-and-synchronization.html</a> so that includes atomic objects and protected objects). For pointers, that means following a simple ownership policy modeled after Rust ownership policy. That allows us to deal with pointers in proof like we do for other data structures, without worrying about possible aliasing. The difficulty comes with mutating a linked data structure while traversing it, and here my colleague Claire Dross initially implemented last year the pledges from Prusti and recently replaced them with the prophecy variables that <span class=\"user-mention\" data-user-id=\"312719\">@Xavier Denis</span> is using in his PhD work. You can see an example of use of prophecy variables here: <a href=\"https://github.com/yannickmoy/am2sp/blob/db487410991cd5373c56f0f251013b85c2e5aef0/src/list_arith.adb#L34\">https://github.com/yannickmoy/am2sp/blob/db487410991cd5373c56f0f251013b85c2e5aef0/src/list_arith.adb#L34</a> and the equivalent with pledges here: <a href=\"https://github.com/yannickmoy/am2sp/blob/0ecdec063a5f09aa246061154c8a6b560d87b85a/src/list_arith.adb#L35\">https://github.com/yannickmoy/am2sp/blob/0ecdec063a5f09aa246061154c8a6b560d87b85a/src/list_arith.adb#L35</a> The SPARK User's Guide now contains a variety of typical loop invariants with prophecy variables: <a href=\"https://docs.adacore.com/live/wave/spark2014/html/spark2014_ug/en/source/loop.html\">https://docs.adacore.com/live/wave/spark2014/html/spark2014_ug/en/source/loop.html</a> (just look for occurrences of \"At_End\").   </p>\n<p>That being said, we'd like to include more static guarantees in Ada itself in the future (enforced only by compilation, while the current solution for SPARK is based on a mix of ownership checking and proof for things like non-null pointer dereference checks and absence of memory leaks), and of course we're looking at Rust as a main source of inspiration here!</p>",
        "id": 231803514,
        "sender_full_name": "Yannick Moy",
        "timestamp": 1616680342
    },
    {
        "content": "<p>Also, regarding formalization, there is very little regarding how SPARK deals with pointers, published recently: <a href=\"https://hal.archives-ouvertes.fr/INRIA-SACLAY/hal-03094566v1\">https://hal.archives-ouvertes.fr/INRIA-SACLAY/hal-03094566v1</a></p>",
        "id": 231804098,
        "sender_full_name": "Yannick Moy",
        "timestamp": 1616680549
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"400488\">@Yannick Moy</span> thanks a lot, that is very helpful :)</p>",
        "id": 231808289,
        "sender_full_name": "RalfJ",
        "timestamp": 1616681871
    },
    {
        "content": "<p>I seem to be joining this thread a bit late, but (like Yannick) I am one of the long-standing developers and users of SPARK, so happy to contribute. I am learning Rust right now, with a focus on \"no_std\" target systems and formal verification, so I'm very interested in things like Prusti, Crux-MIR, and RMC, all of which I hope to take a look at soon.</p>",
        "id": 261906447,
        "sender_full_name": "Roderick Chapman",
        "timestamp": 1637229512
    },
    {
        "content": "<p>What kinds of programs are you interested in verifying?</p>",
        "id": 261924607,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1637241071
    },
    {
        "content": "<p>Cryptographic algorithms mostly. Google for \"SPARKNaCl\" to see what I did in lockdown... :-)</p>",
        "id": 261926722,
        "sender_full_name": "Roderick Chapman",
        "timestamp": 1637242195
    },
    {
        "content": "<p>I am also interested in formal verification of <code>no_std</code>-friendly cryptographic algorithms <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 261931696,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1637244692
    },
    {
        "content": "<p>I just watched your talk from RW2021, so I'll add Creusot to my list of things to look at</p>",
        "id": 261931707,
        "sender_full_name": "Roderick Chapman",
        "timestamp": 1637244698
    },
    {
        "content": "<p>:) there's been pretty major work since then as well</p>",
        "id": 261938960,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1637247883
    },
    {
        "content": "<p>In particular we've added a fairly robust support for traits, which we heavily use to deal with things like <code>Ord</code> or <code>Eq</code>. We've proven a series of key algorithms using this. </p>\n<p>A complete, polymorphic version of binary search (and several sorting algorithms) proven correct: </p>\n<ul>\n<li><a href=\"https://github.com/xldenis/creusot/blob/master/creusot/tests/should_succeed/vector/05_binary_search_generic.rs\">https://github.com/xldenis/creusot/blob/master/creusot/tests/should_succeed/vector/05_binary_search_generic.rs</a></li>\n<li><a href=\"https://github.com/xldenis/creusot/blob/master/creusot/tests/should_succeed/selection_sort_generic.rs\">https://github.com/xldenis/creusot/blob/master/creusot/tests/should_succeed/selection_sort_generic.rs</a></li>\n<li><a href=\"https://github.com/xldenis/creusot/blob/master/creusot/tests/should_succeed/heapsort_generic.rs\">https://github.com/xldenis/creusot/blob/master/creusot/tests/should_succeed/heapsort_generic.rs</a></li>\n<li><a href=\"https://github.com/xldenis/creusot/blob/master/creusot/tests/should_succeed/vector/02_gnome.rs\">https://github.com/xldenis/creusot/blob/master/creusot/tests/should_succeed/vector/02_gnome.rs</a></li>\n</ul>",
        "id": 261939636,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1637248178
    },
    {
        "content": "<p>We've also been developing a 'verification std'</p>",
        "id": 261939865,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1637248268
    },
    {
        "content": "<p><a href=\"https://github.com/xldenis/creusot/tree/master/creusot-contracts/src/logic\">https://github.com/xldenis/creusot/tree/master/creusot-contracts/src/logic</a></p>",
        "id": 261939894,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1637248285
    },
    {
        "content": "<p>We've also shown that our approach scales better than traditional seperation logic approaches for C languages: we've proven a few examples that required manual coq proofs in frama-c</p>",
        "id": 261940120,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1637248392
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"132721\">Tony Arcieri</span> <a href=\"#narrow/stream/183875-wg-formal-methods/topic/Comparing.20Rust.20and.20Ada/near/261931696\">said</a>:</p>\n<blockquote>\n<p>I am also interested in formal verification of <code>no_std</code>-friendly cryptographic algorithms <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>\n</blockquote>\n<p>I am curious. What is actually formal verification of cryptographic algorithms? If I take the abstract description of say SHA-1 and then write rust code that exactly follows each step of this description that is equally likely to be correct as if I exactly follow each step in a formal verification language and then check that the rust code matches what is written in the formal verification language, right?</p>",
        "id": 261944990,
        "sender_full_name": "bjorn3",
        "timestamp": 1637250397
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/183875-wg-formal-methods/topic/Comparing.20Rust.20and.20Ada/near/261944990\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"132721\">Tony Arcieri</span> <a href=\"#narrow/stream/183875-wg-formal-methods/topic/Comparing.20Rust.20and.20Ada/near/261931696\">said</a>:</p>\n<blockquote>\n<p>I am also interested in formal verification of <code>no_std</code>-friendly cryptographic algorithms <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>\n</blockquote>\n<p>I am curious. What is actually formal verification of cryptographic algorithms? If I take the abstract description of say SHA-1 and then write rust code that exactly follows each step of this description that is equally likely to be correct as if I exactly follow each step in a formal verification language and then check that the rust code matches what is written in the formal verification language, right?</p>\n</blockquote>\n<p>Your code would probably not be efficient, and open to side channel attacks if you did that, but yes, it would also be functionally correct.</p>",
        "id": 261945671,
        "sender_full_name": "Alix Trieu",
        "timestamp": 1637250658
    },
    {
        "content": "<p>So it is basically proving that your optimized version is equivalent to the naive version?</p>",
        "id": 261946195,
        "sender_full_name": "bjorn3",
        "timestamp": 1637250867
    },
    {
        "content": "<p>That's one form of proof called 'refinement' in literature</p>",
        "id": 261951568,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1637252846
    },
    {
        "content": "<p>Another key kind of proof is showing standard properties about your code</p>",
        "id": 261951587,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1637252858
    },
    {
        "content": "<p>Especially with crypto algorithms there are various properties you may want to guarantee</p>",
        "id": 261951625,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1637252877
    },
    {
        "content": "<p>a common technique is you write a naive and simple implementation, often as a pure functional program, and then prove an optimized refinement as an imperative program</p>",
        "id": 261951769,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1637252928
    },
    {
        "content": "<p>you can then prove properties on the functional version and get them for free on the imperative one (by refinement)</p>",
        "id": 261951818,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1637252946
    },
    {
        "content": "<p>in the case of crypto there are key properties you may want to show: non interference, forward secrecy, etc...</p>",
        "id": 261952094,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1637253054
    },
    {
        "content": "<p>equivalence proofs are definitely one of the main things I've been interested in pursuing</p>",
        "id": 261955524,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1637254458
    },
    {
        "content": "<p>especially being able to prove that SIMD backends are equivalent to a reference implementation for all possible inputs</p>",
        "id": 261955691,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1637254519
    },
    {
        "content": "<p>Gotcha. Thanks for the explanation everyone!</p>",
        "id": 261990317,
        "sender_full_name": "bjorn3",
        "timestamp": 1637269424
    },
    {
        "content": "<p>here's an example of the sort of thing I'd like to be able to do: <a href=\"https://cr.yp.to/talks/2021.09.03/slides-djb-20210903-saferewrite-4x3.pdf\">https://cr.yp.to/talks/2021.09.03/slides-djb-20210903-saferewrite-4x3.pdf</a></p>",
        "id": 261991923,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1637270179
    },
    {
        "content": "<blockquote>\n<p>with a focus on \"no_std\" target systems and formal verification</p>\n</blockquote>\n<blockquote>\n<p>I am also interested in formal verification of no_std-friendly cryptographic algorithms</p>\n</blockquote>\n<p>To pile on here, I'm currently adding improved support for <code>#![no_std]</code>crates to <a href=\"https://www.youtube.com/watch?v=C9TTioH5JUg\">Prusti</a>. Also, you may enjoy <a href=\"https://github.com/hacspec/hacspec\">hacspec</a> <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"C9TTioH5JUg\" href=\"https://www.youtube.com/watch?v=C9TTioH5JUg\"><img src=\"https://uploads.zulipusercontent.net/c3cafa82302827f083e074bcefa64b4b1c5d2fae/68747470733a2f2f692e7974696d672e636f6d2f76692f43395454696f48354a55672f64656661756c742e6a7067\"></a></div>",
        "id": 262081065,
        "sender_full_name": "Pointerbender",
        "timestamp": 1637335668
    },
    {
        "content": "<p>I am a fan of both Prusti and Hacspec <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 262083013,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1637336525
    },
    {
        "content": "<p>would be quite happy to see something like equivalence proofs between something like a Cryptol or F* reference implementation of an algorithm and Hacspec, and then when there's a verified Rust reference implementation, trying to prove or at least proptest/fuzz equivalence to that</p>",
        "id": 262083202,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1637336612
    },
    {
        "content": "<p>with umm, other people who understand formal verification better than I do working on the former</p>",
        "id": 262083245,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1637336632
    },
    {
        "content": "<p>That sounds neat <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 262083461,
        "sender_full_name": "Pointerbender",
        "timestamp": 1637336717
    },
    {
        "content": "<p>Thanks for that pointer to your talk from RVW this year.. I will certainly take a look. I hope to re-write some of SPARKNaCl (which is a port re-write of TweetNaCl) in no_std Rust soon to see what the various tools can do. I'll probably pick on the core of the curve25519 operations, since they are reasonably hard to prove, but I already know exactly what preconditions and loop invariants are required...</p>",
        "id": 262092008,
        "sender_full_name": "Roderick Chapman",
        "timestamp": 1637339978
    },
    {
        "content": "<p>I failed to get HacSpec to compile in no_std - I think its ByteSeq type depends on std::Vec so that's mildly show-stopping for now I think?</p>",
        "id": 262092202,
        "sender_full_name": "Roderick Chapman",
        "timestamp": 1637340067
    },
    {
        "content": "<p>huh, weird.. should change that to be <code>alloc</code> at least</p>",
        "id": 262092458,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1637340177
    },
    {
        "content": "<p>re: Prusti the main thing I'd like to try using it for is ensuring that a <code>no_std</code>-friendly subset of a crate is panic-free, although last time I tried to do that it didn't quite support all of the language features I needed to do that, although that was awhile ago</p>",
        "id": 262092702,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1637340284
    },
    {
        "content": "<p>I've tried so many different approaches to ensuring code is panic-free in CI and I've never been happy with any of them</p>",
        "id": 262092778,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1637340323
    },
    {
        "content": "<p>Prusti seems like the best so far though</p>",
        "id": 262092795,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1637340330
    },
    {
        "content": "<p>there are a million little hacky crates that do things like try to find the panic handler symbols in the resulting executable and it's like \"no that's not really helpful, I want you to show me where the code that might cause a panic is located\"</p>",
        "id": 262092916,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1637340366
    },
    {
        "content": "<p>should give it another go</p>",
        "id": 262092986,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1637340397
    },
    {
        "content": "<blockquote>\n<p>Thanks for that pointer to your talk from RVW this year</p>\n</blockquote>\n<p>Ah that's not me, I thought it's just a nice quick introduction to Prusti <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span></p>",
        "id": 262094985,
        "sender_full_name": "Pointerbender",
        "timestamp": 1637341136
    }
]