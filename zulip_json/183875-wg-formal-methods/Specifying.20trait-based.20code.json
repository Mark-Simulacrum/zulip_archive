[
    {
        "content": "<p>Hi all!</p>",
        "id": 268702442,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642690090
    },
    {
        "content": "<p>I figured i'd ask around to see if people have ideas / opinions on the best approaches to specifying trait based code, and more specifically specifying traits from <code>std</code>.</p>",
        "id": 268702516,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642690126
    },
    {
        "content": "<p>The core problem is that we would like to attach specifications to traits methods, typically as <code>requires</code> and <code>ensures</code> clauses. This on its own is not an issue, but where we start encountering issues is when we want to specify the behavior of pre-existing stdlib traits like <code>Ord</code> or <code>Eq</code></p>",
        "id": 268702781,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642690246
    },
    {
        "content": "<p>Why do we encounter an issue? Well, specifying the behavior of these traits requires <em>extending</em> them, either adding a <em>new super trait</em> or at minima adding a new item to the trait, which is used to reflect the \"logical\" behavior of this trait</p>",
        "id": 268702912,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642690300
    },
    {
        "content": "<p>to illustrate what I mean, I'll give an example specification for a simplified Eq</p>",
        "id": 268702949,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642690313
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>#[allow(unused)]\npub trait Eq {\n    #[predicate]\n    fn log_eq(self, _: Self) -&gt; bool;\n\n    #[ensures(result == self.log_eq(o))]\n    fn eq(&amp;self, o: &amp;Self) -&gt; bool;\n\n    #[law]\n    #[ensures(x == x)]\n    fn refl(x: Self);\n\n    #[law]\n    #[requires(x == y)]\n    #[ensures(y == x)]\n    fn symmetry(x: Self, y: Self);\n\n    #[law]\n    #[requires(x == y)]\n    #[requires(y == z)]\n    #[ensures(x == z)]\n    fn transitivity(x: Self, y: Self, z: Self);\n}\n</code></pre></div>",
        "id": 268703120,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642690382
    },
    {
        "content": "<p>here we specify <code>eq</code> in terms of a <em>pure, logical relation</em> <code>log_eq</code>, and some laws which we add to the trait</p>",
        "id": 268703212,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642690431
    },
    {
        "content": "<p>the issue which appears is one of 'hooking' into the pre-existing traits. If we want to allow users to benefit from operator notations, we need to somehow make it so that the <em>actual</em> <code>eq</code> has a specification, not just some home-grown trait we happen to have (<a href=\"https://github.com/xldenis/creusot/blob/master/creusot-contracts/src/std/eq.rs\">https://github.com/xldenis/creusot/blob/master/creusot-contracts/src/std/eq.rs</a>)</p>",
        "id": 268703698,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642690599
    },
    {
        "content": "<p>There are many different ways we can tackle the solution to this problem, but they all involve various degrees of hackery, I'm interested if others have encountered a similar problem or have preferred opinions. I can also lay out the approach we are taking in Creusot to address this</p>",
        "id": 268703902,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642690684
    },
    {
        "content": "<p>How reasonable is it to add this stuff to the \"real\" <code>Eq</code>, at least from Creusot's point of view? That is, Creusot replaces the existing trait with this one, and any rust code compiled while Creusot is involved will think this is what the official <code>Eq</code> trait looks like</p>",
        "id": 268713868,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642694266
    },
    {
        "content": "<p>more generally it seems like you might want to compile a custom version of <code>std</code> with these annotations</p>",
        "id": 268714185,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642694377
    },
    {
        "content": "<p>That is a possibility, but I'm not sure how feasible that is?</p>",
        "id": 268726544,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642699216
    },
    {
        "content": "<p>especially since I think the issue is really having a custom <code>core</code>?</p>",
        "id": 268726616,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642699249
    },
    {
        "content": "<p>I actually remember discussing this option with my advisors and a major downside was maintenance, if we have a patched std, I foresee a lot of annoying rebase issues</p>",
        "id": 268731968,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642701467
    },
    {
        "content": "<p>You are probably going to run into similar issues when trying to write specifications for methods on slices, which require an <code>impl&lt;T&gt; [T] {}</code>, rustc will complain because that is a lang item and there can only be one of those :) One work-around could be to use procedural macros that read out the refined specifications and stores these somewhere, but then doesn't actually let the code be passed on to rustc in order to avoid compilation errors (or let it pass through, but rename the trait through the macro - renaming <code>impl</code> blocks for slices will be trickier than renaming traits, though).</p>",
        "id": 268943444,
        "sender_full_name": "Pointerbender",
        "timestamp": 1642836577
    },
    {
        "content": "<p>Yes that’s sort of what I’m doing right now, I have a macro that allows you to attach specifications to external items, including traits.</p>",
        "id": 269012428,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642936844
    },
    {
        "content": "<p>We also allow you to refine the trait bounds on a method so long as those refined bounds imply the original.</p>",
        "id": 269012443,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642936887
    },
    {
        "content": "<p>This allows us to swap in a trait which refines <code>Eq</code> with additional items for specification.</p>",
        "id": 269012491,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642936934
    }
]