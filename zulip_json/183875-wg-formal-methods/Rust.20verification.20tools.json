[
    {
        "content": "<p>My team in Google Research has been thinking about what we want in Rust verification.<br>\nWe want to narrow the gap between testing and verification. e.g., by making it easy to switch back and forth between testing and verification.</p>\n<p>So we have been reimplementing the proptest library so that you can use the same test harness for testing/fuzzing with proptest and for formal verification using automatic verification tools like KLEE.</p>\n<p>It's early days yet but we have something that works and we would love feedback on whether this is a direction that the community should go in or not.</p>\n<p>Code: <a href=\"https://github.com/project-oak/rust-verification-tools\">https://github.com/project-oak/rust-verification-tools</a><br>\nBlog post: <a href=\"https://alastairreid.github.io/why-not-both/\">https://alastairreid.github.io/why-not-both/</a><br>\nTweet: <a href=\"https://twitter.com/alastair_d_reid/status/1301543693233655810\">https://twitter.com/alastair_d_reid/status/1301543693233655810</a></p>\n<div class=\"inline-preview-twitter\"><div class=\"twitter-tweet\"><a href=\"https://twitter.com/alastair_d_reid/status/1301543693233655810\"><img class=\"twitter-avatar\" src=\"https://pbs.twimg.com/profile_images/731458319433519104/q1EULfSQ_normal.jpg\"></a><p>Verifying vs testing?  Why not both?\nNew blog post about our work on Rust verification based on reimplementing the proptest library for formal verification tools so you can use the same test harness with both proptest and with “propverify”.\n<a href=\"https://twitter.com/rustlang\">@rustlang</a> #KLEE\n<a href=\"https://t.co/rAzAvW6MCI\">https://alastairreid.github.io/why-not-both/</a></p><span>- Alastair Reid (@alastair_d_reid)</span></div></div>",
        "id": 208996911,
        "sender_full_name": "Alastair Reid",
        "timestamp": 1599151669
    },
    {
        "content": "<p>It shows a double scroll bar on code blocks in Firefox on Linux:</p>\n<p><a href=\"/user_uploads/4715/phAyFXyFpAP8CF4N0wx2lPLo/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/4715/phAyFXyFpAP8CF4N0wx2lPLo/image.png\" title=\"image.png\"><img src=\"/user_uploads/4715/phAyFXyFpAP8CF4N0wx2lPLo/image.png\"></a></div><p>This is likely caused by the <code>overflow: scroll</code> instead of <code>overflow: auto</code>.</p>",
        "id": 208997420,
        "sender_full_name": "bjorn3",
        "timestamp": 1599151906
    },
    {
        "content": "<p>Ugh! That is horrible. I guess I have to go futz with my website a bit. Thanks for the diagnosis!</p>",
        "id": 209000233,
        "sender_full_name": "Alastair Reid",
        "timestamp": 1599153135
    },
    {
        "content": "<p>I fully agree with the point of this post. :) Testing and verification can complement each other very well.</p>\n<p><span class=\"user-mention\" data-user-id=\"336739\">@Alastair Reid</span> some of this would also be very interesting to the secure code WG (<a class=\"stream\" data-stream-id=\"146229\" href=\"/#narrow/stream/146229-wg-secure-code\">#wg-secure-code</a>), just in case you are not yet familiar with their work.</p>",
        "id": 209071705,
        "sender_full_name": "RalfJ",
        "timestamp": 1599211354
    },
    {
        "content": "<p>A few days ago, we announced the end of our Rust verification project at Google.<br>\nI'm sad to see it end – but I am hoping that others will adapt some of the ideas and solutions to the problems we ran into when tackling \"large\" codebases.<br>\nThis post summarizes what I thought was important about the project <a href=\"https://project-oak.github.io/rust-verification-tools/2021/09/01/retrospective.html\">https://project-oak.github.io/rust-verification-tools/2021/09/01/retrospective.html</a></p>",
        "id": 252154258,
        "sender_full_name": "Alastair Reid",
        "timestamp": 1630923000
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"336739\">@Alastair Reid</span> Some links in your blog post: <a href=\"https://alastairreid.github.io/why-not-both/\">https://alastairreid.github.io/why-not-both/</a><br>\nYou say you use some format from <a href=\"https://alastairreid.github.io/verification-competitions/\">https://alastairreid.github.io/verification-competitions/</a>, but I don't see which one. Could you say more?</p>",
        "id": 252451158,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1631104291
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"382207\">@Bas Spitters</span> I was specifically thinking of SV-COMP and the interface defined in the rules <a href=\"https://sv-comp.sosy-lab.org/2021/rules.php\">https://sv-comp.sosy-lab.org/2021/rules.php</a><br>\nwhich defines operations such as \"X __VERIFIER_nondet_X()\" where X is a builtin type.</p>\n<p>Expressing the same in Rust, there are at least three possible trait-based approaches (based on what we found in MIRAI, KLEE, SMACK and Crux-MIR). <a href=\"https://github.com/project-oak/rust-verification-tools/blob/main/verification-annotations/src/traits.rs\">https://github.com/project-oak/rust-verification-tools/blob/main/verification-annotations/src/traits.rs</a></p>\n<p>The methods in the three traits are</p>\n<ul>\n<li>fn verifier_nondet(self) -&gt; Self;</li>\n<li>fn abstract_value() -&gt; Self;</li>\n<li>fn symbolic(desc: &amp;'static str) -&gt; Self;</li>\n</ul>\n<p>Where the self argument to verifier_nondet is a value that can be used when testing.<br>\nAnd the string argument to symbolic is a name to use in error reports, etc.</p>",
        "id": 252612796,
        "sender_full_name": "Alastair Reid",
        "timestamp": 1631188844
    },
    {
        "content": "<p>On top of that, you need some ways to add assumptions, etc. <a href=\"https://github.com/project-oak/rust-verification-tools/blob/main/verification-annotations/src/verifier/seahorn.rs\">https://github.com/project-oak/rust-verification-tools/blob/main/verification-annotations/src/verifier/seahorn.rs</a></p>\n<p>And individual tools might extend this. For example, our KLEE bindings have a bunch of operations not found in SeaHorn to let you control path merging and to generate a single concrete instance of a symbolic value <a href=\"https://github.com/project-oak/rust-verification-tools/blob/main/verification-annotations/src/verifier/klee.rs\">https://github.com/project-oak/rust-verification-tools/blob/main/verification-annotations/src/verifier/klee.rs</a></p>",
        "id": 252613302,
        "sender_full_name": "Alastair Reid",
        "timestamp": 1631189105
    },
    {
        "content": "<p>In addition to creating symbolic values, the following functions are useful.</p>\n<p>/// Assume that condition <code>cond</code> is true<br>\npub fn assume(cond: bool)</p>\n<p>/// Reject the current execution with a verification failure.<br>\npub fn abort() -&gt; !</p>\n<p>/// Reject the current execution with a verification failure<br>\n/// and an error message.<br>\npub fn report_error(message: &amp;str) -&gt; !</p>\n<p>/// Reject the current execution path with a verification success.<br>\n/// This is equivalent to <code>assume(false)</code> except for the never return type<br>\npub fn reject() -&gt; !</p>",
        "id": 252626354,
        "sender_full_name": "Alastair Reid",
        "timestamp": 1631194522
    },
    {
        "content": "<p>And, if your verification tool can generate failing inputs, it is nice to be able to print those inputs using Rust code (so that they are formatted nicely). For this, it is useful to be able to test whether you are rerunning the verification harness with concrete values or you are verifying the code with symbolic values.</p>\n<p>/// Detect whether the program is being run symbolically in KLEE<br>\n/// or being replayed using the kleeRuntest runtime.<br>\n///<br>\n/// This is used to decide whether to display the values of<br>\n/// variables that may be either symbolic or concrete.<br>\npub fn is_replay() -&gt; bool</p>\n<p>Typical usage:</p>\n<p>let x = abstract_value();<br>\nlet y = abstract_value();<br>\nif is_replay() {<br>\n    println!(\"Test inputs x={} y={}\")<br>\n}<br>\nassert!(x + y == y + x);</p>",
        "id": 252627212,
        "sender_full_name": "Alastair Reid",
        "timestamp": 1631194855
    },
    {
        "content": "<p>Finally, if you want to be able to implement something like  the   #[should_panic] attribute, it is useful to have a way for the verification harness to report the expected behaviour of the system. Something like the following</p>\n<p>/// Declare that failure is the expected behaviour<br>\npub fn expect(msg: Option&lt;&amp;str&gt;) {<br>\n    match msg {<br>\n        None =&gt; eprintln!(\"VERIFIER_EXPECT: should_panic\"),<br>\n        Some(msg) =&gt; eprintln!(\"VERIFIER_EXPECT: should_panic(expected = \\\"{}\\\")\", msg),<br>\n    }<br>\n}</p>\n<p>I think the functions listed above provide important functionality that we would probably want in many different kinds of tool. Of course, the exact names and types could easily change - especially since I was learning Rust and Rust conventions as I was designing this.</p>",
        "id": 252628233,
        "sender_full_name": "Alastair Reid",
        "timestamp": 1631195203
    },
    {
        "content": "<p>Another reason why having a standard API is a good idea (beyond being able to run competitions) is that it lets us build higher-level libraries on top. eg we reimplemented the API of PropTest (a property-based testing crate) to work on top of the above API.</p>\n<p>One of the key things that PropTest gives you (and that PropVerify copied) is an EDSL for defining values to test with.<br>\neg you can write \"x in 1..1000u32\" to generate a value in a range or \"prop::collection::vec(0..10u32, 5)\" to generate a vector of length up to 5 where each value is in the range 0..10.</p>\n<p>The nice thing about doing this is to be able to use a range of techniques from fuzzing (PropTest) through to formal using a variety of different backends (using PropVerify).<br>\n(Caveat: at the time we wrote this, KLEE was the only tool on the formal end of things that could cope with enough of the Rust language that it actually worked with PropVerify. Hopefully this has changed.)</p>",
        "id": 252630319,
        "sender_full_name": "Alastair Reid",
        "timestamp": 1631195981
    }
]