[
    {
        "content": "<p>Hey everyone! I've been developing a project that I hope would be able to bring formal verification to the software engineering mainstream and make provably correct code more normal. It's a dependently typed language currently called Magma that would essentially try to be to both Coq and LLVM what Rust has been to C. I'd greatly appreciate feedback, especially from <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> since I intend to heavily use Iris/Iron.</p>\n<p>The idea is still in the very early ideation and exploratory proving phase:<br>\n<a href=\"https://github.com/blainehansen/magma\">https://github.com/blainehansen/magma</a></p>\n<p>Here's the big picture:</p>\n<ul>\n<li>The language will be a dependently typed calculus of constructions much like Coq, but with clean and approachable design prioritized from the beginning.</li>\n<li>The language will include core theories formalizing \"real\" von neumann computation using Iris at the highest level of genericity possible, so that any concrete instruction architecture or execution environment can be axiomatized.</li>\n<li>A deep but simple metaprogramming system will allow arbitrary embedded languages or custom notation without the extreme opacity and complexity often felt when using Coq's notation system.</li>\n<li>A trackable effects concept using Iron-like fractional tokens will allow arbitrary correctness-related effect types to be applied to code blocks. These trackable effects can be made flexible enough to allow \"progressive verification\", so unverified legacy code can coexist with new verified code without allowing invisible soundness gaps.</li>\n<li>Using these formalizations the language defines a self-hosting query-based compiler so bare metal performance can be enjoyed at all layers of the language architecture.</li>\n</ul>\n<p>There doesn't seem to be anything logically novel here, so the project is just an attempt to merge many good ideas into a practical ergonomic tool.</p>\n<p>I'd love any help or guidance you could offer! Does this idea seem useful and tractable? Have I missed anything? Can you imagine any possible problems I might have using Iris to verify memory resident code? Are there any resources or papers I ought to read before I continue?</p>\n<p>Thank you!</p>",
        "id": 262017994,
        "sender_full_name": "Blaine Hansen",
        "timestamp": 1637286521
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"311402\">@Blaine Hansen</span>  This project has a lot in common with my own project <a href=\"https://github.com/digama0/mm0\">https://github.com/digama0/mm0</a>, with a programming language <a href=\"https://github.com/digama0/mm0/blob/master/mm0-rs/mmc.md\">Metamath C</a> that is designed specifically for writing programs with full functional correctness guarantees (and with formal proofs coming out of the compiler, unlike many similar verified programming languages that use a sat solver for proof obligations but don't try to tie it all together). There is still a ton of UI design work to be done on the syntax and tactics, but it is embedded in a proof assistant with a metaprogramming language so that you can script your way around the shortcomings for the most part.</p>\n<p>A lot of people seem to think that this kind of thing is not feasible, but obviously I beg to differ and with a bit of language design to make proofs in code less of a second class citizen, it can be made palatable to regular programmers (at least, those with a taste for bleeding edge stuff)</p>",
        "id": 262022031,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1637291393
    },
    {
        "content": "<p>Yeah tons of similarities! I especially loved reading this ha:</p>\n<blockquote>\n<p>A type is a function that maps values to separating propositions over machine states. That is, it is a true-or-false statement that applies to portions of the machine state (registers and memory). This is a very low level view, but it has the advantage that because it is so general, users can define types of arbitrary complexity, containing invariants and ownership semantics.</p>\n</blockquote>\n<p>You've done a lot more work on this tool than I have on mine! ha I'm a relative newcomer to formal verification, and this is the first time I've felt brave enough to share anything.</p>\n<p>I have a ton of questions to ask you about mm0! I'm reading the repo but have too many things to ask, especially in regards to teasing out any useful differences between the projects. I'm desperately trying to avoid duplicating work! I need to get to bed but I'm going to ask you a bunch of questions tomorrow :)</p>",
        "id": 262029196,
        "sender_full_name": "Blaine Hansen",
        "timestamp": 1637300112
    },
    {
        "content": "<p>Cool. Would love to collab, PM me any time</p>",
        "id": 262029326,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1637300260
    },
    {
        "content": "<p>Thanks for sharing Blaine, your project seems quite ambitious, which also makes it quite interesting if you succeed!</p>",
        "id": 262038564,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1637310104
    },
    {
        "content": "<p>You may be interested in Steel, which integrates an Iris like framework into F* where you actually have decent automation</p>",
        "id": 262038650,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1637310139
    },
    {
        "content": "<p>More generally, I think you'd be interested in F*</p>",
        "id": 262038662,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1637310147
    },
    {
        "content": "<p>and Lean</p>",
        "id": 262038675,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1637310150
    },
    {
        "content": "<p>F* does a lot of proofs &amp; extraction of low-level imperative code from a dependently typed language, heavily using its metaprogramming features to build more compelx levels of abstraction</p>",
        "id": 262038734,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1637310195
    },
    {
        "content": "<p>Lean has been working on self-hosting itself</p>",
        "id": 262038746,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1637310208
    },
    {
        "content": "<p>In the same vein there's MetaCoq as well</p>",
        "id": 262038769,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1637310221
    },
    {
        "content": "<p>Yes very ambitious, I'm glad no one seems to have any big problems with the design, I'll feel better really getting to work implementing it!</p>\n<p>I'm familiar with F* but I haven't read the Steel papers, I'll check those out!</p>\n<p>And yes metacoq will be a very important jumping off point :)</p>",
        "id": 262153842,
        "sender_full_name": "Blaine Hansen",
        "timestamp": 1637371903
    },
    {
        "content": "<p>Alright <span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span>  here are some of my questions:</p>\n<ul>\n<li>It seems one of the major differences between mm0 and the magma design is that mm0/metamath is very concerned with allowing the actual logic to be instantiated. I assume this is for mathematicians who might be working in some particular logic and don't want to fuss with an embedding? For the more software-focused use I'm targeting I'm having a hard time imagining when I wouldn't want to simply work in something as strong as CiC, but I'm probably just revealing my lack of experience with pure mathematics. Can you think of any ready examples of situations where that kind of logic agnosticism has been useful to someone?</li>\n<li>In the mmc docs you mention that you'd like to use Iris ghost state to handle reference provenances, but you're using Lean? I see you reference an iris-like separation logic you're creating yourself? Has that been difficult or have you learned anything useful in the process? Frankly the innards of Iris and especially the recursive domain equation terrify me ha so I'm hoping to just reuse their existing work.</li>\n<li>Have you used mmc to deploy any \"production\" programs? I'm not finding any references to any, and I'd love to hear your experiences about pain points or lessons learned :)</li>\n</ul>",
        "id": 262153897,
        "sender_full_name": "Blaine Hansen",
        "timestamp": 1637371924
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"311402\">@Blaine Hansen</span> </p>\n<ul>\n<li>MM0 is a foundation-agnostic verification system, which is designed to be simple, as simple as I can make it while still being subject to a soundness theorem. It turns out that foundation-agnosticism is a great way to simplify the kernel; it is hugely simpler than Coq or Lean, but it can still be used to verify proofs in Coq or Lean if you axiomatize them. (As an analogy, you can think of MM0 as a RISC machine for proofs, and Gallina/Lean as CISC machines.) The primary reason for this emphasis on parsimony is because a primary goal of the project is to have a verified verifier for the language, and MMC is the language that will be used to write the verifier and prove it correct.</li>\n<li>I've used Iris for inspiration a lot for designing the MMC separation logic, but my application is much simpler than iris in both design and execution. This comes with a number of limitations, but I've tried to focus on getting to the main project goals and revisit areas that can be generalized later. The main difference, I would say, is that you can't instantiate your own ghost algebras; it is simply <em>a</em> separation logic, not a separation logic framework. The separation logic itself is not particularly complicated: there are heaplets over each little bit of machine state and then these are put together into partial functions. There are not even partial permissions, but that can come later if needed. (In practice, it's not needed as much as you might think because MMC has no <code>malloc</code> yet, it's all globals and stack memory, so ownership is not even all that helpful.)</li>\n<li>MMC is under active development, but is still in alpha stage. This is my PhD thesis project so I'm hoping to have it reasonably usable by the end of the semester, but I've mostly only attempted to compile hello world style programs in it, and right now it is \"only\" giving me machine code, not machine code + proof of correctness like it's supposed to. Once I finish on the main core of the compiler, I hope to open it up to more community development and make it usable more generally. There will certainly be pain points and lessons learned, but many of the limitations are fixable in principle and we need practice to find out what that is.</li>\n</ul>",
        "id": 262159462,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1637378804
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> awesome thank you for being so generous to explain that all so well! I'll definitely read all the papers you've published on the topic, and I'll keep all this in mind as I iterate myself. A tiny kernel to quickly verify verifiers absolutely seems very useful, I'm excited to dig in further :)</p>",
        "id": 262262138,
        "sender_full_name": "Blaine Hansen",
        "timestamp": 1637530843
    },
    {
        "content": "<p>I just want to add that unlike many other software projects, designing a proof language requires a lot of upfront work on paper. Before you starting writing code you should really define the syntax, semantics and typing</p>",
        "id": 262286256,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1637565886
    },
    {
        "content": "<p>and at least have a convincing sketch for a proof of soundness for your language.</p>",
        "id": 262286287,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1637565940
    }
]