[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> Hi. I've come across your PhD thesis and I am very impressed with it.  <br>\nI am thinking about starting a PhD in a similar area (formal methods in Rust ), what would you suggest to be a good topic do drill into?<br>\nMany thanks!</p>",
        "id": 231434370,
        "sender_full_name": "kentrixy",
        "timestamp": 1616487099
    },
    {
        "content": "<p>A big open problem would be \"compcert for rust.\" Compcert is a verified compiler for C in Coq.<br>\nAnother would be to verify the rust standard. Like what Robbert Krebbers' PhD-thesis for C.<br>\nUnfortunately, rust does not seem to be standardized enough.</p>\n<p>The conclusion of <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> 's paper is also interesting:<br>\n<a href=\"https://cacm.acm.org/magazines/2021/4/251364-safe-systems-programming-in-rust/fulltext\">https://cacm.acm.org/magazines/2021/4/251364-safe-systems-programming-in-rust/fulltext</a></p>\n<blockquote>\n<p>There is still much work left to do. Although RustBelt has recently been extended to account for the relaxed-memory concurrency model that Rust inherits from C++,9 there are a number of other Rust features and APIs that it does not yet cover, such as its \"trait\" system, which is complex enough to have been the source of subtle soundness bugs.7 Moreover, although verifying the soundness of an internally unsafe Rust library requires, at present, a deep background in formal semantics, we hope to eventually develop formal methods that can be put directly in the hands of programmers.</p>\n</blockquote>\n<blockquote>\n<p>Finally, while RustBelt has focused on building foundations for Rust itself, we are pleased to see other research projects (notably Prusti6 and RustHorn27) beginning to explore an exciting, orthogonal direction: namely, the potential for Rust's strong type system to serve as a powerful tool in simplifying the formal verification of systems code.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"312719\">@Xavier Denis</span> is making some progress in this direction, I think.</p>",
        "id": 231436087,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1616488160
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"382207\">Bas Spitters</span> <a href=\"#narrow/stream/183875-wg-formal-methods/topic/Research.20topic/near/231436087\">said</a>:</p>\n<blockquote>\n<p>A big open problem would be \"compcert for rust.\" Compcert is a verified compiler for C in Coq.<br>\nAnother would be to verify the rust standard. Like what Robbert Krebbers' PhD-thesis for C.<br>\nUnfortunately, rust does not seem to be standardized enough.</p>\n<p>The conclusion of <span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> 's paper is also interesting:<br>\n<a href=\"https://cacm.acm.org/magazines/2021/4/251364-safe-systems-programming-in-rust/fulltext\">https://cacm.acm.org/magazines/2021/4/251364-safe-systems-programming-in-rust/fulltext</a></p>\n<blockquote>\n<p>There is still much work left to do. Although RustBelt has recently been extended to account for the relaxed-memory concurrency model that Rust inherits from C++,9 there are a number of other Rust features and APIs that it does not yet cover, such as its \"trait\" system, which is complex enough to have been the source of subtle soundness bugs.7 Moreover, although verifying the soundness of an internally unsafe Rust library requires, at present, a deep background in formal semantics, we hope to eventually develop formal methods that can be put directly in the hands of programmers.</p>\n</blockquote>\n<blockquote>\n<p>Finally, while RustBelt has focused on building foundations for Rust itself, we are pleased to see other research projects (notably Prusti6 and RustHorn27) beginning to explore an exciting, orthogonal direction: namely, the potential for Rust's strong type system to serve as a powerful tool in simplifying the formal verification of systems code.</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"312719\">Xavier Denis</span> is making some progress in this direction, I think.</p>\n</blockquote>\n<p>Thanks. I know compcert  and it seems to be a quiet large effort for a PhD, but perhaps a subset of Rust might be a more reasonable target.</p>\n<p>So it looks like there are two possible tangents, one being formal verification on written rust code like Prusti and Rust+F* project I have come across a some time ago. And the other being building foundations for Rust and the compiler itself.</p>",
        "id": 231441613,
        "sender_full_name": "kentrixy",
        "timestamp": 1616491464
    },
    {
        "content": "<p>I don't think I've seen the rust+F* project.</p>\n<p>A concrete project could be combing vellvm2 with wasmcert Coq. I don't know how difficult that would be.</p>",
        "id": 231444310,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1616493065
    },
    {
        "content": "<p>An alternative to compcert would be to do proof preserving compilation. The idea would be basically to take Rust code with Prusti/Creusot/LiquidRust annotations and compile it to, for example, RISC-5 assembly, which–as far as I know–has formal semantics, while also lowering the specifications. This way the only thing that would need to be part of the trusted codebase would be the checker that verifies the proof on the assembly level.</p>",
        "id": 231447109,
        "sender_full_name": "Vytautas Astrauskas [he/him]",
        "timestamp": 1616494630
    },
    {
        "content": "<p>Once Cranelift gets a RISC-V backend, I think using it as backend would be useful for this.</p>",
        "id": 231447506,
        "sender_full_name": "bjorn3",
        "timestamp": 1616494849
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/183875-wg-formal-methods/topic/Research.20topic/near/231447506\">said</a>:</p>\n<blockquote>\n<p>Once Cranelift gets a RISC-V backend, I think using it as backend would be useful for this.</p>\n</blockquote>\n<p>Any plans for Cranelift to get a RISC-5 backend?</p>",
        "id": 231447592,
        "sender_full_name": "Vytautas Astrauskas [he/him]",
        "timestamp": 1616494900
    },
    {
        "content": "<p>The Cranelift's regalloc has a check mode and there is already an informal proof for another component: <a href=\"https://github.com/bytecodealliance/wasmtime/blob/2880dab8f81249138b66528294df09eff45a935b/cranelift/codegen/src/machinst/buffer.rs#L155-L1476\">https://github.com/bytecodealliance/wasmtime/blob/2880dab8f81249138b66528294df09eff45a935b/cranelift/codegen/src/machinst/buffer.rs#L155-L1476</a></p>",
        "id": 231447595,
        "sender_full_name": "bjorn3",
        "timestamp": 1616494901
    },
    {
        "content": "<p><a href=\"https://github.com/bytecodealliance/wasmtime/issues/2217\">https://github.com/bytecodealliance/wasmtime/issues/2217</a></p>",
        "id": 231447624,
        "sender_full_name": "bjorn3",
        "timestamp": 1616494920
    },
    {
        "content": "<p>Nobody is actively working on it as far as I know though.</p>",
        "id": 231447709,
        "sender_full_name": "bjorn3",
        "timestamp": 1616494954
    },
    {
        "content": "<p>Thanks for the update!</p>",
        "id": 231447736,
        "sender_full_name": "Vytautas Astrauskas [he/him]",
        "timestamp": 1616494979
    },
    {
        "content": "<p>Speaking of RISC-V. There's work on a verified compiler from bedrock2 to RISC-V. (Have a look at the IoT example!)<br>\n<a href=\"https://github.com/mit-plv/bedrock2\">https://github.com/mit-plv/bedrock2</a></p>\n<blockquote>\n<p>The source language is a \"C-like\" language called ExprImp. It is an imperative language with expressions. Currently, the only data type is word (32-bit or 64-bit), and the memory is a partial map from words to bytes. \"Records\" are supported as a notation for memory access with an offset.</p>\n</blockquote>\n<p>Making a formal connection between ExprImp and rust would be useful. I haven't looked closely enough at the differences.</p>",
        "id": 231457651,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1616500558
    },
    {
        "content": "<blockquote>\n<p>It is a design decision to not support the following features:</p>\n<ul>\n<li>Function pointers</li>\n<li>Recursive functions (we might add them later, but we always want to prove that we don't run out of stack space)</li>\n<li>Non-terminating programs (except for the top-level event loop)</li>\n</ul>\n</blockquote>",
        "id": 231458192,
        "sender_full_name": "bjorn3",
        "timestamp": 1616500867
    },
    {
        "content": "<p>In addition bedrock2 only supports storing words and not bytes in memory.</p>",
        "id": 231458350,
        "sender_full_name": "bjorn3",
        "timestamp": 1616500970
    },
    {
        "content": "<p>bedrock2 is definitively much smaller than rust, but it may be a start, or inspiration, for a compiler of a subset of rust.<br>\nAdam Chlipala is part of the risc-v committee, if I'm not mistaken.</p>",
        "id": 231460257,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1616502057
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"389506\">@kentrixy</span> by Rust + F* do you mean HACSPEC?</p>",
        "id": 231506498,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1616519098
    },
    {
        "content": "<p>The approach that Vytautas described seems like it would be more tractable in the constraints of a PhD program than a verified compiler in Coq</p>",
        "id": 231506795,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1616519189
    },
    {
        "content": "<p>While a certified compiler is important for extremely high assurance software, I'm more concerned with verifying the functional correctness of Rust code, I think there are more low hanging fruits there</p>",
        "id": 231507133,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1616519312
    },
    {
        "content": "<p>Of course any sort of certified compilation for Rust would be super cool!</p>",
        "id": 231507183,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1616519332
    },
    {
        "content": "<p>There are plenty Rust verification topics that no one has attempted yet, it really depends on what your interests are</p>",
        "id": 231507622,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1616519504
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"382207\">Bas Spitters</span> <a href=\"#narrow/stream/183875-wg-formal-methods/topic/Research.20topic/near/231444310\">said</a>:</p>\n<blockquote>\n<p>I don't think I've seen the rust+F* project.</p>\n<p>A concrete project could be combing vellvm2 with wasmcert Coq. I don't know how difficult that would be.</p>\n</blockquote>\n<p>It is this PhD topic <a href=\"https://blog.merigoux.fr/en/2019/04/16/textinput.html\">https://blog.merigoux.fr/en/2019/04/16/textinput.html</a></p>",
        "id": 231568712,
        "sender_full_name": "kentrixy",
        "timestamp": 1616548741
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312719\">Xavier Denis</span> <a href=\"#narrow/stream/183875-wg-formal-methods/topic/Research.20topic/near/231507133\">said</a>:</p>\n<blockquote>\n<p>While a certified compiler is important for extremely high assurance software, I'm more concerned with verifying the functional correctness of Rust code, I think there are more low hanging fruits there</p>\n</blockquote>\n<p>Do you mind elaborate on that a bit more? There has been a few projects around it but what are some examples of topic of interest?</p>\n<p>Thanks.</p>",
        "id": 231571101,
        "sender_full_name": "kentrixy",
        "timestamp": 1616550849
    },
    {
        "content": "<p>I have tried out Prusti and it seems like that are lot of unsupported Rust features.</p>",
        "id": 231571218,
        "sender_full_name": "kentrixy",
        "timestamp": 1616550964
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312719\">Xavier Denis</span> <a href=\"#narrow/stream/183875-wg-formal-methods/topic/Research.20topic/near/231506498\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"389506\">kentrixy</span> by Rust + F* do you mean HACSPEC?</p>\n</blockquote>\n<p>I believe you are the author of <a href=\"https://github.com/xldenis/creusot\">https://github.com/xldenis/creusot</a> <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span>  Very nice project/concept</p>",
        "id": 231573295,
        "sender_full_name": "kentrixy",
        "timestamp": 1616552760
    },
    {
        "content": "<p>Yep that's me! Plenty of work left to do :) If you're interested in Denis' work, check out: <a href=\"https://github.com/hacspec/hacspec\">https://github.com/hacspec/hacspec</a> which is the most recent iteration of this F* / Rust work. </p>\n<p>AS for your question: What I mean is that certifying compilation of Rust hunts down / eliminates <em>compiler</em> bugs, I'm more interested in hunting down bugs in the Rust code <em>itself</em>.</p>",
        "id": 231606244,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1616579214
    },
    {
        "content": "<p>There are plenty of topics to explore here, for example: unsafe code, traits, async. Within each of these you can go in the direction of formalizing those systems, ie: what RustBelt did for the type system, you can also look at verifying code involving those aspects, aka Prusti / Creusot / MIRAI. Both of these are important directions since for example, RustBelt helps provide the (theoretical) foundations on which we can build verification tools</p>",
        "id": 231606703,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1616579426
    },
    {
        "content": "<p>And though it may still be early for this, there are doubtlessly a bunch of theses that could be written on engineering a complex verified piece of Rust code (ie an OS kernel, etc...)</p>",
        "id": 231606809,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1616579496
    },
    {
        "content": "<p>It all depends on where you see yourself on the 'theory &lt;-&gt; implementation' spectrum and what your specific interests are</p>",
        "id": 231606929,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1616579581
    },
    {
        "content": "<p>On the hacspec slack there's more discussion about an INRIA project verifying the riot bootloader.</p>",
        "id": 231611958,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1616581935
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"389506\">kentrixy</span> <a href=\"#narrow/stream/183875-wg-formal-methods/topic/Research.20topic/near/231434370\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> Hi. I've come across your PhD thesis and I am very impressed with it.  <br>\nI am thinking about starting a PhD in a similar area (formal methods in Rust ), what would you suggest to be a good topic do drill into?<br>\nMany thanks!</p>\n</blockquote>\n<p>Thanks. :)<br>\nAs was already said by others in this thread, I think \"formal verification of functional correctness of Rust programs\" is a wide open space with lots of opportunities for interesting ideas -- and an important space, too. You mentioned Prusti and that is is fairly limited in features; that is certainly true and it'd be interesting to figure out how to do something Prusti-like for more of Rust (supporting at least <code>Vec::iter_mut</code> and maybe even more complicated borrowing patterns), or how to marry Prusti-like verification of safe code with (manual or automated) verification of unsafe code.</p>",
        "id": 231768718,
        "sender_full_name": "RalfJ",
        "timestamp": 1616664215
    },
    {
        "content": "<p>Another big one would be working towards a proper formal semantics for (a reasonable subset of) Rust itself -- ideally directly in terms of the surface language. Probably this is best done via elaboration to a smaller language, maybe something MIR-like.</p>",
        "id": 231769034,
        "sender_full_name": "RalfJ",
        "timestamp": 1616664374
    },
    {
        "content": "<p>Formalizing the trait system comes to my mind; this part of Rust has not been extensively studied formally so far and yet the entire language relies on coherence of the trait system. With upcoming extensions like specialization, it becomes harder and harder to ensure correctness and coherence of the trait system, so this would also be a good way to have direct impact on language development.</p>",
        "id": 231769152,
        "sender_full_name": "RalfJ",
        "timestamp": 1616664466
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/183875-wg-formal-methods/topic/Research.20topic/near/231769034\">said</a>:</p>\n<blockquote>\n<p>Another big one would be working towards a proper formal semantics for (a reasonable subset of) Rust itself -- ideally directly in terms of the surface language. Probably this is best done via elaboration to a smaller language, maybe something MIR-like.</p>\n</blockquote>\n<p>This is one of the goals of Ferrocene. I believe one could compare their goal to developing a rust standard, similar to the C-standard. <span class=\"user-mention\" data-user-id=\"228996\">@Sabree Blackmon</span> or  <span class=\"user-mention\" data-user-id=\"215333\">@Florian Gilcher</span> might want to chime in.<br>\n<a href=\"https://ferrous-systems.com/blog/ferrocene-update-three-the-road/\">https://ferrous-systems.com/blog/ferrocene-update-three-the-road/</a></p>",
        "id": 231770845,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1616665323
    },
    {
        "content": "<p>Yeah I know of Ferrocene. :) Though to me a \"proper formal spec\" implies having something machine-readable such as a Coq definition, which is usually out-of-scope for these kinds of standardization efforts and left to researchers. ;)</p>",
        "id": 231772703,
        "sender_full_name": "RalfJ",
        "timestamp": 1616666209
    },
    {
        "content": "<p>But Robbert could not have written his thesis without the C standard. He was always so happy with that telephone sized book on his desk :-) <br>\n<a href=\"https://robbertkrebbers.nl/thesis.html\">https://robbertkrebbers.nl/thesis.html</a></p>",
        "id": 231782002,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1616670735
    },
    {
        "content": "<p>I think Robbert would have suffered much less pain if the C standard was written with a proper formal spec in mind. ;)</p>",
        "id": 231782302,
        "sender_full_name": "RalfJ",
        "timestamp": 1616670896
    },
    {
        "content": "<p>Agreed. Hacspec is a good start, I hope one can build on that.<br>\nThe Concordium company is using rust for smart contracts. We're working on extraction from Coq to rust, and hopefully that subset of smart contracts could be specified.<br>\nE.g.<br>\n<a href=\"https://docs.rs/concordium-std/0.4.1/concordium_std/\">https://docs.rs/concordium-std/0.4.1/concordium_std/</a></p>",
        "id": 231783240,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1616671336
    },
    {
        "content": "<p>The WASM spec is an outstanding prose document which was clearly written \"with formalization in mind\". I wish more language specs were written like that one. I don't think formalization is strictly required to write a \"formalization in mind\" document that is about as precise, although it's even better if someone in the research community starts doing formalization while the spec is under construction so that small issues can be found while it's early enough to make changes easily.</p>",
        "id": 231785579,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616672602
    },
    {
        "content": "<p>Yeah, wasm is amazingly well-done.</p>",
        "id": 231785865,
        "sender_full_name": "RalfJ",
        "timestamp": 1616672730
    },
    {
        "content": "<p>However, specifying wasm is also orders of magnitude easier than specifying Rust. ;)</p>",
        "id": 231785900,
        "sender_full_name": "RalfJ",
        "timestamp": 1616672743
    },
    {
        "content": "<p>Well, the formalization was done almost simultaneously with the wasm document, and it is also referenced in the document. <span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> do we have a lean version of this already ;-) <br>\n<a href=\"https://github.com/WasmCert/WasmCert-Coq\">https://github.com/WasmCert/WasmCert-Coq</a></p>",
        "id": 231786121,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1616672829
    },
    {
        "content": "<p>Heh. I started porting CompCert a few years ago, but I eventually dropped it when the original client decided to do other things. C is just not a great language for formalization.<br>\n<a href=\"https://github.com/digama0/kremlin\">https://github.com/digama0/kremlin</a></p>",
        "id": 231786771,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616673137
    },
    {
        "content": "<p>Hoping that rust will be better...</p>",
        "id": 231787076,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1616673303
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312719\">Xavier Denis</span> <a href=\"#narrow/stream/183875-wg-formal-methods/topic/Research.20topic/near/231606929\">said</a>:</p>\n<blockquote>\n<p>It all depends on where you see yourself on the 'theory &lt;-&gt; implementation' spectrum and what your specific interests are</p>\n</blockquote>\n<p>thanks. My interest lies mostly in the \"implementation\" or practical part (I came from a SE background)</p>",
        "id": 231891598,
        "sender_full_name": "kentrixy",
        "timestamp": 1616714496
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/183875-wg-formal-methods/topic/Research.20topic/near/231769034\">said</a>:</p>\n<blockquote>\n<p>Another big one would be working towards a proper formal semantics for (a reasonable subset of) Rust itself -- ideally directly in terms of the surface language. Probably this is best done via elaboration to a smaller language, maybe something MIR-like.</p>\n</blockquote>\n<p>Thanks for the reply. Would you think something similar to the scope of \"stacked borrow\" part of your thesis would be suitable for a master thesis? I feel like that is something I am more interested in. i.e make a contribution to the compiler</p>",
        "id": 231922460,
        "sender_full_name": "kentrixy",
        "timestamp": 1616741905
    },
    {
        "content": "<p>Stacked Borrows would be a pretty good master thesis in my book, yeah. :D But note that there are formal proofs there, not \"just\" a compiler/Miri implementation.</p>",
        "id": 232013383,
        "sender_full_name": "RalfJ",
        "timestamp": 1616784002
    },
    {
        "content": "<p>but ultimately this is up to your thesis advisor</p>",
        "id": 232013432,
        "sender_full_name": "RalfJ",
        "timestamp": 1616784010
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/183875-wg-formal-methods/topic/Research.20topic/near/231769152\">said</a>:</p>\n<blockquote>\n<p>Formalizing the trait system comes to my mind; this part of Rust has not been extensively studied formally so far and yet the entire language relies on coherence of the trait system. With upcoming extensions like specialization, it becomes harder and harder to ensure correctness and coherence of the trait system, so this would also be a good way to have direct impact on language development.</p>\n</blockquote>\n<p>Can you elaborate on what \"correctness and coherence of the trait system\" mean? Is it something like proving that the orphan rules actually allow at most one impl?</p>",
        "id": 232249104,
        "sender_full_name": "pandaman",
        "timestamp": 1617015236
    },
    {
        "content": "<p>it also means ensuring that we can't write 'bad' instances that break the invariants of the Rust type system. If I recall correctly there was a problem with Pin where it was possible to write 'evil' impls which would do UB.</p>",
        "id": 232305052,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1617039082
    },
    {
        "content": "<p>I dont <em>think</em> that proving hte uniqueness of instances would be the hard part</p>",
        "id": 232305127,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1617039106
    },
    {
        "content": "<p>but then again specialization throws a wrinkle in that</p>",
        "id": 232305218,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1617039133
    },
    {
        "content": "<p>I think the hard part is just that there are so many moving parts and quite a lot of assumptions/requirements about how they need to fit together, none of which have been formally stated, much less proved</p>",
        "id": 232308677,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617040378
    },
    {
        "content": "<p>I would very much like to see a formal (or informal) specification of the complete rust type system</p>",
        "id": 232308758,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617040410
    },
    {
        "content": "<p>it's always bigger than you think at first</p>",
        "id": 232308783,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617040424
    },
    {
        "content": "<p>yep! i really think that writing down the rust trait system, how it chooses to resolve instances etc would be huge already</p>",
        "id": 232309812,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1617040840
    },
    {
        "content": "<p>and a huge amount of work</p>",
        "id": 232309825,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1617040844
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312719\">Xavier Denis</span> <a href=\"#narrow/stream/183875-wg-formal-methods/topic/Research.20topic/near/232305052\">said</a>:</p>\n<blockquote>\n<p>it also means ensuring that we can't write 'bad' instances that break the invariants of the Rust type system. If I recall correctly there was a problem with Pin where it was possible to write 'evil' impls which would do UB.</p>\n</blockquote>\n<p>this is \"hard mode\" where you don't just have to show coherence of the trait system but then have to find a way for unsafe code to <em>exploit</em> coherence of the trait system</p>",
        "id": 232921324,
        "sender_full_name": "RalfJ",
        "timestamp": 1617381821
    },
    {
        "content": "<blockquote>\n<p>Is it something like proving that the orphan rules actually allow at most one impl?</p>\n</blockquote>\n<p>That's the core of it, yes -- most trait system unsoundnesses boil down to coherence issues I think</p>",
        "id": 232921415,
        "sender_full_name": "RalfJ",
        "timestamp": 1617381851
    },
    {
        "content": "<p>Yea I figure there are some particular issues due to ‘fundamental’ types which could be interesting to reason about</p>",
        "id": 233080070,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1617541512
    },
    {
        "content": "<p>About formalizing the trait system, it would already be useful to do this for the hacspec subset of rust. Trait are used quite a bit in the cryptographic libraries. hacspec has a clear operational semantics.</p>",
        "id": 233776171,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1617951534
    },
    {
        "content": "<p>Regarding formalizing the trait system, it's worth pointing out that this work is already well underway in <a href=\"https://rust-lang.github.io/chalk/book/\">chalk</a> -- as well as an effort to put that formalization into practice as the basis for the compiler and rust-analyzer.</p>",
        "id": 235843772,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1619186008
    },
    {
        "content": "<p>That work is coordinated in <a class=\"stream\" data-stream-id=\"144729\" href=\"/#narrow/stream/144729-wg-traits\">#wg-traits</a></p>",
        "id": 235843824,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1619186036
    },
    {
        "content": "<p>Similarly, <a href=\"https://github.com/rust-lang/polonius/\">polonius</a> includes the basis for a formal specification of the borrow checker; that work is generally coordinated in <a class=\"stream\" data-stream-id=\"186049\" href=\"/#narrow/stream/186049-t-compiler.2Fwg-polonius\">#t-compiler/wg-polonius</a></p>",
        "id": 235843895,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1619186059
    },
    {
        "content": "<p>I think what would be interesting, besides pursuing and elaborating those projects, is trying to stitch them together with a formalization of the <a href=\"https://github.com/rust-lang/rust/blob/master/compiler/rustc_mir/src/borrow_check/type_check/mod.rs\">MIR type checker</a>, which would then be a complete type system for MIR.</p>",
        "id": 235844031,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1619186113
    },
    {
        "content": "<p>I don't think it's worth even thinking about a formal spec or type system for surface rust syntax at this stage.</p>",
        "id": 235844074,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1619186128
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> Is there an overview of the difference between the MIR type checker and rustbelt?</p>",
        "id": 235852049,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1619188994
    },
    {
        "content": "<p>The MIR type checker can't be used to do any formal verification. It only checks if the program is well-typed. It doesn't check that the program doesn't panic or contains functions with <code>unsafe</code> blocks that are unsound.</p>",
        "id": 235857451,
        "sender_full_name": "bjorn3",
        "timestamp": 1619190605
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"382207\">Bas Spitters</span> <a href=\"#narrow/stream/183875-wg-formal-methods/topic/Research.20topic/near/235852049\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> Is there an overview of the difference between the MIR type checker and rustbelt?</p>\n</blockquote>\n<p>I don't think we have a list. In terms of borrow checking, RustBelt's typing rules were defined before NLL was solidified so it is more \"inspired by\" the real thing than closely modeling it. the main differences I am aware of are</p>\n<ul>\n<li>RustBelt doesn't have two-phase borrows</li>\n<li>RustBelt doesn't support code that reads from a <code>&amp;mut</code> with an outstanding shared loan (I simply was not aware that rustc allows this^^)</li>\n</ul>\n<p>Outside borrow checking and traits there's not a lot happening that is very interesting, is it? RustBelt does \"move tracking\" in linear type system style; I am not sure if whatever strategy rustc uses has been formalized.</p>",
        "id": 235857848,
        "sender_full_name": "RalfJ",
        "timestamp": 1619190704
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/183875-wg-formal-methods/topic/Research.20topic/near/235857451\">said</a>:</p>\n<blockquote>\n<p>The MIR type checker can't be used to do any formal verification. It only checks if the program is well-typed. It doesn't check that the program doesn't panic or contains functions with <code>unsafe</code> blocks that are unsound.</p>\n</blockquote>\n<p>well-typed is still a very interesting property.^^</p>",
        "id": 235857997,
        "sender_full_name": "RalfJ",
        "timestamp": 1619190734
    },
    {
        "content": "<p>I think that there are three parts to formalizing Rust traits:<br>\n1) What does the trait part of the typesystem mean: what is allowed, what is not allowed, how is the instance selected, is it coherent, etc.<br>\n2) What are the properties of a given trait.<br>\n    eg a formal statement of what a FusedIterator is required to do.<br>\n    (I was going to give examples involving whether Add and Mul are commutative, associative and distributive - but the answer would sadly have to be \"no\")<br>\n3) Proving that instances actually satisfy any properties that they are meant to satisfy.</p>",
        "id": 235858123,
        "sender_full_name": "Alastair Reid",
        "timestamp": 1619190768
    },
    {
        "content": "<p>A few things that come to mind: drop checking, more primitives (async/yield?), intrinsics / \"boring\" things that make the difference between production compiler and research MVP</p>",
        "id": 235858944,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619190903
    },
    {
        "content": "<p>I would assume that for an actual mir typechecker you need all the boring things</p>",
        "id": 235859083,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619190936
    },
    {
        "content": "<p>I don't have a good sense of how the type system and traits differ between surface rust and MIR</p>",
        "id": 235859298,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619190982
    },
    {
        "content": "<p>I don't think there is any difference for the type system itself.</p>",
        "id": 235859461,
        "sender_full_name": "bjorn3",
        "timestamp": 1619191052
    },
    {
        "content": "<p>The fact that traits can contain associated types, that traits and wellformedness can appear inductively and coinductively in chalk suggests that the actual semantic model for traits might be quite subtle; it seems like it brushes up against some inconsistent logical systems</p>",
        "id": 235859738,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619191164
    },
    {
        "content": "<p>Oh, const eval is another big missing part of formalizing the type system. This is still evolving, but min_const_generics is already stable</p>",
        "id": 235860100,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619191312
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> Your list of boring things includes intrinsics. It turns out that these are equally necessary and equally boring for verification tools, static analysis tools, etc. And, in the case of SIMD intrinsics, it is relatively easy (but fairly tedious) to write an emulation library that implements all of the SIMD intrinsics needed.<br>\nI have done this for use with KLEE (code: <a href=\"https://github.com/project-oak/rust-verification-tools/tree/main/simd_emulation\">https://github.com/project-oak/rust-verification-tools/tree/main/simd_emulation</a>) and the code should be usable by other tools. For my usage, it turns out that I only need a small number of intrinsics because I go via LLVM and LLVM is able to lower most of the SIMD intrinsics that are not processor specific. More would probably be needed to support tools that work at the MIR level.<br>\nI'm happy to help if others want to work on a shared SIMD emulation library - to make it work with more tools, to add tests, to increase the number of intrinsics, etc.</p>",
        "id": 235860983,
        "sender_full_name": "Alastair Reid",
        "timestamp": 1619191655
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"336739\">Alastair Reid</span> <a href=\"#narrow/stream/183875-wg-formal-methods/topic/Research.20topic/near/235858123\">said</a>:</p>\n<blockquote>\n<p>2) What are the properties of a given trait.<br>\n    eg a formal statement of what a FusedIterator is required to do.<br>\n    (I was going to give examples involving whether Add and Mul are commutative, associative and distributive - but the answer would sadly have to be \"no\")</p>\n</blockquote>\n<p>This is an interesting item to include. If the trait is not declared <code>unsafe</code>, I don't think it should be required -- or perhaps it's a question of having distinct goals in mind.</p>",
        "id": 235920743,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1619218680
    },
    {
        "content": "<p>If the goal is proving functional correctness, and you are relying on impls proving that they implement some protocol defined by the trait, than it makes sense. It may suggest either having a distinct kind of \"trait proof\" (one that considers a subset of impls that are themselves proven to meet defined bounds) or other interesting criteria.</p>",
        "id": 235920898,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1619218767
    },
    {
        "content": "<p>I guess we could imagine generalizing <code>unsafe</code> to \"something impls must prove to be legal\"</p>",
        "id": 235920908,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1619218782
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"336739\">Alastair Reid</span> <a href=\"#narrow/stream/183875-wg-formal-methods/topic/Research.20topic/near/235858123\">said</a>:</p>\n<blockquote>\n<p>1) What does the trait part of the typesystem mean: what is allowed, what is not allowed, how is the instance selected, is it coherent, etc.</p>\n</blockquote>\n<p>This is what chalk is focused on.</p>",
        "id": 235920983,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1619218814
    },
    {
        "content": "<blockquote>\n<p>This is an interesting item to include. If the trait is not declared unsafe, I don't think it should be required -- or perhaps it's a question of having distinct goals in mind.</p>\n</blockquote>\n<p>even for safe traits, such contracts will be relevant when verifying functional correctness<br>\n(as you said later)</p>",
        "id": 235958887,
        "sender_full_name": "RalfJ",
        "timestamp": 1619258769
    },
    {
        "content": "<p>(yes, agreed)</p>",
        "id": 235967055,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1619267695
    },
    {
        "content": "<p>Incidentally, I've just started a project to learn rust, and it happens to be a design for traits for describing the properties of add, mul, etc: <a href=\"https://github.com/mdgeorge4153/rusted-roots\">https://github.com/mdgeorge4153/rusted-roots</a>.  It might be a good test case for traits for functional correctness</p>\n<p>It's not very complete or well written, really just a sketch while I'm learning my way around rust</p>",
        "id": 236079352,
        "sender_full_name": "Michael George",
        "timestamp": 1619370477
    }
]