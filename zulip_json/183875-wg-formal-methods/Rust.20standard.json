[
    {
        "content": "<p>Let me repeat a question from the hacspec zulip here. I understand that is no rust analogue of the C-standard. The hacspec semantics is \"obviously correct\", but how to evaluate this statement?<br>\nTo put it very crudely, what prevents the compiler team from evaluating 2+2 to 5 ? <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> <span class=\"user-mention\" data-user-id=\"228996\">@Sabree Blackmon</span> might want to chime in.<br>\nI'm aware of Ferrocene, but the latest blog post seems to be from February <a href=\"https://ferrous-systems.com/blog/ferrocene-update-three-the-road/\">https://ferrous-systems.com/blog/ferrocene-update-three-the-road/</a></p>",
        "id": 256855938,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1633771965
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> Any insights?</p>",
        "id": 257054701,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1633954222
    },
    {
        "content": "<blockquote>\n<p>To put it very crudely, what prevents the compiler team from evaluating 2+2 to 5 ?</p>\n</blockquote>\n<p>(what prevents the authors of the C standard from defining 2+2 = 5 in the next version of the standard?)</p>",
        "id": 257055658,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1633954765
    },
    {
        "content": "<p>Good question. I believe this is the reason Ferrocene wants to have clear versioning. With a version of a specifcation of the language corresponding to each release of the language.<br>\nWASM does the same. See the Change history in v1.1 of their <a href=\"https://webassembly.github.io/spec/core/_download/WebAssembly.pdf\">specification</a></p>\n<p>Oxide makes good progress on specifying a substantial part of the language, and extensively tests their work to the rust test suite. They don't have an interpreter yet, but it would be interesting to test that with the interpreter of hacspec.<br>\n<a href=\"https://github.com/aatxe/oxide\">https://github.com/aatxe/oxide</a></p>",
        "id": 257058290,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1633956104
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"129457\">@Florian Diebold</span> I hope I phrased it more clearly here<br>\n<a href=\"https://github.com/rust-lang/lang-team/issues/123\">https://github.com/rust-lang/lang-team/issues/123</a></p>",
        "id": 257101076,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1633977062
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"382207\">@Bas Spitters</span> There is currently no Rust standard, that is correct. I am personally quite interested in seeing the development of an official \"type system + operational semantics\" for MIR</p>",
        "id": 257124890,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1633992001
    },
    {
        "content": "<p>I think that is a useful and practical step</p>",
        "id": 257124934,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1633992012
    },
    {
        "content": "<p>I don't think that trying to create a specification along the lines of the C standard for Rust is the best investment of time</p>",
        "id": 257124956,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1633992035
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/183875-wg-formal-methods/topic/Rust.20standard/near/257124890\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"382207\">Bas Spitters</span> There is currently no Rust standard, that is correct. I am personally quite interested in seeing the development of an official \"type system + operational semantics\" for MIR</p>\n</blockquote>\n<p>I have been considering helping to drive this over the next year or so as a \"next focus\" for myself -- if so, I would expect to be working quite a lot with the folks on this stream in getting feedback on that!</p>",
        "id": 257125018,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1633992103
    },
    {
        "content": "<p>Should there be a working group for this? The initial steps of taking something like Oxide or RustBelt and expanding the type system to include everything in <code>Ty&lt;'ctx&gt;</code> seem clear enough</p>",
        "id": 257137559,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634002726
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> That's one reason we restarted <a href=\"https://rust-formal-methods.github.io/\">https://rust-formal-methods.github.io/</a> . One can have a smaller subgroup just focusing on  \"type system + operational semantics\" for MIR, of course.</p>",
        "id": 257162208,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1634024727
    },
    {
        "content": "<p>I think it is worth actually starting a draft of something with the aspirations of eventually being part of a rust spec. As far as I know, there is nothing currently in this category except the rust reference and, to some extent, the UCG document. Assuming that we are working outward from the MIR core language, the draft need not be a formal document in the sense of being executable Coq code or something, and to some extent I think that will slow the progress by gatekeeping folks who don't have a strong formal methods background. Rather, I see the role of formal methods experts as auditing and shaping the progression of a precise prose spec so that it remains obviously formalizable, possibly by working out a formal document on the side. I see the WASM spec as a great example of this kind of work.</p>",
        "id": 257163030,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634025229
    },
    {
        "content": "<p>The rust-formal-methods web page is basically empty at the moment, which is understandable since it has just started, but the name of the WG makes it sound like it will be focused on tools for doing formal methods on rust code, which is only tangentially related to the existence of a formal spec, so I would guess that if one starts building a formal spec there then it would be somewhat off topic</p>",
        "id": 257163619,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634025542
    },
    {
        "content": "<p>I agree the wasm spec is great.<br>\nWithout a spec all FM is build on quicksand. I also have in mind a similar informal text/formal code collaboration you mention.</p>\n<p>Yes, the page is a start to bringing people together. PRs are welcome :-)</p>",
        "id": 257164370,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1634025924
    },
    {
        "content": "<blockquote>\n<p>I don't think that trying to create a specification along the lines of the C standard for Rust is the best investment of time</p>\n</blockquote>\n<p>If there is specification work that happens I actually <em>do</em> think it should start with something like the C spec, hopefully better informed from the start to avoid some of the complexities of that document.  I don't think trying to come up with a list of formal semantics judgements is helpful until then. </p>\n<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/183875-wg-formal-methods/topic/Rust.20standard/near/257137559\">said</a>:</p>\n<blockquote>\n<p>Should there be a working group for this? The initial steps of taking something like Oxide or RustBelt and expanding the type system to include everything in <code>Ty&lt;'ctx&gt;</code> seem clear enough</p>\n</blockquote>\n<p>A big issue is that both of these tools are models. Of the two, RustBelt is the only finished one, I don't know what state Oxide is in currently, I heard there was a revised paper in submission... RustBelt's lambda-rust is different from MIR in (many) key ways, bringing it inline would probably mean effectively starting over, but even more: there are whole areas of the type system that are still big question marks ie: trait objects. </p>\n<p>And if we want to specify the type system of rust the situation is trickier: I'm not sure anyone has written down the rules of trait resolution in Rust, and type checking and borrow checking are tangled together, thus defining typing for source rust means discussing its translation to MIR.</p>\n<p>If this is going to be a thing, it will be a huge amount of work and I think would <em>clearly</em> merit an official WG and wide community involvement. It's going to need people who are experts on each part of the language to share their understanding of how things work (and how they should). Long term, this also means changing the RFC process so that RFCs ensure the specification is updated appropriately (but that means we've gotten a spec)</p>",
        "id": 257172329,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1634030134
    },
    {
        "content": "<blockquote>\n<p>If this is going to be a thing, it will be a huge amount of work and I think would clearly merit an official WG and wide community involvement. </p>\n</blockquote>\n<p>Agree 100%. This is a large project, but a journey of a thousand miles begins with a single step, and that step is setting up a WG with this in its charter.</p>\n<blockquote>\n<p>A big issue is that both of these tools are models. Of the two, RustBelt is the only finished one, I don't know what state Oxide is in currently, I heard there was a revised paper in submission... RustBelt's lambda-rust is different from MIR in (many) key ways, bringing it inline would probably mean effectively starting over, but even more: there are whole areas of the type system that are still big question marks ie: trait objects. </p>\n</blockquote>\n<p>I think the best way to crystallize this problem is to actually write a naive-ish extension of RustBelt to all of Rust, put <code>???</code> in the appropriate places, and open issues to track resolution. So far there isn't even really a venue to discuss the problem.</p>",
        "id": 257187614,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634038554
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/183875-wg-formal-methods/topic/Rust.20standard/near/257124890\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"382207\">Bas Spitters</span> There is currently no Rust standard, that is correct. I am personally quite interested in seeing the development of an official \"type system + operational semantics\" for MIR</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> Which MIR do you have in mind? <code>optimized_mir</code>? I think that we can define the operational semantics without lifetimes (for example, by using something like Stacked Borrows). However, if we want to bridge that with the type system, which fundamentally depends on lifetimes, we probably need to have MIR with sufficient lifetime information available in it and, as far as I know, <code>optimized_mir</code> does not have it.</p>",
        "id": 257189206,
        "sender_full_name": "Vytautas Astrauskas [he/him]",
        "timestamp": 1634039302
    },
    {
        "content": "<p>Although the operational semantics does not have lifetimes, the type system should determine the preconditions of the function, with lifetimes mapping to relations on the borrow stacks</p>",
        "id": 257189466,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634039457
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/183875-wg-formal-methods/topic/Rust.20standard/near/257187614\">said</a>:</p>\n<blockquote>\n<p>I think the best way to crystallize this problem is to actually write a naive-ish extension of RustBelt to all of Rust, put <code>???</code> in the appropriate places, and open issues to track resolution. So far there isn't even really a venue to discuss the problem.</p>\n</blockquote>\n<p>I guess what I meant is that we're better off forgetting about Coq for the moment (and the next bunch of moments). A mechanization of all of Rust will follow a paper description.</p>",
        "id": 257191930,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1634040767
    },
    {
        "content": "<p>The operational semantics must not depend on lifetimes even if they are available. Unsafe code is allowed to temporarily lie about lifetimes and for example use 'static everywhere.</p>",
        "id": 257241282,
        "sender_full_name": "bjorn3",
        "timestamp": 1634059876
    },
    {
        "content": "<p>Lifetimed only matter for borrowck. The typechecker can also check lifetime constraints, but also needs to work with lifetimes erased. In fact MIR borrowck erases most lifetimes and then uses MIR typeck to get the lifetime constraints on fresh lifetimes I believe.</p>",
        "id": 257241558,
        "sender_full_name": "bjorn3",
        "timestamp": 1634059991
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/183875-wg-formal-methods/topic/Rust.20standard/near/257241558\">said</a>:</p>\n<blockquote>\n<p>Lifetimed only matter for borrowck. The typechecker can also check lifetime constraints, but also needs to work with lifetimes erased. In fact MIR borrowck erases most lifetimes and then uses MIR typeck to get the lifetime constraints on fresh lifetimes I believe.</p>\n</blockquote>\n<p>Let me try to rephrase what I wanted to say in a hopefully clearer way: there are multiple MIRs and I think we need to decide which one of them we are going to use for defining semantics. One option would be to use <code>optimized_mir</code>, which is <a href=\"https://doc.rust-lang.org/nightly/nightly-rustc/src/rustc_middle/ty/mod.rs.html#1874-1875\">used by Miri</a> (via <a href=\"https://doc.rust-lang.org/nightly/nightly-rustc/src/rustc_const_eval/interpret/machine.rs.html#146\"><code>load_mir</code></a>) and, therefore, feels for me like a natural target for defining operational semantics. However, the MIR type checker runs on a different MIR and if we want to relate type-checking with operational semantics, we need to resolve this somehow.</p>",
        "id": 257248094,
        "sender_full_name": "Vytautas Astrauskas [he/him]",
        "timestamp": 1634062575
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"382207\">Bas Spitters</span> <a href=\"#narrow/stream/183875-wg-formal-methods/topic/Rust.20standard/near/257054701\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> Any insights?</p>\n</blockquote>\n<p>certainly lots of thoughts^^ if only I could just make a copy of the stuff in my brain and share it with y'all... but sadly the bandwidth from my brain to the outside world is limited and that connection is highly congested with other things like being on various PCs and applying for faculty jobs and moving to Boston and being pinged on too many Rust issues and whatnot. :/  Some day I will have a week or at least a few days I can devote to bringing my thoughts on a spec for MIR operational semantics into markdown format and then I will be eager for everyone's feedback. A few months ago I told some people \"some time this year\", but I also thoroughly underestimated how much this move would disrupt me.</p>",
        "id": 257302092,
        "sender_full_name": "RalfJ",
        "timestamp": 1634093233
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116109\">@Vytautas Astrauskas [he/him]</span> I think thatâ€™s orthogonal to the question of the semantics. The semantics of MIR will be independent of whatever form rust programs take. However, for the purposes of defining type checking it might be expedient to add a few ghost instructions to MIR which relate to lifetimes/regions. However their semantics would be nop.</p>",
        "id": 257320162,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1634108565
    },
    {
        "content": "<p>The questions (to me) seem to revolve around things like concurrency, trait objects, etc..</p>",
        "id": 257320342,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1634108698
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> Good luck on the move.<br>\n<span class=\"user-mention\" data-user-id=\"116109\">@Vytautas Astrauskas [he/him]</span> Agreeing on which MIR to specify would already be progress. <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> What would be your preference? Also, what's the status of oxide?</p>",
        "id": 257334881,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1634116713
    },
    {
        "content": "<p>If one takes the name seriously, it's a bit dicey to be using \"optimized MIR\" to define semantics, because then the \"optimizations\" are ungrounded. But lifetime erased MIR seems like a reasonable substitute, since that's the relevant difference here</p>",
        "id": 257337710,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634118094
    },
    {
        "content": "<p>It should also be possible to pull this back to an operational semantics on lifetime annotated MIR, defined by just ignoring any lifetimes during execution. So that should be enough to provide a basis for the whole set of mir-opt passes.</p>",
        "id": 257338254,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634118390
    },
    {
        "content": "<p>Pushing the op.sem even farther back, to post type annotated HIR or so, would be even better, again defined by pullback so that MIR build is correct by construction. In order to keep the number of productions small though I believe it suffices to specify how HIR is turned into MIR and only present an actual op.sem on MIR. (My impression is that this is why <span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> was interested in starting the specification at the MIR level, because it is simpler than the languages it derives from.)</p>",
        "id": 257338445,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634118483
    },
    {
        "content": "<p>there are multiple MIR dialects, but they are actually not <em>that</em> different -- I think drop elaboration is the only major shift, other than that the op.sem should be the same everywhere I think. Also see <a href=\"https://github.com/rust-lang/rust/issues/86299\">https://github.com/rust-lang/rust/issues/86299</a>.</p>",
        "id": 257387994,
        "sender_full_name": "RalfJ",
        "timestamp": 1634139895
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/183875-wg-formal-methods/topic/Rust.20standard/near/257337710\">said</a>:</p>\n<blockquote>\n<p>If one takes the name seriously, it's a bit dicey to be using \"optimized MIR\" to define semantics, because then the \"optimizations\" are ungrounded. But lifetime erased MIR seems like a reasonable substitute, since that's the relevant difference here</p>\n</blockquote>\n<p>isnt the question more that we need to define the semantics of optimized MIR (rather than using optimized MIR to define the semantics of anything)?<br>\nalso, lifetime erasure should not change the semantics.</p>",
        "id": 257388153,
        "sender_full_name": "RalfJ",
        "timestamp": 1634139957
    },
    {
        "content": "<blockquote>\n<p>isnt the question more that we need to define the semantics of optimized MIR (rather than using optimized MIR to define the semantics of anything)?</p>\n</blockquote>\n<p>Well, we need to do both. We need to pick some core language <code>M</code>, such that <code>M</code> has a direct operational semantics on it, and every higher level language <code>H</code> earlier in the pipeline than <code>M</code> has its translation to <code>M</code> specified by some function <code>f : H -&gt; M</code>. The meaning of a program <code>x</code> in <code>H</code> is defined to be the meaning of <code>f(x)</code>, which is in turn defined via the op.sem on <code>M</code>.</p>\n<p>If we take <code>M</code> to be optimized MIR, then that means that pre-optimized MIR would play the role of <code>H</code> here, which means we have to specify the optimizations and I think we don't want to do that. We can take <code>M</code> to be any/all of the MIR dialects however, which gives independent operational semantics to the before and after for mir-opt, meaning that correctness of the optimization becomes a theorem rather than a definition (which is a good thing).</p>\n<blockquote>\n<p>also, lifetime erasure should not change the semantics.</p>\n</blockquote>\n<p>How would you explain the role of the type system and lifetimes in the specification of the abstract machine? Does the machine use a type system at all, or perhaps a weak type system with layouts but no lifetimes?</p>",
        "id": 257393615,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634141820
    },
    {
        "content": "<blockquote>\n<p>If we take M to be optimized MIR</p>\n</blockquote>\n<p>Definitely not. As you said, that would make the optimizations part of the spec!</p>",
        "id": 258406704,
        "sender_full_name": "RalfJ",
        "timestamp": 1634750175
    },
    {
        "content": "<blockquote>\n<p>Does the machine use a type system at all, or perhaps a weak type system with layouts but no lifetimes?</p>\n</blockquote>\n<p>Yeah, that -- the machine cares about types for data layout and validity invariants, but no more than that.</p>",
        "id": 258406860,
        "sender_full_name": "RalfJ",
        "timestamp": 1634750234
    },
    {
        "content": "<p>Is it possible to describe this type system ab initio, rather than \"<code>Ty</code> but without lifetimes\"? Is there anything more than lifetime erasure that happens to turn <code>Ty</code> into the R-AM type system?</p>",
        "id": 258450730,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634766987
    },
    {
        "content": "<p>Because that type system seems like a good place to start</p>",
        "id": 258450766,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634767008
    },
    {
        "content": "<p>(Perhaps \"classification of validity invariants\" is more accurate than \"type system\" here, since it barely qualifies as a type system)</p>",
        "id": 258450950,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634767098
    },
    {
        "content": "<p>Here are some other things that make the MIR type system different from just type erasure:</p>\n<ul>\n<li>Pointers are untyped, i.e. all (sized) <code>*const T</code> and <code>*mut T</code> collapse to a single type</li>\n<li>References are also untyped (aka shallow), but I think are a different type from pointers since they are nonnull</li>\n<li>Most major type categories in <code>Ty</code> retain their distinctions, including in particular structs and enums as well as \"internal\" types like generators, trait objects and closures</li>\n</ul>\n<p>That's already making some claims that might go beyond what UCG has established. For example this implies that <code>&amp;!</code> and <code>*const !</code> are valid to inhabit as long as you don't dereference them, and <code>*const dyn Trait</code> must have a valid vtable pointer. Obviously it requires some tweaking and discussion (hopefully of bounded length), but a description roughly along these lines will answer a lot of open questions about MIR.</p>",
        "id": 258452392,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634767831
    },
    {
        "content": "<p>I think it's important to distinguish the MIR type system from the abstract machine's 'type system'</p>",
        "id": 258495343,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1634798596
    },
    {
        "content": "<p>the mir type system <em>does</em> care about borrows, we want to be able to write the rules of the borrow checker on it</p>",
        "id": 258495365,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1634798618
    },
    {
        "content": "<p>on the other hand the machine only cares about things like type sizes: we just need to know how many bytes are in <code>_1</code> when we do <code>*_blah</code></p>",
        "id": 258495425,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1634798649
    },
    {
        "content": "<p>I <em>think</em> we can't easily get around needing the size of types but maybe we can even define it in a fully type agnostic way</p>",
        "id": 258495601,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1634798797
    },
    {
        "content": "<p>and then we want to (be able to) show that a well-typed MIR program never blocks in the machine (type soundness)</p>",
        "id": 258495638,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1634798842
    },
    {
        "content": "<p>The part that is confusing me is: in what sense is the MIR type system actually a part of the specification then? Proving type soundness is all well and good, but it's somewhat unrelated to what Rust actually does, since unsafe code can go outside the constraints of the type system (not just temporarily, literally \"breaking the rules\" like storing a <code>&amp;'a str</code> to a local variable in a <code>&amp;'static str</code> field) and we still call such programs well defined. Even \"semantic soundness\" in the sense used by RustBelt (which can be used to validate unsafe functions with a safe contract) is not a requirement for valid rust code.</p>\n<p>Somehow, this is operating at another level, which could be called the \"best practices\" for putting <code>unsafe</code> on things. But you can completely lie about the unsafety of everything and the program does not become UB as a result, so this suggests that <code>unsafe</code> is \"just a lint\". That's basically another way of saying that the R-AM does not use safety invariants.</p>\n<p>But Rust certainly does have a type system; users get type inference and lifetime elision and calling a function with the wrong lifetimes is caught by the borrow checker. All of this has to be part of the specification, and maybe MIR is the right level to do it. This is fundamentally a static analysis of the code, so it can't literally be specified in terms of potential executions even though we would like to think of it that way. In particular, I don't know whether we should try to specify exactly NLL / Polonius as implemented, or try to be vague and say that they implement some correct static approximation of dynamic correctness (i.e. not using a value after it is dropped, generalized over all possible executions of the code).</p>",
        "id": 258501436,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634802380
    },
    {
        "content": "<p>I think there are two different issues at play here: the first is specifying the semantics of MIR given a specific program syntax what result do we get</p>",
        "id": 258547686,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1634823953
    },
    {
        "content": "<p>the second is specifying what syntaxes are valid and what we want to guarantee about them (no ub for safe code)</p>",
        "id": 258547779,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1634823980
    },
    {
        "content": "<p>the <em>semantics</em> of mir should be (imo) type independent beyond the layout of types, the purpose is just to define the result of any given mir program and that can potentially include 'stuck / ub'</p>",
        "id": 258547938,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1634824055
    },
    {
        "content": "<p>then using that we can define the type system of MIR which I think we should definitely do, MIR is the defacto public interface of rust for tools / backends</p>",
        "id": 258548133,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1634824113
    },
    {
        "content": "<p>Validity invariants like nonnull references have to be in the R-AM semantics too because they are given to LLVM. It's not just layout</p>",
        "id": 258548446,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634824217
    },
    {
        "content": "<p>sure, I think you get the point, the machine only cares about... machine things</p>",
        "id": 258548533,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1634824250
    },
    {
        "content": "<p>sure</p>",
        "id": 258548548,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634824256
    },
    {
        "content": "<p>but then using that we can define properties that all rust programs must satisfy</p>",
        "id": 258548575,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1634824269
    },
    {
        "content": "<p>I think we agree here. I would really like to see what a semantic definition of types looks like though</p>",
        "id": 258548608,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634824282
    },
    {
        "content": "<p>like: forall programs P (safe and unsafe) the machine must never reach a UB state</p>",
        "id": 258548641,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1634824287
    },
    {
        "content": "<p>how we define type soundness will be interesting as well</p>",
        "id": 258548796,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1634824330
    },
    {
        "content": "<p>would types be defined so as to make type soundness a tautology?</p>",
        "id": 258548855,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634824353
    },
    {
        "content": "<p>not sure I follow</p>",
        "id": 258548881,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1634824366
    },
    {
        "content": "<p>as you've remarked RustBelt uses a rather advanced technique of semantic typing which captures the notion of unsafe abstraction</p>",
        "id": 258548893,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1634824371
    },
    {
        "content": "<p>we can definitely design the syntactic typing rules for MIR, but that still leaves the question of unsafe code</p>",
        "id": 258549021,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1634824429
    },
    {
        "content": "<p>and without a clean answer to that we can't hope to state a useful type soundness theorem for mir</p>",
        "id": 258549099,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1634824449
    },
    {
        "content": "<p>idk, what the answer here is, I haven't really thought about this problem in depth</p>",
        "id": 258549169,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1634824486
    },
    {
        "content": "<p>If the types are semantic types, then it's possible that type soundness is true by definition (i.e. we say that a function has type T -&gt; U if it doesn't cause UB and produces a U from a T). In that case the meat of the type soundness theorem is transferred to showing that the syntactic constructs are well typed</p>",
        "id": 258549443,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634824584
    },
    {
        "content": "<p>I think this roughly accords with the RustBelt approach</p>",
        "id": 258549600,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634824649
    },
    {
        "content": "<p>Anyway, I didn't mean to rant too much on this thread. I just want us to get the ball rolling</p>",
        "id": 258549737,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634824697
    },
    {
        "content": "<p>Yes but I don't know if that's how we want to define the <em>official</em> typesystem of MIR as that effectively means that only POPL attendees will understand it</p>",
        "id": 258550251,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1634824872
    },
    {
        "content": "<p>we want a simple, powerful, easy to explain, flexible, sound and concise type-system should be easy right?</p>",
        "id": 258550385,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1634824922
    },
    {
        "content": "<blockquote>\n<p>that effectively means that only POPL attendees will understand it</p>\n</blockquote>\n<p>Honestly, avoiding this situation is not a high priority IMO. Getting it right should come first, making it easy to understand can be done after the fact. The borrow checker has followed roughly this trajectory, so I don't think it's a misguided approach.</p>",
        "id": 258550813,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634825056
    },
    {
        "content": "<p>Also, the C++ standard is not particularly easy to understand either. Maybe that's a poor comparison, but Rust is likely to be about as complicated (in very different directions, of course)</p>",
        "id": 258550987,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634825114
    },
    {
        "content": "<p>There is another issue with the syntax/semantics definition of types: What if Rust is unsound? This is true at the moment and likely to be true for the forseeable future, but it puts the spec in an uncomfortable position because it probably wants to set things up in such a way as to make soundness a theorem, so there is going to be some part of rustc that differs from the spec</p>",
        "id": 258551616,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634825323
    },
    {
        "content": "<p>well its one thing if rustc deviates from the spec and causes unsoundness</p>",
        "id": 258551756,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1634825382
    },
    {
        "content": "<p>its another thing if the <em>spec</em> is unsound</p>",
        "id": 258551768,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1634825388
    },
    {
        "content": "<p>i know it's naive of me but I would like it if the rust language, on paper has actual metatheoretical properties</p>",
        "id": 258551923,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1634825439
    },
    {
        "content": "<p>I think there are at least a few issues which venture into \"the spec is unsound\" territory. One of the oldest I-unsound issues is about hash collisions, I don't see how to make that sound</p>",
        "id": 258551960,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634825455
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/issues/10389\">https://github.com/rust-lang/rust/issues/10389</a> ?</p>",
        "id": 258552499,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1634825650
    }
]