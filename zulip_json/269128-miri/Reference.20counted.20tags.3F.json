[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> per your suggestion <a href=\"https://github.com/rust-lang/miri/pull/2030#issuecomment-1070920868\">https://github.com/rust-lang/miri/pull/2030#issuecomment-1070920868</a><br>\nI started trying to implement this, but there is a truly massive amount of code in CTFE which relies on pointers/places being Copy :/</p>\n<p>Did you have anything in mind that could make this less painful?</p>",
        "id": 275844482,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1647628208
    },
    {
        "content": "<p>yeah I dont think we want to actually make tags refcounted, TBH...</p>",
        "id": 275844957,
        "sender_full_name": "RalfJ",
        "timestamp": 1647628467
    },
    {
        "content": "<p>The current scheme basically leaks memory. We don't have a way to reclaim memory associated with borrow tags which are inaccessible. Do you have a better idea on how to do that?</p>",
        "id": 275845705,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1647628855
    },
    {
        "content": "<p>I agree that all options are distasteful, but there are a handful of repos I know of whose tests use in excess of 125 GB when checking stacked borrows</p>",
        "id": 275845883,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1647628930
    },
    {
        "content": "<p>is some kind of tracing GC feasible?</p>",
        "id": 275847822,
        "sender_full_name": "RalfJ",
        "timestamp": 1647629918
    },
    {
        "content": "<p>I see your question and I think it is a good one but I will need some time to think about that, if I can even answer it</p>",
        "id": 275852871,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1647632361
    },
    {
        "content": "<p>basically this is a garbage collection problem, and there are other algorithms besides refcounting, and those do allow references to remain <code>Copy</code>, so maybe they are more suited for us here</p>",
        "id": 275853398,
        "sender_full_name": "RalfJ",
        "timestamp": 1647632659
    },
    {
        "content": "<p>I know precious little about GC, but just thinking through this...<br>\nHow do we deal with ptr-int-ptr with tracing? If the ptr is currently in an integer, sure we could deal with that by marking the tags as leaked (somehow). That seems a bit annoying but possible to implement. But what if we leak something like a <code>*mut Vec&lt;u8&gt;</code>? We would have to traverse the pointee, discover that it contains a pointer, and leak that one as well. That sounds like a lot of coupling between SB and CTFE.</p>",
        "id": 275860597,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1647636459
    },
    {
        "content": "<p>My original thought with cleaning up borrow stacks was to to do some sort of GC of <code>Item</code>s in the borrow stacks, because they're only derived from each other. I think that would keep <code>SbTag</code> simple (thus possibly enabling reference counting), what we'd need from CTFE is some kind of hook when a pointer or reference goes away or is leaked, which is starting to sound to me like a similar level of complexity that we need to implement a tracing GC.</p>",
        "id": 275860836,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1647636593
    },
    {
        "content": "<p>The only reason I was interesting in the <code>Rc&lt;SbTag&gt;</code> is that it would be a slick way to add a way for Miri/SB to learn that a pointer has become inaccessible (I want to say dropped, but they aren't Drop).</p>",
        "id": 275861001,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1647636678
    },
    {
        "content": "<p>well, a tracing GC assumes there are roots from which you can recursively find everything</p>",
        "id": 275861419,
        "sender_full_name": "RalfJ",
        "timestamp": 1647636894
    },
    {
        "content": "<p>so worst case for SB, we have to literally go over all the values in the machine everywhere and see which tags are still in use</p>",
        "id": 275861443,
        "sender_full_name": "RalfJ",
        "timestamp": 1647636911
    },
    {
        "content": "<p>that sounds horrible. but I am also no GC expert.^^</p>",
        "id": 275861460,
        "sender_full_name": "RalfJ",
        "timestamp": 1647636920
    },
    {
        "content": "<p>due to ptr-int-ptr roundtrips there is not really such a thing as a pointer \"going away\" for good...</p>",
        "id": 275861585,
        "sender_full_name": "RalfJ",
        "timestamp": 1647636985
    },
    {
        "content": "<p>If it isn't cast to an int, once all copies are dropped it doesn't make sense for the tag (unless it is Untagged) to be a parent tag of any retag, right?</p>",
        "id": 275863005,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1647637737
    },
    {
        "content": "<p>yeah</p>",
        "id": 275863043,
        "sender_full_name": "RalfJ",
        "timestamp": 1647637767
    },
    {
        "content": "<p>but keeping track of all copies is pretty hard</p>",
        "id": 275863069,
        "sender_full_name": "RalfJ",
        "timestamp": 1647637787
    }
]